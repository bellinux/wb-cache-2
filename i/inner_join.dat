41|89|Public
5000|$|The join {{operation}} defined for relational databases {{is often}} referred to as a natural join. In this type of join, two relations are connected by their common attributes. MySQL's approximation of a natural join is the <b>INNER</b> <b>JOIN</b> operator. In SQL, an <b>INNER</b> <b>JOIN</b> prevents a cartesian product from occurring when there are two tables in a query. For each table added to a SQL Query, one additional <b>INNER</b> <b>JOIN</b> is added to prevent a cartesian product. Thus, for N tables in an SQL query, there must be N-1 INNER JOINS to prevent a cartesian product.|$|E
50|$|Any data {{column that}} may be NULL (empty) should never {{be used as a}} link in an <b>inner</b> <b>join,</b> unless the {{intended}} result is to eliminate the rows with the NULL value. If NULL join columns are to be deliberately removed from the result set, an <b>inner</b> <b>join</b> can be faster than an outer join because the table join and filtering is done in a single step. Conversely, an <b>inner</b> <b>join</b> can result in disastrously slow performance or even a server crash when used in a large volume query in combination with database functions in an SQL Where clause. A function in an SQL Where clause can result in the database ignoring relatively compact table indexes. The database may read and <b>inner</b> <b>join</b> the selected columns from both tables before reducing the number of rows using the filter that depends on a calculated value, resulting in a relatively enormous amount of inefficient processing.|$|E
5000|$|The classic hash join {{algorithm}} for an <b>inner</b> <b>join</b> of two relations proceeds as follows: ...|$|E
50|$|One {{can further}} {{classify}} <b>inner</b> <b>joins</b> as equi-joins, as natural joins, or as cross-joins.|$|R
5000|$|The [...] {{statement}} defines how disparate, hierarchical data formats {{are joined}} and {{is comparable to}} <b>inner</b> <b>joins</b> for relational databases.|$|R
5000|$|The above sample query for <b>inner</b> <b>joins</b> can be {{expressed}} as a natural join in the following way:SELECT *FROM employee NATURAL JOIN department; ...|$|R
5000|$|SELECT DISTINCT a FROM Author a <b>INNER</b> <b>JOIN</b> a.books b WHERE b.publisher.name = 'XYZ Press' ...|$|E
5000|$|CREATE VIEW dept_avg AS SELECT department, AVG(salary) AS department_average FROM {{employees}} GROUP BY department; -- List employees {{making more}} than their department average. SELECT employees.employee_number, employees.name FROM employees <b>INNER</b> <b>JOIN</b> dept_avg ON employees.department = dept_avg.department WHERE employees.salary > dept_avg.department_average; -- List employees alongside their respective department averages. SELECT employees.employee_number, employees.name, dept_avg.department_averageGROUP BY department AS temp ON employee.department = temp.department FROM employees <b>INNER</b> <b>JOIN</b> dept_avg ON employees.department = dept_avg.department; DROP VIEW dept_avg; ...|$|E
5000|$|Example of a left {{outer join}} (the '''''' keyword is optional), with the {{additional}} result row (compared with the <b>inner</b> <b>join)</b> italicized: ...|$|E
50|$|A {{commitment}} to SQL code containing <b>inner</b> <b>joins</b> assumes NULL join columns {{will not be}} introduced by future changes, including vendor updates, design changes and bulk processing outside of the application's data validation rules such as data conversions, migrations, bulk imports and merges.|$|R
40|$|Prior work on {{computing}} queries from materialized views {{has focused}} on views defined by expressions consisting of selection, projection, and <b>inner</b> <b>joins,</b> with an optional aggregation on top (SPJG views). This paper provides the first view matching algorithm for views that may also contain outer joins (SPOJG views) ...|$|R
40|$|Prior work on {{computing}} queries from materialized views {{has focused}} on views defined by expressions consisting of selection, projection, and <b>inner</b> <b>joins,</b> with an optional aggregation on top (SPJG views). This paper provides the first view matching algorithm for views that may also contain outer joins (SPOJG views). The algorithm relies on a normal form for SPOJ expressions and does not use bottomup syntactic matching of expressions. It handles any combination of <b>inner</b> and outer <b>joins,</b> deals correctly with SQL bag semantics and exploits not-null constraints, uniqueness constraints and foreign key constraints. ...|$|R
5000|$|SELECT F.EmployeeID, F.LastName, S.EmployeeID, S.LastName, F.CountryFROM Employee F <b>INNER</b> <b>JOIN</b> Employee S ON F.Country = S.CountryWHERE F.EmployeeID < S.EmployeeIDORDER BY F.EmployeeID, S.EmployeeID; ...|$|E
50|$|Every {{constraint}} can {{be viewed}} as a table in a database, where the variables are interpreted as attributes names and the relation is the set of records in the table. The solutions of a constraint satisfaction problem are the result of an <b>inner</b> <b>join</b> of the tables representing its constraints; therefore, the problem of existence of solutions can be reformulated as the problem of checking whether the result of an <b>inner</b> <b>join</b> of a number of tables is empty.|$|E
5000|$|If {{columns in}} an equi-join {{have the same}} name, SQL-92 {{provides}} an optional shorthand notation for expressing equi-joins, {{by way of the}} [...] construct:SELECT *FROM employee <b>INNER</b> <b>JOIN</b> department USING (DepartmentID); ...|$|E
40|$|Most {{existing}} join ordering algorithms {{concentrate on}} join queries with simple <b>join</b> predicates and <b>inner</b> <b>joins</b> only, where simple predicates {{are those that}} involve exactly two relations. However, real queries may contain complex join predicates, i. e. predicates involving more than two relations. We show how to handle complex join predicates efficiently, by modeling the query graph as a hypergraph and reasoning about its connected subgraphs...|$|R
40|$|Joining by {{electromagnetic}} forming is a non-contact assembling {{method that}} is especially suitable for connections in aluminum space frame structures. By reason of increased joint strength along with lower charging energies, form-fit connections are favored over interference-fit connections for this joining process. In contrast to conventional form-fit concepts, {{in which the}} <b>inner</b> <b>joining</b> partner has grooves or pockets, the use of knurled surfaces offers several advantages like easier machinability or the resistance against combined axial and torsional loadings. The objective {{of this paper is}} to identify the influencing geometry and process parameters on the joint strength of tubular joints using mandrels with knurled surfaces, with tube and mandrel being made of the same aluminum alloy AA 6060 -T 6. For that reason, experimental studies were conducted: In addition to pull-out tests to determine the axial strength of joints, first computed tomographic images and, afterwards, micrographs of joined components were produced to analyze the contact zone between tube and mandrel and the deformation behavior of the <b>inner</b> <b>joining</b> partner by non-destructive and destructive means. Based on the detailed knowledge of the influencing variables, guidelines for joint and process design are derived...|$|R
5000|$|Much work in database-systems has {{aimed at}} {{efficient}} implementation of joins, because relational systems commonly call for joins, yet face difficulties in optimising their efficient execution. The problem arises because <b>inner</b> <b>joins</b> operate both commutatively and associatively. In practice, {{this means that}} the user merely supplies the list of tables for joining and the join conditions to use, and the database system has the task of determining {{the most efficient way to}} perform the operation. A query optimizer determines how to execute a query containing joins. A query optimizer has two basic freedoms: ...|$|R
50|$|For simplicity, the {{algorithm}} {{is described in}} the case of an <b>inner</b> <b>join</b> of two relations on a single attribute. Generalization to other join types, more relations and more keys is straightforward.|$|E
5000|$|SELECT t1.EMPLOYEE_ID, [...] t1.LASTNAME || ', ' || t1.FIRSTNAME AS NAME, [...] t2.DEPARTMENT FROM (EMPLOYEES t1 [...] <b>INNER</b> <b>JOIN</b> DEPARTMENTS t2 ON t1.DEPARTMENT_ID = t2.DEPARTMENT_ID) WHERE upper(t1.LASTNAME) LIKE upper('Foo%') [...] AND t1.RETIRED=0 ORDER BY t1.LASTNAME, t1.FIRSTNAME ...|$|E
50|$|An <b>inner</b> <b>join</b> {{requires}} each {{row in the}} two joined {{tables to}} have matching column values, and is a commonly used join operation in applications but should not be assumed {{to be the best}} choice in all situations. <b>Inner</b> <b>join</b> creates a new result table by combining column values of two tables (A and B) based upon the join-predicate. The query compares each row of A with each row of B to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied by matching non-NULL values, column values for each matched pair of rows of A and B are combined into a result row.|$|E
50|$|The {{rim of the}} enamel organ {{where the}} outer and <b>inner</b> enamel {{epithelium}} <b>join</b> is called the cervical loop.|$|R
50|$|Lipopolysaccharides (LPS), {{also known}} as lipoglycans and endotoxins, are large {{molecules}} consisting of a lipid and a polysaccharide composed of O-antigen, outer core and <b>inner</b> core <b>joined</b> by a covalent bond; they {{are found in the}} outer membrane of Gram-negative bacteria, and elicit strong immune responses in animals.|$|R
5000|$|The {{expedition}} {{traveled from}} the mining town of Cailloma by four-wheel drive, then climbed the Apachita Trail and traversed onto Mismi, taking in Kiwicha and Puma Chiri. This is, as McIntyre describes {{it in his}} 1972 National Geographic article, [...] "a semicircle rampart of the continental divide. All that trickles from the <b>inner</b> rim <b>joins</b> to form the Apurimac." ...|$|R
5000|$|The {{effect of}} an outer join {{can also be}} {{obtained}} using a UNION ALL between an <b>INNER</b> <b>JOIN</b> and a SELECT of the rows in the [...] "main" [...] table that do not fulfill the join condition. For example, ...|$|E
5000|$|The cross join {{does not}} itself apply any {{predicate}} to filter rows from the joined table. The {{results of a}} cross join can be filtered by using a [...] clause which may then produce the equivalent of an <b>inner</b> <b>join.</b>|$|E
5000|$|Programmers {{should take}} special care when joining tables on columns that can contain NULL values, since NULL will never match any other value (not even NULL itself), unless the join {{condition}} explicitly uses a combination predicate that first checks that the joins columns are [...] before applying the remaining predicate condition(s). The <b>Inner</b> <b>join</b> can only be safely used in a database that enforces referential integrity or where the join columns are guaranteed not to be NULL. Many transaction processing relational databases rely on Atomicity, Consistency, Isolation, Durability (ACID) data update standards to ensure data integrity, making inner joins an appropriate choice. However transaction databases usually also have desirable join columns that are allowed to be NULL. Many reporting relational database and data warehouses use high volume Extract, Transform, Load (ETL) batch updates which make referential integrity difficult or impossible to enforce, resulting in potentially NULL join columns that a SQL query author cannot modify and which cause inner joins to omit data with no indication of an error. The choice to use an <b>inner</b> <b>join</b> depends on the database design and data characteristics. A left outer join can usually be substituted for an <b>inner</b> <b>join</b> when the join columns in one table may contain NULL values.|$|E
40|$|When we {{integrate}} {{information sources}} that are managed locally, the integrated objects are often semistructured, since {{different sets of}} information sources participate in forming each of the objects. Such integration requires outer join and conversion operators: outer join operators prevent information loss that would be caused by <b>inner</b> <b>joins,</b> and conversion operators are used to mediate the inconsistency among information sources. These operators impose restrictions {{on the order of}} query processing. This paper presents an algorithm for creating a processing plan to integrate information sources without information loss, in the presence of conversion operators. As a framework of our discussion, we use the TSIMMIS mediation system developed at Stanford University. Given a view specification and a query, we create an initial expression graph whose nodes represent query processing units, including outer join and conversion operators. Then, we convert the initial expression graph into an ex [...] ...|$|R
40|$|Large {{enterprises}} {{have been}} relying on parallel database management systems (PDBMS) to process their ever-increasing data volume and complex queries. The scalability {{and performance of}} a PDBMS comes from load balancing on all nodes in the system. Skewed processing will significantly slow down query response time and degrade the overall system performance. Business intelligence tools used by enterprises frequently generate {{a large number of}} outer joins and require high performance from the underlying database systems. Although extensive research has been done on handling skewed processing for <b>inner</b> <b>joins</b> in PDBMS, there is no known research on data skew handling for parallel outer joins. We propose a simple and efficient outer join algorithm called OJSO (Outer Join Skew Optimization) to improve the performance and scalability of parallel outer joins. Our experimental results show that the OJSO algorithm significantly speeds up query elapsed time in the presence of data skew...|$|R
60|$|Without {{saying a}} word more, Jasper Grinder ran from the <b>inner</b> cave and <b>joined</b> Baxter and the guide. His face was pale, and he was evidently much disturbed.|$|R
5000|$|Calculation of the {{disjunctive}} {{shared information}} (DiShIn) without requiring preliminary calculations. It {{assumes that the}} difference {{of the number of}} distinct paths can be estimated on-the-fly by the difference of the number of distinct nodes in the paths. SET @dishin = ( [...] SELECT AVG(dishin.ic) FROM (SELECT MAX(ca_ic.ic) AS ic FROM ( [...] SELECT ca.term_id, ca.diff, -LOG(COUNT(DISTINCT a.gene_product_id)/@maxFreq) AS ic FROM ( [...] SELECT ca.term_id, ABS(ca.ca_t1_number - ca.ca_t2_number) AS diff FROM (SELECT ca.ancestor AS term_id, COUNT(DISTINCT ca_t1_nodes.term2_id) AS ca_t1_number, COUNT(DISTINCT ca_t2_nodes.term2_id) AS ca_t2_number FROM ( [...] SELECT p1.term1_id AS ancestor FROM graph_path p1, graph_path p2 WHERE p1.term2_id = @t1Id AND p2.term2_id = @t2Id AND p1.term1_id = p2.term1_id AND p1.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a') AND p2.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a')) AS ca <b>INNER</b> <b>JOIN</b> graph_path ca_t1_nodes ON (ca.ancestor = ca_t1_nodes.term1_id) <b>INNER</b> <b>JOIN</b> graph_path ca_t2_nodes ON (ca.ancestor = ca_t2_nodes.term1_id) WHERE ca_t1_nodes.term2_id IN ( [...] SELECT p2.term1_id AS ancestor FROM graph_path p2 WHERE p2.term2_id = @t1Id) AND ca_t2_nodes.term2_id IN ( [...] SELECT p2.term1_id AS ancestor FROM graph_path p2 WHERE p2.term2_id = @t2Id) AND ca_t1_nodes.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a') AND ca_t2_nodes.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a') GROUP BY ca.ancestor [...] ) AS ca [...] ) AS ca <b>INNER</b> <b>JOIN</b> graph_path gp ON (ca.term_id = gp.term1_id) <b>INNER</b> <b>JOIN</b> association an ON (gp.term2_id = a.term_id) WHERE a.is_not = 0 AND gp.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a') GROUP BY ca.term_id, ca.diff [...] ) AS ca_ic GROUP BY ca_ic.diff) AS dishin [...] ); Information content normalization to a 0..1 interval SET @maxIC = ( [...] SELECT -LOG(1/@maxFreq) [...] ); SET @t1IC_norm = ( [...] SELECT @t1IC/@maxIC [...] ); SET @t2IC_norm = ( [...] SELECT @t2IC/@maxIC [...] ); SET @dishin_norm = ( [...] SELECT @dishin/@maxIC [...] ); ...|$|E
5000|$|The [...] "explicit join notation" [...] {{uses the}} [...] keyword, {{optionally}} preceded by the [...] keyword, {{to specify the}} table to join, and the [...] keyword to specify the predicates for the join, as in the following example:SELECT employee.LastName, employee.DepartmentID, department.DepartmentName FROM employee <b>INNER</b> <b>JOIN</b> department ONemployee.DepartmentID = department.DepartmentID ...|$|E
5000|$|Calculation of the {{information}} content of input term @t12d SET @t2IC = ( [...] SELECT -LOG(COUNT(DISTINCT a.gene_product_id)/@maxFreq) as ic FROM graph_path gp <b>INNER</b> <b>JOIN</b> association an ON (gp.term2_id = a.term_id) WHERE gp.term1_id = @t1Id AND a.is_not = 0 AND gp.relationship_type_id IN (SELECT id FROM term WHERE name='part_of' OR name='is_a') [...] ); ...|$|E
50|$|He {{was the son}} of W. Dering Addison, of Maidstone. He {{was called}} to the bar on 10 June 1842 by the <b>Inner</b> Temple, <b>joined</b> the home circuit and Kent sessions; he was a {{revising}} barrister for Kent. In 1848 he married Frances Octavia, twelfth child of the Honourable James Wolfe Murray, Lord Cringletie, by whom he left seven children.|$|R
40|$|One of the {{approaches}} for integrating object-oriented programs with databases is to instantiate objects from relational databases by evaluating view queries. In that approach, {{it is often}} necessary to evaluate some joins of the query by left outer joins to prevent information loss caused by the tuples discarded by <b>inner</b> <b>joins.</b> It is also necessary to filter some relations with selection conditions to prevent the retrieval of unwanted nulls. The system should automatically prescribe <b>joins</b> as <b>inner</b> or left outer joins and generate the filters, rather than letting them be specified manually for every view definition. We develop such a mechanism in this paper. We first develop a rigorous system model to facilitate the mapping between an object-oriented model and the relational model. The system model provides a well-defined context for developing a simple mechanism. The mechanism requires only one piece of information from users: null options on an object attribute. The semantics of these [...] ...|$|R
40|$|This paper {{presents}} an active database discrimination network algorithm called Gator, and its implementation in {{a modified version}} of the Ariel active DBMS. Gator is a generalization of the widely known Rete and TREAT algorithms. Gator pattern matching is explained, and it is shown how a discrimination network can speed up condition testing for multi-table triggers. The structure of a Gator network optimizer is described. This optimizer can choose an efficient Gator network for testing the conditions of a set of triggers, given information about the structure of the triggers, database size, attribute cardinality, and update frequency distribution. The optimizer uses a randomized strategy to deal with the problem of a large search space. The results show that optimal Gator networks normally have a shape which neither pure Rete nor pure TREAT, but an intermediate form where one or a few <b>inner</b> <b>joins</b> (fi nodes) are materialized. In addition, this study shows that it is indeed feasible to o [...] ...|$|R
