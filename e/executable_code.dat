1129|388|Public
5|$|A {{memory dump}} of Mini vMac can be {{obtained}} with Linux ckpt or a similar tool after the Agrippa program has been loaded. The <b>executable</b> <b>code</b> could be reverse engineered.|$|E
25|$|Visual Studio {{features}} background compilation (also called incremental compilation). As code {{is being}} written, Visual Studio compiles {{it in the}} background {{in order to provide}} feedback about syntax and compilation errors, which are flagged with a red wavy underline. Warnings are marked with a green underline. Background compilation does not generate <b>executable</b> <b>code,</b> since it requires a different compiler than the one used to generate <b>executable</b> <b>code.</b> Background compilation was initially introduced with Microsoft Visual Basic but has now been expanded for all included languages.|$|E
25|$|The {{original}} {{reason for}} the use of one-pass assemblers was speed of assembly – often a second pass would require rewinding and rereading the program source on tape or rereading a deck of cards or punched paper tape. Later computers with much larger memories (especially disc storage), had the space to perform all necessary processing without such re-reading. The advantage of the multi-pass assembler is that the absence of errata makes the linking process (or the program load if the assembler directly produces <b>executable</b> <b>code)</b> faster.|$|E
40|$|Recently Active Networks were {{proposed}} as {{the approach that}} will enable quick introduction of new services in the current telecommunication infrastructure. This approach allows third party <b>executable</b> <b>codes</b> (proxylet) to be deployed into the network, which creates a big security risk. In this paper we present the application of Bayesian technology {{in the development of}} an anomaly detection system for proxylets. This system will be incorporated into our Intrusion Detection System (IDS) that will provide runtime security to ensure active platform integrity is maintained while running third party <b>executable</b> <b>codes...</b>|$|R
5000|$|... "The <b>Executable</b> Object <b>Code</b> {{satisfies}} the software requirements." ...|$|R
5000|$|An {{image of}} the <b>executable</b> machine <b>code</b> {{associated}} with a program.|$|R
25|$|In 2007, v6-MiniPerl6 ("mp6") and its reimplementation, v6-KindaPerl6 ("kp6") {{were written}} {{as a means}} to {{bootstrap}} the Perl-6.0.0 STD, using Perl 5. The STD is a full grammar for Perl 6 and is written in Perl 6. In theory, anything capable of parsing the STD and generating <b>executable</b> <b>code</b> is a suitable bootstrapping system for Perl 6. kp6 is currently compiled by mp6 and can work with multiple backends. mp6 and kp6 are not full Perl 6 implementations and are designed only to implement the minimum featureset required to bootstrap a full Perl 6 compiler.|$|E
25|$|Buffers {{are areas}} of memory {{set aside to}} hold data, often while moving it from one section of a program to another, or between programs. Buffer {{overflows}} can often be triggered by malformed inputs; if one assumes all inputs will be smaller than a certain size and the buffer is created to be that size, then an anomalous transaction that produces more data could cause it to write past {{the end of the}} buffer. If this overwrites adjacent data or <b>executable</b> <b>code,</b> this may result in erratic program behavior, including memory access errors, incorrect results, and crashes.|$|E
25|$|Exploiting the {{behavior}} of a buffer overflow is a well-known security exploit. On many systems, the memory layout of a program, or the system as a whole, is well defined. By sending in data designed to cause a buffer overflow, it is possible to write into areas known to hold <b>executable</b> <b>code,</b> and replace it with malicious code. Buffers are widespread in operating system (OS) code, so it is possible to make attacks that perform privilege escalation and gain unlimited access to the computer's resources. The famed Morris worm used this as one of its attack techniques.|$|E
5000|$|<b>Executable</b> e <b>code</b> is {{enclosed}} within code-segment markers <' and '>: ...|$|R
50|$|A Macro Assembler for {{translating}} {{assembly language}} programs into <b>executable</b> machine <b>code.</b>|$|R
5000|$|C code {{generation}} - Generates <b>executable</b> C <b>code</b> {{directly from}} the block diagram ...|$|R
25|$|A {{workflow}} is {{a series}} of processing steps connected together so that the output of one step is used as the input of another. Processing steps implement data analysis tasks such as data importing, statistical tests and report generation. In Anduril, processing steps are implemented using components, which are reusable <b>executable</b> <b>code</b> that can be written in any programming language. Components are wired together into a workflow, or a component network, that is executed by the Anduril workflow engine. Workflow configuration is done using a simple yet powerful scripting language, AndurilScript. Workflow configuration and execution can be done from Eclipse, a popular multipurpose GUI, or from the command line.|$|E
25|$|Assembly {{language}} is still taught in most computer science and electronic engineering programs. Although few programmers today regularly work with assembly {{language as a}} tool, the underlying concepts remain very important. Such fundamental topics as binary arithmetic, memory allocation, stack processing, character set encoding, interrupt processing, and compiler design {{would be hard to}} study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly {{language is}} sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient <b>executable</b> <b>code</b> can be created from high-level languages. This is analogous to children needing to learn the basic arithmetic operations (e.g., long division), although calculators are widely used for all except the most trivial calculations.|$|E
25|$|Stuxnet {{attacked}} Windows systems {{using an}} unprecedented four zero-day attacks (plus the CPLINK vulnerability and a vulnerability {{used by the}} Conficker worm). It is initially spread using infected removable drives such as USB flash drives, which contain Windows shortcut files to initiate <b>executable</b> <b>code.</b> The worm then uses other exploits and techniques such as peer-to-peer RPC to infect and update other computers inside private networks that are not directly connected to the Internet. The number of zero-day exploits used is unusual, as they are highly valued and malware creators do not typically make use of (and thus simultaneously make visible) four different zero-day exploits in the same worm. Amongst these exploits were remote code execution on a computer with Printer Sharing enabled, and the LNK/PIF vulnerability, in which file execution is accomplished when an icon is viewed in Windows Explorer; negating the need for user interaction. Stuxnet is unusually large at half a megabyte in size, and written in several different programming languages (including C and C++) which is also irregular for malware. The Windows component of the malware is promiscuous in that it spreads relatively quickly and indiscriminately.|$|E
5000|$|... 12. 20090112566 AUTOMATED GENERATION OF <b>EXECUTABLE</b> DEPLOYMENT <b>CODE</b> FROM A DEPLOYMENT ACTIVITY MODEL 04-30-2009 ...|$|R
40|$|An {{approach}} {{to the problem of}} translation of algebraic programs into <b>executable</b> <b>codes</b> is presented. In particular, an algorithm for translation of algebraic programs represented in the language Aplan into C codes is proposed. An algorithm of reconstruction of types in Aplan is considered that also checks the absence of features used for dynamic specification of procedures in a code...|$|R
50|$|The Extended Common Object File Format (ECOFF) is a {{file format}} for <b>executables,</b> object <b>code,</b> and shared libraries.|$|R
500|$|Other {{programs}} that undertake to parse Perl, such as source-code analyzers and auto-indenters, {{have to contend}} not only with ambiguous syntactic constructs {{but also with the}} undecidability of Perl parsing in the general case. Adam Kennedy's PPI project focused on parsing Perl code as a document (retaining its integrity as a document), instead of parsing Perl as <b>executable</b> <b>code</b> (that not even Perl itself can always do). It was Kennedy who first conjectured that [...] "parsing Perl suffers from the 'halting problem'", which was later proved.|$|E
500|$|After {{the release}} of the Sega Genesis in 1989, video game {{publisher}} Accolade began exploring options to release some of their PC game titles onto the console. At the time, Sega had a licensing deal in place for third-party developers that increased the costs to the developer. According to Accolade co-founder Alan Miller, [...] "One pays them between $10 and $15 per cartridge on top of the real hardware manufacturing costs, so it about doubles the cost of goods to the independent publisher." [...] To get around licensing, Accolade chose to seek an alternative way to bring their games to the Genesis. [...] It did so by purchasing one in order to decompile the <b>executable</b> <b>code</b> of three Genesis games. [...] Such information was used to program their new Genesis cartridges {{in a way that would}} allow them to disable the security lockouts on the Genesis that prevented unlicensed games from being able to be played. [...] This strategy was used successfully to bring [...] to the Genesis in 1990. [...] To do so, Accolade had copied Sega's copyrighted game code multiple times in order to reverse engineer the software of Sega's licensed Genesis games.|$|E
500|$|After {{the release}} of the Sega Genesis in 1989, video game {{publisher}} Accolade began exploring options to release some of their PC game titles onto the console. [...] At the time, however, Sega had a licensing deal in place for third-party developers that increased the costs to the developer. [...] According to Accolade co-founder Alan Miller, [...] "One pays them between $10 and $15 per cartridge on top of the real hardware manufacturing costs, so it about doubles the cost of goods to the independent publisher." [...] In addition to this, Sega required that it would be the exclusive publisher of Accolade's games if Accolade were to be licensed, preventing Accolade from releasing its games to other systems. [...] To get around licensing, Accolade chose to seek an alternative way to bring their games to the Genesis by purchasing a console in order to decompile the <b>executable</b> <b>code</b> of three Genesis games and use it to program their new cartridges {{in a way that would}} allow them to disable the security lockouts that prevented playing of unlicensed games. This was done successfully to bring [...] to the Genesis in 1990. [...] In doing so, Accolade had also copied Sega's copyrighted game code multiple times in order to reverse engineer the software of Sega's licensed Genesis games.|$|E
5000|$|Parameter Data Item Files - Provides {{separate}} {{information that}} influences {{the behavior of}} an <b>executable</b> object <b>code</b> (without changing it). An example would be a configuration file that sets up the schedule and major time frames of a partitioned operating system. The parameter data item file must be verified together with the <b>executable</b> object <b>code,</b> or else it must be tested for all possible ranges of the parameter data items.|$|R
50|$|Traceability from system {{requirements}} to all source <b>code</b> or <b>executable</b> object <b>code</b> is typically required (depending on software level).|$|R
5000|$|... "The <b>Executable</b> Object <b>Code</b> {{satisfies}} the software requirements (that is, intended function), and provides {{confidence in the}} absence of unintended functionality." ...|$|R
2500|$|Devices {{may have}} an {{on-board}} ROM containing <b>executable</b> <b>code</b> for x86 or PA-RISC processors, an Open Firmware driver, or an EFI driver. [...] These are typically necessary for devices used during system startup, before device drivers are loaded by the operating system.|$|E
2500|$|This example shows a {{specification}} in readable language {{embedded in}} <b>executable</b> <b>code.</b> In {{this case a}} choice of the tool is to formalize the specification language into {{the language of the}} test code by adding methods named it and should. Also there is the concept of a specification precondition [...] the before section establishes the preconditions that the specification is based on.|$|E
2500|$|Compilers {{are used}} to {{translate}} source code from a programming language into either object code or machine code. [...] Object code needs further processing to become machine code, and machine code consists of the central processing unit's native instructions, ready for execution. Compiled computer programs are {{commonly referred to as}} executables, binary images, or simply as binaries– a reference to the binary file format used to store the <b>executable</b> <b>code.</b>|$|E
5000|$|... "The <b>Executable</b> Object <b>Code</b> is robust {{with respect}} to the {{software}} requirements that it can respond correctly to abnormal inputs and conditions." ...|$|R
50|$|All {{practical}} programs {{today are}} written in higher-level languages or assembly language. The source code is then translated to <b>executable</b> machine <b>code</b> by utilities such as compilers, assemblers, and linkers, with the important exception of interpreted programs, which are not translated into machine code. However, the interpreter itself, which {{may be seen as}} an executor or processor, performing the instructions of the source code, typically consists of directly <b>executable</b> machine <b>code</b> (generated from assembly or high-level language source code).|$|R
5000|$|Practically all <b>executable</b> {{threaded}} <b>code</b> uses one {{or another}} of these methods for invoking subroutines (each method is called a [...] "threading model").|$|R
2500|$|When an {{application}} is first launched, the [...]NET Framework compiles the CIL code into <b>executable</b> <b>code</b> using its just-in-time compiler, and caches the executable program into the [...]NET Native Image Cache. Due to caching, the application launches faster for subsequent launches, although the first launch is usually slower. To {{speed up the}} first launch, developers may use the Native Image Generator utility to manually ahead-of-time compile and cache any [...]NET application.|$|E
2500|$|Symbolic {{assemblers}} let programmers associate arbitrary names (labels or symbols) with memory {{locations and}} various constants. Usually, every constant and variable {{is given a}} name so instructions can reference those locations by name, thus promoting self-documenting code. In <b>executable</b> <b>code,</b> the name of each subroutine is associated with its entry point, so any calls to a subroutine can use its name. Inside subroutines, GOTO destinations are given labels. Some assemblers support local symbols which are lexically distinct from normal symbols (e.g., the use of [...] "10$" [...] as a GOTO destination).|$|E
50|$|Apache Jelly, a {{tool for}} turning XML into <b>executable</b> <b>code.</b>|$|E
40|$|This paper {{presents}} a model integrated framework, {{referred to as}} the Automatic Control Modeling Environment (ACME), to facilitate the use of control-based technology for selfmanagement in computation systems,. ACME is a domainspecific graphical modeling environment with automated synthesis tools. The framework allows domain engineers to develop models for general computation systems and to capture their performance requirements and operational constraints. The framework can automatically generates <b>executable</b> <b>codes</b> for the controllers based on the given system model and specifications. A case study of an online power management is used to demonstrate the application of ACME...|$|R
40|$|To perform service composition, {{mismatches}} {{are challenging}} obstacles {{due to the}} decentralization and independent development of services. Mediation, as a promising solution, attracts most attentions. And pattern based mediation proposed a modularly constructive thoughtway: Basic mediator patterns were created and sufficient for advanced mediators against all possible mismatches. The pattern structure is illustrated in this paper. And construction rules for each pattern are presented. <b>Executable</b> <b>codes</b> such as BPEL codes can be automatically generated from these rules. As a systematic engineering solution, its feasibility is validated through {{a case study in}} the end...|$|R
50|$|Bytecode Targets produce <b>executable</b> byte <b>code</b> (Neko, SWF, SWF8), {{that can}} be {{executed}} directly by the runtime (Neko VM, Adobe Flash Player, Adobe AIR). Haxe API and platform-specific API is available.|$|R
