207|165|Public
25|$|Objective-J, a superset of JavaScript that compiles to {{standard}} JavaScript. It adds traditional inheritance and Smalltalk/Objective-C style <b>dynamic</b> <b>dispatch</b> and optional pseudo-static typing to JavaScript.|$|E
25|$|Dynamic type {{checking}} is {{the process}} of verifying the type safety of a program at runtime. Implementations of dynamically type-checked languages generally associate each runtime object with a type tag (i.e., a reference to a type) containing its type information. This runtime type information (RTTI) {{can also be used to}} implement <b>dynamic</b> <b>dispatch,</b> late binding, downcasting, reflection, and similar features.|$|E
25|$|Ordinarily, when a {{function}} in a derived class overrides {{a function}} in a base class, the function to call {{is determined by the}} type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called <b>dynamic</b> <b>dispatch.</b> Virtual member functions or methods allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using virtual function tables. If the object type is known, this may be bypassed by prepending a fully qualified class name before the function call, but in general calls to virtual functions are resolved at run time.|$|E
40|$|We {{propose a}} <b>dynamic</b> <b>dispatching</b> rule for {{semiconductor}} assembly production line {{based on the}} current mainstream <b>dynamic</b> <b>dispatching</b> rules. In particular, our dispatching rule considers batch dispatching. Evaluated through simulation, we confirmed {{the effectiveness of this}} dispatching rule and provided additional operational insights for actual production system...|$|R
40|$|Fortran 90 is a modern, {{powerful}} {{language with}} features that support important new programming concepts, including {{those used in}} object-oriented programming. This paper briefly summarizes how to express the concepts of data encapsulation, function overloading, classes, objects, inheritance, and <b>dynamic</b> <b>dispatching.</b> 1 I...|$|R
40|$|In {{programming}} we {{some times}} need {{to choose between}} several implementations of the same functionality based on the run-time types of several arguments. This is called <b>Dynamic</b> Multiple <b>Dispatch.</b> One example of <b>Dynamic</b> Multiple <b>Dispatch</b> is the geom-etry dispatcher in OpenTissue, which takes a pair of geometry objects and selects a collision-detection function based on the objects type. Unfortunately C++ does not support <b>Dynamic</b> Multiple <b>Dispatch</b> natively, and the previous implementation of the geometry dispatcher used static type enumeration, a static function lookup table and conversion through void pointers. In this project I have explored two methods for approximat-ing <b>dynamic</b> multiple <b>dispatch</b> in C++ and I have compared their flexibility, limits and performance. Finally I have implemented the best suitable method in OpenTissue and compared it against the previous implementation...|$|R
2500|$|Apple {{intended}} Swift {{to support}} many core concepts associated with Objective-C, notably <b>dynamic</b> <b>dispatch,</b> widespread late binding, extensible programming and similar features, but [...] "safer" [...] (easier to catch software bugs); Swift has features addressing some common programming errors like null pointers and provides syntactic sugar to help avoid the pyramid of doom. Swift supports {{the concept of}} protocol extensibility, an extensibility system {{that can be applied}} to types, structs and classes, which Apple promotes as a real change in programming paradigms they term [...] "protocol-oriented programming" [...] (similar to traits).|$|E
2500|$|Ruby is object-oriented: every {{value is}} an object, {{including}} classes and instances of types {{that many other}} languages designate as primitives (such as integers, booleans, and [...] "null"). Variables always hold references to objects. Every function is a method and methods are always called on an object. Methods defined at the top level scope become methods of the Object class. Since this class is an ancestor of every other class, such methods can be called on any object. They are also visible in all scopes, effectively serving as [...] "global" [...] procedures. Ruby supports inheritance with <b>dynamic</b> <b>dispatch,</b> [...] mixins and singleton methods (belonging to, and defined for, a single instance rather than being defined on the class). Though Ruby does not support multiple inheritance, classes can import modules as mixins.|$|E
2500|$|Lisp deeply {{influenced}} Alan Kay, {{the leader}} of the research team that developed Smalltalk at Xerox PARC; and in turn Lisp was influenced by Smalltalk, with later dialects adopting object-oriented programming features (inheritance classes, encapsulating instances, message passing, etc.) in the 1970s. [...] The Flavors object system introduced the concept of multiple inheritance and the mixin. The Common Lisp Object System provides multiple inheritance, multimethods with multiple dispatch, and first-class generic functions, yielding a flexible and powerful form of <b>dynamic</b> <b>dispatch.</b> It has served as the template for many subsequent Lisp (including Scheme) object systems, which are often implemented via a metaobject protocol, a reflective metacircular design in which the object system is defined in terms of itself: Lisp was only the second language after Smalltalk (and {{is still one of the}} very few languages) to possess such a metaobject system. Many years later, Alan Kay suggested that as a result of the confluence of these features, only Smalltalk and Lisp could be regarded as properly conceived object-oriented programming systems.|$|E
40|$|The runtime {{performance}} of object-oriented languages often suffers {{due to the}} overhead of <b>dynamic</b> <b>dispatching.</b> In order to make these languages competitive with traditional languages, optimizing compilers attempt to eliminate {{as many of the}} <b>dynamic</b> <b>dispatches</b> as possible. A variety of local and intraprocedural techniques have been developed to do this, but they can be ineffective when they are unable to statically bind and inline a message send. To enable better analysis across noninlined message sends, interprocedural analysis is required. In this paper we describe a simple algorithm for interprocedural class analysis and empirically evaluate its effectiveness as a tool for program optimization. We demonstrate that interprocedural class analysis can substantially decrease application execution times when compared to applications optimized with only intraprocedural techniques. * 1 Introduction Applications written in object-oriented languages often perform poorly when compared to equ [...] ...|$|R
40|$|Abstract- This paper {{proposes a}} novel {{methodology}} of Constraint evolutionary programming for solving <b>dynamic</b> economic <b>dispatch.</b> <b>Dynamic</b> Economic <b>Dispatch</b> {{is one of}} the main functions of power generation operation and control. It determines the optimal settings of generator units with predicted load demand over a certain period of time. The objective is to operate an electric power system most economically while the system is operating within its security limits. Ten units test system with smooth and non-smooth fuel cost functions are considered to illustrate the suitability and effectiveness of the proposed method...|$|R
40|$|Some of the {{benefits}} of object-oriented programming such as extensibility and reusability are fundamentally based on inheritance and late binding. <b>Dynamic</b> <b>dispatching</b> is not only time consuming but it also prevents the usage of some optimization techniques such as inlining or interprocedural analysis. The situation is even more severe for languages supporting multi-methods, where dispatching is not only performed based on the type of the receiver, but also based on the types of the arguments. The most efficient way to perform <b>dynamic</b> <b>dispatching</b> is to avoid it as often as possible, without restricting the use of multi-methods. In this paper it is shown how this goal can be achieved through static analysis. We present a technique which discards all method calls which can be statically bound. Furthermore, even if a method cannot be statically bound, we derive information which will at run time speed up the dispatching process considerably. on leave from: FH Wiesbaden, Fachbereich Infor [...] ...|$|R
50|$|A {{language}} may {{be implemented}} with different <b>dynamic</b> <b>dispatch</b> mechanisms. The choices of the <b>dynamic</b> <b>dispatch</b> mechanism {{offered by a}} language {{to a large extent}} alter the programming paradigms that are available or are most natural to use within a given language.|$|E
50|$|<b>Dynamic</b> <b>dispatch</b> is {{different}} from late binding (also known as dynamic binding). In the context of selecting an operation, binding associates a name to an operation. Dispatching chooses an implementation for the operation after you have decided which operation a name refers to. With <b>dynamic</b> <b>dispatch,</b> the name may be bound to a polymorphic operation at compile time, but the implementation not be chosen until run time. While <b>dynamic</b> <b>dispatch</b> does not imply late binding, late binding does imply dynamic dispatching since the binding is what determines the set of available dispatches.|$|E
5000|$|C {{does not}} have <b>dynamic</b> <b>dispatch,</b> {{so it must be}} {{implemented}} manually in some form. Often an enum is used to identify the subtype of an object. <b>Dynamic</b> <b>dispatch</b> can be done by looking up this value in a function pointer branch table. Here is a simple example in C: ...|$|E
40|$|In this paper, an {{algorithm}} inspired on {{the immune}} system is presented, IA DED stands for Immune Algorithm <b>Dynamic</b> Economic <b>Dispatch,</b> {{it is used to}} solve the <b>Dynamic</b> Economic <b>Dispatch</b> problem. IA DED uses as differentiation process a redistribution power operator and the output power are integer values. The proposed approach is val- idated using three problems taken from the specialized literature. Our results are compared with respect to those obtained by several other approaches. XVII Workshop Agentes y Sistemas Inteligentes (WASI) ...|$|R
40|$|Abstract. Cost {{analysis}} of Java bytecode {{is complicated by}} its unstructured control flow, {{the use of an}} operand stack and its object-oriented programming features (like <b>dynamic</b> <b>dispatching).</b> This paper addresses these problems and develops a generic framework for the automatic cost {{analysis of}} sequential Java bytecode. Our method generates cost relations which define at compile-time the cost of programs as a function of their input data size. To the best of our knowledge, this is the first approach to the automatic cost analysis of Java bytecode. ...|$|R
40|$|Conventional {{specifications}} for object-oriented (OO) programs must adhere to behavioral subtyping {{in support of}} class inheritance and method overriding. However, this requirement may cause loss of precision and modularity during program reasoning. To overcome these two problems we advocate {{a new approach to}} OO veri cation that focuses on multiple specifications (for static and <b>dynamic</b> <b>dispatches)</b> and an enhanced specification subsumption that can help avoid re-verification. We have implemented a prototype verifier for a simple OO language and have successfully validated our new approach for a set of small programs...|$|R
50|$|<b>Dynamic</b> <b>dispatch</b> {{contrasts}} with static dispatch, {{in which the}} implementation of a polymorphic operation is selected at compile-time. The purpose of <b>dynamic</b> <b>dispatch</b> is to support cases where the appropriate implementation of a polymorphic operation cannot be determined at compile time because it depends on the runtime type of one or more actual parameters to the operation.|$|E
5000|$|The fragile {{base class}} {{problem has been}} blamed on open {{recursion}} (<b>dynamic</b> <b>dispatch</b> of methods on [...] ), with the suggestion that invoking methods on [...] default to closed recursion (static dispatch, early binding) rather than open recursion (<b>dynamic</b> <b>dispatch,</b> late binding), only using open recursion when it is specifically requested; external calls (not using [...] ) would be dynamically dispatched as usual.|$|E
50|$|<b>Dynamic</b> <b>dispatch</b> is only done via {{procedures}} in Figures module {{that is the}} generic module.|$|E
50|$|The {{main current}} {{implementation}} is OCaml, which added class inheritance and <b>dynamic</b> method <b>dispatch</b> to Caml the Categorical Abstract Machine Language, {{these are a}} variants of MetaLanguage ML notable for type-inference.|$|R
40|$|Abstract. Based on the {{analyzing}} of {{the characteristics}} of a Body-In-White pressing production process a pressing workshop production management system has been given {{in order to make the}} ERP production scheduling more executable. The detailed function model of it such as task assignment, quality control, mold maintenance and production scheduling has been thoroughly discussed. In order to make the production line capability balance the task dispatching algorithm has been given and the <b>dynamic</b> <b>dispatching</b> and controlling process has been explained. This system can be integrated with the upper ERP/CAPP/PDM system which can improve the information level of a company...|$|R
40|$|This paper {{focuses on}} bed {{resources}} allocation {{in a hospital}} taking into account hospitalization demands, bed capacity, and Activity-Dependent Price (T 2 A) incomes. The data used in this research work combines the elective patient flow and the acute patient flow from emergency department. A mathematical model based on a <b>dynamic</b> <b>dispatching</b> approach is developed and experimented respectively with Lingo and Cplex. Our objective is to maximize the incomes based on T 2 A and to minimize the cost to use supplementary beds. As {{a result of this}} model, the bed allocation planning calculated from the best objective value is presented...|$|R
50|$|<b>Dynamic</b> <b>dispatch</b> {{will always}} incur an {{overhead}} so some languages offer static dispatch for particular methods.|$|E
5000|$|... late-binding (i.e. <b>dynamic</b> <b>dispatch</b> to CLR, DLR, and COM objects) on values statically typed as Object.|$|E
5000|$|... {{abstract}} {{data types}} (which have existential types) allow {{the definition of}} modules but these do not support <b>dynamic</b> <b>dispatch</b> ...|$|E
40|$|International audienceThis paper {{focuses on}} bed {{resources}} allocation in hospital {{taking into account}} hospitalization demands, bed capacity, and “Tarification à l’Activité” (T 2 A) incomes. The data used in this research work combine the elective patient flow and the acute patient flow from emergency department. A mathematical model based on a <b>dynamic</b> <b>dispatching</b> approach is developed and experimented respectively with two mathematical optimization solvers, Lingo and Cplex. Our objective is to maximize the incomes based on T 2 A and to minimize the cost to use supplementary beds. As {{a result of this}} model, the bed allocation planning calculated from the best objective value is presented...|$|R
40|$|AbstractThis study {{explores the}} {{challenge}} of the <b>dynamic</b> <b>dispatching</b> of taxis to the immediate passenger booking requests. In particular, the study leverages on a stable marriage assignment algorithm and applies it for dispatching taxis to passengers. The stable marriage algorithm was developed initially for matching men and women according to their preferences in polynomial time. The results of the custom built simulation model show that the taxi dispatching strategy based on the stable marriage matching improves the taxi operation performance in all observed indicators (taxi profit, number of served passengers, not-occupied and total taxi mileage and passenger waiting time) as compared to the standard first-come, first-served strategy...|$|R
40|$|This {{dissertation}} {{examines the}} use of whole-program optimization {{as a way of}} improving the performance of object-oriented programming languages. Although object-oriented programming conveys a number of software engineering benefits, heavy application of its trademark feature, <b>dynamic</b> <b>dispatching,</b> imposes severe performance penalties when programs are compiled using traditional compilation techniques. Several new techniques that rely on whole-program optimization are described, and these techniques substantially improve the performance of object-oriented programs written in Cecil, Java, C++, and Modula- 3. Among the new techniques is class hierarchy analysis, which provides the compiler with knowledge of the class hierarchy of the entire program. This is an especially important optimization, becaus [...] ...|$|R
5000|$|New Visual Basic [...]NET and C# {{language}} features, such as implicit line continuations, <b>dynamic</b> <b>dispatch,</b> named parameters, and optional parameters ...|$|E
50|$|Although <b>dynamic</b> <b>dispatch</b> is {{not usually}} {{classified}} as a conditional construct, it {{is another way to}} select between alternatives at runtime.|$|E
50|$|The C++ {{standards}} do not mandate {{exactly how}} <b>dynamic</b> <b>dispatch</b> must be implemented, but compilers generally use minor {{variations on the}} same basic model.|$|E
40|$|This paper {{describes}} Lua, {{a language}} for extending applications. Lua combines procedural features with powerful data description facilities, {{by using a}} simple, yet powerful, mechanism of tables. This mechanism implements the concepts of records, arrays, and recursive data types (pointers), and adds some object-oriented facilities, such as methods with <b>dynamic</b> <b>dispatching.</b> Lua presents a mechanism of fallbacks that allows programmers to extend the semantics of the language in some unconventional ways. As a noteworthy example, fallbacks allow the user to add different kinds of inheritance to the language. Currently, Lua is being extensively used in production for several tasks, including user configuration, general-purpose data-entry, description of user interfaces, and storage of structured graphical metafiles...|$|R
40|$|The {{automated}} warehouse considered here {{consists of}} a number of rack locations with three cranes, a narrow aisle shuttle, and several buffer stations with the roller. Based on analyzing of the behaviors of the active resources in the system, a modular and computerized model is presented via a colored timed Petri net approach, in which places are multicolored to simplify model and characterize control flow of the resources, and token colors are defined as the routes of storage/retrieval operations. In addition, an approach for realization of model via visual c++ is briefly given. These facts allow us to render an emulate system to simulate a discrete control application for on-line monitoring, <b>dynamic</b> <b>dispatching</b> control and off-line revising scheduler policies...|$|R
50|$|The {{message is}} the most {{fundamental}} language construct in Smalltalk. Even control structures are implemented as message sends. Smalltalk adopts by default a synchronous, single <b>dynamic</b> message <b>dispatch</b> strategy (as contrasted to the asynchronous, multiple dispatch strategy adopted by some other object-oriented languages).|$|R
