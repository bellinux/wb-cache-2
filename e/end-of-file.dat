45|0|Public
25|$|And the %%EOF <b>end-of-file</b> marker.|$|E
25|$|When {{opened by}} a text editor, human-readable content is {{presented}} to the user. This often consists of the file's plain text visible to the user. Depending on the application, control codes may be rendered either as literal instructions acted upon by the editor, or as visible escape characters that can be edited as plain text. Though there may be plain text in a text file, control characters within the file (especially the <b>end-of-file</b> character) can render the plain text unseen by a particular method.|$|E
25|$|Even before 1 January 2000 arrived, {{there were}} also some worries about 9 September 1999 (albeit less than those {{generated}} by Y2K). Because this date could also be written in the numeric format 9/9/99, it could have conflicted with the date value 9999, frequently used to specify an unknown date. It was thus possible that database programs might act on the records containing unknown dates on that day. Data entry operators commonly entered 9999 into required fields for an unknown future date, (e.g., a termination date for cable television or telephone service), in order to process computer forms using CICS software. Somewhat similar to this is the <b>end-of-file</b> code 9999, used in older programming languages. While fears arose that some programs might unexpectedly terminate on that date, the bug {{was more likely to}} confuse computer operators than machines.|$|E
2500|$|Similar {{procedures}} are provided for input. R5RS Scheme provides the predicates input-port? and output-port?. [...] For character input and output, write-char, read-char, peek-char and char-ready? are provided. [...] For writing and reading Scheme expressions, Scheme provides read and write. [...] On a read operation, the result returned is the <b>end-of-file</b> object if the input port {{has reached the}} end of the file, and this can be tested using the predicate eof-object?.|$|E
2500|$|A {{text file}} (sometimes spelled [...] "textfile"; an old {{alternative}} name is [...] "flatfile") {{is a kind}} of computer file that is structured as a sequence of lines of electronic text. [...] A text file exists stored as data within a computer file system. [...] The end of a text file is often denoted by placing one or more special characters, known as an <b>end-of-file</b> marker, after the last line in a text file. Such markers were required under the CP/M and MS-DOS operating systems. On modern operating systems such as Windows and Unix-like systems, text files do not contain any special EOF character.|$|E
5000|$|EOF: — {{input device}} that {{produced}} <b>end-of-file</b> characters, ASCII 0x1A ...|$|E
5000|$|... !hello out:"hello world" [...] return [...] !hello2 out:"hello world again" [...] exit [...] (<b>end-of-file</b> marker) ...|$|E
5000|$|This example shows a {{file that}} has four data records {{followed}} by an <b>end-of-file</b> record: ...|$|E
5000|$|... accepts and {{discards}} all input; produces no output (always returns an <b>end-of-file</b> indication on a read) ...|$|E
5000|$|...DUMMY* {{all data}} written is {{discarded}} and all reads return an <b>End-of-File</b> (much like /dev/null for UNIX); and ...|$|E
5000|$|DO UNTIL (<b>End-of-File)</b> IF new-zipcode <> current-zipcode display_tally(current-zipcode, zipcount) [...] current-zipcode = new-zipcode zipcount = 0 ENDIF [...] zipcount++ LOOP ...|$|E
50|$|In Unix the <b>end-of-file</b> {{character}} (by default EOT) {{causes the}} terminal driver {{to make available}} all characters in its input buffer immediately; normally the driver would collect characters until it sees an end-of-line character. If the input buffer is empty (because no characters have been typed since the last end-of-line or <b>end-of-file),</b> a program reading from the terminal reads a count of zero bytes. In Unix, such a condition is understood as having {{reached the end of}} the file.|$|E
50|$|In computing, <b>end-of-file</b> (commonly {{abbreviated}} EOF) is {{a condition}} in a computer operating system where no more data can be read from a data source. The data source is usually called a file or stream.|$|E
5000|$|Stream mode: Data is sent as a {{continuous}} stream, relieving FTP from doing any processing. Rather, all processing is left up to TCP. No <b>End-of-file</b> indicator is needed, unless the data is divided into records.|$|E
50|$|A {{database}} (.DBF) file {{is composed}} of a header, data records, deletion flags, and an <b>end-of-file</b> marker. The header contains information about the file structure, and the records contain the actual data. One byte of each record is reserved for the deletion flag.|$|E
5000|$|The {{behavior}} of the [...] "" [...] command when an <b>end-of-file</b> condition has been encountered varies. Some implementations set the cell at the pointer to 0, some set it to the C constant EOF (in practice this is usually -1), some leave the cell's value unchanged. There is no real consensus; arguments for the three behaviors are as follows.|$|E
5000|$|The PL/I [...] I/O {{statements}} {{have relatively}} simple syntax {{as they do}} not offer options for the many situations from <b>end-of-file</b> to record transmission errors that can occur when a record is read or written. Instead, these complexities are handled in the ON-units for the various file conditions. The same approach was adopted for [...] sub-allocation and the [...] condition.|$|E
5000|$|Similar {{procedures}} are provided for input. R5RS Scheme provides the predicates [...] and [...] For character input and output, , , [...] and [...] are provided. For writing and reading Scheme expressions, Scheme provides [...] and [...] On a read operation, the result returned is the <b>end-of-file</b> object if the input port {{has reached the}} end of the file, and this can be tested using the predicate [...]|$|E
50|$|Implicit {{concatenation}} {{occurs when}} an input line contains the string: $CONTINUE WITH FDname MTS will {{continue with the}} FDname given as the new source of data. Or, if a line of the form: $CONTINUE WITH FDname RETURNis read, MTS will return {{the contents of the}} new FDname until and <b>End-of-File</b> is reached and then return the next line of the original FDname (note that, a file that continues with itself causes an infinite loop, usually a mistake, but sometimes used to good effect).|$|E
50|$|The value {{returned}} is {{the number}} of bytes read (zero indicates end of file) and the file position is advanced by this number. It is not an error if this number is smaller than the number of bytes requested; this may happen for example because fewer bytes are actually available right now (maybe because we were close to <b>end-of-file,</b> or because we are reading from a pipe, or from a terminal), or because the system call was interrupted by a signal.|$|E
50|$|When {{opened by}} a text editor, human-readable content is {{presented}} to the user. This often consists of the file's plain text visible to the user. Depending on the application, control codes may be rendered either as literal instructions acted upon by the editor, or as visible escape characters that can be edited as plain text. Though there may be plain text in a text file, control characters within the file (especially the <b>end-of-file</b> character) can render the plain text unseen by a particular method.|$|E
50|$|On Microsoft Windows, reads {{and writes}} to {{anonymous}} pipes are always blocking. In other words, a read from an empty pipe {{will cause the}} calling thread to wait until at least one byte becomes available or an <b>end-of-file</b> is received {{as a result of}} the write handle of the pipe being closed. Likewise, a write to a full pipe will cause the calling thread to wait until space becomes available to store the data being written. Reads may return with fewer than the number of bytes requested (also called a short read).|$|E
5000|$|In the C Standard Library, the {{character}} reading {{functions such as}} getchar return a value equal to the symbolic value (macro) [...] to indicate that an <b>end-of-file</b> condition has occurred. The actual value of [...] is system-dependent (but is commonly -1, such as in glibc) and is distinct from all valid character codes. Block-reading functions return the number of bytes read, {{and if this is}} fewer than asked for, then the end of file was reached or an error occurred (checking of [...] or dedicated function, such as [...] is often required to determine which).|$|E
50|$|In {{the classic}} distribution, the cells are of 8-bit size (cells are bytes), {{and this is}} still the most common size. However, to read non-textual data, a brainfuck program may need to {{distinguish}} an <b>end-of-file</b> condition from any possible byte value; thus 16-bit cells have also been used. Some implementations have used 32-bit cells, 64-bit cells, or bignum cells with practically unlimited range, but programs that use this extra range are likely to be slow, since storing the value n into a cell requires Ω(n) time as a cell's value may only be changed by incrementing and decrementing.|$|E
5000|$|A {{text file}} (sometimes spelled [...] "textfile": an old {{alternative}} name is [...] "flatfile") {{is a kind}} of computer file that is structured as a sequence of lines of electronic text. A text file exists within a computer file system. The end of a text file is often denoted by placing one or more special characters, known as an <b>end-of-file</b> marker, after the last line in a text file. Such markers were required under the CP/M and MS-DOS operating systems. On modern operating systems such as Windows and Unix-like systems, text files do not contain any special EOF character.|$|E
5000|$|In Microsoft's DOS and Windows (and in CP/M {{and many}} DEC {{operating}} systems), {{reading from the}} terminal will never produce an EOF. Instead, programs recognize that the source is a terminal (or other [...] "character device") and interpret a given reserved character or sequence as an <b>end-of-file</b> indicator; most commonly this is an ASCII Control-Z, code 26. Some MS-DOS programs, including parts of the Microsoft MS-DOS shell (COMMAND.COM) and operating-system utility programs (such as EDLIN), treat a Control-Z in a text file as marking the end of meaningful data, and/or append a Control-Z to the end when writing a text file. This was done for two reasons: ...|$|E
5000|$|Usage varies across {{different}} operating systems. Also, certain features of [...] {{will depend on}} the computer system capabilities, such as 's ability to implement an option for direct memory access. Sending a SIGINFO signal (or a USR1 signal on Linux) to a running [...] process makes it print I/O statistics to standard error once and then continue copying. [...] can read standard input from the keyboard. When <b>end-of-file</b> (EOF) is reached, [...] will exit. Signals and EOF are determined by the software. For example, Unix tools ported to Windows vary as to the EOF: Cygwin uses [...] (the usual Unix EOF) and MKS Toolkit uses [...] (the usual Windows EOF).|$|E
50|$|If {{the file}} is {{strictly}} larger than one chunk size, {{a series of}} chunks at file offsets of 2n MiB (n ≥ 0) and one chunk {{right at the end}} of the file are hashed using a CRC32 (polynomial 0xEDB88320 reversed, 0x04C11DB7 normal). The last chunk of the power-of-two series ends strictly more than one chunk size before the end of the file, i.e. there is always at least one unread byte between the last two chunks (if there are that many chunks). The <b>end-of-file</b> chunk may be shorter than one chunk size; it starts at or after one chunk size into the file. The CRC is initialized using smallhash and stored into smallhash.|$|E
50|$|Older {{operating}} {{systems such as}} TOPS-10, along with CP/M, tracked file length only in units of disk blocks and used Control-Z (SUB) to {{mark the end of}} the actual text in the file. For this reason, EOF, or <b>end-of-file,</b> was used colloquially and conventionally as a three-letter acronym for Control-Z instead of SUBstitute. The end-of-text code (ETX), also known as Control-C, was inappropriate for a variety of reasons, while using Z as the control code to end a file is analogous to it ending the alphabet and serves as a very convenient mnemonic aid. A historically common and still prevalent convention uses the ETX code convention to interrupt and halt a program via an input data stream, usually from a keyboard.|$|E
5000|$|Input from a {{terminal}} never really [...] "ends" [...] (unless {{the device is}} disconnected), but {{it is useful to}} enter more than one [...] "file" [...] into {{a terminal}}, so a key sequence is reserved to indicate end of input. In UNIX the translation of the keystroke to EOF is performed by the terminal driver, so a program does not need to distinguish terminals from other input files. By default, the driver converts a Control-D character {{at the start of a}} line into an <b>end-of-file</b> indicator. To insert an actual Control-D (ASCII 04) character into the input stream, the user precedes it with a [...] "quote" [...] command character (usually Control-V). AmigaDOS is similar but uses Control-\ instead of Control-D.|$|E
50|$|Even before 1 January 2000 arrived, {{there were}} also some worries about 9 September 1999 (albeit less than those {{generated}} by Y2K). Because this date could also be written in the numeric format 9/9/99, it could have conflicted with the date value , frequently used to specify an unknown date. It was thus possible that database programs might act on the records containing unknown dates on that day. Data entry operators commonly entered 9999 into required fields for an unknown future date, (e.g., a termination date for cable television or telephone service), in order to process computer forms using CICS software. Somewhat similar to this is the <b>end-of-file</b> code , used in older programming languages. While fears arose that some programs might unexpectedly terminate on that date, the bug {{was more likely to}} confuse computer operators than machines.|$|E
50|$|The {{possible}} {{reason for not}} using a centralized location of information is that tar was originally meant for tapes, which are bad at random access anyway: if the Table Of Contents (TOC) were {{at the start of}} the archive, creating it would mean to first calculate all the positions of all files, which needs doubled work, a big cache, or rewinding the tape after writing everything to write the TOC. On the other hand, if the TOC were at the <b>end-of-file</b> (as is the case with ZIP files, for example), reading the TOC would require that the tape be wound to the end, also taking up time and degrading the tape by excessive wear and tear. Compression further complicates matters; as calculating compressed positions for a TOC at the start would need compression of everything before writing the TOC, a TOC with uncompressed positions is not really useful (since one has to decompress everything anyway to get the right positions) and decompressing a TOC at the end of the file might require decompressing the whole file anyway, too.|$|E
5000|$|An assembler-language {{compiler}} called EZ-Code. This was {{not used}} commercially for some time, since compilation time was then seen as a heavy overhead, but became increasingly used in later years. To save on computer time, typically a programmer would do an initial compile, dry-check the program manually, re-compile, and then test and de-bug the compiled machine-code version of the program, building up a reel of paper-tape machine-code patches to the program as each correction was made. Once a fairly robust copy was available, the changes would be replicated in Assembler and the program re-compiled and re-tested. Frequently, the last stage was never quite completed, {{and it was not}} unknown for production programs to require machine code-patches to be loaded from paper tape for each run. Also, a number of major commercial packages for payroll, accounts and share registration were written by Bureau staff before the Assembler compiler was accepted, and remained entirely in machine code. A further quirk was that the I/O generation routines of the assembler were not used by one programming section, who had written their own generalized I/O package, called Tape Control, based on the COBOL file description table formats. This automated much of the error-prone programming of batching/unbatching of records and controls of simultaneous read/write operations and <b>end-of-file</b> conditions.|$|E
5000|$|Center for Systems and Software Engineering (CSSE) at the University of Southern California has {{developed}} and released a code counting toolset called the Unified CodeCount (UCC), which ensures consistency across independent {{organizations in the}} rules used to count software lines of code. The primary purpose is to support sizing software counts and metrics for historical data collection and reporting purposes. It implements a code counting framework published by the Software Engineering Institute (SEI) and adapted by COCOMO. Logical and physical SLOC are among the metrics generated by the toolset. SLOC refers to Source Lines of Code and is a unit {{used to measure the}} size of software program based on a set of rules. SLOC is a key input for estimating project effort and is also used to calculate productivity and other measurements. There are two types of SLOC: physical and logical sloc. Physical SLOC (PSLOC)- One physical SLOC corresponds to one line starting with the first character and ending by a carriage return or an <b>end-of-file</b> marker of the same line. Blank and comment lines are not counted. Logical SLOC (LSLOC)- Lines of code intended to measure [...] "statements", which normally terminate by a semicolon (C/C++, Java, C#) or a carriage return (VB, Assembly), etc. Logical SLOC are not sensitive to format and style conventions, but they are language dependent.|$|E
40|$|<b>End-of-file</b> {{processing}} in a SAS ® DATA step {{occurs when}} an entire file is read and some specific processing takes place {{only after the}} last record is read from the dataset being processed. When selecting {{a subset of the}} data from the dataset using a subsetting IF statement, problems can arise due to improper placement of the <b>end-of-file</b> processing code. This paper will explain why the problem occurs and offer several suggestions on how to avoid it...|$|E
40|$|We present {{measurements}} of the pion transverse momentum (p_t) spectra in central Si-nucleus collisions in the rapidity range 2. 0 <y< 5. 0 for p_t down to and including p_t= 0. The data exhibit an enhanced pion yield at low p_t compared to what is expected for a purely thermal spectral shape. This enhancement is {{used to determine the}} Delta-resonance abundance at freeze-out. The results are consistent with a direct measurement of the Delta-resonance yield by reconstruction of proton-pion pairs and imply a temperature of the system at freeze-out close to 140 MeV. Comment: 12 pages + 4 figures (uuencoded at <b>end-of-file...</b>|$|E
