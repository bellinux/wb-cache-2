7|336|Public
50|$|The {{building}} comprises seven sections, each containing {{seven or}} eight stalls, making a total of 52. Each section forms a major space or room in the building and is bounded by radial brick fire walls, by faceted inner and outer walls, by a concrete floor with rails and pits and covered by a trussed roof. Each locomotive stall forms a shed for a single <b>engine.</b> <b>Storage</b> roads radiate from a central point.|$|E
5000|$|Sesame's RDF {{database}} API {{differs from}} comparable solutions {{in that it}} offers a stackable interface through which functionality can be added, and the storage <b>engine</b> (<b>Storage</b> and Inference Layer, SAIL) is abstracted from the query interface. Many other triplestores can be used through the Sesame API, including Ontotext GraphDB (built as a Sesame SAIL), Mulgara, and AllegroGraph. Through the stackable interface, functionality {{can be added to}} all of these stores. It can, for example, be used to add indexing and query capabilities to all compatible stores: ...|$|E
40|$|Abstract- The {{space and}} time cost of LR parser {{generation}} is high. Robust and effective LR(1) parser generators are rare to find. This work employed the Knuth canonical algorithm, Pager’s practical general method, lane-tracing algorithm, and other relevant algorithms, implemented an efficient, practical and open-source parser generator Hyacc in ANSI C, which supports full LR(0) /LALR(1) /LR(1) and partial LR(k), and is compatible with Yacc and Bison in input format and command line user interface. In this paper we introduce Hyacc, and give a brief overview on its architecture, parse <b>engine,</b> <b>storage</b> table, precedence and associativity handling, error handling, data structures, performance and usage. Keywords: Hyacc, LR(1), Parser Generator, Compiler, Software tool...|$|E
50|$|CSIC has {{developed}} 10 main product sections: shipbuilding, marine engineering, diesel <b>engines,</b> <b>storage</b> batteries, large steel structure fabrications, port machinery, turbochargers, tobacco machinery, gas meters and automation distribution systems.|$|R
5000|$|KiVi <b>Storage</b> <b>Engine.</b> It is a {{distributed}} relational <b>storage</b> <b>engine</b> with a key-value interface.|$|R
50|$|The second {{category}} are highly optimized <b>storage</b> <b>engines</b> for SQL. These systems {{provide the same}} programming interface as SQL, but scale better than built-in engines, such as InnoDB. Examples of these new <b>storage</b> <b>engines</b> include MySQL Cluster, Infobright, TokuDB and the now defunct InfiniDB. LeanXcale KiVi <b>storage</b> <b>engine</b> also fits in this category. KiVi is a relational <b>storage</b> <b>engine</b> optimized for storing relational data.|$|R
40|$|In this world, {{globalization}} {{has become a}} basic and most popular human trend. To globalize information, {{people are going to}} publish the documents in the internet. As a result, information volume of internet has become huge. To handle that huge volume of information, Web searcher uses search engines. The Webpage indexing mechanism of a search engine plays a big role to retrieve Web search results in a faster way from the huge volume of Web resources. Web researchers have introduced various types of Web-page indexing mechanism to retrieve Webpages from Webpage repository. In this paper, we have illustrated a new approach of design and development of Webpage indexing. The proposed Webpage indexing mechanism has applied on domain specific Webpages and we have identified the Webpage domain based on an Ontology. In our approach, first we prioritize the Ontology terms that exist in the Webpage content then apply our own indexing mechanism to index that Webpage. The main advantage of storing an index is to optimize the speed and performance while finding relevant documents from the domain specific search <b>engine</b> <b>storage</b> area for a user given search query. Comment: 9 pages, 3 figures, 2 tables. ICWA 2013 International Conferenc...|$|E
40|$|Consider a {{database}} of time-series, where each datapoint in the series records {{the total number of}} users who asked for a specific query at an internet search <b>engine.</b> <b>Storage</b> and analysis of such logs can be very beneficial for a search company from multiple perspectives. First, from a data organization perspective, because query Weblogs capture important trends and statistics, they can help enhance and optimize the search experience (keyword recommendation, discovery of news events). Second, Weblog data can provide an important polling mechanism for the microeconomic aspects of a search engine, since they can facilitate and promote the advertising facet of the search engine (understand what users request and when they request it). Due to the sheer amount of time-series Weblogs, manipulation of the logs in a compressed form is an impeding necessity for fast data processing and compact storage requirements. Here, we explicate how to compute the lower and upper distance bounds on the time-series logswhenworking directly on their compressed form. Optimal distance estimation means tighter bounds, leading to better candidate selection/elimination and ultimately faster search performance. Our derivation of the optimal distance bounds is based on the careful analysis of the problem using optimization principles. The experimental evaluation suggests a clear performance advantage of the proposed method, compared to previous compression/search techniques. The presented method results in a 10 – 30 % improvement on distance estimations, which in turn leads to 25 – 80 % improvement on the search performance...|$|E
40|$|Context: Google App Engine (GAE) is a cloud {{computing}} platform, which allows developers {{to develop and}} deploy web based applications on it. It is composed {{of hundreds of thousands}} of commodity servers, distributed globally. GAE scales computing resources automatically, and developers only pay for the amount of time their application uses GAE resources. It imposes some restrictions and limitations on the design and development of applications such as execution time limit, lack of global transactions, way of communication with other applications etc. Objectives: In this study, we evaluate Google App Engine from enterprise application development point of view. We analyzed the behavior and architecture of Google App Engine to evaluate its feasibility for enterprise application development and compared it with Amazon Elastic Compute 2 (Amazon cloud service). We also studied Google App <b>Engine</b> <b>storage</b> system, Bigtable, which is a distributed non-SQL based data store. Methods: In this research study, we performed a literature study of the related {{cloud computing}} technologies and then a prototype enterprise application was developed for experiment. Results: Our literature study showed that Google App Engine has some limitations and restrictions on the development tools and environment. It does not provide support for global transaction, lacks strict consistency mechanisms, and provides highly virtualized and abstract view of the platform to the developer. Despite these limitations, the literature study and our experiment showed that Google App Engine is suited for applications with high read, searching and large write-stream operations. Google App Engine showed consistent performance as compared to Amazon Elastic Compute 2 in our experiment. Conclusions: We conclude that Google App Engine is a scalable platform while maintaining consistent performance but has some limitations due to its architecture and restrictions imposed on the development tools and environment. These limitations make it non-feasible for some types of enterprise applications, such as applications with high and intensive data computation requirement. But in other cases, such as simple data management and non-transactional applications, Google App Engine is an attractive platform...|$|E
5000|$|Transactions with savepoints {{when using}} the default InnoDB <b>Storage</b> <b>Engine.</b> The NDB Cluster <b>Storage</b> <b>Engine</b> also {{supports}} transactions.|$|R
5000|$|Virtual columns {{can only}} be used on tables which use a <b>storage</b> <b>engine</b> which {{supports}} them. <b>Storage</b> <b>engines</b> supporting virtual columns are: ...|$|R
50|$|The MySQL Datacontroller <b>storage</b> <b>engine</b> for the MySQL {{relational}} {{database management system}} is a <b>storage</b> <b>engine</b> which allows a user to create a table that is a local representation of a foreign (remote) table.The foreign table can be located into another <b>storage</b> <b>engine</b> like Oracle or Microsoft SQL Server (MSSQL).|$|R
40|$|University of Minnesota Ph. D. dissertation. August 2014. Major: Computer Science. Advisor: Mohamed F. Mokbel. 1 {{computer}} file (PDF); xi, 134 pages. Recommender systems help users identify useful, interesting items or content (data) from a considerably large search space. By far, {{the most popular}} recommendation technique used is collaborative filtering which exploits the users' opinions (e. g., movie ratings) and/or purchasing (e. g., watching, reading) history in order to extract a set of interesting items for each user. Database Management Systems (DBMSs) do not provide in-house support for recommendation applications despite their popularity. Existing recommender system architectures either do not employ a DBMS at all or only uses it as a data store whereas the recommendation logic is implemented in-full outside the database engine. Incorporating the recommendation functionality inside the DBMS kernel is beneficial for the following reasons: (1) Many recommendation algorithms take as input structured data (users, items, and user historical preferences) that could be adequately stored and accessed using a database system. (2) The In-DBMS approach facilitates applying the recommendation functionality and typical database operations(e. g., Selection, Join) side-by-side. That allows application developers to go beyond traditional recommendation applications, e. g., "Recommend to Alice ten movies", and flexibly define Arbitrary Recommendation scenarios like "Recommend ten nearby restaurants to Alice" and "Recommend to Bob ten movies watched by her friends". (3) Once the recommendation functionality lives inside the database kernel, the recommendation application {{takes advantage of the}} DMBS inherent features (e. g., query optimization, materialized views, indexing) provided by the storage manager and query execution engine. This thesis studies the incorporation of the recommendation functionality inside the core engine of a database management system. This is a major departure from existing recommender system architectures that are implemented on-top of a database engines using either SQL queries or stored procedures. The on-top approach does not harness the full power of the database engine (i. e., query execution <b>engine,</b> <b>storage</b> manager) since it always generates recommendations first and then performs other database operations. Ideas developed in this thesis are implemented inside RecDB; an opensource recommendation engine built entirely inside PostgreSQL (open source relational database system) ...|$|E
5000|$|... #Caption: Aircraft <b>engines</b> in <b>storage</b> at the Bat Cave. Dec 2009.|$|R
50|$|The {{design of}} type UB II {{addressed}} {{many of the problems}} apparent in the preceding type UB I class. The UB II boats featured a two-shaft drive with a much larger battery capacity and larger <b>engines.</b> <b>Storage</b> batteries were placed forward of the central diving tanks to compensate for the much heavier engine installation.|$|R
50|$|The MySQL server {{supports}} transactions {{depending on}} the <b>storage</b> <b>engine</b> used. Since MySQL 5.5, the default <b>storage</b> <b>engine</b> is InnoDB. InnoDB has full ACID transaction support.|$|R
30|$|MongoDB {{provides}} unique multiple <b>storage</b> <b>engines</b> {{within a}} single deployment and automatically manages the movement of data between <b>storage</b> <b>engine</b> technologies using native replication. MongoDB 3.2 consists of four efficient <b>storage</b> <b>engines</b> as shown in Fig.  2, {{all of which can}} coexist {{within a single}} MongoDB replica set [99]. The default WiredTiger <b>storage</b> <b>engine</b> provides concurrency control and native compression with best storage and performance efficiency. MongoDB allows both the combinations of in-memory engine for ultra low-latency operations with a disk-based engine for persistence altogether.|$|R
50|$|As an {{embeddable}} database, RocksDB {{can be used}} as a <b>storage</b> <b>engine</b> {{within a}} larger database management system (DBMS). For example, CockroachDB uses RocksDB as its <b>storage</b> <b>engine.</b>|$|R
5000|$|While Dataphor has a <b>storage</b> <b>engine</b> of its own, it {{can also}} connect to other RDBMSes, and use them as a <b>storage</b> <b>engine.</b> Dataphor can use the {{following}} DBMSes as storage engines: ...|$|R
50|$|Propellant Supply System: It which ensures {{propellant}} {{supply to}} the Orbital Maneuver <b>Engines.</b> Includes <b>storage</b> and propellant distribution.|$|R
50|$|Dataphor is an {{open-source}} truly-relational {{database management}} system (RDBMS) and its accompanying user interface technologies, which together are designed to provide highly declarative software application development. The Dataphor Server has its own <b>storage</b> <b>engine</b> {{or it can be}} a virtual, or federated, DBMS, meaning that it can utilize other database <b>engines</b> for <b>storage.</b>|$|R
50|$|A {{database}} <b>engine</b> (or <b>storage</b> <b>engine)</b> is {{the underlying}} software component that a {{database management system}} (DBMS) uses to create, read, update and delete (CRUD) data from a database. Most database management systems include their own application programming interface (API) that allows the user to interact with their underlying engine without going through the user interface of the DBMS.|$|R
50|$|Mydiamo is a {{database}} encryption software developed by Penta Security Systems for open source databases. It runs on Linux and Microsoft Windows and is freeware for both individuals and public users. MyDiamo supports MySQL, MariaDB, Percona and PostgreSQL. It is installed between the DBMS <b>engine</b> and <b>storage</b> <b>engine.</b> It uses encryption algorithms with AES, TDES, Blowfish, RC4, AESNI.|$|R
50|$|The DataController <b>Storage</b> <b>engine</b> {{was first}} {{based on the}} MySQL Federated <b>Storage</b> <b>Engine</b> was {{authored}} by Patrick Galbraith and Brian Aker and is currently being maintained by Patrick Galbraith and Antony Curtis.It was introduced in 2005 with MySQL 5.0.|$|R
5000|$|Transactions are {{available}} in most SQL database implementations, though with varying levels of robustness. (MySQL, for example, began supporting transactions from version 5.5, with the switch to the InnoDB <b>storage</b> <b>engine.</b> The previously used <b>storage</b> <b>engine,</b> MyISAM did not support transactions.) ...|$|R
50|$|Before version 2.2, {{concurrency}} control was implemented on a per-mongod basis. With version 2.2, {{concurrency control}} was implemented at the database level. Since version 3.0, pluggable <b>storage</b> <b>engines</b> were introduced, and each <b>storage</b> <b>engine</b> may implement concurrency control differently. With MongoDB 3.0 concurrency control is implemented at the collection {{level for the}} MMAPv1 <b>storage</b> <b>engine,</b> and at the document level with the WiredTiger <b>storage</b> <b>engine.</b> With versions prior to 3.0, one approach to increase concurrency is to use sharding. In some situations, reads and writes will yield their locks. If MongoDB predicts a page {{is unlikely to be}} in memory, operations will yield their lock while the pages load. The use of lock yielding expanded greatly in 2.2.|$|R
50|$|Some <b>storage</b> <b>engines</b> are transactional.|$|R
50|$|MongoDB {{acquired}} WiredTiger Inc. on December 16, 2014. The WiredTiger <b>storage</b> <b>engine</b> is {{the default}} <b>storage</b> <b>engine</b> starting in MongoDB version 3.2. It provides a document-level concurrency model, checkpointing, and compression, among other features. In MongoDB Enterprise, WiredTiger also supports Encryption At Rest.|$|R
5000|$|Cyberinfrastructure for informatics: search <b>engines,</b> digital repositories, <b>storage.</b>|$|R
5000|$|The <b>Engine's</b> <b>storage</b> {{was to be}} purely {{mechanical}}, using {{wheels and}} cards.The fact that Babbage's Analytical Engine was to be entirely mechanical will help us rid ourselves of a superstition. Importance is often attached {{to the fact that}} modern digital computers are electrical, and the nervous system is also electrical. Since Babbage's machine was not electrical, and since all digital computers are in a sense equivalent, we see that this use of electricity cannot be of theoretical importance. ... If we wish to find such similarities we should look rather for mathematical analogies of function.|$|R
5000|$|The {{developer}} of the Federated <b>Storage</b> <b>Engine</b> states that [...] "The Federated <b>Storage</b> <b>Engine</b> is a proof-of-concept storage engine", {{but the main}} distributions of MySQL version 5.0 included it and turned it on by default. Documentation {{of some of the}} short-comings appears in [...] "MySQL Federated Tables: The Missing Manual".|$|R
5000|$|ACID {{compliance}} {{when using}} InnoDB and NDB Cluster <b>Storage</b> <b>Engines</b> ...|$|R
5000|$|... mod_mem_cache - {{allows the}} use memory-based <b>storage</b> <b>engine</b> for mod_cache ...|$|R
5000|$|... is {{a logical}} backup tool {{included}} with both community and enterprise editions of MySQL. It supports backing up from all <b>storage</b> <b>engines.</b> MySQL Enterprise Backup is a hot backup utility included {{as part of the}} MySQL Enterprise subscription from Oracle, offering native InnoDB hot backup, as well as backup for other <b>storage</b> <b>engines.</b>|$|R
5000|$|... mod_disk_cache - {{allows the}} use of disk-based <b>storage</b> <b>engine</b> for mod_cache ...|$|R
40|$|This is the User’s Guide for the InnoDB <b>storage</b> <b>engine</b> 1. 1 for MySQL 5. 5. Beginning with MySQL version 5. 1, it is {{possible}} to swap out one version of the InnoDB <b>storage</b> <b>engine</b> and use another (the “plugin”). This manual documents the latest InnoDB plugin, version 1. 1, which works with MySQL 5. 5 and features cutting-edge improvements in performance and scalability. This User's Guide documents the procedures and features that are specific to the InnoDB <b>storage</b> <b>engine</b> 1. 1 for MySQL 5. 5. It supplements the general InnoDB information in the MySQL Reference Manual. Because InnoDB 1. 1 is integrated with MySQL 5. 5, it is generally available (GA) and production-ready. WARNING: Because the InnoDB <b>storage</b> <b>engine</b> 1. 0 and above introduces a new file format, restrictions apply to the use of a database created with the InnoDB <b>storage</b> <b>engine</b> 1. 0 and above, with earlier versions of InnoDB, when using mysqldump or MySQL replication and if you use the older InnoDB Hot Backup product rather than the newer MySQL Enterprise Backup product. See Section 1. 4, “Compatibility Considerations for Downgrade and Backup”...|$|R
