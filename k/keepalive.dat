42|4|Public
5000|$|<b>Keepalive</b> {{interval}} is {{the duration}} between two successive <b>keepalive</b> retransmissions, if acknowledgement {{to the previous}} <b>keepalive</b> transmission is not received.|$|E
5000|$|<b>Keepalive</b> {{time is the}} {{duration}} between two <b>keepalive</b> transmissions in idle condition. TCP <b>keepalive</b> period is required to be configurable and by default is set to no less than 2 hours.|$|E
5000|$|If a <b>Keepalive</b> {{message is}} {{received}} and no {{timer has expired}} before reception of the <b>Keepalive,</b> BGP transitions to the Established state.|$|E
50|$|LMI {{is a set}} of {{signalling}} standards between routers {{and frame}} relay switches. Communication takes place between a router and the first frame relay switch it's connected to. Information about <b>keepalives,</b> global addressing, IP Multicast and the status of virtual circuits is commonly exchanged using LMI.|$|R
30|$|From the figure, we {{can observe}} {{that in the}} RELOAD-dedicated {{scenario}}, the total traffic during the one-hour period is 938 MB, whereas in the C/S-dedicated scenario it is 365 MB. The RELOAD-tunnel scenario generates 750 MB of traffic, whereas C/S-tunnel generates only 124 MB. The higher cost of the RELOAD scenarios is explained especially by the RELOAD overlay maintenance traffic and high amount of STUN traffic required to keep the RELOAD connections between PNs alive (every PN maintains connections to all peers in the routing table, whose size is 8 fingers, 3 successors, and 3 predecessors as described in Table 1). In all of the scenarios, {{a large part of}} the total traffic is STUN keeplives. The percentages are 71 %, 43 %, 96 %, and 53 % for the RELOAD-dedicated, RELOAD-tunnel, C/S-dedicated, and C/S-tunnel scenarios, respectively. For the RELOAD-dedicated and C/S-dedicated scenarios, the largest source of traffic are STUN <b>keepalives</b> for CoAP connections. The percentage of STUN <b>keepalives</b> for CoAP out of total traffic are 40 % and 89 % for the RELOAD-dedicated and C/S-dedicated scenarios, respectively.|$|R
50|$|Finally fault {{tolerance}} {{among members of}} the distribution tree is accomplished through the use of timeouts and <b>keepalives</b> with actual data transmissions doubling as <b>keepalives</b> to minimize traffic. If a child node does not hear from its parent for a while, it routes a new subscribe message toward the root node of the tree, reattaching itself wherever it bumps into the tree for that topic. If a parent doesn't hear from a child for a timeout period, it drops the child from its list of children. (If this action causes its child list to become empty, the parent stops acting as a forwarder altogether.) The only remaining failure point is that of the root node, and Pastry itself automatically overcomes this. Because Pastry duplicates keys among the few nodes closest to the key's actual value, the root node already has mirrors set up, lying dormant. If the root node goes offline, again detected through timeouts, the next-closest Pastry node will begin acting as the root node. When the creator of the topic tries to publish new material the old root node will be unreachable. The publisher will then fall back on the Pastry network and use it to route its publish message to the new root node. Once this has been done, the publisher caches a copy of the new root node's IP address to reduce the use of the Pastry network for future transmissions.|$|R
50|$|A <b>keepalive</b> {{signal is}} often sent at {{predefined}} intervals, and {{plays an important}} role on the Internet. After a signal is sent, if no reply is received the link is assumed to be down and future data will be routed via another path until the link is up again. A <b>keepalive</b> signal {{can also be used to}} indicate to Internet infrastructure that the connection should be preserved. Without a <b>keepalive</b> signal, intermediate NAT-enabled routers can drop the connection after timeout.|$|E
5000|$|<b>Keepalive,</b> {{a common}} {{generalization}} of this feature in various protocols ...|$|E
5000|$|Transmission Control Protocol (TCP) keepalives are an {{optional}} feature, and if included must default to off. The <b>keepalive</b> packet contains null data. In an Ethernet network, a <b>keepalive</b> frame length is 60 bytes, while the server response to this, also a null data frame, is 54 bytes. There are three parameters related to keepalive: ...|$|E
40|$|As a {{de facto}} {{standard}} protocol, Internet protocol security (IPSec) provides secure communication between networked systems. One {{of the most common}} issues today in large-scale virtual private networks using IPSec is the problem of a stale security association, which occurs when the device {{at one end of the}} tunnel maintains the tunnel state but the other end does not. Internet key exchange (IKE) <b>keepalives</b> resolve this by removing the state of the old tunnel and setting up a new tunnel. In particular, the loss of state by a security gateway requires multiple hosts to reestablish tunnels, resulting in high network costs in time, bandwidth usage, etc. The resulting time delay can lead to poor performance, which in turn increases the packet drop rate. To solve this problem, we propose the Fast Session Recovery scheme for IPSec, which reestablishes tunnels, not by renegotiating the session key using IKE, but by backing up the session key. We tested the proposed scheme with an experiment which showed that it can significantly speed up the session reestablishment while increasing total throughput in the network...|$|R
5000|$|<b>Keepalive</b> retry is {{the number}} of retransmissions to be carried out before declaring that remote end is not available.|$|E
5000|$|If {{there is}} no error, a <b>Keepalive</b> message is sent, various timers are set and the state is changed to OpenConfirm.|$|E
5000|$|... 0 (0x00) Received tag list 1 (0x01) Packet for {{transmit}} 2 (0x02) Reserved 3 (0x03) Configuration 4 (0x04) <b>Keepalive</b> 5 (0x05) Port opener ...|$|E
5000|$|If a timer expires {{before a}} <b>Keepalive</b> message is received, or if an error {{condition}} occurs, the router transitions {{back to the}} Idle state.|$|E
5000|$|<b>Keepalive</b> is a {{permanent}} outdoor sculpture in Niedersachsen, Germany, commissioned by the Center for Digital Cultures, Leuphana University Lüneburg. The title, <b>Keepalive,</b> refers to the <b>keepalive</b> signal, a message - often sent at predetermined intervals - that is used on networks to check the link between two devices, to make a diagnosis or to indicate to the internet infrastructure that the connection should be preserved. Domenico Quaranta described the work as generating, [...] "...a fiction that ironically locates it in a post-apocalyptic, cyberpunk scenario where humanity has been “kept alive”, the internet is over and power is provided by fire, but also where technologies and pieces of information have survived as digital junk. Presented as an artwork and preserved as such, it may once turn useful and even essential for a wandering Mad Max to survive, as the only remaining access point to basic information." ...|$|E
50|$|A <b>keepalive</b> (KA) is {{a message}} sent by one device to another to check that {{the link between the}} two is operating, or to prevent the link from being broken.|$|E
50|$|Maintaining client-initiated {{implicit}} mappings alive {{is necessary}} because network gateways delete such mappings {{when they become}} idle, {{as a result of}} treating them as regular client connections; such implicit mappings are preserved by passing <b>keepalive</b> messages through NAT devices or firewalls. Thus, keeping such connections alive requires a constant exchange of otherwise useless <b>keepalive</b> messages between clients and servers, as a workaround that increases network chatter, wastes network bandwidth and CPU cycles, and decreases the autonomy of battery-powered devices. Additionally, some network applications (for example, FTP) require dynamic opening of multiple connections, which involves application-level gateways (ALGs) and additionally increases complexity.|$|E
50|$|Since TCP <b>keepalive</b> is optional, various {{protocols}} (e.g.SMBand TLS)add {{a similar}} feature {{on top of}} it. This is also common for protocols which maintain a session over a connectionless protocol, e.g. OpenVPN over UDP.|$|E
5000|$|Under HTTP 1.0, {{there is}} no {{official}} specification for how <b>keepalive</b> operates. It was, in essence, added to an existing protocol. If the client supports keep-alive, it adds an additional header to the request: ...|$|E
50|$|Created {{explicit}} mappings are permanent, with no {{need for}} application-level <b>keepalive</b> messages to be exchanged between hosts and servers {{for the purpose of}} preserving the mapping. As a result, network usage and power consumption are reduced, and application-level <b>keepalive</b> logic no longer needs to be implemented at client and server sides. After a PCP-based mapping is created, associated externally visible parameters (IP address, protocol and port) need to be announced to clients so incoming connections can be established, which is performed in application-specific ways. Additionally, PCP provides the functionality required to inform applications when the external IP address is changed while a mapping is already established.|$|E
50|$|Since {{the only}} {{purpose is to}} find links that don't work or to {{indicate}} connections that should be preserved, <b>keepalive</b> messages tend to be short and not take much bandwidth. However, their precise format and usage terms depend on the communication protocol.|$|E
50|$|Sprytrons {{lack the}} <b>keepalive</b> {{electrode}} and the preionization radioactive source. The trigger pulse must be stronger {{than for a}} krytron. Sprytrons are able to handle higher currents; krytrons tend {{to be used for}} triggering a secondary switch, e.g., a triggered spark gap, while sprytrons are usually connected directly to the load.|$|E
5000|$|...- init mqtt client with <b>keepalive</b> timer 120secm = mqtt.Client("clientid", 120, [...] "user", [...] "password")-- setup Last Will and Testament (optional)-- Broker {{will publish}} a message with qos = 0, retain = 0, data = [...] "offline"-- to topic [...] "/lwt" [...] if client don't send <b>keepalive</b> packetm:lwt("/lwt", [...] "offline", 0, 0)m:on("connect", function(con) print ("connected") end)m:on("offline", function(con) print ("offline") end)-- on publish message receive eventm:on("message", function(conn, topic, data) print(topic [...]. [...] ":" [...] ) if data ~= nil then print(data) endend)-- for secure: m:connect("192.168.11.118", 1880, 1)m:connect("192.168.11.118", 1880, 0, function(conn) print("connected") end)-- {{subscribe}} topic with qos = 0m:subscribe("/topic",0, function(conn) print("subscribe success") end)-- or subscribe multiple topic (topic/0, qos = 0; topic/1, qos = 1; topic2 , qos = 2)-- m:subscribe({"topic/0"=0,"topic/1"=1,topic2=2}, function(conn) print("subscribe success") end)-- publish a message with data = hello, QoS = 0, retain = 0m:publish("/topic","hello",0,0, function(conn) print("sent") end)m:close (...)-- {{you can call}} m:connect again ...|$|E
50|$|Additionally, {{explicit}} port forwarding rules {{available through}} PCP allow hosts {{to reduce the}} amount of generated traffic by eliminating workarounds in form of outgoing NAT <b>keepalive</b> messages, which are required for maintaining connections to servers and for various NAT traversal techniques such as TCP hole punching. At the same time, less generated traffic reduces the power consumption, directly improving the battery runtime for mobile devices.|$|E
50|$|In {{order to}} prevent the state table from filling up, {{sessions}} will time out if no traffic has passed for a certain period.These stale connections are removed from the state table. Many applications therefore send <b>keepalive</b> messages periodically {{in order to stop}} a firewall from dropping the connection during periods of no user-activity, though some firewalls can be instructed to send these messages for applications.|$|E
50|$|A {{small amount}} of a {{radioactive}} element may be added into the tube, either as a separate piece of material (e.g. nickel-63 in krytrons) or as addition to the alloy of the electrodes (e.g. thorium), to preionize the gas and increase the reliability of electrical breakdown and glow or arc discharge ignition. A gaseous radioactive isotope, e.g. krypton-85, can also be used. Ignition electrodes and <b>keepalive</b> discharge electrodes can also be employed.|$|E
5000|$|In HTTP 1.1, all {{connections}} are considered persistent unless declared otherwise. The HTTP persistent connections {{do not use}} separate <b>keepalive</b> messages, they just allow multiple requests to use a single connection. However, the default connection timeout of Apache httpd 1.3 and 2.0 is as little as 15 seconds and just 5 seconds for Apache httpd 2.2 and above. [...] The advantage of a short timeout {{is the ability to}} deliver multiple components of a web page quickly while not consuming resources to run multiple server processes or threads for too long.|$|E
50|$|BFD {{does not}} have a {{discovery}} mechanism; sessions must be explicitly configured between endpoints. BFD may be used on many different underlying transport mechanisms and layers, and operates independently of all of these. Therefore, it needs to be encapsulated by whatever transport it uses. For example, monitoring MPLS LSPs involves piggybacking session establishment on LSP-Ping packets. Protocols that support some form of adjacency setup, such as OSPF or IS-IS, may also be used to bootstrap a BFD session. These protocols may then use BFD to receive faster notification of failing links than would normally be possible using the protocol's own <b>keepalive</b> mechanism.|$|E
50|$|For example, {{an online}} {{computer}} game (which {{acts as a}} client) requires communication with a game server for exchanging gameplay data such as the movement of players, their different associated parameters, etc. In {{order to make it}} possible for a game server to provide such gameplay data updates to its online clients, those clients must be made accessible to the server. Usually, clients initiate connections to the game server, creating that way implicit mappings, which provide servers with the required communication channels. However, such connections can become idle and subsequently closed by the network gateways, leading to the necessity of maintaining them by using a form of <b>keepalive</b> messages.|$|E
50|$|One {{particularly}} common {{software error}} is to generate query packets at short (less than five second) intervals until a response is received. When such an implementation finds itself behind a packet filter {{that refuses to}} pass the incoming response, {{this results in a}} never-ending stream of requests to the NTP server. Such grossly over-eager clients (particularly those polling once per second) commonly make up more than 50% of the traffic of public NTP servers, despite being a minuscule fraction of the total clients. While it is reasonable to send a few initial packets at short intervals, it is essential for the health of any connectionless network that unacknowledged packets be generated at exponentially decreasing rates. This applies to any connectionless protocol, and many portions of connection-based protocols. Examples {{can be found in the}} TCP specification for connection establishment, zero-window probing, and <b>keepalive</b> transmissions.|$|E
5000|$|In {{order to}} make {{decisions}} in its operations with peers, a BGP peer uses a simple finite state machine (FSM) that consists of six states: Idle; Connect; Active; OpenSent; OpenConfirm; and Established. For each peer-to-peer session, a BGP implementation maintains a state variable that tracks which of these six states the session is in. The BGP defines the messages that each peer should exchange in order to change the session from one state to another. The first state is the [...] "Idle" [...] state. In the [...] "Idle" [...] state, BGP initializes all resources, refuses all inbound BGP connection attempts and initiates a TCP connection to the peer. The second state is [...] "Connect". In the [...] "Connect" [...] state, the router waits for the TCP connection to complete and transitions to the [...] "OpenSent" [...] state if successful. If unsuccessful, it starts the ConnectRetry timer and transitions to the [...] "Active" [...] state upon expiration. In the [...] "Active" [...] state, the router resets the ConnectRetry timer to zero {{and returns to the}} [...] "Connect" [...] state. In the [...] "OpenSent" [...] state, the router sends an Open message and waits for one in return in order to transition to the [...] "OpenConfirm" [...] state. <b>Keepalive</b> messages are exchanged and, upon successful receipt, the router is placed into the [...] "Established" [...] state. In the [...] "Established" [...] state, the router can send/receive: Keepalive; Update; and Notification messages to/from its peer.|$|E
40|$|Part 1 : Networks and System ArchitectureInternational audienceUser applications, such as VoIP, have {{problems}} traversing NAT gateways or firewalls. To mitigate these problems, applications send <b>keepalive</b> messages through the gateways. The interval of sending keepalives is often unnecessarily short, {{which increases the}} network load, especially in mobile networks. Port Control Protocol (PCP) allows the applications to traverse the gateways and to optimize the interval. This paper describes the deployment of PCP in software-defined networks (SDN) and proposes a method to measure <b>keepalive</b> traffic reduction in mobile networks using PCP. The proposed solution extends the battery life of mobile devices and reduces the traffic overhead in WCDMA networks...|$|E
40|$|International audienceMany {{applications}} {{are designed for}} vehicular networks, like chat, dynamic map update or touristic information. The need of services used as building blocks for these applications is then emerging: localization, map matching, data collect, and so on. When a unicast communication is required, applications rely generally on naming, localization and routing services. This approach consumes many network resources and leads to poor performances when the network dynamic is high. We then propose an efficient service, named <b>keepalive,</b> to ensure the continuity of a communication that began between two mobile neighbors. The major strengths of our proposal are that it relies only on local exchanges of identifiers and it is less resource consuming than usual networking services. Moreover, it is beneficial for a large set of applications, including download from road side units or follow me application for instance. Road tests and performance study confirm {{the efficiency of the}} <b>keepalive</b> service...|$|E
40|$|The Port Control Protocol allows an IPv 6 or IPv 4 host {{to control}} how {{incoming}} IPv 6 or IPv 4 packets are translated and forwarded by a Network Address Translator (NAT) or simple firewall, and also allows a host to optimize its outgoing NAT <b>keepalive</b> messages. Status of This Memo This is an Internet Standards Track document. This document {{is a product}} of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by th...|$|E
40|$|This memo {{provides}} {{information for the}} Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2004). All Rights Reserved. This document describes the method detecting a dead Internet Key Exchange (IKE) peer that is presently in use {{by a number of}} vendors. The method, called Dead Peer Detection (DPD) uses IPSec traffic patterns to minimize the number of IKE messages that are needed to confirm liveness. DPD, like other <b>keepalive</b> mechanisms, is needed to determine when to perform IKE peer failover, and to reclaim lost resources...|$|E
40|$|Abstract—Nodes within {{existing}} P 2 P networks typically exchange periodic keep-alive {{messages in}} order to maintain network connections between neighbours. This paper investigates a number of algorithms which allow each individual connections to extend the interval between successive keep-alive messages based upon the likelihood that a corresponding node will remain in the system. Several studies have shown that older peers are more likely to remain in the network longer than their short-lived counterparts. Therefore using the distribution of peer session times and the current age of peers as key attributes, we propose three algorithms that increase the interval between successive <b>keepalive</b> messages as nodes become more reliable. By prioritising keep-alive messages to nodes that are more likely to fail, our algorithms reduce the expected delay betwee...|$|E
