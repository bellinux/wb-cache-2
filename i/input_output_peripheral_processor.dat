0|10000|Public
50|$|For <b>input</b> or <b>output,</b> each <b>peripheral</b> <b>processor</b> accesses a <b>peripheral</b> device over a {{communication}} link called a data channel. One peripheral device can {{be connected to}} each data channel; however, a channel can be modified with hardware to service more than one device.|$|R
40|$|This paper {{develops}} hardware modules {{for rapid}} prototyping of video processing systems {{based on the}} Xilinx video frame buffer controller (VFBC). This implementation allows the storage of video frames in memory external to the programmable device, {{as well as its}} proper handle for designing spatio-temporal processing systems using the Xilinx System Generator model-based design flow. The hardware modules are responsible for the configuration and control of writing and reading VFBC interfaces, as well as the manipulation of video synchronization signals for interconnecting <b>input</b> and <b>output</b> <b>peripherals.</b> The article also include the description of the elaborated modules and the analysis of the results of its use {{for the development of a}} temporal video processing demonstrator using a simple motion detector on a Spartan- 6 SP 605 Evaluation Platform board. Peer Reviewe...|$|R
5000|$|Control devices:In a music workstation, the {{keyboard}} was not {{directly connected to}} the synthesis modules, as in a Minimoog or ARP Odyssey. Instead, {{the keyboard}} switches were digitally scanned, and control signals sent over a computer backplane where they were inputs to the computer processor, which would then route the signals to the synthesis modules, which were output devices on the backplane. This approach had been used for years in computer systems, and allowed the addition of new <b>input</b> and <b>output</b> <b>peripherals</b> without obsoleting the entire computer. In {{the case of the}} music workstations, the next output devices to be added were typically computer terminal displays (some with graphics), {{and in the case of}} the Fairlight, the next input device was a light pen for [...] "drawing" [...] on the display screen.|$|R
40|$|Over {{the past}} decade, Virtual Reality (VR) has {{garnered}} widespread use in psychology, cognitive neuroscience, and especially spatial navigation research. Current VR systems {{are difficult to}} design and configure, particularly when arrays of hardware peripherals are used. Issues with hardware integration, architectural design, and usability {{have led to the}} creation of inflexible and immobile VR systems. We present a potential solution to these issues, the SNaP Framework. The framework integrates VR <b>input</b> and <b>output</b> <b>peripherals</b> and an easy-to-use configuration medium (XML) with a popular software development suite (Virtools) to create a VR system that supports users with different computer skills. We report on the architecture of the SNaP Framework and provide details from a study that measured the usability of the framework. We conclude with a discussion of experiences encountered while designing and implementing the system. 1...|$|R
40|$|Home {{security}} and control {{is one of}} the basic need of the mankind since from evaluation of Embedded Systems. The paper “GSM and internet based home security” is mainly aims to implements the emerging applications of the GSM technology. Using GSM networks, a controlling system has been proposed that will act as an embedded system which can monitor and control appliances and other devices locally using built-in <b>input</b> and <b>output</b> <b>peripherals.</b> Remotely the system allows the user to effectively monitor and control the house/office appliances and equipments via the mobile phone set by sending commands in the form of SMS messages and receiving the appliances status. This project concept is to use keywords as SMS and processing it further as required to perform several operations. The operation to be performed depends up {{on the nature of the}} SMS sent or keyword used. The principle in which the project is based is fairly simple. First, the sent SMS will be received at the receiver mobile station and then the required control signal is generated and sent to the intermediate hardware that we have designed according to the command received in form of the sent message. In this we are using internet also to send messages through internet we can controldevice...|$|R
50|$|Each <b>peripheral</b> <b>processor</b> can {{communicate}} with any peripheral device if another <b>peripheral</b> <b>processor</b> is not using the data channel connected to that device. In other words, only one <b>peripheral</b> <b>processor</b> at a time can use a particular data channel.|$|R
40|$|Two {{different}} {{system architectures}} are presented. The two architectures {{are derived from}} two different data flows within the Spacelab Output Processing System. The major differences between these system architectures are {{in the position of}} the decommutation function (the first architecture performs decommutation {{in the latter half of}} the system and the second architecture performs that function in the front end of the system). In order to be examined, the system was divided into five stand-alone subsystems; Work Assembler, Mass Storage System, <b>Output</b> <b>Processor,</b> <b>Peripheral</b> Pool, and Resource Monitor. The work load of each subsystem was estimated independent of the specific devices to be used. The candidate devices were surveyed from a wide sampling of off-the-shelf devices. Analytical expressions were developed to quantify the projected workload in conjunction with typical devices which would adequately handle the subsystem tasks. All of the study efforts were then directed toward preparing performance and cost curves for each architecture subsystem...|$|R
50|$|The TPC was {{responsible}} for call sequence and state control. It received signalling inputs collected from <b>peripheral</b> <b>processors</b> (see MXU, RLU, RSU, and TCU below) and sent control information back to the <b>peripheral</b> <b>processors.</b>|$|R
50|$|The central {{processor}} shares access to central memory with ten <b>peripheral</b> <b>processors.</b> Each <b>peripheral</b> <b>processor</b> {{is an individual}} computer with its own 1 μs memory of 4K words, each with 12 bits. (They were somewhat similar to CDC 160A minicomputers, sharing the 12-bit word length and portions of the instruction set.) <b>Peripheral</b> <b>processors</b> are used primarily for input/output: the transfer of information between central memory and peripheral devices such as disks and magnetic tape units. They relieve the {{central processor}} of all input/output tasks, {{so that it can}} perform calculations while the <b>peripheral</b> <b>processors</b> are engaged in input/output functions. This feature promotes rapid overall processing of user programs. Each <b>peripheral</b> <b>processor</b> can add, subtract, and perform logical operations. Special instructions performed data transfer between <b>processor</b> memory and <b>peripheral</b> devices at up to 1 μs per word. The <b>peripheral</b> <b>processors</b> were collectively implemented as a barrel processor. Each executes routines independently of the others. (For comparison, on the IBM 360 series of machines, these processors were called channels.) They are a loose predecessor of bus mastering or Direct memory access.|$|R
50|$|<b>Peripheral</b> <b>processor</b> (PP or PPU) {{instructions}} are {{completely different from}} CPU instructions. <b>Peripheral</b> <b>processor</b> hardware is simpler; it has an 18-bit A (accumulator register, a 12-bit Program Address register, a 12-bit Q register (not programmer-visible), and a 22-bit R register (used to accomplish address relocation during central memory read and write instructions on Cyber 180 systems). No special job validation was required to assemble <b>peripheral</b> <b>processor</b> programs, but to be executed, such programs were required to installed into the operating system via special system editing commands.|$|R
50|$|KMC11 - <b>Peripheral</b> <b>processor</b> for Digital Equipment Corporation PDP-11.|$|R
50|$|Subsequent {{modifications}} to the series in 1969 included the extension to 20 <b>peripheral</b> and control <b>processors</b> with 24 channels. (A 30-PPU 6600 machine was operated by Control Data's Software Research Lab during 1971-1973, but this version was never sold commercially.) Control Data also marketed a CDC 6400 with {{a smaller number of}} <b>peripheral</b> <b>processors,</b> the CDC 6415-7 with seven <b>peripheral</b> <b>processors</b> to reduce cost.|$|R
40|$|This paper {{gives some}} results from {{monitoring}} <b>peripheral</b> <b>processor</b> activity on CDC 6000 series machines at the European Nuclear Research Centre (CERN). It relates <b>peripheral</b> <b>processor</b> activity to a (single) central processor {{and argues that}} such an architecture {{is more likely to}} meet future user demands for higher levels of multiprogramming data security and error recovery. (12 refs) ...|$|R
50|$|HCS12 {{products}} {{contain a}} single processor, the HCS12X feature the additional XGATE <b>peripheral</b> <b>processor.</b>|$|R
40|$|This {{thesis is}} a {{continuation}} of work done in a specialization project. The result from the preliminary work have been used to implement a programmable <b>peripheral</b> <b>processor</b> in HDL that can replace non-programmable hardware modules. The implemented solution have then been tested to find out if it is capable of doing the most basic operations that a UART protocol require to do parallel-to-serial and serial-to-parallel conversions. The results of the implementation and testing have been analysed and the performance, area and power consumption have been presented. The resulting performance and area have also been compared to traditional hardware solutions. The results from the tests demonstrates that the presented <b>peripheral</b> <b>processor</b> is capable of doing the basic operations that is required to do parallel-to-serial and serial-to-parallel conversions. However, the area of the <b>peripheral</b> <b>processor</b> is significantly larger than the total area of multiple non-programmable hardware modules. The result of this is that the cost of utilizing a <b>peripheral</b> <b>processor</b> will be greater than with existing solutions...|$|R
50|$|Mainframes are {{designed}} to handle very high volume <b>input</b> and <b>output</b> (I/O) and emphasize throughput computing. Since the late-1950s, mainframe designs have included subsidiary hardware (called channels or <b>peripheral</b> <b>processors)</b> which manage the I/O devices, leaving the CPU free to deal only with high-speed memory. It is common in mainframe shops to deal with massive databases and files. Gigabyte to terabyte-size record files are not unusual. Compared to a typical PC, mainframes commonly have hundreds to thousands of times as much data storage online, and can access it reasonably quickly. Other server families also offload I/O processing and emphasize throughput computing.|$|R
50|$|The <b>peripheral</b> <b>processor</b> {{subsystem}} used {{a technique}} known as barrel and slot {{to share the}} execution unit; each PP had its own memory and registers, but the processor (the slot) itself executed one instruction from each PP in turn (the barrel). This is a crude form of hardware multiprogramming. The <b>peripheral</b> <b>processors</b> had 4096 bytes of 12-bit memory words and an 18-bit accumulator register. Each PP had access to all I/O channels {{and all of the}} system's central memory (CM) in addition to the PP's own memory. The PP instruction set lacked, for example, extensive arithmetic capabilities and did not run user code; the <b>peripheral</b> <b>processor</b> subsystem's purpose was to process I/O and thereby free the more powerful central processor unit(s) to running user computations.|$|R
50|$|However, {{since the}} Cray {{machines}} {{did not have}} <b>peripheral</b> <b>processors,</b> the main central processor executed the operating system code.|$|R
5000|$|COMPASS PP is the {{assembly}} language for the PP (<b>Peripheral</b> <b>Processor),</b> only running operating system code. See CDC 6600 PP architecture.|$|R
50|$|The CP had no {{instructions}} for <b>input</b> and <b>output,</b> which are accomplished through <b>Peripheral</b> <b>Processors</b> (below). No opcodes were specifically dedicated to loading or storing memory; this occurred {{as a side}} effect of assignment to certain A registers. Setting A1 through A5 loaded the word at that address into X1 through X5 respectively; setting A6 or A7 stored a word from X6 or X7. No side effects were associated with A0. A separate hardware load/store unit, called the stunt box, handled the actual data movement independently of the operation of the instruction stream, allowing other operations to complete while memory was being accessed, which required eight cycles, in the best case.|$|R
50|$|The 160 {{architecture}} {{was modified}} {{to become the}} basis of the <b>peripheral</b> <b>processors</b> (PPs) in the CDC 6000 series mainframe computers and its successors. Large parts of the 160 instruction set were unchanged in the <b>peripheral</b> <b>processors.</b> However there were changes to incorporate the 6000 data channel programming, and control of the central processor. In {{the early days of the}} 6000s, almost the entire operating system ran in the PPs. This left the central processor unencumbered by operating system demands and available for user programs.|$|R
5000|$|... "Applications of <b>Input</b> <b>Output</b> Analysis for Less Developed Countries", in Sohn, I. (ed.), Readings in <b>Input</b> <b>Output</b> Analysis, Oxford University Press, 1986 ...|$|R
25|$|In computing, channel I/O is a {{high-performance}} input/output (I/O) architecture that is implemented {{in various forms}} {{on a number of}} computer architectures, especially on mainframe computers. In the past, channels were generally implemented with custom processors, variously named channel, <b>peripheral</b> <b>processor,</b> I/O processor, I/O controller, or DMA controller.|$|R
40|$|This paper {{describes}} some of {{the results}} of a study directed to the specification and procurement of a new cockpit simulator for an advanced class of helicopters. A part of the study was the definition of a challenging benchmark problem, and detailed analyses of it were made to assess the suitability of a variety of simulation techniques. The analyses showed that a particularly cost-effective approach to the attainment of adequate speed for this extremely demanding application is to employ a large minicomputer acting as host and controller for a special-purpose digital <b>peripheral</b> <b>processor.</b> Various realizations of such <b>peripheral</b> <b>processors,</b> all employing state-of-the-art electronic circuitry and a high degree of parallelism and pipelining, are available or under development. The types of <b>peripheral</b> <b>processors</b> array processors, simulation-oriented processors, and arrays of processing elements - are analyzed and compared. They are particularly promising approaches which should be suitable for high-speed simulations of all kinds, the cockpit simulator being a case in point...|$|R
2500|$|A {{parallel}} feedback connection at the <b>input</b> (<b>output)</b> {{decreases the}} <b>input</b> (<b>output)</b> resistance {{by a factor}} ( [...] 1 + β AOL [...] ), where AOL = open loop gain.|$|R
5000|$|KXJ11 - QBUS card (M7616) with PDP-11 based <b>peripheral</b> <b>processor</b> and DMA controller. Based on a J11 CPU {{equipped}} with 512 kB RAM, 64 kB ROM and parallel and serial interfaces.|$|R
50|$|ASP {{evolved from}} {{the design of the}} 7094/7044 Direct Coupled System, using data channel to data channel communication. By {{attaching}} an IBM 7044 as a <b>peripheral</b> <b>processor</b> throughput was more than doubled.|$|R
5000|$|KXJ11 - QBUS card (M7616) with PDP-11 based <b>peripheral</b> <b>processor</b> and DMA controller. Based on a J11 CPU {{equipped}} with 512 kB of RAM, 64 kB of ROM, and parallel and serial interfaces.|$|R
50|$|In {{addition}} to communication between peripheral devices and <b>peripheral</b> <b>processors,</b> communication takes {{place between the}} computer operator and the operating system. This {{was made possible by}} the computer console, which had two CRT screens.|$|R
50|$|ASP {{evolved from}} {{the design of the}} 7094/7044 direct coupled system, using data channel to data channel communication. By {{attaching}} an IBM 7044 as a <b>peripheral</b> <b>processor</b> throughput of the 7094 was more than doubled.|$|R
50|$|In general organization, the STAR {{was similar}} to CDC's earlier supercomputers, where a simple CPU was {{supported}} by a number of <b>peripheral</b> <b>processors</b> that offloaded housekeeping tasks and allowed the CPU to crunch numbers as quickly as possible. In the STAR, both the CPU and <b>peripheral</b> <b>processors</b> were deliberately further simplified, to lower the cost and complexity of implementation. The STAR also differed from the earlier designs by being based on a 64-bit architecture instead of 60-bit, a side effect of the increasing use of 8-bit ASCII processing. Also unlike previous machines, the STAR made heavy use of microcode and also supported a virtual memory capability.|$|R
5000|$|The central {{processor}} (CPU) and central memory (CM) operated in units of 60-bit words. In CDC lingo, the term [...] "byte" [...] referred to 12-bit entities (which {{coincided with the}} word size used by the <b>peripheral</b> <b>processors).</b> Characters were six bits, operation codes were six bits, and central memory addresses were 18 bits. Central processor instructions were either 15 bits or 30 bits.The 18-bit addressing inherent to the Cyber 170 series imposed a limit of 262,144 (256K) words of main memory, which was semiconductor memory in this series. The {{central processor}} had no I/O instructions, relying upon the <b>peripheral</b> <b>processor</b> (PP) units to do I/O.|$|R
30|$|Our {{primary source}} of data is the <b>Input</b> <b>Output</b> Transaction Table of 2007 – 08 {{published}} by Central Statistical Organization (CSO 2012), Government of India. This is a 130 X 130 commodity matrix used for <b>Input</b> <b>Output</b> Analysis.|$|R
50|$|Internally, COS {{was divided}} into a very small message-passing EXEC, {{and a number of}} System Task Processors (STP tasks). Each STP task was similar in nature to the <b>peripheral</b> <b>processor</b> {{programs}} in earlier Control Data operating systems.|$|R
40|$|The use of {{measures}} originally suggested by Bennet, Bowley, and Hicks {{in the context}} of cost of living, welfare, and consumer surplus measurement to measure <b>inputs,</b> <b>outputs,</b> and productivity is examined. Suitably normalized versions of the Bennet-Bowley measures are shown to be exact and superlative measures of <b>input,</b> <b>output,</b> and productivity indicators. <b>Input</b> and <b>output</b> measurement, Productivity measurement, Directional distance functions. ...|$|R
5000|$|The general {{conclusion}} from this example {{and a similar}} example for the output resistance case is:A parallel feedback connection at the <b>input</b> (<b>output)</b> decreases the <b>input</b> (<b>output)</b> resistance by a factor ( [...] 1 + β AOL [...] ), where AOL = open loop gain.|$|R
