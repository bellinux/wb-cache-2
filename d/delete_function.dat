19|74|Public
25|$|As noted above, {{there is}} no {{placement}} delete expression. It {{is not possible to}} call any placement operator <b>delete</b> <b>function</b> using a delete expression.|$|E
25|$|In {{all of the}} overloads, {{the first}} {{parameter}} to the operator <b>delete</b> <b>function</b> is of type , which is {{the address of the}} storage to deallocate.|$|E
25|$|Destroying {{an object}} whose storage is {{allocated}} {{in such a}} fashion requires some care. Because there is no placement delete expression, one cannot use it to invoke the custom deallocator. One must either write a destruction function that invokes the custom deallocator, or call the placement <b>delete</b> <b>function</b> directly, as a function call.|$|E
2500|$|There {{are also}} {{placement}} <b>delete</b> <b>functions.</b> They are overloaded {{versions of the}} non-placement <b>delete</b> <b>functions.</b> The non-placement <b>delete</b> <b>functions</b> are declared as: ...|$|R
5000|$|There {{are also}} {{placement}} <b>delete</b> <b>functions.</b> They are overloaded {{versions of the}} non-placement <b>delete</b> <b>functions.</b> The non-placement <b>delete</b> <b>functions</b> are declared as: void operator delete (void *) throw (...) void operator delete (void *) throw (...) ...|$|R
25|$|The {{placement}} <b>delete</b> <b>functions</b> {{are called}} from placement new expressions. In particular, {{they are called}} if the constructor of the object throws an exception. In such a circumstance, {{in order to ensure}} that the program does not incur a memory leak, the placement <b>delete</b> <b>functions</b> are called. A placement new expression first calls the placement operator new function, then calls the constructor of the object upon the raw storage returned from the allocator function. If the constructor throws an exception, it is necessary to deallocate that storage before propagating the exception back to the code that executed the placement new expression, and that is the purpose of the placement <b>delete</b> <b>functions.</b>|$|R
25|$|A common {{error is}} {{to attempt to}} use a delete {{expression}} to delete the object. This results in the wrong operator <b>delete</b> <b>function</b> being called. Dewhurst recommends two strategies for avoiding this error. The first {{is to ensure that}} any custom allocators rely upon the Standard C++ library's global, non-placement, operator new, and are thus nothing more than simple wrappers around the C++ library's memory management. The second is to create new and delete functions for individual classes, and customize memory management via class function members rather than by using the placement syntax.|$|E
2500|$|Any new {{expression}} {{that uses the}} placement syntax is a placement new expression, and any operator new or operator <b>delete</b> <b>function</b> that takes more than the mandatory first parameter ( [...] and , respectively) is a placement new or placement <b>delete</b> <b>function.</b>|$|E
2500|$|The {{placement}} <b>delete</b> <b>function</b> that {{is called}} matches the placement new function that was invoked by the placement new expression. So, for example, if the following code is executed, the placement <b>delete</b> <b>function</b> {{that is called}} will be operator delete(void *, const A &): ...|$|E
25|$|For {{both the}} new and the <b>delete</b> <b>{{functions}},</b> the functions are global, are not in any namespace, {{and do not have}} static linkage.|$|R
5000|$|Automatic {{creation}} of Enterprise Data Widgets based on schema import. Each widget can display {{data from a}} database table as a grid or edit form. Edit form implements create, update, <b>delete</b> <b>functions</b> automatically.|$|R
25|$|This is why {{the pointer}} {{placement}} <b>delete</b> <b>functions</b> are defined as no-operations by the Standard C++ library. Since the pointer placement new functions do not allocate any storage, there is no storage to be deallocated {{in the event of}} the object's constructor throwing an exception.|$|R
2500|$|The latter {{would involve}} simply writing the {{destructor}} invocation and <b>delete</b> <b>function</b> call into the program: ...|$|E
2500|$|The [...] "placement" [...] {{versions}} of the new and delete operators and functions are known as placement new and placement delete. A new expression, placement or otherwise, calls a new function, {{also known as a}}n allocator function, whose name is operator new. Similarly, a delete expression calls a <b>delete</b> <b>function,</b> also known as a deallocator function, whose name is operator delete.|$|E
2500|$|If no {{matching}} placement <b>delete</b> <b>function</b> exists, no deallocation {{function is}} {{called in the}} event of an exception being thrown by a constructor within a placement new expression. There are also some (older) C++ implementations that do not support placement delete (which, like the exception-throwing allocator functions, were an addition made to C++ when it was standardized) at all. In both such situations, an exception being thrown by a constructor when allocating using a custom allocator will result in a memory leak. [...] (In the case of the older C++ implementations, a memory leak will also occur with non-placement new expressions.) ...|$|E
50|$|Queries: Riak {{provides}} a REST-ful API through HTTP and Protocol Buffers for basic PUT, GET, POST, and <b>DELETE</b> <b>functions.</b> More complex queries are also possible, including secondary indexes, search (via Apache Solr), and MapReduce. MapReduce has native support for both JavaScript (using the SpiderMonkey runtime) and Erlang.|$|R
50|$|Zeus Assembler {{was well}} {{received}} by the computing press. Your Computer praised it as well thought-out, with good auto-line number, renumber, and block <b>delete</b> <b>functions.</b> Sinclair User and Big K highlighted the program's ease of use for beginners, while also being a very powerful tool {{in the hands of}} an expert. The necessity of exiting the assembler in order to save any generated code was cited as a potential drawback, especially for beginners.|$|R
50|$|The {{interface}} {{was again}} updated to include easier custom configuration for the preferences and settings. The most notable upgrade to the 4.0 version was {{the addition of}} the automatic check for updates feature. This release also included enhanced password security, an improvement in the destroying and <b>deleting</b> <b>function</b> when bleaching, and increased efficiency in cleaning sweeps overall. Version 4.0 made Window Washer compatible with AOL 7.0 beta, Netscape 6.1, Windows XP, and Internet Explorer 6.0.|$|R
5000|$|Any [...] {{expression}} {{that uses the}} placement syntax is a placement [...] expression, and any [...] or [...] function that takes more than the mandatory first parameter (std::size_t and void *, respectively) is a placement new or placement <b>delete</b> <b>function.</b>|$|E
5000|$|The latter {{would involve}} simply writing the {{destructor}} invocation and <b>delete</b> <b>function</b> call into the program:A arenaT * p = new (arena) T/* .../p->~T (...) // First invoke the destructor explicitly.operator delete(p, arena) // Then call the deallocator function indirectly via operator delete(void *, A &) [...]|$|E
50|$|Destroying {{an object}} whose storage is {{allocated}} {{in such a}} fashion requires some care. Because there is no placement delete expression, one cannot use it to invoke the custom deallocator. One must either write a destruction function that invokes the custom deallocator, or call the placement <b>delete</b> <b>function</b> directly, as a function call.|$|E
50|$|NoSQLz only {{provides}} basic Create, read, update and <b>delete</b> (CRUD) <b>functions.</b> It {{is designed}} to be very straightforward and easy to implement.|$|R
5000|$|A common {{error is}} {{to attempt to}} use a delete {{expression}} to delete the object. This results in the wrong [...] function being called. Dewhurst recommends two strategies for avoiding this error. The first {{is to ensure that}} any custom allocators rely upon the Standard C++ library's global, non-placement, , and are thus nothing more than simple wrappers around the C++ library's memory management. The second is to create new and <b>delete</b> <b>functions</b> for individual classes, and customize memory management via class function members rather than by using the placement syntax.|$|R
5000|$|... #Subtitle level 4: Explicitly {{defaulted}} and <b>deleted</b> special member <b>functions</b> ...|$|R
5000|$|As many Apple {{keyboards}} lack {{a dedicated}} key for the forward <b>delete</b> <b>function,</b> Mac users wishing {{to have a}} dedicated forward delete key can reassign the forward-delete function to a different key using various third-party applications, such as DoubleCommand or PowerKey. For example, installing and enabling the DoubleCommand application allows the user to use the , [...] or numeric keypad [...] keys as a forward delete key.|$|E
5000|$|In other cases, the Delete key {{is in its}} {{original}} IBM notebook position of above {{and to the right}} of the Backspace key. Many laptops add rows of smaller keys above the Function key line to add keys on a non-standard size keyboard. On this row of smaller keys, the position of the Delete key is positioned at or near the right-hand end. On Apple's line of laptops (e.g. the MacBook and MacBook Pro), the forward <b>delete</b> <b>function</b> can be achieved using the [...] key combination.|$|E
5000|$|If no {{matching}} placement <b>delete</b> <b>function</b> exists, no deallocation {{function is}} {{called in the}} event of an exception being thrown by a constructor within a placement [...] expression. There are also some (older) C++ implementations that do not support placement delete (which, like the exception-throwing allocator functions, were an addition made to C++ when it was standardized) at all. In both such situations, an exception being thrown by a constructor when allocating using a custom allocator will result in a memory leak. (In the case of the older C++ implementations, a memory leak will also occur with non-placement [...] expressions.) ...|$|E
30|$|Operators may retain {{replicated}} environments to skip step 2 in {{the next}} verification when there are sufficient physical resources for virtual resource deployment. Otherwise, operators may delete replicated virtual resources after patch verification {{if they do not}} have a lot of physical resources. By deleting virtual resources on which patch verification is already completed, operators can verify patches implemented on other user virtual environments using the same physical resources. Because OpenStack Heat provides a stack-delete API, operators can delete virtual resources directly by one OpenStack API call. Note that AVFs do not have to provide <b>deleting</b> <b>functions</b> of virtual resources.|$|R
40|$|International Telemetering Conference Proceedings / October 14 - 16, 1980 / Bahia Hotel, San Diego, CaliforniaThe Brine Measuring System-Environmental Monitoring and Data Acquisition System (BRIMS-EMDAS) {{being used}} at the Bryan Mound, Texas, National Strategic Oil Reservoir {{will be used as}} an example to {{demonstrate}} the system features of a remote monitoring and data communications system. A buoy-mounted telemetry system is used to measure ocean temperature, conductivity and flow required for monitoring salinity levels near pumped brine outputs. The monitoring and communication system described in this presentation provides computer-to-computer communication via network as well as remote user display of data inventory, configuration and engineering unit data. The system stresses ease in configuration and inventory control. Configuration make, change and list functions and inventory list, archive and <b>delete</b> <b>functions</b> are provided...|$|R
40|$|Abstract. In {{order to}} make the food safety testing {{instrument}} more flexible and convenient and process a lot of data, combining the advantages of the VB interface design and MATLAB secondary development, the serial communication software is developed based food safety testing instrument. The test data is uploaded to computer through RS 232 serial port. The research staff needs only to input the parameters simply, and all the parameters were automatically matching with the testing instrument, the test data reception, processing, preservation, search and <b>delete</b> <b>functions</b> was completed through VB calling MATLAB. The software has the abilities of friendly interface, easy to use, high stability, and can shield and correct the misuse of users. It has high value in engineering and can be widely used in similar embedded test instrument...|$|R
50|$|The <b>delete</b> <b>function</b> in most {{operating}} systems simply marks the space {{occupied by the}} file as reusable (removes the pointer to the file) without immediately removing any of its contents. At this point the file can be fairly easily recovered by numerous recovery applications. However, once the space is overwritten with other data, there is no known way to use software to recover it. It cannot be done with software alone since the storage device only returns its current contents via its normal interface. Gutmann claims that intelligence agencies have sophisticated tools, including magnetic force microscopes, which together with image analysis, can detect the previous values of bits on the affected area of the media (for example hard disk).|$|E
5000|$|However, if {{only this}} API call were modified, the server {{would end up}} {{fetching}} incorrect data following any database update actions: the Memcached [...] "view" [...] of the data would become out of date. Therefore, in addition to creating an [...] "add" [...] call, an update call would also be needed using the Memcached set function. function update_foo(int userid, string dbUpdateString) /* first update database */ result = db_execute(dbUpdateString) if result /* database update successful : fetch data to be stored in cache */ data = db_select("SELECT * FROM users WHERE userid = ?", userid) /* the previous line could also look like data = createDataFromDBString(dbUpdateString) */ /* then store in cache until next get */ memcached_set("userrow:" [...] + userid, data)This call would update the currently cached data to match the new data in the database, assuming the database query succeeds. An alternative approach would be to invalidate the cache with the Memcached <b>delete</b> <b>function,</b> so that subsequent fetches result in a cache miss. Similar action {{would need to be}} taken when database records were deleted, to maintain either a correct or incomplete cache.|$|E
40|$|When {{most people}} go {{to the trouble of}} getting erasure tools to remove data from their hard drives they expect the job is done correctly. Using erasure tools is a step to protect privacy by {{assuming}} the applied tools erase data rather than simply delete data that may be recovered using forensic tools. In this research we tested the performance of the <b>delete</b> <b>function</b> on three web browsers against the performance of eight erasure tools with alarming results. It was found that the erasure tools had almost the same capability to delete data as the web browsers delete function; and that no tool actually erased data. The implications for people using these tools to protect sensitive data are profound. People and organisations as they retire, sell or dispose of their hardware containing information assets require assurance they will not be impacted by the adverse effects of unintended disclosure of sensitive information. Better software solutions are required and better software certification measures require implementation...|$|E
50|$|An August 2009 {{study by}} the Social Science Research Network found that 50% of {{websites}} using Flash were also employing flash cookies, yet privacy policies rarely disclosed them, and user controls for privacy preferences were lacking. Most browsers' cache and history <b>delete</b> <b>functions</b> do not affect Flash Player's writing Local Shared Objects to its own cache, and the user community is much less aware of the existence and function of Flash cookies than HTTP cookies. Thus, users having deleted HTTP cookies and purged browser history files and caches may {{believe that they have}} purged all tracking data from their computers when in fact Flash browsing history remains. As well as manual removal, the BetterPrivacy addon for Firefox can remove Flash cookies. Adblock Plus can be used to filter out specific threats and Flashblock can be used to give an option before allowing content on otherwise trusted sites.|$|R
40|$|Dynamic memory usage in C++ {{can lead}} to unrecovered allocations. A method of {{overloading}} the builtin new and <b>delete</b> <b>functions</b> is introduced that can ameliorate this problem. 1 Introduction This approach was originally implemented in half a day {{a number of years}} ago (at a company that no longer exists.) It has evolved and matured over the intervening years into something that is only mildly better than the original. A need locate memory leaks was identified in a long-running program (a highly optimizing, retargetable compiler [1].) This sense of a "leak" was dynamic memory being newed without being deleted. The executable size quickly outgrew the size of memory in the machine, requiring an undesirable amount of swapping activity. The program was written in C++ and was running on a UNIX machine. The first step to attacking the problem was to find where memory was being requested, used, and not returned. 2 Approach In C++, it is easy to overload the builtin new and delete operators wit [...] ...|$|R
3000|$|... {{and assume}} that this {{derivative}} is well defined. We make the following assumptions on the utility <b>functions</b> (<b>deleting</b> superscripts to ease notation if a condition holds for both partners): [...]...|$|R
