10000|1131|Public
5|$|A perl <b>executable</b> is {{included}} in several Windows Resource kits in the directory with other scripting tools.|$|E
5|$|A {{memory dump}} of Mini vMac can be {{obtained}} with Linux ckpt or a similar tool after the Agrippa program has been loaded. The <b>executable</b> code could be reverse engineered.|$|E
5|$|Most {{software}} {{that runs on}} Linux can run on FreeBSD using an optional built-in compatibility layer. Hence, most Linux binaries can be run on FreeBSD, including some proprietary applications distributed only in binary form. This compatibility layer is not an emulation; Linux's system call interface is implemented in the FreeBSD's kernel and hence, Linux <b>executable</b> images and shared libraries are treated the same as FreeBSD's native <b>executable</b> images and shared libraries. Additionally, FreeBSD provides compatibility layers for several other Unix-like operating systems, in addition to Linux, such as BSD/OS and SVR4, however, it is more common for users to compile those programs directly on FreeBSD.|$|E
40|$|A serious {{security}} threat today is malicious <b>executables,</b> especially new, unseen malicious <b>executables.</b> Many {{of these new}} malicious <b>executables</b> are undetectable by current anti-virus systems {{because they do not}} contain signatures for these new instances of malicious programs. These new malicious <b>executables</b> are created every day, and thus pose a serious {{security threat}}. We present a framework that detects new, previously unseen malicious <b>executables.</b> Comparing our detection methods with a traditional signature-based method, our method more than doubles the current detection rates for new malicious <b>executables.</b> ...|$|R
40|$|Detecting unknown {{malicious}} <b>executables</b> is {{a challenging}} task. Traditional anti-virus systems use signatures to detect malicious <b>executables.</b> However, the method cannot detect unseen instances or variants. Inspired by biological immune systems, an immune-based approach for detection of unknown malicious <b>executables</b> is proposed in this paper, which {{is referred to}} MEDMI. The approach can use the benign <b>executables</b> to be the training set for building {{the profile of the}} system and then generates detectors to detect malicious <b>executables.</b> The experiments comparing with different detection methods show that the approach provides an effective novel solution to detect malicious <b>executables...</b>|$|R
5000|$|DynInst is a runtime code-patching library that {{is useful}} in {{developing}} dynamic program analysis probes and applying them to compiled <b>executables.</b> Dyninst does not require source code or recompilation in general, however, non-stripped <b>executables</b> and <b>executables</b> with debugging symbols are easier to instrument.|$|R
5|$|As can be {{seen from}} the diagram, the unusual shape of the Paragon made it very {{complicated}} to build. Engineering and factory translated the design into one <b>executable</b> on the shop floor. After overcoming the manufacturing challenges posed by the curved refractor panels and the cabinet legs, the speaker entered production in late 1957.|$|E
5|$|In early {{versions}} of Perl, database interfaces {{were created by}} relinking the interpreter with a client-side database library. This was sufficiently difficult that it was done {{for only a few}} of the most-important and most widely used databases, and it restricted the resulting perl <b>executable</b> to using just one database interface at a time.|$|E
5|$|PHP code may be {{embedded}} into HTML or HTML5 markup, {{or it can}} be used {{in combination}} with various web template systems, web content management systems and web frameworks. PHP code is usually processed by a PHP interpreter implemented as a module in the web server or as a Common Gateway Interface (CGI) <b>executable.</b> The web server software combines the results of the interpreted and executed PHP code, which may be any type of data, including images, with the generated web page. PHP code may also be executed with a command-line interface (CLI) and can be used to implement standalone graphical applications.|$|E
50|$|Current version <b>executables</b> are {{interpreted}} and require no runtime libraries be {{installed on the}} end-user's computer. A planned future version will have compiled <b>executables.</b>|$|R
5000|$|... #!/usr/local/bin/scsh -s!#(define (<b>executables</b> dir) (with-cwd dir (filter file-executable? (directory-files dir #t))))(define (writeln x) (display x) (newline))(for-each writeln (append-map <b>executables</b> ((infix-splitter [...] ":") (getenv [...] "PATH")))) ...|$|R
40|$|A serious {{security}} threat today is malicious <b>executables,</b> especially neH: unseen malicious <b>executables</b> often arriving as eniail attachments. These new malicious <b>executables</b> are created {{at the rate}} of thousands even year and pose a serious {{security threat}}. Current anti-virus systems attempt to detect these new malicious programs with heuristics generated by hand. This approach is costly and oftentimes ineffective. In this papec we present a data-mining framework that detects new, previously unseen malicious <b>executables</b> accurately and automatically. The data-mining framework antoniaticall?~foitrid patterns in our data set and used these patterns to detect a set of new malicious binaries. Coniparing our detection methods with a traditional signaturebased method, our method more than doubles the current detection ratesfor new malicious <b>executables.</b> ...|$|R
5|$|Perl is {{implemented}} as a core interpreter, written in C, {{together with a}} large collection of modules, written in Perl and C. , the interpreter is 150,000 lines of C code and compiles to a 1MB <b>executable</b> on typical machine architectures. Alternatively, the interpreter can be compiled to a link library and embedded in other programs. There are nearly 500 modules in the distribution, comprising 200,000 lines of Perl and an additional 350,000 lines of C code (much of the C code in the modules consists of character encoding tables).|$|E
5|$|Titan is {{available}} for any scientific purpose; access depends {{on the importance of}} the project and its potential to exploit the hybrid architecture. Any selected programs must also be <b>executable</b> on other supercomputers to avoid sole dependence on Titan. Six vanguard programs were the first selected. They dealt mostly with molecular scale physics or climate models, while 25 others were queued behind them. The inclusion of GPUs compelled authors to alter their programs. The modifications typically increased the degree of parallelism, given that GPUs offer many more simultaneous threads than CPUs. The changes often yield greater performance even on CPU-only machines.|$|E
5|$|The PC {{version of}} Metal Gear Solid was {{released}} in North America, Europe and Asia in late 2000. This version was published by Microsoft Game Studios and developed by Digital Dialect. It supports {{the use of a}} keyboard or a USB game controller with at least six buttons (with the manual recommending the Sidewinder Game Pad Pro). It also supports Direct3D-capable video cards, allowing for a high resolution of up to 1024x768. The PC version is simply labelled Metal Gear Solid on the packaging, but the actual game uses the Metal Gear Solid: Integral logo, although it has some differences as well from the PlayStation version of Integral and lacks some of its content. The biggest change was reducing the number of discs from three to two, which was done by giving each disc two separate <b>executable</b> files, one for the main game (mgsi.exe) and the other for the VR training portion (mgsvr.exe), thus eliminating the need for a stand-alone third disc.|$|E
50|$|FreeDOS {{is mostly}} {{compatible}} with MS-DOS. It supports COM <b>executables,</b> standard DOS <b>executables</b> and Borland's 16-bit DPMI <b>executables.</b> It {{is also possible}} to run 32-bit DPMI <b>executables</b> using DOS extenders. The operating system has several improvements relative to MS-DOS, mostly involving support of newer standards and technologies {{that did not exist}} when Microsoft ended support for MS-DOS, such as internationalization, or the Advanced Power Management TSRs. Furthermore, with use of HX DOS Extender, many Win32 console applications function properly in FreeDOS, as do some rare GUI programs, like QEMU and Bochs.|$|R
50|$|While {{designed}} for 16-bit OSes, NE <b>executables</b> can be run on 32-bit Windows. Beginning with Windows Vista, icon resources inside New <b>Executables</b> are not extracted and shown {{even by the}} 32-bit shell. 64-bit versions of Windows completely lack native support for running NE <b>executables,</b> because 64-bit Windows cannot run 16-bit programs on the processor {{without the help of}} an emulator.|$|R
50|$|Due to the {{framework}} being cross-platform compatible, {{the same source}} code and form design {{can be used to}} deploy to the various platforms it supports. It natively supports 32-bit and 64-bit <b>executables</b> on Windows, and 32-bit <b>executables</b> on macOS and iOS, as well as native <b>executables</b> on Android. FireMonkey includes platform services that adapt the user interface to the correct behavior and appearance on each target platform.|$|R
5|$|The {{encryption}} {{resembles the}} RSA algorithm. This algorithm encodes data in 3-byte blocks. First, the each byte is permuted through an 8-position permutation, then the bits are {{split into two}} 12-bit integers (by taking the low 4 bits of the second byte and the 8 bits of the first byte as the first 12-bit integer, and the 8 bits of the third byte and the 4 high bits of the second integer as the second 12-bit integer). Each is individually encrypted by taking them to the 3491st power, mod 4097; the bits are then reassembled into 3 bytes. The encrypted text is then stored in a string variable {{as part of the}} program. To shroud the would be visible and noticeable text it is compressed with the simple Lzw before final storage. As the Macintosh Common Lisp compiler compresses the main program code into the <b>executable,</b> this was not that necessary.|$|E
25|$|In Linux, kernel may destroy {{memory map}} of the old process and start {{constructing}} (loading) new <b>executable,</b> and only then discover that the new <b>executable</b> can't be loaded (for example, some fields in executable's internal tables contain invalid values). In this case, process gets killed by a fatal signal (such as SIGSEGV). Ideally, kernel should fail evecve and return error indication in old <b>executable,</b> but this would require significantly more complex (and slower) code in the kernel.|$|E
25|$|<b>Executable</b> space {{protection}} {{does not}} generally protect against return-to-libc attacks, {{or any other}} attack which does not rely on {{the execution of the}} attackers code. However, on 64-bit systems using ASLR, as described below, <b>executable</b> space protection makes it far more difficult to execute such attacks.|$|E
5000|$|Executing {{programs}} that use parallelization on machines {{that do not}} have Absoft Fortran installed requires inclusion of [...] for 32-bit <b>executables</b> or, for 64-bit <b>executables,</b> [...] This library is distributed under the LGPL 2.1.|$|R
5000|$|... py2exe is a Python {{extension}} which converts Python scripts (.py) into Microsoft Windows <b>executables</b> (.exe). These <b>executables</b> can run on {{a system}} without Python installed. It {{is the most common}} tool for doing so.|$|R
5000|$|To run an {{application}} portably under PNaCl, {{it must be}} compiled to an architecture-agnostic and stable subset of the LLVM intermediate representation bytecode. The <b>executables</b> are called PNaCl <b>executables</b> (pexes). The PNaCl Toolchain makes [...]pexe files; NaCl Toolchain [...]nexe files. The magic number of [...]nexe files is 0x7F 'E' 'L' 'F', which is ELF. In Chrome, they are translated to architecture-specific <b>executables</b> {{so that they can}} be run.|$|R
25|$|Self-extracting {{archives}} (including the <b>executable</b> installer of 7-Zip itself) {{are vulnerable}} to arbitrary code execution through DLL hijacking: they load and run a DLL named UXTheme.dll, {{if it is in}} the same folder as the <b>executable</b> file. 7-Zip 16.03 Release notes say that the installer and SFX modules have added protection against DLL preloading attack.|$|E
25|$|<b>Executable</b> space {{protection}} is {{an approach to}} buffer overflow protection which prevents execution of code on the stack or the heap. An attacker may use buffer overflows to insert arbitrary code into {{the memory of a}} program, but with <b>executable</b> space protection, any attempt to execute that code will cause an exception.|$|E
25|$|A shared {{library or}} shared object is a file that is {{intended}} to be shared by <b>executable</b> files and further shared object files. Modules used by a program are loaded from individual shared objects into memory at load time or run time, rather than being copied by a linker when it creates a single monolithic <b>executable</b> file for the program.|$|E
50|$|They are {{currently}} limited to Win32 and Lin64 <b>executables</b> due to technical {{limitations of the}} developer's system. Each release comes with the full source code, however, so players can build <b>executables</b> for any operating system.|$|R
40|$|There {{is growing}} {{interest}} in analyzing <b>executables</b> to look for bugs and security vulnerabilities. This paper describes the design and implementation of a language for describing the semantics of an instruction set, along with a runtime system to support the static analysis of <b>executables</b> written in that instruction set. The work advances {{the state of the}} art by creating multiple analysis phases from a specification of the concrete operational semantics of the language to be analyzed. By exploiting this powerful infrastructure for creating analysis components, it will be possibly for recently developed analysis techniques for analyzing <b>executables</b> to be applied more broadly, to <b>executables</b> written in a variety of instructions sets...|$|R
50|$|Asmutils is a rewrite of the {{standard}} Unix commands in assembly language aimed to have smallest possible size of ELF <b>executables.</b> All standard Unix commands (ls, cat, sh, etc.) <b>executables</b> are less than one kilobyte in size.|$|R
25|$|The {{possibility}} of embedding <b>executable</b> objects inside otherwise non-executable file formats can make opening those files a risk.|$|E
25|$|Loaders for shared {{libraries}} {{vary widely}} in functionality. Some {{depend on the}} <b>executable</b> storing explicit paths to the libraries. Any change to the library naming or layout of the file system will cause these systems to fail. More commonly, only {{the name of the}} library (and not the path) is stored in the <b>executable,</b> with the operating system supplying a method to find the library on-disk based on some algorithm.|$|E
25|$|Use of an {{optimizing}} compiler {{tends to}} ensure that the <b>executable</b> program is optimized {{at least as much as}} the compiler can predict.|$|E
50|$|StarForce 3.0 {{drivers are}} {{installed}} with certain older game demos, freeware and downloadable games, like TrackMania Nations. Their presence {{is intended to}} prevent crackers from using demo <b>executables</b> to help break retail <b>executables</b> (as the two will usually be quite similar).|$|R
40|$|Abstract. There {{is growing}} {{interest}} in analyzing <b>executables</b> to look for bugs and security vulnerabilities. This paper describes the design and implementation of a language for describing the semantics of an instruction set, along with a runtime system to support the static analysis of <b>executables</b> written in that instruction set. The work advances {{the state of the}} art by creating multiple analysis phases from a specification of the concrete operational semantics of the language to be analyzed. By exploiting this powerful infrastructure for creating analysis components, it will be possibly for recently developed analysis techniques for analyzing <b>executables</b> to be applied more broadly, to <b>executables</b> written in a variety of instructions sets. ...|$|R
50|$|Apple's Mac OS X and iOS fully support PIE <b>executables</b> as of {{versions}} 10.7 and 4.3, respectively; {{a warning}} is issued when non-PIE iOS <b>executables</b> are submitted for approval to Apple's App Store but there's no hard requirement yet and non-PIE applications are not rejected.|$|R
