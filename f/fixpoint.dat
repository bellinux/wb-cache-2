1631|260|Public
25|$|<b>Fixpoint</b> logic extends first-order logic {{by adding}} the closure under the least fixed points of {{positive}} operators.|$|E
5000|$|Kantorovitch <b>fixpoint</b> theorem (known also as Tarski-Kantorovitch <b>fixpoint</b> principle) ...|$|E
50|$|Every order-preserving self-map f of a cpo (P, ⊥) has a least <b>fixpoint.</b> If f is {{continuous}} {{then this}} <b>fixpoint</b> {{is equal to}} the supremum of the iterates (⊥, f(⊥), f(f(⊥)), … fn(⊥), …) of ⊥ (see also the Kleene <b>fixpoint</b> theorem).|$|E
40|$|AbstractIn this paper, we {{investigate}} the structural {{properties of the}} set of <b>fixpoints</b> for the class of nondeterministic recursive definitions. Our study reveals close resemblance between the structural properties of the set of <b>fixpoints</b> {{and those of the}} set of prefixpoints, and it establishes some equality relationships between various <b>fixpoints</b> and their corresponding prefixpoints. Also observed are some nonequality relationships between various <b>fixpoints</b> and their corresponding postfixpoints...|$|R
2500|$|Viscosity measurement, {{viscosity}} {{units and}} <b>fixpoints,</b> glass viscosity calculation ...|$|R
40|$|We {{present a}} new model {{checking}} algorithm for verifying computation tree logic (CTL) properties. Our technique is based on using language inference to learn the <b>fixpoints</b> necessary for checking a CTL formula instead of computing them iteratively as is done in traditional model checking. This allows us to analyze infinite or large state-space systems where the traditional iterations may not converge or may take too long to converge. We allow fairness constraints to be specified for verification of various liveness properties. The main challenge in developing a learning based model checking algorithm for CTL is that CTL properties express nested <b>fixpoints.</b> We overcome this challenge by developing a new characterization of CTL properties in terms of functions that have unique <b>fixpoints.</b> We instantiate our technique to systems in which states are encoded as strings and use a regular inference algorithm to learn the CTL <b>fixpoints.</b> We prove that if the <b>fixpoints</b> have a regular representation, our procedure will always terminate with the correct answer. We have extended our LEVER tool to use the technique {{presented in this paper}} and demonstrate its effectiveness by verifying a number of parametric and integer systems...|$|R
50|$|The least <b>fixpoint</b> of f is {{the least}} element x such that f(x) = x, or, equivalently, such that f(x) ≤ x; the dual holds for the {{greatest}} <b>fixpoint,</b> the greatest element x such that f(x) = x.|$|E
5000|$|... {{holds in}} any state in any set [...] such that, when the {{variable}} [...] is set to , then [...] holds for all of [...] (From the Knaster-Tarski theorem it follows that [...] is the greatest <b>fixpoint</b> of , and [...] its least <b>fixpoint.)</b> ...|$|E
50|$|In {{theoretical}} computer science, the modal μ-calculus (Lμ, Lμ, {{sometimes just}} μ-calculus, although this {{can have a}} more general meaning) {{is an extension of}} propositional modal logic (with many modalities) by adding a least <b>fixpoint</b> operator μ and a greatest <b>fixpoint</b> operator , thus a fixed-point logic.|$|E
40|$|We first {{present a}} first-order modal µ-calculus which uses parameterised maximal and minimal <b>fixpoints</b> to {{describe}} safety and liveness properties of processes which communicate values along ports. Then, using {{a class of}} models based on symbolic graphs, we give a local model checking proof system for this logic. The system is {{a natural extension of}} existing proof systems and although it is sound it is incomplete in general. We prove two different completeness results for certain sub-logics. The first is for safety properties alone, where only parameterised maximal <b>fixpoints</b> are used while the second allows both kinds of <b>fixpoints</b> but restricts the use of parameterisation...|$|R
40|$|We study a {{splitting}} {{property of}} operators and <b>fixpoints.</b> In particular, we investigate {{the circumstances in}} which an operator defined on a product lattice can be split up in operators over the component lattices, and show how its various <b>fixpoints</b> can be obtained by composing the appropriate <b>fixpoints</b> of the component operators. In the context of a specific nonmonotonic logic, our theorem property translates into a compositionality theorem. Such properties have been investigated in the context of logic programming and answer set programming. We will show that our result generalises and abstracts some well-known results about splitting logic programs and answer set programs. status: publishe...|$|R
40|$|In {{this paper}} we develop an {{algebraic}} framework for studying semantics of nonmonotonic logics. Our approach is formulated {{in the language}} of lattices, bilattices, operators and <b>fixpoints.</b> The goal is to describe <b>fixpoints</b> of an operator O defined on a lattice. The key intuition is that of an approximation, a pair (x, y) of lattice elements which can be viewed as an approximation to each lattice element z such that x z y. The key notion is that of an approximating operator, a monotone operator on the bilattice of approximations whose <b>fixpoints</b> approximate the <b>fixpoints</b> of the operator O. The main contribution of the paper is an algebraic construction which assigns a certain operator, called the stable operator, to every approximating operator on a bilattice of approximations. This construction leads to an abstract version of the well-founded semantics. In the paper we show that our theory offers a unified framework for semantic studies of logic programming, default logic and autoepistemic logic...|$|R
50|$|Initial {{data types}} {{can be defined}} as being the least <b>fixpoint</b> (up to {{isomorphism}}) of some type equation; the isomorphism is then given by an initial algebra. Dually, final (or terminal) data types {{can be defined as}} being the greatest <b>fixpoint</b> of a type equation; the isomorphism is then given by a final coalgebra.|$|E
5000|$|If f(lim xn)=lim f(xn) for all {{ascending}} sequences xn, {{then the}} least <b>fixpoint</b> of f is lim fn(0) where 0 {{is the least}} element of L, thus giving a more [...] "constructive" [...] version of the theorem. (See: Kleene fixed-point theorem.) More generally, if f is monotonic, then the least <b>fixpoint</b> of f is the stationary limit of fα(0), taking α over the ordinals, where fα is defined by transfinite induction: fα+1 = f ( [...] fα) and fγ for a limit ordinal γ is the least upper bound of the fβ for all β ordinals less than γ. The dual theorem holds for the greatest <b>fixpoint.</b>|$|E
5000|$|<b>Fixpoint</b> {{semantics}} for logic programming, Theoretical Computer Science (journal), 278 (1-2), 25-51 (2002) Elsevier.|$|E
40|$|This paper characterizes {{connected}} {{components of}} both directed and undirected graphs as atomic <b>fixpoints.</b> As algebraic structure for our investigations we combine complete Boolean algebras with the well-known theory of Kleene Algebra with domain. Using diamond operators as an algebraic generalization of relational image and preimage we show how connected components can be modeled as atomic <b>fixpoints</b> of functions operating on tests and prove some advanced theorems concerning connected components...|$|R
40|$|Abstract The {{constructions of}} <b>fixpoints</b> and while-loops in a {{category}} of domains {{can be derived from}} the colimit, loop(f) of a diagram which consists of a single endomorphism f: D!D. If f is increasing then the colimiting map is the least-fixpoint function Y and loop(f) = f ix(f) the subobject of <b>fixpoints.</b> If f = cond(b; g; 1) is the conditional of a whileprogram then loop(f) = (D:b + loop 1 (g)) ? the lifted sum of the terminating values (where b is false) and the infinite loops. 1 <b>Fixpoints</b> Let Pos(!) the category of!-complete partial orders and continuous functions (bottomless c. p. o. 's). A bottom element (?) can be adjoined to such a poset D by lifting it to D?. Also, if g: D!D 0 ? is continuous then gΛ : D?!D 0 ? is the strict extension of g i. e. agrees with g on D and preserves? [4]. Let f: D!D be a continuous map in Pos(!). Its <b>fixpoints</b> are defined by fix(f) = fd 2 D j f d = dg. Categorically, this definition asserts that th...|$|R
2500|$|The {{following}} {{table lists}} common viscosity <b>fixpoints,</b> applicable to large-scale glass production and experimental glass melting in the laboratory: ...|$|R
50|$|Anonymous {{functions}} are {{a form of}} nested function, in allowing access to variables in {{the scope of the}} containing function (non-local variables). This means anonymous functions need to be implemented using closures. Unlike named nested functions, they cannot be recursive without the assistance of a <b>fixpoint</b> operator (also termed an anonymous <b>fixpoint</b> or anonymous recursion) or binding them to a name.|$|E
50|$|<b>Fixpoint</b> logic extends first-order logic {{by adding}} the closure under the least fixed points of {{positive}} operators.|$|E
50|$|Aiken and Murphy give a <b>fixpoint</b> {{algorithm}} {{to detect}} which nonterminals {{of a given}} regular tree grammar are unproductive.|$|E
40|$|This paper defines flows (or {{discrete}} dynamical systems) and cyclic {{flows in}} a category and investigates how the trajectories {{of a point}} might approach a cycle. The paper considers cyclic flows in the categories of Sets and of Boolean algebras and their duals and characterizes the Stone representation of a cyclic flow in Boolean algebras. A cyclic spectrum is constructed for Boolean flows. Examples include attractive <b>fixpoints,</b> repulsive <b>fixpoints,</b> strange attractors and the logistic equation...|$|R
40|$|AbstractDespite the {{frequent}} comment {{that there is}} no general agreement on the semantics of logic programs, this paper shows that a number of independently proposed extensions to the stable model semantics coincide: the regular model semantics proposed by You and Yuan, the partial stable model semantics by Saccà and Zaniolo, the preferential semantics by Dung, and a stronger version of the stable class semantics by Baral and Subrahmanian. We show that these equivalent semantics can be characterized simply as selecting a particular kind of stable classes, called normal alternating <b>fixpoints.</b> In addition, we indicate that almost all of the previously proposed semantic frameworks coincide with that of normal alternating <b>fixpoints.</b> Due to its simplicity and naturalness, the framework of normal alternating <b>fixpoints</b> offers great potential {{in the study of the}} semantics for various nonmonotonic systems...|$|R
40|$|ABSTRACT. This paper defines flows (or {{discrete}} dynamical systems) and cyclic {{flows in}} a category and investigates how the trajectories {{of a point}} might approach a cycle. The paper considers cyclic flows in the categories of Sets and of Boolean algebras and their duals and characterizes the Stone representation of a cyclic flow in Boolean algebras. A cyclic spectrum is constructed for Boolean flows. Examples include attractive <b>fixpoints,</b> repulsive <b>fixpoints,</b> strange attractors and the logistic equation...|$|R
50|$|SQL however officially {{supports}} such <b>fixpoint</b> queries since 1999, {{and it had}} vendor-specific extensions in {{this direction}} well before that.|$|E
50|$|Bisimilarity {{can also}} be defined in order {{theoretical}} fashion, in terms of <b>fixpoint</b> theory, more precisely as the greatest fixed point of a certain function defined below.|$|E
5000|$|Abstract interpretation, {{in which}} a system verifies an over-approximation of a {{behavioural}} property of the program, using a <b>fixpoint</b> computation over a (possibly complete) lattice representing it.|$|E
40|$|We {{present a}} tableau based proof system for TrTL, a trace based {{temporal}} logic with <b>fixpoints.</b> The proof system generalises similar systems for standard interleaving temporal logics with <b>fixpoints.</b> In our case special attention {{has to be}} given to the modal rule: First we give a system with an interleaving style modal rule, later we use a technique similar to the sleep set method (known from finite state model checking) to obtain a more efficient proof rule. We briefly highlight the relation of the improved rule with recent advances in tableau systems for classical propositional logic, the tamed cut of the system KE. The treatment of <b>fixpoints</b> leads to possibly infinite tableaux, which however can be finitely represented, yielding treelike structures with back loops: we show this using an automata construction. Indirectly we obtain a (known) decidability result...|$|R
40|$|We {{present a}} fast {{bottom-up}} algorithm to compute all <b>fixpoints</b> of a fuzzy closure operator in a finite set over a finite chain of truth degrees, {{along with the}} partial order {{on the set of}} all <b>fixpoints.</b> Fuzzy closure operators appear in several areas of fuzzy logic and its applications, including formal concept analysis (FCA) that we use as a reference area of application in this paper. Several problems in FCA, such as computing all formal concepts from data with graded attributes or computing non-redundant bases of all attribute dependencies, can be reduced to the problem of computing <b>fixpoints</b> of particular fuzzy closure operators associated with the input data. The development of a general algorithm that is applicable, in particular, to these problems is the ultimate purpose of this paper. We present the algorithm, its theoretical foundations, and experimental evaluation...|$|R
40|$|Summary. The Veblen {{hierarchy}} is {{an extension}} of the construction of epsilon numbers (<b>fixpoints</b> of the exponential map: ω ɛ = ɛ). It is a collection ϕα of the Veblen Functions where ϕ 0 (β) = ω β and ϕ 1 (β) = ɛβ. The sequence of <b>fixpoints</b> of ϕ 1 function form ϕ 2, etc. For a limit non empty ordinal λ the function ϕλ is the sequence of common <b>fixpoints</b> of all functions ϕα where α < λ. The Mizar formalization of the concept cannot be done directly as the Veblen functions are classes (not (small) sets). It is done with use of universal sets (Tarski classes). Namely, we define the Veblen functions in a given universal set and ϕα(β) as a value of Veblen function from the smallest universal set including α and β...|$|R
50|$|A {{hierarchical}} query {{is a type}} of SQL query {{that handles}} hierarchical model data. They are special cases of more general recursive <b>fixpoint</b> queries, which compute transitive closures.|$|E
5000|$|Now let [...] (u exists because D ⊆ L). Then for all x ∈ D {{it is true}} that x ≤ u and f(x) ≤ f(u), so x ≤ f(x) ≤ f(u). Therefore, f(u) is {{an upper}} bound of D, but u is the least upper bound, so u ≤ f(u), i.e. u ∈ D. Then f(u) ∈ D (because f(u) ≤ f(f(u))) and so f(u) ≤ u from which follows f(u) = u. Because every <b>fixpoint</b> is in D we have that u is the {{greatest}} <b>fixpoint</b> of f.|$|E
50|$|In particular, {{using the}} Knaster-Tarski {{principle}} one can develop {{the theory of}} global attractors for noncontractive discontinuous (multivalued) iterated function systems. For weakly contractive iterated function systems Kantorovitch <b>fixpoint</b> theorem suffices.|$|E
40|$|It is {{a classic}} result in lattice theory that a poset is a {{complete}} lattice iff it can be realized as <b>fixpoints</b> of a closure operator on a powerset. Dragalin [9, 10] observed that a poset is a locale (complete Heyting algebra) iff it can be realized as <b>fixpoints</b> of a nucleus on the locale of upsets of a poset. He also showed how to generate a nucleus on upsets by adding a structure of “paths” to a poset, forming {{what we call a}} Dragalin frame. This allowed Dragalin to introduce a semantics for intuitionistic logic that generalizes Beth and Kripke semantics. He proved that every spatial locale (locale of open sets of a topological space) can be realized as <b>fixpoints</b> of the nucleus generated by a Dragalin frame. In this paper, we strengthen Dragalin’s result and prove that every locale—not only spatial locales—can be realized as <b>fixpoints</b> of the nucleus generated by a Dragalin frame. In fact, we prove the stronger result that for every nucleus on the upsets of a poset, there is a Dragalin frame based on that poset that generates the given nucleus. We then compare Dragalin’s approach to generating nuclei with the relational approach of Fairtlough and Mendler [11], based on what we call FM-frames. Surprisingly, every Dragalin frame can be turned into an equivalent FM-frame, albeit on a different poset. Thus, every locale can be realized as <b>fixpoints</b> of the nucleus generated by an FM-frame. Finally, we consider the relational approach of Goldblatt [13] and characterize the locales that can be realized using Goldblatt frames...|$|R
5000|$|For a {{complete}} lattice [...] and a monotone function [...] on L, {{the set of}} all <b>fixpoints</b> of f is also {{a complete}} lattice , with: ...|$|R
40|$|We {{study the}} decidability and expressiveness issues of μ-calculus on data words and data ω-words. It is {{shown that the}} full logic {{as well as the}} {{fragment}} which uses only the least <b>fixpoints</b> are undecidable, while the fragment containing only greatest <b>fixpoints</b> is decidable. Two subclasses, namely BMA and BR, obtained by limiting the compositions of formulas and their automata characterizations are exhibited. Furthermore, Data-LTL and two-variable first-order logic are expressed as unary alternation-free fragment of BMA. Finally basic inclusions of the fragments are discussed...|$|R
