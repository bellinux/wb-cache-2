6|7|Public
50|$|Secure by design, in {{software}} engineering, {{means that the}} software has been designed {{from the ground up}} to be secure. Malicious practices are taken for granted and care is taken to minimize impact when a security vulnerability is discovered or on <b>invalid</b> <b>user</b> input.|$|E
50|$|In general, {{building}} robust {{systems that}} encompass every point of possible failure {{is difficult because}} of the vast quantity of possible inputs and input combinations. Since all inputs and input combinations would require too much time to test, developers cannot run through all cases exhaustively. Instead, the developer will try to generalize such cases. For example, imagine inputting some integer values. Some selected inputs might consist of a negative number, zero, and a positive number. When using these numbers to test software in this way, the developer generalizes the set of all reals into three numbers. This is a more efficient and manageable method, but more prone to failure. Generalizing test cases {{is an example of}} just one technique to deal with failure—specifically, failure due to <b>invalid</b> <b>user</b> input. Systems generally may also fail due to other reasons as well, such as disconnecting from a network.|$|E
30|$|Note that objects, actions, {{conditions}} and suspicions are all represented in multilevel hierachies. This allows correlations {{to operate on}} the level of granularity that is more convenient in each scenario. For example, if it is irrelevant to check if a login failure occurred due to an <b>invalid</b> <b>user</b> or an invalid password, than, the following taxonomies would be equivalent: user.admin:login.fail, user.admin:login.fail.pwd, and user.admin:login.fail.user. The use of hierarchical levels addresses this issue in an elegant manner, by making it possible to completely ignore the third level of the action hierarchy, reducing all the previous options simply to: user.admin:login.fail.|$|E
40|$|Part 3 : Extended AbstractsInternational audienceCurrently, {{there are}} many {{solutions}} for authentication. Mostly, the authentication protocols based on traditional cryptographic constructions, such as digital signatures, hash functions and symmetric encryption schemes, are used. To provide more privacy protection, credential systems were introduced. Using these systems, users can anonymously prove that they possess some attributes. The attributes can represent anything from the age of users to their citizenship or, e. g., driving license possession. The main problem of these systems is revocation since it is currently impossible to efficiently revoke <b>invalid</b> <b>users,</b> attackers or users who use stolen identities. In this paper, a novel conception for anonymous credentials with practical revocation is proposed...|$|R
30|$|Checking for {{image quality}} and {{validity}} among the user-uploaded images as users {{may not be aware}} the suitability of an image for image recognition. This automatic process will inspect each image to check whether it is blurred, texture-less or a duplicate of another category. If the image is unsuitable or <b>invalid,</b> the <b>users</b> will be informed.|$|R
40|$|The paper {{deals with}} {{reflection}} of relation among people in Czech public opinion. Great tolerance prevails towards religious people, {{young people and}} <b>invalids.</b> Romanies, alcoholics, <b>users</b> of drugs and people with criminal past create at least acceptable group. In long term tolerance increase, excepted Romanies. CR is placed in 14 position from 23 European countries from point of view tolerance...|$|R
40|$|History of {{networks}} {{dates back to}} the early 1970 ’s and due to the emerging ding demands placed on networks by administrators and users, securing the network becomes a necessity. In this research work we studied the various existing methods employed in securing private networks and came up with using radius server as a backbone to network security. A dedicated network was designed and the administrative and client networks on virtual LAN (VLAN) basis configured. This ultimately authenticates a valid user and rejects an <b>invalid</b> <b>user</b> from gaining access into the network using the method of authentication, authorization and accounting (AAA), while monitoring the valid user and keeping record of activities on the network...|$|E
40|$|In USENIX 2001, Boneh et al. {{introduced}} {{a new way of}} obtaining fast revocation for RSA keys {{with the help of a}} security mediator. In 2003, Boneh et al. also showed how to convert the security-mediated RSA encryption scheme into an identity-based mediated RSA encryption scheme. This new technique addressed the shortcoming of identity-based cryptography where revocation required appending the valid date for a user's keys together with his identity-string, allowing for instant revocation of <b>invalid</b> <b>user</b> keys. Subsequently, many security-mediated cryptographic primitives were proposed. Surprisingly however, no work has yet to be done to address security-mediated identity-based identification schemes despite more than a decade has passed since this feature was incorporated into encryption and signature primitives. In this paper, we provide that contribution by defining the appropriate security notions for achieving fast revocation for identity-based identification schemes. Subsequently we show a concrete scheme that achieves these security notions under provable security...|$|E
40|$|The C++ {{programming}} language offers a feature known as exception handling, which is used, for instance, to report error conditions. This technique {{can result in}} more robust software. On the other hand, it generally has a highly negative performance impact, even when exceptions are not actually thrown. This impact is especially important on an architecture such as the HP/Intel IA- 64 processor, which is very sensitive to compiler optimizations. Hewlett-Packard implemented exception handling for IA- 64 {{in a way that}} leaves the door open for optimizations, even in the presence of exceptions. 1. Overview of C++ Exception Handling Most software has to deal with exceptional conditions, such as insufÞcient resources, missing Þle or <b>invalid</b> <b>user</b> input. In C, such a condition is typically reported using special return codes from functions. For instance, the ubiquitous malloc function indicates an out-of-memory situation by returning a NULL pointer. Typical C code would test this situation as follows: void *ptr = malloc(1000000); if (ptr = = NULL) fprintf(stderr, ÒSorry, out of memory); C++ exceptions are a better way to report such a condition. A C++ function that detects an exceptional situation can throw an exception, which can be caught by any of the calling functions using an exception handler. For instance, the previous code could be written in a C++ program as follows (the error test is in bold) : struct OutOfMemory...|$|E
5000|$|This method targets {{the index}} found in P2P file sharing systems. The index {{allows users to}} locate the IP {{addresses}} of desired content. Thus, this method of attack makes searching difficult for network users. The attacker inserts {{a large amount of}} invalid information into the index to prevent users from finding the correct resource. [...] Invalid information could include random content identifiers or fake IP addresses and port numbers. [...] When a user attempts to download the corrupted content, the server will fail to establish a connection due to the large volume of <b>invalid</b> information. <b>Users</b> will then waste time trying to establish a connection with bogus users thus increasing the average time it takes to download the file. [...] The index poisoning attack requires less bandwidth and server resources than decoy insertion. Furthermore, the attacker does not have to transfer files nor respond to requests. For this reason, index poisoning requires less effort than other methods of attack.|$|R
40|$|Real-Time Graphical Interval Logic is a {{modal logic}} for {{reasoning}} about {{time in which}} the basic modality is the interval. The logic differs from other logics in {{that it has a}} natural intuitive graphical representation that resembles the timing diagrams drawn by system designers. We have developed an automated deduction system for the logic, which includes a theorem prover and a user interface. The theorem prover checks the validity of proofs in the logic and produces counterexamples to <b>invalid</b> proofs. The <b>user</b> interface includes a graphical editor that enables the user to create graphical formulas on a workstation display, and a database and proof manager that tracks proof dependencies and allows graphical formulas to be stored and retrieved. In this paper we describe the logic, the automated deduction system, and an application to robotics. KEYWORDS: Automated Deduction, Buchi Automaton, Graphical Representation, Interval Logic, Real-Time, Temporal Logic. Introduction Real systems [...] ...|$|R
40|$|DSMC Analysis Code (DAC) is a flexible, highly automated, easy-to-use {{computer}} program for predicting flows of rarefied gases [...] especially flows of upper-atmospheric, propulsion, and vented gases impinging on spacecraft surfaces. DAC implements the direct simulation Monte Carlo (DSMC) method, which is {{widely recognized as}} standard for simulating flows at densities so low that the continuum-based equations of computational fluid dynamics are <b>invalid.</b> DAC enables <b>users</b> to model complex surface shapes and boundary conditions quickly and easily. The discretization of a flow field into computational grids is automated, thereby relieving the user of a traditionally time-consuming task while ensuring (1) appropriate refinement of grids throughout the computational domain, (2) determination of optimal settings for temporal discretization and other simulation parameters, and (3) satisfaction of the fundamental constraints of the method. In so doing, DAC ensures an accurate and efficient simulation. In addition, DAC can utilize parallel processing to reduce computation time. The domain decomposition needed for parallel processing is completely automated, and the software employs a dynamic load-balancing mechanism to ensure optimal parallel efficiency throughout the simulation...|$|R
40|$|Previous AIX {{development}} environment experience with ASC White and Early Delivery systems UV and UM was leveraged {{to provide a}} smooth and robust transition to the Purple {{development environment}}. Still, there were three major changes that initially caused serious problems for Purple users. The first was making 64 -bit builds of executables the default instead of 32 -bit. The second was requiring all executables to use large page memory. The third was the phase-out of the popular, but now defunct, third-party C++ compiler KCC, which required the migration of many codes to IBM's xlC C++ compiler. On Purple, the default build environment changed from 32 -bit builds to 64 -bit builds in order to enable executables to use the 4 GB per processor (32 GB per node) memory available, and {{in order for the}} MPI library to do collective optimizations that required the larger 64 -bit address space. The 64 -bit build environment was made default by setting the IBM environment variable OBJECT{_}MODE to 64 and wrapping third-party software (mainly the gnu compilers) in order to make them handle OBJECT{_}MODE properly. Because not all applications could port to 64 -bit right away, (usually due to third-party constraints, such as python not supporting 64 -bit AIX builds until very recently), 32 -bit builds of the major common third-party libraries also had be supported. This combined 32 / 64 bit build support was accomplished fairly seamlessly using the AIX feature that allows both 32 -bit and 64 -bit versions of the code to appear in the same library file, and documentation with clear examples helped our library developers generate the required combined 32 -bit and 64 -bit libraries for Purple. In general, the port to 64 -bit AIX executables went smoothly. The most common problem encountered with 64 -bit was that many C codes didn't prototype malloc everywhere, via ''include '', which caused invalid pointers to be returned by unprototyped malloc calls. This was usually seen in old crusty C libraries, leading to segfault on first use of the <b>invalid</b> pointer. <b>Users</b> had not encountered this prototype issue on other 64 -bit Operating Systems (Tru 64 and SUN) because those vendors worked around this issue by ''auto-prototyping'' malloc for the user. IBM instead required a compiler option to be thrown for autoprototyping. This issue was resolved with user education, and often a quick recognition of the symptoms by support personnel. This addresses a requirement for a report on problems encountered with the tools and environment, and the resolution or status...|$|R

