369|1|Public
25|$|To prevent {{frustration}} with unsensed failures, all {{the connections between}} layers in the switch are allocated using <b>first-in-first-out</b> lists (queues). As a result, if a connection is faulty or noisy and the customer hangs up and redials, they will get {{a different set of}} connections and subswitches. A last-in-first-out (stack) allocation of connections might cause a continuing string of very frustrating failures.|$|E
25|$|In {{determining}} gain, it {{is necessary}} to determine which property is sold and the amount of basis of that property. This may require identification conventions, such as <b>first-in-first-out,</b> for identical properties like shares of stock. Further, tax basis must be allocated among properties purchased together unless they are sold together. Original basis, usually cost paid for the asset, is reduced by deductions for depreciation or loss.|$|E
5000|$|<b>First-in-first-out</b> queues, an {{asynchronous}} pipe between enqueuing and dequeuing programs.|$|E
50|$|Network devices use <b>First-In-First-Out</b> queue, Weighted fair queue, Priority queue and Custom queue.|$|E
5000|$|... {{receives}} the message, retrieves {{it from the}} head of the channel, and stores it in the variable msg. The channels pass messages in <b>first-in-first-out</b> order.|$|E
50|$|OpenBSD {{attempted}} to replace spinlocks with ticket locks which enforced <b>first-in-first-out</b> behaviour, however {{this resulted in}} more CPU usage in the kernel and larger applications, such as Firefox, becoming much slower.|$|E
5000|$|This {{differs from}} the queue {{abstract}} data type or <b>First-In-First-Out</b> List (FIFO), where elements can only be added to one end and removed from the other. This general data class has some possible sub-types: ...|$|E
50|$|Taxpayers may {{track the}} basis and {{accumulated}} {{depreciation of assets}} individually or in vintage accounts, as in the old ADR system. Where assets are tracked in vintage accounts, a <b>first-in-first-out</b> convention is usually applied to determine basis of assets retired.|$|E
50|$|To prevent {{frustration}} with unsensed failures, all {{the connections between}} layers in the switch are allocated using <b>first-in-first-out</b> lists (queues). As a result, if a connection is faulty or noisy and the customer hangs up and redials, they will get {{a different set of}} connections and subswitches. A last-in-first-out (stack) allocation of connections might cause a continuing string of very frustrating failures.|$|E
50|$|When {{multiple}} {{goods are}} bought or made, {{it may be}} necessary to identify which costs relate to which particular goods sold. This may be done using an identification convention, such as specific identification of the goods, <b>first-in-first-out</b> (FIFO), or average cost. Alternative systems may be used in some countries, such as last-in-first-out (LIFO), gross profit method, retail method, or combinations of these.|$|E
5000|$|The Linux kernel {{contains}} different scheduler classes. By default the kernel uses a scheduler mechanism {{called the}} Completely Fair Scheduler {{introduced in the}} 2.6.23 version of the kernel. Internally this default-scheduler class {{is also known as}} , but the kernel also contains two POSIX-compliant real-time scheduling classes named [...] (realtime <b>first-in-first-out)</b> and [...] (realtime round-robin), both of which take precedence over the default class.|$|E
50|$|In {{determining}} gain, it {{is necessary}} to determine which property is sold and the amount of basis of that property. This may require identification conventions, such as <b>first-in-first-out,</b> for identical properties like shares of stock. Further, tax basis must be allocated among properties purchased together unless they are sold together. Original basis, usually cost paid for the asset, is reduced by deductions for depreciation or loss.|$|E
50|$|The {{pipelining}} {{of requests}} {{results in a}} dramatic improvement in the loading times of HTML pages, especially over high latency connections such as satellite Internet connections. The speedup is less apparent on broadband connections, as the limitation of HTTP 1.1 still applies: the server must send its responses {{in the same order}} that the requests were received — so the entire connection remains <b>first-in-first-out</b> and HOL blocking can occur. The asynchronous operation of the upcoming HTTP/2 or SPDY could be a solution for this.|$|E
5000|$|It is also {{possible}} to implement backpressure on a set ofpre-specified paths. This can restrict the capacity region, but might improve in-orderdelivery and delay. Another way to improve delay, without affecting the capacity region, is to use an enhancedversion that biases link weights towards desirable directions. [...] Simulations of such biasing have shown significant delay improvements.Note that backpressure does not require <b>First-in-First-Out</b> (FIFO) service at the queues. It has been observedthat Last-in-First-Out (LIFO) service can dramatically improve delay {{for the vast majority}} of packets,without affecting throughput.|$|E
5000|$|Asynchronous register-transfer systems (such as computers) have {{a general}} solution. In the 1980s, some {{researchers}} discovered that almost all synchronous register-transfer machines could be converted to asynchronous designs by using <b>first-in-first-out</b> synchronization logic. In this scheme, the digital machine is characterized {{as a set of}} data flows. In each step of the flow, an asynchronous [...] "synchronization circuit" [...] determines when the outputs of that step are valid, and presents a signal that says, [...] "grab the data" [...] to the stages that use that stage's inputs. It turns out that just a few relatively simple synchronization circuits are needed.|$|E
5000|$|The Linux kernel {{contains}} different scheduler classes. By default, the kernel uses a scheduler mechanism {{called the}} Completely Fair Scheduler (CFS) {{introduced in the}} 2.6.23 version of the kernel. Internally, this default scheduler class {{is also known as}} , but the kernel also contains two POSIX-compliant real-time scheduling classes named [...] (realtime <b>first-in-first-out)</b> and [...] (realtime round-robin) both of which take precedence over the default class. The [...] scheduling class was added to the Linux scheduler in version 3.14 of the Linux kernel mainline, released on 30 March 2014,and takes precedence over all the other scheduling classes.|$|E
50|$|However, {{the concept}} of the virtual arrival curve is flawed. This curve does not {{correctly}} show the queue length resulting from the interruption in traffic (i.e. red signal). It assumes that all vehicles are still reaching the stop bar before being delayed by the red light. In other words, the virtual arrival curve portrays the stacking of vehicles vertically at the stop bar. When the traffic signal turns green, these vehicles are served in a <b>first-in-first-out</b> (FIFO) order. For a multi-lane approach, however, the service order is not necessarily FIFO. Nonetheless, the interpretation is still useful because of the concern with average total delay instead of total delays for individual vehicles.|$|E
50|$|Priority queue {{is divided}} into 4 sub queues with {{different}} priorities. Data in each queue are only served when the higher priority queues are empty. If data come into the empty higher priority queue while the network OS is transferring data of lower priority queue, network OS will hold data of the lower priority queue and process data in higher priority queue first. The network OS does not care how long lower priority queues {{have to wait for}} their turn because it always finishes each queue from highest to lowest priority first before moving to the next queue. Within each queue, packets are forwarded based on <b>First-In-First-Out</b> basis.|$|E
5000|$|One {{important}} aspect of determining tax deductions for business expenses is the timing of such deduction. The method used for this is {{commonly referred to as}} an accounting method. Accounting methods for tax purposes may differ from applicable GAAP. Examples include timing of recognition of cost recovery deductions (e.g., depreciation), current expensing of otherwise capitalizable costs of intangibles, and rules related to costs that should be treated as part of cost of goods not yet sold. [...] Further, taxpayers often have choices among multiple accounting methods permissible under GAAP and/or tax rules. Examples include conventions for determining which goods have been sold (such as <b>first-in-first-out,</b> average cost, etc.), whether or not to defer minor expenses producing benefit in the immediately succeeding period, etc.|$|E
5000|$|The use of wa to {{introduce}} a new theme of discourse is directly linked {{to the notion of}} grammatical theme. Opinions differ on the structure of discourse theme, though it seems fairly uncontroversial to imagine a <b>first-in-first-out</b> hierarchy of themes that is threaded through the discourse. Of course, human limitations restrict the scope and depth of themes, and later themes may cause earlier themes to expire. In these sorts of sentences, the steadfast translation into English uses constructs like [...] "speaking of X" [...] or [...] "on the topic of X", though such translations tend to be bulky as they fail to use the thematic mechanisms of English. For lack of a comprehensive strategy, many teachers of Japanese emphasize the [...] "speaking of X" [...] pattern without sufficient warning.|$|E
5000|$|In {{computer}} science, a queue ( [...] ) is {{a particular}} kind of abstract data type or collection in which the entities in the collection are kept in order and the principal (or only) operations on the collection are the addition of entities to the rear terminal position, known as enqueue, and removal of entities from the front terminal position, known as dequeue. This makes the queue a <b>First-In-First-Out</b> (FIFO) data structure. In a FIFO data structure, the first element added to the queue will {{be the first one to}} be removed. This is equivalent to the requirement that once a new element is added, all elements that were added before have to be removed before the new element can be removed. Often a peek or front operation is also entered, returning the value of the front element without dequeuing it. A queue is an example of a linear data structure, or more abstractly a sequential collection.|$|E
5000|$|Routine blood {{storage is}} 42 days or 6 weeks for stored packed {{red blood cells}} (also called [...] "StRBC" [...] or [...] "pRBC"), by far the most {{commonly}} transfused blood product, and involves refrigeration but usually not freezing. There has been increasing controversy about whether a given product unit's age is a factor in transfusion efficacy, specifically on whether [...] "older" [...] blood directly or indirectly increases risks of complications. Studies have not been consistent on answering this question, with some showing that older blood is indeed less effective but with others showing no such difference; nevertheless, as storage time remains the only available way to estimate quality status or loss, a <b>first-in-first-out</b> inventory management approach is standard presently. It is also important to consider that there is large variability in storage results for different donors, which combined with limited available quality testing, poses challenges to clinicians and regulators seeking reliable indicators of quality for blood products and storage systems.|$|E
50|$|For example, an {{abstract}} stack, {{which is a}} last-in-first-out structure, could be defined by three operations: push, that inserts a data item onto the stack; pop, that removes a data item from it; and peek or top, that accesses a data item {{on top of the}} stack without removal. An abstract queue, which is a <b>first-in-first-out</b> structure, would also have three operations: enqueue, that inserts a data item into the queue; dequeue, that removes the first data item from it; and front, that accesses and serves the first data item in the queue. There would be no way of differentiating these two data types, unless a mathematical constraint is introduced that for a stack specifies that each pop always returns the most recently pushed item that has not been popped yet. When analyzing the efficiency of algorithms that use stacks, one may also specify that all operations take the same time no matter how many data items have been pushed into the stack, and that the stack uses a constant amount of storage for each element.|$|E
5000|$|RTLinux {{provides}} {{the capability of}} running special real-time tasks and interrupt handlers on the same machine as standard Linux. These tasks and handlers execute {{when they need to}} execute no matter what Linux is doing. The worst case time between the moment a hardware interrupt is detected by the processor and the moment an interrupt handler starts to execute is under 15 microseconds on RTLinux running on a generic x86 (circa 2000). A RTLinux periodic task runs within 35 microseconds of its scheduled time on the same hardware. These times are hardware limited, and as hardware improves RTLinux will also improve. Standard Linux has excellent average performance and can even provide millisecond level scheduling precision for tasks using the POSIX soft real-time capabilities. Standard Linux is not, however, designed to provide sub-millisecond precision and reliable timing guarantees. RTLinux was based on a lightweight virtual machine where the Linux [...] "guest" [...] was given a virtualized interrupt controller and timer, and all other hardware access was direct. From {{the point of view of}} the real-time [...] "host", the Linux kernel is a thread. Interrupts needed for deterministic processing are processed by the real-time core, while other interrupts are forwarded to Linux, which runs at a lower priority than real-time threads. Linux drivers handled almost all I/O. <b>First-In-First-Out</b> pipes (FIFOs) or shared memory can be used to share data between the operating system and RTLinux.|$|E
30|$|A {{comparison}} {{of the performance of}} the proposed technique with that of a conventional <b>first-in-first-out</b> (FIFO) scheduler as well as a technique from the literature [29] that has objectives similar to RM-DCWF is presented.|$|E
3000|$|The {{wireless}} link {{is assumed}} to carry N long-lived TCP-Reno flows using <b>first-in-first-out</b> (FIFO) scheduling with a common packet size L. Each flow i,i∈{ 0, 1,…,N− 1 }, {{is assumed to}} have a fixed (yet arbitrary) RTT denoted by R [...]...|$|E
40|$|Simple loop <b>first-in-first-out</b> (FIFO) {{bubble memory}} shift {{register}} has continuous storage capability. Bubble shift register simplifies chip-control electronics by enabling all control functions to be alined at same bit. FIFO shift register is constructed from passive replicator and annihilator combinations...|$|E
3000|$|... [...]. Store each {{codeword}} in a <b>first-in-first-out</b> (FIFO) buffer {{of length}} n. A multiplexer {{is used to}} choose a symbol at each transmission time i ∈ [1, n] {{from one of the}} FIFO buffers according to the state s R,i(k). Then, the chosen symbol is transmitted.|$|E
3000|$|For a {{realistic}} DSL scenario, the data workload represents the user behavior, {{and can be}} modeled as a time-slotted system, indexed by t. A finite <b>first-in-first-out</b> (FIFO) data queue is associated to each user, whose output {{is defined by the}} physical layer transmit rate R [...]...|$|E
40|$|We {{develop an}} {{efficient}} snapshot algorithm that needs no control messages {{and does not}} require channels to be <b>first-in-first-out.</b> We also show that several stable properties (e. g., termination, deadlock) can be detected with uncoordinated distributed snapshots. For such properties, our algorithm can be further simplified...|$|E
40|$|Abstract This paper {{outlines}} {{relationship between}} <b>first-in-first-out</b> (FIFO) and link (or path) travel time computing, {{by means of}} cumulative arrival and departure flows or curves, and implementation in dynamic traffic assignment (DTA) solving. First, {{it is noted that}} the assumption of link/path FIFO satisfaction underlies this method of computing travel times. Then, under assumption of aggregate link FIFO we set out expressions to ensure FIFO for each traffic type (destination type) on the link. We also set out how to maintain FIFO inside a cell while the cell-transmission recipe is employed to model time-varying traffic flows. The method presented is applicable to ordinary, diverge and merge cells and maintains FIFO on cells, links and paths. Keywords dynamic traffic assignment, travel time computation, <b>first-in-first-out</b> (FIFO), dynamics of traffic flows, whole-link models, cell-transmission recip...|$|E
40|$|Currently the Internet only {{offers a}} single {{type of service}}: all packets are {{serviced}} on a best-effort, <b>first-in-first-out</b> (FIFO) basis. This single type of service limits the nature of applications that can be adequately supported. As the “information revolution ” is currently underway, more and more new applications are emerging...|$|E
40|$|This {{paper is}} general view about Queue. This paper {{is divided into}} four parts. In first part is {{introduction}} of queue. In second parts is about Circular buffer, Deque, Priority queue and there description. The queue is a <b>First-In-First-Out</b> (FIFO) data structure. In four parts discuss about implementation of queue...|$|E
40|$|Abstract: This paper {{presents}} a {{virtual private network}} traffic pricing model with <b>first-in-first-out</b> and round-robin bandwidth scheduling. A transaction-level pricing architecture based on proxy server technology is proposed for the implementation. The experiment us ing real-time test data shows that the pricing mechanism can effectively improve a VPN's transmission efficiency measured in the service welfare rate. 1...|$|E
30|$|The Location Manager {{keeps the}} last {{location}} of each target, as {{received from the}} Location reporting API. Based on this information, it generates location events which are then stored in a <b>first-in-first-out</b> queue. Each event contains information about the target (e.g., Alice), the type of the event (arrive or leave) and the place to which the events refer (e.g., P 1).|$|E
40|$|We {{deal with}} timed event graphs whose holding times {{associated}} with places are variable. Defining a <b>first-in-first-out</b> functioning rule, {{we show that}} such graphs can be linearly described in (max,+) algebra. Moreover, this linear representation allows extending the just-in-time control synthesis existing for timed event graphs with constant holding times. An example is proposed in order to illustrate how the approach can be applied as a just-in-time strategy for production lines...|$|E
