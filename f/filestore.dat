33|3|Public
5000|$|The {{dedicated}} Acorn <b>FileStore</b> units, {{running on}} dedicated hardware with higher capacity and more facilities.|$|E
50|$|The {{following}} {{is a list of}} non-database XQuery processors which provide an XQuery API for Java interface (typically allowing query against documents parsed from XML in <b>filestore,</b> and held in memory as DOM or similar trees).|$|E
50|$|Another notable {{feature of}} Flex was the tagged, write-once <b>filestore.</b> This allowed {{arbitrary}} code and data structures {{to be written}} and retrieved transparently, without recourse to external encodings. Data could thus be passed safely from program to program.|$|E
50|$|This {{would not}} be a problem is all of the {{integrals}} could be held in CPU memory simultaneously.In that case the computed integral can be assigned into its position in the array oftwo electron integrals by computing the required index from the p,q,r and s indices.In the 1960s it was essentially impossible to hold all of the two electron integrals inmemory simultaneously. Therefore, M Yoshimine developed a sorting algorithm for two-electron integrals which reads the unordered list of integrals from a files and transforms it into an ordered list which is then written to another file. A by-product of this is that the <b>filestoring</b> the ordered integrals does not need to contain the p,q,r,s indices for each integral.The ordering process uses a direct access file but the input and output files of integralsare sequential.|$|R
40|$|The {{original}} publication {{is available}} at www. springerlink. com???. Copyright Springer. [Full text {{of this article is}} not available in the UHRA]In this paper we introduce a distributed object-based document architecture called DODA in order to illustrate a novel strategy for achieving both high availability and high integrity in the context of open processing distributed between mutually suspicious domains without a common management hierarchy. Our approach to availability is to structure documents into small components called folios {{in such a way as}} to allow the maximum opportunity for concurrent processing, and to allow these components to be freely replicated and distributed. Integrity conflicts are resolved using an optimistic form of control called optimistic integrity control (OIC) applied to recoverable work units. Our approach to security is to shrinkwrap the document components using cryptographic checksums, and to provide a set of building block components called functionaries which a group of users can combine in such a way as to provide each user with a means of ensuring that an agreed notion of integrity is enforced while relying upon a minimum of non-local trust. In particular, we do not rely upon a trusted computing base or a shared system infrastructure. The local availability of document versions and of the resources to process them are completely under local user control. The lack of availability of the functionaries does not have severe consequences, and the presence of mutual suspicion makes it easier to ensure that users can trust the functionaries to provide the intended service. A major benefit of using OIC is that it allows the integration of untrusted components such as <b>filestores</b> and directory servers into the system. In particular, an untrusted soft locking service can be used in order to reduce the number of concurrency conflicts, and untrusted security components can be used to screen out attempted access control violations...|$|R
40|$|For {{researches}} in {{the field}} of the data mining and machine learning the necessary condition is an availability of various input data set. Now researchers create the databases of such sets. Examples of the following systems are: The UCI Machine Learning Repository, Data Envelopment Analysis Dataset Repository, XMLData Repository, Frequent Itemset Mining Dataset Repository. Along with above specified statistical repositories, the whole pleiad from simple <b>filestores</b> to specialized repositories can be used by researchers during solution of applied tasks, researches of own algorithms and scientific problems. It would seem, a single complexity for the user will be search and direct understanding of structure of so separated storages of the information. However detailed research of such repositories leads us to comprehension of deeper problems existing in usage of data. In particular a complete mismatch and rigidity of data files structure with SDMX - Statistical Data and Metadata Exchange - standard and structure used by many European organizations, impossibility of preliminary data origination to the concrete applied task, lack of data usage history for those or other scientific and applied tasks. Now there are lots of methods of data miming, as well as quantities of data stored in various repositories. In repositories there are no methods of DM (data miming) and moreover, methods are not linked to application areas. An essential problem is subject domain link (problem domain), methods of DM and datasets for an appropriate method. Therefore in this work we consider the building problem of ontological models of DM methods, interaction description of methods of data corresponding to them from repositories and intelligent agents allowing the statistical repository user to choose the appropriate method and data corresponding to the solved task. In this work the system structure is offered, the intelligent search agent on ontological model of DM methods considering the personal inquiries of the user is realized. For implementation of an intelligent data and metadata exchange repository the agent oriented approach has been selected. The model uses the service oriented architecture. Here is used the cross platform programming language Java, multi-agent platform Jadex, database server Oracle Spatial 10 g, and also the development environment for ontological models - Protégé Version 3. 4...|$|R
50|$|The Garmin.img {{format is}} what Garmin devices use {{to store the}} maps for its GPS units. The img files contain a header and many subfiles. Img's <b>filestore</b> is based on FAT system. Some old GPS units {{are not able to}} work with {{multiple}} img files so they need to be merged into one file called gmapsupp.img using programs like Mapsource.|$|E
5000|$|Starting {{with the}} 1904A, a paging unit was {{available}} for larger 1900 processors and George 4 was written {{to take advantage of}} it. George 4 remained compatible with George 3. (It was common to alternate George 3 and 4 on the same machine and <b>filestore,</b> running George 3 during the day for small, interactive workloads and George 4 at night for large, memory intensive, jobs.) ...|$|E
50|$|S3-based {{storage is}} priced per {{gigabyte}} per month. Applications access S3 through an API. For example, Apache Hadoop supports a special s3: filesystem to support reading from and writing to S3 storage during a MapReduce job. There are also S3 filesystems for Linux, which mount a remote S3 <b>filestore</b> on an EC2 image, {{as if it}} were local storage. As S3 is not a full POSIX filesystem, things may not behave the same as on a local disk (e.g., no locking support).|$|E
5000|$|These {{divisions}} and sub-divisions of VME/B were {{reflected in the}} hierarchical structure of the CADES database. This enabled the reuse of code within VME/B (one {{of the goals of}} software engineering). This, coupled with a suite of tools, and the use of SDL (Software Design Language) as the development language, version history and the concept of [...] source code (that is code that has passed QA and subsequently resides within CADES <b>filestore)</b> improved development time whilst providing satisfactory audit trails and QA processes.|$|E
5000|$|In July 1965 a {{team from}} ICT was present at a seminar at NPL {{describing}} the CTSS operating system developed for MIT's Project MAC. They decided that the ICT would need to provide multi-access facilities, known to ICT as MOP, [...] "Multiple Online Processing". In November 1965 H. P. Goodman, head of the Operating Systems Branch attended the Fall Joint Computer Conference in Las Vegas where plans for Multics were initially described. [...] Some of the Multics features discussed influenced future development of George, notably the tree structured <b>filestore.</b>|$|E
50|$|Ten15 {{served as}} an {{intermediate}} language for compilers, but with several unique features, {{some of which have}} still to {{see the light of day}} in everyday systems. Firstly, it was strongly typed, yet wide enough in application to support most languages — C being an exception, chiefly because C deliberately treats an array similar to a pointer to the first element of that array. This ultimately led to Ten15's development into TDF, which in turn formed the basis for ANDF. Secondly, it offered a persistent, write-only <b>filestore</b> mechanism, allowing arbitrary data structures to be written and retrieved without conversion into an external representation.|$|E
50|$|Within {{a virtual}} machine, code can run {{at up to}} sixteen {{different}} layers of protection, called access levels (or ACR levels, after the Access Control Register which controls the mechanism). The most privileged levels of operating system code (the kernel) operate in the same virtual machine as the user application, as do intermediate levels such as the subsystems to implement <b>filestore</b> access and networking. System calls thus involve a change of protection level, but not an expensive call to invoke code in a different virtual machine. Every code module executes at a particular access level, and can invoke the functions offered by lower-level (more privileged) code, but cannot make direct access to memory or other resources at that level. The architecture thus offers a built-in encapsulation mechanism to ensure system integrity.|$|E
40|$|There is a {{class of}} data, {{including}} messages and business workflow state, for which conventional monolithic databases are less than ideal. Performance and scalability of Application Server systems can be dramatically increased by distributing such data across transactional filestores, {{each of which is}} bound to a server instance in a cluster. This paper describes a high-performance, transactional <b>filestore</b> that has been developed for the BEA WebLogic Application Server and benchmarks it against a database. The <b>filestore</b> uses a novel, platform-independent disk scheduling algorithm to minimize the latency of small, synchronous writes to disk. 1...|$|E
40|$|Flash filestores have {{a variety}} of unique {{features}} that lead to interesting design constraints. One challenge is that of ensuring that each block of the drive is used and erased evenly, known as "wear-levelling". This paper presents a novel approach to the analysis of wear-levelling algorithms using probabilistic specification and analysis techniques. A simplified version of the wear-levelling algorithm used in the JFFS flash <b>filestore</b> is used as an illustration. The expected lifetime of a flash <b>filestore</b> implementing such an algorithm is derived using probabilistic proof techniques. © 2010 University of Newcastle upon Tyne. Printed and published by the University of Newcastle upon Tyne...|$|E
40|$|Event-B is {{a formal}} method used for specifying and {{reasoning}} about systems. Rodin is a toolset for developing system models in Event-B. Our experiment which is outlined {{in this paper}} is aimed at applying Event-B and Rodin to a flash-based <b>filestore.</b> Refinement is a useful mechanism that allows developers to sharpen models step by step. Two uses of refinement, feature augmentation and structural refinement, were employed in our development. Event decomposition and machine decomposition are structural refinement techniques on which we focus in this work. We present an outline of a verified refinement chain for the flash <b>filestore.</b> We also outline evidence of {{the applicability of the}} method and tool together with some guidelines...|$|E
40|$|We {{describe}} {{the design of}} a comparable corpus that spans all of the world’s languages and facilitates large-scale cross-linguistic processing. This Universal Corpus consists of text collections aligned at the document and sentence level, multilingual wordlists, and a small set of morphological, lexical, and syntactic annotations. The design encompasses submission, storage, and access. Submission preserves the integrity of the work, allows asynchronous updates, and facilitates scholarly citation. Storage employs a cloud-hosted <b>filestore</b> containing normalized source data together with a database of texts and annotations. Access is permitted to the <b>filestore,</b> the database, and an application programming interface. All aspects of the Universal Corpus are open, and we invite community participation in its design and implementation, and in supplying and using its data. ...|$|E
40|$|Abstract. Event-B is {{a formal}} method used for specifying and reason-ing about systems. Rodin is a toolset for {{developing}} system models in Event-B. Our experiment which is outlined {{in this paper}} is aimed at applying Event-B and Rodin to a flash-based <b>filestore.</b> Refinement is a useful mechanism that allows developers to sharpen models step by step. Two uses of refinement, feature augmentation and structural refinement, were employed in our development. Event decomposition and machine decomposition are structural refinement techniques on which we focus in this work. We present an outline of a verified refinement chain for the flash <b>filestore.</b> We also outline evidence of {{the applicability of the}} method and tool together with some guidelines. Key words: refinement, event decomposition, machine decomposition, file system, flash memory, proof, Event-B, Rodin...|$|E
40|$|Abstract. This paper focusses on the {{modelling}} of NAND Flash Memory technology, done {{as part of}} the POSIX <b>filestore</b> pilot study. This is {{the first}} known work on formal models of NAND Flash Memory. We describe recently published results, the current modelling activities, and sketch out our plans for future research in this area. ...|$|E
40|$|The major {{objective}} of the Service Oriented Computing Environment (SORCER) [1] is to form dynamic federations of network services that provide engineering data, applications and tools on a grid [23 - 28]. To {{meet the requirements of}} these service providers in terms of data sharing and managing in the form of data files, the <b>FileStore</b> Service (FSS) was developed as a core service in SORCER. The value of <b>FileStore</b> service is enhanced when both web based user agents and service providers can readily share the content in a seamless fashion. This framework fits the SORCER philosophy of grid interactive service-oriented programming [2], where users create distributed programs using exclusively interactive user agents. The Document Manager user agent is a web-based GUI, which allows authorized users to securely access the <b>FileStore</b> service {{in the same way as}} users use their local file system. This paper is structured as follows: first, a brief overview of SORCER is given and then, FSS is described. Next, we discuss how data is passed across multiple services and how providers dealing with parts of data can filter out information from large files using the filter framework. We also discuss how these files are used by different services and managed by web based user agents. Finally we discuss an actual use case of this service in the FIPER project [1] for B 2 B Fuel Nozzle and Combustor service between GE Global Research Center and Parker Hannifin and also some proposed extensions to the existing system...|$|E
40|$|Capabilities in Flex {{are first}} class data objects which allow one {{to define and}} limit the right to access data or obey an action. Their use extends from mainstores to filestores and across {{networks}} of Flexes. This paper gives a general description of how Flex capabilities are implemented, controlled and used. They are classified into four varieties, mainstore, <b>filestore,</b> remote and universal. Each of these varieties has its own range and lifetime designed to combine consistency, integrity and utility with implementability. I Acce-icf Fo...|$|E
40|$|Abstract. In {{this paper}} we {{describe}} a formalism which uses the stochastic process algebra PEPA as the inscription language for labelled stochastic Petri nets. Viewed in another way, {{the net is}} used to provide a structure for combining related PEPA systems. The combined modelling language naturally represents such applications as mobile code systems where the PEPA terms are used to model the program code which moves between network hosts (the places in the net). We describe {{the implementation of a}} tool to support this modelling formalism and apply this to model a peer-to-peer <b>filestore.</b> ...|$|E
40|$|As an ultra {{lightweight}} {{web application}} DotWikIE (Rees, 2006) {{showed that a}} single web page, loaded directly from the local machine 2 ̆ 7 s <b>filestore,</b> could support a wiki application running within a web browser. This allows the web page to carry data content {{which can be used}} and manipulated by a browser on any machine without requiring an Internet connection. The single web page contains both the application logic and data repository for the wiki, is highly portable, and can easily copied for backup and deployment. While DotWikIE is useful a web-based wiki with the same functionality has the advantage of being accessible on any Internet-connected machine. DotWikIEWeb is the evolution of DotWikIE as an ultra lightweight web application that works either from the local <b>filestore</b> or from a web site. This paper presents the technological problems and discusses an implementation of DotWikIEWeb and its ability to become the single page seed of a colony of associated wiki pages. DotWikIEWeb retains the benefits of single page web applications while gaining the capability to operate on a web site. Because of their flexibility wikis in general tend to become unstructured quickly as the user grasps the freedom to populate and format each wiki component in an ad hoc way. This is seen as one of the main advantages of a wiki. The paper concludes by discussing some approaches to how wikis could retain a more regular structure for their content...|$|E
40|$|Higher and Further {{education}} {{institutions in the}} UK {{are in the process}} of migrating their IT infrastructures to exploit Shibboleth technologies for federated access management. Ease of use and secure access are paramount to the successful uptake of these technologies, both from the end user and system administrator perspective. The JISC-funded GLASS project is a one-year project investigating the use of Shibboleth to support single sign-on to a variety of campus resources at the University of Glasgow including browser-based email access; the Moodle online virtual learning environment; the WebSURF online student records facility, and a network <b>filestore</b> browser. This paper describes the implementation issues and experiences gained in rolling out the Shibboleth technologies to support federated access management. 1...|$|E
40|$|A <b>filestore</b> is a {{structured}} {{collection of data}} files housed in a conven-tional hierarchical file system. Many applications use filestores as a poor-man’s database, and the correct execution of these applica-tions requires that the collection of files, directories, and symbolic links stored on disk satisfy a variety of precise invariants. More-over, all of these structures must have acceptable ownership, per-mission, and timestamp attributes. Unfortunately, current program-ming languages do not provide support for documenting assump-tions about filestores, detecting errors in them, or safely loading from and storing to them. This paper describes the design, implementation, and semantics of Forest, a new domain-specific language for describing filestores. The language uses a type-based metaphor to specify the expected structure, attributes, and invariants of filestores. Forest generate...|$|E
40|$|We {{present a}} CSP {{model of the}} {{internal}} behaviour of Flash Memory, based on its specification by the Open Nand-Flash Interface (ONFi) consortium. This contributes directly to the low-level modelling of the data-storage technology that is {{the target of the}} POSIX <b>filestore</b> mini-challenge. The key objective was to ensure that the internal behaviour was well-specified, and that it was consistent with the specification of the external interface of such devices. The FDR toolkit was used to perform the revelent refinement/model-checking. In addition to uncovering errors and possible sources of misinterpretation in the ONFi standard, this work also describes a methodology for model data-entry based on a ?state-chart? dialect of XML (SCXML) using XSLT to translate into CSP, and HTML, to support validation...|$|E
40|$|One of {{the central}} {{services}} provided by the University of Cambridge Computing Service is the email system, Hermes. Since its introduction in 1993 {{it was based on}} UW-IMAP and a shared Unix <b>filestore.</b> This architecture has a number of inherent limitations in performance, scalability, resilience, and cost-effectiveness. In order to address these problems, and particularly users ’ desire for larger messages and disk quotas, the system is being replaced with a mostly-compatible reimplementation based on multiple CMU Cyrus message stores. This paper explains the effects of the limitations of the old system, including the restrictions imposed on our users, and the implementation of our webmail software, Prayer. We describe how Cyrus has been modified to make the transition to the new system easier, and to address the anticipated reliability and administration problems caused by using more inexpensive hardware. Finally, after covering the changing role of our central email relay in the new architecture, we discuss some possible development projects for the future. 1...|$|E
40|$|ABSTRACT: This paper {{describes}} the virtual filesystem interface found in 4. 4 BSD. This interface is designed around an object oriented virtual file node or "vnode " data structure. The vnode structure is described {{along with its}} method for dynamically expanding its set of operations. These operations have been divided into two groups: those to manage the hierarchical filesystem name space and those to manage the flat <b>filestore.</b> The translation of pathnames is described, as it requires a tight coupling between the virtual filesystem layer and the underþing filesystems through which the path traverses. This paper {{describes the}} filesystem services that are exported from the vnode interface to its clients, both local and remote. It also describes the set of services provided by the vnode layer to its client filesystems. The vnode interface has been generalized to allow multiple filesystems to be stacked together. After describing the stacking functionality, several examples of stacking filesystems are shown...|$|E
40|$|The Sharing Ancient Wisdoms project (SAWS) is {{establishing}} a research workflow of editing, linking and publishing semantically-enhanced TEI/XML-based digital editions of ancient manuscripts that contain wise sayings. Of particular research {{interest is the}} ability to investigate links between these manuscripts. Digital edition creation, storage, annotation and, most recently, the adding of RDF and Linked Data are hot topics in digital humanities research, making SAWS workflows and supporting technologies highly transferable. Updating and maintaining published files, currently stored in a web <b>filestore,</b> has become troublesome. Additionally, the lengthy, involved procedures of transcribing and editing manuscripts have caused delays. More intuitive interfaces for editing and annotating files would be helpful. Scholars studying manuscripts in right-to-left (RTL) languages have also reported difficulties working with standard XML editors. In this work we explore if SAWS's research workflows can be made more efficient and intuitive through the use of repository tools developed within Islandora for the Editing Modernism in Canada (EMiC) research project...|$|E
40|$|Traditionally {{there has}} been a clear {{distinction}} between computational (short-term) memory and <b>filestore</b> (long-term memory). This distinction has been maintained mainly due to limitations of technology. Recently {{there has been}} considerable interest in programming languages and systems which support orthogonal persistence. In such systems arbitrary data structures may persist beyond the life of the program which created them and this distinction is blurred. Systems supporting orthogonal persistence require a persistent store in which to maintain the persistent objects. Such a persistent store can be implemented via an extended virtual memory with addresses large enough to address all objects. Superimposing structure and a protection scheme on these addresses may well result in them being sparsely distributed. An additional incentive for supporting large virtual addresses is an interest in exploiting the potential of very large main memories to achieve supercomputer speed. This paper presents hardware and software mechanisms to implement a paged virtual memory which can be efficiently accessed by large addresses. An implementation of these techniques for a capability-based computer, MONADS-PC, is described...|$|E
40|$|A network {{architecture}} called Highball and a preliminary {{design for a}} prototype, wide-area data network designed to operate at speeds of 1 Gbps and beyond are described. It is intended for applications requiring high speed burst transmissions where some latency between requesting a transmission and granting the request can be anticipated and tolerated. Examples include real-time video and disk-disk transfers, national <b>filestore</b> access, remote sensing, and similar applications. The network nodes include an intelligent crossbar switch, but have no buffering capabilities; thus, data must be queued at the end nodes. There are no restrictions on the network topology, link speeds, or end-end protocols. The end system, nodes, and links can operate at any speed up to the limits imposed by the physical facilities. An overview of an initial design approach is presented and is intended as a benchmark upon which a detailed design can be developed. It describes the {{network architecture}} and proposed access protocols, as well as functional descriptions of the hardware and software components {{that could be used}} in a prototype implementation. It concludes with a discussion of additional issues to be resolved in continuing stages of this project...|$|E
40|$|We present our {{experience}} {{of working with the}} Failures-Divergence Refinement (FDR) toolkit while extending our modelling of the behaviour of Flash Memory. This effort is a step towards the low-level modelling of data-storage technology that is the target of the POSIX <b>filestore</b> mini-challenge. The key objective was to advance previous work presented in [4, 2] to cover the full Open Nand-Flash In-terface (ONFi) 2. 1 model. The previous work covered a sub-model of the mandatory features of ONFi 1. 0. The FDR toolkit was used for refinement/model-checking. In addition to the compression techniques available in FDR, we also experimented with FDR Explorer- an application-programming interface (API) that allowed us to get a better picture of FDR performance. This paper summarises the progress we made, and the limits we encountered. We are now able to verify many of the operations in ONFi 2. 1 model using full Failures-Divergence refinement checking, rather than just trace refinement. Through the use of compression techniques available in the FDR toolkit and in particular by hiding the events deeper in the model, {{we were able to get}} compression of the state-space. The work also reports the number of attempts to compile the full ONFi 2. 1 model. 1...|$|E
40|$|A <b>filestore</b> is a {{structured}} {{collection of data}} files housed in a conven-tional hierarchical file system. Many applications use file systems as a poor-man’s database, and the correct execution of these appli-cations requires that the collection of files, directories, and sym-bolic links stored on disk satisfy a variety of precise invariants. Moreover, all of these structures must have acceptable ownership, permission, and timestamp attributes. Unfortunately, current pro-gramming languages do not provide support for documenting as-sumptions about filestores, detecting errors, or safely loading from and storing to them. This paper describes the design, implementation, and seman-tics of Forest, a novel domain-specific language for describing file-stores. The language uses a type-based metaphor to specify the ex-pected structure, attributes, and invariants of filestores. Forest gen-erates loading and storing functions that {{make it easy to}} connect data on disk to an isomorphic representation in memory that can be manipulated as if it were any other data structure. Forest also gen-erates metadata that describes {{the degree to which the}} structures on the disk conform to the specification, making error detection easy. Forest essentially extends the type discipline of programming lan-guages to the untyped world of file systems. We have implemented Forest as an embedded domain-specific language in Haskell. Our implementation leverages Haskell’s generic programming infrastructure to provide a toolkit so that third-party developers can build tools that work with arbitrary For-est descriptions. We show the use of this toolkit on a number of examples including a file system visualizer, an access checker, and description-directed variants of several standard UNIX shell tools. Finally, we formalize a core fragment Forest in a semantics inspired by classical tree logics and prove round-tripping laws showing that the loading and storing functions behave correctly. 1...|$|E
40|$|A viable archive {{should contain}} {{material}} which is useful, accessible and easily implemented {{on the target}} system. The growth of electronic communication, electronic mail in particular, has brought into being computer-based archives, removing the restrictions of geographical or political boundaries. This paper describes {{the growth of the}} Aston Archive, the Archivists and how we manage the archive. I shall describe our approach to make implementation across a wide range of systems consistent and how we answer questions such as "Does the archive contains fonts for device Y " or "How do I use printer X". I hope to answer the question "Is the Archive Useful?" 1. Definition of an Archive If the proverbial "man in the street " were asked the question "What is an archive?", the most likely reply would be "A collection of books or records". A popularly held view is of the 19 th-century room filled with books collecting dust, or records of births, deaths and marriages. In the United Kingdom for many centuries, parish records formed the basis of archives and were usually kept in the Parish Church- a situation which no longer applies, I might add. Chamber's Student Dictionary (Revised edition 1980) defines archives as "the place in which government records are kept: public records". The University is mainly funded by government monies and the archive does contain public records, so the definition seems relevant. I suppose that the modern concept of an archive was created {{with the advent of the}} digital computer, and it was only a matter of time before "collections " of computer programs and similar material acquired the title ARCHIVE. In fact, the common term used when preserving the <b>filestore</b> of a computer against corruption for future use is archiving, and a number of products on the open market make use of the word. The major growth in electronic communication in the last few years has opened up the concept of a central archive to serve large areas of a country or even the globe. There are a number of well-known archives in the world, and several which serve the TEX community. I shall, of course, be concentrating on the one located at Aston University in the Unite...|$|E
40|$|Ko Wing Hoi. Duplicate {{numbering}} of leave 67. Thesis (M. Sc.) [...] Chinese University of Hong Kong, 1992. Includes bibliographical references (leaves 71 - 72). Chapter 1. [...] - INTRODUCTION [...] - p. 1 Chapter 2. [...] - COMPARISONS OF LAN AND PABX [...] - p. 3 Chapter 2. 1 [...] - Typical LAN system [...] - p. 3 Chapter 2. 1. 1 [...] - Characteristics of a LAN [1] [...] - p. 3 Chapter 2. 1. 2 [...] - Transmission {{medium of}} LAN [...] - p. 5 Chapter 2. 1. 3 [...] - LAN access control methods [...] - p. 6 Chapter 2. 1. 4 [...] - Interfacing to the LAN [...] - p. 8 Chapter 2. 1. 5 [...] - LAN topology [...] - p. 8 Chapter 2. 1. 6 [...] - Switching techniques [...] - p. 9 Chapter 2. 2 [...] - Applications of LAN [...] - p. 11 Chapter 2. 2. 1 [...] - Small <b>filestore</b> LAN's [...] - p. 12 Chapter 2. 2. 2 [...] - Wiring replacement LAN's [...] - p. 12 Chapter 2. 2. 3 [...] - Personal computer networks [...] - p. 13 Chapter 2. 2. 4 [...] - General purpose LAN's [...] - p. 13 Chapter 2. 3 [...] - Typical PABX system [...] - p. 14 Chapter 2. 3. 1 [...] - PABX topology [...] - p. 15 Chapter 2. 3. 2 [...] - Circuit switching [...] - p. 15 Chapter 2. 3. 3 [...] - Telephony signalling [...] - p. 16 Chapter 2. 3. 3. 1 [...] - Pulsing [...] - p. 16 Chapter 2. 3. 3. 2 [...] - Subscriber loop signaling [2] [...] - p. 17 Chapter 2. 3. 4 [...] - ISDN (Integrated Services Digital Network) [...] - p. 19 Chapter 2. 4 [...] - Applications of PABX [...] - p. 21 Chapter 2. 5 [...] - Comparisons of LAN and PABX [...] - p. 22 Chapter 3. [...] - INTEGRATION OF PABX WITH LAN [...] - p. 25 Chapter 3. 1 [...] - Advantages of integration of PABX with LAN [...] - p. 25 Chapter 3. 1. 1. [...] - LAN-PABX Gateway [...] - p. 28 Chapter 3. 1. 2. [...] - Problems in interconnecting PABX and LAN [6] [...] - p. 29 Chapter 3. 1. 3. [...] - ISDN-PABX [7] [...] - p. 30 Chapter 3. 2 [...] - Architecture of Integrated LAN and PABX [...] - p. 31 Chapter 3. 3 [...] - Typical applications [...] - p. 32 Chapter 4. [...] - CALL PROCESSING [...] - p. 35 Chapter 4. 1 [...] - Finite State Diagrams for voice calls [...] - p. 37 Chapter 4. 2 [...] - SDL representations of voice calls [...] - p. 39 Chapter 4. 3 [...] - Software implementations of SDL diagrams [...] - p. 40 Chapter 4. 3. 1 [...] - PABX operating system [...] - p. 40 Chapter 4. 3. 2 [...] - Trunk operating system [...] - p. 43 Chapter 4. 3. 3 [...] - Message format [...] - p. 43 Chapter 4. 4 [...] - Pseudo codes for PABX [...] - p. 45 Chapter 4. 4 [...] - Pseudo codes for trunks [...] - p. 52 Chapter 5. [...] - HARDWARE IMPLEMENTATION [...] - p. 57 Chapter 5. 1 [...] - TRUNK INTERFACE [...] - p. 58 Chapter 5. 1. 1 [...] - PABX to CO call [...] - p. 58 Chapter 5. 1. 2 [...] - CO to PABX call [...] - p. 59 Chapter 5. 2 [...] - Subscriber Interface Circuit [...] - p. 59 Chapter 5. 4 [...] - PSTN Trunk Interf ace [...] - p. 60 Chapter 6. [...] - CONCLUSIONS [...] - p. 62 Acknowledgements [...] - p. 64 APPENDIX A [...] - p. 65 CCITT SPECIFICATION AND DESCRIPTION LANGUAGE [15] [...] - p. 65 APPENDIX B [...] - p. 68 "SIGNALLING FOR SWITCHING SYSTEMS IN HK [16],[17]" [...] - p. 68 Chapter B. 1 [...] - Tone plan [...] - p. 68 Chapter B. 2 [...] - Tone levels [...] - p. 68 Chapter B. 3 [...] - Ringing frequency and voltage [...] - p. 68 Chapter B. 4 [...] - Dial pulse [...] - p. 68 Chapter B. 5 [...] - DTMF (Dual-tone multi-frequency) [...] - p. 69 Chapter B. 6 [...] - PCM coding [...] - p. 69 REFERENCES [...] - p. 7...|$|E

