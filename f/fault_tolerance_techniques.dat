287|8625|Public
50|$|Reliability {{improvements}} target {{all aspects}} of UAV systems, using resilience engineering and <b>fault</b> <b>tolerance</b> <b>techniques.</b>|$|E
50|$|The Configurable Fault Tolerant Processor Project aims to {{demonstrate}} the feasibility of using Field Programmable Gate Arrays (FPGAs) for spacecraft computer processing by applying various <b>fault</b> <b>tolerance</b> <b>techniques</b> to the designs. CFTP provides a valuable testbed for on-orbit evaluation of various fault tolerant concepts.|$|E
5000|$|Failure: A {{failure is}} an {{instance}} in {{time when a}} system displays behaviour that is contrary to its specification. An error may not necessarily cause a failure, for instance an exception may be thrown by a system but this may be caught and handled using <b>fault</b> <b>tolerance</b> <b>techniques</b> so the overall operation of the system will conform to the specification.|$|E
40|$|Checkpointing is an {{efficient}} <b>fault</b> <b>tolerance</b> <b>technique</b> used in distributed systems. Due {{to the emerging}} challenges of the mobile distributed system as low bandwidth, mobility, lack of stable storage, frequent disconnections and limited battery life, the <b>fault</b> <b>tolerance</b> <b>technique</b> designed for distributed system can not directly implemented on mobile distributed systems(MDSs). This research paper presents {{an efficient}} low cost synchronous checkpointing algorithm which fit into the mobile environment...|$|R
30|$|Cotroneo et al. (2013) is of {{view that}} fault {{injection}} methods mostly inject faults during experimentation phase and repeat the process various times. Advanced fault injection techniques start injection on encountering specific types {{of events in the}} system. Fault injection is a valid way for validating the <b>fault</b> <b>tolerance</b> <b>technique</b> (Fugini et al. 2009).|$|R
30|$|Many of the {{techniques}} (Chan et al. 2007; Foster et al. 2003; Wei-Tek et al. 2003; Zheng and Lyu 2008; Zheng and Lyu 2009) provided are not appropriate {{to be used in}} different systems having specific performance requirements. An adaptive <b>fault</b> <b>tolerance</b> <b>technique</b> with QoS-aware middleware is proposed by Zheng and Lyu (2010). Zheng model is based on user collaborated QoS aware middleware that can dynamically adjust its <b>fault</b> <b>tolerance</b> configurations in order to achieve reliability and performance.|$|R
40|$|Reliable {{computing}} {{in critical}} tasks is a log-term issue in computer systems. Two major fields of research are fault avoidance techniques and <b>fault</b> <b>tolerance</b> <b>techniques.</b> Even though these techniques {{can be used}} together, {{in many cases they}} are in opposing sides in system design. <b>Fault</b> <b>tolerance</b> <b>techniques</b> are also separated in two major fields, hardware redundancy and time redundancy. In this paper, I am going to compare the fault avoidance techniques with the purely software implemented <b>fault</b> <b>tolerance</b> <b>techniques</b> from with the experiments carried out in a special space mission, the ARGOS project...|$|E
40|$|Reliability {{is one of}} {{the most}} {{important}} quality attributes of a software system. One way to improve the reliability of a software system is to use software <b>fault</b> <b>tolerance</b> <b>techniques.</b> However, existing reliability prediction approaches for component-based systems either do not allow modeling software <b>fault</b> <b>tolerance</b> <b>techniques</b> or do not support defining explicitly reliability-relevant behavioral aspects of software <b>fault</b> <b>tolerance</b> <b>techniques.</b> This limits the ability to apply the approaches in different application contexts. In this paper, we extend the core model of a recent component-based reliability prediction approach to take into consideration software <b>fault</b> <b>tolerance</b> <b>techniques</b> and analyze their impact on the overall reliability of component-based systems. We demonstrate the applicability of our approach by modeling the reliability of the reporting service of a document exchange server and conducting reliability predictions. リサーチレポート（北陸先端科学技術大学院大学情報科学研究科...|$|E
40|$|In this paper, we give {{a survey}} on various <b>fault</b> <b>tolerance</b> <b>techniques</b> and related issues in {{distributed}} systems. More specially speaking, {{we talk about}} two most important issues; multiple fault handling capability and performance. This survey provides the related research results and also explored the future directions about <b>fault</b> <b>tolerance</b> <b>techniques,</b> {{and it is a}} good reference for researcher...|$|E
40|$|Absfmct- Algorithm-based <b>fault</b> <b>tolerance</b> (ABFT) is a low-overbead {{system-level}} <b>fault</b> <b>tolerance</b> <b>technique.</b> Many ABFT schemes {{have been}} proposed {{in the past for}} fast Fourier transform (FFT) networks. In this work, a new ABFT scheme for F m networks is proposed. We show that the new approach maintains the high throughput of previous schemes, yet needs lower hardware overhead and achieves higher fault converge than previous schemes by. IOU et aL and Tao et aL Index Terms- Algorithm-based <b>fault</b> <b>tolerance,</b> concurrent error detection, fast Fourier transform, hardware redundancy schemes, transient errors. I...|$|R
30|$|In {{order to}} design {{reliable}} SOA applications, important design decisions {{have to be}} made by the architect. Such decisions are difficult, especially in the context of mashups, since the architect has to consider many aspects related to both <b>fault</b> <b>tolerance</b> and SOA-specific quality requirements. Regarding <b>fault</b> <b>tolerance,</b> the architect has to consider, for example: the availability of variants, the best <b>fault</b> <b>tolerance</b> <b>technique</b> to be used in a certain context, how the system should fail and scenarios involving error detection and handling (failure modes), the categories of faults to be tolerated (fault latency), assumptions about the environment and components (fault assumptions), etc.|$|R
30|$|In retry, if {{a problem}} occurs in a {{distributed}} application, and due to that problem the application stops, then instead of finding {{the cause of the}} problem, we restart the application. Retry is considered to be the simplest failure recovery or <b>fault</b> <b>tolerance</b> <b>technique.</b> That is to say that, we hope that whatever were the causes of failures, the effect will not be encountered in the subsequent retries (Hwang and Kesselman 2003).|$|R
40|$|Current {{usage of}} {{computers}} and data communication networks {{for a variety of}} daily tasks, calls for widespread deployment of <b>fault</b> <b>tolerance</b> <b>techniques</b> with inexpensive off-the-shelf hardware and software. Group communication is in this context a particularly appealing technology, as it provides to the application programmer reliability guarantees that highly simplify many <b>fault</b> <b>tolerance</b> <b>techniques.</b> It ha...|$|E
40|$|This paper {{describes}} software <b>fault</b> <b>tolerance</b> <b>techniques</b> {{to mitigate}} SEU faults in the Raw architecture, {{which is a}} single-chip parallel tiled computing architecture. The <b>fault</b> <b>tolerance</b> <b>techniques</b> we use are efficient Checkpointing and Rollback of processor state, Break-pointing, Selective Replication of code and Selective Duplication of tiles. Our <b>fault</b> <b>tolerance</b> <b>techniques</b> can be fully implemented in the software, without any changes to the architecture, transparent to the user, and designed to fulfill run-time performance and throughput requirements of the system. We illustrate these techniques by mitigating matrix multiply kernel mapped on Raw. The proposed techniques are also applicable to other tiled architectures (and also parallel systems in general). 1...|$|E
40|$|In {{this paper}} we give a survey on various <b>fault</b> <b>tolerance</b> <b>techniques</b> and related issues in {{distributed}} systems and WSNs. More specially speaking, {{we talk about}} two most important issues; multiple fault handling capability and performance. This survey provides the related research results and also explored the future directions about <b>fault</b> <b>tolerance</b> <b>techniques,</b> {{and it is a}} good reference for researcher...|$|E
40|$|Hazard {{radiation}} {{can lead}} the system <b>fault</b> therefore <b>Fault</b> <b>Tolerance</b> is required. <b>Fault</b> Tolerant is a system, {{which is designed}} to keep operations running, despite the degradation in the specific module is happening. Many <b>fault</b> <b>tolerances</b> have been developed to handle the problem, to find the most robust and efficient in the possible technology. This paper will present the Five Modular Redundancy (FMR) with Mitigation Technique to Recover the Error Module. With Dynamic Partial Reconfiguration technology that have already available today, such <b>fault</b> <b>tolerance</b> <b>technique</b> can be implemented successfully. The project showed the robustness of the system is increased and module which is error can be recovered immediately. Comment: 6 Page...|$|R
40|$|In {{this paper}} we {{investigate}} the different <b>techniques</b> of <b>fault</b> <b>tolerance</b> {{which are used}} in many real time distributed systems. The main focus is on types of fault occurring in the system, fault detection techniques and the recovery techniques used. A fault can occur due to link failure, resource failure or by any other reason is to be tolerated for working the system smoothly and accurately. These faults can be detected and recovered by many techniques used ccordingly. An appropriate fault detector can avoid loss due to system crash and reliable <b>fault</b> <b>tolerance</b> <b>technique</b> can save from system failure. This paper provides how these methods are applied to detect and tolerate faults from various Real Time Distributed Systems...|$|R
40|$|We study recent {{developments}} in quantum computing (QC) testing and <b>fault</b> <b>tolerance</b> (FT) <b>techniques</b> and discuss several attempts to formalize quantum logic fault models. We illustrate the inherent need for <b>fault</b> <b>tolerance</b> in QC due to the decoherence problem. Further, we examine several ideas regarding random testing and examine the viability of built-insystem-test (BIST) in future QC circuits. 1...|$|R
40|$|Traditional modular {{redundancy}} {{based upon}} software <b>fault</b> <b>tolerance</b> <b>techniques,</b> such as N-version programming and recovery blocks, is now widely known {{and its use}} is on the increase. By contrast, data <b>fault</b> <b>tolerance</b> <b>techniques</b> have been largely ignored. The most likely reason for this omission is the perception that implementations are highly complex. Fortunately this situation has been greatly improved by object oriented systems which supply many of the required facilities. These allow data <b>fault</b> <b>tolerance</b> <b>techniques</b> {{to take their place}} alongside software design diversity techniques. Currently the areas of software fault tolerance and object-oriented techniques have been developed separately. This paper describes an approach to merge these two areas, providing a framework to utilise object-oriented approaches to achieve software fault tolerance incorporating both design and data diversity techniques. Index Terms [...] - Software fault tolerance, object fault tolerance, design diversity, [...] ...|$|E
30|$|We are not {{familiar}} with any work that surveys diverse fault-tolerant SOAs. As a consequence, we address, in turn, work related to literature review of <b>fault</b> <b>tolerance</b> <b>techniques</b> in general.|$|E
30|$|The second {{challenge}} {{faced by}} GridTS—providing a fault-tolerant scheduling infrastructure—is treated by combining three <b>fault</b> <b>tolerance</b> <b>techniques</b> to tolerate crash faults in {{components of the}} its infrasctructure: replication, checkpointing and transactions.|$|E
40|$|In this paper, {{we propose}} a {{low-cost}} <b>fault</b> <b>tolerance</b> <b>technique</b> for microprocessor multipliers, both non-pipelined (NP) and pipelined (P). Our fault tolerant multiplier designs {{are capable of}} detecting and correcting errors, diagnosing hard faults, and reconfiguring to take the faulty subunit off-line. We utilize the branch misprediction recovery mechanism in the microprocessor core to take the error detection process off the critical path. Our analysis shows that our scheme provides 99 % fault security and, compared to a baseline unprotected multiplier, achieves this <b>fault</b> <b>tolerance</b> with low performance overhead (5 % for NP and 2. 5 % for P multiplier) and reasonably low area (38 % NP and 26 % P) and power consumption (36 % NP and 28. 5 % P) overheads. ...|$|R
40|$|The {{primary goal}} was to {{determine}} whether the application of <b>fault</b> <b>tolerance</b> to software increases its reliability if the cost of production is the same as for an equivalent nonfault tolerance version derived from the same requirements specification. Software development protocols are discussed. The feasibility of adapting to software design <b>fault</b> <b>tolerance</b> the <b>technique</b> of N-fold Modular Redundancy with majority voting was studied...|$|R
40|$|We {{present a}} new {{approach}} to <b>fault</b> <b>tolerance</b> for High Performance Computing system. Our approach is based on a careful adaptation of the Algorithmic Based <b>Fault</b> <b>Tolerance</b> <b>technique</b> (Huang and Abraham, 1984) to the need of parallel distributed computation. We obtain a strongly scalable mechanism for <b>fault</b> <b>tolerance.</b> We can also detect and correct errors (bit-flip) on the fly of a computation. To assess the viability of our approach, we have developed a fault tolerant matrixmatrix multiplication subroutine and we propose some models to predict its running time. Our parallel fault-tolerant matrix-matrix multiplication scores 1. 4 TFLOPS on 484 processors (cluster jacquard. nersc. gov) and returns a correct result while one process failure has happened. This represents 65 % of the machine peak efficiency and less than 12 % overhead with respect to the fastest failure-free implementation. We predict (and have observed) that, as we increase the processor count, the overhead of the <b>fault</b> <b>tolerance</b> drops significantly...|$|R
30|$|After {{defining}} the initial specification related to fault tolerance, {{the last step}} is to review the feasibility of the designed solution and refine it based on concepts related to classical <b>fault</b> <b>tolerance</b> <b>techniques.</b> In order to make this task easier, in the following we provide a summary comparing classical <b>fault</b> <b>tolerance</b> <b>techniques,</b> which is important for choosing a design solution, giving a {{special attention to the}} type of adjudicator. It is important to stress that the design issues presented are compliant with the taxonomy presented in Figure 4. Instead of presenting a full discussion on such techniques, we summarise some of the findings on design diversity, in particular the findings related to non-functional characteristics of the described design solutions, represented by the taxonomy. The analysis of these characteristics provide a good support to define the system fault tolerance (Section 5). A summary of results and discussion for supporting the SOA architect on choosing <b>fault</b> <b>tolerance</b> <b>techniques</b> is presented in the following. A detailed discussion {{in the context of a}} literature review of existing solutions is presented in Section 5.|$|E
30|$|Proactive and {{reactive}} <b>fault</b> <b>tolerance</b> <b>techniques</b> {{are placed}} in the fault treatment and removal category. The significant difference between them is that the proactive techniques anticipate and predict, while the reactive mechanisms react and respond.|$|E
30|$|Section 5 {{discusses}} the threats and {{the validity of}} the review. Section 5 presents related work, which also considers related literature reviews of software <b>fault</b> <b>tolerance</b> <b>techniques.</b> Finally, Section 5 presents some concluding remarks and directions for continuing work.|$|E
40|$|Nowadays use of {{distributed}} {{systems such as}} internet and cloud computing is growing dramatically. Coordinator existence in these systems is crucial due to processes coordinating and consistency requirement as well. However the growth makes their election algorithm even more complicated. Too many algorithms are proposed in this area but the two most well known one are Bully and Ring. In this {{paper we propose a}} fault tolerant coordinator election algorithm in typical bidirectional ring topology which is twice as fast as Ring algorithm although far fewer messages are passing due to election. <b>Fault</b> <b>tolerance</b> <b>technique</b> is applied which leads the waiting time for the election reaching to zero...|$|R
40|$|Cloud {{computing}} {{has emerged}} as one of the latest technologies for delivering on-demand sophisticated services over the Internet. To make effective use of tremendous capabilities of the cloud, efficient scheduling algorithms are required. While concerning on large scale system, <b>fault</b> <b>tolerance</b> is a very critical issue, since the cloud resources are extensively disseminated among diverse locations. This leads to a higher probability of failures while solving huge problems, thus the cloud service reliability could be relatively low. Therefore, providing an effective <b>fault</b> <b>tolerance</b> <b>technique</b> for a cloud system is mandatory. This paper introduces an efficient and reliable Rule-based Semantic Fault Tolerant Scheduling (RSFTS) technique for Cloud Environment. The overall system is described semantically to assign resources based on a set of semantic rules. The proposed technique could achieve the maximum reliability, availability and high efficiency. </p...|$|R
40|$|This {{technical}} report presents the design, validation {{and evaluation of}} an efficient online <b>fault</b> <b>tolerance</b> <b>technique</b> for <b>fault</b> detection and recovery in presence of three TSV defects: voids, delamination between TSV and landing pad, and TSV short-to-substrate. The technique employs transition delay test for TSV fault detection. Fault recovery is carried out by employing redundant TSVs and rerouting input/output signals to fault-free TSVs. This technique is efficient because it requires small (2 x number of TSVs per group) number of clock cycles for fault detection and recovery. Using 65 -nm technology, simulations are carried out using HSPICE and ModelSim to validate fault detection and recovery. Synthesized RTL model of this technique is {{used to evaluate the}} area overhead. It is shown that regular and redundant TSVs can be divided into groups to minimize area overhead without affecting <b>fault</b> <b>tolerance</b> capability of the technique...|$|R
40|$|Abstract — Scalability {{models are}} {{powerful}} analytical tools for evaluating and predicting {{the performance of}} parallel applica-tions. Unfortunately, existing scalability models do not quantify failure impact and therefore cannot accurately account for application performance {{in the presence of}} failures. In this study, we extend two well-known models, namely Amdahl’s law and Gustafson’s law, by considering the impact of failures and the effect of <b>fault</b> <b>tolerance</b> <b>techniques</b> on applications. The derived reliability-aware models can be used to predict application scalability in failure-present environments and evaluate <b>fault</b> <b>tolerance</b> <b>techniques.</b> Trace-based simulations via real failure logs demonstrate that the newly developed models provide a better understanding of application performance and scalability in the presence of failures. I...|$|E
40|$|Abstract- Fault {{tolerance}} is a {{major concern}} to guarantee availability and reliability of critical services as well as application execution. In order to minimize failure impact on the system and application execution, failures should be anticipated and proactively handled. <b>Fault</b> <b>tolerance</b> <b>techniques</b> are used to predict these failures and take an appropriate action before failures actually occur. This paper discusses the existing <b>fault</b> <b>tolerance</b> <b>techniques</b> in cloud computing based on their policies, tools used and research challenges. Cloud virtualized system architecture has been proposed. In the proposed system autonomic fault tolerance has been implemented. The experimental results demonstrate that the proposed system can deal with various software faults for server applications in a cloud virtualized environment...|$|E
30|$|Proactive fault tolerance: Fault is an another {{challenge}} {{to guarantee the}} critical service availability and reliability. Failures should be anticipated and proactively handled, to minimize failure impacts on the application execution and system performance. For this different type of <b>fault</b> <b>tolerance</b> <b>techniques</b> are used [54].|$|E
40|$|As {{multiprocessor}} systems {{become more}} complex, their reliability {{will need to}} increase as well. In this {{paper we propose a}} novel technique which is applicable {{to a wide variety of}} distributed real-time systems, especially those exhibiting data parallelism. System-level <b>fault</b> <b>tolerance</b> involves reliability <b>techniques</b> incorporated within the system hardware and software whereas application-level <b>fault</b> <b>tolerance</b> involves reliability <b>techniques</b> incorporated within the application software. We assert that, for high reliability, a combination of system-level <b>fault</b> <b>tolerance</b> and application-level <b>fault</b> <b>tolerance</b> works best. In many systems, application-level <b>fault</b> <b>tolerance</b> can be used to bridge the gap when system-level <b>fault</b> <b>tolerance</b> alone does not provide the required reliability. We exemplify this with the RTHT target tracking benchmark and the ABF beamforming benchmark. Keywords: distributed real-time systems, <b>fault</b> <b>tolerance,</b> checkpointing, imprecise computation, target tracking, be [...] ...|$|R
40|$|International audienceThis paper {{presents}} a new fault injection method {{based on the}} CEU (Code Emulated Upsets) strategy that simulates the consequences of SEUs (Single Event Upsets) in complex digital circuits such as processors, observed in radiation ground test experiments. Multiple upsets are injected during the program execution at instants following the probability distribution obtained from radiation static tests. Upsets are injected in all accessible targets of the studied processor (registers, internal memories, cache memories) with minimum intrusiveness, using an interrupt mechanism. The proposed approach was validated on a 64 -bits MIPS processor. Fault injection campaigns evaluated both {{the impact on the}} errors occurring in the data cache and the efficiency of a software implemented <b>fault</b> <b>tolerance</b> <b>technique...</b>|$|R
40|$|Since {{the last}} decade, {{computing}} systems turn to large scale parallel platforms composed {{of thousands of}} processors. Many actual applications run on such systems for long duration, up to several days or weeks. Recently, statistic studies about failures on high performance computing platforms emphasize that the {{mean time between failures}} may not exceed few hours. Thus, it is necessary to develop effcient strategies providing a safe and reliable completion of applications. This may be achieved through redundancy or by storing intermediate computation states on reliable external devices. Saved states are then used to restart computations from the last checkpoint. This last approach called checkpointing {{is one of the most}} popular <b>fault</b> <b>tolerance</b> <b>technique</b> in parallel systems...|$|R
