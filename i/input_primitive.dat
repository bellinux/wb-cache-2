8|80|Public
30|$|We have {{introduced}} the discrete-tilt concept for text entry, {{which is a}} special case of tilt-based interaction wherein the <b>input</b> <b>primitive</b> is triggered after a well-defined sequence of Pitch or Roll movements of the mobile device. As opposed to solutions that use continuous-tilt approach, discrete-tilt-based interaction in great deal does not rely on visual feedback. Altogether eight input primitives have been proposed and applied for text entry.|$|E
30|$|Finally, we {{find the}} idea of {{combining}} discrete-tilt and continuous-tilt within cursor-based text entry methods an idea worth to consider. Such an approach would assume continuous <b>input</b> <b>primitive</b> invocations once the device leaves the neutral position zone, but with distinct audio and/or tactile feedback for every single invocation. Consequently, the cursor could be continuously moved in a particular direction, with the corresponding interaction still less relying on any visual feedback. The implementation of the proposed design is already underway.|$|E
30|$|We {{furthermore}} enriched the discrete-tilt concept {{with the}} possibility of dwelling in the valid tilt zone. Specifically, if the smartphone is retained in the valid tilt zone for a well-defined amount of time before returning to the neutral position zone, a different <b>input</b> <b>primitive</b> could be invoked. We call this type of movement sequence a long tilt. Since the previously described interaction can result either with the regular or the long tilt, we can state that altogether eight input primitives can be generated using our discrete-tilt concept.|$|E
3000|$|..., {{since the}} related <b>input</b> <b>primitives</b> (2 sRL, 2 sRR, 2 sPU, and 2 sPD) are {{directly}} {{assigned to the}} one of four available options.|$|R
40|$|We {{describe}} {{a method for}} doing image compositing using either 2 D geometric shapes or raster images as <b>input</b> <b>primitives.</b> The resolution of the final image is virtually unlimited but, as no frame buffer is used, performance is much less dependant on resolution than with standard painting programs, allowing rendering very large images in reasonable time. Many standard features found in compositing programs have been implemented, like hierarchical data structures for <b>input</b> <b>primitives,</b> lighting control for each layer and filter operations (for antialiasing or defocus). 1...|$|R
30|$|In {{this section}} we {{introduce}} three different text entry methods {{that rely on}} the discrete-tilt concept. The design and interaction are described with special emphasis being on keyboard layouts and corresponding input schemes description. For every interaction method we calculate the number of discrete tilts (<b>input</b> <b>primitives)</b> required to select a given character.|$|R
40|$|We {{present a}} {{formalism}} for provenance in distributed systems {{based on the}} ?-calculus. Its main feature is that all data products are annotated with metadata represent- ing their provenance. The calculus is given a provenance tracking semantics, which ensures that data provenance is updated as the computation proceeds. The calculus also enjoys a pattern-restricted <b>input</b> <b>primitive</b> which al- lows processes to decide what data to receive and what branch of computation to proceed with based on the provenance information of data. We give examples to illustrate {{the use of the}} calculus and discuss some of the semantic properties of our provenance notion. We con- clude by reviewing related work and discussing direc- tions for future research...|$|E
40|$|We {{evaluated}} tilt as {{an input}} method for devices with built-in accelerometers, such as touchscreen phones and tablet computers. The evaluation was empirical and experimental. Sixteen participants performed a tilt-based position-select task, {{similar to the}} multi-directional Fitts’ law task in ISO 9241 - 9. Four levels of tilt gain (25, 50, 100, and 200) and two selection modes (first-entry and 500 ms dwell) were used. Movement times were lowest with tilt gain = 50 and first-entry selection. Maximum tilt angles ranged from about 2 ° to 13 °, depending on condition. Tilt as an <b>input</b> <b>primitive</b> is shown to conform to Fitts ’ law. Throughput is low, however, about 2. 3 bits/s for first-entry and 1. 2 bits/s for dwell. ACM Classification: H. 5. 2 [Information interfaces an...|$|E
30|$|Since {{it is very}} {{cumbersome}} to keep {{a mobile}} device in its neutral position with zero pitch/roll angles, especially when walking, we define a neutral position zone - an angle-based offset wherein the device {{is assumed to be}} motionless. Basically, tilting within the neutral position zone will never invoke any particular action, hence involuntary movements will be filtered out. When the device leaves the neutral position zone, it means that the user is starting to execute the tilt sequence intentionally. To make a valid discrete tilt, the pitch/roll threshold angle should be exceeded by tilting in the wanted direction. The threshold angle is introduced in order to augment the disambiguation between spontaneous and deliberate movements, as well as to provide required wrist strokes in line with natural interaction. It is reasonable to define separate threshold angles for Pitch and Roll because constraints of different wrist movements (flexion, pronation, supination, ulnar and radial deviation) are not equal [12]. Once the threshold angle has been surpassed, the device is assumed to be positioned in the valid tilt zone. Finally, an immediate backward movement from the valid tilt zone to the neutral position zone results with the <b>input</b> <b>primitive</b> invocation.|$|E
40|$|We {{present a}} method for image {{compositing}} and rendering using 2 D geometric shapes or raster images as <b>input</b> <b>primitives,</b> disposed in a 3 D environment around which the camera can move. An animation system has been implemented which calculates camera and scene information to render the frames. The key features of this quasi- 3 D system are described. Two animations generated by the system are given as examples...|$|R
30|$|The {{paper is}} {{structured}} as follows. In Related work section we describe existing tilt-based text entry solutions that {{usually do not}} use the QWERTY layout, and/or rely on continuous application feedback. Pitch and Roll as <b>input</b> <b>primitives</b> for mobile devices section introduces the tilt-based concept which supports an interaction less relying on visual feedback; here we define Pitch and Roll movement sequences as discrete-tilt <b>input</b> <b>primitives</b> for mobile devices. In Discrete-tilt Pitch and Roll based text entry methods section we apply the proposed input commands on text entry in the mobile, by introducing three different text entry methods that utilize both QWERTY-based keyboard layouts and discrete-tilt-based strategies for character selection. Modeling upper-bound text entry speeds section deals with the proposed methods, targeting error-free interaction and expert-level input efficiency. We describe the used modeling methodology which consists of: (i) user experiment which is conducted to determine the time of discrete-tilt execution, (ii) movement models able to predict the total time required to enter a particular character, (iii) a constructed linguistic model for the English language that provides a matrix of digraph probabilities, and (iv) calculated predictions for discrete-tilt-based text entry speeds. In Discussion section we evaluate the proposed designs {{with respect to the}} predictions hence obtained, and discuss the model limitations. The last section offers a brief recapitulation, including the outline of our future research plan.|$|R
40|$|The {{computational}} Grid is {{a promising}} {{platform for the}} deployment of large-scale scientific and engineering application. This paper presents a Quasi- 3 D (almost true 3 D) animation system using either 2 D geometric shapes or raster images (cels) as <b>input</b> <b>primitives.</b> Rendering high-quality computer images requires intensive computation, and therefore {{a large amount of}} time. To speed up the rendering process, a Grid environment has been constructed with Globus and Condor in which a large number of animation frames can be rendered simultaneously using disparate Grid resources. The results show that the rendering performance has been highly improved using the Grid environment...|$|R
40|$|Abstract. Clipping a {{triangle}} or a convex quadrilateral to a plane {{is a common}} operation in computer graphics. This clipping is implemented by fixed-function units within the graphics pipeline under most rasterization APIs. It is increasingly interesting to perform clipping in programmable stages as well. For example, to clip bounding volumes generated in the Geometry unit to the near plane, or to clip an area light source to the tangent plane of a surface in a Pixel unit. While clipping a convex polygon is algorithmically trivial, doing so efficiently on vector architectures like GPUs can be tricky. This article presents an efficient implementation of Sutherland-Hodgman clipping for vector processors. It has high branch coherence, uses only register storage (i. e., {{it does not require}} a move-relative memory operation), leverages both data and instruction parallelism, and has a peak register count of only two 4 -vectors (7 scalars). I found it to be about five times faster than direct Sutherland-Hodgman and yield a 45 % increase in net throughput when applied in the algorithm from a previous publication on two different GPU architectures. The principles of optimization presented for this class of parallel algorithm extend to other algorithms and architectures. The result of clipping a primitive by a plane is the intersection of the primitive and the positive half-space bounded by the plane. If the <b>input</b> <b>primitive</b> is a convex polygon with k vertices, then result is expressible as a convex polygon with k + 1 vertices, assuming we allow a zero-area polygon to represent the empty intersection and allow the result to contain degenerate vertices. Clipping arises frequently in computer graphics. For example, one often clips 3 D polygons to the near plane so that their 2 D projection is continuous and easy to rasterize or bound. An increasing number of algorithm...|$|E
40|$|Abstract] Although {{the first}} {{electronic}} circuit {{specifically designed to}} accelerate rendering {{was developed in the}} early 1980 s, the term GPU (Graphics Processing Unit) was popularized by the Nvidia Geforce 256 in 1999. From this first single-chip processor, which processes a minimum of ten million polygons per second, to current GPUs, which offer a competitive solution to massive parallel computation, there has been continuous research and uninterrupted growth. In recent years, the demand for computer graphics has expanded across many scientific and engineering areas. Hence, the interactive rendering of complex and realistic models has become a hot topic in computer graphics, supported by unstoppable development in the pipeline of the GPU. Current GPU pipelines are triangle oriented and have been designed to process and render a large amount of triangles. Nevertheless, as the CPU-GPU bus is a habitual bottleneck, a triangle-oriented pipeline {{has proved to be a}} limited solution. As complex models can be more precisely described by equations than by a triangle mesh, parametric surfaces have gained ground as a new paradigm as they introduce relevant characteristics into the representation along with the rendering of complex models in real time. The compact representation provided by these surfaces reduces memory consumption and, moreover, its representation provides smoother, more continuous models than a set of triangles. Parametric surfaces can also select the level of detail on the y and they are invariant under an afine transformation, thus they can be easily scalable. In addition to their mathematical characteristics, parametric surfaces provide interesting properties in computer graphics as animation and collision detection become simpler and faster than a set of polygons, owing to the fact that a much smaller number of points need to be processed. Nonetheless, parametric surfaces are usually tessellated as set of triangles in the CPU and finally these triangles are sent down the GPU pipeline to be rendered. This dissertation goes a step further and proposes the evaluation and tessellation of parametric surfaces on the GPU. This dissertation includes a deep analysis of the rendering of parametric surfaces on the GPU focused on the mathematical characteristics of parametric surfaces with the aim of providing an efficient strategy for rendering complex models in real time. Two different parametric surfaces have been analyzed: Bezier and NURBS surfaces. Bezier surfaces have been considered as an <b>input</b> <b>primitive</b> owing to their simple and regular representation. However, as the NURBS descriptions are more suitable for complex models, the direct rendering of NURBS models has also been analyzed in this thesis. In conclusion, this thesis elaborates on different strategies for the real time rendering of complex models represented as parametric surfaces. In this thesis a set of schemes for the tessellation of Bezier surfaces on the GPU are designed: a non-adaptive approach, a fully adaptive proposal and a semiadaptive approach with an intermediate degree of exibility. The non-adaptive proposal is based on the on-the- y generation of the parametric grid according to the level of resolution of each object and the camera position that determines the refinement degree of the surface. This proposal considers each Bezier surface as the <b>input</b> <b>primitive</b> to the pipeline, thus Bezier surfaces are tessellated and evaluated on the GPU and the computational power of current GPUs is exploited with a computational complex shader and an optimized memory access is designed. Although a single version of the proposal is possible, generating two different variants allows many specific details to be tweaked for optimal performance, depending on the speci fic GPU architecture. Therefore, a Vertex Shader Tessellation (VST) variant is designed for GPU which could only operate on existing data, such as pipelines based on DirectX 9 Meanwhile a Geometry Shader Tessellation (GST) variant is designed for GPUs which allows the generation and destruction of geometric primitives, such as those based on DirectX 10 or DirectX 11. With respect to the fully adaptive, Dyanamic and Adaptive Bezier Tessellation (DABT), and semi-adaptive proposals, the aim is to reduce the number of triangles in the final mesh while maintaining the quality of the resulting image. Surface tessellation must be sufficiently fine to capture geometric and appearance details. Nevertheless, overtessellating results in an increasing surface evaluation and rasterization workload. Both schemes are based on a 3 -stage pipeline: first, a fixed tessellation pattern is computed to guide the adaptive procedure for the patch; next, the new vertices obtained from the first step are conditionally inserted by applying a set of heuristics consisting of tests local to the patch; finally, a specific scheme is employed to represent the inserted vertices and the reconstruction methodology based on the preprocessing of this information. The quality of the final triangle mesh is determined by both the inserted vertices and the reconstruction method employed to generate the resulting mesh. These proposals allow all triangles generated by them to be processed independently without introducing T-junctions or mesh cracks. Unlike the DABT proposal, which permits multiple levels of resolution inside a patch, the semi adaptive proposal is characterized by a lower degree of divergence, reducing the adaptive degree of exibility. This latter scheme is a tradeoff between a non-adaptive tessellation scheme and a fully adaptive proposal. The objective is to reduce the irregularity of the algorithm and the associated divergence of the DABT in order to optimize the graphics hardware utilization. The final chapter in this dissertation goes a step further, and a new pipeline called Rendering Pipeline for NURBS Surfaces (RPNS) is presented. RPNS is a novel solution for the direct rendering of NURBS surfaces on the GPU with no previous tessellation procedure or preprocessing. A deep analysis of current GPU pipeline evinces that the current stages for primitive generation, such as geometry shader or tessellator, are not suitable for the direct rendering of NURBS surfaces on the GPU. Hence, a NURBS-oriented pipeline (RPNS) has been designed according to the geometric characteristics of NURBS surfaces. The aim is to efficiently render each surface so that the final image has no cracks or holes, neither inside each surface nor between neighbor surfaces, making it possible to exploit the parallelism of the GPU to perform common operations, such as sketching on surfaces, interactive trimming or surface intersection. RPNS is based on a new primitive called KSQuad, which allows the direct rendering of NURBS surfaces. The design of RPNS relies on two mainstays to achieve sound performance and high-qualilty results: adaptive discretization of KSQuad and evaluation of NURBS surfaces with no approximation. To test our proposals, and even though this thesis focuses principally on algorithmic improvements to the rendering pipeline rather than an optimized implementation, these proposals have been implemented to measure their performance on current GPUs, achieving real-time rendering rates...|$|E
30|$|Finally, in our {{previous}} work we introduced a fully functional text entry prototype for Android devices in which the standard touch modality {{could be used in}} combination with Pitch and Roll movements [11]. We used the concept of discrete tilts for <b>input</b> <b>primitives,</b> as well as a special QWERTY-based keyboard layout and an original input scheme for character selection. The prototype was successfully tested on four devices from both smartphone and tablet class. This proposed text entry method inspired us to develop two additional tilt-based solutions that are described in detail in the following, together with the original one, and comparatively analyzed using predictive modeling.|$|R
40|$|We {{present a}} novel {{approach}} to voxelization, based on intersecting the <b>input</b> <b>primitives</b> against intersection tar-gets in the voxel grid. Instead of relying on geometric proximity measures, our approach is topological in nature, i. e., it builds on the connectivity and separability properties of the input and the intersection targets. We discuss voxelization of curves and surfaces in both 2 D and 3 D, and derive intersection targets that produce voxeliza-tions with various connectivity, separability and thinness properties. The simplicity of our method allows for easy proofs of these properties. Our approach is directly applicable to curved primitives, and it is independent of input tessellation. 1...|$|R
40|$|Existing {{techniques}} for object tracking with Multiple Instance Learning take {{the approach of}} extracting low-level patches of fixed size and aspect ratios within each image, and employ many simplistic assumptions. In this work, we propose an approach that automatically utilizes image segments as <b>input</b> <b>primitives</b> to develop a multi-level segmentation-based system, and build a target model refinement procedure that learns the optimal model corresponding to the target object. To go beyond existing restrictive assumptions, we further develop automatic scene environmental models to assign prior probabilities to segment instances {{of belonging to the}} target vs scene. We demonstrate impressive qualitative and quantitative results with tracking sequences in typical outdoor surveillance settings. ...|$|R
40|$|For {{a number}} of years, {{robotics}} researchers have exploited hierarchical representations of geometrical objects and scenes in motion-planning, collision-avoidance, and simulation. However, few general techniques exist for automatically constructing them. We present a generic, bottom-up algorithm that uses a heuristic clustering technique to produced balanced, coherent hierarchies. Its worst-case running time is O(N{sup 2 }logN), but for non-pathological cases it is O(NlogN), where N {{is the number of}} <b>input</b> <b>primitives.</b> We have completed a preliminary C++ implementation for input collections of 3 D convex polygons and 3 D convex polyhedra and conducted simple experiments with scenes of up to 12, 000 polygons, which take only a few minutes to process. We present examples using spheres and convex hulls as hierarchy primitives...|$|R
40|$|Collision {{detection}} is {{an important}} component in simulation applications which are based on virtual geographic information system (VGIS). In this paper, an effective collision detection algorithm for multiple objects in VGIS, VGIS-COLLIDE, is presented. The algorithm firstly integrates existing quadtree, which is the global hierarchical structure of VGIS, with axis-aligned bounding box of object to perform the broad-phase of collision detection. After that, exact collision detection between two objects which have passed the broad-phase of collision detection is performed. The algorithm makes no assumption about <b>input</b> <b>primitives</b> or object's motion and is directly applicable to all triangulated models. It can be applicable to both rigid and deformable objects without preprocessing. The performance of the algorithm has been demonstrated in several environments consisting of a high number of objects with hundreds of thousands of triangles...|$|R
40|$|We {{present a}} new {{approach}} for computing generalized Voronoi diagrams in two and three dimensions using interpolation-based polygon rasterization hardware. The <b>input</b> <b>primitives</b> may be points, lines, polygons, curves, or surfaces. The algorithm computes a discrete Voronoi diagram by rendering a three dimensional distance mesh corresponding to each primitive. The polygonal mesh is a bounded-error approximation of a nonlinear distance function. The algorithm divides the space into regular cells. For each cell it computes the closest primitive and the distance to that primitive using polygon scan-conversion and Z-buffer depth comparison. We present efficient techniques to detect Voronoi boundaries and compute Voronoi neighbors. The algorithm has been implemented on SGI workstations and PCs using OpenGL and applied to complex 2 D and 3 D datasets. We also demonstrate the applications of our algorithm to fast motion planning in static and dynamic environments, and improving the performance of continuous Voronoi diagram computation...|$|R
40|$|National High Technology Research and Development Program of China (863 Programme) 2009 AA 12 Z 331 Collision {{detection}} is {{an important}} component in simulation applications which are based on virtual geographic information system (VGIS). In this paper, an effective collision detection algorithm for multiple objects in VGIS, VGIS-COLLIDE, is presented. The algorithm firstly integrates existing quadtree, which is the global hierarchical structure of VGIS, with axis-aligned bounding box of object to perform the broad-phase of collision detection. After that, exact collision detection between two objects which have passed the broad-phase of collision detection is performed. The algorithm makes no assumption about <b>input</b> <b>primitives</b> or object's motion and is directly applicable to all triangulated models. It can be applicable to both rigid and deformable objects without preprocessing. The performance of the algorithm has been demonstrated in several environments consisting of a high number of objects with hundreds of thousands of triangles...|$|R
40|$|The paper {{describes}} {{the development of}} a fuzzy knowledge based prototype system for conceptual design. This real time system is designed to infer user’s sketching intentions, to segment sketched input and generate corresponding geometric primitives: straight lines, circles, arcs, ellipses, elliptical arcs, and B-spline curves. Topology information (connectivity, unitary constraints and pairwise constraints) is received dynamically from 2 D sketched <b>input</b> and <b>primitives...</b>|$|R
40|$|A recent {{trend in}} model-based object {{recognition}} {{is to build}} efficient systems for primary hypotheses generation. These systems, also called visual indexing, rely {{on the assumption that}} object identification can be performed by recovering local invariants. However, reliable and significant local features are difficult to retrieve when the image background is not uniform. Our solution to this problem takes advantage of a new concept called temporal precedence. The originality of the approach consists in transforming the initial static input image into a dynamic flow of data. Primitives extracted from the image are temporally ranked so as to favor most relevant features for recognition. Most importantly, ranks of features of different kinds may be compared. The architecture of our indexing system is composed of a set of knowledge sources which update in parallel a blackboard structure. The asynchronism produced by the flow of <b>input</b> <b>primitives</b> is used in the activation strategy of knowledge sources...|$|R
40|$|We {{present a}} novel {{approach}} for fast collision detection between multiple deformable and breakable objects in a large environment using graphics hardware. Our algorithm takes into account low bandwidth {{to and from the}} graphics cards and computes a potentially colliding set (PCS) using visibility queries. It involves no precomputation and proceeds in multiple stages: PCS computation at an object level and PCS computation at sub-object level, followed by exact collision detection. We use a linear time two-pass rendering algorithm to compute each PCS efficiently. The overall approach makes no assumption about the <b>input</b> <b>primitives</b> or the object's motion and is directly applicable to all triangulated models. It has been implemented on a PC with NVIDIA GeForce FX 5800 Ultra graphics card and applied to different environments composed of a high number of moving objects {{with tens of thousands of}} triangles. It is able to compute all the overlapping primitives between different objects up to image-space resolution in a few milliseconds...|$|R
40|$|International audienceEvaluating {{mathematical}} expression recognition {{involves a}} complex interaction of <b>input</b> <b>primitives</b> (e. g. pen/finger strokes), recognized symbols, and recognized spatial structure. Existing performance metrics simplify {{this problem by}} separating the assessment of spatial structure from the assessment of symbol segmentation and classification. These metrics do not characterize the overall accuracy of a penbased mathematics recognition, {{making it difficult to}} compare math recognition algorithms, and preventing the use of machine learning algorithms requiring a criterion function characterizing overall system performance. To address this problem, we introduce performance metrics that bridge the gap from handwritten strokes to spatial structure. Our metrics are computed using bipartite graphs that represent classification, segmentation and spatial structure at the stroke level. Overall correctness of an expression is measured by counting the number of relabelings of nodes and edges needed to make the bipartite graph for a recognition result match the bipartite graph for ground truth. This metric may also be used with other primitive types (e. g. image pixels) ...|$|R
40|$|International audienceWe {{present a}} novel {{approach}} for fast collision detection between multiple deformable and breakable objects ina large environment using graphics hardware. Our algorithm takes into account low bandwidth to and from thegraphics cards and computes a potentially colliding set (PCS) using visibility queries. It involves no precomputationand proceeds in multiple stages: PCS computation at an object level and PCS computation at sub-objectlevel, followed by exact collision detection. We use a linear time two-pass rendering algorithm to compute eachPCS efficiently. The overall approach makes no assumption about the <b>input</b> <b>primitives</b> or the object's motion andis directly applicable to all triangulated models. It has been implemented on a PC with NVIDIA GeForce FX 5800 Ultra graphics card and applied to different environments composed of {{a high number of}} moving objects withtens of thousands of triangles. It is able to compute all the overlapping primitives between different objects up toimage-space resolution in a few milliseconds...|$|R
40|$|Abstract: This paper {{presents}} {{an approach to}} real-time rendering of non-planar projections with a single center and straight projection rays. Its goal is to provide optimal and consistent image quality. It operates entirely in object space to remove the need for image resampling. In contrast to most other object-space approaches, it does not evaluate non-linear functions on the GPU, but approximates the projection itself {{by a set of}} perspective projection pieces. Within each piece, graphics hardware can provide optimal image quality. The result is a coherent and crisp rendering. Procedural textures and stylization effects greatly benefit from our method as they usually rely on screen-space operations. The real-time implementation runs entirely on GPU. It replicates <b>input</b> <b>primitives</b> on demand and renders them into all relevant projection pieces. The method is independent of the input mesh density and is not restricted to static meshes. Thus, it is well suited for interactive applications. We demonstrate it for an analytic and a freely designed projection. ...|$|R
40|$|Abstract—Evaluating {{mathematical}} expression recognition {{involves a}} complex interaction of <b>input</b> <b>primitives</b> (e. g. pen/finger strokes), recognized symbols, and recognized spatial structure. Existing performance metrics simplify {{this problem by}} separating the assessment of spatial structure from the assessment of symbol segmentation and classification. These metrics do not characterize the overall accuracy of a penbased mathematics recognition, {{making it difficult to}} compare math recognition algorithms, and preventing the use of machine learning algorithms requiring a criterion function characterizing overall system performance. To address this problem, we introduce performance metrics that bridge the gap from handwritten strokes to spatial structure. Our metrics are computed using bipartite graphs that represent classification, segmentation and spatial structure at the stroke level. Overall correctness of an expression is measured by counting the number of relabelings of nodes and edges needed to make the bipartite graph for a recognition result match the bipartite graph for ground truth. This metric may also be used with other primitive types (e. g. image pixels) ...|$|R
40|$|Abstract. This paper {{presents}} {{an approach to}} real-time rendering of non-planar projections with a single center and straight projection rays. Its goal is to provide the same optimal and consistent image quality GPUs deliver for perspective pro-jections. It therefor renders the result directly without image resampling. In con-trast to most object-space approaches, it does not evaluate non-linear functions on the GPU, but approximates the projection itself {{by a set of}} perspective projection pieces. Within each piece, graphics hardware can provide optimal image quality. The result is a coherent and crisp rendering. Procedural textures and stylization effects greatly benefit from our method as they usually rely on screen-space op-erations. The real-time implementation runs entirely on GPU. It replicates <b>input</b> <b>primitives</b> on demand and renders them into all relevant projection pieces. The method is independent of the input mesh density and is not restricted to static meshes. Thus, it is well suited for interactive applications. We demonstrate an analytic and a freely designed projection based on our method. Key words: Non-planar projections, geometry shaders, geometry amplification, non-photorealistic rendering...|$|R
40|$|Communication {{protocol}} testing {{can be done}} with a test architecture consisting of remote Tester and local Responder processes. By ignoring interaction primitive parameters and additional state variables, it is possible to adapt test sequence generation techniques for finite state machines (FSM) to generate sequences for protocols specified as incomplete finite state machines. For real protocols, tests can be designed based on the formal specification of the protocol which uses an extended FSM model in specifying the transition types. The transition types are transformed into a simpler form called normal form transitions which can be modelled by a control and a data flow graph. Furthermore, the data flow graph is partitioned to obtain disjoint blocks representing the different functions of the protocol. Tests are designed by considering parameter variations of the <b>input</b> <b>primitives</b> of each data flow function and determining the expected outputs. This methodology gives complete test coverage of all data flow functions and tests for unspecified cases can be designed using the control and data flow graphs. The methodology is applied to two real protocols: Transport protocols Classes 0 and 2...|$|R
40|$|A {{conceptual}} model is discussed {{which allows the}} hierarchic definition of high-level input driven objects, called input-output tools, from any set of basic <b>input</b> <b>primitives.</b> An input-output tool {{is defined as a}} named object. Its most important elements are the input rule, output rule, internal tool definitions, and a tool body consisting of executable statements. The input rule contains an expression with tool designators as operands and with operators allowing for sequencing, selection, interleaving, and repetition. Input rules are similar in appearance to production rules in grammars. The input expression specifies one or more input sequences, or input patterns, in terms of tool designators. An input parser tries, at run-time, to match (physical) input tokens against active input sequences. If a match between an input token and a tool designator is found, the corresponding tool body is executed, and the output is generated according to specifications in the tool body. The control structures in the input expression allow a variety of input patterns from any number of sources. Tool definitions may occur in-line or be stored in a library. All tools are ultimately encompassed in one tool representing the program...|$|R
40|$|Figure 1 : Example {{subdivision}} surface scenes rendered with diffuse {{path tracing}} (up to 8 bounces, 7 − 12 secondary rays/primary ray). Right: the Courtyard scene (66 K patches after feature-adaptive subdivision) is adaptively-tessellated into 1. 4 M triangles from scratch per frame, and ray traced with over 90 M rays per second (including shading) on a high-end Intel R©Xeon R © processor system using our efficient lazy-build caching scheme. Left: four Barbarians {{embedded in the}} Sponza Atrium scene (426 K patches) and adaptively-tessellated into 11 M triangles are ray traced with 40 M rays per second. A 60 MB lazy-build cache allows for rendering this scene with over 91 % {{of the performance of}} an unbounded memory cache. Compared to ray tracing a pre-tessellated version, the memory consumption is reduced by 6 − 7 ×. A common way to ray trace subdivision surfaces is by construct-ing and traversing spatial hierarchies on top of tessellated <b>input</b> <b>primitives.</b> Unfortunately, tessellating surfaces requires a substan-tial amount of memory storage, and involves significant construc-tion and memory I/O costs. In this paper, we propose a lazy-build caching scheme to efficiently handle these problems while also ex-ploiting the capabilities of today’s many-core architectures. To this end, we lazily tessellate patches only when necessary, and utiliz...|$|R
30|$|Finally, we {{note that}} the {{presented}} method is ideally suited for the incorporation of h-adaptivity. A combination of this immersed FEM with hierarchical refinement techniques as shown, for instance, in [47] would render a powerful analysis toolbox, which yields accurate numerical predictions based only on the <b>input</b> of geometry <b>primitives.</b>|$|R
5000|$|Some {{programming}} languages (e.g. Visual Basic) {{will not}} read past a [...] "soft" [...] EOF {{when using the}} built-in text file reading <b>primitives</b> (<b>INPUT,</b> LINE INPUT etc.), and alternate methods must be adopted, e.g. opening the file in binary mode or using the File System Object to progress beyond it.|$|R
30|$|Motion sensors {{integrated}} into contemporary smartphones allow {{the introduction of}} new mobile interaction paradigms, here including tilt-based input control in the mobile context. Namely, as opposed to existing implementations that typically apply continuous feedback on tilting, we define Pitch and Roll movement sequences that change the orientation of the mobile device as discrete-tilt <b>input</b> <b>primitives.</b> The respective commands are then used to manage text entry within three discrete-tilt-based methods thus introduced: keyboard bisection, single cursor, and quad cursor. Each method is based on the use of a particular QWERTY-based keyboard layout with related strategy for character input. We model upper-bound text entry speeds for the input methods, taking into account both movement aspects and language context. The movement model corresponds to both the tilt-based shortest path between two consequent characters, which is theoretically defined, and the time of discrete-tilt execution, which is obtained from user testing experiment we conducted. The linguistic model, comprising digraph statistics, is constructed basing on available English corpora. This modeling approach provides discrete-tilt-based text entry speed predictions representing efficiency rates for expert behavior, i.e. for optimal performance. The results obtained enable the evaluation of the proposed designs without need to test with real users, and can furthermore serve as a baseline for efficiency of text entry implementations that rely on discrete tilt.|$|R
40|$|The recent {{availability}} of Non-Manifold Topology (NMT) enables the coexistence of wireframe geometry, surfaces, and solids {{in a single}} representation with complete topological resolution. This in turn allows {{a new approach to}} boundary evaluation. This new approach merges a set of primitives into a single Boundary REPresentation (B-rep), and selects the desired Boolean results without destroying any B-rep entities. The results of the Boolean operations are displayed by drawing only selected entities. The B-rep resulting from the merge contains a complete description of the <b>input</b> <b>primitives.</b> While traditional algorithms allow incremental addition of primitives, this new approach also allows incremental deletion of primitives from the merged B-rep. Changes in Boolean operators and/or their order of evaluation can be reflected in the B-rep simply by changing the criteria of the selection process. Constructive Solid Geometry (CSG) editing operations can be mirrored in the B-rep incrementally, i. e. without performing complete reevaluation of the B-rep from its constituent primitive definitions. In addition, the domain of boundary evaluation has been extended to include Boolean operations between wireframe geometry, surfaces, and solids. This new approach has been successfully implemented and tested to boundary evaluation. Test results have shown an order of magnitude reduction in the cost associated with reflecting CSG editing operations on existing B-reps, with only minimal additional cost for initial construction. Also shown are examples of Boolean operations between solids, surfaces, and wire...|$|R
