27|50|Public
5000|$|User {{can write}} an InstanceCreator which {{allows them to}} <b>deserialize</b> {{instances}} of classes without a defined no-args constructor.|$|E
50|$|Gson (also {{known as}} Google Gson) {{is an open}} source Java library to {{serialize}} and <b>deserialize</b> Java objects to (and from) JSON.|$|E
5000|$|To <b>deserialize</b> output {{produced}} by last example, you can execute the following code:Gson gson = new Gson (...)String json ="{\"name\":\"John\",\"surname\":\"Doe\",\"cars\":{\"manufacturer\":\"Audi\",\"model\":\"A4\",\"capacity\":1.8,\"accident\":false},{\"manufacturer\":\"Škoda\",\"model\":\"Octavia\",\"capacity\":2.0,\"accident\":true},\"phone\":245987453}";Person johnDoe = gson.fromJson(json, Person.class);System.out.println(johnDoe.toString (...) [...] ); ...|$|E
5000|$|When <b>deserializing,</b> Gson is {{navigating}} the type tree {{of the object}} being <b>deserialized.</b> This results in ignoring extra fields present in the JSON input.|$|R
5000|$|Windows PowerShell: Windows PowerShell {{implements}} serialization {{through the}} built-in cmdlet [...] [...] serializes [...]NET objects and stores the resulting XML in a file. To reconstitute the objects, use the [...] cmdlet, which generates a <b>deserialized</b> object from the XML in the exported file. <b>Deserialized</b> objects, often known as [...] "property bags" [...] are not live objects; they are snapshots that have properties, but no methods. Two dimensional data structures {{can also be}} (<b>de)serialized</b> in CSV format using the built-in cmdlets [...] and [...]|$|R
5000|$|Marshalling - serializing and <b>deserializing</b> the {{arguments}} and return values of method calls [...] "over the wire".|$|R
5000|$|User {{can write}} a custom {{serializer}} and/or deserializer {{so that they can}} control the whole process and even (<b>de)serialize</b> instances of classes for which the source code is not accessible.|$|E
50|$|Unmarshal {{methods can}} <b>deserialize</b> an entire XML {{document}} {{or a small}} part of it. When the XML root element is globally declared, these methods utilize the JAXBContext's mapping of XML root elements to JAXB mapped classes to initiate the unmarshalling. If the mappings are not sufficient and the root elements are declared locally, the unmarshal methods use declaredType methods for the unmarshalling process. These two approaches can be understood below.|$|E
5000|$|Serialization formats {{in general}} face {{the problem of}} schema evolution — the fact that, except under the most unusual circumstances, at times one version of the {{software}} will attempt to <b>deserialize</b> data that was serialized by an older version of the software or even by an independent implementation of the same format, while new versions of the software may desire to add new features. In a few cases, it is feasible to translate all the existing data into a new format, but this has several drawbacks: ...|$|E
50|$|Next is Selective serialization. When {{class is}} <b>deserialized,</b> thread {{stored in the}} id that was held will not work.|$|R
50|$|User-defined types (UDTs) {{that allow}} users to create simple or complex data types {{which can be}} {{serialized}} and <b>deserialized</b> within the database.|$|R
50|$|Finally {{the custom}} {{serialization}} involves implementing GetObectData method and special conductor {{that is used}} when object is <b>deserialized.</b> The following example is shown below.|$|R
5000|$|Older {{applications}} {{written with}} the Carbon API have a potential issue when being ported {{to the current}} Intel Macs. While the Resource Manager and operating system know how to <b>deserialize</b> data correctly for common resources like [...] "snd [...] " [...] or [...] "moov", resources created using TMPL resources have to be byte swapped manually to ensure file interoperability between PPC and Intel-based versions of an application. (While the resource map and other implementation details are big endian, the Resource Manager by itself doesn't have any knowledge {{of the contents of}} a generic resource, and so cannot perform the byte swapping automatically.) ...|$|E
50|$|SCOOP {{uses the}} Broker Architecture to {{distribute}} its Futures. It {{is based on}} a central element, called the Broker, that dispatches work to its workers. The main difference between this pattern and a Master/slave topology reside in the Future origin. In the Broker architecture, the Futures emanate from a worker, which is located {{on the periphery of the}} topology, instead of the master in the Master/slave architecture. This allows higher reliability in regard to worker faults and generally better performances due to the generic function of the Broker. Since he doesn't need to serialize nor <b>deserialize</b> any Future to route them around the grid, his workload consists of networking or interprocess I/O and almost no CPU processing time. This lowers the bottleneck of the Broker topology.|$|E
50|$|Camera Link uses one {{to three}} Channel-link {{transceiver}} chips with four links at 7 serial bits each.At a minimum, Camera Link uses 28 bits to represent up to 24 bits of pixel data and 3 bits for video sync signals, leaving one spare bit.The video sync bits are Data Valid, Frame Valid, and Line Valid. The data are serialized 7:1, and the four data streams and a dedicated clock are driven over five LVDS pairs. The receiver accepts the four LVDS data streams and LVDS clock, andthen drives the 28 bits and a clock to the board.The camera link standard calls for these 28 bits to be transmitted over 4 serializeddifferential pairs with a serialization factor of 7. The parallel data clock is transmittedwith the data. Typically a 7× clock must be generated by a PLL or SERDES block in order to transmit or receive the serialized video. To <b>deserialize</b> the data,a shift register and counter may be employed. The shift register catches each of the serialized bits, one at a time, then registers the data out into the parallel clock domain - oncethe data counter has reached its terminal value.|$|E
50|$|To {{reconstitute}} the XML Infoset, the XOP Package is <b>deserialized</b> {{into the}} XOP Infoset plus the extracted content, {{and then the}} extracted content is put back into the XML Infoset.|$|R
5000|$|REBOL: REBOL will {{serialize}} to file (...) or to a [...] (...) [...] Strings {{and files}} can be <b>deserialized</b> using the polymorphic [...] function. [...] provides cross-language data serialization in R, using protocol buffers.|$|R
50|$|Gson uses {{reflection}} so it {{does not}} require additional modifications to classes of (<b>de)serialized</b> objects. In fact it just needs the class to have defined default no-args constructor (not entirely true, see Features).|$|R
50|$|Alto both blurred {{and ignored}} {{the lines between}} {{functional}} elements. Rather than a distinct central processing unit with a well-defined electrical interface (e.g., system bus) to storage and peripherals, the Alto ALU interacts directly with hardware interfaces to memory and peripherals, driven by microinstructions output from the control store. The microcode machine supports up to 16 cooperative tasks, each with fixed priority. The emulator task executes the normal instruction set to which most applications are written; that instruction set is similar to, but not the same as, that of a Data General Nova. Others tasks serve the display, memory refresh, disk, network, and other I/O functions. As an example, the bitmap display controller {{is little more than}} a 16-bit shift register; microcode moves display refresh data from main memory to the shift register, which serializes it into a display of pixels corresponding to the ones and zeros of the memory data. Ethernet is likewise supported by minimal hardware, with a shift register that acts bidirectionally to serialize output words and <b>deserialize</b> input words. Its speed was designed to be 3 Mbit/s because the microcode engine could not go faster and continue to support the video display, disk activity and memory refresh.|$|E
30|$|DataReader: {{takes the}} data from the Subscriber, to <b>deserialize</b> it into the {{appropriate}} type of topic. Afterwards the data reader forward the information to the application.|$|E
40|$|LeanMinHash is a {{subclass}} of MinHash. It uses less {{memory and}} allows faster (de) serialization. See documentation for details. Removed serialize, <b>deserialize,</b> and bytesize methods from MinHash. These are supported in LeanMinHash instead. Serialized MinHash objects before this version {{will not be}} deserialized properly. To migrate see here. Documentation now have its own website...|$|E
50|$|Abstract Syntax Notation One (ASN.1) is an {{interface}} description language for defining data structures {{that can be}} serialized and <b>deserialized</b> in a standard, cross-platform way. It's broadly used in telecommunications and computer networking, and especially in cryptography.|$|R
30|$|As already pointed out, {{some changes}} to the Modelica {{libraries}} require more than a template adaption which {{is related to the}} mapping of the <b>deserialized</b> CIM C++ objects to the dictionaries of the template engine used to complete the Modelica templates to full system models.|$|R
50|$|Dart {{is a very}} {{asynchronous}} language. With this, it uses isolates for concurrency. Since {{these are}} workers which pass messages, it needs a way to serialize a message. This is done using a snapshot, which is generated from a given object, and then this is transferred to another isolate for <b>deserializing.</b>|$|R
40|$|Software {{components}} can be connectedby XML processing pipelines, {{which may}} perform adaptations. In our model, individual pipeline stages serialize source data structures to XML, perform one or multiple XSL transformations, transport {{the message to}} its destination and finally <b>deserialize</b> it to target data structures. Implementation of this model is open to optimizations. The present paper discusses two such optimizations: symbolic execution and lazy evaluation...|$|E
40|$|This paper {{introduces}} new open-source cross-platform C++ {{software library}} able to store, serialize and <b>deserialize</b> hierarchically arranged class instances and their data members via XML files. The library {{is based on}} mature cross-platforrn library called wxWidgets {{so it can be}} successfully used on many target platforms such as MS Windows, Linux or OS X. The article describes an inner structure of the software library, used principles, and illustrates the usage on simple examples as well...|$|E
40|$|In {{all cases}} a data {{structure}} (or {{an array of}} data structures) needs to be serialized or deserialized in the C++ programming language, a developer needs to write {{his or her own}} code. If the serialization mechanism needs to accommodate further expansion of the structure or the structure itself contains variable-length fields (especially strings), the required code can quickly grow quite large and may not be reused in further cases. However, using the reflection mechanism described in [1], one can quickly serialize and <b>deserialize</b> any data structure or container with few lines of code...|$|E
40|$|Spartan®- 6 devices contain input SerDes (ISERDES) {{and output}} SerDes (OSERDES) blocks. These {{primitives}} simplify {{the design of}} serializing and <b>deserializing</b> circuits, while allowing higher operational speeds. This application note discusses how to efficiently use these primitives {{in conjunction with the}} input delay blocks and phase detector circuitry. ISERDES and OSERDE...|$|R
5000|$|Since {{the classes}} are {{themselves}} objects, {{they can be}} asked questions such as [...] "what methods do you implement?" [...] or [...] "what fields/slots/instance variables do you define?". So objects can easily be inspected, copied, (<b>de)serialized</b> and so on with generic code that applies to any object in the system.|$|R
40|$|A 10 Gb/s Synchronous Optical Network (SONET) {{transceiver}} {{is designed}} with 90 nm digital CMOS technology. It {{consists of a}} serializing transmitter (TX) and a <b>deserializing</b> receiver (RX) on a single chip. The 10 GHz differential LC VCO's in TX and RX, fully differential circuits, multiple power domains are implemented to exceed SONET jitter specifications. 1...|$|R
40|$|Ever since online {{digital storage}} devices were first {{introduced}} in the late 1950 's and early 1960 's, the various functions key to storing data on these devices have been slowly migrating into the devices themselves. Early disk drives would send analog signals from the read/write head to a physically separate box that would <b>deserialize</b> and frame data into bytes. This data would then be sent to other processors to perform redundancy checks and data transmission to the requesting computer system. As engineers were able to fit more functionality into smaller spaces at reasonable costs, these key functions were migrated into the disk drive itself {{to the point where}} we now have an entirely selfcontained unit complete with all the electronics that used to fill a small room...|$|E
40|$|International audienceThree Dimensional Integrated Circuits are an {{important}} new paradigm in which different dies are stacked atop one another, and interconnected by Through Silicon Vias (TSVs). Testing 3 D-ICs poses additional challenges {{because of the need}} to transfer data to the non-bottom layers and the limited number of TSVs available in the 3 D-ICs for the data transfer. A novel test compression technique is proposed that introduces the ability to share tester data across layers using daisy-chained decompressors. This improves the encoding of test patterns substantially, thereby reducing the amount of test data required to be stored on the external tester. In addition, an inter-layer serialization technique is proposed, which further reduces the number of TSVs required, using simple hardware to serialize and <b>deserialize</b> the test data. Experimental results are presented demonstrating the efficiency of the technique proposed...|$|E
30|$|The ISO/IEC Motion Picture Group (MPEG) {{issued in}} 2002 a standard, called MPEG- 7, which enables the content {{description}} of multimedia data in XML. The standard supports applications to exchange, identify, and filter multimedia contents based on MPEG- 7 descriptions. However, especially mobile applications {{that deal with}} MPEG- 7 suffer from limited bandwidth, low computational power, and limited battery life. In this document, we describe an index system adopted from database systems that allows filter mechanisms and random access to encoded MPEG- 7 streams and which overcome the limitation of the network and the consuming terminal. Encoding is applied {{in order to reduce}} the data rate of the XML documents to be transmitted. The indexed parts of the encoded streams can be accessed without the need to <b>deserialize</b> the complete stream. Furthermore, the system is evaluated and results of the experimental evaluation are discussed.|$|E
40|$|Grail is an {{open source}} graph library, which is {{developed}} at the MSI of Växjö University, tools like the VizzAnalyzer and vizz 3 d use Grail for representing their internal structures. In this thesis, an adapter serializing and <b>deserializing</b> Grail graphs to and from XMI is introduced. XMI is short for XML Metadata Interchange; it is developed by the Object Management Group (OMG) ...|$|R
30|$|At first level, {{there are}} the library mappings. The {{relevant}} data from CIM C++ objects, as <b>deserialized</b> by CIM++, is first stored in an intermediate object representation (i. e. in the Modelica Workshop) with a class structure {{similar to the one}} of the Modelica library. Hence, for each Modelica library there can be a set of appropriate C++ class definitions in the Modelica Workshop.|$|R
50|$|If {{a remote}} {{function}} is called, the client library creates an object describing the call, including all parameters. This object is serialized using the Boost serialization library {{and transferred to}} the server. Currently {{this can be done}} using Unix domain sockets or TCP. The server <b>deserializes</b> the object and calls the corresponding method. The result (return value or exception) is again serialized and sent back to the client.|$|R
