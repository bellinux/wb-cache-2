3|1107|Public
50|$|The {{program counter}} (PC), {{commonly}} called the instruction pointer (IP) in Intel x86 and Itanium microprocessors, and {{sometimes called the}} <b>instruction</b> <b>address</b> <b>register</b> (IAR), the instruction counter, or {{just part of the}} instruction sequencer,is a processor register that indicates where a computer is in its program sequence.|$|E
5000|$|The IBM 1130 {{was a small}} 16-bit word-addressable machine. It {{had only}} six {{registers}} plus condition indicators, and no stack. The registers are <b>Instruction</b> <b>Address</b> <b>Register</b> (IAR), Accumulator (ACC), Accumulator Extension (EXT), and three index registers X1 - X3. The calling program is responsible for saving ACC, EXT, X1, and X2. There are two pseudo-operations for calling subroutines, [...] to code non-relocatable subroutines directly linked with the main program, and [...] to call relocatable library subroutines through a transfer vector. [...] Both pseudo-ops resolve to a Branch and Store IAR (...) machine instruction that stores {{the address of the}} next instruction at its effective address (EA) and branches to EA+1.|$|E
5000|$|As {{well as the}} two index {{registers}} {{already mentioned}} (referred to as 1 and 2, or binary 01 and 10) there were other registers."Reg 4" [...] (0100) was the <b>instruction</b> <b>address</b> <b>register</b> (IAR) which pointed at the current instruction."Reg 8" [...] (1000) was the address recall register (ARR), set by certain instructions. Among these was the conditional branch (mnemonic BC) which used it {{to point to the}} byte immediately following the branch operation. For IBM mainframe folks this means that the S/3 branch could be likened to a conditional BALR (branch and link register). Very useful when branching to a sub-routine, and returning after it had processed.Finally, [...] "Reg 16" [...] (00010000) was the program status register (PSR), holding such things as the results of a compare instruction.Note that registers were used only for addressing and program status, not for arithmetic.|$|E
50|$|The machine {{instructions}} can {{be grouped}} into six categories: accumulator instructions, branch instructions, memory reference <b>instructions,</b> <b>address</b> <b>register</b> <b>instructions,</b> scratchpad register instruction, miscellaneous instructions (interrupt, input, output, indirect scratchpad register, load, and store).|$|R
40|$|Abstract. Compact code {{generation}} {{is very important}} for an embedded system that has to be implemented on a chip with a severely limited amount of size. Even though on-chip data memory optimization technique has been given more attention, on-chip instruction memory optimization should not be neglected. We propose in this paper some algorithms for a memory offset assignment for embedded DSP processors in order to minimize the number of <b>instructions</b> for <b>address</b> <b>register</b> operations. Extensive experimental results demonstrate the efficacy of our solution. ...|$|R
40|$|Dynamic {{programming}} allows locally optimal instruction {{selection for}} expression trees. More importantly, the algorithm allows concise and elegant specification of code generators. Aho, Ganapathi, and Tjiang have built the Twig code-generator-generator, which produces dynamic-programming code-generators from grammar-like specifications. Encoding a complex architecture as a grammar for a dynamic-programming codegenerator -generator shows the expressive {{power of the}} technique. Each <b>instruction,</b> <b>addressing</b> mode, <b>register</b> and class can be expressed individually in the grammar. The grammar can be factored much more readily than with the Graham-Glanville LR(1) algorithm, {{so it can be}} much more concise. Twig specifications for the VAX and MC 68020 are described, and the corresponding code generators select very good (and under the right assumptions, optimal) instruction sequences. Limitations and possible improvements to the specification language are discussed. 1. Introduction One of the last [...] ...|$|R
5000|$|... 128 {{high-speed}} index registers (B-lines) {{that could}} be used for address modification in the mostly double-modified <b>instructions.</b> The <b>register</b> <b>address</b> space also included special registers such as the extracode operand address, the exponent of the floating-point accumulator. Three of the 128 registers were program counter registers: 126 was supervisor control, 125 was extracode control, and 127 was user control. Register 0 always held value 0.|$|R
2500|$|In PowerPC G1, G2, G3, and G4 {{pages are}} {{normally}} [...] After a TLB miss, the standard PowerPC MMU begins two simultaneous lookups. [...] One lookup attempts {{to match the}} address with one of four or eight data block <b>address</b> translation (DBAT) <b>registers,</b> or four or eight <b>instruction</b> block <b>address</b> translation <b>registers</b> (IBAT), as appropriate. [...] The BAT registers can map linear chunks of memory as large as [...] and are normally used by an OS to map large portions of the address space for the OS kernel's own use. [...] If the BAT lookup succeeds, the other lookup is halted and ignored.|$|R
40|$|Abstract. In DSP processors, {{minimizing}} {{the amount of}} address cal-culations is critical for reducing code size and improving performance since studies of programs have shown that <b>instructions</b> that manipulate <b>address</b> <b>registers</b> constitute {{a significant portion of}} the overall instruc-tion count (up to 55 %). This work presents a compiler-based optimiza-tion strategy to reduce the code size in embedded systems. Our strategy maximizes the use of indirect addressing modes with post-increment and post-decrement capabilities available in DSP processors. These modes can be exploited by ensuring that successive references to variables ac-cess consecutive memory locations. To achieve this spatial locality, our approach uses both access pattern modification (program code restruc-turing) and memory storage reordering (data layout restructuring). ...|$|R
40|$|We {{introduce}} {{an energy}} consumption analysis of complex digital systems through {{a case study}} of ARM 7 TDMI RISC processor by using a new energy measurement technique. We developed a cycle-accurate energy consumption measurement system based on charge transfer which is robust to spiky noise and is capable of collecting a range of power consumption profiles in real time. The relative energy variation of the RISC core is measured by changing the op-code, the <b>instruction</b> fetch <b>address,</b> the <b>register</b> number, the register value, the data fetch address, and the immediate operand value in each pipeline stage, respectively. We demonstrated energy charac-terization of a pipelined RISC processor for high-level power re-duction. 1...|$|R
5000|$|The [...] <b>instruction</b> stores the <b>address</b> of {{the next}} <b>instruction</b> (return <b>address)</b> in the <b>register</b> {{specified}} by the first argument - register 14 - and branches to the second argument <b>address</b> in <b>register</b> 15.|$|R
50|$|The {{effective}} <b>address</b> for a <b>Register</b> indirect <b>instruction</b> is the <b>address</b> in {{the specified}} register. For example, (A7) {{to access the}} content of <b>address</b> <b>register</b> A7.|$|R
40|$|In DSP processors, {{minimizing}} {{the amount of}} address calculations is critical for reducing code size and improving performance, since studies of programs have shown that <b>instructions</b> that manipulate <b>address</b> <b>registers</b> constitute {{a significant portion of}} the overall instruction count (up to 55 %). This work presents a compiler-based optimization strategy to “reduce the code size in embedded systems. ” Our strategy maximizes the use of indirect addressing modes with postincrement/decrement capabilities available in DSP processors. These modes can be exploited by ensuring that successive references to variables access consecutive memory locations. To achieve this spatial locality, our approach uses both access pattern modification (program code restructuring) and memory storage reordering (data layout restructuring). Experimental results on a set of benchmark codes show the effectiveness of our solution and indicate that our approach outperforms the previous approaches to the problem. In addition to resulting in significant reductions in instruction memory (storage) requirements, the proposed technique improves execution time...|$|R
40|$|DSP {{architectures}} typically provide {{indirect addressing}} modes with autoincrement and decrement. In addition, indexing mode {{is generally not}} available, and there are usually few, if any, general-purpose registers. Hence, {{it is necessary to}} use <b>address</b> <b>registers</b> and perform <b>address</b> arithmetic to access automatic variables. Subsuming the address arithmetic into autoincrement and decrement modes improves the size of the generated code. In this article we present a formulation of the problem of optimal storage assignment such that explicit <b>instructions</b> for <b>address</b> arithmetic are minimized. We prove that for the case of a single <b>address</b> <b>register</b> the decision problem is NP-complete, even for a single basic block. We then generalize the problem to multiple <b>address</b> <b>registers.</b> For both cases heuristic algorithms are given, and experimental results are presented...|$|R
50|$|NAR 1 {{programs}} are commonly self-modifying. Unlike {{in some other}} architectures, {{this is not a}} 'trick'. As memory can not be <b>addressed</b> by a <b>register,</b> the only way to dynamically manipulate memoory data is to modify memory manipulation instructions. Above example also contains a typical trick to save memory - <b>instruction</b> (at <b>address</b> 30) is reused as data by another <b>instruction</b> (at <b>address</b> 28).|$|R
50|$|When the read <b>address</b> <b>register</b> {{equals the}} write <b>address</b> <b>register,</b> the FIFO is empty.|$|R
5000|$|... 0003 NOOP 00 0000 0000 No-operation <b>{{instruction}},</b> next <b>instruction</b> <b>address</b> is 0000 0000 HALT 01 0000 8000 Halt, next <b>instruction</b> <b>address</b> is {{the console}} (this Halt instruction was stored in 0000 by the STD instruction above) ...|$|R
50|$|FIFO Empty: When the read <b>address</b> <b>register</b> {{reaches the}} write <b>address</b> <b>register,</b> the FIFO {{triggers}} the Empty signal.|$|R
5000|$|CP {{instructions}} {{are written in}} a particularly user-friendly form: [...] "SA1 A0+B1" [...] denotes set <b>address</b> <b>register</b> A1 to the sum of <b>address</b> <b>register</b> A0 and index register B1. The hardware then initiates a memory load from the computed <b>address</b> into <b>register</b> X1.|$|R
50|$|In {{the early}} {{instances}} {{of the architecture}} (System/360 and early System/370), the <b>instruction</b> <b>address</b> was 24 bits; in later instances (XA/370), the <b>instruction</b> <b>address</b> was 31 bits plus a mode bit (24 bit addressing mode if zero; 31 bit addressing mode if one) {{for a total of}} 32 bits.|$|R
40|$|PC {{instruction}} memory, {{fetch instruction}} Register numbers register file, read registers Depending on instruction class Use ALU to calculate Arithmetic result Memory address for load/store Branch target address Access data memory for load/store PC target address or PC + 4 3 Abstract / Simplified View Two types of functional units: elements that operate on data values (combinational) elements that contain state (sequential) 4 PC <b>address</b> <b>instruction</b> instruction memory data memory <b>address</b> data <b>registers</b> data register # register # register # ALU Abstract / Simplified View Cannot just join wires together Use multiplexers 5 PC <b>address</b> <b>instruction</b> instruction memory data memory <b>address</b> data <b>registers</b> data register # register # register # ALU Recall...|$|R
5000|$|Indirect <b>{{register}}</b> access (<b>address</b> <b>register,</b> {{data register}} in mapped memory) ...|$|R
50|$|Also, a Harvard {{architecture}} {{machine has}} distinct code and data <b>address</b> spaces: <b>instruction</b> <b>address</b> zero {{is not the}} same as data <b>address</b> zero. <b>Instruction</b> <b>address</b> zero might identify a twenty-four bit value, while data address zero might indicate an eight-bit byte that is not part of that twenty-four bit value.|$|R
5000|$|IP/EIP/RIP: Instruction pointer. Holds {{the program}} counter, the current <b>instruction</b> <b>address.</b>|$|R
5000|$|... 64-bit {{processor}} {{status register}} (PSW), {{which includes a}} 24-bit <b>Instruction</b> <b>Address</b> ...|$|R
40|$|Abstract — The power {{dissipation}} at the off-chip bus {{is a significant}} part of the overall {{power dissipation}} in digital systems. This paper presents irredundant address bus encoding methods which reduce signal transitions on the <b>instruction</b> <b>address</b> buses by using adaptive codebook methods. These methods are based on the temporal locality and spatial locality of <b>instruction</b> <b>address.</b> Since applications tend to JUMP / BRANCH to limited sets of addresses, proposed encoding methods assign the least signal transition codes to the addresses of JUMP / BRANCH operations in the past. Our encoding methods reduce the signal transitions on the <b>instruction</b> <b>address</b> buses by an average of 88 %. I...|$|R
50|$|The {{effective}} address for an absolute <b>instruction</b> <b>address</b> is the address parameter itself with no modifications.|$|R
5000|$|... +------+ | nop | {{execute the}} {{following}} instruction +------+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address)</b> ...|$|R
5000|$|... 16 kB {{dedicated}} video RAM (64 kB {{standard in}} C128DCR, C128/C128D can be upgraded to 64 kB), {{accessible to the}} CPU only in a doubly indirect method (<b>address</b> <b>register,</b> data register on VDC, which in turn are <b>addressed</b> through <b>address</b> <b>register,</b> data register in mapped memory) ...|$|R
40|$|A major hurdle {{of recent}} x 86 superscalar {{processor}} designs is limited instruction issue rate {{due to the}} overly complex x 86 instruction formats. To alleviate this problem, the machine states must be preserved and the <b>instruction</b> <b>address</b> routing paths must be simplified. We propose an <b>instruction</b> <b>address</b> queue, whose queue size has been estimated to handle saving of <b>instruction</b> <b>addresses</b> with three operations: allocation, access, and retirement. The <b>instruction</b> <b>address</b> queue will supply the stored <b>instruction</b> <b>addresses</b> as data for three mechanisms: changing instruction flow, updating BTB, and handling exceptions. It {{can also be used}} for internal snooping to solve self-modified code problems. Two CISC hazards in the x 86 architectures, the variable instruction length and the complex addressing mode, have been considered in this design. Instead of the simple full associative storing method in lower degree (< 4) superscalar systems, the line-offset method is used in this address queue. This will reduce by 1 / 3 the storage space for a degree- 5 superscalar x 86 processor with even smaller access latency. We use synthesis tools to analyze the design, and show that it produces optimized results. Because the address queue design can keep two different line <b>addresses</b> in an <b>instruction</b> access per cycle, this method can be extended for designing a multiple instruction block issue system, such as the trace processor...|$|R
5000|$|... de:Memory <b>Address</b> <b>Register</b> und Memory Buffer Register#Memory Buffer Register ...|$|R
50|$|Instructions {{must be on}} a two-byte {{boundary}} in memory; {{hence the}} low-order bit of the <b>instruction</b> <b>address</b> is always 0.|$|R
5000|$|Memory <b>Address</b> <b>Register</b> Display Selector - Rotary switch, 12 {{positions}} ...|$|R
50|$|In {{the present}} {{instances}} {{of the architecture}} (z/Architecture), the <b>instruction</b> <b>address</b> is 64 bits and the PSW itself is 128 bits.|$|R
5000|$|... +----+------------------------------+ |jump| offset | jump {{relative}} +----+------------------------------+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address</b> + offset, offset may be negative) ...|$|R
5000|$|... +------+-----+-----+ |skipEQ| reg1| reg2| {{skip the}} {{following}} instruction if reg1=reg2 +------+-----+-----+ [...] (Effective PC <b>address</b> = next <b>instruction</b> <b>address</b> + 1) ...|$|R
