7|9|Public
5000|$|After each {{conversion}} {{associated with}} an input/output <b>format</b> <b>specifier.</b> For example, in the expression , there is a sequence point after the [...] is evaluated and before printing [...]|$|E
5000|$|In C, {{a similar}} {{facility}} is available via [...] and the [...] "character" [...] <b>format</b> <b>specifier,</b> {{though in the}} presence of other workarounds this is generally not used: ...|$|E
5000|$|Consider the {{following}} short C {{program that has}} a local variable char array [...] which holds a password; the program asks the user for an integer and a string, then echoes out the user-provided string.If the user input is filled {{with a list of}} format specifiers such as [...] , then will start reading from the stack. Eventually, one of the [...] <b>format</b> <b>specifier</b> will access the address of [...] , which is on the stack, and print [...] to the screen.|$|E
50|$|A {{common use}} case is in {{constructing}} printf or scanf format strings, where <b>format</b> <b>specifiers</b> are given by macros.|$|R
50|$|In Common Lisp, the tilde {{is used as}} the prefix for <b>format</b> <b>specifiers</b> in <b>format</b> strings.In Max/MSP, a tilde is used {{to denote}} objects that process at the computer's {{sampling}} rate, i.e. mainly those that deal with sound.|$|R
5000|$|... is a {{function}} in Common Lisp that can produce formatted text using a format string similar to the printf format string. It provides more functionality than , allowing the user to output numbers in English, apply certain <b>format</b> <b>specifiers</b> only under certain conditions, iterate over data structures, and output in a tabular format. This functionally originates in MIT's Lisp Machine Lisp, where {{it was based on}} Multics [...]|$|R
5000|$|The above {{can be used}} in {{compound}} with numeric modifiers and the , [...] modifiers which {{stand for}} [...] "long" [...] in between the percent symbol and the letter. There can also be numeric values between the percent symbol and the letters, preceding the [...] modifiers if any, that specifies the number of characters to be scanned. An optional asterisk (...) right after the percent symbol denotes that the datum read by this <b>format</b> <b>specifier</b> is not to be stored in a variable. No argument behind the format string should be included for this dropped variable.|$|E
50|$|It is {{possible}} to leak information about memory layout using format string vulnerabilities. Format string functions such as printf use a variable argument list to do their job; format specifiers describe what the argument list looks like. Because of the way arguments are typically passed, each <b>format</b> <b>specifier</b> moves closer {{to the top of}} the stack frame. Eventually, the return pointer and stack frame pointer can be extracted, revealing the address of a vulnerable library and the address of a known stack frame; this can completely eliminate library and stack randomization as an obstacle to an attacker.|$|E
50|$|The ATIS {{signalling}} protocol {{is based on}} that used for Digital Selective Calling (DSC); with the ATIS transmissions having the <b>format</b> <b>specifier</b> field set to a value of 121. While DSC transmissions take place exclusively on Channel 70, the ATIS digital signal is transmitted on the same VHF channel as the voice transmission: it lasts for 285 milliseconds after the PTT button has been released, using frequency modulation frequency-shift keying (FSK) between the frequencies of 1,300 Hz and 2,100 Hz at 1,200 baud. The core part of the message is transmitted using 10-bit codes; each code being formed of a 7-bit symbol followed by a 3-bit count {{of the number of}} zeros in that symbol.|$|E
5000|$|A typical exploit uses a {{combination}} of these techniques to force a program to overwrite the address of a library function or the return address on the stack with a pointer to some malicious shellcode. The padding parameters to <b>format</b> <b>specifiers</b> are used to control the number of bytes output and the [...] token is used to pop bytes from the stack until the beginning of the format string itself is reached. The start of the format string is crafted to contain the address that the [...] format token can then overwrite with the address of the malicious code to execute.|$|R
40|$|Abstract. Format-string {{attack is}} one of the few truly threats to {{software}} security. Many previous methods for addressing this problem rely on program source code analysis or special recompilation, and hence exhibit limitations when applied to protect the source code unavailable software. In this paper, we present a transparent run-time approach to the defense against format-string attacks via dynamic taint and flexible validation. By leveraging library interposition and ELF binary analysis, we taint all the untrusted user-supplied data as well as their propagations during program execution, and add a security validation layer to the printf-family functions in C Standard Library in order to enforce a flexible policy to detect the format string attack on the basis of whether the format string has been tainted and contains dangerous <b>format</b> <b>specifiers.</b> Compared with other existing methods, our approach offers several benefits. It does not require the knowledge of the application or any modification to the program source code, and can therefore also be used with legacy applications. Moreover, as shown in our experiment, it is highly effective against the most types of format-string attacks and incurs low performance overhead. ...|$|R
5000|$|Printf format string (of which [...] "printf" [...] {{stands for}} [...] "print formatted") {{refers to a}} control {{parameter}} used by a class of functions in the string-processing libraries of various programming languages. The format string is written in a simple template language, and specifies a method for rendering an arbitrary number of varied data type parameters into a string. This string is then by default printed on the standard output stream, but variants exist that perform other tasks with the result, such as returning it as {{the value of the}} function. Characters in the format string are usually copied literally into the function's output, as is usual for templates, with the other parameters being rendered into the resulting text in place of certain placeholders - points marked by <b>format</b> <b>specifiers,</b> which are typically introduced by a [...] character, though syntax varies. The format string itself is very often a string literal, which allows static analysis of the function call. However, it can also be the value of a variable, which allows for dynamic formatting but also a security vulnerability known as an uncontrolled format string exploit.|$|R
5000|$|During 1999, Swatch {{produced}} several {{models of}} watch, branded [...] "Swatch [...]beat", that displayed Swatch Internet Time {{as well as}} standard time, and even convinced a few websites (such as CNN.com) {{to use the new}} format. PHP's date (...) function has a <b>format</b> <b>specifier</b> 'B' which returns the Swatch Internet Time notation for a given time stamp. [...] It is also used as a time reference on ICQ, and the online role-playing game Phantasy Star Online has used it since its launch on the Dreamcast in 2000 to try to facilitate cross-continent gaming (as the game allowed Japanese, American and European players to mingle on the same servers). In March 2001, Ericsson released the T20e, a mobile phone which gave the user the option of displaying Internet Time. Outside these areas, however, it appears to be infrequently used. While Swatch still offers the concept on its website, it no longer markets beat watches. In July 2016, Swatch released Touch Zero Two, its second wirelessly connected watch, with Swatch Internet Time function.|$|E
40|$|Ultimately, {{scientific}} numerical models need quantified output uncertainties so that modeling can evolve {{to better}} match reality. Documenting model input uncertainties and variabilities {{is a necessary}} first step toward that goal. Without known input parameter uncertainties, model sensitivities are all one can determine, and without code verification, output uncertainties are simply not reliable. The basic premise of uncertainty markup is to craft a tolerance and tagging mini-language that offers a natural, unobtrusive presentation and {{does not depend on}} parsing each type of input file format. Each file is marked up with tolerances and optionally, associated tags that serve to label the parameters and their uncertainties. The evolution of such a language, often called a Domain Specific Language or DSL, is given in [1], but in final form it parallels tolerances specified on an engineering drawing, e. g., 1 +/- 0. 5, 5 +/- 10 %, 2 +/- 10 where % signifies percent and o signifies order of magnitude. Tags, necessary for error propagation, can be added by placing a quotation-mark-delimited tag after the tolerance, e. g., 0. 7 +/- 20 % 'T_effective'. In addition, tolerances might have different underlying distributions, e. g., Uniform, Normal, or Triangular, or the tolerances may merely be intervals due to lack of knowledge (uncertainty). Finally, to address pragmatic considerations such as older models that require specific number-field <b>formats,</b> C-style <b>format</b> <b>specifiers</b> can be appended to the tolerance like so, 1. 35 +/- 10 U_ 3. 2 f. As an example of use, consider figure 1, where a chemical reaction input file is has been marked up to include tolerances and tags per table 1. Not only does the technique provide a natural method of specifying tolerances, but it also servers as in situ documentation of model uncertainties. This tolerance language comes with a utility to strip the tolerances (and tags), to provide a path to the nominal model parameter file. And, as shown in [1], having the ability to quickly mark and identify model parameter uncertainties facilitates error propagation, which in turn yield output uncertainties...|$|R
40|$|The {{question}} how adverbs (and adverbials, more generally) 1 integrate into {{the structure of}} the clause has been, and continues to be, a moot question. In work of the early 90 s, later merged into Cinque (1999), I suggested that adverbs should not be seen as accessory appendices to clause structure (as the traditional notion of adjunct would suggest), but rather {{as an integral part of}} it, despite their general optionality. Much as inflectional morphology, functional particles, and auxiliaries were at the time considered to be the overt manifestation, in head format, of the functional portion of the clause, AdvPs, I argued, could be seen as the overt manifestation of the same functional distinctions in <b>specifier</b> <b>format.</b> The main evidence for their belonging to the functional make-up of the clause was the observation that cross-linguistically the number and type of the different classes of AdvPs and their relative order appears to *. I thank Richard Kayne for comments on a previous version of this article...|$|R
40|$|These {{notes were}} written to {{accompany}} a two-semester introductory course in Electrical Engineering. The {{primary goal of}} the course is {{to introduce you to}} the art of technical problem solving. Conventional Electrical Engineering curricula, in favorable cases at least, produce engineers who are reasonably adept at operating many of the tools important to the field, such as mathematics and circuit analysis. Often, however, these engineers lack skill in choosing which tools to use and in designing a plan of attack to solve problems which are new to them, even though they have all the information and skills needed to fabricate a satisfactory solution. Problem solving is more of an art than a science, and it can only be learned through experience. I hope these notes and the homework exercises will help you to develop this important ability early in your academic career. The notes have two secondary goals. The first is to {{show you some of the}} ideas that you will encounter a little later in your academic career, and to solidify your grasp of some ideas you have seen already. Seeing the new ideas now and giving them time to 2 ̆ 2 rattle around 2 ̆ 2 in your head for a while will make them easier to master when you encounter them later in more specialized courses. For example Chapter 8 is devoted entirely to the analysis of simple circuits in order to determine currents and voltages. The purpose here is not to make you proficient at circuit analysis, but rather to introduce you to the basic ideas, such as just what is a current or a voltage. Then, when you encounter the subject again in considerably more detail, you will have some understanding and familiarity to fall back on. The other secondary goal is to provide you with skill in using a computer. In the first semester of the course, your interaction with a computer will be almost entirely through a spreadsheet program. This is a pretty specialized program which turns out to be surprisingly useful in engineering. It allows you to graph data and functions, and to do rather complex arithmetic calculations on large quantities of data easily. I hope that you will come to view the spreadsheet as a tool you can use later to help you understand things and to avoid some of the arithmetic drudgery. This is the easiest goal of the course to achieve. I think you should find the spreadsheet easy to learn and entertaining to use (it was designed that way). In the second semester, you will be introduced to a more general-purpose program, called the C compiler. C is a computer language somewhat similar to FORTRAN, Pascal, or BASIC which allows you to write your own programs, and thereby to tell the computer exactly what you want it to do. You will probably not emerge from the course as a skilled C programmer, but I hope you will be able to use C to solve many of the problems which you are likely to encounter later in your career. Perhaps most importantly, I hope you will have a good idea about just what can be done with C, and what can’t, so that you will be able to further develop your skill at using C as the need arises. Volume 2 —CONTENTS 11. FINITE SUMS AND INTEGRATION § 11. 1 HowMuch Water Can a Water Tower Hold? § 11. 2 Numerical Solution § 11. 3 Analytic Solution § 11. 4 Just HowMuch Water Does the Notrees Tank Hold, Anyway? § 11. 5 Connection with Integrals § 11. 6 Numerical Evaluation of Integrals § 11. 7 APPENDIX: Derivation of Formula for [summation Σ j 2, from j = 0 to N – 1] § 11. 8 Exercises 12. FINITE DIFFERENCES AND DIFFERENTIATION § 12. 1 Velocities from a Table of Distances § 12. 2 Connection with Derivatives § 12. 3 The Numerical Evaluation of Derivatives § 12. 4 Exercises 13. NUMERICAL SOLUTION OF DIFFERENTIAL EQUATIONS § 13. 1 Population Growth—A Simple Differential Equation § 13. 2 Analytic Solution of Differential Equations § 13. 2. 1 Classification of Differential Equations § 13. 2. 2 AMethod for Solving Some Differential Equations § 13. 2. 3 Comparison of Analytic and Numerical Solutions § 13. 2. 4 Initial Conditions § 13. 2. 5 For the Skeptics Among You § 13. 3 Numerical Solution of Differential Equations § 13. 3. 1 Euler’s Method § 13. 3. 2 Modified Euler’s Method § 13. 4 An Example from Electrical Engineering, a RC Circuit § 13. 4. 1 The Analytic Solution § 13. 4. 2 The Numerical Solution § 13. 5 A Second Example: An RLC Circuit § 13. 5. 1 The t 3 ̆c 0 Era § 13. 5. 2 The t 2 ̆ 6 #; 2 ̆ 6 #; 0 Era § 13. 5. 3 The Numerical Method § 13. 5. 4 The Initial Value Problem § 13. 5. 5 Programming Quattro-Pro § 13. 5. 6 A Synopsis of the Analytic Solution § 13. 5. 7 Numerical Instability § 13. 6 Exercises 14. COMPUTER ARCHITECTURE § 14. 1 Memory Architecture § 14. 2 The CPU § 14. 3 Communication between the CPU and External Circuits § 14. 4 More About Instructions § 14. 5 Programming the CPU § 14. 6 A Fictional CPU with a Simple Instruction Set § 14. 6. 1 The Move Instructions § 14. 6. 2 The Jump and Compare Instructions and the Condition Register § 14. 6. 3 Arithmetic Operations § 14. 6. 4 Logical Operations and HALT § 14. 6. 5 The Machine Instruction Column § 14. 6. 6 Some Simple Program Examples § 14. 7 Higher Level Languages § 14. 8 Appendix: The 80386 Architecture § 14. 9 Exercises 15. SOME PROGRAMMING TECHNIQUES § 15. 1 Using the PFW 007 Emulator § 15. 2 Shifting a Number n Bits and DO Loops § 15. 3 Writing to a File and Character Strings § 15. 4 A Program to Multiply Two Numbers § 15. 5 Subroutines § 15. 6 Stacks § 15. 7 Subroutines and Stacks § 15. 7. 1 The Return Address § 15. 7. 2 Passing Arguments to Subroutines § 15. 7. 3 Recursion § 15. 7. 4 Automatic and Static Storage § 15. 8 Reading a Number from the Input File § 15. 9 Recursion and a Program to Calculate n! § 15. 10 APPENDIX: Using the Turbo C Editor § 15. 11 Exercises 16. PROGRAMMING THE CPU WITH C § 16. 1 Elements of a C Program § 16. 2 Getting Results Printed Out § 16. 3 Compiling and Running C Programs § 16. 3. 1 Entering, Compiling, and Running a Program § 16. 3. 2 What’s Really Happening § 16. 3. 3 Compile-Time Errors § 16. 3. 4 Run-Time Errors § 16. 4 Exercises 17. MORE PROGRAMMING THE CPU IN C § 17. 1 Pointers § 17. 1. 1 Rear Window I: Addresses of Variables § 17. 1. 2 Rear Window II: Byte Ordering § 17. 2 Arrays § 17. 3 Conditionals, and Program Flow and Loops § 17. 3. 1 Conditionals § 17. 3. 2 Program Flow and Loops § 17. 4 Two Examples § 17. 4. 1 Multiplying Integers “by hand” § 17. 4. 2 Reversing a Character String § 17. 5 Rear Window III: A Program in the Raw § 17. 6 Appendix: The Joy of Segmentation § 17. 7 Exercises 18. PROGRAMMING IN C TO SOLVE PROBLEMS § 18. 1 Functions § 18. 1. 1 A Function which Returns a Value. § 18. 1. 2 ANSI vs K 2 ̆ 6 R C § 18. 1. 3 A Function which Returns Information Via an Argument § 18. 2 Printf, Scanf, and <b>Format</b> <b>Specifiers</b> § 18. 2. 1 Printf and <b>Format</b> <b>Specifiers</b> § 18. 2. 2 Scanf § 18. 3 Multi-Dimensional Arrays § 18. 3. 1 Adding Two Matrices § 18. 3. 2 A Program for Averaging Test Scores § 18. 3. 3 Arrays as Function Arguments § 18. 4 Preprocessor Directives and Stdio § 18. 5 Type Casting of Variables § 18. 6 Exercises 19. C PROGRAM EXAMPLES § 19. 1 Simulating a Random Walk and Memory Allocation § 19. 2 Dynamic Memory Allocation § 19. 3 Using C to Solve Differential Equations § 19. 4 Recursive Function Calls § 19. 4. 1 n Factorial § 19. 4. 2 Determinant § 19. 5 Exercise...|$|R

