210|713|Public
50|$|T1 may write {{some value}} into A {{which makes the}} {{database}} inconsistent. It is possible that interleaved execution can expose this inconsistency and lead to inconsistent final <b>database</b> <b>state,</b> violating ACID rules.|$|E
50|$|During {{the course}} of its {{campaign}} against the <b>database</b> <b>state,</b> NO2ID has helped establish three other independent campaigns: TheBigOptOut.org and medConfidential campaigning for medical confidentiality and LeaveThemKidsAlone, a parent-led campaign against the fingerprinting of children in schools and nurseries.|$|E
5000|$|If a long running {{transaction}} T2 {{starts a}} read operation of Object 2 and Object 1 after T1 committed {{and there is}} a concurrent update transaction T3 which deletes Object 2 and adds Object 3="Foo-Bar", the <b>database</b> <b>state</b> will look like at time 2: ...|$|E
25|$|In 2010, The World Religion <b>Database</b> <b>states</b> {{there are}} 7.3 million Bahá'ís.|$|R
40|$|This paper {{explains}} how four model transformations between database models work: (1) An ER (Entity-Relationship) database schema {{is transformed into}} a collection of ER <b>database</b> <b>states,</b> (2) a RE (Relational) database schema into a collection of RE <b>database</b> <b>states,</b> (3) an ER database schema into a RE database schema, and (4) a collection of ER <b>database</b> <b>states</b> into a collection of RE <b>database</b> <b>states.</b> These four separate transformations may be viewed as a single transformation between the ER datamodel and the RE datamodel. The schemas are regarded as determining the syntax of the datamodels, and the set of associated states is regarded as being the semantics of the datamodels, because the states associate meaning with the schemas. When one usually considers database models, one formally only treats syntactical aspects, i. e., schemas, and handles the semantics merely informally. Our approach allows to formally handle syntax and semantics of database models and their transformation within a single and uniform framework. The approach thus allows to precisely describe properties of the datamodel...|$|R
40|$|Automatically {{generating}} sufficient <b>database</b> <b>states</b> {{is imperative}} to reduce human efforts in testing database applications. Complementing the traditional block or branch coverage, we develop an approach that generates <b>database</b> <b>states</b> to achieve advanced code coverage including boundary value coverage(BVC) and logical coverage(LC) for source code under test. In our approach, we leverage dynamic symbolic execution to examine close relationships among host variables, embedded SQL query statements, and branch conditions in source code. We then derive constraints such that data satisfying those constraints can achieve the target coverage criteria. We implement our approach upon Pex, which is a state-of-the-art DSE-based test-generation tool for. NET. Empirical evaluations on two real database applications show that our approach assists Pex to generate test <b>database</b> <b>states</b> that can effectively achieve both BVC and LC, complementing the block or branch coverage...|$|R
50|$|Serializability of a {{schedule}} means equivalence (in the outcome, the <b>database</b> <b>state,</b> data values) to a serial schedule (i.e., sequential with no transaction overlap in time) {{with the same}} transactions. It is the major criterion for the correctness of concurrent transactions' schedule, and thus supported in all general purpose database systems.|$|E
5000|$|Example of a tagged before hookBefore('@ATM') do |scenario| # Ruby codeendHooks {{are often}} used to {{maintain}} <b>database</b> <b>state,</b> typically by cleaning up prior to running a scenario. It is also possible to start and roll back a transaction using [...] and [...] hooks, and many Cucumber extensions provide an [...] tag for such a purpose.|$|E
5000|$|Atomicity {{requires}} that each transaction be [...] "all or nothing": if {{one part of}} the transaction fails, then the entire transaction fails, and the <b>database</b> <b>state</b> is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors and crashes. To the outside world, a committed transaction appears (by its effects on the database) to be indivisible ("atomic"), and an aborted transaction does not happen.|$|E
50|$|The USDA's Fungal <b>Database</b> <b>states</b> that P. {{narcissi}} {{may be a}} synanamorph of Stagonosporopsis curtisii (Peyronellaea curtisii (Berk.) Aveskamp, Gruyter & Verkley).|$|R
40|$|Consider {{a scheme}} of {{databases}} Q and two signatures: L 0 = f!g, L = f!g[whereΩ is a finite relational signature. For a database scheme SC = fR 1; : : :; R n g, denote L + 0 = L 0 [SC and L + = L [SC. FO is the first-order language. FO in L + 0 is called restricted. FO in L + is called extended. Consider a countable universe U in L. Assume CH. It {{is possible to}} reconstruct the proofs of corollaries into ones not using CH. Let V be a saturated elementary extension of U in power @ 1. There is the only such V up to elementary isomorphisms over U. Th. 1. An extended query Φ is equal for all the finite <b>database</b> <b>states</b> over U to a restricted query iff Φ is generic for all the pseudo-finite <b>database</b> <b>states</b> over V. Th. 2. If U is o-minimal, every locally generic for all the finite <b>database</b> <b>states</b> over U extended query is generic for all the pseudo-finite <b>database</b> <b>states</b> over V. Divisible ordered Abelian groups are o-minimal structures. So, for example, groups of rati [...] ...|$|R
40|$|Testing {{database}} applications typically {{requires the}} generation of tests consisting of both program inputs and <b>database</b> <b>states.</b> Recently, a testing technique called Dynamic Symbolic Execution (DSE) has been proposed to reduce manual effort in test generation for software applications. However, applying DSE to generate tests for database applications faces various technical challenges. For example, the database application under test needs to physically connect to the associated database, {{which may not be}} available for various reasons. The program inputs whose values are used to form the executed queries are not treated symbolically, posing difficulties for generating valid <b>database</b> <b>states</b> or appropriate <b>database</b> <b>states</b> for achieving high coverage of query-result-manipulation code. To address these challenges, in this article, we propose an approach called SynDB that synthesizes new database interactions to replace the original ones from the database application under test. In this way, we bridge various constraints within a database application: query-construction constraints, query constraints, database schema constraints, and query-result-manipulation constraints. We then apply a state-of-the-art DSE engine called Pex for. NET from Microsoft Research to generate both program inputs and <b>database</b> <b>states.</b> The evaluation results show that tests generated by our approach can achieve higher code coverage than existing test generation approaches for database applications...|$|R
5000|$|Blake said: [...] "There are {{political}} references in Extant too, and Ringlands {{talks about the}} danger of entering into a <b>database</b> <b>state,</b> the growing use of drones and excess CCTV in the UK. These topics are included because they are relevant to the story - in Ringlands they essentially are the story - I won't apologise for that. If it leads to more people reading more on the subjects I raise, then I would say that is a good thing. Not enough people know or understand just how little freedom we have left." ...|$|E
50|$|ISAM is {{very simple}} to {{understand}} and implement, as it primarily consists of direct, sequential access to a database file. It is also very inexpensive. The tradeoff is that each client machine must manage its own connection to each file it accesses. This, in turn, leads {{to the possibility of}} conflicting inserts into those files, leading to an inconsistent <b>database</b> <b>state.</b> This is typically solved {{with the addition of a}} client-server framework which marshals client requests and maintains ordering. This is the basic concept behind a database management system (DBMS), which is a client layer over the underlying data store.|$|E
5000|$|As {{a simple}} example, if an {{application}} contains {{a way of}} viewing {{some part of the}} <b>database</b> <b>state,</b> and a way of editing it, then users may edit that state but then not see it changing in the viewer. Alarmed that their edit [...] "didn't work", they may try it again, potentially more than once. If the updates are not idempotent (e.g., they increment a value), this can lead to disaster. Even if they are idempotent, the spurious updates place a burden on the database system - and the situation in which replication delays become particularly noticeable is when the database system is at a high level of load anyway; this can become a vicious circle.|$|E
50|$|This family {{comprises}} about 21 genera and 116 species {{according to}} O'Loughlin & Waters (2004), whereas the World Asteroidea <b>Database</b> <b>states</b> that it includes 150 species in 25 genera.|$|R
50|$|The {{universal}} relation assumption in relational <b>databases</b> <b>states,</b> {{that one}} can place all data attributes into a (possibly very wide) table, which may then be decomposed into smaller tables as needed.|$|R
50|$|Nam Phong {{is today}} a Royal Thai Air Force bombing range. However, the World Aeronautical <b>database</b> <b>states</b> that the runway {{is still in}} use. There is no ICAO {{location}} indicator for this field.|$|R
50|$|In {{concurrency}} control of databases, transaction processing (transaction management), and various transactional applications (e.g., transactional memory and software transactional memory), both centralized and distributed, a transaction schedule is serializable if its outcome (e.g., the resulting <b>database</b> <b>state)</b> {{is equal to}} the outcome of its transactions executed serially, i.e. without overlapping in time. Transactions are normally executed concurrently (they overlap), since this is the most efficient way. Serializability is the major correctness criterion for concurrent transactions' executions. It is considered the highest level of isolation between transactions, and plays an essential role in {{concurrency control}}. As such it is supported in all general purpose database systems. Strong strict two-phase locking (SS2PL) is a popular serializability mechanism utilized in most of the database systems (in various variants) since their early days in the 1970s.|$|E
50|$|Sometimes it {{is desired}} {{to bring a}} {{database}} back to a previous state (for many reasons, e.g., cases when the database is found corrupted due to a software error, or if it has been updated with erroneous data). To achieve this, a backup operation is done occasionally or continuously, where each desired <b>database</b> <b>state</b> (i.e., the values of its data and their embedding in database's data structures) is kept within dedicated backup files (many techniques exist to do this effectively). When this state is needed, i.e., when it is decided by a database administrator to bring the database back to this state (e.g., by specifying this state by a desired point in time when the database was in this state), these files are utilized to restore that state.|$|E
5000|$|The {{concept of}} a {{database}} transaction (or atomic transaction) has evolved in order to enable both a well understood database system behavior in a faulty environment where crashes can happen any time, and recovery from a crash to a well understood <b>database</b> <b>state.</b> A database transaction is a unit of work, typically encapsulating a number of operations over a database (e.g., reading a database object, writing, acquiring lock, etc.), an abstraction supported in database and also other systems. Each transaction has well defined boundaries in terms of which program/code executions are included in that transaction (determined by the transaction's programmer via special transaction commands). Every database transaction obeys the following rules (by support in the database system; i.e., a database system is designed to guarantee them for the transactions it runs): ...|$|E
30|$|Existing fire history {{databases}} {{were compiled}} {{into a single}} standardized project database that {{formed the basis for}} image scene selection. Fire history sources were generally from federal agency <b>databases</b> and <b>state</b> <b>databases.</b> In some cases, state and federal agencies have collaborated in developing and maintaining a single <b>database</b> for <b>state</b> and federal incidents. Federal agency data are aggregated into the Incident Command System database known as the ICS 209 (named after the form number used to report incident status), maintained by the National Interagency Fire Center (NIFC) in Boise, Idaho ([URL] ICS 209 data make up most of the records in the MTBS project <b>database.</b> <b>States</b> were solicited for fire occurrence data when it was uncertain whether the fires were included in the ICS 209.|$|R
5000|$|Details with a {{photograph}} in the Chinese-Australian Historical Images in Australia (CHIA) <b>database</b> <b>states</b> that the 1st Scout Troop finished in 1931 {{and that the}} 2nd Darwin Scout Troop was established by Jo Ruddict in 1938.|$|R
5000|$|The Australian Crime Fiction <b>Database</b> <b>stated</b> {{that the}} author [...] "delivers an {{outstanding}} thriller with complex characters, pressure coming from both within the police force and from a dangerous unknown assailant and a strong unexpected ending." ...|$|R
50|$|Concurrency control {{typically}} also {{ensures the}} Recoverability property of schedules for maintaining correctness {{in cases of}} aborted transactions (which can always happen for many reasons). Recoverability (from abort) means that no committed transaction in a schedule has read data written by an aborted transaction. Such data disappear from the database (upon the abort) and are parts of an incorrect <b>database</b> <b>state.</b> Reading such data violates the consistency rule of ACID. Unlike Serializability, Recoverability cannot be compromised, relaxed at any case, since any relaxation results in quick database integrity violation upon aborts. The major methods listed above provide serializability mechanisms. None of them in its general form automatically provides recoverability, and special considerations and mechanism enhancements are needed to support recoverability. A commonly utilized special case of recoverability is Strictness, which allows efficient database recovery from failure (but excludes optimistic implementations; e.g., Strict CO (SCO) cannot have an optimistic implementation, but has semi-optimistic ones).|$|E
5000|$|Checkpoint: The {{purpose of}} {{checkpointing}} {{is to provide}} a snapshot of the data within the database. A checkpoint, in general, is any identifier or other reference that identifies the state of the database at a point in time. Modifications to database pages are performed in memory and are not necessarily written to disk after every update. Therefore, periodically, the database system must perform a checkpoint to write these updates which are held in-memory to the storage disk. Writing these updates to storage disk creates a point in time in which the database system can apply changes contained in a transaction log during recovery after an unexpected shut down or crash of the database system. If a checkpoint is interrupted and a recovery is required, then the database system must start recovery from a previous successful checkpoint. Checkpointing can be either transaction-consistent or non-transaction-consistent (called also fuzzy checkpointing). Transaction-consistent checkpointing produces a persistent database image that is sufficient to recover the database to the state that was externally perceived at the moment of starting the checkpointing. A non-transaction-consistent checkpointing results in a persistent database image that is insufficient to perform a recovery of the <b>database</b> <b>state.</b> To perform the database recovery, additional information is needed, typically contained in transaction logs. Transaction consistent checkpointing refers to a consistent database, which doesn't necessarily include all the latest committed transactions, but all modifications made by transactions, that were committed at the time checkpoint creation was started, are fully present. A non-consistent transaction refers to a checkpoint which is not necessarily a consistent database, and can't be recovered to one without all log records generated for open transactions included in the checkpoint. Depending on the type of database management system implemented a checkpoint may incorporate indexes or storage pages (user data), indexes and storage pages. If no indexes are incorporated into the checkpoint, indexes must be created when the database is restored from the checkpoint image.|$|E
40|$|Traditional {{database}} systems {{provide a}} user {{with the ability}} to query and manipulate one <b>database</b> <b>state,</b> namely the current <b>database</b> <b>state.</b> However, in several emerging applications, the ability to analyze "what-if" scenarios in order to reason about the impact of an update (before committing that update) is of paramount importance. Example applications include hypothetical database access, active database management systems, and version management, to name a few. The central thesis of the Heraclitus paradigm is to provide flexible support for applications such as these by elevating deltas, which represent updates proposed against the current <b>database</b> <b>state,</b> to be first-class citizens. Heraclitus[Alg,C] is a database programming language that extends C to incorporate the relational algebra and deltas. Operators are provided that enable the programmer to explicitly construct, combine, and access deltas. Most interesting is the when operator, that supports hypothetical access [...] ...|$|E
5000|$|For {{the example}} above, to record valid time, the Person table has two fields added, Valid-From and Valid-To. These specify {{the period when}} a person's address is valid in the real world.On April 4, 1975 John's father {{registered}} his son's birth. An official then inserts a new entry into the <b>database</b> <b>stating</b> that John lives in Smallville from April 3. Note that although the data was inserted on the 4th, the <b>database</b> <b>states</b> that the information is valid since the 3rd. The official does not yet know if or when John will move to another place, so the Valid-To field is set to infinity (∞). The entry in the database is: ...|$|R
50|$|While the FCC <b>database</b> <b>states</b> {{that the}} station's {{transmitter}} tower {{is located on}} Boot Key, {{as well as the}} transmitter for Radio Marti. Radio Marti is actually on Sister's Creek Island, adjacent to Boot Key and inside the Marathon City limits.|$|R
40|$|There are {{a variety}} of {{advanced}} database features which require the ability to manipulate "virtual" <b>database</b> <b>states</b> along with the actual stored state; examples of this include rule-based triggers in active databases, support for hypothetical reasoning, and some concurrent transaction processing systems. This pape...|$|R
40|$|Integrity {{constraints}} {{are usually}} {{assumed to be}} permanent properties that must be satisfied by any <b>database</b> <b>state.</b> However, there are many situations requiring also temporary constraints, that is, constraints that must hold only for a single <b>database</b> <b>state.</b> In this {{paper we propose a}} schema to define both permanent and temporary constraints, that supports efficient constraint checking and semantic query optimization. The proposed schema associates integrity constraints to rules and queries, and it uses methods, that were originally defined for permanent constraints only, to perform constraint checking and semantic query optimization...|$|E
40|$|AGENDA is a {{tool set}} for testing {{relational}} database applications. In this paper we extend AGENDA to test transaction consistency. Two levels of checks are used to check both <b>database</b> <b>state</b> and state transition. The transition check validates the state transition performed by the transaction. The state check validates that the overall global consistency properties hold for the new <b>database</b> <b>state.</b> Our tool set can handle general SQL assertions that are defined in the SQL standard but are not supported by current DBMSs, such as constraints involving multiple tables and SQL aggregration functions. A test generation heuristic that takes account of certain constraints is also presented. A case study based on the TPC-C benchmark shows promising results. 1...|$|E
40|$|In this paper, {{we propose}} a novel fragile and robust {{persistent}} watermarking scheme for relational databases that embeds {{both private and}} public watermarks where the former allows the owner to prove his ownership, while the latter allows any end-user to verify the correctness and originality of the data in the database without loss of strength and security. The public watermarking is based on a part of the <b>database</b> <b>state</b> which remains invariant under processing of the queries associated with the database, whereas the private watermarking is based on an appropriate form of the original <b>database</b> <b>state,</b> called abstract database, and the semantics-based properties of the data which remain invariant under processing of the associated queries...|$|E
30|$|The primary {{outcome was}} 1 -year survival, and {{secondary}} outcomes included in-hospital mortality, ICU length of stay, ICU-free days and hospital length of stay. Mortality data were abstracted from the Mayo Clinic <b>databases,</b> <b>state</b> of Minnesota electronic death certificates and the Rochester Epidemiology Project death data system [19].|$|R
50|$|Salinger died {{suddenly}} in 1962, under disputed circumstances. The Internet Movie <b>Database</b> <b>states</b> {{that he had}} a heart attack in his sleep, but it is claimed that Salinger committed suicide. He lost his home in the 1961 Bel Air Fire, which police believe may have contributed to his despondency.|$|R
50|$|While the Internet Movie <b>Database</b> <b>states</b> {{that the}} film had been revised to its {{original}} ending for a re-release in 1979, Steve Biodrowski of Cinefantastique magazine notes {{that the film}} was still being shown with the complete footage, including a 2005 screening at the Academy of Motion Picture Arts and Sciences, honoring director Don Siegel.|$|R
