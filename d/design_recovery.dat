102|460|Public
5000|$|... "Constraint-Based <b>Design</b> <b>Recovery</b> for Software Reengineering: Theory and Experiments (International Series in Software Engineering)" ...|$|E
50|$|TXL is most {{commonly}} used in software analysis and reengineering tasks such as <b>design</b> <b>recovery,</b> and in rapid prototyping of new programming languages and dialects.|$|E
5000|$|Born in Melfort, Saskatchewan, Woods holds a Ph.D and M.Math {{from the}} David R. Cheriton School of Computer Science at the University of Waterloo in Canada and a B.Sc. from the University of Saskatchewan. He {{was the first}} Ph.D student of Professor Qiang Yang.Woods' Ph.D was {{published}} in 1997 as a book co-written with Alex Quilici and Qiang Yang entitled [...] "Constraint-Based <b>Design</b> <b>Recovery</b> for Software Reengineering: Theory and Experiments"He then worked for Carnegie Mellon's Software Engineering Institute on product line development and practical software architectural reconstruction and analysis.|$|E
40|$|The {{evaluation}} of <b>design</b> pattern <b>recovery</b> techniques and tools is significant as numbers of emergent techniques are presented {{and used in}} the past to recover patterns from source code of legacy applications. The problem of very diverse precision and recall values extracted by different pattern recovery techniques and tools on the same examined applications is not investigated thoroughly. It is very desirable to compare features of existing techniques as abundance of techniques supplemented with different tools has been presented in the last decade. We believe that new innovations for this discipline can be based on the empirical {{evaluation of}} existing techniques. The selected techniques cover the whole spectrum of state of the art research in <b>design</b> pattern <b>recovery.</b> The major contribution of this paper is a comprehensive discussion on state of the art in <b>design</b> pattern <b>recovery</b> research in the last decade followed by a proposed framework for classification and evaluation of existing <b>design</b> pattern <b>recovery</b> techniques. Finally we listed our observations as lessons learned which hamper <b>design</b> pattern <b>recovery</b> research and these observations can be used for future research directions and guidelines for this disciplin...|$|R
30|$|Packaging <b>designed</b> for <b>recovery,</b> and a {{significant}} part of the raw materials from recycled materials.|$|R
5000|$|The {{processing}} plant {{was built by}} GR Engineering Services from Perth and consists of a primary/secondary crusher building near the mine and stockpile, feeding the main {{processing plant}} via conveyor, and a tertiary crusher building. <b>Design</b> <b>recoveries</b> of tin and tungsten {{are in the range}} of 58 - 66% depending on feed type (soft granite near-surface, hard granite towards depth), with grades of >60% tungstate and tin as final products.|$|R
40|$|The {{benefits}} of formal methods in software development are well recognised and well documented. <b>Design</b> <b>recovery</b> involves analysing the source code and recovers the desired design elements based on <b>design</b> <b>recovery</b> specification. One {{way to ensure}} the correctness of the recovered design is to use formal methods in the process. This paper describes an approach to apply formal methods to <b>design</b> <b>recovery.</b> We present the Concept Mapping Language (CML), which is largely based on an adapted form of First Order Languages with object-orientation syntactical extension, to specify the recovery specification that guide the <b>design</b> <b>recovery</b> process. The CML enforces consistency in the specification through formal notations and syntax, and the formal specification ensures correctness in the recovered design through formally correct specification. The result is a simple and reliable approach to apply formal methods to <b>design</b> <b>recovery</b> that will ensure correctness in the specification and therefore the r [...] ...|$|E
40|$|While many {{commercial}} and academic <b>design</b> <b>recovery</b> tools {{have been proposed}} over the years, assessing their relevance and comparing them is difficult {{due to the lack}} of a well-defined, comprehensive, and common framework. In this paper, we introduce such a common comparative framework. The framework builds upon our own experience and extends existing comparative frameworks. We illustrate the comparative framework on two specific <b>design</b> <b>recovery</b> tools. © 2006 IEEE. SCOPUS: cp. pinfo:eu-repo/semantics/publishe...|$|E
40|$|<b>Design</b> <b>recovery,</b> {{which means}} extracting design {{documents}} from source code, is usually done by static analysis techniques. Analysing behaviour by static analysis is very imprecise. We combine static and dynamic analysis {{to increase the}} preciseness of our <b>design</b> <b>recovery</b> process. In this paper we present an approach to collect data for the dynamic analysis by recording method calls during a program’s execution. To {{reduce the amount of}} information we monitor only relevant classes and methods identified by static analysis. 1...|$|E
40|$|Abstract — This paper {{introduces}} the <b>Recovery</b> <b>design</b> pattern. The pattern presents an abstract design model that helps in the <b>designing</b> the <b>recovery</b> problem independent {{of a specific}} application. This pattern has been developed based on the concepts of Stable Design Patterns. Stable design patterns are built based on the concepts of software stability introduced in [5, 6,and 7]. Index Terms—Enduring business themes, Software stability, Software patterns, Stable analysis patterns. I...|$|R
30|$|Qin and Ji (2010) {{applied a}} fuzzy {{programming}} tool to <b>design</b> the product <b>recovery</b> network. That research {{is one of}} the first studies which regarded to logistics network <b>design</b> with product <b>recovery</b> in fuzzy environment. Three fuzzy programming models were formulated and a hybrid intelligent algorithm was designed to solve the proposed models.|$|R
50|$|The early writ of detinue was {{specifically}} <b>designed</b> for <b>recovery</b> of a chattel wrongfully detained, {{but not an}} action to recover loss due to a chattel being harmed while the defendant had it.|$|R
40|$|A {{fundamental}} {{weakness of}} conventional reverse engineering approaches {{is the lack}} of support in identifying program structures and recurring patterns. The integration of human domain knowledge represented via patterns can significantly improve <b>design</b> <b>recovery</b> results. The recognition of a program’s design leads to recurring patterns that, at present, have to be identified in demanding tasks by a human engineer without automated assistance. In this paper we present extensions to our reverse engineering approach based on various <b>design</b> <b>recovery</b> patterns {{that can be used in}} further automating such demanding tasks. The <b>design</b> <b>recovery</b> patterns are defined according to several factors we consider to be essential in the reverse engineering process. Based on these influence factors we show the integration of such patterns in our reverse engineering approach and define the notion of pattern-driven reverse engineering. The implications of pattern-driven reverse engineering and the improvements to be achieved for program understanding are discussed for each kind of patterns in turn. ...|$|E
40|$|The year 2000 problem posed a {{difficult}} problem for many IT shops world wide. The {{most difficult part}} of the problem was not the actual changes to ensure compliance, but finding and classifying the data fields that represent dates. This is a problem well suited to <b>design</b> <b>recovery.</b> This paper presents an overview of LS/ 2000, a system that used <b>design</b> <b>recovery</b> to analyze source code for year 2000 risks and guide a source transformation that was able to automatically remediate over 99 % of the year 2000 risks in over three billion lines of production IT source. 1...|$|E
40|$|Computer Assisted Program Understanding systems take input {{primarily}} {{in the form of}} source code and produce output representing system concepts in some useful form. This paper discusses the development of a program <b>design</b> <b>recovery</b> environment based on structural and behavioral recognition of programming plans. Our research investigates program an d plan representation methods and the issues related t o the detection of code fragments using pattern matching techniques. In particular, we consider the integration of diverse tools allowing selection from a choic e of strategies. Our investigation focuses on technique s to allow partial <b>design</b> <b>recovery</b> when complete recognition is not feasible. Finally, we discuss the underlying process paradigm, called &quot;Goal-Question-Analysis-Action&quot;. ...|$|E
3000|$|The {{study of}} the {{robustness}} of Mann's algorithm is initiated by Combettes [22] where he considered a parallel projection method algorithm in signal synthesis (<b>design</b> and <b>recovery)</b> problems in a real Hilbert space [...]...|$|R
5000|$|GDPS/GM: It {{is based}} on {{asynchronous}} IBM Global Mirror technology with no restrictions on distance. It is <b>designed</b> to <b>recovery</b> from a total failure at one site. It will activate secondary storage devices and backup systems.|$|R
40|$|In this paper, {{we present}} a forward {{recovery}} model for programming robust context-aware applications. The mechanisms devised {{as part of this}} model fall into two categories: asynchronous event handling and synchronous exception handling. These mechanisms enable <b>designing</b> <b>recovery</b> actions to handle different kinds of failure conditions arising in context-aware applications. These include service discovery failures, service binding failures, exceptions raised by a service, and context invalidations. This model is integrated in the high-level programming framework that we have designed for building context-aware collaborative (CSCW) applications. In this paper, we demonstrate the capabilities of this model for programming various kinds of recovery patterns in context-aware applications...|$|R
40|$|Reverse {{engineering}} {{techniques are}} applied to generate a part model {{where there is no}} existing documentation or it is no longer up to date. To facilitate the reverse engineering tasks, a modular, multiperspective <b>design</b> <b>recovery</b> framework has been developed. An evaluation of the product and feature complexity characteristics can readily be extracted from the <b>design</b> <b>recovery</b> framework by using a modification of a rapid complexity assessment tool. The results from this tool provide insight with respect to the original design and assists with the evaluation of potential alternatives and risks, as illustrated by the case study. Organised by: Cranfield UniversityMori Seiki – The Machine Tool Compan...|$|E
40|$|Full <b>design</b> <b>recovery</b> aims at {{reproducing}} {{an existing}} object by analyzing its dimensions, features, form, and properties. The collected {{data and information}} must be transformed into pertinent product knowledge at the system, embodiment and detail levels. This requires a coordinated, collaborative effort to collect and analyze the data and other available information. A thorough analysis of the environment must be conducted in order determine the functional requirements, infer the original needs, and deduce the form and fit features for the part of interest. To address these issues, an integrated and systematic framework for <b>design</b> <b>recovery</b> of mechanical parts is proposed. An example is presented that illustrates {{the application of the}} proposed approach...|$|E
40|$|Nowadays, the {{majority}} of productivity applications are interactive and graphical in nature. In this paper, we explore the possibility of taking advantage of these two characteristics in a <b>design</b> <b>recovery</b> tool. Specifically, {{the fact that an}} application is interactive means that we can identify distinct execution bursts corresponding closely to "actions " performed by the user. The fact that the application is graphical means that we can describe those actions visually from fragments of the application display itself. Combining these two ideas, we obtain an explicit mapping from high-level actions performed by a user (similar to use case scenarios/specification fragments) to their low-level implementation. This mapping can be used for <b>design</b> <b>recovery</b> of interactive graphical applications. We demonstrate our approach using L Y X, a scientific word processor...|$|E
40|$|Estimating {{residual}} {{value of an}} end-of-life product is an essential preliminary to <b>design</b> for <b>recovery.</b> This paper presents a quantitative model for estimating time-varying value of an end-of-life product. The model estimates the expected economic value of a product by considering two major depreciation factors, physical deterioration and technological obsolescence. The developed model is illustrated with an example of desktop computer and potential applications to <b>design</b> for <b>recovery</b> are presented. The model can contribute to enhancing the {{residual value}} of a product and/or improving the way of retrieving the residual value. It can also assist the <b>recovery</b> system <b>design,</b> such as product take-back planning and recovery strategy planning...|$|R
50|$|Refanezumab is a {{monoclonal}} antibody <b>designed</b> for the <b>recovery</b> of motor function after stroke.|$|R
25|$|Multidimensional family therapy, {{which is}} <b>designed</b> to support <b>recovery</b> {{of the patient}} by {{improving}} family functioning.|$|R
40|$|Software {{source text}} is the raw {{material}} of program understanding and transformation systems. In order to share the results of source analyses, both between phases of a <b>design</b> <b>recovery</b> process, and between tools and systems in different processes, a source text interchange format is needed. This paper describes a simple technique, ‘source factoring’, by which a common structural decomposition of source text can address the many issues of preprocessing, macro processing, lexical analysis, <b>design</b> <b>recovery,</b> and automated transformation. Above all, source factorization allows the results of design analysis to be attached to source, {{and the results of}} source transformation to be reinstalled cleanly into the code base. This view of source text underlies the architecture of a successful software maintenance system which has processed billions of lines of legacy code in all major programming languages...|$|E
40|$|Abstract. Semantic {{annotations}} {{will play}} a crucial role in making the vision of the Semantic Web a reality. In this work, we propose a general domain-independent architecture for semantic markup adopting software <b>design</b> <b>recovery</b> techniques, and demonstrate its feasibility in a limited but realistic domain. The results of this experimentation are validated using three stage evaluation schema. ...|$|E
40|$|Most <b>design</b> <b>recovery</b> {{approaches}} {{start from}} analysing source code. Nonetheless, {{it is very}} difficult to get adequate design information only depending on source code. Additional available information is required and Feature Oriented Analysis (FOA) is a way to reach this aim. FOA addresses the understanding of features in software systems and defines mechanisms for carrying a feature from the problem domain into the solution domain. Using feature as the first-class entity for software evolution can improve program comprehension and <b>design</b> <b>recovery.</b> In this paper, an approach is proposed to recover software design based on the feature model, which is a kind of legacy system knowledge. The features will first be located and mapped to the implementation module so that feature-oriented components can be identified and retrieved, and then, through the analysis of the feature relations, the design model of legacy system can be recovered and used for the future evolution...|$|E
5000|$|Graceful degradation, {{where the}} product is <b>designed</b> to allow <b>recovery</b> from {{exceptional}} events without intervention by technical support staff ...|$|R
50|$|Celebrate Recovery is an American Christian twelve-step program <b>designed</b> to {{facilitate}} <b>recovery</b> {{from a wide}} variety of dysfunctional behavior patterns.|$|R
5000|$|... 1972: Viktor Kovda (...) [...] "for {{his theory}} on the {{hydromorphic}} {{origin of the}} soils of the great plains of Asia, Africa, Europe and the Americas" [...] and nine researchers from [...] "for their development of the L-D process <b>designed</b> for <b>recovery</b> of steel from low phosphorus pig iron." ...|$|R
40|$|Field {{studies were}} {{conducted}} by MCC to determine areas of research of mutual interest to MCC and JSC. NASA personnel from the Information Systems Directorate and research faculty from UHCL/RICIS visited MCC in Austin, Texas to examine tools and applications under development in the MCC Software Technology Program. MCC personnel presented workshops in hypermedia, design knowledge capture, and <b>design</b> <b>recovery</b> on site at JSC for ISD personnel. The following programs were installed on workstations in the Software Technology Lab, NASA/JSC: (1) GERM (Graphic Entity Relations Modeler); (2) gIBIS (Graphic Issues Based Information System); and (3) DESIRE (<b>Design</b> <b>Recovery</b> tool). These applications were made available to NASA for inspection and evaluation. Programs developed in the MCC Software Technology Program run on the SUN workstation. The programs do not require special configuration, but they will require larger than usual amounts of disk space and RAM to operate properly...|$|E
40|$|We {{describe}} three {{case studies}} {{in the use of}} Basic LOTOS. The studies cover <b>design</b> <b>recovery,</b> requirements specification, and design activities. We also report lessons learned from the studies. Early lessons suggested changes to the syntax of the language used, and the need for some specific analysis tools. The last case study reports some of the results of these changes...|$|E
40|$|Many {{tasks in}} {{software}} engineering {{can be characterized}} as source to source transformations. <b>Design</b> <b>recovery,</b> software restructuring, forward engineering, language translation, platform migration and code reuse can all be understood as transformations from one source text to another. TXL, the Tree Transformation Language, is a programming language and rapid prototyping system specifically designed to support rulebased source to source transformation. Originally conceived as a tool for exploring programming language dialects, TXL has evolved into a general purpose source transformation system that has proven well suited {{to a wide range of}} software maintenance and reengineering tasks, including the <b>design</b> <b>recovery,</b> analysis and automated reprogramming of billions of lines of commercial Cobol, PL/I and RPG code for the Year 2000. In this paper we introduce the basic features of modern TXL and its use in a range of software engineering applications, with an emphasis on how each task can be achieved by source transformation...|$|E
40|$|AbstractDesign pattern {{recovery}} {{approaches are}} assisted by different tools which recognize patterns from source code of legacy applications. Several tools {{are presented in}} related work, but little attention is paid on the evaluation of tools due to the unavailability of standard benchmarks and frameworks. Different pattern recovery tools extract different results from the same examined systems. The causes for disparity of results and ignorance for cross validation of results by different tools is still not thoroughly investigated. In this paper, we review existing <b>design</b> pattern <b>recovery</b> tools based on their available features and compare them regarding limitations of different tools. We recommend guidelines based on our observation and on the evaluation of different tools {{which can be used}} for comparing features of existing tools and developing new <b>design</b> pattern <b>recovery</b> tools...|$|R
40|$|Extension Service 4 -H 258 : 4 -H Model Rocketry; Beginner level, at the beginning, <b>designs</b> unlimited, <b>recovery</b> systems, out {{come the}} tools, special helps, those {{finishing}} touches, up it goes…,the launch, test for stability, launch pads, rocketeers pledge, {{what made it}} fly?, what a hobby!, project clubs, happy rocketing!, and always follow safety rules...|$|R
40|$|The {{amount of}} {{resource}} provisioning prior to failure events to support optical path recovery {{has a significant}} impact on network performance, and so <b>designing</b> <b>recovery</b> mechanisms for any large network necessitates balancing multiple (in some cases, competing) requirements. The Common Control and Measurement Plane (CCAMP) working group’s Protection and Restoration Design Team conducted a qualitative analysis of path protection schemes using different degrees of backup resource pre-provisioning. The resulting analysis grid highlights some of the trade-offs between the different approaches. In this paper, we describe the results of a simulation study that we conducted using the NIST GMPLS/Lightwave Agile Switching Simulator (GLASS) simulation tool. By measuring network performance with respect to the metrics used by the design team, we were able to produce quantitative results that confirm the design team’s qualitative analysis and provide additional information for carriers and service providers who are designing optical networks. 1...|$|R
