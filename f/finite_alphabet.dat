1434|300|Public
25|$|Let L be a {{language}} over a <b>finite</b> <b>alphabet</b> Σ.|$|E
2500|$|... be {{a finite}} group {{presentation}} where the X is a <b>finite</b> <b>alphabet</b> and where R⊆F(X) is a finite set of cyclically reduced words.|$|E
2500|$|Antimatroids {{also have}} an {{equivalent}} definition as a formal language, that is, {{as a set of}} strings defined from a <b>finite</b> <b>alphabet</b> of symbols. A language L defining an antimatroid must satisfy the following properties: ...|$|E
5000|$|... and [...] are <b>finite</b> <b>alphabets</b> of the {{available}} vertex and arc labels, ...|$|R
3000|$|... to all be {{discrete}} and <b>finite</b> <b>alphabets,</b> and {{all probability}} distributions {{are to be}} interpreted as probability mass functions.|$|R
5000|$|Let [...] denote two <b>finite</b> <b>alphabets</b> and let [...] and [...] {{denote the}} set of all finite words from those alphabets (respectively).|$|R
2500|$|Every computable {{function}} has {{a finite}} procedure giving explicit, unambiguous {{instructions on how}} to compute it. Furthermore, this procedure has to be encoded in the <b>finite</b> <b>alphabet</b> used by the computational model, so there are only countably many computable functions. For example, functions may be encoded using a string of bits (the alphabet [...] ).|$|E
2500|$|NP can {{be defined}} {{similarly}} using nondeterministic Turing machines (the traditional way). However, a modern approach to define NP {{is to use the}} concept of certificate and verifier. Formally, NP is defined as the set of languages over a <b>finite</b> <b>alphabet</b> that have a verifier that runs in polynomial time, where the notion of [...] "verifier" [...] is defined as follows.|$|E
2500|$|As {{discussed}} above, the Cantor Normal Form of ordinals below [...] can {{be expressed}} in an alphabet containing only the function symbols for addition, multiplication and exponentiation, as well as constant symbols for each natural number and for [...] We can {{do away with the}} infinitely many numerals by using just the constant symbol 0 and the operation of successor, [...] (for example, the integer 4 may be expressed as [...] ). This describes an ordinal notation: a system for naming ordinals over a <b>finite</b> <b>alphabet.</b> This particular system of ordinal notation is called the collection of arithmetical ordinal expressions, and can express all ordinals below , but cannot express [...] There are other ordinal notations capable of capturing ordinals well past , but because there are only countably many strings over any <b>finite</b> <b>alphabet,</b> for any given ordinal notation there will be ordinals below [...] (the first uncountable ordinal) that are not expressible. Such ordinals are known as large countable ordinals.|$|E
40|$|Abstract — We {{provide a}} novel achievability {{proof of the}} Slepian-Wolf theorem for i. i. d. sources over <b>finite</b> <b>alphabets.</b> We {{demonstrate}} that random codes that are linear over the real field achieve the classical Slepian-Wolf rate region. For <b>finite</b> <b>alphabets</b> we show that decoding is equivalent to solving an integer program. The techniques used may be of independent interest for code design for a wide class of information theory problems, and for the field of compressed sensing. I...|$|R
3000|$|... is the Kullback-Leibler distance. The term in {{the limit}} is the sum {{capacity}} lower bound for <b>finite</b> <b>alphabets</b> which is derived in [21].|$|R
40|$|We {{propose a}} modulus based zero-forcing (MZF) {{detection}} for multi-input multi-output (MIMO) channels. Traditionally, a ZF detector nulls out all interferences from other layers when detecting a current layer, which can yield suboptimal detection-performance {{due to the}} noise-enhancement issue. In many communication systems, <b>finite</b> <b>alphabets</b> such as M quadrature-amplitude-modulation (QAM) are widely used, which comprises √(M) pulse-amplitude-modulation (PAM) symbols for the real and imaginary parts. With <b>finite</b> <b>alphabets,</b> one feasible way to improve ZF detection is to allow controllable interferences that can be removed away by modulus operations. Comment: Submitted; 4 figure...|$|R
2500|$|Let Σ be a <b>finite</b> <b>alphabet</b> of b digits, and Σ∞ {{the set of}} all {{sequences}} {{that may}} be drawn from that alphabet. Let S ∈ Σ∞ be such a sequence. [...] For each a in Σ let NS(a, n) denote {{the number of times}} the letter a appears in the first n digits of the sequence S. [...] We say that S is simply normal if the limit ...|$|E
2500|$|This {{definition}} can {{be extended}} to define a notion of randomness for infinite sequences from a <b>finite</b> <b>alphabet.</b> These algorithmically random sequences can be defined in three equivalent ways. One way uses an effective analogue of measure theory; another uses effective martingales. [...] The third way defines an infinite sequence to be random if the prefix-free Kolmogorov complexity of its initial segments grows quickly enoughnbsp&— {{there must be a}} constant c such that the complexity of an initial segment of length n is always at least n−c. [...] This definition, unlike the definition of randomness for a finite string, is not affected by which universal machine is used to define prefix-free Kolmogorov complexity.|$|E
2500|$|The {{expressive}} {{power of}} {{various forms of}} second-order logic on finite structures is intimately tied to computational complexity theory. The field of descriptive complexity studies which computational complexity classes can be characterized {{by the power of}} the logic needed to express languages (sets of finite strings) in [...] them. A string w=w1···wn in a <b>finite</b> <b>alphabet</b> A can be represented by a finite structure with domain D={1,...,n}, unary predicates Pa for each a∈A, satisfied by those indices i such that wi=a, and additional predicates which serve to uniquely identify which index is which (typically, one takes the graph of the successor function on D or the order relation <, possibly with other arithmetic predicates). Conversely, the table of any finite structure can be encoded by a finite string.|$|E
40|$|International audienceThe Generalized Markov Lemma {{has been}} used in the proofs of several multiterminal source coding theorems for <b>finite</b> <b>alphabets.</b> An {{alternative}} approach to extend this result to countable infinite sources is proposed. We establish sufficient conditions to guarantee the joint typicality of reproduction sequences of random descriptions that have not been necessarily generated from the product of probability measures. Compared to existing proofs for <b>finite</b> <b>alphabets,</b> our technique is simpler and self-contained. It also offers bounds on the asymptotic tail probability of the typicality event providing a scaling law for a large number of source encoders...|$|R
40|$|We {{consider}} {{a class of}} systems over <b>finite</b> <b>alphabets,</b> namely discrete-time systems with linear dynamics and a <b>finite</b> input <b>alphabet.</b> We formulate a notion of finite uniform bisimulation, and motivate and propose a notion of regular finite uniform bisimulation. We derive sufficient conditions {{for the existence of}} finite uniform bisimulations, and propose and analyze algorithms to compute finite uniform bisimulations when the sufficient conditions are satisfied. We investigate the necessary conditions, and conclude with a set of illustrative examples. Comment: 19 page...|$|R
50|$|Concatenation theory, {{also called}} string theory, character-string theory, or {{theoretical}} syntax, studies character strings over <b>finite</b> <b>alphabets</b> of characters, signs, symbols, or marks. String theory is foundational for formal linguistics, computer science, logic, and metamathematics especially proof theory. A generative grammar {{can be seen}} as a recursive definition in string theory.|$|R
2500|$|A finite-state gambler (a.k.a. finite-state martingale) is a finite-state machine over a <b>finite</b> <b>alphabet</b> , each {{of whose}} states is {{labelled}} with percentages {{of money to}} bet on each digit in [...] For instance, for an FSG over the binary alphabet , the current state q bets some percentage [...] of the gambler's money on the bit 0, and the remaining [...] fraction of the gambler's money on the bit 1. The money bet on the digit that comes next in the input (total money times percent bet) is multiplied by , {{and the rest of}} the money is lost. After the bit is read, the FSG transitions to the next state according to the input it received. A FSG d succeeds on an infinite sequence S if, starting from $1, it makes unbounded money betting on the sequence; i.e., if ...|$|E
50|$|Let L be a {{language}} over a <b>finite</b> <b>alphabet</b> Σ.|$|E
50|$|Let R be a semiring and A a <b>finite</b> <b>alphabet.</b>|$|E
40|$|AbstractIn {{this paper}} we prove that, except for at most one, all {{the ranks of}} a right {{infinite}} word which is recurrent and not ultimately periodic are {{the starting point of}} anω-division. Using this we give a very simple proof of Shirshov's theorem. We also extend it to not necessarily <b>finite</b> <b>alphabets...</b>|$|R
40|$|<b>Finite</b> <b>alphabets</b> of {{at least}} three letters permit the {{construction}} of square-free words of infinite length. We show that the entropy density is strictly positive and derive reasonable lower and upper bounds. Finally, we present an approximate formula which is asymptotically exact with rapid convergence in the number of letters. Comment: 18 page...|$|R
40|$|AbstractA {{model of}} {{computation}} dealing with infinite alphabets is proposed. This model {{is based on}} replacing the equality test by substitution. It {{appears to be a}} natural generalization of the classical Rabin-Scott finite-state automata and possesses many of their closure and decision properties. Also, when restricted to <b>finite</b> <b>alphabets</b> the model is equivalent to finite-state automata...|$|R
50|$|It {{follows that}} a k-automatic {{sequence}} is necessarily a sequence on a <b>finite</b> <b>alphabet.</b>|$|E
5000|$|A is a <b>finite</b> <b>alphabet,</b> and finite (possibly empty) strings on A {{are called}} words.|$|E
50|$|If the inputs are {{coded as}} strings over a <b>finite</b> <b>alphabet,</b> size {{might be the}} string length.|$|E
40|$|This {{report is}} about the {{algorithm}} by Amir and Nor for real-time indexing over fixed <b>finite</b> <b>alphabets</b> [1]. Here, indexing refers {{to the problem of}} finding patterns within a text. The text is arriving at a constant rate and is composed of symbols from a fixed, finite set. For example, the set could consist of al...|$|R
40|$|We {{consider}} the classical multiterminal source coding problem subject to distortion constraints computed using the logarithmic loss distortion measure. We provide a single-letter {{description of the}} achievable rate distortion region for arbitrarily correlated sources with <b>finite</b> <b>alphabets.</b> In doing so, we also give the rate distortion region for the m-encoder CEO problem. Several applications and examples are given. ...|$|R
40|$|We {{introduce}} a GUI fronted program that can compute combinatorial properties and topological invariants of recognisable and primitive symbolic substitutions on <b>finite</b> <b>alphabets</b> and their associated tiling spaces. We introduce theory {{from the study}} of aperiodic 1 -dimensional tilings along with pseudocode highlighting the algorithms that we have implemented into the GUI. Grout is written using C++ and its standard library...|$|R
50|$|An {{information}} source is {{a sequence of}} random variables ranging over a <b>finite</b> <b>alphabet</b> &Gamma;, having a stationary distribution.|$|E
5000|$|More formally, {{the star}} {{height of a}} regular expressionE over a <b>finite</b> <b>alphabet</b> A is inductively defined as follows: ...|$|E
50|$|In mathematics, an {{information}} source is {{a sequence of}} random variables ranging over a <b>finite</b> <b>alphabet</b> &Gamma;, having a stationary distribution.|$|E
40|$|AbstractWe {{consider}} one-sided infinite words generated via iteration by primitive substitutions on <b>finite</b> <b>alphabets</b> {{and provide}} bounds on the palindrome complexity function {{as well as}} uniform bounds on the frequencies of palindromes in such words. As an application of these bounds, we prove that the strongly palindromic sequences in a primitive substitution dynamical system form a set of measure zero...|$|R
40|$|Abstract—We {{consider}} the two-encoder multiterminal source coding problem subject to distortion constraints computed under logarithmic loss. We provide a single-letter {{description of the}} achievable rate distortion region for arbitrarily correlated sources with <b>finite</b> <b>alphabets.</b> In doing so, we also give the rate distortion region for the CEO problem under logarithmic loss. Notably, the Berger-Tung inner bound is tight in both settings. I...|$|R
40|$|Abstract-We {{examine the}} problem of {{deciphering}} a file that has been Huffman coded, but not otherwise encrypted. We find that a Huffman code can be surprisingly difficult to cryptanalyze. We present {{a detailed analysis of}} the situation for a three-symbol source alphabet and present some results for general <b>finite</b> <b>alphabets.</b> Index Terms-Huffman codes, cryptography, encoding rules, ambiguity, independent sources, Markov sources. I...|$|R
