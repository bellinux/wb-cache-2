201|19|Public
2500|$|A finite-state machine (FSM) or <b>finite-state</b> <b>automaton</b> (FSA, plural: automata), finite automaton, {{or simply}} a state machine, is a {{mathematical}} model of computation. [...] It is an abstract machine that can be in exactly one of {{a finite number of}} states at any given time. [...] The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.|$|E
50|$|An {{aperiodic}} <b>finite-state</b> <b>automaton</b> is a <b>finite-state</b> <b>automaton</b> whose transition monoid is aperiodic.|$|E
5000|$|A finite-state {{transducer}} (FST) is a finite-state {{machine with}} two memory tapes, following the terminology for Turing machines: an input tape and an output tape. This contrasts with an ordinary <b>finite-state</b> <b>automaton,</b> {{which has a}} single tape. A FST {{is a type of}} <b>finite-state</b> <b>automaton</b> that maps between two sets of symbols. [...] A FST is more general than a <b>finite-state</b> <b>automaton</b> (FSA). A FSA defines a formal language by defining a set of accepted strings while a FST defines relations between sets of strings.|$|E
40|$|Developmental second-order {{recurrent}} {{neural networks}} of special type modified to enhance stability in face of inputs beyond range of inputs on which trained. Second-order recurrent neural networks contain product feedback units {{and can be}} trained, by use of example inputs and outputs, to act as <b>finite-state</b> <b>automatons.</b> Particular second-order recurrent neural networks in question learn grammars in sense they are trained to generate binary responses to input training sequences of ones and zeros, each sequence being marked "legal" or "illegal" according to grammar to be learned...|$|R
40|$|The aim of {{the paper}} is the {{development}} of algorithms for the finite-state cluster-analysis, the theoretical and numerical investigation of algorithms and the application of obtained results to the solution of applied problems. First the group of independent <b>finite-state</b> <b>automatons</b> with linear tactics has been used in the cluster-analysis. The asymptotic optimality of finite-state parallel clusterization has been established. The new algorithms of clusterization using the groups of determinated and stochastic automatons have been developed. The algorithms have been applied: in solving problem for selection of the morphofunctional development types of schoolboys; at analysis of multi-extremum problem structureAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
40|$|A {{possible}} {{cellular automaton}} approach to weather (and in particular rainfall) modelling is considered. After posing a paradigm {{problem in a}} manner reminiscent of a numerical PDE solver and showing that the general approach appears to be valid, we consider some more detailed modelling and comment on how this {{could be used to}} construct a genuine <b>finite-state</b> cellular <b>automaton...</b>|$|R
50|$|A counter-free {{language}} is a regular language {{for which there is}} an integer n such that for all words x, y, z and integers m ≥ n we have xymz in L if and only if xynz in L. A counter-free automaton is a <b>finite-state</b> <b>automaton</b> which accepts a counter-free language. A <b>finite-state</b> <b>automaton</b> is counter-free if and only if it is aperiodic.|$|E
5000|$|... {{the engine}} may convert it to a {{deterministic}} <b>finite-state</b> <b>automaton</b> (DFA) {{and run the}} input through the result; ...|$|E
50|$|If {{a system}} is {{regarded}} as a <b>finite-state</b> <b>automaton</b> with a set of transitions (operations) that change the system's state, then a security policy {{can be seen as a}} statement that partitions these states into authorized and unauthorized ones.|$|E
40|$|In {{this paper}} we present simple methods for {{construction}} {{and evaluation of}} finite-state spell-checking tools using an existing <b>finite-state</b> lexical <b>automaton,</b> freely available <b>finite-state</b> tools and Internet corpora acquired from projects such as Wikipedia. As an example, we use a freely available open-source implementation of Finnish morphology, made with traditional finite-state morphology tools, and demonstrate rapid building of Northern Sámi and English spell checkers from tools and resources available from the Internet. 1...|$|R
40|$|Abstract. A frontier-to-root {{deterministic}} <b>finite-state</b> tree <b>automaton</b> (DTA) {{can be used}} as {{a compact}} data structure to store collections of unranked ordered trees. DTAs are usually sparser than string automata, as most transitions are undefined and therefore, special care must be taken in order to minimize them efficiently. However, it is difficult to find simple and detailed descriptions of the minimization procedure in the published literature. Here, we fully describe a simple implementation of the standard minimization algorithm that needs a time in O(|A | 2), with |A | being the size of the DTA. ...|$|R
50|$|The proofs of Courcelle's theorem show a {{stronger}} result: {{not only can}} every (counting) monadic second-order property be recognized in linear time for graphs of bounded treewidth, {{but it can be}} recognized by a <b>finite-state</b> tree <b>automaton.</b> Courcelle conjectured a converse to this: if a property of graphs of bounded treewidth is recognized by a tree automaton, then it can be defined in counting monadic second-order logic. Despite an attempted proof by , this is still considered to be unsolved. However, some special cases are known: in particular, it is true for graphs of treewidth at most three.|$|R
5000|$|Other {{approaches}} to cellular computing include developing an in vivo programmable and autonomous <b>finite-state</b> <b>automaton</b> with E. coli, and designing and constructing in vivo cellular logic gates and genetic circuits that harness the cell's existing biochemical processes (see for example [...] ).|$|E
5000|$|Regular {{expression}} matching {{can be done}} {{by building}} a <b>finite-state</b> <b>automaton.</b> Regular expressions can be easily converted to nondeterministic automata (NFAs), in which for each state and input symbol there may be several possible next states. After building the automaton, several possibilities exist: ...|$|E
50|$|A {{read-only}} Turing {{machine or}} Two-way deterministic <b>finite-state</b> <b>automaton</b> (2DFA) is class of models of computability that {{behave like a}} standard Turing machine and can move in both directions across input, except cannot write to its input tape. The machine in its bare form is equivalent to a Deterministic finite automaton in computational power, and therefore can only parse a regular language.|$|E
40|$|Abstract. In {{this paper}} we {{introduce}} {{a notion of}} a regular expression over infinite alphabets and show that a language is definable by an infinite alphabet regular expression {{if and only if}} it is acceptable by <b>finite-state</b> unification based <b>automaton</b> – a model of computation that is tightly related to other models of automata over infinite alphabets. ...|$|R
40|$|AbstractWe {{define the}} new {{notion of a}} (<b>finite-state)</b> {{unification}} <b>automaton,</b> a device for finite-state recognition of relational languages by means of unification transitions. Words in such a language are formed by composing base relations, and have the general form ri 1 (xj 1, xk 1) ···rin(xjn, xkn) for some n. Generation of such languages by regarding Horn clauses as grammers has been considered before, but {{to the best of}} our knowledge, recognizing such languages by suitably designed automata is a new approach. The main result presented is a pumping lemma, forming a necessary condition for finite-state recognizability. Some example results about such automata are given...|$|R
2500|$|The proofs of Courcelle's theorem show a {{stronger}} result: {{not only can}} every (counting) monadic second-order property be recognized in linear time for graphs of bounded treewidth, {{but it can be}} recognized by a <b>finite-state</b> tree <b>automaton.</b> Courcelle conjectured a converse to this: if a property of graphs of bounded treewidth is recognized by a tree automaton, then it can be defined in counting monadic second-order logic. In 1998 , claimed a resolution of the conjecture. However, the proof is widely regarded as unsatisfactory [...] Until 2016, only a few special cases were resolved: in particular, the conjecture has been proved for graphs of treewidth at most three, for k-connected graphs of treewidth k, for graphs of constant treewidth and chordality, and for k-outerplanar graphs.|$|R
50|$|A finite-state machine (FSM) or <b>finite-state</b> <b>automaton</b> (FSA, plural: automata), finite automaton, {{or simply}} a state machine, is a {{mathematical}} model of computation. It is an abstract machine that can be in exactly one of {{a finite number of}} states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.|$|E
50|$|In 1987 {{an article}} was {{published}} detailing {{the development of}} a character string search engine (SSE) for rapid text retrieval on a double-metal 1.6-μm n-well CMOS solid-state circuit with 217,600 transistors lain out on a 8.62x12.76-mm die area. The SSE accommodated a novel string-search architecture which combines a 512-stage <b>finite-state</b> <b>automaton</b> (FSA) logic with a content addressable memory (CAM) to achieve an approximate string comparison of 80 million strings per second. The CAM cell consisted of four conventional static RAM (SRAM) cells and a read/write circuit. Concurrent comparison of 64 stored strings with variable length was achieved in 50 ns for an input text stream of 10 million characters/s, permitting performance despite the presence of single character errors in the form of character codes. Furthermore, the chip allowed nonanchor string search and variable-length `don't care' (VLDC) string search.|$|E
40|$|It is {{well known}} that {{context-free}} parsing {{can be seen as the}} intersection of a contextfree language with a regular language (or, equivalently, the intersection of a context-free grammar with a <b>finite-state</b> <b>automaton).</b> The present article provides a practical efficient way to compute this intersection by converting the grammar into a special <b>finite-state</b> <b>automaton</b> (the GLR(0) -automaton) which is subsequently intersected with the given <b>finite-state</b> <b>automaton.</b> As a byproduct, we present a generalisation of Tomita’s algorithm to recognize several inputs simultaneously. ...|$|E
40|$|AbstractThe main {{result of}} this paper is a {{description}} of linguistically motivated non-context-free phenomena equivalently in terms of regular tree languages (to express the recursive properties) and both a logical and an operational perspective (to establish the intended linguistic relations). The result is exemplified with a particular non-context-free phenomenon, namely cross-serial dependencies in natural languages such as Swiss German or Dutch. The logical description is specified in terms of binary monadic second-order (MSO) formulas and the operational description is achieved by means of a linear and non-deleting macro tree transducer. Besides giving a grammatical presentation for the regular tree language we shall also specify an implementation {{in the form of a}} <b>finite-state</b> (tree) <b>automaton</b> to emphasize the effectivity of our approach...|$|R
40|$|The paper {{deals with}} the proof method of {{verification}} by augmented finitary abstraction (vaa), which presents an effective approach to the verification of the temporal properties of (potentially infinitestate) reactive systems. The method consists of a two-step process by which, in a first step, the system and its temporal specification are combined an then abstracted into a <b>finite-state</b> Buchi <b>automaton.</b> The second step uses model checking to establish emptiness of the abstracted automaton. The vaa method {{can be considered as}} a viable alternative to verification by temporal deduction which, up to now, has been the main method shown to be complete for the verification of infinite-state systems. The paper presents a general recipe for the abstraction of Buchi automata which is shown to be sound, where soundness means that emptiness of the abstract automaton implies emptiness of the concrete (infinitestate) automaton. To [...] ...|$|R
5000|$|In a nested word automaton, the {{position}} [...] in the nested word (w,↝) {{might be a}} return position; if so, the state after reading [...] will not only depend on the linear state in which the automaton was before reading , but also on a hierarchical state propagated by the automaton {{at the time it}} was in the corresponding call position. In analogy to regular languages of words, a set L of nested words is called regular if it is accepted by some (<b>finite-state)</b> nested word <b>automaton.</b>|$|R
40|$|Abstract. We {{propose a}} {{representation}} of simple conceptual graphs with binary conceptual relations, {{which is based on}} finite-state automata. The representation enables the calculation of injective projection as a two-stage process: off-line calculation of the computationally-intensive subsumption checks and encoding of the results as a minimal <b>finite-state</b> <b>automaton,</b> and run-time calculation by look-up in the minimal <b>finite-state</b> <b>automaton</b> using the projection query as a word belonging to the automaton language. This approach is feasible since {{a large part of the}} projection calculations does not depend on the run-time query but only on the relatively static statements in the knowledge base...|$|E
40|$|Abelian {{complexity}} {{of a word}} u is a function that counts the number of pairwise non-abelian-equivalent factors of u of length n. We prove that for any c-balanced Parry word u, {{the values of the}} abelian complexity function can be computed by a <b>finite-state</b> <b>automaton.</b> The proof is based on the notion of relative Parikh vectors. The approach works for any function F(n) that can be expressed in terms of the set of relative Parikh vectors corresponding to the length n. For example, we show that the balance function of a c-balanced Parry word is computable by a <b>finite-state</b> <b>automaton</b> as well. Comment: 19 page...|$|E
40|$|Abstract. A {{counting}} <b>finite-state</b> <b>automaton</b> is a nondeterministic <b>finite-state</b> <b>automaton</b> which, on {{an input}} over its input alphabet, (magically) writes in binary {{the number of}} accepting computations on the input. We examine the complexity of computing the counting function of an NFA, and the complexity of recognizing its range {{as a set of}} binary strings. We also consider the pumping behavior of counting finite-state automata. The class of functions computed by counting NFA’s (1) includes a class of functions computed by deterministic finite-state transducers; (2) is contained in the class of functions computed by polynomially time- and linearly space-bounded Turing transducers; (3) includes a function whose range is the composite numbers. 1...|$|E
40|$|We {{represent}} a filamentous actin molecule as a graph of <b>finite-state</b> machines (F-actin <b>automaton).</b> Each node in the graph takes three states [...] - resting, excited, refractory. All nodes update their states simultaneously {{and by the}} same rule, in discrete time steps. Two rules are considered: threshold rule [...] - a resting node is excited if it {{has at least one}} excited neighbour and narrow excitation interval rule [...] - a resting node is excited if it has exactly one excited neighbour. We analyse distributions of transient periods and lengths of limit cycles in evolution of F-actin automaton, propose mechanisms for formation of limit cycles and evaluate density of information storage in F-actin automata...|$|R
40|$|Building and {{developing}} linguistic resources for languages is of prime importance with {{many areas of}} application. This paper focusses on a fully automatic approach to the aquisition of a syllable phonotactics for a particular language. In this approach the phonotactic constraints for a language are encoded in a <b>finite-state</b> phonotactic <b>automaton</b> the structure {{of which can be}} automatically derived from an example set of well-formed syllables that may occur in the language in question. Such automatic acquisition of phonotactics is achieved {{through the use of a}} regular grammatical inference algorithm which is entirely data driven ensuring that it can be applied to any language provided syllable labelled data is available. The approach allows for a rapid and low cost development of phonotactic resources for any language under observation. This makes it an attractive approach for developing phonotactic resources for lesser studied languages in the case where syllable labelled data for a language is available but language specific information required for hand constructing a phonotactics may not. Given that syllable labelled data for a language may not always be available a semi-automatic approach to acquiring a syllable phonotactics from phoneme labelled data without syllable boundaries is also discussed. ...|$|R
40|$|Tree walking {{transducers}} are an expressive formalism for reasoning about XSLT-like document transformations. One of {{the useful}} properties of tree transducers is decidability of type checking: given a transducer and {{input and output}} types, it can be checked statically whether the transducer is type correct, i. e., whether each document adhering to the input type is necessarily transformed into documents adhering to the output type. Here, a “type” means a regular set of trees specified by a <b>finite-state</b> tree <b>automaton.</b> Usually, type checking of tree transducers is extremely expensive; already for simple top-down tree transducers it {{is known to be}} EXPTIME-complete. Are there expressive classes of tree transducers for which type checking can be performed in polynomial time? Most of the previous approaches are based on inverse type inference. The approach presented here goes the other direction: it uses forward type inference. This means to infer, given a transducer and an input type, the corresponding set of output trees. In general, this set is not a type, i. e., is not regular. However, its intersection emptiness with a given type can be decided. Using this approach it is shown that type checking can be performed in polynomial time, if (1) the output type is specified by a deterministic tree automaton and (2) the transducer visit...|$|R
40|$|This paper {{describes}} a non-deterministic tokeniser implemented {{and used for}} the development of a French finite-state grammar. The tokeniser includes a <b>finite-state</b> <b>automaton</b> for simple tokens and a lexical transducer that encodes a wide variety of multiword expressions, associated with multiple lexical descriptions when required...|$|E
40|$|A {{piecewise-linear}} {{hybrid system}} is a dynamic system which {{is the product of}} a <b>finite-state</b> <b>automaton</b> and a family of affine systems on polytopes. In full generality, determination of the controllability of such systems is undecidable. For control synthesis it is therefore of interest to determine subclasses of such systems for which the problem is decidable. In this paper an approach to controllability is described for which the problem decomposes into a reachability problem for a <b>finite-state</b> <b>automaton</b> and one for a family of affine systems on polytopes. For a subclass of such systems an equivalent condition for reachability of a piecewise-linear hybrid system is summarized. The solution to the subproblem of control to a facet of a polytope is presented...|$|E
40|$|Let (Q, ∑, δ, ω) be a <b>finite-state</b> <b>automaton</b> with {{input-output}} alphabet ∑. Let ∑+ be {{the free}} semigroup generated by ∑ and ∑N be {{the set of}} all infinite sequences of elements of ∑. Rayna (1974) Inform. Contr. 24 calls a sequence x ∑ ∑N complete {{if and only if}} every A ∑ ∑+ is contained in x. Huffman (1959) IRE Trans. Circuit Theory Suppl. CT- 6 calls a <b>finite-state</b> <b>automaton</b> information-lossless iff there exist no two states qi and qf and no two different equal-length input blocks A, B ∑ ∑+ and an output block C ∑ ∑+ such that δ(qi, A) = qf = δ(qi, B) and ω(qi, A) = C = ω(qi, B). Gordon (1976) Inform Contr. 32 calls a degree of finite-state transformability complete iff it contains a complete sequence. In that paper the properties of an information-lossless <b>finite-state</b> <b>automaton</b> are studied when a complete sequence is the input. In this paper we use the properties discovered by Gordon (1976) to study the set U[x] of upper bounds for a complete degree of finite-state transformability. The main result states that, for any two complete degrees [x] and [y], we have U[x] is orderisomorphic to U[y]...|$|E
40|$|Abstract In {{real-time}} systems, correctness {{depends on}} the time at which events occur. Examples of real-time systems include timed protocols and many embedded system controllers. Timed automata are an extension of finite-state automata that include real-valued clock variables used to measure time. Given a timed <b>automaton,</b> an equivalent <b>finite-state</b> region <b>automaton</b> can be constructed, which guarantees decidability. Timed model checking tools like Uppal, Kronos, and Red use specialized data structures to represent the real-valued clock variables. A different approach, called integer-discretization, is to define clock variables that can assume only integer values, but, in general, this does not preserve continuous-time semantics. This paper describes an implicit representation of the region automaton to which ordinary model checking tools can be applied directly. This approach differs from integer discretization because {{it is able to}} handle real-valued clock variables using a finite representation and preserves the continuous-time semantics of timed automata. In this framework, we introduce the GoAbstraction, a technique {{to reduce the size of}} the state space. Based on a conservative approximation of the region automaton, GoAbstraction makes it possible to verify larger systems. In order to make the abstraction precise enough to prove meaningful properties, we introduce auxiliary variables, called Go variables, that limit the drifting of clock variables in the abstract system. The paper includes preliminary experimental results showing the effectiveness of our technique using both symbolic and bounded model checking tools...|$|R
40|$|A graph G on n {{vertices}} is a k-leaf power (G ∈ Gk) {{if it is}} isomorphic to a graph {{that can}} be “generated” from a tree T that has n leaves, by taking the leaves to represent vertices of G, and making two vertices adjacent {{if and only if}} they are at distance at most k in T. We address two questions in this paper: (1) As k increases, do we always have Gk ⊆ Gk+ 1 ? Answering an open question of Andreas Brandstädt and Van Bang Le [2, 3, 1], we show that the answer, perhaps surprisingly, is “no. ” (2) How should one design algorithms to determine, for k-leaf powers, if they have some property? One way this can be done is to use the fact that k-leaf powers have bounded cliquewidth. This fact, plus the FPT cliquewidth approximation algorithm of Oum and Seymour [14], combined with the results of Courcelle, Makowsky and Rotics [7], allows us to conclude that properties expressible in a general logic formalism, can be decided in FPT time for k-leaf powers, parameterizing by k. This is wildly inefficient. We explore a different approach, under the assumption that a generating tree is given with the graph. We show that one can use the tree directly to decide the property, by means of a <b>finite-state</b> tree <b>automaton.</b> (A more general theorem has been independently obtained by Blumensath and Courcelle [5].) We place our results in a general context of “tree-definable” graph classes, of which k-leaf powers are one particular example...|$|R
40|$|A celebrated theorem by Courcelle {{states that}} every problem definable in monadic second-order logic (MSO) {{can be solved}} in linear time on graphs of bounded treewidth. This meta-theorem along with its {{extensions}} by Arnborg, Lagergren, and Seese {{as well as by}} Courcelle and Mosbah explains, why many important graph problems that are NP-hard on general graphs can be solved efficiently on tree-decomposable graphs. Such problems include, for instance, Vertex Cover, Dominating Set, 3 -Colorability, Steiner Tree, Max-Cut, and Hamiltonian Cycle. The standard proof of Courcelle's Theorem is to translate the MSO-formula into a <b>finite-state</b> tree <b>automaton</b> that accepts a tree decomposition of the input graph iff the graph is a model for the MSO-formula. Existing, optimized software such as MONA can be used to construct the corresponding tree automaton, which for bounded treewidth is of constant size. Unfortunately, the constants involved can become extremely large - every quantifier alternation in the MSO formula requires a power set construction for the automaton. Here, the required space causes severe problems in practical applications. In this thesis, we develop a novel approach based on model checking games, also known as Hintikka games. We show that one can construct the model checking game via a linear-time dynamic programming algorithm on a tree decomposition of the input graph. To make the size of the games manageable in practical settings, we introduce a three-valued extension of the classical model checking game and a technique that we call "early determinization. " Furthermore, we describe our implementation of the resulting MSO model checking algorithm for graphs of bounded treewidth and present experimental results. These indicate that for some natural optimization problems our approach is a suitable alternative to Integer Linear Optimization...|$|R
