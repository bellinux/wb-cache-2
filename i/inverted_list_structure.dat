2|2098|Public
40|$|Abstract: Inverted List Indexes {{are popular}} in {{information}} retrieval (IR) systems to support efficient keyword queries. They are also utilized in exact and fuzzy string matching. In many IR systems it {{is acceptable to}} execute updates offline because recency of documents is not a strong requirement. However, in some systems (e. g. news systems) the most recent documents {{may be the most}} relevant answers to a search query. For these systems it is desirable to allow updates to execute online. This requires concurrency control (CC) on the <b>inverted</b> <b>list</b> <b>structure</b> to disallow the execution of incorrect interleavings of reads and writes. Traditional concurrency control protocols like 2 PL have been shown to perform poorly, therefore novel techniques have been developed that exploit the semantics of the transactions and their operations on inverted lists. We briefly introduce two of CC mechanisms [KAM’ 96, BMV’ 96], compare them and comment on their performance. Essentials: Both papers identify fundamental properties of transactions on inverted lists that need to be considered for CC: I. At a high level, transactions are either read-only or write-only. A transaction cannot consist of arbitrarily combined reads and writes. This implies that write operations do no...|$|E
40|$|At {{the age of}} Web 2. 0, Web content becomes live, {{and users}} would like to {{automatically}} receive content of interest. Popular RSS subscription approach cannot offer fine-grained filtering approach. In this paper, we propose a personalized subscription approach over the live Web content. The document is represented by pairs of terms and weights. Meanwhile, each user defines a top-k continuous query. Based on an aggregation function to measure the relevance between a document and a query, the user continuously receives the top-k most relevant documents inside a sliding window. The challenge of the above subscription approach is the high processing cost, especially {{when the number of}} queries is very large. Our basic idea is to share evaluation results among queries. Based on the defined covering relationship of queries, we identify the relations of aggregation scores of such queries and develop a graph indexing structure (GIS) to maintain the queries. Next, based on the GIS, we propose a document evaluation algorithm to share query results among queries. After that, we re-use evaluation history documents, and design a document indexing structure (DIS) to maintain the history documents. Finally, we adopt a cost model-based approach to unify the approaches of using GIS and DIS. The experimental results show that our solution outperforms the previous works using the classic <b>inverted</b> <b>list</b> <b>structure...</b>|$|E
40|$|Abstract—String {{matching}} {{and dynamic}} dictionary matching are significant principles in computer science. These principles require an efficient data structure for accommodating the pattern or patterns to be searched {{for in a}} large given text. Moreover, in the dynamic dictionary matching, the structure is able to insert or delete the individual patterns over time. This research article introduces a new dynamic data <b>structure</b> named <b>inverted</b> <b>lists</b> for both principles. The <b>inverted</b> <b>lists</b> data <b>structure,</b> which {{is derived from the}} inverted index, is implemented by the perfect hashing idea. This structure focuses on the position of characters and provides a hashing table to store the string patterns. The new data structure is more time efficient than traditional structures. Also, this structure is faster to construct and consumes less memory than others...|$|R
40|$|Strings are {{ubiquitous}} in computer systems and hence string processing has attracted extensive research effort from computer scientists in diverse areas. One {{of the most}} important problems in string processing is to efficiently evaluate the similarity between two strings based on a specified similarity measure. String similarity search is a fundamental problem in information retrieval, database cleaning, biological sequence analysis, and more. While a large number of dissimilarity measures on strings have been proposed, edit distance is the most popular choice in a wide spectrum of applications. Existing indexing techniques for similarity search queries based on edit distance, e. g., approximate selection and join queries, rely mostly on n-gram signatures coupled with <b>inverted</b> <b>list</b> <b>structures.</b> These techniques are tailored for specific query types only, and their performance remains unsatisfactory especially in scenarios with strict memory constraints or frequent data updates. In this paper we propose the B ed-tree, a B +-tree based index structure for evaluating all types of similarity queries on edit distance and normalized edit distance. We identify the necessary properties of a mapping from the string space to the integer space for supporting searching and pruning for these queries. Three transformations are proposed that capture different aspects of information inherent in strings, enabling efficient pruning during the search process on the tree. Compared to stateof-the-art methods on string similarity search, the B ed-tree is a complete solution that meets the requirements of all applications, providing high scalability and fast response time...|$|R
40|$|We {{consider}} {{the problem of}} efficiently indexing Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF) Boolean expressions over a high-dimensional multi-valued attribute space. The goal is to rapidly find the set of Boolean expressions that evaluate to true for a given assignment of values to attributes. A {{solution to this problem}} has applications in online advertising (where a Boolean expression represents an advertiser’s user targeting requirements, and an assignment of values to attributes represents the characteristics of a user visiting an online page) and in general any publish/subscribe system (where a Boolean expression represents a subscription, and an assignment of values to attributes represents an event). All existing solutions that we are aware of can only index a specialized sub-set of conjunctive and/or disjunctive expressions, and cannot efficiently handle general DNF and CNF expressions (including NOTs) over multi-valued attributes. In this paper, we present a novel solution based on the <b>inverted</b> <b>list</b> data <b>structure</b> that enables us to index arbitrarily complex DNF and CNF Boolean expressions over multi-valued attributes. An interesting aspect of our solution is that, by virtue of leveraging <b>inverted</b> <b>lists</b> traditionally used for ranked information retrieval, we can efficiently return the top-N matching Boolean expressions. This capability enables emerging applications such as ranked publish/subscribe systems [16], where only the top subscriptions that match an event are desired. For example, in online advertising there is a limit on the number of advertisements that can be shown on a given page and only the “best ” advertisements can be displayed. We have evaluated our proposed technique based on data from an online advertising application, and the results show a dramatic performance improvement over prior techniques. 1...|$|R
40|$|Dataspaces are {{collections}} of heterogeneous and partially unstructured data. Unlike data-integration systems that also offer uniform access to heterogeneous data sources, dataspaces do {{not assume that}} all the semantic relationships between sources are known and specified. Much of the user interaction with dataspaces involves exploring the data, and users {{do not have a}} single schema to which they can pose queries. Consequently, it is important that queries are allowed to specify varying degrees of structure, spanning keyword queries to more structure-aware queries. This paper considers indexing support for queries that combine keywords and structure. We describe several extensions to <b>inverted</b> <b>lists</b> to capture <b>structure</b> when it is present. In particular, our extensions incorporate attribute labels, relationships between data items, hierarchies of schema elements, and synonyms among schema elements. We describe experiments showing that our indexing techniques improve query efficiency by an order of magnitude compared with alternative approaches, and scale well with the size of the data...|$|R
40|$|Search engines {{make use}} of <b>inverted</b> <b>list</b> caching in RAM and dynamic pruning schemes to reduce query {{evaluation}} times. While {{only a small portion}} of lists are processed with dynamic pruning, current systems still store the entire <b>inverted</b> <b>list</b> in cache. In this paper we investigate caching only the pieces of the <b>inverted</b> <b>lists</b> that are actually used to answer a query during dynamic pruning. We examine an LRU cache model, and two recently proposed models. We also introduce a new dynamic pruning scheme for impact- ordered <b>inverted</b> <b>lists...</b>|$|R
40|$|Most file {{organizations}} for on-line econdary key retrieval consist of two subcomponents - a structural file and a data file. The structural file provides, a physical access {{path in the}} data base for each query, so that searches can be restricted to small portions of the data file. The data file contains the data records where information is stored. Hence, the file design problem consists of (1) an efficient design of the structural file, and (2) an allocation of data records in the data file so that a given set of data records can be jointly retrieved at mimimum cost. <b>List</b> <b>structure</b> organizations and clustered organizations are shown to be important structures for secondary key retrieval. This thesis studies the design aspects of the structural and data files for both of the above organizations. The most popular <b>list</b> <b>structure</b> files are the <b>inverted</b> <b>list</b> and the multilist organizations. It is shown that either organization is a special case of {{a new class of}} hybrid list organizations. File elements in this class are characterized by a list length parameter l_th, and a list is stored as an <b>inverted</b> <b>list</b> or as a multilist depending on whether its length is larger than l_th or not. Analytical and simulation results indicate that neither a pure <b>inverted</b> <b>list</b> organization nor a pure multilist organization is normally the best choice for all elements in the class. A new method is also introduced for the structure of combined indices for <b>list</b> <b>structure</b> files. A combined index is created only if its component keys co-occur frequently in the queries. Experimental results show that such combined indices do improve the search performances for both <b>inverted</b> <b>list</b> and multilist organizations. Search methods and physical implementations of clustered organizations are discussed. The balancing of cluster trees is shown to be an important concept. A search model is established to obtain optimal branching ratios for cluster trees. The optimal branching ratio is seen to be dependent on certain statistical characteristics of the data base. The last part of the thesis concerns itself with the arrangement of records in the dataa file. The data records are assigned to blocks in the disk like devices. The goal is to minimize the average number of block accesses in processing the query set in the system. This problem {{turns out to be a}} polynomial complete problem. Heuristic algorithms are therefore used for the record block assignment. Experimental results show that a record organization produced by the heuristic algorithms is more efficient than a random assignment of records to the blocks...|$|R
40|$|Abstract. Inverted indexes are the {{fundamental}} index for information retrieval systems. Due to {{the correlation between}} terms, <b>inverted</b> <b>lists</b> in the index may have substantial overlap and hence redundancy. In this paper, we propose a new approach that reduces the size of <b>inverted</b> <b>lists</b> while retaining time-efficiency. Our solution is based on merging <b>inverted</b> <b>lists</b> that bear high overlap {{to each other and}} manage their content in the resulting condensed index. An efficient algorithm is designed to discover heavily-overlapped <b>inverted</b> <b>lists</b> and construct the condensed index for a given dataset. We demonstrate that our algorithm delivers considerable space saving while incurring little query performance overhead. ...|$|R
30|$|For every label a in {{an input}} data tree T, we {{construct}} an <b>inverted</b> <b>list</b> L_a {{of the data}} nodes with label a ordered by their pre-order appearance in T. Figure 2 a, b shows a data tree and <b>inverted</b> <b>lists</b> of its labels.|$|R
40|$|Sequential {{patterns}} of d-gaps exist pervasively in <b>inverted</b> <b>lists</b> of Web document collection indices {{due to the}} cluster property. In this paper the information of d-gap sequential patterns {{is used as a}} new dimension for improving inverted index compression. We first detect d-gap sequential patterns using a novel data structure, UpDown Tree. Based on the detected patterns, we further substitute each pattern with its pattern Id in the <b>inverted</b> <b>lists</b> that contain it. The resulted <b>inverted</b> <b>lists</b> are then coded with an existing coding scheme. Experiments show that this approach can effectively improve the compression ratio of existing codes...|$|R
5000|$|ADABAS is an <b>inverted</b> <b>list</b> data base, {{with the}} {{following}} characteristics or terminology: ...|$|R
40|$|The <b>inverted</b> <b>lists</b> {{strategy}} is frequently {{used as an}} index data structure for very large textual databases. Its implementation and comparative performance has been studied in sequential and parallel applications. In the latter, with relatively few studies, {{there has been a}} sort of "which-is-better" discussion about two alternative parallel realizations of the basic data structure and algorithms. We suggest that a mix between the two is actually a better alternative. Depending on the workload generated by the users, the composite <b>inverted</b> <b>lists</b> algorithm we propose in this paper can operate either as a local or global <b>inverted</b> <b>list,</b> or both at the same time...|$|R
40|$|Search engines {{make use}} of <b>inverted</b> <b>list</b> caching in RAM and dynamic pruning schemes to reduce query {{evaluation}} times. While {{only a small portion}} of lists are processed with dynamic pruning, current systems still store the entire <b>inverted</b> <b>list</b> in cache. In this paper we investigate caching only the pieces of the <b>inverted</b> <b>lists</b> that are actually used to answer a query during dynamic pruning. We examine an LRU cache model, and two recently proposed models. We also introduce a new dynamic pruning scheme for impactordered <b>inverted</b> <b>lists.</b> Using two large web collections and corresponding query logs we show that, using an LRU cache, our new pruning scheme reduces the number of disk accesses during query processing time by 7 %– 15 % over the state-of-the-art impact-ordered baseline, without reducing answer quality. Surprisingly, however, we discover that using our new pruning scheme makes little difference to disk traffic when the more sophisticated caching schemes are employed...|$|R
40|$|Given a {{collection}} of strings, goal of the approximate string matching is to efficiently find the strings in the collection {{that are similar to}} a query string. In this paper, we focus on edit distance as measure to quantify the similarity between two strings. Existing q-gram based methods to address this problem use inverted indexes to index the q-grams of given string collection. These methods begin by generating the q-grams of query string (disjoint or overlapping) and then merge the <b>inverted</b> <b>lists</b> of these q-grams. Several filtering techniques have been proposed so as to segment <b>inverted</b> <b>lists</b> to relatively shorter lists thus reducing the merging cost. We use a filtering technique which we call as “position restricted alignment " that combines well known length filtering and position filtering to provide more aggressive pruning. We then provide an indexing scheme that integrates the <b>inverted</b> <b>lists</b> storage with the proposed filter thus enabling us to auto-filter the <b>inverted</b> <b>lists.</b> We evaluate the effectiveness of the proposed approach by thorough experimentation. 1...|$|R
5000|$|The {{relation}} [...] "contains" [...] between subsets {{and elements}} can be <b>inverted,</b> <b>listing</b> the subsets each element is contained in.|$|R
40|$|Abstract. We {{study the}} growth of {{epitaxial}} thin films on pre-patterned substrates that influence the surface diffusion of subsequently depositedmaterial using a kineticMonte Carlo algorithm that combines the use of <b>inverted</b> <b>lists</b> with rejection. The result-ing algorithm is well adapted to systems with spatially heterogeneous hopping rates. To evaluate the algorithm’s performance we compare it with an efficient, binary-tree based algorithm. A key finding is that the relative performance of the <b>inverted</b> <b>list</b> algorithm improves with increasing system size...|$|R
40|$|Maintaining strict static score {{order of}} <b>inverted</b> <b>lists</b> is a {{heuristic}} used by search engines {{to improve the}} quality of query results when the entire <b>inverted</b> <b>lists</b> cannot be processed. This heuristic, however, increases the cost of index generation and requires complex index build algorithms. In this paper, we study a new index organization based on static score bucketing. We show that this new technique significantly improves in index build performance while having minimal impact on the quality of search results...|$|R
40|$|Large web {{search engines}} {{have to answer}} {{thousands}} of queries per second with interactive response times. A {{major factor in the}} cost of executing a query is given by the lengths of the <b>inverted</b> <b>lists</b> for the query terms, which increase with the size of the document collection and are often in the range of many megabytes. To address this issue, IR and database researchers have proposed pruning techniques that compute or approximate term-based ranking functions without scanning over the full <b>inverted</b> <b>lists...</b>|$|R
40|$|Abstract — Keyword {{search is}} {{the easiest way to}} access the data in the face of {{information}} explosion. <b>Inverted</b> <b>lists</b> are used to index documents to access those documents according to a set of keywords efficiently. These <b>inverted</b> <b>lists</b> are large in size. So, many compression techniques have been proposed to reduce the storage space and disk I/O time. This paper presents a convenient index structure, which is an extension of the Generalized Inverted Index (GINIX). Ginix merges the consecutive IDs in <b>inverted</b> <b>lists</b> into interval lists and it reduces the size of the inverted index. The new index structure is called Extended Inverted Index (XINIX) which extends the structure of Ginix. The primary objective of Xinix is to minimize the storage cost. Xinix not only reduces the storage cost, but also increase the search performance, compared with traditional inverted indexes...|$|R
40|$|In this work, {{we study}} a novel top-k query type, called top-k,m queries. Suppose {{we are given}} a set of groups and each group {{contains}} a set of attributes, {{each of which is}} associated with a ranked <b>inverted</b> <b>list</b> of tuples, where each tuple contains a tuple ID and a score. All <b>inverted</b> <b>lists</b> are ranked according to the scores of tuples. We are interested in selecting top-k combinations of attributes according to the corresponding top-m match instances of tuples. This problem has a wide rang...|$|R
40|$|Abstract. In this paper, {{we propose}} a new {{technique}} for multidimensional query processing which can be widely applied in database systems. Our new technique, called tree striping, generalizes the well-known <b>inverted</b> <b>lists</b> and multidimensional indexing approaches. A theoretical analysis of our generalized technique shows that both, <b>inverted</b> <b>lists</b> and multidimensional indexing approaches, are far from being optimal. A consequence of our analysis is {{that the use of}} a set of multidimensional indexes provides considerable improvements over one d-dimensional index (multidimensional indexing) or d one-dimensional indexes (<b>inverted</b> <b>lists).</b> The basic idea of tree striping is to use the optimal number k of lower-dimensional indexes determined by our theoretical analysis for efficient query processing. We confirm our theoretical results by an experimental evaluation on large amounts of real and synthetic data. The results show a speed-up of up to 310 % over the multidimensional indexing approach and a speed-up factor of up to 123 (12, 300 %) over the inverted-lists approach. 1...|$|R
40|$|Static index pruning {{methods have}} been {{proposed}} to reduce size of the inverted index of information retrieval systems. The goal is to increase efficiency (in terms of query response time) while preserving effectiveness (in terms of ranking quality). Current state-of-the-art approaches include the term-centric pruning approach and the document-centric pruning approach. While the term-centric pruning considers each <b>inverted</b> <b>list</b> independently and removes less important postings from each <b>inverted</b> <b>list,</b> the document-centric approach considers each document independently and removes less important terms from each document. In other words, the term-centric approach does not consider {{the relative importance of}} a posting in comparison with others in the same document, and the document-centric approach does not consider the relative importance of a posting in comparison with others in the same <b>inverted</b> <b>list.</b> The consequence is less important postings are not pruned in some situations, and important postings are pruned in some other situations. We propose a posting-based pruning approach, which is a generalization of both the term-centric and document-centric approaches. This approach ranks all postings and keeps only a subset of top ranked ones. The rank of a posting depends on several factors, such as its rank in its <b>inverted</b> <b>list,</b> its rank in its document, its weighting score, the term weight and the document weight. The effectiveness of our approach is verified by experiments using TREC queries and TREC datasets...|$|R
30|$|Sublist L_X is the <b>inverted</b> <b>list</b> of data tree nodes that {{participate}} in the occurrences of Q to T. By Proposition 2, X can be computed using L_X' instead of using the corresponding label <b>inverted</b> <b>list.</b> Further, if X {{is the image of}} nodes X_ 1 and X_ 2 defined by the homomorphisms from the left and right parent of Q, respectively, we can compute X using the intersection, L_X_ 1 ∩ L_X_ 2, of L_X_ 1 and L_X_ 2 which is the sublist of L_X_ 1 and L_X_ 2 comprising the nodes that appear in both L_X_ 1 and L_X_ 2.|$|R
40|$|Declining {{disk and}} CPU costs have kindled a renewed {{interest}} in e cient document indexing techniques. In this paper, the problem of incremental updates of <b>inverted</b> <b>lists</b> is addressed using a dual-structure index data structure that dynamically separates long and short <b>inverted</b> <b>lists</b> and optimizes the retrieval, update, and storage of each type of list. The behavior of this index is studied {{with the use of a}} synthetically-generated document collection and a simulation model of the algorithm. The index structure is shown to support rapid insertion of documents, fast queries, and to scale well to large document collections and many disks. ...|$|R
40|$|Several {{methods have}} been {{proposed}} to evaluate queries over a native XML DBMS, where the queries specify both path and keyword constraints. These broadly consist of graph traversal approaches, optimized with auxiliary structures known as structure indexes; and approaches based on information-retrieval style <b>inverted</b> <b>lists.</b> However, no published literature addresses methods of combining <b>structure</b> indexes and <b>inverted</b> <b>lists.</b> We {{bridge this gap by}} proposing a strategy that combines the two forms of auxiliary indexes and a query evaluation algorithm for branching path expressions based on this strategy. Our technique is general and applicable {{for a wide range of}} choices of <b>structure</b> indexes and <b>inverted</b> <b>list</b> join algorithms. Our experiments over a native XML DBMS show the benefit of integrating the two forms of indexes. We also consider algorithmic issues in evaluating path expression queries when the notion of relevance ranking is incorporated. By integrating the above techniques with the Threshold Algorithm proposed by Fagin et al., we obtain instance optimal algorithms to push down top k computation. 1...|$|R
40|$|Abstract—This paper {{proposes a}} new {{solution}} to string matching problem. This solution constructs an <b>inverted</b> <b>list</b> representing a string pattern to be searched for. It then uses a new algorithm to process an input string {{in a single}} pass. The preprocessing phase takes 1) time complexity O(m) 2) space complexity O(1) where m is the length of pattern. The searching phase time complexity takes 1) O(m+α) in average case 2) O(n/m) in the best case and 3) O(n) in the worst case, where α {{is the number of}} comparing leading to mismatch and n is the length of input text. Keywords—String matching, <b>inverted</b> <b>list,</b> <b>inverted</b> index, pattern, algorithm. I. ...|$|R
40|$|We {{consider}} {{the problem of}} how to combine <b>structure</b> indexes and <b>inverted</b> <b>lists</b> to answer queries over a native XML DBMS, where the queries specify both path and keyword constraints. We augment the <b>inverted</b> <b>list</b> entries to integrate them with a given structure index, and present novel algorithms for evaluating branching path expressions. Our experiments show the benefit of integrating the two forms of indexes. We also {{consider the}} problem of evaluating path expression queries with (several alternative) extensions that incorporate relevance ranking. By integrating the above techniques with the Threshold Algorithm proposed by Fagin et al., we obtain instance optimal algorithms to push down top k computation...|$|R
40|$|Wit h the {{proliferation}} of the world’s “information highways” {{a renewed interest in}} efficient document indexing techniques has come about. In this paper, the problem of incremental updates of <b>inverted</b> <b>lists</b> is addressed using a new dualstrncture index. The index dynamically separates long and short <b>inverted</b> <b>lists</b> and optimizes the retrieval, update, and storage of each type of list. To study the behavior of the inclex, a space of engineering trade-offs which range from optimizing update time to optimizing query performance is described. We quantitatively explore this space by using actual data and hardware in combination with a simulation of an information retrieval system. then describe the best algorithm for a variety of criteria. ...|$|R
40|$|With the {{proliferation}} of the world 2 ̆ 7 s "information highways 2 ̆ 72 ̆ 7 {{a renewed interest in}} efficient document indexing techniques has come about. In this paper, the problem of incremental updates of <b>inverted</b> <b>lists</b> is addressed using a new dual-structure index data structure. The index dynamically separates long and short <b>inverted</b> <b>lists</b> and optimizes the retrieval, update, and storage of each type of list. To study the behavior of the index, a space of engineering trade-offs which range from optimizing update time to optimizing query performance is described. We quantitatively explore this space by using actual data and hardware in combination with a simulation of an information retrieval system. We then describe the best algorithm for a variety of criteria...|$|R
40|$|Most {{information}} in science, engineering and {{business has been}} recorded in form of text. This information can be found online in the World-Wide-Web. One of the major tools to support information access are the search engines which usually use information retrieval techniques to rank Web pages based on a simple query and an index <b>structure</b> like the <b>inverted</b> <b>lists.</b> The retrieval models are {{the basis for the}} algorithms that score and rank the Web pages. The focus of this presentation is to show some <b>inverted</b> <b>lists</b> alternatives, based on buckets, for an information retrieval system. The main interest is how query performance is effected by the index organization on a cluster of PCs. The server design is effected on top of the parallel computing model Bul...|$|R
40|$|Compression of <b>inverted</b> <b>lists</b> with {{methods that}} support fast {{intersection}} operations {{is an active}} research topic. Most compression schemes rely on encoding differences between consecutive positions with techniques that favor small numbers. In this paper we explore a completely different alternative: We use Re-Pair compression of those differences. While Re-Pair by itself offers fast decompression at arbitrary positions in main and secondary memory, we introduce variants that in addition speed up the operations required for <b>inverted</b> <b>list</b> intersection. We compare the resulting data structures with several recent proposals under various list intersection algorithms, to conclude that our Re-Pair variants offer an interesting time/space tradeoff for this problem, yet further improvements are required for it to improve upon {{the state of the}} art. ...|$|R
40|$|In this paper, {{we propose}} a novel compact tree (Ctree) for XML indexing, which {{provides}} not only concise path summaries {{at the group}} level but also detailed child-parent links at the element level. Group level mapping allows efficient pruning of a large search space while element level mapping provides fast access to the parent of an element. Due to the tree nature of XML data and queries, such fast child-to-parent access is essential for efficient XML query processing. Using group-based element reference, Ctree enables the clustering of <b>inverted</b> <b>lists</b> according to groups, which provides efficient join between <b>inverted</b> <b>lists</b> and structural index group extents. Our experiments reveal that Ctree is efficient for processing both single-path and branching queries with various value predicates...|$|R
30|$|We present now our {{homomorphic}} tree pattern mining algorithm called HomTreeMiner (Fig. 8). The {{first part}} of the algorithm computes the sets containing all frequent 1 -patterns F_ 1 (i.e., nodes) and 2 -patterns F_ 2 (lines 1 – 2). F_ 1 can be easily obtained by finding <b>inverted</b> <b>lists</b> of T whose size (in terms of number of nodes) is no less than minsup. The total time for this step is O(|T|). F_ 2 is computed by the following procedure: Let X / Y denote a 2 -pattern formed by two elements X and Y of F_ 1. The support of X / Y is computed via algorithm TwigStack on the <b>inverted</b> <b>lists</b> L_lb(X) and L_lb(Y) that are associated with labels lb(X) and lb(Y), respectively. The total time for each 2 -pattern candidate is O(|T|).|$|R
40|$|Abstract — In this paper, {{we focus}} on {{efficient}} keyword query processing for XML data based on SLCA and ELCA semantics. We propose for each keyword a novel form of <b>inverted</b> <b>list,</b> which includes IDs of nodes that directly or indirectly contain the keyword. We propose a family of efficient algorithms {{that are based on}} the set intersection operation for both semantics. We show that the problem of SLCA/ELCA computation becomes finding a set of nodes that appear in all involved <b>inverted</b> <b>lists</b> and satisfy certain conditions. We also propose several optimization techniques to further improve the query processing performance. We have conducted extensive experiments with many alternative methods. The results demonstrate that our proposed methods outperform existing ones by up to two orders of magnitude in many cases. I...|$|R
40|$|In this paper, {{we propose}} a new merge-based index {{maintenance}} strategy for Information Retrieval systems. The new model {{is based on}} partitioning of the inverted index across the terms in it. We exploit the query log to partition the on-disk inverted index into two types of sub-indexes. <b>Inverted</b> <b>lists</b> of the terms contained in the queries that are frequently posed to the Information Retrieval systems are kept in one partition, called frequent-term index and the other <b>inverted</b> <b>lists</b> form another partition, called infrequentterm index. We use a lazy-merge strategy for maintaining infrequent-term sub-indexes, and an active merge strategy for maintaining frequent-term sub-indexes. The sub-indexes are also similarly split into frequent and in-frequent parts. Experimental {{results show that the}} proposed method improves both index maintenance performance and query performance compared to the existing merge-based strategies...|$|R
