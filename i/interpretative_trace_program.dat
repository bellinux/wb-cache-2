0|855|Public
5000|$|... ktrace is {{somewhat}} similar to Linux's strace, except for being much faster with strace, every system call {{executed by the}} <b>traced</b> <b>program</b> requires context switch to the <b>tracing</b> <b>program</b> and back, while the tracing with ktrace is actually performed by the kernel, so no additional context switches are required.|$|R
5000|$|Kerkythea - free ray <b>tracing</b> <b>program</b> with {{enhanced}} Sketchup compatibility ...|$|R
50|$|The Leave No <b>Trace</b> State Advocate <b>Program</b> assists {{interested}} Leave No Trace {{educators and}} volunteers with their local {{effort to promote}} and teach minimum impact outdoor ethics. These active State Advocate volunteers are {{a key part of}} the Leave No <b>Trace</b> <b>program</b> because they coordinate outreach, education and training in their respective states. The State Advocates support volunteers with Leave No Trace training, increase on-the-ground awareness and attend events to further the Leave No <b>Trace</b> <b>program</b> and mission. The State Advocates have been instrumental in building communities of volunteers and educators, state-by-state.|$|R
40|$|Light can be coupled {{out of a}} {{waveguide}} to {{a focused}} point by a focusing grating coupler and has possible applications in optical data storage. The grating can be fabricated with either e-beam techniques or holographic techniques. Two design methods are demonstrated that model the focusing grating coupler with holographic optical elements. Both methods take a geometrical optics approach to designing the holographic optical elements and both methods make use of commercially available ray <b>trace</b> <b>programs.</b> The first method uses complicated non-rotationally symmetric construction optics and requires either a modified ray <b>trace</b> <b>program</b> or special user defined surfaces. The second method involves a much simpler approach which did not require any changes to an existing ray <b>trace</b> <b>program</b> and requires only rotationally symmetric elements to correct the aberrations...|$|R
50|$|RMI is {{a partner}} of the Leave No <b>Trace</b> <b>program</b> of the Center for Outdoor Ethics. Leave No Trace {{partners}} raise awareness of outdoor ethics.|$|R
30|$|Novice {{learners}} {{often fail}} to <b>trace</b> <b>programs</b> step by step because of insufficient understandings of statement sequencing and insufficient ability {{to keep track of}} program state.|$|R
40|$|A {{systematic}} {{performance analysis}} of aplanatic Cassegrainian telescopes {{has been accomplished}} {{by means of a}} ray <b>trace</b> <b>program.</b> The results indicate that the available field angle for a given geometric spot size is, to a very close approximation, a function of the relative back focal distance only. Image curvatures, as computed by third-order theory and by the ray <b>trace</b> <b>program,</b> were found to be in very close agreement. Image curvature is plotted {{as a function of the}} ray height ratio for a wide range of secondary magnification...|$|R
5000|$|YafaRay is a free, {{open source}} ray <b>tracing</b> <b>program</b> that uses an XML scene {{description}} language. It has an addon for the 2.78 {{version of the}} 3D modelling software Blender.|$|R
5000|$|March 21, 2010: Financial Industry Regulatory Authority (FINRA). BBGIDs {{accepted}} to uniquely identify securities reported to its U.S. Securities and Exchange Commission (SEC) mandated Trade Reporting And Compliance Engine (<b>TRACE)</b> <b>program.</b>|$|R
40|$|Abstract—To improve {{software}} dependability, a {{large number}} of software engineering tools have been developed over years. Many of them are difficult to apply in practice because their system and library requirements are incompatible with those of the subject software. We propose a technique called platform independent executable trace. Our technique traces and virtualizes a regular program execution that is platform dependent, and generates a stand-alone <b>program</b> called the <b>trace</b> <b>program.</b> Run-ning the <b>trace</b> <b>program</b> re-generates the original execution. More importantly, <b>trace</b> <b>program</b> execution is completely independent of the underlying operating system and libraries such that it can be compiled and executed on arbitrary platforms. As such, it can be analyzed by a third party tool on a platform preferred by the tool. We have implemented the technique on x 86 and sensor platforms. We show that buggy executions of 10 real-world Windows and sensor applications can be traced and virtualized, and later analyzed by existing Linux tools. We also demonstrate how the technique can be used in cross-platform malware analysis. I...|$|R
40|$|This report {{describes}} {{the design and}} implementation {{of a set of}} tools for capturing and analysing <b>program</b> <b>traces</b> called Logrind 2. The tools are implemented as add-ons to the popular Valgrind and GDB debugging tools. <b>Program</b> <b>traces</b> are captured using dynamic instrumentation and stored in a relational database. Logrind 2 provides support for pretty-printing these traces in a clear and understandable format. The toolset also includes an extended SQL query language that ranges over <b>program</b> <b>traces.</b> Other tools may interface with Logrind 2 using this query language. The <b>program</b> <b>trace</b> schema supports multiple sources and can be used to compare runs of a program. Logrind 2 supports random access navigation of <b>program</b> <b>traces</b> using the concept of a <b>program</b> <b>trace</b> ’cursor’. Users may use this feature to examine the historical state of a process. <b>Program</b> <b>trace</b> capture using Logrind 2 was benchmarked using the BYTEmark benchmark program and the results are described in this report. The report also evaluates the <b>program</b> <b>trace</b> query language with a discussion of possible optimisations. ...|$|R
5000|$|<b>Program</b> <b>trace</b> ... Branch <b>tracing</b> {{compresses}} <b>program</b> execution data, by emitting messages at branch or exception instructions only. Trace analysis reconstructs {{the program}} flow using a local image of code memory contents.|$|R
40|$|We {{present an}} {{effective}} dynamic analysis for finding a broad class of deadlocks, including the well-studied lock-only deadlocks {{as well as}} the less-studied, but no less widespread or insidious, deadlocks involving condition variables. Our analysis consists of two stages. In the first stage, our analysis observes a multi-threaded program execution and generates a simple multi-threaded <b>program,</b> called a <b>trace</b> <b>program,</b> that only records operations observed during the execution that are deemed relevant to finding deadlocks. Such operations include lock acquire and release, wait and notify, thread start and join, and change of values of user-identified synchronization predicates associated with condition variables. In the second stage, our analysis uses an off-the-shelf model checker to explore all possible thread interleavings of the <b>trace</b> <b>program</b> and check if any of them deadlocks. A key advantage of our technique is that it discards most of the program logic which usually causes state-space explosion in model checking, and retains only the relevant synchronization logic in the <b>trace</b> <b>program,</b> which is sufficient for finding deadlocks. We have implemented our analysis for Java, and have applied it to twelve real-world multi-threaded Java programs. Our analysis is effective in practice, finding thirteen previously known as well as four new deadlocks...|$|R
30|$|As {{configured}} by the Driver, Intel PT notifies the Driver via a Performance Monitoring Interrupt (PMI) {{when the}} Trace Buffer becomes overloaded (Step 6 a). The processor pauses the <b>traced</b> <b>program</b> execution and switches to the PMI handler. The PMI handler invokes the Trace Analyzer (Step 6 b).|$|R
40|$|NASA's current {{predictive}} capabilities {{using the}} ray <b>tracing</b> <b>program</b> (RTP) are validated using helicopter noise data taken at Eglin Air Force Base in 2007. By including refractive propagation effects due to wind and temperature, the ray tracing code {{is able to}} explain large variations in the data observed during the flight test...|$|R
40|$|In many {{introductory}} programming courses, {{students are}} urged to <b>trace</b> <b>programs</b> in a textbook {{to see if they}} understand how the programs work. In addition, students may have to <b>trace</b> simple <b>programs</b> on a test (a typical question calls for a display of a program 2 ̆ 7 s output). As a student confronts more and more complex language features, and as examples become more lengthy, the tracing idea seems to fall by the wayside. We expect a student to understand complex programs, but we don 2 ̆ 7 t seem to offer any practical guidance about how this understanding may be achieved...|$|R
40|$|Abstract—we {{reported}} here tasks we accomplished {{to improve the}} 2 D curve tracing algorithm: 1) Optimized individual steps in the <b>tracing</b> <b>program</b> with tools {{from the field of}} digital image processing; 2) Implemented training sets and evaluation conditions that teach the program to look for parameters that fit a wide variety of data quality...|$|R
5000|$|Class 2 adds {{ownership}} <b>trace</b> and <b>program</b> <b>trace</b> {{and allows}} the auxiliary debugging port to be shared with [...] "slow" [...] I/O port pins. Ownership trace allows current task or current process trace for systems based on real-time kernels or operating-systems.|$|R
50|$|<b>Program</b> <b>Trace</b> Query Language (PTQL) is a {{language}} based on relational queries over <b>program</b> <b>traces,</b> in which programmers can write expressive, declarative queries about program behavior.|$|R
40|$|The Alpha Magnetic Spectrometer detects a {{large amount}} of {{particles}} below rigidity cutoff. Those high energy particles create questions related to radiation belts and atmospheric neutrinos. To understand the origin of these particles, we use a trajectory <b>tracing</b> <b>program</b> to simulate particle trajectories in realistic geomagnetic field. The complex behaviors and large e + /e − are explained here. ...|$|R
40|$|We {{study the}} {{relation}} between antenna spacing and capacity of MIMO channels for indoor environments using a ray <b>tracing</b> <b>program.</b> It has been confirmed also by measurements that in rich scattering environments an antenna spacing below 0. 5 lambda is sufficient to reach nearly the full capacity predicted for multiple-antenna arrays in ideal and uncorrelated Rayleigh fading channels...|$|R
50|$|REFUNITE {{was founded}} in 2008 by two Danish brothers, David and Christopher Mikkelsen, after their {{personal}} journey trying to reconnect a young, Afghan refugee with his family. In their search, the two brothers discovered that existing family <b>tracing</b> <b>programs</b> lacked cross-border, collaborative technology {{and the process of}} family tracing was also often tied to cumbersome procedures and paperwork.|$|R
40|$|A {{system is}} {{presented}} for ray tracing trimmed NURBS surfaces. While approaches to components are drawn largely from existing literature, their combination {{within a single}} framework is novel. This paper also differs from prior work in that the details of an efficient implementation are fleshed out. Throughout, {{emphasis is placed on}} practical methods suitable to implementation in general ray <b>tracing</b> <b>programs.</b> 1 Introduction The modeling community has embraced trimmed NURBS as a primitive of choice. The result has been a rapid proliferation in the number of models utilizing this representation. At the same time, ray tracing has become a popular method for generating computer graphics images of geometric models. Surprisingly, most ray <b>tracing</b> <b>programs</b> do not support the direct use of untessellated trimmed NURBS surfaces. The direct use of untessellated NURBS is desirable because tessellated models increase memory use which can be detrimental to runtime efficiency on modern architectures. [...] ...|$|R
40|$|This report {{describes}} {{the generation of}} synthetic stereo image pairs and a cyclopean depth map using the ray <b>tracing</b> <b>program</b> PoVRay. A ray <b>tracing</b> <b>program</b> produces simulated snapshots of a 3 D model, one pixel at a time, by tracing rays backwards from the viewpoint through the image and into the scene. If a ray strikes an object in the scene, the image pixel through which it passed is painted with the colour of that object; otherwise, the image pixel is painted with the colour of the background. By offsetting the viewpoint {{to the left and}} right of a central position, it’s possible to generate stereo image pairs. These can be combined with a central depth view, in which pixel intensity is proportional to distance from the viewpoint, by adding fog to the environment. Since the three views are rendered with the same perspective projection, they are in perfect correspondence...|$|R
40|$|A {{system is}} {{presented}} for ray tracing trimmed NURBS surfaces. While approaches to components are drawn largely from existing literature, their combination {{within a single}} framework is novel. This paper also differs from prior work in that the details of an efficient implementation are fleshed out. Throughout, {{emphasis is placed on}} practical methods suitable to implementation in general ray <b>tracing</b> <b>programs.</b> ...|$|R
40|$|In this work, we {{have created}} a {{realistic}} model of a solar tracker using Mayavi: 3 D scientific data visualization and plotting in Python, Enthought Canopy:a comprehensive Python analysis environment and Persistence of Vision Ray Tracer, or POV-Ray, a ray <b>tracing</b> <b>program</b> which generates photo-realistic images from a text-based scene description, {{a model of the}} solar tracker was also 3 D printed...|$|R
30|$|A 1. The student {{consumed}} {{sufficient time}} (more than 3  min) <b>tracing</b> the <b>program</b> (Ex 1).|$|R
40|$|The optical {{characteristics}} of a paraboloidal solar concentrator are analyzed using the intercept factor curve (a format for image data) to describe {{the results of a}} mathematical model and to represent reduced data from experimental testing. This procedure makes it possible not only to test an assembled concentrator, but also to evaluate single optical panels or to conduct non-solar tests of an assembled concentrator. The use of three-dimensional ray <b>tracing</b> computer <b>programs</b> to calculate the mathematical model is described. These ray <b>tracing</b> <b>programs</b> can include any type of optical configuration from simple paraboloids to array of spherical facets and can be adapted to microcomputers or larger computers, which can graphically display real-time comparison of calculated and measured data...|$|R
50|$|During the 1980s, NOLS {{continued}} to evolve. NOLS partnered with the University of Utah to offer college credit for courses, and {{helped create the}} U.S. Leave No <b>Trace</b> <b>program.</b> In 1989, NOLS adopted an outcome-based education model. In 1999, NOLS acquired the Wilderness Medicine Institute, one of the nation's foremost trainers of wilderness medicine. NOLS also began to offer professional training to corporate and institutional clients, including NASA.|$|R
40|$|We {{designed}} and implemented a traffic accident analysis system (TAAS) in the paper. TAAS {{is the system}} faced traffic accident analysis, which uses the traffic rules (law) as knowledge sources to judge if the driver is responsible for a traffic accident. TAAS has characteristics of separating knowledge base and inference engine, using production rule and backward chaining. Besides, TAAS used predefined text and <b>tracing</b> <b>program</b> to realize explanation mechanism. <br /...|$|R
40|$|The paper {{deals with}} the {{detailed}} description of the Italian educational policy-making post Second World War and draws some <b>interpretative</b> <b>traces</b> concerning the two-way connection between the hegemonic governance settlements and the discursive frames influencing the education policy-making and its change. Adopting the interpretative tools of the critical policy historiography and the critical discourse approaches, the work interprets the recent trajectory of the Italian education system identifying two different political eras, namely the era of the welfarist education state and the (re) building of the nation and the era of the restructuring of education, between managerialism, decentralisation and a tentative neoliberalism. Through the analysis of policy texts, literature and previous researches, the article sketches the education debate in Italy during the last sixty-five years, its dynamics, controversies and contradictions, and the shifting of the organisational and governance settlements. After the welfarist era, where the alliance between the bureaucratic and professional discourses dominated the Italian educational landscape, straddling the new millennium, some hints of the entering of a neoliberal discourse are recognisable. The Italian system could be described as messy and still evolving and the war of discourses witnesses educational governance settlements still hybridising and confronting each other...|$|R
40|$|Abstract This paper {{presents}} TORNADO, {{a unique}} input replay tool based on system call replay. It {{is capable of}} <b>tracing</b> <b>program</b> executions with an acceptable overhead of less than a factor 2. It is fully operational for the Linux operating system. The tool requires no instrumentation, recompilation or relinking of the applications. This paper also presents a new technique capable of tracing write operations performed by the OS kernel to user space. ...|$|R
40|$|AbstractWe study {{recognition}} ability {{of humans and}} line <b>trace</b> <b>programs</b> in order to construct a reverse Turing test based on one-stroke symbol traces. Our aim is to analyze the difference between humans and computers {{from the point of}} view of recognizing distorted and nicked character images. We carry out experiments to show it is tractable for humans to recognize and trace a one- stroke character or symbol, but intractable for computer programs...|$|R
40|$|Goal of {{this work}} is to write an {{optimized}} program for visualization of 3 D scenes using ray tracing method. First, the theory of ray tracing together with particular techniques are presented. Next part focuses on different approaches to accelerate the algorithm. These are space partitioning structures, fast ray-triangle intersection technique and possibilities to parallelize the whole ray tracing method. A standalone chapter addresses the design {{and implementation of the}} ray <b>tracing</b> <b>program...</b>|$|R
25|$|Usually, {{the most}} {{difficult}} part of debugging is finding the bug. Once it is found, correcting it is usually relatively easy. Programs known as debuggers help programmers locate bugs by executing code line by line, watching variable values, and other features to observe program behavior. Without a debugger, code may be added so that messages or values may be written to a console or to a window or log file to <b>trace</b> <b>program</b> execution or show values.|$|R
40|$|An address trap (breakpoint) {{mechanism}} and last-in-first-out (LIFO) address stack are suggested as two {{additions to the}} basic microprocessor architecture whose functions are solely to aid the programmer. These devices provide the programmer {{with the ability to}} specify address breakpoints and to <b>trace</b> <b>program</b> execution back through N instructions, where N is the depth of the stack. Both devices, plus interface logic and buffering, have been designed for an INTEL 8080 -based system using approximately 25 integrated-circuit packages...|$|R
