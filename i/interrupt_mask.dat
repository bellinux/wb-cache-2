14|33|Public
50|$|Processors {{typically}} have an internal <b>interrupt</b> <b>mask</b> which allows software to ignore all external hardware interrupts {{while it is}} set. Setting or clearing this mask may be faster than accessing an <b>interrupt</b> <b>mask</b> register (IMR) in a PIC or disabling interrupts in the device itself. In some cases, such as the x86 architecture, disabling and enabling interrupts on the processor itself act as a memory barrier; however, it may actually be slower.|$|E
5000|$|Maskable {{interrupt}} (IRQ): {{a hardware}} interrupt {{that may be}} ignored by setting a bit in an <b>interrupt</b> <b>mask</b> register's (IMR) bit-mask.|$|E
50|$|The 8085 has {{extensions}} {{to support}} new interrupts, with three maskable vectored interrupts (RST 7.5, RST 6.5 and RST 5.5), one non-maskable interrupt (TRAP), and one externally serviced interrupt (INTR). Each {{of these five}} interrupts has a separate pin on the processor, a feature which permits simple systems to avoid {{the cost of a}} separate interrupt controller. The RST 7.5 interrupt is edge triggered (latched), while RST 5.5 and 6.5 are level-sensitive. All interrupts are enabled by the EI instruction and disabled by the DI instruction. In addition, the SIM (Set <b>Interrupt</b> <b>Mask)</b> and RIM (Read <b>Interrupt</b> <b>Mask)</b> instructions, the only instructions of the 8085 that are not from the 8080 design, allow each of the three maskable RST interrupts to be individually masked. All three are masked after a normal CPU reset. SIM and RIM also allow the global <b>interrupt</b> <b>mask</b> state and the three independent RST <b>interrupt</b> <b>mask</b> states to be read, the pending-interrupt states of those same three interrupts to be read, the RST 7.5 trigger-latch flip-flop to be reset (cancelling the pending interrupt without servicing it), and serial data to be sent and received via the SOD and SID pins, respectively, all under program control and independently of each other.|$|E
5000|$|Extended PSW Mode {{that enables}} {{additional}} <b>interrupt</b> <b>masking</b> and additional control registers ...|$|R
5000|$|... <b>interrupt</b> <b>masks,</b> which protect {{access to}} global {{resources}} (critical section) on uniprocessor systems; ...|$|R
50|$|Optional {{features}} in MSI (64-bit addressing and <b>interrupt</b> <b>masking)</b> are also mandatory with MSI-X.|$|R
50|$|In {{processor}} states P1 and P2, 16 GPRs were available; in State P3, 6 GPRs were available, {{while in}} State P4, 5 GPRs were available. An interrupt status register and <b>interrupt</b> <b>mask</b> register were provided {{in each of}} the four processor states. The one set of floating-point registers was available to all processor states.|$|E
50|$|There {{are three}} registers, an <b>Interrupt</b> <b>Mask</b> Register (IMR), an Interrupt Request Register (IRR), and an In-Service Register (ISR). The IRR {{maintains}} {{a mask of}} the current interrupts that are pending acknowledgement, the ISR maintains a mask of the interrupts that are pending an EOI, and the IMR maintains a mask of interrupts {{that should not be}} sent an acknowledgement.|$|E
50|$|PICs {{typically}} {{have a common}} set of registers: Interrupt Request Register (IRR), In-Service Register (ISR), <b>Interrupt</b> <b>Mask</b> Register (IMR). The IRR specifies which interrupts are pending acknowledgement, and is typically a symbolic register which can not be directly accessed. The ISR register specifies which interrupts have been acknowledged, but are still waiting for an End Of Interrupt (EOI). The IMR specifies which interrupts are to be ignored and not acknowledged. A simple register schema such as this allows up to two distinct interrupt requests to be outstanding at one time, one waiting for acknowledgement, and one waiting for EOI.|$|E
50|$|These {{commands}} set the <b>interrupt</b> <b>masks,</b> while returning {{their previous}} contents. This returned information, {{can then be}} used with the splx routine to change the masks back.|$|R
50|$|In computing, {{interrupt}} latency is {{the time}} that elapses from when an interrupt is generated to when {{the source of the}} interrupt is serviced. For many operating systems, devices are serviced as soon as the device's interrupt handler is executed. Interrupt latency may be affected by microprocessor design, <b>interrupt</b> controllers, <b>interrupt</b> <b>masking,</b> and the operating system's (OS) interrupt handling methods.|$|R
5000|$|... "The naming {{goes back}} to the early days of UNIX on the PDP-11. The PDP-11 had a {{relatively}} simplistic level-based interrupt structure. When running at a specific level, only higher priority interrupts were allowed. UNIX named functions for setting the interrupt priority level after the PDP-11 SPL instruction, so initially the functions had names like spl4 and spl7. Later machines came out with <b>interrupt</b> <b>masks,</b> and BSD changed the names to more descriptive names such as splbio (for block I/O) and splhigh (block out all interrupts)." ...|$|R
50|$|What {{causes the}} bug {{is not an}} <b>interrupt</b> <b>mask,</b> nor are {{interrupts}} being explicitly disabled. Instead, an anomaly in the Cyrix's instruction pipeline prevents interrupts from being serviced {{for the duration of}} the loop; since the loop never ends, interrupts will never be serviced. The xchg instruction is atomic, meaning that other instructions are not allowed to change the state of the system while it is executed. In order to ensure this atomicity, the designers at Cyrix made the xchg uninterruptible. However, because of pipelining and branch predicting, another xchg enters the pipeline before the previous one completes, leaving the processor in this uninterruptible state forever.|$|E
50|$|Until {{the release}} of the 386, {{protected}} mode did not offer a direct method to switch back into real mode once protected mode was entered. IBM devised a workaround (implemented in the IBM AT) which involved resetting the CPU via the keyboard controller and saving the system registers, stack pointer and often the <b>interrupt</b> <b>mask</b> in the real-time clock chip's RAM. This allowed the BIOS to restore the CPU to a similar state and begin executing code before the reset. Later, a triple fault was used to reset the 286 CPU, which was a lot faster and cleaner than the keyboard controller method (and does not depend on IBM AT-compatible hardware, but will work on any 80286 CPU in any system).|$|E
50|$|An Interrupt Request Level (IRQL) is a {{hardware}} independent means with which Windows prioritizes interrupts {{that come from}} the system's processors. On processor architectures which Windows runs on, hardware generates signals which are sent to an interrupt controller. The interrupt controller sends an interrupt request (or IRQ) to the CPU with a certain priority level, and the CPU sets a mask which causes any other interrupts with a lower priority {{to be put into}} a pending state, until the CPU releases control back to the interrupt controller. If a signal comes in at a higher priority, then the current interrupt will be put into a pending state, the CPU sets the <b>interrupt</b> <b>mask</b> to the priority and places any interrupts with a lower priority into a pending state until the CPU finishes handling the new, higher priority interrupt.|$|E
5000|$|Software may use {{the full}} {{subroutine}} stack depth; <b>interrupts</b> are <b>masked</b> while the stack is full, and will be taken {{as soon as a}} return instruction is executed.|$|R
5000|$|The {{traditional}} form of {{interrupt handler}} is the hardware interrupt handler. Hardware interrupts arise from electrical conditions or low-level protocols implemented in digital logic, are usually dispatched via a hard-coded table of interrupt vectors, asynchronously {{to the normal}} execution stream (as <b>interrupt</b> <b>masking</b> levels permit), often using a separate stack, and automatically entering into a different execution context (privilege level) {{for the duration of}} the interrupt handler's execution. In general, hardware interrupts and their handlers are used to handle high-priority conditions that require the interruption of the current code the processor is executing.|$|R
50|$|On single-processor systems, an {{application}} running in kernel mode and <b>masking</b> <b>interrupts</b> {{is the lowest}} overhead method to prevent simultaneous access to a shared resource. While <b>interrupts</b> are <b>masked</b> and the current task {{does not make a}} blocking OS call, the current task has exclusive use of the CPU since no other task or interrupt can take control, so the critical section is protected. When the task exits its critical section, it must unmask interrupts; pending interrupts, if any, will then execute. Temporarily <b>masking</b> <b>interrupts</b> should only be done when the longest path through the critical section is shorter than the desired maximum interrupt latency. Typically this method of protection is used only when the critical section is just a few instructions and contains no loops. This method is ideal for protecting hardware bit-mapped registers when the bits are controlled by different tasks.|$|R
40|$|In {{this paper}} we {{describe}} a new, low-overhead technique for manipulating processor interrupt state in an operating system kernel. Both uniprocessor and multiprocessor operating systems protect against uniprocessor deadlock and data corruption by selectively {{enabling and disabling}} interrupts during critical sections. This happens frequently during latency-critical activities such as IPC, scheduling, and memory management. Unfortunately, the cycle cost of modifying the <b>interrupt</b> <b>mask</b> has increased by {{an order of magnitude}} in recent processor architectures. In this paper we describe optimistic interrupt protection, a technique which substantially reduces the cost of interrupt masking by optimizing mask manipulation for the common case of no interrupts. We present results for the Mach 3. 0 microkernel operating system, although the technique is applicable to other kernel architectures, both micro and monolithic, that rely on interrupts to manage devices. 1 Introduction This paper describes [...] ...|$|E
40|$|This {{position}} paper states our new approach of implementing low-level OS components, especially device drivers. We introduce {{the notion of}} concurrent objects into low-level system programming. A device driver for every hardware device is implemented as independent concurrent objects. A device driver object has a single thread of control, so that mutual exclusion operations such as spl and semaphores are not necessary. Mechanisms of synchronization, object scheduling, and <b>interrupt</b> <b>mask</b> handling are clearly separated from actual device control programs, and these are implemented by the system for device driver objects. By these methods, low-level OS components can be made flexible and executed safely, with practical performance. 1 Introduction In these days, highly distributed and heterogeneous computing are coming into reality. This {{is driven by the}} trends of building Information Super Highway. Particularly, VOD (Video on Demand) services using continuousmedia servers and settop-boxes [...] ...|$|E
40|$|This paper {{proposes a}} new {{approach}} of implementing low-level OS components, especially device drivers. We introduce the notion of concurrent objects into device driver programming. A device driver for every hardware device is implemented as independent concurrent objects. A device driver object has a single thread of control, so that mutual exclusion operations such as spl and semaphores are not necessary. Mechanisms of synchronization, scheduling objects, and <b>interrupt</b> <b>mask</b> handling are clearly separated from actual device control programs, and these are implemented by the system for device driver objects. Both an interrupt and a service request to a device driver object will be delivered as a message, so programmers need not to distinguish {{these two types of}} invocation requests. Therefore, programmers can concentrate on writing the actual device control codes without writing auxiliary codes for synchronization, and the codes will be executed much safer. We show our implementation on [...] ...|$|E
40|$|A DMA Controller can offload a {{processor}} tremendously. A memory copy operation can be {{initiated by the}} processor and while the processor executes others tasks the memory copy can be fulfilled by the DMA Controller. An implementation of a DMA Controller for use in LEON 3 SoC:s has been made during this master thesis. Problems that occurred while designing a controller of this type concerned AMBA buses, data transfers, alignment and interrupt handling. The DMA Controller supports AMBA and is attached to an AHB master and APB slave. The DMA Controller supports burst transfers to maximize data bandwidth. The source and destination address can be arbitrarily aligned. It supports multiple channels and it has interrupt generation on transfer completion along with <b>interrupt</b> <b>masking.</b> The implemented functionality works as intended. ...|$|R
50|$|There are {{hardware-based}} and software-based {{approaches to}} the problem. For example, FreeBSD detects <b>interrupt</b> storms and <b>masks</b> problematic <b>interrupts</b> for some time in response.|$|R
40|$|Operating systems {{should be}} made {{flexible}} from their low-level system structures, {{to enable them to}} adapt to dynamic changes of the outer world. This paper proposes a methodology for making device drivers completely re-configurable, by introducing objectoriented reflective programming into the low-level system structures of operating systems. We introduce concurrent objects and continuations as a basic framework for low-level system object programming. Under our framework, it is possible to write device driver code without managing the <b>interrupt</b> <b>masks,</b> and to eliminate the burden of synchronization codes from low-level system objects. We discuss the important design issues that are needed to introduce object-oriented reflective programming into the lowlevel structures of operating systems, where critical timing constraints must be maintained. Finally, we present the implementation of our methodology on our Apertos operating system and demonstrate its efficiency through our preliminary [...] ...|$|R
40|$|Some {{computers}} {{provide an}} instruction {{to find the}} index of a 1 in a computer word, but many do not. This paper provides a fast and novel algorithm based on de Bruijn sequences to solve this problem. The algorithm involves {{little more than an}} integer multiply and a lookup in a small table. We compare the performance of our algorithm with other popular strategies that use table lookups or floating-point conversion. 1 Introduction Many applications that use one-word bit vectors require the ability to find the binary index of a 1 in a word. For example, some computers set a bit in an <b>interrupt</b> <b>mask</b> when an interrupt occurs, and the interrupt handler must determine which bit is set in order to properly vector the interrupt. Many chess programs represent the pieces of a given type as a 64 -bit word, each bit of which indicates {{the presence or absence of}} the piece type on a particular square of the chessboard [5]. To determine which square a piece occupies as a row/column index, the inde [...] ...|$|E
40|$|BACKGROUND: Rates {{of fresh}} gas flow (FGF) {{commonly}} used when continuous positive airway pressure (CPAP) is delivered by face mask theoretically reduce the delivery {{and availability of}} therapeutic aerosols. As it may be hazardous for patients with acute respiratory failure to <b>interrupt</b> <b>mask</b> CPAP, the effects of CPAP on aerosol kinetics and bronchodilator efficacy were investigated. METHOD: The effect of CPAP at 10 cm H 2 O at a FGF rate of 50 l/min on the delivery of technetium labelled aerosol generated from a readily available jet nebuliser was measured using a bench model of spontaneous respiration. In a separate clinical study the bronchodilator responses to incremental doses of nebulised salbutamol were measured in nine stable asthmatic subjects in a random sequence of conventional nebulisation (control) or nebulisation whilst receiving CPAP via a tight fitting face mask. Each patient acted as {{his or her own}} control. RESULTS: CPAP significantly reduced total aerosol delivery to the face mask from 6. 85 (1. 52) % to 1. 3 (0. 37) % of the initial nebuliser charge. In the clinical study a significant bronchodilator response to nebulised salbutamol was seen during both conventional nebulisation and nebulisation whilst receiving CPAP by face mask. The shape of the dose-response curves and the magnitude of the total increase in the forced expiratory volume in one second (FEV 1) was identical for CPAP and control conditions. CONCLUSIONS: Despite a reduction in aerosol presented to the proximal airway, the bronchodilator response to inhaled beta 2 agonists in stable asthmatic subjects was not affected when CPAP was delivered by face mask. Despite a high rate of FGF, nebulised beta 2 agonists are effective when administered in conjunction with CPAP delivered by face mask. ...|$|E
50|$|This novel {{begins with}} the Back-to-Africa rally, which is run by Reverend Deke O’Malley. The rally is <b>interrupted</b> by <b>masked</b> white hijackers who come armed to steal the {{collected}} money, which amounts to $87,000. A large amount of shooting occurs and one man is killed as the hijackers make their getaway with the money in a large truck.|$|R
50|$|FLIHs cause jitter {{in process}} execution. FLIHs also <b>mask</b> <b>interrupts.</b> Reducing the jitter is most {{important}} for real-time operating systems, since they must maintain a guarantee that execution of specific code will complete within an agreed amount of time.To reduce jitter and to reduce the potential for losing data from <b>masked</b> <b>interrupts,</b> programmers attempt to minimize the execution time of a FLIH, moving {{as much as possible}} to the SLIH. With the speed of modern computers, FLIHs may implement all device and platform-dependent handling, and use a SLIH for further platform-independent long-lived handling.|$|R
40|$|Uses <b>interrupt</b> <b>masks</b> {{to protect}} access to global {{resources}} on uniprocessor systems (by raising or lowering IRQLs). Uses spinlocks on multiprocessor systems. Provides dispatcher objects which may act as mutexes and semaphores. Dispatcher objects may also provide events. An event acts {{much like a}} condition variable. 4 Linux Synchronization Kernel disables interrupts for synchronizing access to global data on uniprocessor systems. Uses spinlocks for multiprocessor synchronization. Uses semaphores and readers-writers locks when longer sections of code need access to data. Implements POSIX synchronization primitives to support multitasking, multithreading (including real-time threads), and multiprocessing. 5 High-IRQL Synchronization Synchronization on MP systems use spinlocks to coordinate among the processors Spinlock acquisition and release routines implement a one-owner-at-a-time algorithm A spinlock is either free, or {{is considered to be}} owned by a CPU Analogous to using Windows API mutexes from user mode A spinlock is just a data cell in memory Accessed with a test-and-set operation that is atomic across all processors 31 KSPIN_LOCK is an opaque data type, typedef‟d as a ULONG To implement synchronization, a single bit is sufficien...|$|R
50|$|Her new job is <b>interrupted</b> when <b>masked</b> {{prostitutes in}} Hoodtown are found not only murdered, but left unmasked, which {{is every bit}} as horrible in itself as death; a great dishonor. X then becomes a self-taught private eye searching for the killer since the police, who do not reside in Hoodtown, and like most maskless people in this novel's society, spit upon masked folks as members of the lowest caste, are nonchalant about finding the murderer.|$|R
5000|$|The Puppet Party (Dukkepartiet) is a {{political}} protest party in Denmark. The party was formed in April 2014. It declared its mission as “to exhibit the emptiness and thereby restarting democracy.” The party members have taken part in protests in rubber <b>masks,</b> <b>interrupting</b> Parliament sessions.|$|R
50|$|Rimgale and Brian go to Swayzak's home {{to confront}} him, but <b>interrupt</b> a <b>masked</b> man about {{to set the}} place alight. The latter attacks them with a flashlight, but is burned by an {{electrical}} socket on his back. Rimgale saves Brian and Swayzak from the house, but is injured in an explosion. In his hospital bed, Rimgale tells Brian to visit Ronald again. Ronald helps Brian realize that only a firefighter would be so careful as to not let the backdraft fires rage out of control.|$|R
5000|$|Even in a CPU which {{supports}} nested interrupts, a handler is often reached with all <b>interrupts</b> globally <b>masked</b> by a CPU hardware operation. In this architecture, an interrupt handler would normally save the smallest amount of context necessary, and then reset the global interrupt disable flag {{at the first}} opportunity, to permit higher priority interrupts to interrupt the current handler. It is also important for the interrupt handler to quell the current interrupt source by some method (often toggling a flag bit of some kind in a peripheral register) so that the current interrupt isn't immediately repeated on handler exit, resulting in an infinite loop.|$|R
30|$|Secure {{touch screen}} and display {{controller}} reconfiguration. When a user intends to type in an IME soft keyboard, some reconfiguration {{should be done}} for the STIE initialization. We reconfigure Interrupt Security Register(ICDISR), Priority Mask Register (ICCPMR) and Enable Set Register (ICDISER) to make the touch input as a secure <b>interrupt</b> and <b>mask</b> all non-secure intterupt. In CPU Interface Control Register (ICCICR), FIQEn, EnableS are set to 1 to enable FIQ interrupt. FIQ bit in Secure Configuration Register (SCR) is also set to 1 to ensure FIQ interrupt routing to TrustZone monitor mode. Besides, touch screen and display controller are set to be secure peripherals with TZPC. As a proof-of-concept prototype, we only implement single-touch in the separate touch driver and leave multi-touch as a future work.|$|R
50|$|When {{the shared}} {{resource}} must be reserved without blocking all other tasks (such as waiting for Flash memory to be written), {{it is better}} to use mechanisms also available on general-purpose operating systems, such as semaphores and OS-supervised interprocess messaging. Such mechanisms involve system calls, and usually invoke the OS's dispatcher code on exit, so they typically take hundreds of CPU instructions to execute, while <b>masking</b> <b>interrupts</b> may take as few as one instruction on some processors.|$|R
5000|$|Several seasons {{after the}} death of Cluny, Matthias and Cornflower had a son, Mattimeo. But one night, as the Redwallers were celebrating, they were <b>interrupted</b> by the <b>masked</b> fox, Slagar the Cruel, who was {{previously}} known as Chickenhound, who entered Redwall with a band of rodents, drugged everyone and kidnapped all of their children. Matthias, Basil Stag Hare and Jess headed out to save them, gaining new and old allies along the way, such as Orlando the Axe, the Guosim shrews, and the [...] "Sparra".|$|R
