1249|2764|Public
25|$|Jet 3.0 {{included}} many enhancements, {{including a new}} <b>index</b> <b>structure</b> that reduced storage size and the time that was taken to create indices that were highly duplicated, the removal of read locks on index pages, a new mechanism for page reuse, a new compacting method for which compacting the database resulted in the indices being stored in a clustered-index format, a new page allocation mechanism to improve Jet's read-ahead capabilities, improved delete operations that speeded processing, multithreading (three threads were used to perform read ahead, write behind, and cache maintenance), implicit transactions (users {{did not have to}} instruct the engine to start manually and commit transactions to the database), a new sort engine, long values (such as memos or binary data types) were stored in separate tables, and dynamic buffering (whereby Jet's cache was dynamically allocated at start up and had no limit and which changed from a first in, first out (FIFO) buffer replacement policy to a least recently used (LRU) buffer replacement policy). Jet 3.0 also allowed for database replication.|$|E
50|$|In {{computer}} science, the Bx tree is a query {{and update}} efficient B+ tree-based <b>index</b> <b>structure</b> for moving objects.|$|E
5000|$|The Data Definition Language (DDL) manages {{table and}} <b>index</b> <b>structure.</b> The most basic items of DDL are the , , , [...] and [...] statements: ...|$|E
40|$|Abstract—Out of {{different}} spatial <b>indexing</b> <b>structures</b> available for accessing spatial data, {{none of them}} is suitable for high dimensions. This is because {{the performance of the}} spatial <b>indexing</b> <b>structures</b> become poorer with the increase in dimension. Thus {{there is a need for}} a better spatial <b>indexing</b> <b>structure</b> for the same. Here we have proposed a hybrid <b>indexing</b> <b>structure</b> by combining the Quad Tree and X Tree. We have considered the X Tree over R Tree used in the previous hybrid <b>indexing</b> <b>structure,</b> QR Tree. This is due to the better performance of X Tree over the R Tree in case of highly overlapped data. Keywords-Spatial indexing, Hybrid spatial indexing, Quad tree, X tree, R Tree, QR Tree, QX Tree...|$|R
40|$|We {{introduce}} two new hash-based <b>index</b> <b>structures</b> to <b>index</b> set-valued attributes. Both {{are able}} to support subset and superset queries. Analytical cost models for the new <b>index</b> <b>structures</b> {{as well as for}} the two existing <b>index</b> <b>structures,</b> sequential signature file and Russian Doll Tree, are presented and experimentally validated. Using the validated cost model, we express the performance of all four <b>index</b> <b>structures</b> in terms of the performance of the sequential signature file. This allows a direct analytical comparison of their performance. Last, we report on our benchmark results comparing the real performance of all four <b>index</b> <b>structures.</b> We especially investigate their performance for skewed data. 1 Introduction Since the invention of database management systems, tremendous effort has been undertaken in order to invent <b>index</b> <b>structures.</b> Historically this work was mostly carried out in the context of relational databases. The impressive results comprise very versatile index s [...] ...|$|R
40|$|Abstract — We {{discuss a}} new {{efficient}} out-of-core multidimensional <b>indexing</b> <b>structure,</b> information-aware 2 n-tree, for indexing very large multidimensional volumetric data. Building {{a series of}} (n- 1) -Dimensional <b>indexing</b> <b>structures</b> on n-Dimensional data causes a scalability problem in the situation of continually growing resolution in every dimension. However, building a single n-Dimensional <b>indexing</b> <b>structure</b> can cause an indexing effectiveness problem compared to the former case. The informationaware 2 n-tree {{is an effort to}} maximize the <b>indexing</b> <b>structure</b> efficiency by ensuring that the subdivision of space have as similar coherence as possible along each dimension. It is particularly useful when data distribution along each dimension constantly shows a different degree of coherence from each other dimension. Our preliminary results show that our new tree can achieve higher <b>indexing</b> <b>structure</b> efficiency than previous methods. I...|$|R
5000|$|LaJolla Structural {{alignment}} of RNA and proteins using an <b>index</b> <b>structure</b> for fast {{alignment of}} thousands of structures. Including an easy to use command line interface. Open source at Sourceforge.|$|E
50|$|Metadata in {{a museum}} context is the {{information}} that trained cultural documentation specialists, such as archivists, librarians, museum registrars and curators, create to <b>index,</b> <b>structure,</b> describe, identify, or otherwise specify works of art, architecture, cultural objects and their images. Descriptive metadata is most commonly used in museum contexts for object identification and resource recovery purposes.|$|E
5000|$|... with t {{the moment}} of calculation; Cap the free float market cap of a {{specific}} listing and J a coefficient used to adjust the index {{on the back of}} capital increases or other corporate actions so as to ensure continuity. The formula can be adjusted to accommodate changes in <b>index</b> <b>structure,</b> such as the temporary suspension of companies pending news.|$|E
40|$|Data {{warehouses}} {{are used}} to store large amounts of data. This data is often used for On-Line Analytical Processing (OLAP). Short response times are essential for on-line decision support. Common approaches to reach this goal in read-mostly environments are the precomputation of materialized views {{and the use of}} <b>index</b> <b>structures.</b> In this paper, a framework is presented to evaluate different <b>index</b> <b>structures</b> analytically depending on nine parameters for the use in a data warehouse environment. The framework is applied to four different <b>index</b> <b>structures</b> to evaluate which structure works best for range queries. We show that all parameters influence the performance. Additionally, we show why bitmap <b>index</b> <b>structures</b> use modern disks better than traditional tree structures and why bitmaps will supplant the tree based <b>index</b> <b>structures</b> in the future. 1 Introduction Data warehouse and OLAP applications differ very much from the traditional database applications. Traditional da [...] ...|$|R
40|$|In {{the last}} few years, the {{increase}} of online video has challenged {{research in the field}} of video information retrieval. Video search engines have become common on the Internet and require the use of powerful tools for fast access to data. However the representation of multimedia data as video shot or keyframe with visual features requires the use of a multidimensional space and <b>indexing</b> <b>structures</b> face the well known ``curse of dimensionality". In this paper, we propose a new <b>indexing</b> <b>structure</b> that combines a clustering algorithm using random projections and a recursive multidimensional <b>indexing</b> <b>structure.</b> In our experiments, we study the effeciency and the effectiveness of our <b>indexing</b> <b>structure</b> using visual features of video shots of TRECVID database. We compare our proposed structure with other state-of-the-art methods...|$|R
40|$|Scoring {{models that}} {{make use of}} {{proximity}} information usually improve result quality in text retrieval. Considering that <b>index</b> <b>structures</b> carrying proximity information can grow huge in size {{if they are not}} pruned, it is helpful to tune indexes towards space requirements and retrieval quality. This paper elaborates on our approach used for INEX 2009 to tune <b>index</b> <b>structures</b> for different choices of result size k. To allow for comparison as to retrieval quality with non-pruned <b>index</b> <b>structures,</b> we also depict our results from the Adhoc Track...|$|R
50|$|A T-tree is a {{balanced}} index tree data structure optimized for caseswhere both the index {{and the actual}} data are fully kept in memory,just as a B-tree is an <b>index</b> <b>structure</b> optimized for storage on blockoriented secondary storage devices like hard disks. T-trees seek to gain the performance benefitsof in-memory tree structures such as AVL trees while avoiding the large storage space overhead whichis common to them.|$|E
5000|$|When {{used in a}} database, the {{structure}} of geohashed data has two advantages. First, data indexed by geohash will have all points for a given rectangular area in contiguous slices (the number of slices depends on the precision required {{and the presence of}} geohash [...] "fault lines"). This is especially useful in database systems where queries on a single index are much easier or faster than multiple-index queries. Second, this <b>index</b> <b>structure</b> can be used for a quick-and-dirty proximity search: the closest points are often among the closest geohashes.|$|E
50|$|When a {{vector space}} is {{equipped}} with a nondegenerate bilinear form (or metric tensor as it is often called in this context), operations can be defined that convert a contravariant (upper) index into a covariant (lower) index and vice versa. A metric tensor is a (symmetric) (0, 2)-tensor; it is thus possible to contract an upper index of a tensor with one of the lower indices of the metric tensor in the product. This produces a new tensor with the same <b>index</b> <b>structure</b> as the previous tensor, but with lower index generally shown in the same position of the contracted upper index. This operation is quite graphically known as lowering an index.|$|E
40|$|Due to the {{advances}} in hardware technology and {{increase in production}} of multimedia data in many applications, during the last decades, multimedia databases have become increasingly important. Contentbased multimedia retrieval is one of an important research area {{in the field of}} multimedia databases. Lots of research on this field has led to proposition of different kinds of <b>index</b> <b>structures</b> to support fast and efficient similarity search to retrieve multimedia data from these databases. Due to variety and plenty of proposed <b>index</b> <b>structures,</b> we suggest a systematic framework based on partitioning method used in these structures to classify multimedia <b>index</b> <b>structures,</b> and then we evaluated these structures based on important functional measures. We hope this proposed framework will lead to empirical and technical comparison of multimedia <b>index</b> <b>structures</b> and development of more efficient structures at future...|$|R
40|$|Similarity {{queries are}} an {{important}} query type in multimedia databases. To implement these types of queries, database systems often use spatial <b>index</b> <b>structures</b> like the R*-Tree. However, the majority of performance evaluations for spatial <b>index</b> <b>structures</b> rely on a conventional background storage layer based on conventional hard drives. Since newer devices like solid-state-disks (SSD) have a completely different performance characteristic, {{it is an interesting}} question how far existing <b>index</b> <b>structures</b> profit from these modern storage devices. In this paper, we therefore examine the performance behaviour of the R*-Tree on an SSD compared to a conventional hard drive. Testing various influencing factors like system load, dimensionality and page size of the index our evaluation leads to interesting insights into the performance of spatial <b>index</b> <b>structures</b> on modern background storage layers. 1...|$|R
40|$|Various <b>index</b> <b>structures</b> {{have been}} {{proposed}} {{to speed up the}} evaluation of XML path expressions. However, existing XML path indices su#er from at least one of three limitations: they focus only on <b>indexing</b> the <b>structure</b> (relying on a separate index for node content), they are useful only for simple path expressions such as root-to-leaf paths, or they cannot be tightly integrated with a relational query processor. Moreover, there is no unified framework to compare these <b>index</b> <b>structures.</b> In this paper, we present a framework defining a family of <b>index</b> <b>structures</b> that includes most existing XML path indices. We also propose two novel <b>index</b> <b>structures</b> in this family, with different space-time tradeo#s, that are e#ective for the evaluation of XML branching path expressions (i. e., twigs) with value conditions. We also show how this family of <b>index</b> <b>structures</b> can be implemented using the access methods of the underlying database system. Finally, we present an experimental evaluation that shows the performance tradeo# between index space and matching time. The experimental results show that our novel indices achieve orders of magnitude improvement in performance for evaluating twig queries, albeit at a higher space cost, over the use of previously proposed XML path indices that can be tightly integrated with a relational query processor...|$|R
50|$|When a {{vector space}} is {{equipped}} with an inner product (or metric as it is often called in this context), there exist operations that convert a contravariant (upper) index into a covariant (lower) index and vice versa. A metric itself is a (symmetric) (0,2)-tensor, it is thus possible to contract an upper index of a tensor {{with one of the}} lower indices of the metric. This produces a new tensor with the same <b>index</b> <b>structure</b> as the previous, but with lower index in the position of the contracted upper index. This operation is quite graphically known as lowering an index.Conversely, a metric has an inverse which is a (2,0)-tensor. This inverse metric can be contracted with a lower index to produce an upper index. This operation is called raising an index.|$|E
5000|$|DBSCAN visits {{each point}} of the database, {{possibly}} multiple times (e.g., as candidates to different clusters). For practical considerations, however, the time complexity is mostly governed {{by the number of}} regionQuery invocations. DBSCAN executes exactly one such query for each point, and if an indexing structure is used that executes a neighborhood query in , an overall average runtime complexity of [...] is obtained (if parameter [...] is chosen in a meaningful way, i.e. such that on average only [...] points are returned). Without the use of an accelerating <b>index</b> <b>structure,</b> or on degenerated data (e.g. all points within a distance less than [...] ), the worst case run time complexity remains [...] The distance matrix of size [...] can be materialized to avoid distance recomputations, but this needs [...] memory, whereas a non-matrix based implementation of DBSCAN only needs [...] memory.|$|E
5000|$|The leaves (the bottom-most index blocks) of the B+ tree {{are often}} linked {{to one another}} in a linked list; this makes range queries or an (ordered) {{iteration}} through the blocks simpler and more efficient (though the aforementioned upper bound can be achieved even without this addition). This does not substantially increase space consumption or maintenance on the tree. This illustrates one of the significant advantages of a B+tree over a B-tree; in a B-tree, since not all keys are present in the leaves, such an ordered linked list cannot be constructed. A B+tree is thus particularly useful as a database system index, where the data typically resides on disk, as it allows the B+tree to actually provide an efficient structure for housing the data itself (this is described in as <b>index</b> <b>structure</b> [...] "Alternative 1").|$|E
40|$|In {{temporal}} document {{databases and}} temporal XML databases, temporal text-containment queries are a potential performance bottleneck. In this paper we describe {{how to manage}} documents and <b>index</b> <b>structures</b> in such databases {{in a way that}} makes temporal textcontainment querying feasible. We describe and discuss different <b>index</b> <b>structures</b> that can improve such queries. Three of the alternatives have been implemented in the V 2 temporal document database system, and the performance of the <b>index</b> <b>structures</b> is studied using temporal web data. The results show that even a very simple time-indexing approach can reduce query cost by up to three orders of magnitude...|$|R
40|$|Flash Memory is {{the most}} {{prevalent}} storage medium found on modern Wireless Sensor Devices (WSDs). In this article we present two external memory <b>index</b> <b>structures</b> for the efficient retrieval of records stored on the local flash memory of a WSD. Our <b>index</b> <b>structures,</b> MicroHash and MicroGF (Micro Grid Files), exploit the asymmetric read/write and wear characteristics of flash memory in order to offer high performance indexing and searching capabilities {{in the presence of}} a low energy budget, which is typical for the devices under discussion. Both structures organize data and index pages on the flash media using a sorted by timestamp file organization. A key idea behind these <b>index</b> <b>structures</b> is that expensive random access deletions are completely eliminated. MicroHash enables equality searches by value in constant time and equality searches by timestamp in logarithmic time at a small cost of storing the index pages on the flash media. Similarly, MicroGF enables spatial equality and proximity searches in constant time. We have implemented these <b>index</b> <b>structures</b> in nesC, the programming language of the TinyOS operating system. Our trace-driven experimentation with several real datasets reveals that our <b>index</b> <b>structures</b> offe...|$|R
5000|$|TokuMX, a fork of MongoDB with {{stronger}} {{consistency and}} new <b>index</b> <b>structures</b> ...|$|R
5000|$|The largest entity on a CD {{is called}} a track. A CD can contain up to 99 tracks (including a data track for mixed mode discs). Each track can in turn have up to 100 indexes, though players which handle this feature are rarely found outside of pro audio, {{particularly}} radio broadcasting. The vast majority of songs are recorded under index 1, with the pre-gap being index 0. Sometimes hidden tracks are placed {{at the end of}} the last track of the disc, often using index 2 or 3. This is also the case with some discs offering [...] "101 sound effects", with 100 and 101 being indexed as two and three on track 99. The index, if used, is occasionally put on the track listing as a decimal part of the track number, such as 99.2 or 99.3. (Information Society's Hack was one of very few CD releases to do this, following a release with an equally obscure CD+G feature.) The track and <b>index</b> <b>structure</b> of the CD were carried forward to the DVD format as title and chapter, respectively.|$|E
50|$|Jet 3.0 {{included}} many enhancements, {{including a new}} <b>index</b> <b>structure</b> that reduced storage size and the time that was taken to create indices that were highly duplicated, the removal of read locks on index pages, a new mechanism for page reuse, a new compacting method for which compacting the database resulted in the indices being stored in a clustered-index format, a new page allocation mechanism to improve Jet's read-ahead capabilities, improved delete operations that speeded processing, multithreading (three threads were used to perform read ahead, write behind, and cache maintenance), implicit transactions (users {{did not have to}} instruct the engine to start manually and commit transactions to the database), a new sort engine, long values (such as memos or binary data types) were stored in separate tables, and dynamic buffering (whereby Jet's cache was dynamically allocated at start up and had no limit and which changed from a first in, first out (FIFO) buffer replacement policy to a least recently used (LRU) buffer replacement policy). Jet 3.0 also allowed for database replication.Jet 3.0 was replaced by Jet 3.5, which uses the same database structure, but different locking strategies, making it incompatible with Jet 3.0.|$|E
40|$|An {{efficient}} <b>index</b> <b>structure</b> {{for complex}} multi-dimensional objects {{is one of}} the most challenging requirements in non-traditional applications such as geographic information systems, computer-aided design, and multimedia databases. This paper presents a multi-dimensional <b>index</b> <b>structure</b> based on a novel object decomposition method. This is an extension of an existing <b>index</b> <b>structure.</b> The proposed <b>index</b> <b>structure</b> integrates two index structures, one for original objects and the other for their decomposed components. An analytical model is developed for our <b>index</b> <b>structure.</b> The performance of our <b>index</b> <b>structure</b> is compared with that of a state-of-the-art <b>index</b> <b>structure</b> by experimental measurements. Our <b>index</b> <b>structure</b> outperforms the state-of-the-art <b>index</b> <b>structure</b> due to its ability to reduce a large amount of storage. Additionally, our <b>index</b> <b>structure</b> is easier to implement and applicable to various spatial data such as curves, regions, and volumes. This work was supported by the Na [...] ...|$|E
40|$|New {{applications}} have emerged, demanding {{database management}} systems with enhanced functionality. However, high performance {{is a necessary}} precondition for the acceptance of such systems by end users. In this context we developed, implemented, and tested algorithms and <b>index</b> <b>structures</b> for improving the performance of advanced database management systems. We focused on <b>index</b> <b>structures</b> and join algorithms for set-valued attributes...|$|R
50|$|MemSQL uses skip lists as {{its prime}} <b>indexing</b> <b>structure</b> for its {{database}} technology.|$|R
5000|$|Java library {{implementing}} Allen's Interval Algebra (incl. {{data and}} <b>index</b> <b>structures,</b> e.g., interval_tree) ...|$|R
40|$|This paper {{proposes a}} spatial <b>index</b> <b>structure</b> {{based on a}} new space-partitioning method. Previous {{research}} proposed various high dimensional index structures. However, when dimensionality becomes high, {{the effectiveness of the}} spatial <b>index</b> <b>structure</b> disappears. This problem is called the “curse of dimensionality”. This paper focuses {{on the fact that the}} volume of high dimensional space is mostly occupied by its surface and then proposes a new surface <b>index</b> <b>structure.</b> The utility of this new surface spatial <b>index</b> <b>structure</b> is illustrated through a series of experiments. <br /...|$|E
30|$|A popular <b>index</b> <b>structure</b> for {{geometric}} {{information is}} R-tree [25]. Wang et al. [26] proposed an R-tree-based indexing scheme for trajectory data of cars in a distributed environment, and Du et al. [27] proposed an <b>index</b> <b>structure</b> {{with a number}} of R-trees and Hilbert space-filling curves [28]. Another <b>index</b> <b>structure</b> for geometric information is Quad-tree [29]. Chen et al. [30] indexed GPS data using Quad-tree and Hilbert space-filling curves, and Xie et al. [31] utilized HBase tables as an index based on Quad-tree. In this study, we optimized the <b>index</b> <b>structure</b> in [30] to obtain improved performance.|$|E
30|$|However, HBase cannot process queries with {{attributes}} {{other than}} Rowkey. Fortunately, this restriction {{can be overcome}} by using an <b>index</b> <b>structure.</b> Specifically, as latitude and longitude are two primary attributes in our system for representing geographical information, we can construct an <b>index</b> <b>structure</b> for the two attributes. We revised the method in [30] to meet our requirements. The <b>index</b> <b>structure</b> comprises two parts: R-tree [25] and Hilbert space-filling curve [28].|$|E
40|$|We {{propose a}} minimum overlap based hyperspherical region graph <b>indexing</b> <b>structure</b> to achieve fast similarity-based queries for both {{low and high}} {{dimensional}} datasets. Specifically, we reduce the region overlaps in the graph construction phase by incrementally dividing each saturated hyperspherical region and removing the longest edge of a minimum spanning tree representation of the internal objects. This overlap reduction scheme creates more separated regions, so fewer regions as potential paths are traversed when a query is issued. We also introduce a k-nearest-neighbor search scheme by automatically deciding the search radius to return the required number of nearest neighbors. Our extensive experimental results show {{the effectiveness of the}} proposed <b>indexing</b> <b>structure</b> compared with other tree and graph based <b>indexing</b> <b>structures.</b> <b>Index</b> Terms — Hyperspherical region graph, minimu...|$|R
40|$|A lot {{of recent}} work has {{focussed}} on bulk loading of data into multidimensional <b>index</b> <b>structures</b> {{in order to}} efficiently construct such structures for large datasets. Previous work on bulk loading data focussed at building <b>index</b> <b>structures</b> from scratch, while the problem of bulk insertions into existing <b>index</b> <b>structures</b> has been largely overlooked. In this paper, we address this new problem with particular focus on R-trees [...] which are an important class of <b>index</b> <b>structures</b> used widely in commercial database systems. We propose a new technique, which {{as opposed to the}} current technique of inserting data one by one, bulk inserts entire new datasets into an active R-tree. This technique, called STLT (for Small-Tree-Large-Tree), considers the new dataset as an R-tree itself (small tree), identifies and prepares a suitable location in the original R-tree (large tree) for insertion, and lastly performs the insert of the small tree into the large tree. Extensive experimental studies both o [...] ...|$|R
40|$|<b>Indexing</b> <b>structures</b> are of {{fundamental}} importance to modeling languages for mathematical programming as a device for mathematical abstraction, {{and because they}} facilitate achieving conciseness, stability, and error-resistance. The aim {{of this article is}} to stimulate discussion of such structures, especially the two most common kinds found in algebraic style languages: sets and relations. We offer a taxonomy of set-based and relation-based <b>indexing</b> <b>structures,</b> a suite of detailed examples illustrating this taxonomy, and a number of specific principles (some arguable and some not) for incorporating <b>indexing</b> <b>structures</b> into modeling languages. We also examine four modeling languages in detail with respect to their indexing capabilities: AMPL, GAMS, LINGO, and SML. By attempting to work all of the illustrative examples in each language, we are able to reach some conclusions concerning relative expressive power, economy of notation, obedience to our principles of "good" language design, ease of data handling, and other criteria. modeling language, modeling systems, mathematical programming, <b>indexing</b> <b>structures...</b>|$|R
