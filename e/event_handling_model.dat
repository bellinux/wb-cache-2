5|2675|Public
50|$|The W3C {{designed}} {{a more flexible}} <b>event</b> <b>handling</b> <b>model</b> in DOM Level 2.|$|E
5000|$|This <b>event</b> <b>handling</b> <b>model</b> was {{introduced}} by Netscape Navigator, and remains the most cross-browser model [...] There are two model types: inline model and traditional model.|$|E
5000|$|Flash Player 6: Added an <b>event</b> <b>handling</b> <b>model,</b> {{accessibility}} {{controls and}} support for switch. The first version with support for the AMF and RTMP protocols which allowed for on demand audio/video streaming.|$|E
40|$|Abstract: Around city {{applications}} such as E-Government, E-Business, etc, <b>event</b> <b>handling</b> becomes a common activity. When <b>handling</b> an <b>event</b> in a city, people {{should focus on the}} task of integrating, conforming and scheduling heterogeneous, distributed resources from multi-domains, as well as sharing knowledge among different organizations. This paper proposes a rule-based distributed resources integrating and scheduling <b>model</b> for <b>event</b> <b>handling.</b> The <b>model</b> has a hierarchical structure with four levels: resource layer, knowledge layer, business layer and representation layer. Detail work on the knowledge layer is explored, which includes the definition of formal business rule, reference to resources in a rule, as well as the design and implementation of the rule system. Finally, an <b>event</b> <b>handling</b> prototype system of unitive alarm taking in for iEMS (integrated emergency management system) is implemented to validate the model...|$|R
40|$|The {{increasing}} {{complexity of}} controller systems, applied in modern passenger cars, requires adequate simulation tools. The toolset FASIM_C++, {{described in the}} following, uses complex vehicle models in three-dimensional vehicle dynamics simulation. The structure of the implemented dynamic models and the generation of the equations of motion applying the method of kinematic differentials is explained briefly. After a short introduction in methods of <b>event</b> <b>handling,</b> several vehicle <b>models</b> and applications like controller development, roll-over simulation and real-time-simulation are explained. Finally some simulation results are presented...|$|R
40|$|Abstract—The model driven {{architecture}} (MDA) allows to {{move the}} software development form the time consuming and error-prone level of writing program code to the next higher level of modeling. The MDA requires tools for modeling, transformation of models, and code generation. In the past, we have developed such tools successfully. Using these tools we recognized serious problems preparing concise, uniform, and complete models using the unified modeling language (UML). In detail these problems concern first the specification and parameterization of GUI elements, second the <b>event</b> <b>handling,</b> and third the modeling of the required behavior. In this paper we show efficient solutions for these problems using the object constraint language (OCL) together with the UML for modeling. While the parameterization of GUI elements can be solved with the OCL directly, the last two problems were solved by {{an extension of the}} OCL into an executable OCL, which we call XOCL. We show the benefits of all three new approaches by means of an example of a complete platform independent model (PIM). Keywords-OCL extension, action language, <b>event</b> <b>handling,</b> platform independent <b>model,</b> class diagram I...|$|R
40|$|In {{earlier work}} we have {{developed}} three domain specific visual approaches for event-based system specification. The first, ViTABaL-WS, uses the Tool Abstraction (TA) metaphor to support specification of web services composition via higher level data and control flows and generation of BPEL 4 WS code. The second, Kaitiaki, uses an Event-Query-Filter-Action (EQFA) metaphor to allow visual primitives composition and java code generation for diagramming tool event handlers. The third, MaramaTatau, uses a spreadsheet-like metaphor to construct meta-model formulae visually to specify structural dependencies and constraints to be realised at runtime. We propose an integrated visual approach that is generalised from these three explored exemplar approaches to specify event handling behaviours. We derive a canonical <b>event</b> <b>handling</b> <b>model</b> which enables interoperability between these exemplar event models, with also the support for synthesised runtime visualisation. This paper discusses the requirements and design of the resulting general purpose event handling framework, its evaluation and some key future directions. 1...|$|E
40|$|ZebraNet is a mobile, {{wireless}} {{sensor network}} in which nodes move throughout an environment working to gather and process information about their surroundings [10]. As in many sensor or wireless systems, nodes have critical resource constraints such as processing speed, memory size, and energy supply; they also face special hardware issues such as sensing device sample time, data storage/access restrictions, and wireless transceiver capabilities. This paper discusses and evaluates ZebraNet’s system design decisions {{in the face of}} a range of real-world constraints. Impala—ZebraNet’s middleware layer—serves as a lightweight operating system, but also has been designed to encourage application modularity, simplicity, adaptivity, and repairability. Impala is now implemented on ZebraNet hardware nodes, which include a 16 -bit microcontroller, a lowpower GPS unit, a 900 MHz radio, and 4 Mbits of non-volatile FLASH memory. This paper discusses Impala’s operation scheduling and <b>event</b> <b>handling</b> <b>model,</b> and explains how system constraints and goals led to the interface designs we chose between the application, middleware, and firmware layers. We also describe Impala’s network interface which unifies media access control and transport control into an efficient network protocol. With the minimum overhead in communication, buffering, and processing, it supports a range of message models, all inspired by and tailored to ZebraNet’s application needs. By discussing design tradeoffs in the context of a real hardware system and a real sensor network application, this paper’s design choices and performance measurements offer some concrete experiences with software systems issues for the mobile sensor design space. More generally, we feel that these experiences can guide design choices in a range of related systems...|$|E
40|$|The Real-Time Specification for Java (RTSJ) {{is silent}} on {{multiprocessor}} issues. It attempts not to preclude multiprocessor implementations but provides no direct support. Many {{areas of the}} RTSJ leave an implementation considerable freedom on how it provides the defined functionality. One such area is the asynchronous <b>event</b> <b>handling</b> (AEH) <b>model.</b> <b>Events</b> are fired and associated handlers are scheduled for execution in response; handlers have defined scheduling parameters and deadlines. The primary goal of the AEH model is to support a lightweight real-time concurrency model. Hence handlers, in general, do not have dedicated threads. Rather, the implementation is responsible for ensuring that all handlers meet their deadlines. Typically real-time threads are assigned to execute handlers by the implementation. This paper discusses the issues associated with implementing the AEH model on multiprocessor systems. The emphasis here is on achieving a lightweight model. A model is lightweight if {{it is able to}} meet the deadlines of all handlers with as few as possible real-time threads. In the RTSJ this is made more complicated because asynchronous event handlers are allowed to suspend themselves (for example, by waiting on a monitor condition). Such handlers are called blocking handlers. Most of an implementation’s freedom comes from being able to optimize the support for those handlers that do not block. The paper first examines all possible releasin...|$|R
5000|$|Unified <b>event</b> <b>handling</b> {{system based}} on the DOM <b>event</b> <b>handling</b> standard.|$|R
5000|$|<b>Event</b> <b>handling</b> {{systems that}} use both the event type {{and the type}} of the {{receptor}} object in order to call the correct <b>event</b> <b>handling</b> routine.|$|R
40|$|Longitudinal {{network data}} {{recording}} {{the moment at}} which ties appear, change, or disappear are increasingly available. Event history models {{can be used to}} analyze the dynamics of time-stamped network data. This paper adapts the discrete-time event history model to social network data. A discrete-time event history model can easily incorporate a multilevel design and time-varying covariates. A multilevel design is needed to account for dependencies among ties and vertices, which should not be ignored in a small longitudinal network. Time-varying covariates are required to analyze network effects, that is, the impact of previous ties. In addition, a discrete-time <b>event</b> history <b>model</b> <b>handles</b> constraints on who can act or who can be acted upon in a straightforward way. The model can be estimated with multilevel logistic regression analysis, which is illustrated by an application to book reviews, so network evolution can be analyzed with a fairly standard statistical tool...|$|R
40|$|Abstract. The paper {{presents}} the LinkSmart middleware platform {{that addresses the}} Internet of Things and Services approach. The platform was designed to support the interoperability and seamless integration of various external devices, sensors, and services into the mainstream enterprise systems. The design and development of LinkSmart goes across two integrated European research projects, namely the FP 6 IST project Hydra and the FP 7 ICT project EBBITS. Modular architecture and functionality of LinkSmart prototype, developed by combining the service-oriented architecture, peer-to-peer networking, and semantic web services technologies, is described with focus on semantic binding of networked devices by means of underlying ontologies and knowledge-based inference mechanisms. Extensions of the solution towards the service orchestration, complex <b>event</b> <b>handling,</b> business process <b>modelling</b> and workflow processing are discussed and described on a mechanism of context-aware processing of sensor data. Key words: semantic web services, Internet of Things and Services, ontology for services, devices and events, networked embedded systems AMS subject classifications. 94 - 04, 94 B 99 1. Introduction. The innovative and rapidly evolving research area of Internet of Things and Services (IoTS) [16], [20] addresses an investigation of ways and means for seamless functional interconnection and effec-tive, so-called intelligent, communication of various devices, services, information systems and resources towards operational scenarios. The aim of efforts {{in this area is}} focused on a development of platforms and solution...|$|R
5000|$|<b>Event</b> <b>handling</b> order: handler3 (...) - > handler2 (...) -> handler1 (...) ...|$|R
40|$|Developing an ecient {{parallel}} simulation framework for multiprocessor systems is hard. A primary {{concern is the}} considerable amount of parallelization overhead imposed on the <b>event</b> <b>handling</b> routines of the simulator. Besides complex event scheduling algorithms, the main sources of overhead are thread synchronization and locking of shared data. Thus, compared to sequential simulation, the overhead of parallelization may easily outweigh its performance benets. We introduce two ecient <b>event</b> <b>handling</b> schemes based on our parallel-simulation extension Horizon for OMNeT++. First, we present a push-based <b>event</b> <b>handling</b> scheme to minimize the overhead of thread synchronization and locking. Second, we complement this scheme with a novel event scheduling algorithm that signicantly reduces the overhead of parallel event scheduling. Lastly, we prove the correctness of the scheduling algorithm. Our evaluation reveals a total reduction of the <b>event</b> <b>handling</b> overhead of up to 16 x. QC 20140102 </p...|$|R
5000|$|Input Events: <b>Event</b> <b>handling,</b> Support for Keyboard, Mouse, Joystick and Game {{controller}} ...|$|R
5000|$|Version 7: 2000 (dynamic cache, task {{scheduling}} and <b>event</b> <b>handling,</b> cross-platform administration tools) ...|$|R
5000|$|<b>Event</b> <b>handling</b> - <b>Events</b> could {{increase}} the runtime for real-time systems in an unpredictable manner.|$|R
5000|$|... jQuery: A JavaScript library that abstracts DOM {{manipulation}} and traversal, animation, <b>event</b> <b>handling,</b> and other common JavaScript tasks.|$|R
40|$|The Komodo project {{concerns}} {{the handling of}} multiple real-time events by Java threads that are supported by a multithreaded Java microcontroller. The architecture of the processor core and resulting implications are considered. The use of thread-based <b>event</b> <b>handling</b> is introduced and explained in combination with an Automatic Guided Vehicle (AGV) application. The advantages of thread-based <b>event</b> <b>handling</b> over a normal Interrupt Service Routine (ISR) strategy are demonstrated {{by the development of}} the AGV example. ...|$|R
40|$|Radio Frequency Identification (RFID) is a {{wireless}} communication technology that uses radio-frequency waves to transfer information between tagged objects and readers without line of sight. This creates tremendous opportunities for linking real world objects {{into a world}} of &# 039;Internet of things&# 039;. Application of RFID to Fast Moving Consumer Goods sector will introduce billions of RFID tags in the world. Almost everything is tagged for tracking and identification purposes. This phenomenon will impose a new challenge not only to the network capacity but also to the scalability of processing of RFID events and data. This chapter uses two national demonstrator projects in Australia as case studies to introduce an event management framework to process high volume RFID data streams in real time and automatically transform physical RFID observations into business-level <b>events.</b> The <b>model</b> <b>handles</b> various temporal <b>event</b> patterns, both simple and complex, with temporal constraints. The model can be implemented in a data management architecture that allows global RFID item tracking and enables fast, large-scale RFID deployment...|$|R
40|$|This paper {{presents}} an asynchronous <b>event</b> <b>handling</b> mechanism for real-time applications that leverages existing system services in COTS systems. In our implementation, event dispatching is initiated within bottom-half interrupt handling routines, {{in order to}} support predictable, safe, and efficient <b>event</b> <b>handling</b> functionality at user-level. We compare our asynchronous I/O mechanism with existing user-level approaches, such as the GNU C library implementation of the AIO API and the Linux signal abstraction. Using a user-level sandboxing scheme for asynchronous <b>event</b> <b>handling,</b> results show that network receive events can be dispatched in less than 15 microseconds using commodity hardware components. We show that the proposed architecture significantly outperforms the above mentioned user-level asynchronous I/O mechanisms and provides more flexibility than available hard real-time extensions. Keywords: real-time, COTS, asynchronous I/O, event dispatchin...|$|R
5000|$|Profile C - Addresses common {{functionalities}} of IP {{access control}} systems, such as door state and control, credential management, and <b>event</b> <b>handling.</b>|$|R
50|$|Other major <b>events</b> <b>handled</b> by the {{division}} include the Singapore Airshow exhibitions in Changi, and the Hari Raya Puasa bazaars at Geylang Serai.|$|R
5000|$|An {{advanced}} event model (XML Events) {{consistent with}} W3C standards that frees applications {{from having to}} deal with vendor-specific and browser-specific <b>event</b> <b>handling.</b>|$|R
40|$|ABSTRACT 1 Embedded {{real-time}} {{applications that}} {{interact with the}} out-side environment may be subjected to temporal uncertainty due to the potential asynchronous characteristics of <b>events.</b> If <b>event</b> <b>handling,</b> which is usually associated with inter-rupts, is not carefully controlled, overload scenarios can cause application tasks to miss deadlines, with severe con-sequences. In this paper we {{address the problem of}} control-ling <b>event</b> <b>handling</b> timeliness, by enhancing the real-time multitasking kernel RTEMS with components to character-ize event rate, decide if there is an overload situation, and switch between an interrupt mode and a polling mode <b>event</b> <b>handling.</b> This is done with minimal impact on the existing application, by replacing the interrupt handler by another one that implements those control mechanisms before call-ing the original application interrupt service routine. A case study using the keyboard as the input device is presented, and implementation issues are discussed...|$|R
50|$|Anonymous inner {{classes are}} also used where the <b>event</b> <b>handling</b> code is only used by one {{component}} and therefore does not need a named reference.|$|R
50|$|Virtual Machine Manager (VMM32.VXD): Responsible for memory management, <b>event</b> <b>handling,</b> {{interrupt}} handling, {{loading and}} initializing virtual device drivers, creating new virtual machines and thread scheduling.|$|R
5000|$|DOM Level 3, {{published}} in April 2004, added support for XPath and keyboard <b>event</b> <b>handling,</b> {{as well as}} an interface for serializing documents as XML.|$|R
50|$|The {{runtime system}} {{implements}} the virtual machine, automatic memorymanagement with garbage collection of stacks and dictionary, <b>event</b> <b>handling</b> and data-driven execution.Versions of ECLiPSe implement OR-parallelism.|$|R
5000|$|IDE support. Jspx can be {{developed}} using any IDE, however {{there is no direct}} support for jspx. Developer has to write the <b>event</b> <b>handling</b> manually.|$|R
5000|$|... {{it forces}} authors {{to mix the}} content of the {{document}} with the specifications of the scripting and <b>event</b> <b>handling,</b> rather than allowing them to separate them.|$|R
40|$|Part 9 : Smart Monitoring SystemsInternational audienceA {{fast and}} {{efficient}} response to hazardous events {{can make the}} difference between life and death. Using this necessity as premise, surveillance systems are evolving, increasing the number of sensors used in event detection and developing new methods and algorithms for <b>events</b> <b>handling.</b> Nevertheless the timeliness and efficiency of response to events could be improved using new technologies, such as mobile devices with GPS capabilities, georeferenced location of events, and event classification. Having access to events and security agents’ locations could improve <b>event’s</b> <b>handling</b> in terms of responsiveness and appropriate distribution of work load per agent. Under the scope of a research project Advanced Surveillance System (DVA) a new approach to surveillance systems based in this geographic position of sensors, detected events and security agents was developed. DVA implements new algorithms for events’ assignment and processing. This paper describes DVA’s new approach to <b>event</b> <b>handling...</b>|$|R
50|$|Microsoft Small Basic is Turing complete. It {{supports}} conditional branching, loop structures, and subroutines for <b>event</b> <b>handling.</b> Variables are weakly typed {{and dynamic}} with no scoping rules.|$|R
40|$|Abstract—A {{critical}} issue {{dealt with in}} Wireless Sensor and Actor Networks (WSANs) is the real time response of actors to events occurring in the network area. The fast notification of actors from Sensor Nodes (SNs) about the events {{as well as the}} effective coordination of actors for prompt <b>event</b> <b>handling</b> is most important in these networks. In this paper, we introduce a distributed protocol for effective <b>event</b> <b>handling</b> in a WSAN. Existing approaches mainly favoring actors near the current <b>event</b> for <b>handling</b> it, may lead to highly ineffective solutions for certain worst-case scenarios. Through a randomized approach, our solution also selects distant actors for <b>handling</b> <b>events,</b> and guarantees fast average responsiveness to events and a balanced energy distribution among actors. In addition, it features efficient distributed algorithms for sensor to actor and actor to actor coordination which are of independent interest. I...|$|R
5000|$|<b>Event</b> <b>handling</b> {{goes into}} three steps. First, define an event var e = Event.new;Second, specify event {{handlers}} at (e?) echo("received event e");Third, [...] "emit" [...] this event e!; ...|$|R
