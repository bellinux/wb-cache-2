1|13|Public
5000|$|... #Subtitle level 2: Fourth and <b>fifth-generation</b> <b>language</b> {{primitives}} ...|$|E
50|$|While {{fourth-generation}} programming {{languages are}} designed to build specific programs, <b>fifth-generation</b> <b>languages</b> {{are designed to}} make the computer solve a given problem without the programmer. This way, the user only needs {{to worry about what}} problems need to be solved and what conditions need to be met, without worrying about how to implement a routine or algorithm to solve them. <b>Fifth-generation</b> <b>languages</b> are used mainly in artificial intelligence research. Prolog, OPS5 and Mercury are examples of <b>fifth-generation</b> <b>languages.</b>|$|R
50|$|A <b>fifth-generation</b> {{programming}} <b>language</b> (5GL) is a {{programming language}} based on solving using constraints given to the program, rather than using an algorithm written by a programmer. Most constraint-based and logic programming languages and some other declarative <b>languages</b> are <b>fifth-generation</b> <b>languages.</b>|$|R
50|$|In the 1980s and 1990s, {{there were}} {{efforts to develop}} <b>fifth-generation</b> {{programming}} <b>languages</b> (5GL).|$|R
50|$|In the 1980s, <b>fifth-generation</b> <b>languages</b> were {{considered}} to be the way of the future, and some predicted that they would replace all other languages for system development, with the exception of low-level languages. Most notably, from 1982 to 1993, Japan put much research and money into their fifth-generation computer systems project, hoping to design a massive computer network of machines using these tools.|$|R
5000|$|Visual {{programming}} by [...] "properties, methods, {{events and}} actions" [...] {{can be a}} <b>fifth-generation</b> programming <b>language.</b>|$|R
50|$|Examples of {{end-user}} computing are systems built using fourth-generation programming languages, such as MAPPER or SQL, {{or one of}} the <b>fifth-generation</b> programming <b>languages,</b> such as ICAD.|$|R
50|$|Fourth-generation {{programming}} <b>languages</b> (4GL) and <b>fifth-generation</b> programming <b>languages</b> (5GL) do {{not have}} a simple one-to-many correspondence from high-to-low level primitives. There are some elements of interpreted language primitives embodied in 4GL and 5GL specifications, but the approach to the original problem is less a procedural language construct and are more oriented toward problem solving and systems engineering.|$|R
50|$|Metacomputing is also {{a useful}} {{descriptor}} for self-referential programming systems. Often these systems are functional as <b>fifth-generation</b> computer <b>languages</b> which {{require the use of}} an underlying metaprocessor software operating system in order to be operative. Typically metacomputing occurs in an interpreted or real-time compiling system since the changing nature of information in processing results may result in an unpredictable compute state throughout the existence of the metacomputer (the information state operated upon by the metacomputing platform).|$|R
50|$|The 1980s were {{years of}} {{relative}} consolidation in imperative languages. Rather than inventing new paradigms, {{all of these}} movements elaborated upon the ideas invented in the previous decade. C++ combined object-oriented and systems programming. The United States government standardized Ada, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called <b>fifth-generation</b> programming <b>languages</b> that incorporated logic programming constructs. The functional languages community moved to standardize ML and Lisp. Research in Miranda, a functional language with lazy evaluation, began to take hold in this decade.|$|R
40|$|Automated {{prototyping}} tool-kit (APT) is {{an integrated}} set of software tools that generate source programs directly from real-time requirements. The APT system uses a <b>fifth-generation</b> prototyping <b>language</b> {{to model the}} communication structure, timing constraints, 1 / 0 control, and data buffering that comprise the requirements for an embedded software system. The language supports the specification of hard real-time systems with reusable components from domain specific component libraries. APT has been used successfully as a research tool in prototyping large war-fighter control systems (e. g. the command-and-control station, cruise missile flight control system, patriot missile defense systems) and demonstrated its capability to support the development of large complex embedded software...|$|R
40|$|This paper {{addresses}} {{the problem of}} how to produce reliable software that is also flexible and cost effective for the DoD distributed software domain. DoD software systems fall into two categories: information systems and war fighter systems. Both types of systems can be distributed, heterogeneous and network-based, consisting of a set of components running on different platforms and working together via multiple communication links and protocols. We propose to tackle the problem using prototyping and a “wrapper and glue ” technology for interoperability and integration. This paper describes a distributed development environment, CAPS (Computer-Aided Prototyping System), to support rapid prototyping and automatic generation of wrapper and glue software based on designer specifications. The CAPS system uses a <b>fifth-generation</b> prototyping <b>language</b> to model the communication structure, timing constraints, I/O control, and data buffering that comprise the requirements for an embedded software system. The language supports the specification of hard real-time systems with reusable components from domain specific component libraries. CAPS has been used successfully as a research tool in prototyping large war-fighter control systems (e. g. the command-and-control station, cruise missile fligh...|$|R
40|$|This text {{contains}} {{description of}} the syntax and semantics of the language, MODEL, and techniques for its use. MODEL is a <b>fifth-generation</b> computer <b>language.</b> It is equational and non-procedural. (What these terms mean will be made clear to you as you begin {{to get involved in}} the MODEL system.) In this chapter, we shall discuss the value of the language. MODEL is a tool for systems and program design and development. Like most computer languages, the MODEL system comes with a compiler which is used to receive and analyze the language statements. But as we shall see later on, the whole process of analysis and coding is radically different in the MODEL system from programming methods in current practice. Using today's conventional technology, it is necessary for the analyst to have knowledge of how a computer works internally. Otherwise, the analysis is often unusable by the programmers. To express data processing requirements that are translatable into a procedural language requires knowledge of how a computer executes the solution of the problem Non-procedural languages are problem-oriented and independent of knowledge of how the computer works. MODEL eliminates the need for transfer of information from analyst to programmer. The MODEL system uses the computer to perform program design and coding automatically. In traditional systems design, afte...|$|R
40|$|This text {{contains}} {{description of}} the syntax and semantics of the language, MODEL, and techniques for its use. MODEL is a <b>fifth-generation</b> computer <b>language.</b> It is equational and non-procedural. (What these terms mean will be made clear to you as you begin {{to get involved in}} the MODEL system.) In this chapter, we shall discuss the value of the language. MODEL is a tool for systems and program design and development. Like most computer languages, the MODEL system comes with a compiler which is used to receive and analyze the language statements. But as we shall see later on, the whole process of analysis and coding is radically different in the MODEL system from programming methods in current practice. Using today 2 ̆ 7 s conventional technology, it is necessary for the analyst to have knowledge of how a computer works internally. Otherwise, the analysis is often unusable by the programmers. To express data processing requirements that are translatable into a procedural language requires knowledge of how a computer executes the solution of the problem Non-procedural languages are problem-oriented and independent of knowledge of how the computer works. MODEL eliminates the need for transfer of information from analyst to programmer. The MODEL system uses the computer to perform program design and coding automatically. In traditional systems design, after the requirements and analysis phases are completed, the programming task begins. Specifications are given to programmers who fmt perform the program 2 ̆ 6 sign and then write and debug the programs. In MODEL, once a specification is completed, the 2 ̆ 2 programming 2 ̆ 2 task is also done as a byproduct The specification itself is entered into the computer; submitted to the MODEL compiler. A PL/I program is generated, as well as a series of reports about the newly generated program. MODEL has facilities for automating all program development phases: design, coding and testing. It reduces the analyst 2 ̆ 7 s involvement with computer execution through having the compiler interface with the computer and its environment. The analyst writes a specification which is entered into the computer. The specification is transformed into a PL/I program by the MODEL compiler. As soon as the specification is completed the system is ready for testing. In short, MODEL is an outgrowth of a widespread need to make programming more natural and more accessible to non-programmers. Welcome to the realm of non-procedurality. You are going to learn a new methodology for systems analysis. It will help you to complete complex projects and enable you to conceptualize problems in a clear, precise manner, without having to at the same time worry about its implementation in a computer...|$|R

