8|109|Public
50|$|TEX {{programs}} were primarily designed {{to extend the}} line editor system. Consequently, TEX had no concept of file input/output relying instead on making changes to the working file via line <b>edit</b> <b>commands</b> and saving as needed.|$|E
50|$|However, <b>edit</b> <b>commands</b> {{represent}} the equation differently and keyboard direction commands reflect this. Analogous to a filesystem hierarchy of files and folders within folders, each equation is {{represented as a}} Tree structure. Each equation in Ket is a tree of operations and functions (tree branches) and variables and values (tree leaves).|$|E
50|$|A {{frequent}} {{application of}} quantization {{in this context}} lies within MIDI application software or hardware. MIDI sequencers typically include quantization in their manifest of <b>edit</b> <b>commands.</b> In this case, the dimensions of this timing grid are set beforehand. When one instructs the music application to quantize a certain group of MIDI notes in a song, the program moves each note to the closest point on the timing grid.|$|E
5000|$|EDT recognizes an {{additional}} usage for the Gold key, {{to enter a}} repeat count. For example, the keystrokes [...] enter a line of twenty equals signs. Repeat counts also apply to keypad <b>editing</b> <b>commands,</b> but if such a command itself requires the Gold key, the Gold key must be pressed again before the command key. For example, assuming a VT100 keypad, [...] perform the PASTE <b>editing</b> <b>command</b> (once), while [...] performs PASTE four times. For <b>editing</b> <b>commands</b> which are directional, such as moving the cursor, negative repeat counts {{may be used to}} indicate reverse direction.|$|R
50|$|The <b>edit</b> <b>command</b> is a macro that expands to get -e.|$|R
5000|$|A wide {{selection}} of <b>editing</b> <b>commands,</b> including indenting and unindenting, paragraph reformatting and line joining.|$|R
50|$|TEX {{programs}} are {{a collection of}} TSS line editing commands, TSS session commands and TEX statements. TEX variables could be inserted into TSS commands and TSS line editor commands via the TEX variable substitution feature. TEX programs were primarily designed to extend the line editor system. Consequently, TEX had no concept of file input/output relying instead on applying line <b>edit</b> <b>commands</b> to the working file and saving as needed.|$|E
50|$|Similar to XEDIT, THE uses IBMs REXX as its macro language, {{which makes}} THE highly {{configurable}} and versatile. This provides {{the ability to}} create powerful extensions to the editor and/or customize it to specialized needs. For example, one can create <b>edit</b> <b>commands</b> that would allows one to manipulate columns of text (e.g. copy/move or insert/delete a column of text within a file). With REXX, one can also integrate OS commands or external functions into an edit session. Since version 3.0, THE also has user-configurable syntax highlighting.|$|E
40|$|The MTS Manual is {{a series}} of volumes that {{describe}} in detail the facilities provided by the Michigan Terminal System. The MTS file editor is used for editing MTS files. <b>Edit</b> <b>commands</b> perform the editing functions on the edit file. These functions fall into three general categories: (1) changing the contents of the file, (2) searching the file for a character string or set of character strings, and (3) setting global editor options and modifiers. ...|$|E
5000|$|No {{support for}} <b>command</b> line <b>editing</b> (<b>Command</b> {{retrieval}} and <b>editing</b> is handled at an abstraction level between user and shell.) ...|$|R
40|$|In {{software}} system development, domain-specific visual notations are increasingly used and need a tool environment consisting of visual editors, simulators, model transformers, etc. Several Eclipse projects {{head for a}} meta technology to define domain-specific modeling languages. The Eclipse Modeling Framework (EMF) [4] {{can be used to}} define the underlying models of visual editors. A visual editor may be generated using the Graphical Modeling Framework (GMF) [3] which started recently as Eclipse technology subproject aiming at providing an infrastructure for generating visual editors in Eclipse. In essence, GMF forms a bridge between EMF and GEF [2], whereby a diagram definition is linked to a domain model which serves as input to the generation of a visual editor. GMF-generated editors offer basic <b>editing</b> <b>commands</b> to create, <b>edit,</b> move and delete single model elements (basic editing). Graph transformation-based editors (see e. g. Tiger [6]) show that the generation of editors with complex <b>editing</b> <b>commands</b> is also possible. Editing e. g. activity diagrams, there might be <b>editing</b> <b>commands</b> available which insert or delete a complete decision structure in one step. In this paper, we describe how meta model-based editor design and generation performed by GMF [3], can be extended by graph transformation concepts to define and generate complex <b>editing</b> <b>commands</b> to be used in GMF-generated visual editors...|$|R
50|$|PC DOS 6 {{does not}} include the <b>edit</b> <b>command.</b> Instead, it has the DOS E Editor. This was {{upgraded}} to support mouse and menus in version of 7.0.|$|R
40|$|This brief {{paper is}} a {{response}} to a call [7] for opinion statements from mem-bers of the editorial board of the upcoming journal: LNCS Transactions on Foundations for Mastering Change (FoMaC). In the call it says: FoMaC intends to establish a forum for formal methods-based research that fosters a discipline for rigorously dealing with the nature of today’s agile system development, which is characterized by unclear premises, unforeseen change, and the need for fast reaction, in a context of hard to control frame conditions, like third party components, network-problem, and attacks. The phases covered span from meta modeling to modeling and design, imple-mentation, runtime and finally evolution/migration. In the extreme, all software correctness issues can be considered as purely change issues, where the funda-mental question is the following: given a program P, potentially empty, will the addition of the program fragment ∆ make P + ∆ satisfy a property ψ? Program fragments ∆ can here be understood liberally, as for example <b>edit</b> <b>commands</b> (replace these lines of code with these lines of code), refinements- as in stepwis...|$|E
40|$|The {{literature}} reports research efforts allowing the editing of interactive TV multimedia documents by end-users. In {{this article we}} propose complementary contributions relative to end-user generated interactive video, video tagging, and collaboration. In earlier work we proposed the watch-and-comment (WaC) paradigm as the seamless capture of an individual`s comments so that corresponding annotated interactive videos be automatically generated. As a proof of concept, we implemented a prototype application, the WACTOOL, that supports the capture of digital ink and voice comments over individual frames and segments of the video, producing a declarative document that specifies both: different media stream structure and synchronization. In this article, we extend the WaC paradigm in two ways. First, user-video interactions are associated with <b>edit</b> <b>commands</b> and digital ink operations. Second, focusing on collaboration and distribution issues, we employ annotations as simple containers for context information by using them as tags in order to organize, store and distribute information in a P 2 P-based multimedia capture platform. We highlight the design principles of the watch-and-comment paradigm, and demonstrate related results including {{the current version of}} the WACTOOL and its architecture. We also illustrate how an interactive video produced by the WACTOOL can be rendered in an interactive video environment, the Ginga-NCL player, and include results from a preliminary evaluation. FINEPFAPESP[03 / 13930 - 4]CAPESCNP...|$|E
40|$|Domain {{specific}} modeling {{languages are}} of increasing {{importance for the}} development of software and other systems. Meta tools are needed to support rapid development of domain-specific solutions. Usually, domainspecific modeling languages are defined by providing a meta model using the MOF/EMF approach. The language definition can be used to generate a corresponding editor using meta tools such as Eclipse GMF. The meta model defines all symbols and relations of the domain-specific model which can be used to provide an editor with basic <b>editing</b> <b>commands.</b> In addition, further language properties can be formulated by OCL constraints which form the input to a syntax checker. If the modeling language has not only simple syntax structures, syntax-directed editing would increase the convenience. Up to now, meta CASE tools being based on EMF do not provide support for the definition of complex <b>editing</b> <b>commands.</b> A natural way to define <b>editing</b> <b>commands</b> is the formulation by transformation rules, specifying the pre- and post-conditions of each command. The background for this approach is the grammar-based definition of visual modeling languages. While the transformation rules for simple commands can be generated automatically, complex commands are defined by the language designer. The formal basis for this kind of editor definition is given by graph transformation. A meta model-based editor specification extended by such rules shall be used to generate Eclipse plug-ins for domain-specific editing with complex <b>editing</b> <b>commands.</b> ...|$|R
5000|$|Using the {{scripting}} language, {{filters are}} prepared with <b>editing</b> <b>commands</b> to match and replace {{text in the}} downloaded page. Specific pages can be targeted for filtering by matching the page's URL with a specified pattern.|$|R
50|$|Emacs {{also has}} a {{built-in}} tutorial. Emacs displays instructions for performing simple <b>editing</b> <b>commands</b> and invoking the tutorial when it is launched with no file to edit. The tutorial is by Stuart Cracraft and Richard Stallman.|$|R
5000|$|Special <b>editing</b> <b>{{commands}},</b> such as {{commands to}} jump to the beginning {{or the end of}} a function while editing a programming file or commands to validate documents or insert closing tags while working with markup languages such as XML.|$|R
5000|$|XEmacs {{text-editing}} features {{commands to}} manipulate words and paragraphs (deleting them, moving them, moving through them, and so forth), syntax highlighting for making source code easier to read, and [...] "keyboard macros" [...] for performing arbitrary batches of <b>editing</b> <b>commands</b> {{defined by the}} user.|$|R
5000|$|Edlin {{is a line}} editor, and {{the only}} text editor {{provided}} with early versions of MS-DOS. Although superseded in MS-DOS 5.0 and later by the full-screen <b>edit</b> <b>command,</b> and by Notepad in Microsoft Windows, {{it continues to be}} included in the 32-bit versions of current Microsoft operating systems.|$|R
40|$|Composing {{text on the}} {{computer}} is usually heavily dependent on editing, such as moving text around, correcting spacing, and inserting punctuation characters. Dictation systems, based on automatic speech recognition, are not known for their efficiency as an editing tool—something that significantly reduces their potential for freeing the user from the keyboard. Speech recognition has almost invariably been tied to natural language, but we {{point out that this}} approach is inherently disadvantageous in important ways. Instead, given the evidence that humans routinely become experts at sequencing signs not related to natural language, we propose that <b>editing</b> <b>command</b> languages should rely on symbolizations {{similar to that of the}} keyboard. We introduce ShortTalk, an <b>editing</b> language whose <b>command</b> sequences are primitive symbol combinations that are not confusable with dictation. We argue that ShortTalk by construction may solve common editing situations much more efficiently than by use of keyboard and mouse. Our experimental results for ShortTalk indicate that an average information rate of about 16 bps for <b>editing</b> <b>commands</b> is achievable. Thus, editing by speech may be more efficient than by non-verbal means. 1...|$|R
50|$|CRT-based editing terminals, {{which can}} work compatibly {{with a variety}} of {{phototypesetting}} machines, were a major technical innovation in this regard. Keyboarding the original text on a CRT screen, with easy-to-use <b>editing</b> <b>commands,</b> is faster than keyboarding on a Linotype machine. Storing the text magnetically for easy retrieval and subsequent editing also saves time.|$|R
5000|$|Protext was {{designed}} for speed and flexibility [...] and features the usual word processing features, such as a spell checker, thesaurus, auto-correction and good printer support. While later releases supported use of a mouse, the fastest editing with Protext would be using the keyboard, with all commonly used <b>editing</b> <b>commands</b> available with control key combinations.|$|R
30|$|In {{the next}} section we state the problem {{addressed}} in this work. Section  3 presents the I/O framework discussed in this paper. Section  4 provides a brief introduction to Clive and to its Go dialect as used in the examples that follow. Section  5 describes the Go I/O framework used in Clive. Section  6 provides examples of file processing commands using it. Sections  7, 8, and 9 introduce other examples for file <b>editing</b> <b>commands,</b> commands using non-linear pipelines, and user interfaces. Sections  10 and 11 describe the implementation and discuss some drawbacks and lessons learned. Sections  12 and 13 provide quantitative evaluation results and discuss related and further work.|$|R
50|$|Word {{processors}} typically {{require the}} use of special function keys to access <b>editing</b> <b>commands</b> as opposed to text entry. This proved to be a challenge on the TRS-80 Model I and Model III computers, as their keyboards had no non-typewriter modifier keys—not even a Control key. Instead, Tandy drafted the '@' key to access features such as margin control and load/save.|$|R
5000|$|The early screen {{modes of}} Emacs, for example, were {{directly}} inspired by WAITS' [...] "E" [...] editor -- {{one of a}} family of editors that were the first to do real-time editing, in which the <b>editing</b> <b>commands</b> were invisible and where one typed text at the point of insertion/overwriting. The modern style of multi-region windowing is said to have originated there.|$|R
3000|$|In editors such as Sam [10] {{a command}} {{language}} is provided {{to let the}} user write <b>editing</b> <b>commands.</b> In Clive, the ix editor does not include a command language, but uses plain system commands. This can be done because the I/O framework discussed in this paper permits data to have structure (although the system simply forwards messages without interpreting them, like UNIX would do.) [...]...|$|R
30|$|Document {{formatting}} {{systems like}} roff [23] use pipelines with different commands to process and filter document streams. They {{are similar in}} spirit to the approach used in Clive for processing I/O streams (at least for <b>editing</b> <b>commands).</b> Of course, roff like tools rely on conventions {{to be able to}} cooperate in a pipe-line more than they rely on the mechanisms provided by the underlying system, and they are specific-purpose tools.|$|R
30|$|In {{the context}} of digital TV systems, we can {{intuitively}} see the influence of incremental validation in the conventional process of authoring, {{but this is not}} the only situation where such validation can offer performance gains. The fact that set-top boxes (device that executes interactive applications) are environments with limited computing resources raises the need for validation techniques that avoid redundant checks in such a limited hardware. A particular case of this need is the validation of applications created within the set-top box in TV viewers’ households (Social TV) [7], since this validation must be done without affecting performance. On the other hand, systems such as ISDB-Tb [4] allow broadcasters to send <b>editing</b> <b>commands</b> to applications while they are being displayed, allowing what is known as live editing of content [8]. Before applying such edits, first it is necessary to validate them in order to make sure that the <b>editing</b> <b>commands</b> will result in consistent, accurate and coherent documents. From the above discussion, we can notice that the need for incremental validation mechanisms is present in various circumstances.|$|R
40|$|The Local Editing Protocol {{allows a}} local {{programmable}} terminal {{to execute the}} most common <b>editing</b> <b>commands</b> on behalf of an extensible text editor on a remote system, thus greatly improving speed of response without reducing flexibility. The Line Saving Protocol allows the local system to save text which is not displayed, and display it again later when it is needed, {{under the control of}} the remote editor. Both protocols are substantially system and editor independent...|$|R
50|$|Emacs is {{primarily}} a text editor and is designed for manipulating pieces of text, although {{it is capable of}} formatting and printing documents like a word processor by interfacing with external programs such as LaTeX, Ghostscript or a web browser. Emacs provides commands to manipulate and differentially display semantic units of text such as words, sentences, paragraphs and source code constructs such as functions. It also features keyboard macros for performing user-defined batches of <b>editing</b> <b>commands.</b>|$|R
40|$|Pegasus is a {{prototype}} drawing system for rapid geometric design. Using Pegasus, a user can construct precise geometric diagrams easily without struggling with complicated <b>editing</b> <b>commands.</b> Two novel interaction techniques are introduced: interactive beautification and predictive drawing. Interactive beautification receives the user's free stroke input and beautifies it by considering possible geometric constraints among segments by generating multiple candidates to prevent recognition errors. Predictive drawing predicts the user's next drawing operation {{based on the}} spatial relationship among existing segments on the screen...|$|R
40|$|The {{aim of this}} {{bachelor}} {{thesis is}} to design and implement a system which can edit planar tiles. It can replace some tiles by their instances, or pattern, preserving continuity on the edges. Editor of floor conguration, editor of tiles (instances) and component visualizating a bigger part of floor will be necessary. The application will use square and rectangle tiles. It will have at least basic graphical <b>editing</b> <b>commands</b> and support for automatic or semiautomatic satisfaction of continuity between neighbouring tiles...|$|R
50|$|In computing, a {{line editor}} is a text editor {{in which each}} <b>editing</b> <b>command</b> applies {{to one or more}} {{complete}} lines of text designated by the user. Line editors predate screen-based text editors and originated in an era when a computer operator typically interacted with a teleprinter (essentially a printer with a keyboard), with no video display, and no ability to move a cursor interactively within a document. Line editors were also a feature of many home computers, avoiding the need for a more memory-intensive full-screen editor.|$|R
50|$|Peripheral {{processor}} (PP or PPU) {{instructions are}} {{completely different from}} CPU instructions. Peripheral processor hardware is simpler; it has an 18-bit A (accumulator register, a 12-bit Program Address register, a 12-bit Q register (not programmer-visible), and a 22-bit R register (used to accomplish address relocation during central memory read and write instructions on Cyber 180 systems). No special job validation was required to assemble peripheral processor programs, but to be executed, such programs were required to installed into the operating system via special system <b>editing</b> <b>commands.</b>|$|R
5000|$|Note: {{the term}} [...] "linkage editor" [...] {{should not be}} {{construed}} as implying that the program operates in a user-interactive mode (like, for example, a text editor). It is strictly intended for batch-mode execution, with the <b>editing</b> <b>commands</b> being supplied by the user on sequentially organized records, such as [...] "unit record" [...] media (a card deck, for example) or DASD media (a disk file, for example), but a tape is also supported, and tapes were often used during the initial installation of the OS.|$|R
