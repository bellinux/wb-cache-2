429|298|Public
5|$|PHP 5 {{introduced}} {{private and}} protected member variables and methods, along with abstract classes, final classes, abstract methods, and final methods. It also introduced a standard way of declaring constructors and destructors, {{similar to that}} of other object-oriented languages such as C++, and a standard exception handling model. Furthermore, PHP 5 added interfaces and allowed for multiple interfaces to be implemented. There are special interfaces that allow objects to interact with the runtime system. Objects implementing ArrayAccess can be used with array syntax and objects implementing <b>Iterator</b> or IteratorAggregate can be used with the foreach language construct. There is no virtual table feature in the engine, so static variables are bound with a name instead of a reference at compile time.|$|E
25|$|An {{enumerator}} is an <b>iterator.</b>|$|E
25|$|The in c clause {{specifies}} the container, {{which may}} be a list, set, sum, product, unevaluated function, array, or an object implementing an <b>iterator.</b>|$|E
40|$|We discuss {{several kinds}} of custom <b>iterators</b> for use with the STL that are {{substantially}} different from the <b>iterators</b> {{that come with the}} STL. We present class templates that implement these custom <b>iterators</b> in a generic manner. Contents 1. Introduction 2. STL <b>Iterators</b> and Custom <b>Iterators</b> 3. Combining <b>Iterators</b> 4. Processing <b>Iterators</b> 5. Dereferencing <b>Iterators</b> 6. <b>Iterators</b> to Members 7. Generating <b>Iterators</b> 8. Conclusion 9. References Introduction We will assume that the reader possesses a basic working knowledge of the C++ Standard Template Library (STL). The <b>iterators</b> that come with the STL typically represent ranges within an STL container. In other words, the range of data items that is represented by a pair of these <b>iterators</b> is present in memory {{in the form of an}} STL container object. We have found many situations where a program needs to iterate through sequentially structured data, but this data is not or should not be present in memory in the form of a range in a contain [...] ...|$|R
50|$|The STL {{implements}} {{five different}} types of <b>iterators.</b> These are input <b>iterators</b> (that can only be used to read a sequence of values), output <b>iterators</b> (that can only be used to write a sequence of values), forward <b>iterators</b> (that can be read, written to, and move forward), bidirectional <b>iterators</b> (that are like forward <b>iterators,</b> but can also move backwards) and s (that can move freely any number of steps in one operation).|$|R
40|$|Software {{libraries}} rely increasingly on <b>iterators</b> {{to provide}} generic traversal of data structures. These <b>iterators</b> {{can be represented}} either as objects that maintain state or as programs that suspend and resume control. This paper addresses two problems that remain {{in the use of}} <b>iterators</b> today: The first problem is that <b>iterators</b> represented as state-saving objects in languages such as C++ or Java typically have logic that is much more complicated than control–based <b>iterators.</b> This paper presents a program structuring technique that allows object–based <b>iterators</b> to be implemented with the same clarity as control–based <b>iterators.</b> The second problem is that the usual implementations of control–based <b>iterators</b> are not sufficiently efficient for high-performance applications. This paper presents a code optimization technique that can be applied to control–based iteration to produce efficient natural loops at the machine code level. Combined, these two results allow <b>iterators</b> for complex data structures to be easily written and efficiently implemented...|$|R
25|$|A pull parser {{creates an}} <b>iterator</b> that {{sequentially}} visits the various elements, attributes, and data in an XML document. Code that uses this <b>iterator</b> can test the current item (to tell, for example, {{whether it is}} a start-tag or end-tag, or text), and inspect its attributes (local name, namespace, values of XML attributes, value of text, etc.), and can also move the <b>iterator</b> to the next item. The code can thus extract information from the document as it traverses it. The recursive-descent approach tends to lend itself to keeping data as typed local variables in the code doing the parsing, while SAX, for instance, typically requires a parser to manually maintain intermediate data within a stack of elements that are parent elements of the element being parsed. Pull-parsing code can be more straightforward to understand and maintain than SAX parsing code.|$|E
25|$|Where some_iterable_object {{is either}} a data {{collection}} that supports implicit iteration (like a list of employee's names), or {{may in fact be}} an <b>iterator</b> itself. Some languages have this in addition to another for-loop syntax; notably, PHP has this type of loop under the name for each, as well as a three-expression for-loop (see below) under the name for.|$|E
2500|$|In {{computer}} science, a for-loop (or {{simply for}} loop) [...] is a control flow statement for specifying iteration, which allows code {{to be executed}} repeatedly. The syntax of a for-loop {{is based on the}} heritage of the language and the prior programming languages it borrowed from, so programming languages that are descendants of or offshoots of a language that originally provided an <b>iterator</b> will often use the same keyword to name an <b>iterator,</b> e.g., descendants of ALGOL use [...] "for", while descendants of Fortran use [...] "do." [...] There are other possibilities, for example COBOL which uses [...] "PERFORM VARYING".|$|E
50|$|XL <b>iterators</b> allow programmers to {{implement}} both generators and <b>iterators.</b>|$|R
40|$|Iteration is an {{operation}} that traverses the objects of a collection object. <b>Iterators</b> are operators/methods widely used for iteration on a collection of objects. However, <b>iterators</b> {{were considered to be}} ad hoc and to be a sign of weakness in object-oriented programming languages. There is a need to formalize <b>iterators</b> and to study their strength and weaknesses. In this paper we first propose a taxonomy of <b>iterators</b> {{based on the number of}} data states and the number of control points. The taxonomy identifies four categories of <b>iterators.</b> The simplest one can be implemented straightforwardly in an object-oriented language. <b>Iterators</b> of other categories need transformations and are more difficult to design and implement. Finally, we compare the efficiency of <b>iterators</b> with other implementations of iteration. The results show that all iteration techniques tested, including <b>iterators,</b> have been well optimized and are almost as fast as directly coded loops using recent C++ compilers...|$|R
50|$|With {{respect to}} the field of {{reinforcement}} learning, learning automata are characterized as policy <b>iterators.</b> In contrast to other reinforcement learners, policy <b>iterators</b> directly manipulate the policy π. Another example for policy <b>iterators</b> are evolutionary algorithms.|$|R
2500|$|The [...]NET 2.0 Framework allowed C# to {{introduce}} an <b>iterator</b> that provides generator functionality, using a [...] construct similar to [...] in Python. With a , the function automatically keeps its state during the iteration.|$|E
2500|$|This type of for-loop is a {{generalisation}} of the numeric range type of for-loop, as {{it allows}} for the enumeration of sets of items other than number sequences. It is usually characterized {{by the use of}} an implicit or explicit <b>iterator,</b> in which the loop variable takes on each of the values in a sequence or other data collection. A representative example in Python is: ...|$|E
2500|$|Pull parsing {{treats the}} {{document}} {{as a series}} of items read in sequence using the <b>iterator</b> design pattern. This allows for writing of recursive descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLPullParser in Smalltalk, XMLReader in PHP, ElementTree.iterparse in Python, System.Xml.XmlReader in the [...]NET Framework, and the DOM traversal API (NodeIterator and TreeWalker).|$|E
40|$|Collections and <b>iterators</b> {{are widely}} used in the Object {{community}} since they are standards ofthe Java language. We present a certified functional implementation of collections and <b>iterators</b> addressing the Specification And Verification of Component Based Systems 2006 challenge. More precisely we describe a FoCaLiZe implementation providingthese functionalities. Our approach uses inheritance and parameterization to describe functional <b>iterators.</b> Our code can be run in Ocaml andis certified using Coq. We provide general specifications for collections,iterators and removable <b>iterators</b> together with complete implementationfor collections using lists as representation and <b>iterators</b> over those...|$|R
5000|$|Java <b>iterators</b> and {{collections}} can be automatically converted into Scala <b>iterators</b> {{and collections}}, respectively, simply {{by adding the}} single line ...|$|R
50|$|The global / {{functions}} were augmented with / functions, which return constant <b>iterators,</b> and / and / which return reverse <b>iterators.</b>|$|R
50|$|From {{the field}} of {{software}} engineering, a Fail Fast <b>Iterator</b> is an <b>iterator</b> that attempts to raise an error if the sequence of elements processed by the <b>iterator</b> is changed during iteration.|$|E
50|$|In {{object-oriented}} programming, the <b>iterator</b> {{pattern is}} a design pattern {{in which an}} <b>iterator</b> is used to traverse a container and access the container's elements. The <b>iterator</b> pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.|$|E
5000|$|In Magik {{generator}} {{methods are}} called <b>iterator</b> methods. New <b>iterator</b> methods {{can be defined}} using the [...] and [...] statements: ...|$|E
50|$|In Scala, <b>iterators</b> have a rich set {{of methods}} similar to collections, {{and can be used}} {{directly}} in for loops. Indeed, both <b>iterators</b> and collections inherit from a common base trait - scala.collection.TraversableOnce. However, because of the {{rich set of}} methods available in the Scala collections library, such as map, collect, filter etc., it is often not necessary to deal with <b>iterators</b> directly when programming in Scala.|$|R
50|$|The {{philosophy}} of the Standard Template Library (STL) embedded in the C++ Standard Library is to use generic algorithms {{in the form of}} templates using <b>iterators.</b> <b>Iterators</b> are hard to implement efficiently which caused Alexander Stepanov to blame some compiler writers for their initial weak performance. The complex categories of <b>iterators</b> have also been criticized, and ranges have been proposed for the C++ standard library.|$|R
5000|$|One {{big problem}} is that <b>iterators</b> often deal with heap {{allocated}} data in the C++ containers and becomes invalid if the data is independently moved by the containers. Functions that change {{the size of the}} container often invalidate all <b>iterators</b> pointing to it, creating dangerous cases of undefined behavior. Here is an example where the <b>iterators</b> in the for loop get invalidated because of the std::string container changing its size on the heap: ...|$|R
5000|$|Any {{user-defined}} {{class can}} support standard iteration (either implicit or explicit) by defining an [...] method that returns an <b>iterator</b> object. The <b>iterator</b> object then needs {{to define a}} [...] method that returns the next element and an [...] method that returns the next <b>iterator</b> object to use.|$|E
5000|$|C++ {{implements}} iterators {{with the}} semantics of pointers in that language. In C++, a class can overload {{all of the}} pointer operations, so an <b>iterator</b> can be implemented that acts more or less like a pointer, complete with dereference, increment, and decrement. This has the advantage that C++ algorithms such as [...] can immediately be applied to plain old memory buffers, {{and that there is}} no new syntax to learn. However, it requires an [...] "end" [...] <b>iterator</b> to test for equality, rather than allowing an <b>iterator</b> to know that it has reached the end. In C++ language, we say that an <b>iterator</b> models the <b>iterator</b> concept.|$|E
5000|$|An <b>iterator</b> {{may allow}} the {{container}} object {{to be modified}} without invalidating the <b>iterator.</b> For instance, once an <b>iterator</b> has advanced beyond the first element {{it may be possible}} to insert additional elements into the beginning of the container with predictable results. With indexing this is problematic since the index numbers must change.|$|E
40|$|We {{present a}} new {{language}} construct, filtered <b>iterators,</b> for safe and robust input processing. Filtered <b>iterators</b> are designed to eliminate many common input-processing errors while enabling robust continued execution. The design is inspired by (a) observed common input-processing errors and (b) continued execution strategies that are implemented by developers fixing input validation errors. Filtered <b>iterators</b> decompose inputs into input units, atomically and automatically discarding units that trigger errors. Statistically significant results from a developer study highlight the difficulties that developers encounter when developing input-processing code using standard language constructs. These results also demonstrate the effectiveness of filtered <b>iterators</b> in eliminating many of these difficulties and enabling developers to produce safe and robust input-processing code...|$|R
30|$|<b>Iterators</b> are j and n.|$|R
50|$|<b>Iterators</b> are {{a useful}} {{abstraction}} of input streams - {{they provide a}} potentially infinite iterable (but not necessarily indexable) object. Several languages, such as Perl and Python, implement streams as <b>iterators.</b> Alternative implementations of stream include data-driven languages, such as AWK and sed.|$|R
50|$|<b>Iterator</b> {{safety is}} defined {{separately}} {{for the different}} types of standard containers, in some cases the <b>iterator</b> is very permissive in allowing the container to change while iterating.|$|E
5000|$|Iterators {{are usually}} used in pairs, where one {{is used for}} the actual {{iteration}} and the second serves to mark the end of the collection. The iterators are created by the corresponding container class using standard methods such as [...] and [...] The <b>iterator</b> returned by [...] points to the first element, while the <b>iterator</b> returned by [...] is a special value that does not reference any element. When an <b>iterator</b> is advanced beyond the last element it is by definition equal to the special end <b>iterator</b> value.|$|E
50|$|In {{computer}} programming, an <b>iterator</b> is {{an object}} that enables a programmer to traverse a container, particularly lists. Various types of iterators are often provided via a container's interface. Though the interface and semantics of a given <b>iterator</b> are fixed, iterators are often implemented {{in terms of the}} structures underlying a container implementation and are often tightly coupled to the container to enable the operational semantics of the <b>iterator.</b> Note that an <b>iterator</b> performs traversal and also gives access to data elements in a container, but does not perform iteration (i.e., not without some significant liberty taken with that concept or with trivial use of the terminology). An <b>iterator</b> is behaviorally similar to a database cursor. Iterators date to the CLU programming language in 1974.|$|E
50|$|Containers are {{sometimes}} implemented {{in conjunction with}} <b>iterators.</b>|$|R
40|$|Fully-parallel {{execution}} of a high-level data-parallel language based on nested sequences, higher order functions and generalized <b>iterators</b> can be realized in the vector model using a suitable representation of nested sequences and a small set of transformational rules to distribute <b>iterators</b> through the constructs of the language. 1...|$|R
5000|$|It is like <b>Iterators</b> in {{that if a}} {{fatal error}} occurs, it notifies the {{observer}} separately (by calling a second function), and when all the items have been sent, it completes (and notifies the observer by calling a third function). It also borrows many of its operators from <b>Iterators.</b>|$|R
