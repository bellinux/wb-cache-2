130|47|Public
5000|$|Open & Closed Flowgraphs. An open <b>flowgraph</b> {{contains}} strictly dependent or strictly independent nodes; {{otherwise it}} is a closed <b>flowgraph.</b>|$|E
5000|$|GRC is {{effectively}} a Python code-generation tool. When a <b>flowgraph</b> is [...] "compiled" [...] in GRC, it generates Python code {{that creates the}} desired GUI windows and widgets, and creates and connects the blocks in the <b>flowgraph.</b>|$|E
5000|$|CryEngine has a node-based visual {{programming}} language called <b>FlowGraph.</b>|$|E
40|$|The aim of {{this paper}} is to generalise the Fenton-Whitty-Kaposi (FWK) {{approach}} to structure software metrics by considering arbitrary sets of decomposition operations for <b>flowgraphs.</b> In the FWK approach decomposition of <b>flowgraphs</b> is unique, but the number of associated metric functions is not finite and these functions are all independent. In general, the decomposition of <b>flowgraphs</b> is not unique, which leads to constraints on the associated metric functions. Here we derive these constraints explicitly for two special cases, where we consider only the two operations sequencing and nesting as decomposition operations. It is shown that the two resulting classes of structure metrics are contained in the class of recursive structure metrics of the FWK approach. 2 1 Introduction In the Fenton-Whitty-Kaposi (FWK) approach to software structure metrics [1, 2, 3], software is modelled in terms of <b>flowgraphs.</b> There are two operations on <b>flowgraphs,</b> sequencing and nesting, with which flowgrap [...] ...|$|R
50|$|The general {{notion of}} flow graph {{has been called}} program graph, but the same term has also been used to denote only control flow graphs. Flow graphs have also been called unlabeled <b>flowgraphs,</b> and proper <b>flowgraphs.</b> These graphs are {{sometimes}} used in software testing.|$|R
40|$|An {{implementation}} oriented algorithm for lazy code {{motion is}} presented that minimizes {{the number of}} computations in programs while suppressing any unnecessary code motion {{in order to avoid}} superfluous register pressure. In particular, this variant of the original algorithm for lazy code motion works on <b>flowgraphs</b> whose nodes are basic blocks rather than single statements, as this format is standard in optimizing compilers. The theoretical foundations of the modified algorithm are given in the first part, where t-refined <b>flowgraphs</b> are introduced for simplifying the treatment of <b>flowgraphs</b> whose nodes are basic blocks. The second part presents the `basic block' algorithm in standard notation, and gives directions for its implementation in standard compiler environments. Keywords Elimination of partial redundancies, code motion, data flow analysis (bit-vector, unidirectional, bidirectional), nondeterministic <b>flowgraphs,</b> t-refined flow graphs, critical edges, lifetimes of registers, com [...] ...|$|R
5000|$|... #Caption: Editing a GNU Radio <b>flowgraph</b> in the GNU Radio Companion ...|$|E
5000|$|... #Caption: A simple RC {{system and}} its closed <b>flowgraph.</b> A [...] "dummy" [...] {{transmittance}} Z(s) is introduced to close the system.|$|E
50|$|Leadwerks Game Engine is {{marketed as}} an easy to learn game {{development}} system, {{with three layers}} of development intended to ease the learning curve. The <b>flowgraph</b> system and visual editor allow simple games to be created without programming. Lua script allows more advanced game mechanics and custom behavior, while C++ {{can be used for}} low-level programming and importing external libraries.|$|E
40|$|AbstractGraph {{theory is}} used to model program control {{structures}} rigorously as <b>flowgraphs.</b> Formal methods are defined which allow the classification and reconstruction of <b>flowgraphs</b> {{in terms of an}} arbitrary set of primitives. The criterion of classification sheds new light on a classical graph-theoretic characterisation of D-structuredness, and provides an extension of this characterisation in the case when the notion of structuredness is generalised...|$|R
5000|$|Closed <b>flowgraphs</b> {{describe}} closed {{systems and}} have been utilized to provide a rigorous theoretical basis for topological techniques of circuit analysis.|$|R
40|$|Generalised {{approach}} to software structure rnetrics by P. M. van den Broek and KG. van den Berg The {{aim of this}} paper is to generalise the Fenton-Witty-Kaposi (FWK) {{approach to}} structure software metrics by considering arbitrary sets of decomposition operations for <b>flowgraphs.</b> In the FWK approach, decomposition of <b>flowgraphs</b> is unique, but the number of associated metric functions is not finite and these functions are all independent. In general, the decomposition of <b>flowgraphs</b> is not unique, which leads to constraints on the associated metric functions. Here we derive these constraints explicitly for two special cases, where we consider only the two operations sequencing and nesting a s decomposition operations. It is shown that the two resulting classes of structure metrics are contained in the class of recursive structure metrics of the FWK approach. ...|$|R
50|$|The {{following}} illustration and {{its meaning}} were introduced by Mason to illustrate basic concepts:In the simple flow graphs of the figure, a functional dependence of a node {{is indicated by}} an incoming arrow, the node originating this influence {{is the beginning of}} this arrow, and in its most general form the signal flow graph indicates by incoming arrows only those nodes that influence the processing at the receiving node, and at each node, i, the incoming variables are processed according to a function associated with that node, say Fi. The <b>flowgraph</b> in (a) represents a set of explicit relationships:Node x1 is an isolated node because no arrow is incoming; the equations for x2 and x3 have the graphs shown in parts (b) and (c) of the figure.|$|E
40|$|An {{algorithm}} is presented which produces a {{program with the}} minimum number of goto statements. We can apply the algorithm not only to an arbitrary loop free <b>flowgraph</b> {{but also to the}} class of “gate flowgraph” in which all entries and exits are particular for every cycle of the <b>flowgraph.</b> The algorithm has an O(n) time bound where n is the number of nodes in the <b>flowgraph.</b> Every <b>flowgraph</b> can be trivially transformed into a gate <b>flowgraph...</b>|$|E
40|$|Abstract: 2 ̆ 2 ASSIGN is a {{tool for}} {{building}} large-scale applications, in particular signal processing applications, on distributed- memory multicomputers. The programming model is the familiar coarse- grained <b>flowgraph,</b> where nodes correspond to computations and directed edges correspond to FIFO queues. Given a <b>flowgraph</b> description of an application, ASSIGN compiles the <b>flowgraph</b> onto the processors of a distributed-memory parallel computer, automatically handling such details as partitioning the <b>flowgraph</b> and placing and routing the partitioned <b>flowgraph.</b> The first target machine is iWarp, a multicomputer system developed jointly by Intel and Carnegie Mellon. 2 ̆...|$|E
50|$|These <b>flowgraphs</b> can {{be written}} in either C++ or the Python {{programming}} language. The GNU Radio infrastructure is written entirely in C++, {{and many of the}} user tools are written in Python.|$|R
40|$|AbstractIrreducible program fowgraphs are {{important}} {{in the study of}} program structuredness. In this paper a partial order is defined on the set of irreducible <b>flowgraphs.</b> This allows us to characterise those programs which can be re-structured by node splitting, where structuredness is defined in terms of any “subgraph-closed” set of irreducible <b>flowgraphs.</b> This includes all sets of structural components available in modern programming languages such as Ada, Modula- 2, and C. In particular, we apply our results to the study of multiple-exit and multilevel exit control structures, giving a new characterisation of the BJn-charts of Kosaraju and a sharpening of two results of Peterson, Kasami, and Tokura...|$|R
50|$|In {{computer}} science, rooted graphs {{in which}} the root vertex can reach all other vertices are called flow graphs or <b>flowgraphs.</b> Sometimes an additional restriction is added specifying that a flow graph must have a single exit (sink) vertex as well.|$|R
40|$|The legal {{articles}} {{are difficult to}} understand for a nonspecialist. We think that understanding becomes easier if the legal {{articles are}} expressed {{in the form of}} the <b>flowgraph.</b> Since legal articles contain lots of information, the <b>flowgraph</b> size becomes large when this information is expressed {{in the form of the}} <b>flowgraph.</b> The display size and the resolution of the computers are limited. It is hard to handle such information in the computer display. Therefore, we need techniques which express the <b>flowgraph</b> in a compact manner...|$|E
40|$|Abstract-The {{concept of}} a data <b>flowgraph</b> is formalized as a bipartite {{directed}} graph. Each execution sequence of a computer program has a corresponding data <b>flowgraph</b> which describes functionally {{what happens to the}} data if that execution sequence is followed. The data <b>flowgraph</b> gives information which is useful in analyzing parallel processing, test case preparation, error analysis, and program verification. An attack aircraft tactical system is used to illustrate how the concept of data flowgraphs is applied to analyze real-time systemrs. Index Terms-Bipartite graph, control complexity, data <b>flowgraph,</b> discrete systems, execution sequence, independence, parallel processes, program analysis. I...|$|E
40|$|Malware is a {{pervasive}} problem in distributed computer and network systems. Identification of malware variants provides great benefit in early detection. Control flow {{has been proposed}} as a characteristic that can be identified across variants, resulting in classificaiton empoying <b>flowgraph</b> based signatures. Static analysis is widely used to construct the signatures but can be ineffective if malware undergoes a code packing transforrmation to hide its real content. This thesis proposes a novel system, names Malwise, for malware classification using a fast application level emulator to reverse the code packing transformation, and two <b>flowgraph</b> matching algorithms to perform classification: exact <b>flowgraph</b> matching and approximate <b>flowgraph</b> matching" [...] Abstract...|$|E
40|$|An implementation-oriented {{algorithm}} for lazy code {{motion is}} presented that minimizes {{the number of}} computations in programs while suppressing any unnecessary code motion {{in order to avoid}} superfluous register pressure. In particular, this variant of the original algorithm for lazy code motion works on <b>flowgraphs</b> whose nodes are basic blocks rather than single statements, since this format is standard in optimizing compilers. The theoretical foundations of the modified algorithm are given in the first part, where t-refined <b>flowgraphs</b> are introduced for simplifying the treatment of flow graphs whose nodes are basic blocks. The second part presents the “basic block ” algorithm in standard notation and gives directions for its implementation in standard compiler environments...|$|R
40|$|FunnyQT {{is a model}} {{querying}} {{and model}} transformation library for the functional Lisp-dialect Clo-jure providing a rich and efficient querying and transformation API. This paper describes the FunnyQT solution to the TTC 2013 <b>Flowgraphs</b> Transformation Case. It solves all four tasks, and it has won the best efficiency award for this case. ...|$|R
40|$|This paper {{provides}} {{a comparison of}} three looping operations: Kleene's repetition (`star'), Elgot's iteration (`dagger') and feedback (`uparrow'). The comparison {{is based on an}} algebraic study of an algebra for <b>flowgraphs</b> (this is a generic name for digraph models like: automata, nets, flowchart schemes, etc.), called biflow. Equivalent presentations of biflows and biflows over algebraic or matrix theories are given using these operations. Finally, there are given extensions of these algebras to cope with axiomatisations of the regular languages and regular trees. 1 Introduction Different characterizations of regular languages were given in the early book of Marcus, [Mar 64]. Here we deal with algebraic presentations of regular languages, regular trees and <b>flowgraphs</b> (automata, nets, flowchart schemes, etc.). In order to get an algebraic theory of computation one needs an axiomatic looping operation. This may be Kleene's repetition (cf. [Con 71], for example), Elgot's iteration [Elg 75] [...] ...|$|R
40|$|Abstract. Multimedia {{middleware}} {{needs to}} support {{a wide variety of}} devices together with their respective data formats. This becomes increasingly relevant and difficult in a distributed environment where new devices and formats can become available at any time and {{must be taken into account}} when deciding how to set up a <b>flowgraph</b> of distributed multimedia components. In this paper we present an automatic algorithm for configuring and connecting a high-level <b>flowgraph</b> of multimedia components. Given this abstract <b>flowgraph</b> of participating devices and key components, the algorithm automatically selects necessary additional components, chooses suitable formats, and connects the <b>flowgraph,</b> while trying to achieve the best possible quality. ...|$|E
40|$|<b>Flowgraph</b> models {{provide an}} {{alternative}} approach in modeling a multi-state stochastic process. One {{of the most widely}} used stochastic processes that have many real-world applications especially in actuarial models is the Markov jump process or continuous- time Markov chain. However, finding waiting time distributions between any two states in a Markov jump process can be very difficult. <b>Flowgraph</b> analysis for Markov jump process comprises of modeling the possible states of the process, the interstates waiting time distribution, and working on the moment generating function domain to obtain the total waiting time distribution in form of density or survival function. This paper gives the theory and computational method of <b>flowgraph</b> analysis, uses it in Markov process problems, and compares the traditional Markov process construction method with the <b>flowgraph</b> method to demonstrate the convenience and practicality of <b>flowgraph</b> analysis. Comment: 12 pages, 22 Figures, 7 th European Business Research Conference held in Rome, Ital...|$|E
40|$|The {{concept of}} a data <b>flowgraph</b> is formalized as a bipartite {{directed}} graph. Each execution sequence of a computer program has a corresponding data <b>flowgraph</b> which describes functionally {{what happens to the}} data if that execution sequence is followed. the data <b>flowgraph</b> gives information which is useful in analyzing parallel processing, test case preparation, error analysis, and program verification. An attach aircraft tactical system is used to illustrate how the concept of data flowgraphs is applied to analyze real-time systems...|$|E
40|$|In this {{document}} we describe use cases {{and its role}} in the software development process. There is no precise semantics of use cases. Use case descriptions can be formalized with control <b>flowgraphs.</b> Based on this formalization, the use of the standard technique of sequence charts can be improved, in particular for the uses relation and the extend relation between use cases...|$|R
40|$|An Effort-length-complexity metrics {{model for}} {{software}} (Elc) based on measurement theory is introduced. The model {{is defined by}} e(p) = l(p) c(p), where p is any piece of software, e(p) the effort in developing it, l(p) its length, and c(p) its structural complexity. Rules for computing Elc for the basic structured constructs are given. These make Elc sensitive to sequencing, nesting and modularization. A Scheme function is supplied for computing e; l and c for any program or collection of programs given in form of <b>flowgraphs.</b> The tool may be callibrated to user's model of complexity by specifying some parameters. Arguments for the usability of Elc are supplied by deriving theoretical properties and by case studies. Keywords: Effort, length, stuctural complexity, hierarchical measure, software metrics, <b>flowgraphs</b> 1 Introduction One of the first software quality measures proposed is McCabe's cyclomatic complexity measure. As described by McCabe, {{the primary purpose of}} the measure is [...] ...|$|R
40|$|A mathematicalsatyle of {{description}} of simulation models is introduced {{as an alternative}} to more traditional methods, like <b>flowgraphs</b> and programming lanquaqes, which are less suited to represent the system at intermediate levels of development of the model. Understandability of the model, machine generetion of simulation code and proof of correctness are at least three reasons in favour this approach. A general modeling criterion is outlined and applied to a specific case study...|$|R
40|$|AbstractWe {{give the}} syntax and {{semantics}} {{of a language}} for expressing recursive systems of <b>flowgraph</b> equations. The flowgraphs may have “GOTO” nodes, i. e., nodes which represent edges external to the <b>flowgraph,</b> but which may become internal if the <b>flowgraph</b> is composed with other flowgraphs. This {{requires the use of}} continuation semantics. We give an elementary proof that the language we use to express flowgraphs, containing iteration, pairing, and composition operators, is sufficient to do so. Continuation semantics is then defined via this language...|$|E
40|$|AbstractWe {{present an}} {{approach}} to maintaining consistency between code and specification during refactoring, where a specification comprises several UML diagrams of different types. Code is represented as a <b>flowgraph,</b> and the <b>flowgraph</b> and UML diagrams constitute different views of a software system. A refactoring is modelled {{as a set of}} distributed graph transformations, organized into transformation units...|$|E
40|$|<b>Flowgraph</b> {{models are}} useful {{in a wide variety}} of systems {{engineering}} and survival analysis problems. They are especially useful for analyzing time to event data and constructing corresponding Bayes predictive distributions. When a continuous time semi-Markov process defines transition times between a finite number of states and interest focuses on estimat- ing densities, survival/reliability and hazard functions, or predictive distributions, <b>flowgraph</b> models provide a way of presenting the model and an associated method for data analysis. I will introduce <b>flowgraph</b> models and related saddlepoint methods for problems in systems engineering and multistate modelling as arises in survival analysis. An important advantage of <b>flowgraph</b> / saddlepoint methods is the ability to construct likelihoods for incomplete data. I will focus on modelling using data from a study on diabetic retinopathy. I will discuss advantages over direct simulation and also situations where data are missing but known to the investigator. Much of this work has been applied to cellular telephone networks and, time permitting, I will discuss that as well...|$|E
40|$|In {{this paper}} {{we present a}} new {{approach}} for incremental data flow analysis based on elimination methods. Unlike previous elimination-based incremental data flow analysis, our approach can handle arbitrary non-structural and structural changes to program <b>flowgraphs,</b> including irreducibility. We use properties of dominance frontiers and iterated dominance frontiers for updating data flow solutions. These properties are applicable to both reducible and irreducible <b>flowgraphs.</b> Since we use properties of dominance frontiers (and iterated dominance frontiers) we also give a simple algorithm for updating the dominance frontier relation. The dominance frontier update algorithm is based on our previous work for updating dominator trees. i Contents 1 Introduction 1 2 Exhaustive Elimination Method: An Overview 2 3 Our Approach 5 3. 1 Initial and Final Flow Equations : : : : : : : : : : : : : : : : : : : : : : : : : : : 5 3. 2 Basic Steps : : : : : : : : : : : : : : : : : : : : : : : : : : : : : [...] ...|$|R
40|$|Traditional {{worst-case}} {{execution time}} (WCET) analysis must make very pessimistic assumptions regarding {{the cost of}} preemptions for a real-time job. For every potential preemption point, the analysis must add to the WCET of a job the cache-related preemption delay (CRPD) incurred due to the contention for memory resources with other jobs in the system. However, recent work has shown that CRPD can vary at each preemption point (due to the cache lines that must be reloaded for subsequent code after the preemption). Using this observation and information obtained from schedulability analysis on the maximum length of the non-preemptive region of a job, we seek to find the optimal set of explicit preemption-points (EPPs) that minimize the WCET and ensure system schedulability. Utilizing graph grammars and dynamic programming, we develop a pseudo-polynomial-time algorithm {{that is capable of}} analyzing jobs that can be represented by control <b>flowgraphs</b> with arbitrarily-nested conditional structures. This algorithm extends previous work that could only handle sequential <b>flowgraphs.</b> Exhaustive experiments are included to show that the proposed approach is able to significantly improve the bounds on the worst-case execution times of limited preemptive tasks...|$|R
40|$|Abstract. This paper {{presents}} {{a solution to}} the <b>Flowgraphs</b> case study for the Transformation Tool Contest 2013 (TTC 2013). Starting from Java source code, we execute a chain of model transformations to derive a simplified model of the program, its control flow graph and its data flow graph. Finally we develop a model transformation that validates the program flow by comparing it with a set of flow specifications written in a domain specific language. The proposed solution has been implemented using ATL...|$|R
