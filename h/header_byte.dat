6|73|Public
50|$|In the {{following}} table, n {{is the value}} of the <b>header</b> <b>byte</b> as a signed integer.|$|E
5000|$|Block mode: FTP {{breaks the}} data into several blocks (block <b>header,</b> <b>byte</b> count, and data field) and then passes {{it on to}} TCP.|$|E
50|$|Since {{there was}} only one {{compression}} algorithm available when MPQs were first deployed in Diablo, those archives used a different archive file metadata flag to indicate compression and did not use a compression <b>header</b> <b>byte.</b>|$|E
40|$|Abstract — Retransmission ambiguity, {{arising from}} delay spikes in a {{wireless}} mobile environment, results in poor TCP performance. Eifel improves {{the performance of}} TCP by using the timestamp option, which requires additional <b>header</b> <b>bytes,</b> resulting in increased overhead in bandwidth constrained wireless networks. Moreover, the destination needs to support the timestamp option. In this paper, we propose a new algorithm, called DualRTT, which increases the performance of TCP {{in the presence of}} delay spikes, without requiring any additional <b>header</b> <b>bytes.</b> It requires changes only at the sender, and hence is easier to deploy in the existing Internet infrastructure. It also does not require the destination to support the TCP timestamp option. Results show that DualRTT increases the performance of TCP, and also achieves a higher transport layer efficiency than previous algorithms...|$|R
50|$|The IPv4 header {{checksum}} is {{a simple}} checksum used in version 4 of the Internet Protocol (IPv4) to protect the header of IPv4 data packets against data corruption. This checksum is calculated only for the <b>header</b> <b>bytes</b> (with the checksum bytes set to 0), is 16 bits long and {{is a part of}} the IP packet header.|$|R
5000|$|The demos and intros {{for modern}} {{platforms}} are compressed either by general-purpose executable compressors (such as UPX) or programs {{specifically designed for}} the compression of small intros. The decompressor stubs integrated in 4K intros are often well under 200 bytes in size. Some Windows-based 4K intros may even wrap themselves inside DOS-based [...] executables in order to eliminate the <b>header</b> <b>bytes.</b> Decompression facilities provided by the operating system may also be used.|$|R
50|$|In modern MPQ archives, each segment (or sector) of a file can be {{compressed}} using {{a combination}} of compression algorithms. A <b>header</b> <b>byte</b> is prepended to every compressed sector to indicate which compressions were used. The order in which those compressors are applied is hardcoded.|$|E
50|$|UniPro short-header packets use {{a single}} <b>header</b> <b>byte</b> for L3 information. It {{includes}} the 7-bit L3 destination address. The remaining bit indicates the short-header packet format. For short-header packets, the L3 source address {{is not included}} in the header because it is assumed that the two communicating devices have exchanged such information beforehand (connection-oriented communication).|$|E
50|$|The coded {{video data}} is {{organized}} into NAL units, {{each of which}} is effectively a packet that contains an integer number of bytes. The first byte of each H.264/AVC NAL unit is a <b>header</b> <b>byte</b> that contains an indication of the type of data in the NAL unit. For HEVC the header was extended to two bytes. All the remaining bytes contain payload data of the type indicated by the header.The NAL unit structure definition specifies a generic format for use in both packet-oriented and bitstream-oriented transport systems, and a series of NAL units generated by an encoder is referred to as a NAL unit stream.|$|E
5000|$|Like EIA-608 bits are {{transmitted}} {{in the order}} of LSB to MSB with odd parity coding of 7-bit character codes. [...] However unlike EIA-608, the digital DVB version is transmitted the same way. For single bit error recovery during transmission, the packet address (page row and magazine numbers) and <b>header</b> <b>bytes</b> (page number, subtitle flag, etc.) use hamming code 8/4 with extended packets (header extensions) using hamming 24/18, which basically doubles the bits used.|$|R
5000|$|A {{field that}} {{specifies}} the length in bytes of the UDP header and UDP data. The minimum length is 8 bytes {{because that is}} the length of the header. The field size sets a theoretical limit of 65,535 <b>bytes</b> (8 <b>byte</b> <b>header</b> + 65,527 <b>bytes</b> of data) for a UDP datagram. However the actual limit for the data length, which is imposed by the underlying IPv4 protocol, is 65,507 bytes (65,535 − 8 <b>byte</b> UDP <b>header</b> − 20 <b>byte</b> IP <b>header).</b>|$|R
5000|$|The {{size of a}} HIRES Monochrome BSAVE image {{without the}} two <b>byte</b> <b>header</b> was 8000 <b>bytes</b> (the same size as visible screen memory), and was [...] "linearized". The many file {{extensions}} possible included [...]HIR and [...]HBM, if a file extension was used at all.|$|R
30|$|Packet headers with {{redundancy}} may {{be reduced}} through compression techniques as has been done with great success for cRTP (Compressed Real-time Transport Protocol) and ROHC (Robust Header Compression)[5]. For a VoIP flow, RTP/UDP/IP <b>headers</b> take 40 <b>bytes.</b> However, only 12 bytes of them changes when the packets get routed. Schemes, such as cRTP or ROHC, aim at compressing the 40 bytes into a 2 byte connection ID. VOIP packets are very small compared to other traffic on a WiFi network. Consider a 33 byte GSM codec packet compared to a packet of web traffic that may be up to 1, 500 bytes. To transmit this GSM codec packet using VOIP, a RTP <b>header</b> (12 <b>bytes),</b> a UDP <b>header</b> (8 <b>bytes),</b> and an IP <b>header</b> (20 <b>bytes)</b> must be added, thereby giving a total IP packet size of 73 bytes. To send one GSM codec payload packet every 20 ms (13.2 kbit/s) therefore requires an IP level bit stream of 29.2 kbit/s. There are further overheads due to the 802.11 MAC headers and protocol used to reliably transmit data over the WiFi channel, though they are optimized for larger packets (1, 500 bytes).|$|R
5000|$|On {{first sight}} {{the use of}} 50% of the CAN message payload for {{purposes}} other than transmitting operational data {{may seem like a}} waste of bandwidth. However, the CANaerospace message header delivers valuable information which would require the use of message payload bytes also when realized otherwise: The header allows receiving stations to analyze received messages immediately with respect to origin, data type, integrity and creation time. To accomplish this, no further information except the knowledge of the CAN identifier assignment for the particular system is needed. The message <b>header</b> <b>bytes</b> have the following meaning: ...|$|R
5000|$|Header Length (Hdr len): a 1-bit {{value that}} for GTP' version 0 {{indicates}} {{if using a}} 20 <b>byte</b> <b>header</b> (value 0) (as per GTP) or this 6 <b>byte</b> <b>header.</b> This bit must be unset (value 0) for subsequent GTP' versions and in these does not indicate the header length as this must always be 6 bytes.|$|R
2500|$|J2178-3 – Defines {{standards}} for network message frame IDs for single <b>byte</b> <b>headers</b> ...|$|R
5000|$|YMSG packets {{consist of}} a twenty <b>byte</b> <b>header,</b> that {{consists}} of four bytes for [...] "YMSG", two bytes for the version (current is version 19),two bytes for the vendor id (typically 0), two bytes for the packet length(content only, {{does not include the}} 20 <b>byte</b> <b>header),</b> two <b>bytes</b> for the Service(the type of ymsg packet), 4 bytes for the Status(not related to buddy status, though is used to log in as invisible), and four bytes for the Session id. The rest of the packet is a variable length table of key/value pairs, where the key is an ASCII representation of a numeric code representing the field type, and the value is its associated data. A two byte separator, the hexadecimal values C0 and 80, are used to delimit each entry in this table.|$|R
50|$|The {{file format}} {{consists}} of an 8 <b>byte</b> <b>header,</b> followed by any number of icons.|$|R
5000|$|Encrypted packets have an {{additional}} 31 or 24 <b>byte</b> <b>header</b> before the AES-CBC encrypted payload as follows: ...|$|R
5000|$|Load {{relocation}} {{was first}} introduced on the VIC-20 because this machine could start BASIC RAM in several different locations, depending on the memory expansion that was installed. The older Commodore PET series did not support relocation, so [...] and [...] {{would have the same}} effect: the file would be loaded into the same memory region from which it was saved. Load relocation happens in the host, being an exception to what is said above about the secondary address being used only device-internally. Since the PET cannot relocate files, BASIC programs written on later Commodore machines must be modified by using a sector editor to change the <b>header</b> <b>bytes.</b> It is also possible to use the PET's built-in machine language monitor to change the link address for the BASIC program after loading it.|$|R
3000|$|... [...]) of 80, 100, and 120 bytes, to {{minimize}} the PHY (6 bytes) and MAC (8 <b>bytes)</b> <b>headers</b> overhead per information bit.|$|R
50|$|If X is zero, {{only the}} low 24 {{bits of the}} Sequence Number are transmitted, and the generic <b>header</b> is 12 <b>bytes</b> long.|$|R
5000|$|Econet used a {{connectionless}} transmission model, {{similar to}} the current UDP, with no checksumming or error correction at this layer. Each packet had a four <b>byte</b> <b>header</b> consisting of: ...|$|R
40|$|Internet growing, {{compression}} of Internet Protocol (IP) headers {{is seen as}} crucial to maximally utilize scarce wireless bandwidth. The traditional IP compression schemes rely on consistent per-flow state in order to perform header compression. See for instance [1], [2], [3]. While these approaches focus on compression gain, i. e., {{the reduction in the}} number of <b>header</b> <b>bytes</b> as a percentage of the total packet size, the overhead is the cost of managing state per each unidirectional flow. In this document we present a new header compression scheme with the emphasis on reducing or even eliminating the state, perhaps at the cost of reduced compression gain compared to the existing methods. We make use of existing route table information in order to achieve the state reduction. The net result is that significant compression gain can be achieved at a greatly reduced cost of maintaining and managing per-flow state information. This could be especially beneficial for short-lived flows...|$|R
40|$|Abstract—Using {{data from}} 43 users across two platforms, {{we present a}} {{detailed}} look at smartphone traffic. We find that browsing contributes {{over half of the}} traffic, while each of email, media, and maps contribute roughly 10 %. We also find that the overhead of lower layer protocols is high because of small transfer sizes. For half of the transfers that use transport-level security, <b>header</b> <b>bytes</b> correspond to 40 % of the total. We show that while packet loss is the main factor that limits the throughput of smartphone traffic, larger send buffers at Internet servers can improve the throughput of a quarter of the transfers. Finally, by studying the interaction between smartphone traffic and the radio power management policy, we find that the power consumption of the radio can be reduced by 35 % with minimal impact on the performance of packet exchanges. Categories and Subject Descriptors C. 2. 5 [Computer-Communication Networks] Local and Wide...|$|R
3000|$|It is the {{protocol}} that adds the least overhead to the ethernet network: it adds only 28 bytes overhead to every packet (20 byte IPv 4 c <b>header</b> + 8 <b>byte</b> UDP <b>header).</b>|$|R
5000|$|All AppleMIDI {{protocol}} messages use {{a common}} structure of 4 words of 32 bits, with a <b>header</b> containing two <b>bytes</b> with value 255, {{followed by two}} bytes describing {{the meaning of the}} message: ...|$|R
50|$|The GSE Packet header {{is highly}} dynamic and {{provides}} for many options. The minimum <b>header</b> is two <b>bytes,</b> comprising three flags fields, and a 12-bit payload length field. The diagram below shows all possible fields.|$|R
50|$|The ELF header defines {{whether to}} use 32- or 64-bit addresses. The header {{contains}} three fields that are affected by this setting and offset other fields that follow them. The ELF <b>header</b> is 64 <b>bytes</b> long.|$|R
50|$|The DCCP generic header takes {{different}} forms {{depending on the}} value of X, the Extended Sequence Numbers bit. If X is one, the Sequence Number field is 48 bits long, and the generic <b>header</b> takes 16 <b>bytes,</b> as follows.|$|R
5000|$|The router {{divides the}} packet into {{fragment}}s. The max size of each fragment is the MTU minus the IP <b>header</b> size (20 <b>bytes</b> minimum; 60 bytes maximum). The router puts each fragment {{into its own}} packet, each fragment packet having following changes: ...|$|R
30|$|The {{recommended}} {{maximum size}} of a packet for Titan Nodes is 24 bytes, as it can easily be fitted with 5 <b>bytes</b> <b>header</b> into a TinyOS active message. The active message is used to transmit data over wireless links and offers 29 bytes of payload.|$|R
50|$|This {{structure}} {{was designed for}} any digital audio or metadata {{that is to be}} synchronized with a video frame. SDI transports every eight bits in a 10 bit aligned packet, unlike MXF which is byte aligned and the ancillary flag bytes are replaced by 128 bit header. If the cdp_timecode_added is true, then a five byte SMPTE timecode section is inserted before the cdp_data_section. If the cdp_service_info_added is true, then a two <b>byte</b> <b>header</b> and seven <b>bytes</b> per service listing of caption services is inserted after the cdp_data_section. The cdp_framing_rate can be set to the following enumerations: 1 for 24000/1001, 2 for 24, 3 for 25, 4 for 30000/1001, 5 for 30, 6 for 50, 7 for 60000/1001 and 8 for 60 frames per second.|$|R
50|$|After permissions {{have been}} created, the client has two choices for sending the actual data, (1) it {{can use the}} Send {{mechanism}}, or (2) it can reserve a channel using the ChannelBind request. The Send mechanism is more straightforward, but contains a larger <b>header,</b> 36 <b>bytes,</b> that can substantially increase the bandwidth in a TURN relayed conversation. By contrast, the ChannelBind method is lighter: the header is only 4 bytes, but it requires a channel to be reserved which needs to be periodically refreshed, among other considerations.|$|R
40|$|Abstract — It {{has been}} over a decade since Mobility support for IPv 4 was {{proposed}} and standardized by the IETF. The challenges of maintaining active sessions for mobile users without modifying existing correspondent hosts or the scalable nature of Internet routing were met by associating seperate IP addresses for routing and end-point identification. This approach resulted in a per-packet overhead of {{a certain number of}} <b>header</b> <b>bytes</b> as well as suboptimal routing – a packet destined for a mobile user needed to always visit the home network before being sent to the actual location. Optimizations for routing as well as header compression techniques were proposed and standardized subsequently. The adoption of this standard, however, has been much slower than was previously expected even though commer-cial routers have been shipping with support for over half a decade. Additionally, the seeming lack of applications, poor handoff performance, suboptimal routing, signalling overheads and security issues have raised questions about whether Mobile IP will ever see widespread adoption. In this paper, we take the position that inspite of its limitations and slow uptake, Mobile IP will see widespread commercial deployment in the near future. The primary basis of our argument is the adoption, and subsequent use, of Mobile IP in the cellular service provider community. I...|$|R
5000|$|The {{size of a}} HIRES Color BSAVE image (of the {{uncompressed}} type {{produced by}} DOODLE) was 9024 bytes (the same size as videoram plus visible screen memory) without the two <b>byte</b> <b>header,</b> and was [...] "linearized". The file extension was [...]DD, if a file extension was used at all.|$|R
