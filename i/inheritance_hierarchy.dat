213|200|Public
50|$|Object-oriented {{programming}} in D {{is based on}} a single <b>inheritance</b> <b>hierarchy,</b> with all classes derived from class Object. D does not support multiple inheritance; instead, it uses Java-style interfaces, which are comparable to C++'s pure abstract classes, and mixins, which separates common functionality from the <b>inheritance</b> <b>hierarchy.</b> D also allows the defining of static and final (non-virtual) methods in interfaces.|$|E
5000|$|In {{defining}} this <b>inheritance</b> <b>hierarchy</b> we {{have already}} defined certain restrictions, not {{all of which are}} desirable: ...|$|E
5000|$|Four classes {{provide the}} {{facilities}} to describe new classes. Their <b>inheritance</b> <b>hierarchy</b> (from Object), {{and the main}} facilities they provide are: ...|$|E
40|$|<b>Inheritance</b> <b>hierarchies</b> {{have become}} more and more complex {{according}} to an enlargement of object-oriented technology. One of the main problems is the effective searching in such hierarchies. More sophisticated algorithms are needed to searching in the data. In this article we present a novel approach to efficient searching in large <b>inheritance</b> <b>hierarchies.</b> The updatable approach employs the multi-dimensional data structures to indexing <b>inheritance</b> <b>hierarchies</b> and effective searching in the data...|$|R
50|$|JavaScript {{supports}} <b>inheritance</b> <b>hierarchies</b> through prototyping in {{the manner}} of Self.|$|R
40|$|We present here some {{thoughts}} and ongoing work regarding transformations of multiple <b>inheritance</b> <b>hierarchies</b> into single <b>inheritance</b> <b>hierarchies.</b> We follow {{an approach that}} tries to categorize multiple inheritance situations according to a semantic point of view. Different situations should be captured through diagrammatic UML annotations that would allow to detect a given situation and hence apply the appropriate transformation, automatically if possible...|$|R
5000|$|For {{users of}} C++, Versant {{requires}} that the uppermost class in an <b>inheritance</b> <b>hierarchy</b> inherit from a base class [...] "PObject", which handles database activities.|$|E
50|$|Subclasses in an <b>inheritance</b> <b>hierarchy</b> {{are allowed}} to weaken {{preconditions}} (but not strengthen them) and strengthen postconditions and invariants (but not weaken them). These rules approximate behavioural subtyping.|$|E
50|$|Object-oriented design {{techniques}} such as documenting layers of the <b>inheritance</b> <b>hierarchy</b> can reduce {{the effect of this}} problem, as they collect in one place the information that the programmer is required to understand.|$|E
40|$|Increasingly, <b>inheritance</b> <b>hierarchies</b> {{are being}} used to reduce {{redundancy}} in natural language processing lexicons. Systems that utilize <b>inheritance</b> <b>hierarchies</b> {{need to be able to}} insert words under the optimal set of classes in these hierarchies. In this paper, we formalize this problem for feature-based default <b>inheritance</b> <b>hierarchies.</b> Since the problem turns out to be NP-complete, we present an approximation algorithm for it. We show that this algorithm is efficient and that it performs well with respect to a number of standard problems for default inheritance. A prototype implementation has been tested on lexical hierarchies and it has produced encouraging results. The work presented here is also relevant to other types of default hierarchies. Zusammenfassung. In zunehmendem Masse werden Erbschaftshierarchien zur kompakten Beschreibung von Worteigenschaften in Sprachverarbeitungslexica verwendet. Systeme, die Erbschaftshierarchien benutzen, mussen Worte in die optimale Klasse (ode [...] ...|$|R
40|$|Most, {{object-oriented}} {{programs have}} imperfectly designed <b>inheritance</b> <b>hierarchies</b> and imperfectly fact,ored methods, and these imperfections tend to increase with maintenance. Hence, even object-oriented programs {{are more expensive}} to main-tain, harder to understand and larger than neces-sary. Aut,omatic restructuring of inheritance hi-erarchies and refa. ctoring of methods can improve the design of <b>inheritance</b> <b>hierarchies,</b> and the fac-toring of methods. This results in programs be-ing smaller, having better code re-use and being more consistent. This paper describes Guru, a prototype tool for automatic inheritance hierar-chy restructuring and method refactoring of Self programs. Results from realistic applications of the tool are presented. ...|$|R
40|$|In {{this paper}} {{we face the}} problem of {{providing}} a common representation for knowledge learnt from examples {{and some kind of}} background knowledge about a given framework. To this end we postulate <b>inheritance</b> <b>hierarchies</b> endowed with some retrieval rules in addition to the <b>inheritance</b> operation. This <b>hierarchies</b> can be algorithmicaly built according to the specifications encoded in our input data. The cor...|$|R
50|$|IFC defines an EXPRESS based {{entity-relationship}} model consisting {{of several hundred}} entities organized into an object-based <b>inheritance</b> <b>hierarchy.</b> Examples of entities include building elements such as IfcWall, geometry such as IfcExtrudedAreaSolid, and basic constructs such as IfcCartesianPoint.|$|E
5000|$|The {{problem of}} {{computing}} lowest common ancestors of classes in an <b>inheritance</b> <b>hierarchy</b> arises {{in the implementation}} of object-oriented programming systems [...] The LCA problem also finds applications in models of complex systems found in distributed computing [...]|$|E
5000|$|Changes to {{the middle}} of an <b>inheritance</b> <b>{{hierarchy}}.</b> Inserting a new class in{{to the middle}} of a hierarchy is impossible without losing your existing objects, unless custom code is written to do this operation in a series of steps.|$|E
40|$|We {{introduce}} two abstraction {{mechanisms for}} streamlining {{the process of}} semantic interpretation. Configurational descriptions of dependency graphs increase the linguistic generality of interpretation schemata, while interfacing them to lexical and conceptual <b>inheritance</b> <b>hierarchies</b> reduces the amount and complexity of semantic specifications. ...|$|R
40|$|Lexical <b>inheritance</b> <b>hierarchies</b> {{are used}} widely {{as a means}} of {{representing}} lexical information efficiently, but there have been few attempts to construct them automatically. This paper presents a modular architecture which makes it possible to evaluate different formal criteria that may guide a learning algorithm...|$|R
50|$|In <b>inheritance</b> <b>hierarchies,</b> the {{declaration}} of a virtual destructor in the base class ensures that the destructors of derived classes are invoked properly when an object is deleted through a pointer-to-base-class. Objects that may be deleted in this way need to inherit a virtual destructor.|$|R
50|$|The singly rooted hierarchy, in {{object-oriented}} programming, is {{a characteristic}} of most (but not all) OOP-based programming languages. In most such languages, in fact, all classes inherit directly or indirectly from a single root, usually with a name similar to Object; all classes then form a common <b>inheritance</b> <b>hierarchy.</b>|$|E
5000|$|... taxonomy: A {{complete}} {{data model}} in an <b>inheritance</b> <b>hierarchy</b> where all data elements inherit their behaviors {{from a single}} [...] "super data element". The difference between a data model and a formal taxonomy is the arrangement of data elements into a formal tree structure where each element in the tree is a formally defined concept with associated properties.|$|E
5000|$|XML tag {{inheritance}} is {{a methodology}} {{not present in}} any other XML data binding tools. This feature is immensely useful in mapping XML documents to classes with a deep <b>inheritance</b> <b>hierarchy,</b> typically found in GUI API. Thus CookXml is useful in writing XUL motors. [...] CookSwing and CookSwt are two such examples for mapping XML documents to Swing and SWT classes.|$|E
40|$|We apply default <b>inheritance</b> <b>hierarchies</b> to {{generating}} the morphology of Hebrew verbs. Instead of lexically listing each {{of a word}} form's various parts, this strategy represents inflectional exponents as markings associated with the application of rules by which complex word forms are deduced from simpler roots or stems...|$|R
40|$|I {{propose a}} uniform {{approach}} to the elimination of redundancy in CCG lexicons, where grammars incorporate <b>inheritance</b> <b>hierarchies</b> of lexical types, defined over a simple, feature-based category description language. The resulting formalism is partially `constraint-based', in that the category notation is interpreted against an underlying set of tree-like feature structures. I argu...|$|R
40|$|A {{framework}} for concurrent, object-oriented natural language parsing is introduced. The underlying grammar model is fully lexicalized, headdriven, dependency-oriented, and structured along multiple <b>inheritance</b> <b>hierarchies.</b> The computation model relies upon the actor paradigm, with concurrency entering through asynchronous message passing. Protocols for establishing basic dependency relations and {{for coping with}} structural ambiguities and text-level anaphora are considered...|$|R
5000|$|Static: The <b>inheritance</b> <b>hierarchy</b> of {{an object}} is fixed at {{instantiation}} when the object's type is selected and does not change with time. For example, the inheritance graph does not allow a [...] object to become a [...] object while retaining the state of its [...] superclass. (This kind of behavior, however, can be achieved with the decorator pattern.) Some have criticized inheritance, contending that it locks developers into their original design standards.|$|E
50|$|Personal Knowbase is a {{more modern}} {{commercial}} product based solely on a keyword (category) paradigm, though it uses a simple flat keyword structure rather than an <b>inheritance</b> <b>hierarchy</b> like Agenda. Haystack and Chandler are other information management tools which use categorization in important ways. William Jones' Memory Extender took an artificial intelligence twist on {{the whole notion of}} keywords/categories, by allowing an item's keywords to be weighted, and adjusted over time by both the user and the system. This allowed the strength of category membership to vary dynamically for each of an item's assignments, in an attempt to yield more precise retrieval.|$|E
50|$|An object's {{dispatch}} table {{will contain}} the addresses of the object's dynamically bound methods. Method calls are performed by fetching the method's address from the object's dispatch table. The dispatch table {{is the same}} for all objects belonging to the same class, and is therefore typically shared between them. Objects belonging to type-compatible classes (for example siblings in an <b>inheritance</b> <b>hierarchy)</b> will have dispatch tables with the same layout: the address of a given method will appear at the same offset for all type-compatible classes. Thus, fetching the method's address from a given dispatch table offset will get the method corresponding to the object's actual class.|$|E
40|$|Instructors {{using the}} {{textbook}} may use and modify these slides for pedagogical purposes. Inheritance � Another fundamental object-oriented technique is inheritance, used {{to organize and}} create reusable classes � Chapter 7 focuses on: deriving new classes from existing classes creating class hierarchies the protected modifier polymorphism via <b>inheritance</b> <b>inheritance</b> <b>hierarchies</b> for interfaces <b>inheritance</b> used in graphical user interfaces...|$|R
40|$|Grammar {{development}} {{over the}} last decades has seen a shift away from large inventories of grammar rules to richer lexical structures. Many modern grammar theories are highly lexicalised. But simply listing lexical entries typically results in an undesirable amount of redundancy. Lexical <b>inheritance</b> <b>hierarchies,</b> on the other hand, {{make it possible to}} capture linguistic generalisations and thereby reduce redundancy...|$|R
40|$|Using default logic, we formalize NETL-like <b>inheritance</b> <b>hierarchies</b> with exceptions. This {{provides}} {{a number of}} benefits: (1) A precise semantics for such hierarchies. (2) A provably correct (with respect to the proof theory of default logic) inference algorithm for acyclic networks. (3) A guarantee that acyclic networks have extensions. (4) A provably correct quasi-parallel inference algorithm for such networks. 1...|$|R
5000|$|Finally, the {{object-oriented}} {{notion of}} type inheritance {{is available in}} a few solutions. The different card types in NoteCards are arranged into an <b>inheritance</b> <b>hierarchy,</b> so that new types can be created as extensions of old. Aquanet extends this to multiple inheritance among types; the [...] "slots" [...] that an object contains are those of its type, plus those of all supertypes. SPRINT and Tinderbox also use a frame-based approach, and allow default values for attributes to be inherited from supertypes. This way, an item need not define values for all its attributes explicitly: unless overridden, an item's slot will have the shared, default value for all items of that type.|$|E
50|$|The merge of parents' linearizations {{and parents}} list {{is done by}} {{selecting}} the first head of the lists which {{does not appear in}} the tail (all elements of a list except the first) of any of the lists. Note, that a good head may appear as the first element in multiple lists at the same time, but it is forbidden to appear anywhere else. The selected element is removed from all the lists where it appears as a head and appended to the output list. The process of selecting and removing a good head to extend the output list is repeated until all remaining lists are exhausted. If at some point no good head can be selected, because the heads of all remaining lists appear in any one tail of the lists, then the merge is impossible to compute due to cyclic dependencies in the <b>inheritance</b> <b>hierarchy</b> and no linearization of the original class exists.|$|E
5000|$|The {{ability to}} share a single {{instance}} of the [...] parent between [...] and [...] is enabled by recording the memory offset between the [...] or [...] members {{and those of the}} base [...] within the derived class. However this offset can in the general case only be known at runtime, thus [...] must become ( [...] , , , , , [...] ). There are two vtable pointers, one per <b>inheritance</b> <b>hierarchy</b> that virtually inherits [...] In this example, one for [...] and one for [...] The object size has therefore increased by two pointers, but now there is only one [...] and no ambiguity. All objects of type [...] will use the same vpointers, but each [...] object will contain its own unique [...] object. If another class inherits from , such as , then the vpointer in the [...] part of [...] will generally be different to the vpointer in the [...] part of [...] though they may happen to be the same should the [...] class be the same size as [...]|$|E
40|$|When one {{works with}} a system that {{utilizes}} <b>inheritance</b> <b>hierarchies</b> the following problem often arises. A new object is introduced {{and it must be}} integrated into a hierarchy; under which classes in the hierarchy should the new object be positioned? In this paper, I formalize this problem for feature-based default <b>inheritance</b> <b>hierarchies.</b> Since {{it turns out to be}} NP-complete, I present an approximation algorithm for it. I show that this algorithm is efficient and look at some of the possible problematic situations for the algorithm. Although more analysis and experimentation are needed, these preliminary results show that the algorithm warrants such efforts. This work was funded by NSF grant IRI- 9013160, ONR/DARPA research grant no. N 00014 - 92 -J- 1512, and a grant from the Land Baden-Wurttemberg, Germany. 1 Introduction Recent computational linguistics research into natural language lexicons has gone beyond simply listing idiosyncratic information about words. Many researchers are adding [...] ...|$|R
40|$|<b>Inheritance</b> <b>hierarchies</b> are {{introduced}} {{as a means}} of representing taxonomicallyorganized data. The hierarchies are built up from so-called feature types that are ordered by subtyping and whose elements are records. Every feature type comes with a set of features prescribing fields of its record elements. So-called feature terms are available to denote subsets of feature types. Feature unification is introduced as an operation that decides whether two feature terms have a nonempty intersection and computes a feature term denoting the intersection. We model our <b>inheritance</b> <b>hierarchies</b> as algebraic specifications in ordersortedequational logic using initial algebra semantics. Our framework integrates feature types whose elements are obtained as records with constructor types whose elements are obtained by constructor application. Unification in these hierarchies combines record unification with order-sorted term unification and is presented as constraint solving. We specify a unitary unification algorithm by a set of simplification rules and prove its soundness and completeness with respect to the model-theoretic semantics...|$|R
40|$|Subtyping tests, i. e., {{determining}} whether one type is a subtype of another, are a frequent operation during {{the execution of}} objectoriented programs. The challenge is in encoding the hierarchy in a small space, while simultaneously making sure that subtyping tests have efficient implementation. We present a new scheme for encoding multiple and single <b>inheritance</b> <b>hierarchies,</b> which, in the standardized hierarchies, reduces the footprint of all previously published schemes. The scheme is called PQ-encoding after PQ-trees, a data structure previously used in graph theory for finding the orderings that satisfy a collection of constraints. In particular, we show that in the traditional object layout model, the extra memory requirements for single <b>inheritance</b> <b>hierarchies</b> is zero. In the PQ-encoding subtyping tests are constant time, and use only two comparisons. Other than PQ-trees, PQ-encoding uses several novel optimization techniques. These techniques are applicable also in improving the performance of other, previously published, encoding schemes...|$|R
