0|4747|Public
40|$|Through-silicon vias (TSVs) present new, {{essential}} elements within 3 D stacked Integrated Circuits (IC). Since they connect different layers of 3 D stacks, their proper operation {{is an essential}} prerequisite for the system function. In this paper a procedure for deriving local <b>digital</b> <b>test</b> <b>sequences</b> for TSVs is presented. The behavior of TSVs including their typical surrounding circuitry is investigated under the impact of assumed faults using fault simulation. Since a purely digital consideration of faulty behavior of TSVs is not sufficient, the TSVs have to be modeled and analyzed at electrical level. The TSVs are embedded by inverters used as drivers at the inputs and buffers at the outputs. All mentioned elements are described at electrical level by spice-like netlists. By an analogue fault simulation tool faults are injected into this electric network model. The simulations of the so modified networks were running in parallel on a compute cluster including the evaluations of the fault effects. The fault simulations are carried out automatically. The test signals needed for fault detection are concatenated to form a <b>digital</b> TSV <b>test</b> <b>sequence...</b>|$|R
50|$|The Enhanced Full Rate (GSM 06.60) {{technical}} specification describes the detailed mapping between input blocks of 160 speech samples in 13-bit uniform PCM format to encoded blocks of 244 bits and from encoded blocks of 244 bits to output blocks of 160 reconstructed speech samples. It also specifies the conversion between A-law or μ-law (PCS 1900) 8-bit PCM and 13-bit uniform PCM. This part of specification also describes the codec {{down to the}} bit level, thus enabling the verification of compliance to the part to {{a high degree of}} confidence by use of a set of <b>digital</b> <b>test</b> <b>sequences.</b> These <b>test</b> <b>sequences</b> are described in GSM 06.54 and are available on disks.|$|R
40|$|Abstract — This paper {{presents}} a scheme for the rapid measurement of weighting sequences of in-operation linear systems. Finite duration sequences {{are used as}} test signals to the system under test, whose response to the sequence is processed by an appropriate <b>digital</b> filter. The <b>test</b> <b>sequences</b> are here required to have high energy ratio and low sidelobes in their autocorrelation function. It is shown that {{in the absence of}} noise an inverse filter is optimum while in very heavy noise matched filter is the best...|$|R
40|$|Abstract. The {{testing of}} a {{state-based}} system may involve the applica-tion {{of a number}} of adaptive <b>test</b> <b>sequences.</b> Where the implementation under test (IUT) is deterministic, the response of the IUT to some adap-tive <b>test</b> <b>sequence</b> γ 1 may be capable of determining the response of the IUT to some other adaptive <b>test</b> <b>sequence</b> γ 2. Thus, the expected cost of applying a set of adaptive <b>test</b> <b>sequences</b> depends upon the order in which they are applied. This paper explores properties of adaptive <b>test</b> <b>sequences</b> and the problem of finding an order of application, of the el-ements from some set of adaptive <b>test</b> <b>sequences,</b> that minimises the expected cost of testing. ...|$|R
40|$|An {{important}} issue in protocol conformance testing {{is how to}} generate <b>test</b> <b>sequences</b> in an efficient and effective way that achieves the required fault detection coverage. We proposed an approach for finding shorter <b>test</b> <b>sequences</b> for protocol conformance testing based on the Wp method in our previous work. While the method generated good quality <b>test</b> <b>sequences,</b> an extra leading sequence {{may have to be}} added if the final <b>test</b> <b>sequence</b> generated was not started from the same starting state of the given FSM. A new approach is proposed in this paper to overcome this problem thus {{to improve the quality of}} the final <b>test</b> <b>sequence.</b> The new <b>test</b> <b>sequence</b> generated always starts from the same starting state of the given FSM. This effectively reduces the length of generated <b>test</b> <b>sequence...</b>|$|R
40|$|Testing complex systems, {{such as the}} ASML TWINSCAN lithographic machine, is {{expensive}} and time consuming. In a previous work, a <b>test</b> <b>sequencing</b> method to calculate time-optimal <b>test</b> <b>sequences</b> has been developed. Because complex systems are composed of several subsystems, which are again composed of several modules, there exists a need to hierarchically model <b>test</b> <b>sequencing</b> problems. Such a hierarchical <b>test</b> <b>sequencing</b> problem consists of a high-level model that describes a <b>test</b> <b>sequencing</b> problem at the system level, and one or more low-level models that describe the <b>test</b> <b>sequencing</b> problems at the subsystem or module level. The tests at the system level correspond to the solutions of low-level problems. This paper describes a hierarchical <b>test</b> <b>sequencing</b> model and proposes two algorithms to compute an optimal <b>test</b> <b>sequence.</b> The benefits of hierarchically modeling a problem are less computational effort and less modeling effort, because not all relations are needed. This is illustrated by a small example. The industrial relevance of this method is illustrated on a case study related to a manufacturing testing phase of a lithographic machine...|$|R
40|$|Conformance <b>testing</b> using <b>test</b> <b>sequences</b> is {{the main}} means {{to ensure that a}} {{protocol}} implementation conforms to its specification. For systems which are specified by nondeterministic finite state machines, a commonly used technique to generate <b>test</b> <b>sequences</b> is the generalized Wp-method with reset which often yields long <b>test</b> <b>sequences</b> if no reliable reset function exists in the system. In this paper, we propose a bipartite graph matching approach to optimize <b>test</b> <b>sequences</b> generated using the generalized Wp-method for protocol conformance testing. Our approach significantly reduces the length of the <b>test</b> <b>sequences</b> required for conformance testing while maintaining the same fault detection capability...|$|R
40|$|Abstract-Protocol {{testing for}} the purpose of {{certifying}} the imple-mentation’s adherence to the protocol specification can be done with a test architecture consisting of remote tester and local responder proc-esses generating specific input stimuli, called <b>test</b> <b>sequences,</b> and observing the output produced by the implementation under test. It is possible to adapt <b>test</b> <b>sequence</b> generation techniques for finite state machines, such as transition tour, characterization, and checking sequence methods, to generate <b>test</b> <b>sequences</b> for protocols specified as incomplete finite state machines. For certain <b>test</b> <b>sequences,</b> the tester or responder processes are forced to consider the timing of an interaction in which they have not taken part; these <b>test</b> <b>sequences</b> are called nonsynchronizahle. The three <b>test</b> <b>sequence</b> generation algo-rithms are modified to obtain synchronizable <b>test</b> <b>sequences.</b> The checking of a given protocol for intrinsic synchronization problems is also discussed. Complexities of synchronizable <b>test</b> <b>sequence</b> genera-tion algorithms are given and complete testing of a protocol is shown to he infeasible. To extend the applicability of the characterization and checking sequences, different methods are proposed to enhance the protocol specifications: special test input interactions are defined and a metho-dology is developed to complete the protocol specifications. P I...|$|R
40|$|This paper investigates {{problems}} of the form: produce a <b>test</b> <b>sequence</b> p, that contains each element of some non-empty set T of sequences, such that there does not exist a <b>test</b> <b>sequence</b> p # that contains each element of T and has fewer resets than p. The proposed (polynomial time) algorithm is guaranteed to produce a <b>test</b> <b>sequence</b> that has the minimum number of resets when considering <b>test</b> <b>sequences</b> that connect the sequences from T but do not utilize overla...|$|R
40|$|We {{present a}} {{procedure}} to generate short <b>test</b> <b>sequences</b> for syn-chronous sequential circuits described {{at the gate}} level. Short <b>test</b> <b>sequences</b> are important in reducing test application time and memory requirements. The proposed procedure constructs a <b>test</b> <b>sequence</b> {{using a combination of}} fault-independent and fault-oriented criteria. Experimental results are presented to demon-strate its effectiveness. 1...|$|R
40|$|Bounds on <b>test</b> <b>sequence</b> length {{can be used}} as a {{testability}} measure. We give {{a procedure}} to compute the upper bound on <b>test</b> <b>sequence</b> length for an arbitrary sequential circuit. We prove that the bound is exact for a certain class of circuits. Three design rules are specified to yield circuits with lower <b>test</b> <b>sequence</b> bounds. ...|$|R
40|$|We {{describe}} {{a method for}} on-chip generation of weighted <b>test</b> <b>sequences</b> for synchronous sequential circuits. For combinational circuits, three weights, 0, 0. 5 and 1, are sufficient to achieve complete coverage of stuck-at faults, since these weights are sufficient to reproduce any specific test pattern. For sequential circuits, the weights we use are defined based on subsequences of a deterministic <b>test</b> <b>sequence.</b> Such weights allow us to reproduce parts of the <b>test</b> <b>sequence,</b> and help ensure that complete fault coverage would be obtained by the weighted <b>test</b> <b>sequences</b> generated...|$|R
40|$|Properly {{generated}} test suites may {{not only}} locate the defects in software systems, but also help {{in reducing the}} high cost associated with software testing, ft is often desired that <b>test</b> <b>sequences</b> in a <b>test</b> suite can be automatically generated to achieve required test coverage. However, automatic <b>test</b> <b>sequence</b> generation remains {{a major problem in}} software testing. This paper proposes an ant colony optimization approach to automatic <b>test</b> <b>sequence</b> generation for state-based software testing. The proposed approach can directly use UML artifacts to automatically generate <b>test</b> <b>sequences</b> to achieve required test coverage...|$|R
40|$|This paper {{presents}} {{a method for}} the selection of <b>test</b> <b>sequences</b> from statecharts. It is shown that a statechart can {{be transformed into a}} flow graph modeling the flow of both control and data in the statechart. The transformation enables the application of conventional control and data flow analysis techniques to the <b>test</b> <b>sequence</b> selection from statecharts. The resulting set of <b>test</b> <b>sequences</b> provides the capability of determining whether an implementation establishes the desired flow of controlanddataexpressedinstatecharts. Keywords: software testing and analysis, specification-based <b>testing,</b> <b>test</b> <b>sequence</b> selection, statecharts, data flow analysis...|$|R
40|$|This paper {{describes}} {{simulations of}} a <b>test</b> <b>sequence</b> transmission for intrusive measurement of VTQoS in mobile environment. The {{aim of the}} simulation was to analyze an influence of multipath signals propagation and propagation attenuation on the <b>test</b> <b>sequence.</b> Evaluation the generated sequences {{was based on the}} calculation of mean square measure and correlation coefficient. These measures were used as a criterion for suitable <b>test</b> <b>sequences</b> selection. Reconsideration of an influence of mobile environment on the <b>test</b> <b>sequences,</b> which are composed from simple signals, is the aim of this paper...|$|R
40|$|Deterministic test {{generation}} methods typically {{target a}} primary fault and generate a <b>test</b> <b>sequence</b> for detecting it. Since the generated <b>test</b> <b>sequence</b> may also detect ancillary faults, fault simulation is subsequently employed {{and both the}} primary and the ancillary faults are eliminated from the fault list. The same fault dropping mechanism is also employed in simulation-based test generation methods, wherein random, pseudo-random, or algorithmically constructed <b>test</b> <b>sequences</b> are fault-simulated on the circuit. In either case, the primary objective is the derivation {{of a set of}} <b>test</b> <b>sequences</b> that detects all faults and fault dropping is an essential element in order to reduce test generation time. As a result, test generation methods typically produce a suboptimal set of <b>test</b> <b>sequences,</b> i. e. a set wherein some tes...|$|R
5000|$|Test Houses for CE devices: Eurofins <b>Digital</b> <b>Testing</b> (formerly <b>Digital</b> TV Labs) ...|$|R
40|$|The {{concept of}} a test vector has been a central feature in <b>digital</b> <b>test</b> {{hardware}} and software since the earliest <b>digital</b> <b>test</b> systems of almost forty years ago. It {{has always been a}} tricky concept to explain and defend, and newer devices and their test requirements are brutally exposing the weaknesses in the test vector concept...|$|R
40|$|Abstract—Functional <b>test</b> <b>sequences</b> {{are often}} used in {{manufacturing}} testing to target defects that are not detected by structural test. Therefore, {{it is necessary to}} evaluate the quality of functional <b>test</b> <b>sequences.</b> However, it is very time-consuming to evaluate the quality of functional <b>test</b> <b>sequences</b> by gate-level fault simulation. Therefore, we propose output deviations as a metric to grade functional <b>test</b> <b>sequences</b> at the register transfer (RT) level without explicit fault simulation. Experimental results for the open-source Parwan processor and the Scheduler module of the Illinois Verilog Model (IVM) show that the deviations metric is computationally efficient and it correlates well with gate-level coverage for stuck-at, transition-delay, and bridging faults. Results also show that functional <b>test</b> <b>sequences</b> that are reordered based on output deviations provide steeper gate-level fault coverage ramp-up compared to other ordering methods. I...|$|R
40|$|Abstract Recently various {{real-time}} {{communication protocols}} have been proposed. In this paper, first, we propose a timed I/O automaton model {{so that we}} can simply specify such real-time protocols. The proposed model can handle not only time but also data values. Then, we propose a conformance testing method for the model. In order to trace a <b>test</b> <b>sequence</b> (I/O sequence) on the timed I/O automaton model, we need to execute each I/O action in the <b>test</b> <b>sequence</b> at an adequate execution timing which satisfies all timing constraints in the <b>test</b> <b>sequence.</b> However, since outputs are given from IUTs and uncontrollable, we cannot designate their output timing in advance. Also their output timing affects the executable timing for the succeeding I/O actions in the <b>test</b> <b>sequence.</b> Therefore, in general, the executable timing of each input action in a <b>test</b> <b>sequence</b> can be specified by a function of the execution time of the preceding I/O actions. In this paper, we propose an algorithm to decide efficiently whether a given <b>test</b> <b>sequence</b> is executable. We also give an algorithm to derive such a function from an executable <b>test</b> <b>sequence</b> automatically using a technique for solving linear programming problems, and propose a conformance testing method using those algorithms...|$|R
40|$|SUMMARY This paper {{presents}} {{an approach to}} specification-based testing of concurrent programs with representative <b>test</b> <b>sequences</b> generated from Statecharts. Representative <b>test</b> <b>sequences</b> are a subset of all possible interleavings of concurrent events that define the behaviors of a concurrent program. Because a program’s correctness may be determined by checking whether a program implemented all behaviors in its specification or not, the program {{can be regarded as}} being correct if it can supply an alternative execution that has the same effects as the program’s behavior with each representative <b>test</b> <b>sequence.</b> Based on this observation, we employ each representative <b>test</b> <b>sequence</b> as a seed to generate an automaton that accepts its equivalent sequences to reveal the same behavior. In order to effectively test a concurrent program, the automaton such generated accepts all sequences equivalent to the representative <b>test</b> <b>sequence</b> and it is used to control test execution. This paper describes an automated process of generating automata from a Statecharts specification and shows how the proposed approach works on Statecharts specifications through some examples. key words: statecharts, concurrent program, specification-based <b>testing,</b> <b>test</b> <b>sequence,</b> equivalent class 1...|$|R
50|$|The {{movements}} of the test system are tightly controlled by a <b>digital</b> <b>test</b> controller.|$|R
40|$|International audienceThe {{combination}} of higher quality requirements and sensitivity of high performance circuits to delay defects {{has led to}} an increasing emphasis on delay testing of VLSI circuits. In this context, it has been proven that Single Input Change (SIC) <b>test</b> <b>sequences</b> are more effective than classical Multiple Input Change (MIC) <b>test</b> <b>sequences</b> when a high robust delay fault coverage is targeted. In this paper, we show that random SIC (RSIC) <b>test</b> <b>sequences</b> achieve a higher fault coverage than random MIC (RMIC) <b>test</b> <b>sequences</b> when both robust and non-robust tests are under consideration. Experimental results given in this paper are based on a software generation of RSIC <b>test</b> <b>sequences</b> that can be easily generated in this case. For a built-in self-test (BIST) purpose, hardware generated RSIC sequences have to be used. This kind of generation will be shortly discussed {{at the end of the}} paper...|$|R
40|$|Finite-state-machine-based {{conformance}} testing has been comprehensively {{studied in the}} literature {{in the context of}} centralized test architecture. As distributed test architecture involves multiple remote testers, applying a <b>test</b> <b>sequence</b> generated from a given n-port finite state machine to an implementation under test (IUT) may result in controllability problems. A possible way to resolve this problem is to select an appropriate <b>test</b> <b>sequence,</b> whose application to the IUT will not involve controllability problems. Thus generating such efficient <b>test</b> <b>sequences</b> is an interesting issue. There are several possibilities for such <b>test</b> <b>sequence</b> generation and we provide empirical study to compare the efficiency of two typical solutions proposed in the literature in terms of the length of the generated <b>test</b> <b>sequences.</b> While both of the two techniques rely on solutions to the Rural Postman Problem (RPP), a well-used RPP solution has been adopted and further improved in this thesis work...|$|R
40|$|Two fast {{algorithms}} for static <b>test</b> <b>sequence</b> compaction {{are proposed}} for sequential circuits. The algorithms {{are based on}} the observation that <b>test</b> <b>sequences</b> traverse through a small set of states, and some states are frequently re-visited throughout the application of a test set. Subsequences that start and end on the same states may be removed if necessary and su#cient conditions are met for them. The techniques require only two fault simulation passes and are applied to <b>test</b> <b>sequences</b> generated by various test generators, resulting in signi#cant compactions very quickly for circuits that have many revisited states. I Introduction Test <b>sequence</b> compaction produces <b>test</b> <b>sequences</b> of reduced lengths, which can greatly reduce the test application time. Test application time is important because it directly impacts the cost of testing. Twotypes of compaction techniques exist: dynamic and static compaction. Dynamic <b>test</b> <b>sequence</b> compaction performs compaction concurrently with the test [...] ...|$|R
40|$|The {{combination}} of higher quality requirements and sensitivity of high performance circuits to delay defects {{has led to}} an increasing emphasis on delay testing of VLSI circuits. In this context, it has been proven that Single Input Change (SIC) <b>test</b> <b>sequences</b> are more effective than classical Multiple Input Change (MIC) <b>test</b> <b>sequences</b> when a high robust delay fault coverage is targeted. In this paper, we show that random SIC (RSIC) <b>test</b> <b>sequences</b> achieve a higher fault coverage than random MIC (RMIC) <b>test</b> <b>sequences</b> when both robust and non-robust tests are under consideration. Experimental results given in this paper are based on a software generation of RSIC <b>test</b> <b>sequences</b> that can be easily generated in this case. For a built-in self-test (BIST) purpose, hardware generated RSIC sequences have to be used. This kind of generation will be shortly discussed {{at the end of the}} paper...|$|R
40|$|The {{functionality}} of high-voltage {{circuit breakers}} is tested in high-power laboratories. Due to the necessary {{power and the}} physical size of the equipment, testing is rather expensive and time consuming. The steps followed so far by the authors in order to enable the <b>digital</b> <b>testing</b> of HV circuit breakers are described in this paper. At {{the end of the}} article, examples of <b>digital</b> <b>testing</b> are also presente...|$|R
30|$|A <b>test</b> <b>sequence</b> is a {{composition}} of test steps that cover certain equivalence classes, optionally {{together with a}} specification of transitions between them. Note that for simplicity, this article does not distinguish between <b>test</b> <b>sequences</b> and <b>test</b> cases, as does [8].|$|R
40|$|We {{present in}} this paper a new concept of <b>test</b> <b>sequence</b> {{generation}} for realistic faults in CMOS ICs based on the pre-determined testing conditions of cells in the standard cell library. In a one-time effort, fabrication level defects in each cell in the standard cell library are extensively analyzed via circuit simulations. Optimal <b>test</b> <b>sequence</b> of each cell is then determined and pre-stored for later use. For a given circuit under test (CUT), the automatic <b>test</b> <b>sequence</b> generation (ATSG) program generates the <b>test</b> <b>sequence</b> of the circuit under test by trying to satisfy all <b>test</b> <b>sequences</b> of all cells in the given netlist. The results on ISCAS 85 benchmark circuits show that the proposed approach reduces test generation time and test size significantly while providing the capability to adapt to virtually any fault/defect model. 1. Introduction Test coverage of a production test has {{a direct impact on}} the defective parts per million (DPM) measurement. Increasing the test coverage of th [...] ...|$|R
40|$|Executing {{instructions}} from the cache {{has been shown to}} improve the defect coverage of real chips. However, although the faults detected by such tests can be deteremined, there has been no technique to target test generation for an undetected fault. This paper presents a novel technique to map pre-computed <b>test</b> <b>sequences</b> at the module level of a processor, to sequences of instructions. The module level pre-computed <b>test</b> <b>sequence</b> is translated into a temporal logic property and the negation of the property is passed to a bounded model checker. The model checker produces a counter-example for the temporal logic property. This counter-example trace contains the instruction sequence that can be applied at the primary inputs to produce the pre-computed <b>test</b> <b>sequence</b> at the module inputs. This technique has no restrictions on the type of <b>test</b> <b>sequences,</b> so {{it can be used to}} map <b>test</b> <b>sequences</b> for any kind of fault to processor instructions. It can also be used in the design phase to produce validation tests. ...|$|R
40|$|Extended finite state {{machines}} (EFSMs), and languages such as state-charts {{that are similar}} to EFSMs, are widely used to model state-based systems. When testing from an EFSM M it is common to aim to produce a set of <b>test</b> <b>sequences</b> (input sequences) that satisfies a test criterion that relates to the transition paths (TPs) of M that are executed by the <b>test</b> <b>sequences.</b> For example, we might require that the set of TPs triggered includes all of the transitions of M. One approach to generating such a set of <b>test</b> <b>sequences</b> is to split the problem into two stages: choosing a set of TPs that achieves the test criterion and then producing <b>test</b> <b>sequences</b> to trigger these TPs. However, the EFSM may contain infeasible TPs and the problem of generating a <b>test</b> <b>sequence</b> to trigger a given feasible TP (FTP) is generally uncomputable. In this paper we present a search-based approach that uses two techniques: (1) A TP fitness metric based on our previous work that estimates the feasibility of a given transition path; and (2) A fitness function to guide the search for a <b>test</b> <b>sequence</b> to trigger a given FTP. We evaluated our approach on five EFSMs: A simple in-flight safety system; a class II transport protocol; a lift system; an ATM; and the Inres initiator. In the experiments the proposed approach successfully tested approximately 96. 75 % of the transitions and the proposed <b>test</b> <b>sequence</b> generation technique triggered all of the generated FTPs...|$|R
40|$|A {{distributed}} system {{may have a}} number of separate interfaces called ports and in testing {{it may be necessary to}} have a separate tester at each port. This introduces a number of issues, including the necessity to use synchronised <b>test</b> <b>sequences</b> and the possibility that output-shifting faults go undetected. This paper considers the problem of generating a minimal synchronised <b>test</b> <b>sequence</b> that detects output-shifting faults when the system is specified using a finite state machine with multiple ports. The set of synchronised <b>test</b> <b>sequences</b> that detect output-shifting faults is represented by a directed graph G and test generation involves finding appropriate tours of G. This approach is illustrated using the test criterion that the <b>test</b> <b>sequence</b> contains a <b>test</b> segment for each transition...|$|R
40|$|In this paper, {{we propose}} a {{functional}} testing method of media synchronization protocols, which control the synchronization between audio and movie, described in concurrent synchronous timed I/O automata. In order to trace all <b>test</b> <b>sequences</b> (I/O event sequences) with synchronization on the model, {{we need to}} execute each I/O event at an adequate timing which satisfies the whole timing constraint for all the given <b>test</b> <b>sequences.</b> However, the outputs are given from the IUT and uncontrollable. Also each output/synchronization timing may a#ect executable timing for its succeeding I/O events in the <b>test</b> <b>sequences.</b> In this paper, we propose a technique to derive a set of time intervals which make all the given <b>test</b> <b>sequences</b> executable, and propose a method for functional testing using the technique...|$|R
40|$|Finite state {{machines}} {{have been used}} to model a number of classes of system and there has thus been much interest in the automatic generation of <b>test</b> <b>sequences</b> from finite {{state machines}}. Many finite state machine based <b>test</b> techniques utilize <b>sequences</b> that check the final states of transitions, the most general such sequence being a separating sequence: an input sequence that distinguishes between two states of an FSM. When using such techniques the <b>test</b> <b>sequence</b> length can be reduced by utilizing overlap. This paper investigates overlap for separating sequences and shows how this can be incorporated into <b>test</b> <b>sequence</b> generation...|$|R
40|$|INTRODUCTION Design {{validation}} by simulation-based techniques is {{the most}} common approach to verification due to the computational complexity of more formal techniques. Validation entails the generation of a <b>test</b> pattern <b>sequence</b> which is applied to the design during simulation to trigger erroneous behavior. Since simulation can only be performed with a small subset of the entire space of <b>test</b> <b>sequences,</b> some method is needed to estimate the degree of verification achieved by a given <b>test</b> <b>sequence.</b> The degree of verification afforded by a <b>test</b> <b>sequence</b> must be known in order to direct test pattern generation, and to provide the designer with the knowledge that verification goals have been achieved. Several researchers have proposed different functional fault models as tools in determining the degree of verification achieved by a <b>test</b> <b>sequence.</b> A functional fault model describes the space of erroneous design behaviors which can be expected {{as a result of a}} de...|$|R
40|$|This paper {{deals with}} the {{sequential}} diagnosis approach and the associated <b>test</b> <b>sequencing</b> problem (i. e. the problem of generating the <b>sequence</b> of <b>tests</b> required to reach a diagnostic conclusion at minimum cost). The traditional <b>test</b> <b>sequencing</b> problem is generalized here to include asymmetrical and multi-valued tests. We present the sequential diagnosis tool (SDT) that enables the user to generate solutions of the generalized <b>test</b> <b>sequencing</b> problem. SDT can be employed as a kernel of a diagnostic reasoner in automatic test equipment or system maintenance software. � 2000 Elsevier Science B. V. All rights reserved...|$|R
