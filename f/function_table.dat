70|456|Public
25|$|The Computer History Museum in Mountain View, California {{has three}} panels and a <b>function</b> <b>table</b> on display (on {{loan from the}} Smithsonian Institution).|$|E
25|$|Early in 1952, a {{high-speed}} shifter was added, which improved the speed for shifting {{by a factor}} of five. In July 1953, a 100-word expansion core memory was added to the system, using binary coded decimal, excess-3 number representation. To support this expansion memory, ENIAC was equipped with a new <b>Function</b> <b>Table</b> selector, a memory address selector, pulse-shaping circuits, and three new orders were added to the programming mechanism.|$|E
25|$|The Electronic Numerical Integrator And Computer (Fall 1945) was a Turing complete, {{general-purpose}} computer that used 17,468 vacuum tubes {{to create the}} circuits. At its core, it {{was a series of}} Pascalines wired together. Its 40 units weighed 30 tons, occupied , and consumed $650 per hour (in 1940s currency) in electricity when idle. It had 20 base-10 accumulators. Programming the ENIAC took up to two months. Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels using heavy black cables. Each <b>function</b> <b>table</b> had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week. The ENIAC featured parallel operations. Different sets of accumulators could simultaneously work on different algorithms. It used punched card machines for input and output, and it was controlled with a clock signal. It ran for eight years, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.|$|E
5000|$|... "The Use of <b>Function</b> <b>Tables</b> with Computing Machines" [...] (July 12, 1946) ...|$|R
40|$|Experience {{has shown}} that the issue of {{software}} documentation cannot be ignored if safe reliable software is the goal. To be useful, software documentation should be easy to manipulate. <b>Function</b> <b>tables</b> are a natural way of documenting software through the use of mathematical tabular notation. The need has been expressed for a tool to automatically generate the mathematical composition of two <b>function</b> <b>tables,</b> which would document the sequential execution of two programs. The Function Composition Tool is a prototype toward this end. The tool is based on existing algorithms using normal <b>function</b> <b>tables,</b> and their extensions to vector <b>function</b> <b>tables.</b> This work involves the design and implementation of the software. Supporting software enables the execution of test suites on the tool. iii Acknowledgements I would like to express my appreciation for the efforts and advice of my supervisors, Dr. David L. Parnas and Dr. Martin von Mohrenschildt, and those of the defense committee, Dr. Emil [...] ...|$|R
40|$|Dynamic {{dispatch}} with virtual <b>function</b> <b>tables</b> is {{not very}} efficient on modern hardware. This {{is a problem with}} object-oriented programming which makes heavy use of inheritance and dynamically-bound messages. By analysing the whole system at compile time it is possible to replace virtual <b>function</b> <b>tables</b> with simple binary branch code. This approach has the advantage of reducing the amount of generated code and greatly speeding up execution time. 1...|$|R
5000|$|IBM Dialog test {{facility}} with Panel, <b>Function,</b> <b>Table</b> testing with variable tracing ...|$|E
5000|$|... #Caption: A <b>function</b> <b>table</b> from ENIAC {{on display}} at Aberdeen Proving Ground museum.|$|E
5000|$|Most {{oscillator}} opcodes {{will use}} an internal sine <b>function</b> <b>table</b> if the table number is omitted.|$|E
5000|$|Brizuela, B. M. & Lara-Roth, S. (2002). Additive {{relations}} and <b>function</b> <b>tables.</b> Journal of mathematical behavior, 20 (3), 309-319.|$|R
50|$|It {{is common}} for the <b>function</b> <b>tables</b> of such computer-generated state-machines to be {{optimized}} with logic-minimization software such as Minilog.|$|R
25|$|The United States Army Ordnance Museum at Aberdeen Proving Ground, Maryland, where ENIAC was used, {{has one of}} the <b>function</b> <b>tables.</b>|$|R
5000|$|The Computer History Museum in Mountain View, California {{has three}} panels and a <b>function</b> <b>table</b> on display (on {{loan from the}} Smithsonian Institution).|$|E
50|$|The {{implementation}} process {{starts with a}} logic minimization phase, to be described below, {{in order to simplify}} the <b>function</b> <b>table</b> by combining the separate terms into larger ones containing fewer variables.|$|E
50|$|A virtual method table (VMT), virtual <b>function</b> <b>table,</b> {{virtual call}} table, {{dispatch}} table, vtable, or vftable is a mechanism {{used in a}} programming language to support dynamic dispatch (or run-time method binding).|$|E
5000|$|... #Caption: Cpl. Irwin Goldstein (foreground) {{sets the}} {{switches}} {{on one of}} ENIAC's <b>function</b> <b>tables</b> at the Moore School of Electrical Engineering. (U.S. Army photo) ...|$|R
5000|$|Martinez, M. V., & Brizuela, B. M. (2006). A third grader’s way of {{thinking}} about linear <b>function</b> <b>tables.</b> Journal of Mathematical Behavior, 25(4), 285-298.|$|R
5000|$|... #Caption: Four ENIAC {{panels and}} one of its three <b>function</b> <b>tables,</b> on display at the School of Engineering and Applied Science at the University of Pennsylvania ...|$|R
50|$|Sterratt, D., Graham, B., Gillies, A., & Willshaw, D. (2011) {{classify}} {{the biological}} model of neuroscience into nine levels from ion channels to nervous system level based on size and <b>function.</b> <b>Table</b> 1 {{is based on}} this for neuronal networks.|$|E
50|$|An object graph is a {{directed}} graph, {{which might}} be cyclic. When stored in RAM, objects occupy different segments of the memory with their attributes and <b>function</b> <b>table,</b> while relationships are represented by pointers or {{a different type of}} global handler in higher-level languages.|$|E
5000|$|A {{real-time}} {{version of}} KMP {{can be implemented}} using a separate failure <b>function</b> <b>table</b> for each character in the alphabet. If a mismatch occurs on character [...] in the text, the failure <b>function</b> <b>table</b> for character [...] is consulted for the index [...] in the pattern at which the mismatch took place. This will return {{the length of the}} longest substring ending at [...] matching a prefix of the pattern, with the added condition that the character after the prefix is [...] With this restriction, character [...] in the text need not be checked again in the next phase, and so only a constant number of operations are executed between the processing of each index of the text. This satisfies the real-time computing restriction.|$|E
5000|$|The maximal {{degree of}} the graph is 1, {{and the game}} can be {{described}} as [...] <b>functions</b> (<b>tables)</b> of size [...] So, the total size of the input will be [...]|$|R
25|$|The School of Engineering and Applied Science at the University of Pennsylvania {{has four}} of the {{original}} forty panels {{and one of the}} three <b>function</b> <b>tables</b> of ENIAC (on loan from the Smithsonian).|$|R
5000|$|The ENIAC was {{modified}} {{to run as}} a primitive read-only stored-program computer (using the <b>Function</b> <b>Tables</b> for program ROM) and was demonstrated as such on September 16, 1948, running a program by Adele Goldstine for von Neumann.|$|R
5000|$|... #Caption: [...] An {{example of}} lookup table, where the data at {{addresses}} from 63 to 67 are zoomed. (based on Figure 2.1 on [...] ) On Csound, {{it is called}} f-table (<b>function</b> <b>table),</b> and used for various purposes including: wavetable-lookup synthesis, waveshaping, MIDI note mapping, and storing ordered pitch-class sets.|$|E
50|$|Players {{are given}} a {{classification}} {{depending on the type}} and extent of their disability. The classification system allows players to compete against others with a similar level of <b>function.</b> <b>Table</b> tennis has ten numbered classes, with lower numbers corresponding to more severe disability. Classes one through five compete in wheelchairs and classes six through ten compete while standing.|$|E
50|$|To {{automate}} costly engineering processes, some EDA {{can take}} state tables that describe state machines and automatically produce a truth table or a <b>function</b> <b>table</b> for the combinational logic {{of a state}} machine. The state table {{is a piece of}} text that lists each state, together with the conditions controlling the transitions between them and the belonging output signals.|$|E
50|$|During {{the early}} stages of his career, he {{developed}} and compiled several mathematical tables such as the Standard Four Figure Mathematical Tables jointly constructed with L. J. Comrie and published in 1931, Standard Table of Square Roots (1932), and Jacobian Elliptic <b>Function</b> <b>Tables</b> (1932).|$|R
50|$|The {{first version}} of the ENIAC {{computer}} was programmed via cabling, switches and plugboards. ENIAC's cabling was later reconfigured to use the existing <b>Function</b> <b>Tables</b> data ROM memory as program ROM memory (the switches and plugboards continued {{to be used in}} the reconfigured ENIAC).|$|R
25|$|A {{number of}} {{improvements}} {{were made to}} ENIAC after 1948, including a primitive read-only stored programming mechanism using the <b>Function</b> <b>Tables</b> as program ROM, an idea included in the ENIAC patent and proposed independently by Richard Clippinger of BRL. Clippinger consulted with von Neumann on what instruction set to implement. Clippinger had thought of a 3-address architecture while von Neumann proposed a 1-address architecture because it was simpler to implement. Three digits of one accumulator (6) were used as the program counter, another accumulator (15) {{was used as the}} main accumulator, a third accumulator (8) was used as the address pointer for reading data from the <b>function</b> <b>tables,</b> and most of the other accumulators (1–5, 7, 9–14, 17–19) were used for data memory.|$|R
50|$|Early in 1952, a {{high-speed}} shifter was added, which improved the speed for shifting {{by a factor}} of five. In July 1953, a 100-word expansion core memory was added to the system, using binary coded decimal, excess-3 number representation. To support this expansion memory, ENIAC was equipped with a new <b>Function</b> <b>Table</b> selector, a memory address selector, pulse-shaping circuits, and three new orders were added to the programming mechanism.|$|E
50|$|A {{patient may}} suffer from various {{illnesses}} regarding the wrist. Examples include TFCC lesion, scapholunate and lunotriquetral instability, ganglions, and synovitis. These illnesses concern many different tissues and structures. By using just one portal, one {{will never be}} able to visualize all these structures and tissues. For that reason, several portals exist, each having its own <b>function</b> (<b>Table</b> 1). The traditional portals are at the back of the hand (dorsal side), because many neurovascular structures are at risk at the palmar side of the hand.|$|E
50|$|The input for ESPRESSO is a <b>function</b> <b>table</b> of {{the desired}} functionality; {{the result is a}} {{minimized}} table, describing either the ON-cover or the OFF-cover of the function, depending on the selected options. By default, the product terms will be shared as much as possible by the several output functions, but the program can be instructed to handle each of the output functions separately. This allows for efficient implementation in two-level logic arrays such as a PLA (Programmable Logic Array) or a PAL (Programmable Array Logic).|$|E
40|$|Classical {{strategies}} for resource management in operating systems are often complex and innapropriate for embedded systems. Implementations for these strategies may use either virtual <b>function</b> <b>tables</b> or long conditional structures to provide transparent access to different resources. This overhead is unacceptable for embedded systems. The EPOS operating system provides flexible and transparent {{access to resources}} for applications without incurring in unnecessary overhead. Metaprogrammed structures are used to predict, according to application usage and in compile time, whether a resource must use a polymorphic representation or may be accessed through direct calls. This way, virtual <b>function</b> <b>tables</b> are only used in the system when strictly necessary, and thus saving resources. In this article, we show that this strategy is a viable alternative for resource management in embedded systems...|$|R
40|$|Over 300 {{sequences}} {{and many}} unsolved problems and conjectures related to them are presented herein together with theorems corollaries, formulae, examples, mathematical criteria, etc. (about integer sequences, numbers, quotients, residues, exponents, sieves, pseudo-primes/squares/cubes/factorials, almost primes, mobile periodicals, <b>functions,</b> <b>tables,</b> prime/square/factorial bases, generalized factorials, generalized palindromes, etc.). Comment: 140 page...|$|R
40|$|This paper {{describes}} new two obfuscation methods {{the fist}} method can control computational complexity {{and the second}} method can achieve semantic obfuscation. The computational complexity can be strictly controlled by using the technique of RSA encryption. The computational complexity can be arbitrarily specified by the impossibility of factorization of prime number in RSA encryption method. Semantic obfuscation is achieved by transforming a <b>function</b> into a <b>table</b> <b>function.</b> The <b>table</b> <b>function</b> method only shows input data and output data. It hides all the intermediate processing data. Because the explicit function form is hidden, {{it is thought that}} analysis takes time. The computational complexity technique and semantic technique can be used at the same time, by embedding the <b>table</b> <b>function</b> into the program with computational complexity method...|$|R
