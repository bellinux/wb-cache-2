1276|454|Public
5|$|This proof, {{published}} by Gabriel Lamé in 1844, represents {{the beginning of}} computational complexity theory, and also the first practical application of the <b>Fibonacci</b> <b>numbers.</b>|$|E
5|$|For a {{time after}} the fourth night, Robert cannot find the Number Devil in his dreams; later, however, on the fifth night, Robert finds himself at a desert where the Number Devil teaches him about {{triangular}} numbers {{through the use of}} coconuts. On the sixth night, the Number Devil teaches Robert about the natural occurrence of <b>Fibonacci</b> <b>numbers,</b> which the Number Devil shortens to Bonacci numbers, by counting brown and white rabbits as they reproduce multiple times. By this dream, Robert's mother has noticed a visible change in Robert's mathematical interest, and Robert begins going to sleep earlier to encounter the Number Devil. The seventh night brings Robert to a bare, white room, where the Number Devil presents Pascal's triangle and the patterns that the triangular array displays. On the eighth night, Robert is brought to his classroom at school. The Number Devil arranges Robert's classmates in multiple ways, teaches him about permutations, and what the Number Devil calls vroom numbers (factorials).|$|E
5|$|The {{computational}} {{efficiency of}} Euclid's algorithm {{has been studied}} thoroughly. This efficiency can be described {{by the number of}} division steps the algorithm requires, multiplied by the computational expense of each step. The first known analysis of Euclid's algorithm is due to A. A. L. Reynaud in 1811, who showed that the number of division steps on input (u, v) is bounded by v; later he improved this to v/2 +2. Later, in 1841, P. J. E. Finck showed that the number of division steps is at most 2log2v+1, and hence Euclid's algorithm runs in time polynomial {{in the size of the}} input. Émile Léger, in 1837, studied the worst case, which is when the inputs are consecutive <b>Fibonacci</b> <b>numbers.</b> Finck's analysis was refined by Gabriel Lamé in 1844, who showed that the number of steps required for completion is never more than five times the number h of base-10 digits of the smaller numberb.|$|E
5000|$|... a <b>Fibonacci</b> <b>number,</b> being 3 plus 5. The next <b>Fibonacci</b> <b>number</b> is 13. 8 is {{the only}} {{positive}} <b>Fibonacci</b> <b>number,</b> aside from 1, that is a perfect cube.|$|R
50|$|The {{length of}} each Fibonacci string is a <b>Fibonacci</b> <b>number,</b> and {{similarly}} {{there exists a}} corresponding Fibonacci string for each <b>Fibonacci</b> <b>number.</b>|$|R
40|$|In 1982, Prodinger and Tichy {{defined the}} <b>Fibonacci</b> <b>number</b> of a graph G {{to be the}} number of {{independent}} sets of the graph G. They did so since the <b>Fibonacci</b> <b>number</b> of the path graph Pn is the <b>Fibonacci</b> <b>number</b> F(n+ 2) and the <b>Fibonacci</b> <b>number</b> of the cycle graph Cn is the Lucas number Ln. The tadpole graph Tn,k is the graph created by concatenating Cn and Pk with an edge from any vertex of Cn to a pendant of Pk for integers n= 3 and k= 0. This paper establishes formulae and identities for the <b>Fibonacci</b> <b>number</b> of the tadpole graph via algebraic and combinatorial methods...|$|R
25|$|The <b>Fibonacci</b> <b>numbers</b> {{are also}} {{an example of}} a {{complete}} sequence. This means that every positive integer can be written as a sum of <b>Fibonacci</b> <b>numbers,</b> where any one number is used once at most.|$|E
25|$|The <b>Fibonacci</b> <b>numbers</b> are {{important}} in the computational run-time analysis of Euclid's algorithm to determine the greatest common divisor of two integers: the worst case input for this algorithm {{is a pair of}} consecutive <b>Fibonacci</b> <b>numbers.</b>|$|E
25|$|Moreover, every {{positive}} integer can {{be written}} in a unique way as the sum {{of one or more}} distinct <b>Fibonacci</b> <b>numbers</b> {{in such a way that}} the sum does not include any two consecutive <b>Fibonacci</b> <b>numbers.</b> This is known as Zeckendorf's theorem, and a sum of <b>Fibonacci</b> <b>numbers</b> that satisfies these conditions is called a Zeckendorf representation. The Zeckendorf representation of a number can be used to derive its Fibonacci coding.|$|E
50|$|In particular, for n {{greater than}} 12, the nth <b>Fibonacci</b> <b>number</b> F(n) {{has at least}} one prime divisor that does not divide any earlier <b>Fibonacci</b> <b>number.</b>|$|R
5000|$|... 55 is the 10th <b>Fibonacci</b> <b>number</b> and a {{triangular}} number (the {{sum of the}} consecutive numbers 1 to 10). It is the largest <b>Fibonacci</b> <b>number</b> to also be {{a triangular}} number.|$|R
5000|$|... where [...] is the th <b>Fibonacci</b> <b>number,</b> and so [...] is the th {{distinct}} <b>Fibonacci</b> <b>number</b> {{starting with}} [...] The last bit [...] {{is always an}} appended bit of 1 and does not carry place value.|$|R
25|$|In words, {{the sum of}} {{the first}} <b>Fibonacci</b> <b>numbers</b> with odd index up to F2n−1 is the (2n)th Fibonacci number, and {{the sum of the}} first <b>Fibonacci</b> <b>numbers</b> with even index up to F2n is the (2n+1)th Fibonacci number minus1.|$|E
25|$|An easily {{programmed}} alternative {{using only}} integer arithmetic is to calculate two large consecutive <b>Fibonacci</b> <b>numbers</b> and divide them. The ratio of <b>Fibonacci</b> <b>numbers</b> F 25001 and F 25000, each over 5000 digits, yields over 10,000 significant digits {{of the golden}} ratio.|$|E
25|$|<b>Fibonacci</b> <b>numbers</b> {{are used}} by some {{pseudorandom}} number generators.|$|E
50|$|Two is {{the third}} <b>Fibonacci</b> <b>number.</b>|$|R
40|$|It is {{well known}} that the / 1 th <b>Fibonacci</b> <b>number</b> Fn is given by the Binet-Moivre form Fn = {a n- p n) IV 5, where a, 0 = (l ± J 5) 12. JVlobius [2], however, gave a {{different}} way to characterize a <b>Fibonacci</b> <b>number.</b> Let z be an integer with z> 2. Then z is a. <b>Fibonacci</b> <b>number</b> if and only if the interval [gz-l/z, gz + l/z] contains exactly one integer ^ where g=a = (l + 45) / 2 is th...|$|R
50|$|In particular, {{when there}} is a <b>Fibonacci</b> <b>number</b> of coins in the {{starting}} pile, the position is losing for the first player (and winning for the second player). However, when the starting number of coins is not a <b>Fibonacci</b> <b>number,</b> the first player can always win with optimal play.|$|R
25|$|A {{one-dimensional}} optimization method, {{called the}} Fibonacci search technique, uses <b>Fibonacci</b> <b>numbers.</b>|$|E
25|$|<b>Fibonacci</b> <b>numbers</b> {{arise in}} the {{analysis}} of the Fibonacci heap data structure.|$|E
25|$|All known {{factors of}} <b>Fibonacci</b> <b>numbers</b> F(i) {{for all i}} < 50000 are {{collected}} at the relevant repositories.|$|E
40|$|Motivated by {{a problem}} posed by Barwell, we apply graph theory to {{determine}} all n {{for which the}} numbers 1, [...] ., n can be ordered so that the sum of any two consecutive terms is a <b>Fibonacci</b> <b>number.</b> We prove that such an ordering exists {{if and only if}} n is 9, 11, a <b>Fibonacci</b> <b>number,</b> or one less than a <b>Fibonacci</b> <b>number.</b> For each such n, we also prove that at most two such orderings exist, up to symmetry. In this paper, we consider a problem posed by Barwell [1]. Barwell asked for an ordering of the numbers 1, [...] ., 34 such that any two consecutive terms sum to a <b>Fibonacci</b> <b>number.</b> We attack this problem using graph theory, by defining a graph with vertices { 1, [...] ., 34 } and edges {uv: u + v is a Fibonacci number}. An ordering of the desired form then corresponds to a spanning path in the graph, i. e. a path that visits each vertex. Using this approach, we solve a more general problem by determining all n such that the numbers 1, [...] ., n, have such an ordering: this holds if and only if n is 9, 11, a <b>Fibonacci</b> <b>number,</b> or one less than a <b>Fibonacci</b> <b>number.</b> We also prove that for each such n there are at most two such orderings (up to symmetry) ...|$|R
40|$|The <b>Fibonacci</b> <b>number</b> F (G) of a graph G {{is defined}} as the number of {{independent}} vertex subsets of G. It was introduced in a paper of Prodinger and Tichy in 1982. There, they also ask for a formula for the <b>Fibonacci</b> <b>number</b> of a generalized Petersen graph. The aim of the current paper is to solve this problem by deriving a recursion. It will be shown that the <b>Fibonacci</b> <b>number</b> of the generalized Petersen graph with 4 n + 2 vertices is asymptotically α n+ 1 / 2, where α = 5. 6709364838 is an algebraic number of degree 5...|$|R
5000|$|We write {{a program}} that computes the nth <b>Fibonacci</b> <b>number,</b> for n>2: ...|$|R
25|$|Barr also {{published}} a related work in The Sketch in around 1913, generalizing the <b>Fibonacci</b> <b>numbers</b> to higher-order recurrences.|$|E
25|$|The first 21 <b>Fibonacci</b> <b>numbers</b> Fn for n=0,1,2, …, 20 are: {{factored}} into primes {{and links to}} more extensive tables.|$|E
25|$|Since the {{conversion}} factor 1.609344 for miles to kilometers {{is close to}} the golden ratio (denoted φ), the decomposition of distance in miles into a sum of <b>Fibonacci</b> <b>numbers</b> becomes nearly the kilometer sum when the <b>Fibonacci</b> <b>numbers</b> are replaced by their successors. This method amounts to a radix 2 number register in golden ratio base φ being shifted. To convert from kilometers to miles, shift the register down the Fibonacci sequence instead.|$|E
5000|$|To {{examine a}} <b>Fibonacci</b> <b>number</b> program in PostScript: /fib { dup dup 1 eq exch 0 eq or not { dup 1 sub fib exch 2 sub fib add } if } defA {{recursive}} definition {{is used on}} the stack. The <b>Fibonacci</b> <b>number</b> function takes one argument. First, it is tested for being 1 or 0.|$|R
5000|$|Evaluating Pn-3(x) at x = 2 {{gives the}} nth <b>Fibonacci</b> <b>number</b> plus (-1)n.|$|R
5000|$|... its perimeter, at order n, equals [...] [...] is the nth <b>Fibonacci</b> <b>number.</b>|$|R
25|$|The <b>Fibonacci</b> <b>numbers</b> can {{be found}} in {{different}} ways among the set of binary strings, or equivalently, among the subsets of a given set.|$|E
25|$|Yuri Matiyasevich {{was able}} to show that the <b>Fibonacci</b> <b>numbers</b> can be defined by a Diophantine equation, which led to his solving Hilbert's tenth problem.|$|E
25|$|Generating {{the next}} number by adding 3 numbers (tribonacci numbers), 4 numbers (tetranacci numbers), or more. The {{resulting}} sequences {{are known as}} n-Step <b>Fibonacci</b> <b>numbers.</b>|$|E
2500|$|A Fibonacci prime is a <b>Fibonacci</b> <b>number</b> that is prime. The {{first few}} are: ...|$|R
40|$|This article {{discusses}} the Diophantine equations {{in the form}} x 2 + axy + by 2 = c. The values of a, b, and c are constructed by <b>Fibonacci</b> <b>number</b> Fn and Lucas number L n. Furthermore, all integer solutions of the Diophantine equations {{in the form of}} <b>Fibonacci</b> <b>number</b> and Lucas number is determined by using Fibonacci and Lucas identities...|$|R
5000|$|Upon termination, x1 is the (n−1)-th <b>Fibonacci</b> <b>number</b> and x2 is the nth <b>Fibonacci</b> <b>number.</b> i is an {{iterator}} {{variable that}} goes from n to 2. As i is decremented in every iteration, the assumption (...) is only true {{prior to the}} first iteration. The test is (...) is only true after the last iteration of the loop (assuming i > 2).|$|R
