44|327|Public
50|$|Dynamic {{dispatch}} {{is different}} from late binding (also known as dynamic binding). In the context of selecting an operation, binding associates a name to an operation. Dispatching chooses an implementation for the operation after you have decided which operation a name refers to. With dynamic dispatch, the name may be bound to a polymorphic operation at compile time, but the implementation not be chosen until run time. While dynamic dispatch does not imply late binding, late binding does imply <b>dynamic</b> <b>dispatching</b> since the binding is what determines the set of available dispatches.|$|E
50|$|SOM is {{also much}} more robust {{in terms of}} fully {{supporting}} {{a wide variety of}} OO languages. Whereas basic COM essentially defines a cut-down version of C++ to program to, SOM supports almost all common features and even some more esoteric ones. For instance SOM supports multiple inheritance, metaclasses and <b>dynamic</b> <b>dispatching.</b> Some of these features are not found in most languages, which had led most SOM/COM-like systems to be simpler at the cost of supporting fewer languages. The full flexibility of multi-language support was important to IBM, however, as they had a major effort underway to support both Smalltalk (single inheritance and dynamic dispatch) with C++ (multiple inheritance and fixed dispatch).|$|E
40|$|We {{propose a}} <b>dynamic</b> <b>dispatching</b> rule for {{semiconductor}} assembly production line {{based on the}} current mainstream <b>dynamic</b> <b>dispatching</b> rules. In particular, our dispatching rule considers batch dispatching. Evaluated through simulation, we confirmed {{the effectiveness of this}} dispatching rule and provided additional operational insights for actual production system...|$|E
50|$|A {{language}} may {{be implemented}} with different <b>dynamic</b> <b>dispatch</b> mechanisms. The choices of the <b>dynamic</b> <b>dispatch</b> mechanism {{offered by a}} language {{to a large extent}} alter the programming paradigms that are available or are most natural to use within a given language.|$|R
5000|$|C {{does not}} have <b>dynamic</b> <b>dispatch,</b> {{so it must be}} {{implemented}} manually in some form. Often an enum is used to identify the subtype of an object. <b>Dynamic</b> <b>dispatch</b> can be done by looking up this value in a function pointer branch table. Here is a simple example in C: ...|$|R
50|$|<b>Dynamic</b> <b>dispatch</b> {{contrasts}} with static dispatch, {{in which the}} implementation of a polymorphic operation is selected at compile-time. The purpose of <b>dynamic</b> <b>dispatch</b> is to support cases where the appropriate implementation of a polymorphic operation cannot be determined at compile time because it depends on the runtime type of one or more actual parameters to the operation.|$|R
40|$|Fortran 90 is a modern, {{powerful}} {{language with}} features that support important new programming concepts, including {{those used in}} object-oriented programming. This paper briefly summarizes how to express the concepts of data encapsulation, function overloading, classes, objects, inheritance, and <b>dynamic</b> <b>dispatching.</b> 1 I...|$|E
40|$|Some of the {{benefits}} of object-oriented programming such as extensibility and reusability are fundamentally based on inheritance and late binding. <b>Dynamic</b> <b>dispatching</b> is not only time consuming but it also prevents the usage of some optimization techniques such as inlining or interprocedural analysis. The situation is even more severe for languages supporting multi-methods, where dispatching is not only performed based on the type of the receiver, but also based on the types of the arguments. The most efficient way to perform <b>dynamic</b> <b>dispatching</b> is to avoid it as often as possible, without restricting the use of multi-methods. In this paper it is shown how this goal can be achieved through static analysis. We present a technique which discards all method calls which can be statically bound. Furthermore, even if a method cannot be statically bound, we derive information which will at run time speed up the dispatching process considerably. on leave from: FH Wiesbaden, Fachbereich Infor [...] ...|$|E
40|$|Abstract. Cost {{analysis}} of Java bytecode {{is complicated by}} its unstructured control flow, {{the use of an}} operand stack and its object-oriented programming features (like <b>dynamic</b> <b>dispatching).</b> This paper addresses these problems and develops a generic framework for the automatic cost {{analysis of}} sequential Java bytecode. Our method generates cost relations which define at compile-time the cost of programs as a function of their input data size. To the best of our knowledge, this is the first approach to the automatic cost analysis of Java bytecode. ...|$|E
5000|$|The fragile {{base class}} {{problem has been}} blamed on open {{recursion}} (<b>dynamic</b> <b>dispatch</b> of methods on [...] ), with the suggestion that invoking methods on [...] default to closed recursion (static dispatch, early binding) rather than open recursion (<b>dynamic</b> <b>dispatch,</b> late binding), only using open recursion when it is specifically requested; external calls (not using [...] ) would be dynamically dispatched as usual.|$|R
50|$|C++ uses {{early binding}} and offers both <b>dynamic</b> and static <b>{{dispatch}}.</b> The default form of dispatch is static. To get <b>dynamic</b> <b>dispatch</b> the programmer must declare a method as virtual.|$|R
50|$|<b>Dynamic</b> <b>dispatch</b> is only done via {{procedures}} in Figures module {{that is the}} generic module.|$|R
40|$|Abstract. Based on the {{analyzing}} of {{the characteristics}} of a Body-In-White pressing production process a pressing workshop production management system has been given {{in order to make the}} ERP production scheduling more executable. The detailed function model of it such as task assignment, quality control, mold maintenance and production scheduling has been thoroughly discussed. In order to make the production line capability balance the task dispatching algorithm has been given and the <b>dynamic</b> <b>dispatching</b> and controlling process has been explained. This system can be integrated with the upper ERP/CAPP/PDM system which can improve the information level of a company...|$|E
40|$|This paper {{focuses on}} bed {{resources}} allocation {{in a hospital}} taking into account hospitalization demands, bed capacity, and Activity-Dependent Price (T 2 A) incomes. The data used in this research work combines the elective patient flow and the acute patient flow from emergency department. A mathematical model based on a <b>dynamic</b> <b>dispatching</b> approach is developed and experimented respectively with Lingo and Cplex. Our objective is to maximize the incomes based on T 2 A and to minimize the cost to use supplementary beds. As {{a result of this}} model, the bed allocation planning calculated from the best objective value is presented...|$|E
40|$|International audienceThis paper {{focuses on}} bed {{resources}} allocation in hospital {{taking into account}} hospitalization demands, bed capacity, and “Tarification à l’Activité” (T 2 A) incomes. The data used in this research work combine the elective patient flow and the acute patient flow from emergency department. A mathematical model based on a <b>dynamic</b> <b>dispatching</b> approach is developed and experimented respectively with two mathematical optimization solvers, Lingo and Cplex. Our objective is to maximize the incomes based on T 2 A and to minimize the cost to use supplementary beds. As {{a result of this}} model, the bed allocation planning calculated from the best objective value is presented...|$|E
50|$|<b>Dynamic</b> <b>dispatch</b> {{will always}} incur an {{overhead}} so some languages offer static dispatch for particular methods.|$|R
5000|$|... late-binding (i.e. <b>dynamic</b> <b>dispatch</b> to CLR, DLR, and COM objects) on values statically typed as Object.|$|R
5000|$|... {{abstract}} {{data types}} (which have existential types) allow {{the definition of}} modules but these do not support <b>dynamic</b> <b>dispatch</b> ...|$|R
40|$|AbstractThis study {{explores the}} {{challenge}} of the <b>dynamic</b> <b>dispatching</b> of taxis to the immediate passenger booking requests. In particular, the study leverages on a stable marriage assignment algorithm and applies it for dispatching taxis to passengers. The stable marriage algorithm was developed initially for matching men and women according to their preferences in polynomial time. The results of the custom built simulation model show that the taxi dispatching strategy based on the stable marriage matching improves the taxi operation performance in all observed indicators (taxi profit, number of served passengers, not-occupied and total taxi mileage and passenger waiting time) as compared to the standard first-come, first-served strategy...|$|E
40|$|This {{dissertation}} {{examines the}} use of whole-program optimization {{as a way of}} improving the performance of object-oriented programming languages. Although object-oriented programming conveys a number of software engineering benefits, heavy application of its trademark feature, <b>dynamic</b> <b>dispatching,</b> imposes severe performance penalties when programs are compiled using traditional compilation techniques. Several new techniques that rely on whole-program optimization are described, and these techniques substantially improve the performance of object-oriented programs written in Cecil, Java, C++, and Modula- 3. Among the new techniques is class hierarchy analysis, which provides the compiler with knowledge of the class hierarchy of the entire program. This is an especially important optimization, becaus [...] ...|$|E
40|$|This paper {{describes}} Lua, {{a language}} for extending applications. Lua combines procedural features with powerful data description facilities, {{by using a}} simple, yet powerful, mechanism of tables. This mechanism implements the concepts of records, arrays, and recursive data types (pointers), and adds some object-oriented facilities, such as methods with <b>dynamic</b> <b>dispatching.</b> Lua presents a mechanism of fallbacks that allows programmers to extend the semantics of the language in some unconventional ways. As a noteworthy example, fallbacks allow the user to add different kinds of inheritance to the language. Currently, Lua is being extensively used in production for several tasks, including user configuration, general-purpose data-entry, description of user interfaces, and storage of structured graphical metafiles...|$|E
5000|$|New Visual Basic [...]NET and C# {{language}} features, such as implicit line continuations, <b>dynamic</b> <b>dispatch,</b> named parameters, and optional parameters ...|$|R
50|$|Although <b>dynamic</b> <b>dispatch</b> is {{not usually}} {{classified}} as a conditional construct, it {{is another way to}} select between alternatives at runtime.|$|R
40|$|<b>Dynamic</b> <b>dispatch,</b> or {{late binding}} of {{function}} calls, is a salient feature of object-oriented programming languages like C++ and Java. It {{can be costly}} on deeply pipelined processors, because dynamic calls translate to hard to predict multi-way branch instructions, which are prone to causing pipeline bubbles. Several alternative implementation techniques have been designed {{in the past in}} order to perform <b>dynamic</b> <b>dispatch</b> without relying on these expensive branch instructions. Unfortunately it is difficult to compare the performance of these competing techniques, and the issue of which technique is best under what conditions still has no clear answer. In this study we aim to answer this question, by measuring the performance of four alternative control structures for <b>dynamic</b> <b>dispatch</b> on several execution environments, under a variety of precisely controlled execution conditions...|$|R
40|$|The {{automated}} warehouse considered here {{consists of}} a number of rack locations with three cranes, a narrow aisle shuttle, and several buffer stations with the roller. Based on analyzing of the behaviors of the active resources in the system, a modular and computerized model is presented via a colored timed Petri net approach, in which places are multicolored to simplify model and characterize control flow of the resources, and token colors are defined as the routes of storage/retrieval operations. In addition, an approach for realization of model via visual c++ is briefly given. These facts allow us to render an emulate system to simulate a discrete control application for on-line monitoring, <b>dynamic</b> <b>dispatching</b> control and off-line revising scheduler policies...|$|E
40|$|Abstract. In {{order to}} {{implement}} the balanced distribution in Cloud Computing system and to improve the utilization ratio of the resource as well as handling up rate of the system, the system of <b>dynamic</b> <b>dispatching</b> system based on Cloud Computing has been designed and implemented after the study on the Cloud Computing. Firstly, a layered loading balancing scheduling mode has been proposed, providing {{the structure of the}} dispatching service system. Secondly, a comprehensive service distribution algorithm has been designed and implemented in consideration of respective local service counts, each join points ’ performance, current load distribution and semantic. Finally, the result of the experiment indicates that the scheduling system can improve the efficiency of dispatching service and the utilization ratio in the Cloud Computing system...|$|E
40|$|The {{run-time}} {{characteristics of}} Java, {{such as high}} frequency of method invocation, <b>dynamic</b> <b>dispatching</b> and dynamic loading, make Java more difficult than other object-oriented programming languages, such as C++, for conducting Worst-Case Execution Time (WCET) analysis. To offer a more flexible way to develop object-oriented real-time applications in the realtime Java environment without loss of predicability and performance, we propose a novel gain time reclaiming framework integrated with WCET analysis. This paper demonstrates how to improve the utilisation and performance of the whole system by reclaiming gain time at run-time. Our approach shows that integrating WCET with gain time reclaiming can not only provide a more flexible environment, but it also does not necessarily result in unsafe or unpredictable timing behaviour...|$|E
50|$|The C++ {{standards}} do not mandate {{exactly how}} <b>dynamic</b> <b>dispatch</b> must be implemented, but compilers generally use minor {{variations on the}} same basic model.|$|R
25|$|Objective-J, a superset of JavaScript that compiles to {{standard}} JavaScript. It adds traditional inheritance and Smalltalk/Objective-C style <b>dynamic</b> <b>dispatch</b> and optional pseudo-static typing to JavaScript.|$|R
40|$|Understanding {{mechanisms}} that affect degradation and durability of solid oxide fuel cell (SOFC) stacks and systems {{is becoming increasingly}} important as systems are being deployed around the world. A novel simulation approach accounting for state-of-the-art understanding of degradation mechanisms {{in the context of}} an operating SOFC system has been developed. Investigative tools simulating lifetime degradation have been applied to a physical SOFC system model designed and controlled to allow <b>dynamic</b> <b>dispatch.</b> The system was operated in two modes (a) constant power output mode, and (b) diurnal <b>dynamic</b> <b>dispatch</b> mode. Results show that on a time basis the SOFC system with <b>dynamic</b> <b>dispatch</b> proved more durable and less degraded than the system operated in constant full-power output. The net energy production was roughly equivalent between the two modes, with the dynamically dispatched fuel cell degrading slightly less and producing a greater portion of power during peak demand. ©The Electrochemical Society...|$|R
40|$|Conventional {{specifications}} for object-oriented (OO) programs must adhere to behavioral subtyping {{in support of}} class inheritance and method overriding. However, this requirement inherently weakens the specifications of overridden methods in superclasses, leading to imprecision during program reasoning. To address this, we advocate a fresh approach to OO verification {{that focuses on the}} distinction and relation between specifications that cater to calls with static dispatching from those for calls with <b>dynamic</b> <b>dispatching.</b> We formulate a novel specification subsumption that can avoid code re-verification, where possible. Using a predicate mechanism, we propose a flexible scheme for supporting class invariant and lossless casting. Our aim is to lay the foundation for a practical verification system that is precise, concise and modular for sequential OO programs. We exploit the separation logic formalism to achieve this...|$|E
40|$|The use of dynamically-dispatched {{procedure}} calls {{is a key}} {{mechanism for}} writing extensible and flexible code in object-oriented languages. Unfortunately, <b>dynamic</b> <b>dispatching</b> imposes a runtime performance penalty. Some recent implementations of pure object-oriented languages have utilized profile-guided receiver class prediction to reduce this performance penalty, and some researchers have argued for applying receiver class prediction in hybrid languages like C++. We performed a detailed examination of the dynamic profiles of eight large object-oriented applications written in C++ and Cecil, determining that the receiver class distributions are strongly peaked and stable across both inputs and program versions through time. We describe techniques for gathering and manipulating profile information at varying degrees of precision, particularly {{in the presence of}} optimizations such as inlining. Our implementation of profile-guided receiver class prediction improves the performance of lar [...] ...|$|E
40|$|Introduction Nowadays, {{middleware}} {{technologies are}} the main infrastructure to support component-based programming. To meet the dynamic configuration requirements of several application classes, middleware systems like CORBA and DCOM provide some reflective mechanisms, such as interface introspection, <b>dynamic</b> <b>dispatching,</b> and message interceptors. Recent evolution of CORBA and DCOM {{emphasizes the importance of}} reflective mechanisms for middleware systems [8, 4]. Some research works have also focused on developing reflective mechanisms that allow the dynamic evolution of the middleware itself [5, 9]. To take advantage of a reflective middleware, it is necessary to have programming tools that provide dynamic facilities. However, traditional language bindings for middleware systems are based on statically compiled stubs and skeletons. This requires clients to be recompiled each time a change in the server's interface takes place or each time a new service is to be used. Servers must be...|$|E
50|$|The vtable is {{generally}} {{a good performance}} trade-off to achieve <b>dynamic</b> <b>dispatch,</b> but there are alternatives, such as binary tree dispatch, with higher performance but different costs.|$|R
40|$|The {{notion of}} MyType has been {{proposed}} to promote type-safe reuse of binary methods and recently extended to mutually recursive definitions. It is well known, however, that MyType does not match with subtyping well. In the current type systems, type safety is guaranteed at the expenses of subtyping, hence <b>dynamic</b> <b>dispatch.</b> In this article, we propose two mechanisms, namely, nonheritable methods and exact statements to remedy the mismatch between MyType and subtyping. We rigorously prove their safety by modeling them in a small calculus. Key words: binary methods, <b>dynamic</b> <b>dispatch,</b> exact types, MyType, subtypin...|$|R
5000|$|... <b>dynamic</b> <b>dispatch</b> - common {{functions}} can be pre-loaded {{and less}} common functions fetched only on first encounter to reduce memory usage. In-table memoization {{can be employed}} to achieve this.|$|R
