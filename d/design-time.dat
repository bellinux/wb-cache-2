860|0|Public
50|$|There is {{a direct}} {{relationship}} between run-time autonomy and the <b>design-time</b> autonomy. Increasing the <b>design-time</b> autonomy automatically increases the ability to evolve service’s implementation environment.|$|E
5000|$|<b>Design-time</b> {{spreadsheet}} schema wizard and spreadsheet format designer ...|$|E
50|$|Installing a <b>design-time</b> {{package is}} {{equivalent}} to linking to the IDE, thus distributing the Lazarus IDE with a GPL-incompatible <b>design-time</b> package (e.g. the JEDI packages, which are licensed under the Mozilla Public License) pre-installed would cause a license violation. This however does not prohibit proprietary packages from being developed with Lazarus.|$|E
5000|$|Sophisticated {{workflow}} {{model validation}} features (e.g. deadlock detection at <b>design-time).</b>|$|E
5000|$|Management: the <b>design-time</b> and {{run-time}} Cloud management {{from multiple}} perspectives ...|$|E
5000|$|... a <b>design-time</b> HMI/GUI {{construction}} tool (called Citect Graphics Builder) and ...|$|E
5000|$|Compiled {{code means}} {{applications}} run faster with more <b>design-time</b> errors trapped at the development stage.|$|E
5000|$|Services are {{independent}} {{and control the}} functionality they encapsulate, from a <b>Design-time</b> and a run-time perspective.|$|E
50|$|Essential {{elements}} of an SOAIF include <b>design-time</b> and run-time infrastructure, together with service-oriented tools for deploying distributed processes and implementation flows.|$|E
5000|$|In [...]Net 2.0, Windows Forms gained richer layout controls, office 2003 style toolstrip controls, {{multithreading}} component, richer <b>design-time</b> {{and data}} binding support {{as well as}} ClickOnce for web-based deployment.|$|E
50|$|On 18 April 2011, version 4.0.1 was {{released}} supporting some customer-demanded fixes for Windows Workflow Foundation. Its <b>design-time</b> component, which requires Visual Studio 2010 SP1, adds a workflow state machine designer.|$|E
50|$|For {{the purpose}} of static analysis, e.g. to detect {{semantic}} errors at <b>design-time,</b> {{it is also possible}} to represent workflow in a mathematical form using a formal notation such as Petri nets.|$|E
50|$|GLScene allows programmers {{to create}} OpenGL 3D objects at <b>design-time</b> using the {{interface}} shown. A {{wide range of}} objects and additional VCL controls are provided to help the programmer to build powerful 3D Delphi applications.|$|E
5000|$|VSTO {{solutions}} developed against newer Office versions {{will not}} work in older Office versions as they lack the necessary Primary Interop Assemblies (PIAs) [...] Office 2010 applications will always use VSTO 2010 Runtime. <b>Design-time</b> support is as follows: ...|$|E
5000|$|Elastic Page Design: (also patent-pending) enables {{developers}} to design complex web interfaces that allow {{parts of the}} web page to dynamically adjust their size to suit their content at run-time (fluid layout), whilst maintaining all <b>design-time</b> constraints (fixed layout).|$|E
50|$|Eventually {{system designs}} {{may see the}} advent of {{composable}} architectures where published semantic-based interfaces are joined together to enable new and meaningful capabilities. These could predominately be described by means of <b>design-time</b> declarative specifications, that could ultimately be rendered and executed at run-time.|$|E
50|$|The {{application}} of the service loose coupling and the service abstraction principles helps in attaining <b>design-time</b> autonomy as their application results in services whose contracts are shielded from their logic and implementation and hence, the services could be redesigned without affecting their service consumers.|$|E
5000|$|These systems, {{sometimes}} referred to as [...] "static site generators", pre-process all content, applying templates before publication to generate web pages. Since pre-processing systems do not require a server to apply the templates at request time, they may also exist purely as <b>design-time</b> tools.|$|E
5000|$|<b>Design-time</b> {{autonomy}} {{refers to}} the independence with which the services could be evolved without impacting their service consumers. This type of autonomy is required as the service’s underlying legacy resources might need an overhaul or the service’s logic might need refactoring {{in order to make}} it more efficient.|$|E
5000|$|Semantic {{integration}} {{can also}} be used to facilitate <b>design-time</b> activities of interface design and mapping. In this model, semantics are only explicitly applied to design and the run-time systems work at the syntax level. This [...] "early semantic binding" [...] approach can improve overall system performance while retaining the benefits of semantic driven design.|$|E
5000|$|Careless use of locks {{can result}} in {{deadlock}} or livelock. A number of strategies {{can be used to}} avoid or recover from deadlocks or livelocks, both at <b>design-time</b> and at run-time. (The most common strategy is to standardize the lock acquisition sequences so that combinations of inter-dependent locks are always acquired in a specifically defined [...] "cascade" [...] order.) ...|$|E
50|$|Visual Composer {{produces}} {{applications in}} a declarative form, enabling code-free execution mode for multiple runtime environments. It provides application lifecycle support by maintaining {{the connection between}} an application and its model throughout its lifecycle. Visual Composer is designed with an open architecture, which enables developers to extend its <b>design-time</b> environment and modelling language, {{as well as to}} integrate external data services.|$|E
50|$|The core IDE exposes an API {{that other}} teams in Oracle use to build {{extensions}} to JDeveloper. BPEL, Portal, Business Intelligence and other {{components of the}} Oracle platform all build their <b>design-time</b> tools on top of JDeveloper. The same IDE platform also serves {{as the basis of}} another Oracle product, SQL Developer, which Oracle Corporation promotes specifically to PL/SQL- and database-developers.|$|E
50|$|Semantic design {{tools and}} runtime {{automation}} platforms {{can be built}} to support the fundamental concepts of SOP. For example, a service virtual machine (SVM) that automatically creates service objects as units of work and manages their context can be designed to run based on the SOP program metadata stored in XML and created by a <b>design-time</b> automation tool. In SOA terms, the SVM is both a service producer and a service consumer.|$|E
50|$|Visual Web Developer Express is a {{freeware}} web {{development tool}} that allows developers {{to evaluate the}} web development and editing capabilities of the other Visual Studio editions at no charge. Its main function is to create ASP.NET websites. It has a WYSIWYG interface, drag-and-drop user interface designer, enhanced HTML and code editors, a limited database explorer, support for CSS, JavaScript and XML, and integrated, <b>design-time</b> validation for standards including XHTML 1.0/1.1 and CSS 2.1.|$|E
5000|$|New {{types are}} defined using the [...] keyword. For {{functional}} programming, F# provides tuple, record, discriminated union, list, option, and result types. A tuple represents {{a set of}} n values, where n ≥ 0. The value n is called the arity of the tuple. A 3-tuple would be represented as , where A, B, and C are values of possibly different types. A tuple {{can be used to}} store values only when the number of values is known at <b>design-time</b> and stays constant during execution.|$|E
5000|$|Service-oriented {{architectures}} (SOA) {{are based}} on the notion of software services, which are high-level software components that include web services. Implementation of an SOA requires tools as well as run-time infrastructure software. This is collectively referred to as a service-oriented architecture implementation framework or (SOAIF). The SOAIF envisions a comprehensive framework that provides all the technology that an enterprise might need to build and run an SOA. An SOAIF includes both <b>design-time</b> and run-time capabilities as well as all the software functionality an enterprise needs to build and operate an SOA, including service-oriented: ...|$|E
50|$|Computer {{security}} inference {{control is}} {{the attempt to}} prevent users to infer classified information from rightfully accessible chunks of information with lower classification. Computer security professionals install protocols into databases to prevent inference attacks by software. Techniques to detect and remove inference channels can be organized into two categories. The ﬁrst category includes techniques that detect inference channels during database design time.Inference channels are removed by modifying the database design or by increasing the classiﬁcation levels {{of some of the}} data items. Techniques in the second category seek to eliminate inference channel violations during query processing time. If an inference channel is detected, the query is either refused or modiﬁed to avoid security violations. While <b>design-time</b> is easier to manage and implement, query-time approach allows more availability of data than in <b>design-time</b> approach because more information (past and present queries/answers) can be used for disclosure inference. Disclosure Monitor (DiMon) detects and eliminates inference channels based on database constraints. A Disclosure Inference Engine (DiIE) is proposed, that generates all information that can be disclosed based on a user’s previous query results, the current query results, and a set of Horn-clause constraints. Dynamic Disclosure Monitor (D2Mon) guarantees data confidentiality and maximal availability even in the presence of inferences and updates.It is our intention to complement an existing access control mechanism (e.g., DAC, MAC, RBAC) to address the inference problem.|$|E
5000|$|The {{strategy}} pattern uses composition {{instead of}} inheritance. In the strategy pattern, behaviors {{are defined as}} separate interfaces and specific classes that implement these interfaces. This allows better decoupling between the behavior and the class that uses the behavior. The behavior can be changed without breaking the classes that use it, and the classes can switch between behaviors by changing the specific implementation used without requiring any significant code changes. Behaviors can also be changed at run-time {{as well as at}} <b>design-time.</b> For instance, a car object’s brake behavior can be changed from BrakeWithABS (...) to Brake (...) by changing the brakeBehavior member to: ...|$|E
50|$|Flash Catalyst can import Adobe Photoshop, Adobe Illustrator, Adobe Fireworks, or Flash XML Graphics (FXG) files {{keeping all}} their features. The {{converted}} artwork {{can then be}} used as functional UI components (creating Flex component skins). After importing, users use simple WYSIWYG techniques to create and edit behaviors (mouse event handling, etc.) without writing code and create animated transitions. Flash Catalyst can also use <b>design-time</b> data placeholders when marking up an application, testing interactivity, and choreographing motion. These placeholders can then be replaced at production-time with final artwork. This same method {{can be used to}} create UIs to handle dynamic data without having access to the actual data source.|$|E
5000|$|Web Matrix {{included}} {{a number of}} features that made it an appealing alternative to Visual Studio 2003. It was a comparatively small download, fast and easy to install, and it was specific to Web applications. This set it apart from Visual Studio, avoiding many of the complexities required to support different tools, languages, and development environments in Visual Studio. It used a folder-based model, rather than the project model used in Visual Studio, and did not require <b>design-time</b> compilation into a single deployable [...]dll. Instead, developers could deploy the source code for their ASP.NET pages and rely on ASP.NET to dynamically compile the pages on first request.|$|E
5000|$|The next version, Delphi 2005 (Delphi 9, also Borland Developer Studio 3.0), {{included}} the Win32 and [...]NET {{development in a}} single IDE, reiterating Borland's commitment to Win32 developers. Delphi 2005 includes <b>design-time</b> manipulation of live data from a database. It also includes an improved IDE and added a for ... in statement (like C#'s foreach) to the language. However, it was widely criticized for its bugs; both Delphi 8 and Delphi 2005 had stability problems when shipped, which were only partially resolved in service packs. The ability to compile native windows applications (*.exe) was added back into Delphi 2005 after being removed in Delphi 8. CLX support was dropped for new applications from this release onwards.|$|E
5000|$|Although {{increasing}} service {{autonomy to}} the maximum extent is always desirable, {{it is not always}} possible to design each and every service with maximum <b>design-time</b> and run-time autonomy. As a result, the services need to be prioritized so that their autonomy could be addressed according to their value for business. This could be done by having a look at the functional context of the service. Services whose functional contexts are independent of any particular business process, e.g. entity [...] and utility services, are good candidates for increasing their autonomy. This is because they offer functionality that is of interest to different types of consumers. On the other hand, business process specific services, e.g. task and orchestrated task services, are less reusable and are dependent upon the individual autonomy of their composed services.|$|E
5000|$|A {{composite}} service can be declared to loop. The loop can {{be bound by}} a fixed number of iterations with an optional built-in delay between iterations and it can dynamically terminate using a [...] "service exit with success" [...] or [...] "service exit with failure" [...] construct inside of the looping {{composite service}}. Furthermore, any service interface can automatically run in a loop or [...] "foreach" [...] mode, if it is supplied with two or more input components upon automatic preparation. This behavior is supported at <b>design-time</b> when a data list structure from one service is connected to a service that takes a single data structure (i.e. non-plural) as its input. If a runtime property of the composite service interface is declared to support [...] "foreach" [...] in parallel, then the runtime automation environment can automatically multi-thread the loop and run it in parallel. This {{is an example of}} how SOP programming constructs provide built-in advanced functionality.|$|E
40|$|Institutions, also {{referred}} to as normative systems, offer ameans to govern open systems, in particular open multi-agent systems. Research in logics, and subsequently tools, has led to support for thespecification, verification and enactment of institutions. Most effort todate has focused on the <b>design-time</b> properties of institutions (either onthe normative or the system level), such as whether a particular state ofaffairs is reachable or not from a given set of initial conditions. Such modelsare useful in forcing the designer to state their intentions precisely,and for testing (<b>design-time)</b> properties. However, we identify two problemsin the direct utilization of <b>design-time</b> models in the governance oflive (run-time) systems: (i) over-specification of constraints on agent autonomyand (ii) generation of <b>design-time</b> model artefacts. In this paperwe present a methodology to tackle these two problems and extract runtimereasoning components from a <b>design-time</b> model. We demonstratehow to derive an event-based run-time model of institutions that can beincorporated into the capabilities of autonomous BDI agents to addressthe issues above in order to realize practical norm-governed multi-agentsystems. © Springer-Verlag Berlin Heidelberg 2012...|$|E
40|$|A Dynamic Software Product Line (DSPL) aims at {{managing}} run-time {{adaptations of}} a software system. It {{is built on}} the assumption that context changes that require these adaptations at run-time can be anticipated at <b>design-time.</b> Therefore, the set of adaptation rules and the space of configurations in a DSPL are predefined and fixed at <b>design-time.</b> Yet, for large-scale and highly distributed systems, anticipating all relevant context changes during <b>design-time</b> is often not possible due to the uncertainty of how the context may change. Such <b>design-time</b> uncertainty therefore may mean that a DSPL lacks adaptation rules or configurations to properly reconfigure itself at run-time. We propose an adaptive system model to cope with <b>design-time</b> uncertainty in DSPLs. This model combines learning of adaptation rules with evolution of the DSPL configuration space. It takes particular account of the mutual dependencies between evolution and learning, such as using feedback from unsuccessful learning to trigger evolution. We describe concrete steps for learning and evolution to show how such feedback can be exploited. We illustrate the use of such a model with a running example from the cloud computing domain...|$|E
