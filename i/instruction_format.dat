115|187|Public
25|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and unconditional branch instructions use the branch <b>instruction</b> <b>format,</b> while the jump instructions use the memory <b>instruction</b> <b>format.</b>|$|E
25|$|The <b>instruction</b> <b>format</b> used 3 bits for opcode, and 12 bits for address. Block I had 11 {{instructions:}} TC, CCS, INDEX, XCH, CS, TS, AD, and MASK (basic), and SU, MP, and DV (extra). The first eight, called basic instructions, {{were directly}} accessed by the 3-bit op. code. The final three were denoted as extracode instructions {{because they were}} accessed by performing a special type of TC instruction (called EXTEND) immediately before the instruction.|$|E
25|$|Most RISC {{architectures}} have fixed-length instructions (commonly 32 bits) and {{a simple}} encoding, which simplifies fetch, decode, and issue logic considerably. One drawback of 32-bit instructions is reduced code density, which is more adverse a characteristic in embedded computing {{than it is in}} the workstation and server markets RISC architectures were originally designed to serve. To address this problem, several architectures, such as ARM, Power ISA, MIPS, RISC-V, and the Adapteva Epiphany, have an optional short feature-reduced <b>instruction</b> <b>format</b> or instruction compression feature. The SH5 also follows this pattern, albeit having evolved in the opposite direction, having added longer media instructions to an original 16-bit encoding.|$|E
5000|$|The Simplified Instruction Computer {{has three}} <b>instruction</b> <b>formats,</b> and the Extra Equipment add-on {{includes}} a fourth. The <b>instruction</b> <b>formats</b> provide {{a model for}} memory and data management. Each format has a different representation in memory: ...|$|R
25|$|The integer {{arithmetic}} instructions use the integer operate <b>instruction</b> <b>formats.</b>|$|R
25|$|The Alpha ISA has a fixed {{instruction}} length of 32 bits. It has six <b>instruction</b> <b>formats.</b>|$|R
25|$|Both the PPE and SPE are RISC {{architectures}} with a fixed-width 32-bit <b>instruction</b> <b>format.</b> The PPE {{contains a}} 64-bit {{general purpose register}} set (GPR), a 64-bit floating point register set (FPR), and a 128-bit Altivec register set. The SPE contains 128-bit registers only. These {{can be used for}} scalar data types ranging from 8-bits to 64-bits in size or for SIMD computations on a variety of integer and floating point formats. System memory addresses for both the PPE and SPE are expressed as 64-bit values for a theoretic address range of 264 bytes (16 exabytes or 16,777,216 terabytes). In practice, not all of these bits are implemented in hardware. Local store addresses internal to the SPU (Synergistic Processor Unit) processor are expressed as a 32-bit word. In documentation relating to Cell a word is always taken to mean 32 bits, a doubleword means 64 bits, and a quadword means 128 bits.|$|E
2500|$|Uniform <b>instruction</b> <b>format,</b> using {{single word}} with the opcode {{in the same}} bit {{positions}} for simpler decoding ...|$|E
2500|$|IBM {{introduced}} a smaller, more affordable computer in 1954 that proved very popular. The IBM 650 weighed over 900kg, the attached power supply weighed around 1350kg {{and both were}} held in separate cabinets of roughly 1.5 meters by 0.9 meters by 1.8 meters. It cost US$500,000 ($ as of [...] ) or could be leased for US$3,500 a month ($ as of [...] ). Its drum memory was originally 2,000 ten-digit words, later expanded to 4,000 words. [...] Memory limitations such as this were to dominate programming for decades afterward. [...] The program instructions were fetched from the spinning drum as the code ran. [...] Efficient execution using drum memory was provided {{by a combination of}} hardware architecture: the <b>instruction</b> <b>format</b> included the address of the next instruction; and software: the Symbolic Optimal Assembly Program, SOAP, assigned instructions to the optimal addresses (to the extent possible by static analysis of the source program). Thus many instructions were, when needed, located in the next row of the drum to be read and additional wait time for drum rotation was not required.|$|E
5000|$|There {{are five}} <b>instruction</b> <b>formats,</b> {{referred}} to as Types A, B,C, D and E. [...] Most instructions are of type B.|$|R
5000|$|There are two <b>instruction</b> <b>formats,</b> {{referred}} to as [...] "Type A" [...] and [...] "Type B". [...] Most instructions were of type B.|$|R
40|$|The {{concept of}} retargetability enables {{compiler}} technology {{to keep pace}} with the increasing variety of domain-specific embedded processors. In order to achieve user retargetability, powerful processor modeling formalisms are required. Most of the recent modeling formalisms concentrate on horizontal, VLIWlike <b>instruction</b> <b>formats.</b> However, for encoded <b>instruction</b> <b>formats</b> with restricted instruction-level parallelism (ILP), a large number of ILP constraints might need to be specified, resulting in less concise processor models. This paper presents an HDL-based approach to processor modeling for retargetable compilation, in which ILP may be implicitly constrained. As a consequence, the formalism allows for concise models also for encoded <b>instruction</b> <b>formats.</b> The practical applicability of the modeling formalism is demonstrated by means of a case study for a complex DSP 1 1 Introduction As a result of the increasing diversity of embedded processors, retargetable compilers have received re [...] ...|$|R
50|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and unconditional branch instructions use the branch <b>instruction</b> <b>format,</b> while the jump instructions use the memory <b>instruction</b> <b>format.</b>|$|E
50|$|The Franklin Academy {{has adopted}} a Direct <b>Instruction</b> <b>format.</b>|$|E
5000|$|The <b>instruction</b> <b>format</b> for the 910 and 920 {{systems is}} as follows: ...|$|E
50|$|The basic <b>{{instruction}}</b> <b>formats</b> {{allowed for}} one, {{two and three}} word instructions. The model 990/12 CPU allowed for a four word instruction with the extended mode operations.|$|R
50|$|AltiVec is a {{standard}} part of the Power ISA v.2.03 specification. It was never formally {{a part of the}} PowerPC architecture until this specification although it used PowerPC <b>instruction</b> <b>formats</b> and syntax and occupied the opcode space expressly allocated for such purposes.|$|R
5000|$|Predicated {{instructions}} were popular in European computer designs of the 1950s, including the Mailüfterl (1955), the Zuse Z22 (1955), the ZEBRA (1958), and the Electrologica X1 (1958). The IBM ACS-1 design of 1967 allocated a [...] "skip" [...] bit in its <b>instruction</b> <b>formats,</b> and the CDC Flexible Processor in 1976 allocated three conditional execution bits in its microinstruction formats.|$|R
50|$|The AEA <b>instruction</b> <b>format</b> {{consisted}} of 5-bit instruction code, index bit and a 12-bit address.|$|E
5000|$|Uniform <b>instruction</b> <b>format,</b> using {{single word}} with the opcode {{in the same}} bit {{positions}} for simpler decoding ...|$|E
5000|$|The <b>instruction</b> <b>format</b> for the 930 {{system is}} {{compatible}} with prior systems except for the bits used for extended memory: ...|$|E
40|$|Reducing {{instruction}} memory requirements {{by improving}} code density using compression techniques {{has been the}} aim of much recent work on embedded devices. Previous work {{has been successful in}} improving compression ratios with modest decompression overhead for general purpose RISC architectures. However, most traditional compression techniques fail to produce good results for tightly encoded VLIW architectures. Increased popularity of highly flexible VLIW <b>instruction</b> <b>formats</b> have triggered a search for new variants of traditional compression schemes which achieve good compression ratios with low decompression overhead. We propose a simple variant of a dictionary based compression scheme and report the results of simulations on a widely used VLIW architecture, the TI TMS 320 C 62 x, exploring various options like field sizes, use of profiling information, and study their effects on compression ratios and decompression overheads. The advantage of our scheme is its simplicity and its easy adaptability to varying <b>instruction</b> <b>formats...</b>|$|R
40|$|Introduction: Many {{embedded}} systems have severe cost, power consumption, and space constraints. Reducing code size {{is a critical}} factor in meeting these constraints. Program code is often the largest consumer of memory in controlintensive applications, affecting both system cost and size. Also, instruction fetches are responsible for a significant fraction of system power and memory bandwidth. Existing variable-length <b>instruction</b> <b>formats</b> provide higher code densities than fixed-length formats, but are illsuite...|$|R
3000|$|In {{the above}} code fragments, the {{constant}} 0 × 114 within the indexed instructions is the offset for the num_symtab member. As {{the methods used}} by compilers can be very different, all possible <b>instruction</b> <b>formats</b> for various architectures must be clarified. Code fragment 4 is again from the module_get_kallsym (...) function, and fragments 5 – 8 illustrate the disassembly of the instruction that accesses the strtab and symtab members of the module for different architectures.|$|R
50|$|The <b>instruction</b> <b>format</b> {{for normal}} mode {{is the same}} as for the 930. Addressing differs between user mode and monitor mode.|$|E
50|$|Franklin Academy is {{a public}} charter school located in Wake Forest, North Carolina. Grades taught are K-12 using a Direct <b>Instruction</b> <b>format.</b>|$|E
50|$|The 1960 {{announcement}} of the English Electric KDF9 is the first {{announcement of}} a zero-address <b>instruction</b> <b>format</b> computer, rapidly followed by the Burroughs B5000.|$|E
50|$|Listing control {{statements}} provide <b>instructions</b> for <b>formatting</b> {{both the}} listing {{generated by the}} preprocessor and the listing generated by the compiler.|$|R
40|$|Abstract: Post {{processing}} is {{to change}} the cutter location files into each axis motion files according to the structures of machine movements and control <b>instruction</b> <b>formats.</b> The case study of 5 -axis double rotary table of the CNC machine is researched in this paper. The machine structure and the machine kinematics are analyzed to get the coordinate transformation matrixes, then specified post processing procedures of this machine are developed, the system achieves good effects in practical application...|$|R
50|$|The OR1200 CPU is an {{implementation}} of the 32-bit ORBIS32 instruction set architecture (ISA) and (optionally) ORFP32X ISA implementing IEEE-754 compliant single precision floating point support. The ISA has five <b>instruction</b> <b>formats</b> and supports two addressing modes: register indirect with displacement, and PC-relative. The implementation has a single-issue 5-stage pipeline and is capable of single cycle execution on most instructions. The CPU also contains a MAC unit {{in order to better}} support digital signal processing (DSP) applications.|$|R
50|$|The AN/GYK-12 has a 32-bit <b>instruction</b> <b>format</b> and {{operates}} {{on data from}} one bit to a doubleword (64 bits) in size. Only fixed-point binary arithmetic is provided.|$|E
5000|$|The Model 50 uses a 90 bit (or 85 bit, {{depending}} on definition) [...] "horizontal microcode" [...] <b>instruction</b> <b>format,</b> with each word containing 15 (or 25) separate fields. There are 2816 words of microcode storage.|$|E
5000|$|The <b>instruction</b> <b>format</b> defined for the AN/USQ-17 {{marked the}} {{beginning}} of an instruction set which would be carried on, with many changes along the way, into later UNIVAC computers including the UNIVAC 1100/2200 series which is still in use [...]|$|E
50|$|The key design goal is {{readability}} - {{that the}} language be readable as-is, without looking like it has been marked up with tags or <b>formatting</b> <b>instructions,</b> unlike text <b>formatted</b> with a markup language, such as Rich Text Format (RTF) or HTML, which have obvious tags and <b>formatting</b> <b>instructions.</b> To this end, its main inspiration is the existing conventions for marking up plain text in email, though it also draws from earlier markup languages, notably setext, Textile, and reStructuredText.|$|R
40|$|This paper {{presents}} {{a new approach}} that is complete functionality of SDR implemented in an Application Specific Instruction Processor (ASIP). In this paper, we discuss the details of design of architecture for an ASIP for SDR with a single bus and dedicated paths. We explain the instruction-set design for implementation of the SDR functionality and their <b>instruction</b> <b>formats.</b> We have used SystemC language for functional modeling and simulating architecture of an ASIP {{as well as its}} instruction-set. Simulation results for chosen instruction set are shown...|$|R
40|$|Because {{of changes}} in {{computer}} technology and terminology, {{it is often difficult}} for present-day observers to judge the significance of early digital computer projects. In this paper we follow some architectural themes of interest, as they evolved in the design of three innovative Manchester University computers: the Mark I, Atlas and MU 5. Themes such as operand address-generation, <b>instruction</b> <b>formats</b> and memory-management are traced during the period 1948 - 75. These themes are illustrated by a set of normalised diagrams which may act as an aid to further study of original references...|$|R
