198|1453|Public
5000|$|The abducible predicates in [...] are [...] "it rained" [...] and [...] "the {{sprinkler}} was on" [...] and {{the only}} <b>integrity</b> <b>constraint</b> in [...] is: ...|$|E
5000|$|CHECK Constraint - Virtuoso {{provides}} on {{a column}} an <b>integrity</b> <b>constraint</b> that requires certain conditions {{to be met}} before the data is inserted or modified. If the checks are not satisfied then the transaction cannot be completed.|$|E
50|$|If a {{referential}} <b>integrity</b> <b>constraint</b> {{is defined}} {{to the effect}} that {Shop Type, Nearest Shop} from the first table must refer to a {Shop Type, Shop} from the second table, then the data anomalies described previously are prevented.|$|E
40|$|This paper investigates {{temporal}} <b>integrity</b> <b>constraints</b> in valid time databases, i. e. databases {{that capture}} the time-varying {{nature of the}} part of reality being modeled. We first provide a taxonomy of <b>integrity</b> <b>constraints</b> in (temporal) databases {{in order to establish}} a common terminology. The taxonomy identifies two classes of valid time integrity constraints: intrastate and interstate <b>integrity</b> <b>constraints.</b> Intrastate <b>integrity</b> <b>constraints</b> result from generalizing nontemporal <b>integrity</b> <b>constraints.</b> They guarantee the consistency of every snapshot of a valid time database. Interstate <b>integrity</b> <b>constraints</b> relate and constrain different valid time snapshots and, therefore, they are unique to the temporal dimension. ChronoLog, a query language based on first order predicate logic, can express both types of <b>integrity</b> <b>constraints.</b> Furthermore, timerestricted <b>integrity</b> <b>constraints</b> may be expressed in ChronoLog. Finally, we discuss the efficient checking of valid time integrity c [...] ...|$|R
40|$|This paper {{considers}} {{the problem of}} containment of conjunctive queries (CQ) with disjunctive <b>integrity</b> <b>constraints.</b> Query containment problem {{in the presence of}} <b>integrity</b> <b>constraints</b> has been studied broadly, especially with functional and inclusion dependencies. However, to handle incomplete information in the database, disjunctions are needed to be expressed as <b>integrity</b> <b>constraints.</b> In this paper we introduce disjunctive referential <b>integrity</b> <b>constraints</b> and give a sound and complete algorithm for checking the containment of conjunctive queries under disjunctive referential and implication constraints. ...|$|R
40|$|Abstract. Semantic <b>integrity</b> <b>constraints</b> specify {{relations}} between entity classes. These relations must hold {{to ensure that}} the data conforms to the semantics intended by the data model. For spatial data many semantic <b>integrity</b> <b>constraints</b> are based on spatial properties like topological or metric relations. Reasoning on such spatial relations and the corresponding derivation of implicit knowledge allow for many interesting applications. The paper investigates reasoning algorithms which can be used to check the internal consistency of a set of spatial semantic <b>integrity</b> <b>constraints.</b> Since <b>integrity</b> <b>constraints</b> are defined at the class level, the logical properties of spatial relations can not directly be applied. Therefore a set of 17 abstract class relations has been defined, which combined with the instance relations enables the specification of <b>integrity</b> <b>constraints.</b> The investigated logical properties of the class relations enable to discover conflicts and redundancies in sets of spatial semantic <b>integrity</b> <b>constraints...</b>|$|R
5000|$|The {{observation}} that the grass is wet has two potential explanations, [...] "it rained" [...] and [...] "the sprinkler was on", which entail the observation. However, only the second potential explanation, [...] "the sprinkler was on", satisfies the <b>integrity</b> <b>constraint.</b>|$|E
5000|$|The {{following}} examples further {{illustrate the}} ACID properties. In these examples, the database table has two columns, A and B. An <b>integrity</b> <b>constraint</b> {{requires that the}} value in A and the value in B must sum to 100. The following SQL code creates a table as described above: ...|$|E
50|$|If we {{attempted}} to insert a new customer with the ID 1234567890, this would violate {{the design of the}} relvar since Customer ID is a primary key and we already have a customer 1234567890. The DBMS must reject a transaction such as this that would render the database inconsistent by a violation of an <b>integrity</b> <b>constraint.</b>|$|E
40|$|We {{introduce}} a formalism to couple <b>integrity</b> <b>constraints</b> over general-purpose knowledge bases with actions {{that can be}} executed to restore consistency. This formalism generalizes active <b>integrity</b> <b>constraints</b> over databases. In the more general setting of multi-context systems, adding repair suggestions to <b>integrity</b> <b>constraints</b> allows defining simple iterative algorithms to find all possible grounded repairs - repairs for the global system that follow the suggestions given by the actions in the individual rules. We apply our methodology to ontologies, and show that it can express most relevant types of <b>integrity</b> <b>constraints</b> in this domain...|$|R
40|$|<b>Integrity</b> <b>constraints</b> play a {{major role}} when the quality of spatial data is checked by {{automatic}} procedures. Nevertheless the possibilities of checking {{the internal consistency of the}} <b>integrity</b> <b>constraints</b> themselves are hardly researched jet. This work analyses the applicability of reasoning techniques like the composition of spatial relations and constraint satisfaction in networks of constraints to find conflicts and redundancies in sets of spatial semantic <b>integrity</b> <b>constraints.</b> These <b>integrity</b> rules specify relations among entity classes. Such relations must hold to assure that the data is fitting to the semantics intended by the data model. For spatial data many semantic <b>integrity</b> <b>constraints</b> are based on spatial properties described for example through qualitative topological or metric relations. Since <b>integrity</b> <b>constraints</b> are defined at the class level, the reasoning properties of these spatial relations can not directly be applied. Therefore a set of class relations has been defined which, combined with the instance relations, enables for the specification of <b>integrity</b> <b>constraints</b> and to reason about them...|$|R
40|$|Schema {{integration}} is a main {{step in the}} database integration process. Due {{to the fact that}} the semantics of a schema is also determined by its <b>integrity</b> <b>constraints,</b> a correct and complete schema integration has to deal with <b>integrity</b> <b>constraints</b> existing in the different schemata to be integrated. However, most existing schema integration approaches do not consider <b>integrity</b> <b>constraints.</b> In this paper, we present a framework for the correct handling of <b>integrity</b> <b>constraints</b> during schema integration. In particular, we work out the correspondence between local <b>integrity</b> <b>constraints</b> and global extensional relationships among the classes of the schemata to be integrated. Since extensional relationships - which are traditionally specified by the database designer as assertions - provide the basic input for a schema integration, the precise definition of such extensional relationships is needed. We provide a way for partially deriving extensional relationships from the <b>integrity</b> <b>constraints</b> defined on the corresponding classes. The knowledge about the correspondences between the underlying <b>integrity</b> <b>constraints</b> and extensional relationships can then be utilized for an augmented schema integration process. (orig.) Available from TIB Hannover: RR 4485 (1998, 15) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekSIGLEDEGerman...|$|R
5000|$|The goal [...] "John is citizen" [...] has two abductive solutions, one {{of which}} is [...] "John is born in the USA", the other of which is [...] "John is born outside the USA" [...] and [...] "John is registered". The {{potential}} solution of becoming a citizen by residence and naturalization fails because it violates the <b>integrity</b> <b>constraint.</b>|$|E
5000|$|A check {{constraint}} {{is a type}} of <b>integrity</b> <b>constraint</b> in SQL which specifies {{a requirement}} that must be met by each row in a database table. The constraint must be a predicate. It can refer to a single column, or multiple columns of the table. The result of the predicate can be either , , or , depending on the presence of NULLs. If the predicate evaluates to , then the constraint is not violated and the row can be inserted or updated in the table. This is contrary to predicates in [...] clauses in [...] or [...] statements.|$|E
50|$|Since {{the purpose}} of the foreign key is to {{identify}} a particular row of the referenced table, it is generally required that the foreign key is equal to the candidate key in some row of the primary table, or else have no value (the NULL value.). This rule is called a referential <b>integrity</b> <b>constraint</b> between the two tables.Because violations of these constraints can be the source of many database problems, most database management systems provide mechanisms to ensure that every non-null foreign key corresponds to a row of the referenced table.|$|E
40|$|Abstract. The Resource Space Model (RSM) is a {{semantic}} data model based on orthogonal classification semantics for effectively managing various resources in interconnection environment. In {{parallel with the}} integrity theories of relational and XML-based data models, this keynote presents the integrity theory for the RSM, including the entity <b>integrity</b> <b>constraints</b> based on the key system of the RSM, the membership <b>integrity</b> <b>constraints,</b> the referential <b>integrity</b> <b>constraints,</b> and the user-defined <b>integrity</b> <b>constraints</b> relevant to applications. This theory guarantees the RSM to correctly and efficiently specify and manage resources. Its implementation approach and application in culture exhibition are demonstrated. ...|$|R
40|$|Abductive Logic Programming is a {{computationally}} founded {{representation of}} abductive reasoning. In most ALP frameworks, <b>integrity</b> <b>constraints</b> express domain-specic logical relationships that abductive answers {{are required to}} satisfy. <b>Integrity</b> <b>constraints</b> are usually known a priori. However, in some applications (such as interactive abductive logic programming, multi-agent interactions, contracting) {{it makes sense to}} relax this assumption, in order to let the abductive reasoning start with incomplete knowledge of <b>integrity</b> <b>constraints,</b> and to continue without restarting when new <b>integrity</b> <b>constraints</b> become known. In this paper, we propose a declarative semantics for abductive logic programming with addition of <b>integrity</b> <b>constraints</b> during the abductive reasoning process. We propose an operational instantiation (with formal termination, soundness and completeness properties) and an implementation of such a framework based on the SCIFF language and proof procedure...|$|R
40|$|<b>Integrity</b> <b>constraints</b> on {{data are}} {{typically}} defined when workflow and business process models are developed. Keeping data consistent {{is vital for}} workflow execution. Traditionally, enforcing data <b>integrity</b> <b>constraints</b> is left for the underlying database system, while workflow system focuses primarily on performing tasks. This paper presents a new mechanism that turns a workflow into an equivalent one that will preserve <b>integrity</b> <b>constraints.</b> For a given workflow schema (or model) and a given set of data <b>integrity</b> <b>constraints,</b> an algorithm developed in this paper injects additional conditions into the workflow schema that restricts possible execution paths. The modified workflow will guarantee data consistency (i. e., satisfaction of the <b>integrity</b> <b>constraints)</b> whenever the workflow updates the database(s). In addition, we show that our injection mechanism is "conservative complete, i. e., the conditions inserted are weakest possible. By making workflow execution self-behaving, enforcing <b>integrity</b> <b>constraints</b> over multi-databases is avoided, and constraints specific to a workflow can also be enforced effectively. Mechanisms such as this enhance independence of workflow executions from the environment-a much desired property. 18 page(s...|$|R
50|$|A {{good example}} of this {{evolution}} {{can be found in the}} signal <b>integrity</b> <b>constraint.</b> In the mid-1990s (180 nmnode), industry visionaries were describing the impending dangers of coupling noise long before chips werefailing. By the mid-late 1990s, noise problems were cropping up in advanced microprocessor designs.By 2000, automated noise analysis tools were available and were used to guide manual fix-up. The totalnumber of noise problems identified by the analysis tools identified by the flow quickly became too manyto correct manually. In response, CAD companies developed the noise avoidance flows that are currently inuse in the industry.|$|E
50|$|For {{referential}} integrity {{to hold in}} a relational database, any column in a base table that is declared a foreign key can contain either a null value, or only values from a parent table's primary key or a candidate key. In other words, when a foreign key value is used it must reference a valid, existing primary key in the parent table. For instance, deleting a record that contains a value referred to by a foreign key in another table would break {{referential integrity}}. Some relational database management systems (RDBMS) can enforce referential integrity, normally either by deleting the foreign key rows as well to maintain integrity, or by returning an error and not performing the delete. Which method is used may be determined by a referential <b>integrity</b> <b>constraint</b> defined in a data dictionary.|$|E
50|$|Heterogeneities in {{databases}} arise due {{to factors}} such as differences in structures, semantics of data, the constraints supported or query language. Differences in structure occur when two data models provide different primitives such as object oriented (OO) models that support specialization and inheritance and relational models that do not. Differences due to constraints occur when two models support two different constraints. For example the set type in CODASYL schema may be partially modeled as a referential <b>integrity</b> <b>constraint</b> in a relationship schema. CODASYL supports insertion and retention that are not captured by referential integrity alone. The query language supported by one DBMS can also contribute to heterogeneity between other component DBMSs. For example, differences in query languages with the same data models or different versions of query languages could contribute to heterogeneity.|$|E
40|$|Correct transformations and {{integrations}} of schemata {{within the}} process of federated database design have to encompass existing local <b>integrity</b> <b>constraints.</b> Most of the proposed methods for schema transformation and integration do not sufficiently consider explicit <b>integrity</b> <b>constraints.</b> In this paper we present an approach to deal with <b>integrity</b> <b>constraints.</b> Our approach bases on the idea to relate <b>integrity</b> <b>constraints</b> to extensions. A set of elementary operations for schema restructuring and integration is identified. For these operations we define major rules for dealing with <b>integrity</b> <b>constraints.</b> By means of a small example we then demonstrate the application of these rules. 1 Introduction In many large organizations, different legacy data management systems are maintained and operated. These data management systems and the data managed by them have developed independently from each other. Among these systems there are database management systems but also merely file [...] ...|$|R
50|$|<b>Integrity</b> <b>constraints.</b>|$|R
5000|$|Data {{integrity}} is normally enforced in a database system {{by a series}} of <b>integrity</b> <b>constraints</b> or rules. Three types of <b>integrity</b> <b>constraints</b> are an inherent part of the relational data model: entity integrity, referential integrity and domain integrity: ...|$|R
50|$|LDDT {{included}} an environmental (namespace) hierarchy, multiple levels of model, the modeling of generalization/specialization, and the explicit representation of relationships by primary and foreign keys, {{supported by a}} well defined role naming facility. The primary keys and unambiguously role-named foreign keys expressed sometimes subtle uniqueness and referential integrity constraints {{that needed to be}} known and honored by whatever type of database was ultimately designed. Whether the database design used the <b>integrity</b> <b>constraint</b> based keys of the LDDT model as database access keys or indexes was an entirely separate decision. The precision and completeness of the LDDT models was an important factor in enabling the relatively smooth transformation of the models into database designs. Early LDDT models were transformed into database designs for IBM's hierarchical database, IMS. Later models were transformed into database designs for Cullinet's network database, IDMS, and many varieties of relational database.|$|E
40|$|Data is {{business}} asset {{that should be}} safeguarded and maintained. Business data is recorded in a table/relation. Because inconeet relation structure could produce any modification anomaly, this relation should be normalized. Data modification in normalized relation will face referential <b>integrity</b> <b>constraint</b> problem. This problem could make inconsistent data and wrong information. Referential <b>integrity</b> <b>constraint</b> depends on minimum relationship cardinality. The trial and implementation of referential <b>integrity</b> <b>constraint</b> is taken on Microsoft Access. Abstract in Bahasa Indonesia : Data adalah asset perusahaan yang harus dijaga dan dipelihara. Data perusahaan dicatat pada tabel/relation. Struktur relation yang kurang baik dapat mengakibatkan modification anomaly, sehingga relation tersebut harus di-normalisasi. Modifikasi data pada relation yang sudah di-normalisasi akan menghadapi masalah referential <b>integrity</b> <b>constraint.</b> Masalah tersebut menyebabkan data tidak konsisten dan menghasilkan informasi yang salah. Referential <b>integrity</b> <b>constraint</b> tergantung pada minimum relationship cardinality. Penulis mengimplementasikan dan menguji coba referential <b>integrity</b> <b>constraint</b> pada Microsoft Access. Kata kunci: modification anomaly, normalization, referential <b>integrity</b> <b>constraint,</b> relationship cardinality constraint...|$|E
40|$|This {{document}} explains {{and shows}} {{the results of}} the elaboration of the master final project, devoted to the problem of the <b>integrity</b> <b>constraint</b> violations in OCL design of data. More specifically, the project addresses the <b>integrity</b> <b>constraint</b> problems in a given OCL contract and proposes an iterative solution for the violations which will be explained in detailed way...|$|E
5000|$|The above {{definition}} takes {{a particular}} {{view on the}} formalization {{of the role of}} the <b>integrity</b> <b>constraints</b> [...] as restrictions on the possible abductive solutions. It requires that these are entailed by the logic program extended with an abductive solution, thus meaning that in any model of the extended logic program (which one can think of as an ensuing world given [...] ) the requirements of the <b>integrity</b> <b>constraints</b> are met. In some cases this may be unnecessarily strong and the weaker requirement of consistency, namely that [...] is consistent, can be sufficient, meaning that there exists at least one model (possible ensuing world) of the extended program where the <b>integrity</b> <b>constraints</b> hold. In practice, in many cases these two ways of formalizing the role of the <b>integrity</b> <b>constraints</b> coincide as the logic program and its extensions always have a unique model. Many of the ALP systems use the entailment view of the <b>integrity</b> <b>constraints</b> as this can be easily implemented without the need for any extra specialized procedures for the satisfaction of the <b>integrity</b> <b>constraints</b> since this view treats the constraints in the same way as the problem goal.Note also that in many practical cases the third condition in this formal definition of an abductive explanation in ALP is either trivially satisfied or it is contained in the second condition via the use of specific <b>integrity</b> <b>constraints</b> that capture consistency.|$|R
40|$|<b>Integrity</b> <b>constraints</b> {{represent}} {{an important source}} of information about the real world. They are usually used to define constraints on data (functional dependencies, inclusion dependencies etc.). Nowadays <b>integrity</b> <b>constraints</b> have a wide applicability in several contexts such as semantic query optimization...|$|R
40|$|Abstract. We study active <b>integrity</b> <b>constraints,</b> a {{formalism}} {{designed to}} describe <b>integrity</b> <b>constraints</b> on databases and to specify preferred ways to enforce them. The original semantics proposed for active <b>integrity</b> <b>constraints</b> {{is based on}} the concept of a founded repair. We point out that groundedness underlying founded repairs does not prevent cyclic justifications and so, may be inappropriate in some applications. Thus, using a different notion of grounding, with roots in logic programming and revision programming, we introduce two new semantics: of justified weak repairs, and of justified repairs. We study properties of these semantics, relate them to earlier semantics of active <b>integrity</b> <b>constraints,</b> and establish the complexity of basic decision problems. ...|$|R
40|$|The aim of {{this paper}} is to obtain {{advantages}} for <b>integrity</b> <b>constraint</b> checking in bitemporal deductive databases, analyzing the temporal <b>integrity</b> <b>constraint</b> behaviour. First at all, a new taxonomy of temporal integrity constraints is introduced to achieve a better understanding of why constraints are required and a best way to define them using first order logic. In order to meet these goals, we have studied temporal <b>integrity</b> <b>constraint</b> taxonomies existing on the temporal database area and other deeply related areas such as multiversion databases. These works have been adapted and further developed to cover the scope of bitemporal deductive databases. Before checking, we study the transaction behaviour, introducing the concept of coherent transaction. This allows us to reject transactions that are not coherent, without more information requirements. For <b>integrity</b> <b>constraint</b> checking in bitemporal deductive databases, we derive a set of transition rules for each temporal <b>integrity</b> <b>constraint.</b> Then, Standard Linear Deduction with Negation as Failure Resolution is used to verify that a transaction does not violate any constraint before the transaction is allowed to commit. The set of transition rules obtained is very large; therefore, a carefully analysis of the integrity constraints using the taxonomy introduced above drastically reduces the number of rules. Finally, the paper concludes with an example of the application of this new reduced set of transition rules for <b>integrity</b> <b>constraint</b> checking in bitemporal deductive databases. Postprint (published version...|$|E
40|$|An {{important}} {{problem that}} arises when updating a deductive database {{is that of}} <b>integrity</b> <b>constraint</b> maintenance. That is, given a consistent database and an update request, to obtain all possible updates of base facts such that the request is satisfied and no <b>integrity</b> <b>constraint</b> is violated. This problem becomes more complex when view updates are also taken into account. In this paper we define a method for view updating and <b>integrity</b> <b>constraint</b> maintenance in deductive databases. We propose a new method that is sound and that improves current methods by dealing with three kinds of updates: insertion, deletion and modification updates on base and derived predicates. Moreover, due to the inclusion of an specific modification operator, the own definition of the method deals with key information of base and derived predicates. Keywords. view updating, <b>integrity</b> <b>constraint</b> maintenance 1 Introduction Several problems may arise when updating a deductive database [18]. A well [...] ...|$|E
40|$|Several {{problems}} may arise when a deductive database is updated. The {{problems that are}} addressed in this paper are those of <b>integrity</b> <b>constraint</b> maintenance and view updating. In this sense, we define a method that tackles both problems in an integrated way {{and that it is}} sound and complete. We also propose an architecture for our method to deal with both problems efficiently. Improvement of efficiency during the <b>integrity</b> <b>constraint</b> maintenance is based on a technique that determines the order in which integrity constraints should be handled. This technique is based on the generation of a graph that states the relationships between potential violations and potential repairs of integrity constraints. This order reduces significantly the number of times that each <b>integrity</b> <b>constraint</b> has to be considered after any <b>integrity</b> <b>constraint</b> repair. To improve efficiency during view updating, we propose to perform an initial analysis of the update request {{to reduce the number of}} database accesses and to explore only the relevant alternatives that may lead to valid solutions of an update request. Furthermore, a detailed comparison considering effectiveness and efficiency issues is also provided with respect to other methods that also deal with <b>integrity</b> <b>constraint</b> maintenance and view updating. Postprint (published version...|$|E
40|$|Modeling of {{semantics}} {{is one of}} {{the most}} difficult tasks in database design. Constraints are used to express database semantics. They are used differently in database models. They express domain restrictions, specify relationships between components and state database behavior. The utilization depends on the richness of the type system used in the model. The relational model is using a simple type system and has a very large set of <b>integrity</b> <b>constraints.</b> Semantical models are using richer type systems which express also different types of <b>integrity</b> <b>constraints.</b> At the same time, the theory of <b>integrity</b> <b>constraints</b> is more complex. Object-oriented models use either a simple type system or type systems like the semantical models. The theory of <b>integrity</b> <b>constraints</b> is still under development. This overview tries to give a unifying framework on <b>integrity</b> <b>constraints.</b> 1 1 Introduction The goal of this overview is to provide a systematic and unifying introduction to the theory of constrai [...] ...|$|R
40|$|The {{formalism}} {{of active}} <b>integrity</b> <b>constraints</b> was introduced {{as a way}} to specify particular classes of <b>integrity</b> <b>constraints</b> over relational databases together with preferences on how to repair existing inconsistencies. The rule-based syntax of such <b>integrity</b> <b>constraints</b> also provides algorithms for finding such repairs that achieve the best asymptotic complexity. However, the different semantics that have been proposed for these <b>integrity</b> <b>constraints</b> all exhibit some counter-intuitive examples. In this work, we look at active <b>integrity</b> <b>constraints</b> using ideas from algebraic fixpoint theory. We show how database repairs can be modeled as fixpoints of particular operators on databases, and study how the notion of grounded fixpoint induces a corresponding notion of grounded database repair that captures several natural intuitions, and in particular avoids the problems of previous alternative semantics. In order to study grounded repairs in their full generality, we need to generalize the notion of grounded fixpoint to non-deterministic operators. We propose such a definition and illustrate its plausibility in the database context...|$|R
40|$|In {{this paper}} we {{integrate}} a history [...] encoding based methodology for checking dynamic database <b>integrity</b> <b>constraints</b> into a situation-calculus based specification of relational database updates. By doing this, {{we are able}} to: (1) Answer queries about a whole hypothetical evolution of a database, without having to update the entire database and keep all the information associated to the generated states, (2) State and prove dynamic <b>integrity</b> <b>constraints</b> as static <b>integrity</b> <b>constraints,</b> (3) Transform history dependent preconditions for updates into local preconditions...|$|R
