29|10000|Public
2500|$|One of the {{challenges}} in defining quality is that [...] "everyone feels they understand it" [...] and other <b>definitions</b> <b>of</b> <b>software</b> quality could be based on extending the various descriptions {{of the concept of}} quality used in business.|$|E
50|$|ISO/IEC/IEEE 29119 Software Testing - Test Techniques, {{provides}} standard <b>definitions</b> <b>of</b> <b>software</b> {{test design}} techniques (also known as test case design techniques or test methods) {{that can be}} used during the test design and implementation process that is defined in ISO/IEC/IEEE 29119-2. Techniques of part 4 are intended to support part 2 or can be used without part 2.|$|E
40|$|<b>Definitions</b> <b>of</b> <b>software</b> art and {{generative}} art {{have changed}} in the last ten years. This is because artists using the computer to create artworks and critics writing about their work have created invented categories to understand what is happening. It has been argued by some critics that there is no relationship between software and generative art. However, there are some critics who state that generative art has replaced software art, and that software art no longer exists. Yet, from a different perspective some critics argued that software does still exist but in a different form. This essay looks at the <b>definitions</b> <b>of</b> <b>software</b> art and generative art. It aims to show the relationship between software and generative art, including {{the differences between the two}} art forms...|$|E
5000|$|In 1972, Bauer {{published}} the following <b>definition</b> <b>of</b> <b>software</b> engineering:"Establishment {{and use of}} sound engineering principles to economically obtain software that is reliable and works on real machines efficiently." ...|$|R
40|$|We {{argue that}} domain models should produce four basic products: {{identification}} <b>of</b> reusable <b>software</b> components, <b>definition</b> <b>of</b> <b>software</b> architectures that explain how components can be composed, {{a demonstration of}} architecture scalability, and a direct relationship of these results to <b>software</b> generation <b>of</b> target systems...|$|R
40|$|The {{consequences}} of a class of system failures, commonly known as software vulnerabilities, violate security policies. They can cause the loss of information and reduce the value or usefulness of the system. ^ An increased {{understanding of the nature}} of vulnerabilities, their manifestations, and the mechanisms that can be used to eliminate and prevent them can be achieved by the development <b>of</b> a unified <b>definition</b> <b>of</b> <b>software</b> vulnerabilities, the development of a framework for the creation of taxonomies for vulnerabilities, and the application of learning, visualization, and statistical tools on a representative collection <b>of</b> <b>software</b> vulnerabilities. ^ This dissertation provides a unifying <b>definition</b> <b>of</b> <b>software</b> vulnerability based on the notion that it is security policies that define what is allowable or desirable in a system. It also includes a framework for the development of classifications and taxonomies for software vulnerabilities. ^ This dissertation presents a classification <b>of</b> <b>software</b> vulnerabilities that focuses on the assumptions that programmers make regarding the environment in which their application will be executed and that frequently do not hold during the execution of the program. ^ This dissertation concludes by showing that the unifying <b>definition</b> <b>of</b> <b>software</b> vulnerability, the framework for the development of classifications, and the application of learning and visualization tools can be used to improve security. ...|$|R
40|$|Many {{competing}} <b>definitions</b> <b>of</b> <b>software</b> components {{have been}} proposed over the years, but still today there is only partial agreement over such basic issues as granularity (are components bigger or smaller than objects, packages, or application?), instantiation (do components exist at run-time or only at compile-time?), and state (should we distinguish between components and "instances" of components?) ...|$|E
40|$|Firstly, the {{analysis}} of software faults ’ rising process and, secondly, the creation of mathe-matical models for software reliability indexes ’ estimation are most strongly-developed line of in-vestigation in software reliability evaluation and control sphere. These researches are really essen-tial, {{taking into account the}} importance of reliability control for safety-, life-critical software [1]. Software reliability is defined as the probability of failure-free software operation for a spe-cified period of time in a specified environment. Basic <b>definitions</b> <b>of</b> <b>software</b> reliability theory are: cumulative number of failures- tM, mean failure function- tMEt, failure intensit...|$|E
40|$|The {{goal of this}} {{position}} paper is to perform a non-empirical validation of the “number of requirements ” measure, which can help to control the Requirements Management process. The reason to validate this measure is {{to contribute to the}} lack of rigorous measures validation in the literature. The aim has been addressed by applying two <b>definitions</b> <b>of</b> <b>software</b> measure validation to the measure. However the measure is still not validated because of the impossibility to prove that the representation condition is satisfied both theoretically and empirically. Several questions are arisen and discussed and they confirm the immaturity of the measures validation field...|$|E
40|$|Abstract. With {{the rapid}} {{development}} of electronic components manufacturing {{technology and the}} application of reliability technology, the hardware reliability of the CNC system and servo drive system has been greatly improved. Currently, the performance and functionality of CNC system, which achieved gradually by the <b>software</b> instead <b>of</b> hardware, is becoming increasingly complex. However, very few researches on the reliability <b>of</b> CNC system <b>software</b> was presented. In this paper, the basic conceptions and important <b>of</b> CNC <b>software</b> reliability were discussed, and comparative analysis on the research status at domestic and abroad were studied from the view of theoretical research and engineering practice. Meanwhile, the paper collected field failure data on 30 CNC systems in six months, and reliability analysis was made based on the data. 1 the Definition and the Importance <b>of</b> CNC <b>Software</b> Reliability 1. 1 The <b>Definition</b> <b>of</b> <b>Software</b> Reliability In 1983 ，IEEE Computer Society made a clear <b>definition</b> <b>of</b> <b>software</b> reliability, which was accepted as national standard by National Institute of Standards and Technology (NIST) in the United States later. Then in 1989, China also accepted the definition as national standard. According to GB/T 11457 - 95 -Software Engineering Terms, the <b>definition</b> <b>of</b> <b>software</b> reliability is as follow...|$|R
40|$|Software {{architectures}} {{are often}} {{claimed to be}} robust. However, there is no explicit and concrete <b>definition</b> <b>of</b> <b>software</b> architecture robustness. This paper gives a <b>definition</b> <b>of</b> <b>software</b> architecture robustness and presents a set of architecture metrics that were applied to real-time telecommunications software {{for the evaluation of}} robustness. The {{purpose of this study is}} to provide a structured method to support software architecture evaluations and downstream software implementations. The study also expands the software architecture research to quantitative and measurable evaluations as opposed to qualitative assessments. In addition, this paper presents an empirical case study of applying the metrics. The approach and the metrics data provide insights into software architecture sensitivity analysis on system qualities and trade-off analysis among a set of design alternatives to support product evolution. 1...|$|R
40|$|The {{bachelor}} thesis {{deals with}} <b>definition</b> <b>of</b> <b>software</b> utility for investment management in environment of financial advisory company {{operating in the}} Czech republic. The thesis {{is divided into three}} logical units, which describe the legal framework for investment operation, a description of processes related to investment and design of specifications document for the creation of the instrument...|$|R
40|$|Compared with {{software}} projects, {{the estimation of}} website projects is not mature enough without any methods for size or workload estimation. This paper researched Function Point Analysis (FPA), the most important size estimation method in software projects and then constructed Commerce Website Function Point Analysis (CWFPA) by introducing principles of FPA into commerce website projects. The paper reserved the basic <b>definitions</b> <b>of</b> <b>software</b> FPA for CWFPA and researched some key factors combined with characteristics of commerce website projects including the functional complexity, function point weight and value adjustment factor. In the end, a commerce website project PET was given as a demonstration of CWFPA. </p...|$|E
40|$|The {{development}} of sustainable software {{has been identified}} as one of the key challenges in the field of computational science and engineering. However, there is currently no agreed definition of the concept. Current definitions range from a composite, non-functional requirement to simply an emergent property. This lack of clarity leads to confusion, and potentially to ineffective and inefficient efforts to develop sustainable software systems. The aim {{of this paper is to}} explore the emerging <b>definitions</b> <b>of</b> <b>software</b> sustainability from the field of software engineering in order to contribute to the question, what is software sustainability? The preliminary analysis suggests that the concept of software sustainability is complex and multifaceted with any consensus towards a shared definition within the field of software engineering yet to be achieved...|$|E
40|$|Abstract — The {{development}} of sustainable software {{has been identified}} as one of the key challenges in the field of computational science and engineering. However, there is currently no agreed definition of the concept. Current definitions range from a composite, non-functional requirement to simply an emergent property. This lack of clarity leads to confusion, and potentially to ineffective and inefficient efforts to develop sustainable software systems. The aim {{of this paper is to}} explore the emerging <b>definitions</b> <b>of</b> <b>software</b> sustainability from the field of software engineering in order to contribute to the question, what is software sustainability? The preliminary analysis suggests that the concept of software sustainability is complex and multifaceted with any consensus towards a shared definition within the field of software engineering yet to be achieved. Index Terms — Non-functional requirements, quality attributes, software engineering, software sustainability, sustainabilit...|$|E
40|$|The {{scientific}} computing {{needs of}} the Earth Science and Application Division (ESAD) were evaluated, and it was determined whether the existing visualization environment provides the proper tools for meeting those needs. Some of the deficiencies were corrected using off-the-shelf software. The following subject areas are covered: (1) evaluation of visualization environment at ESAD; (2) <b>definition</b> <b>of</b> science needs; (3) evaluation of available sortware/hardware; and (4) <b>definition</b> <b>of</b> <b>software</b> development environment...|$|R
40|$|This report {{presents}} {{guidelines for}} defining, recording, and reporting two frequently used measures <b>of</b> <b>software</b> size [...] physical source lines and logical source statements. We propose a general framework for constructing size definitions {{and use it}} to derive operational methods for reducing misunderstandings in measurement results. We show how the methods can be applied to address the information needs of different users while maintaining a common <b>definition</b> <b>of</b> <b>software</b> size...|$|R
5000|$|A {{suggested}} <b>definition</b> <b>of</b> <b>software</b> patent {{has been}} proposed by the Foundation for a Free Information Infrastructure (FFII) as being a [...] "patent on any performance of a computer realised {{by means of a}} computer program". According to the European Patent Office, there is no legal or conclusive definition for a software patent. According to the FFII, software patents should not exist under European law.|$|R
40|$|Explicit, formal <b>definitions</b> <b>of</b> <b>software</b> {{processes}} {{are needed for}} process understanding, communication, analysis, execution guidance, and improvement support. We conducted a case study which involved the creation of formal process definitions using Abstraction Hierarchy Diagrams, IDEF 0, MVP-L, and APPL/A. This paper describes the study, presents the lessons learned about process definition in general, and compares the notations used. We discovered that different notations were appropriate depending on {{the goals of the}} process definition effort. Keywords: process definition, software process modeling, process representation, case study. 1 Introduction Software process definition is a topic of great interest to the software engineering community. A defined process is an important leverage point from which to address software product quality and productivity issues. It is necessary for progressing to Level 3 of the Software Engineering Institute's Capability Maturity Model. It facilitate [...] ...|$|E
40|$|Software {{developers}} ’ work is {{much more}} interesting and multifarious in practice than formal <b>definitions</b> <b>of</b> <b>software</b> development processes imply. Rational models of work are often representations of processes defined {{as they should be}} performed, rather than portrayals of what people actually do in practice. These models offer a simplified picture of the phenomena involved, and are frequently confused with how the work is carried out in reality, or they are advocated as the ideal way to accomplish the work. A longitudinal ethnographic study (45 days of fieldwork over 20 months) of a group of professional software developers revealed the importance of including their observed practice, and the “infrastructure ” that supports and shapes this practice, in an authentic account of their work. Moreover, this research revealed that software development work practice and the infrastructure used to produce software are inextricably entwined and mutually constitutive over time...|$|E
40|$|It {{is widely}} felt that {{software}} quality, {{in the form}} of reliability or "trustworthiness," can be demonstrated by the successful completion of testing that "covers" the software. However, this intuition has little experimental or theoretical support. This paper considers why the intuition is so powerful and yet misleading. Formal <b>definitions</b> <b>of</b> <b>software</b> "dependability" are suggested, along with new approaches for measuring this analog of trustworthiness. 1. The idea of test coverage From the beginning of computer programming, clever people have looked for clever ways to catch the mistakes that too easily enter even the best programs. The essential ideas are ones of systematic coverage, judging the quality of a test by how well it explores the nooks and crannies of program or specification. The ideas of functional coverage, based on the specification, and control coverage, based on the program's control structure, are the most popular. They have been repeatedly reinvented and captur [...] ...|$|E
50|$|ROOM is a {{modeling}} {{language for}} the <b>definition</b> <b>of</b> <b>software</b> systems. It allows the complete code generation {{for the whole}} system from the model. ROOM comes with a textual {{as well as with}} a graphical notation.Typically the generated code is accompanied with manually written code, e.g. for graphical user interfaces (GUI).The code is compiled and linked against a runtime library which provides base classes and basic services (e.g. messaging).|$|R
40|$|Higher order {{software}} (HOS) {{is concerned}} only with computable functions and relationships. The HOS methodology {{can be used}} for the <b>definition</b> <b>of</b> <b>software</b> for multiprogrammed, multiprocessor, or multicomputer systems. A description of HOS methodology is presented, giving attention to questions of formulation, interface correctness, specification language principles, and HOS analyzers. Aspects of system design are considered, and details <b>of</b> <b>software</b> management are discussed. Attention is given to modularity as defined by HOS, frozen module management, the assembly control supervisor, and aspects of reliability and efficiency...|$|R
40|$|Traditionally, {{software}} architecture {{is seen as}} the result <b>of</b> the <b>software</b> architecture design process, the solution, usually represented by a set of components and connectors. Recently, the why of the solution, the set of design decisions made by the software architect, is complementing or even replacing the solution-oriented <b>definition</b> <b>of</b> <b>software</b> architecture. This in turn leads {{to the study of the}} process of making these decisions. We outline some research directions that may help us understand and improve the {{software architecture}} design process...|$|R
40|$|Software Agents {{are the new}} {{revolution}} in software usability. Agents are described with anthropomorphic features such as intelligence, autonomy, and such. The school of researchers from the fields of Artificial Intelligence (AI), Distributed AI (DAI), and other more pragmatic researchers are engaged in defining these "software entities" and creating this new field of study and development along the way. In the mean time, while researchers fight for formal definitions, this new technology is bringing powerful and useful tools to the end user, in particular managing huge amount of data, such as that produced by the Internet, and taking decisions on what the user may be interested in. 1. Introduction `Intelligent Agent' and the more generic term `Agent' are terms {{that have been used}} interchangeably, since some kind of "intelligence" has been consistently described as one of the attributes of a software agent [Franklin, 96]. One of the <b>definitions</b> <b>of</b> <b>software</b> agents describes them as "cha [...] ...|$|E
40|$|The {{importance}} of software for business systems continues to grow. Software products play {{an increasingly important}} role in industry and society. The need f r delivering 2 ̆ 2 quality products 2 ̆ 2 and 2 ̆ 2 quality services 2 ̆ 2 has become as relevant for companies in the field qf sqfiware development as for any other company doing business. Many software companies have already spent considerable efJ rt on {{improving the quality of}} their products and processes. However, the existence of various quality approaches makes it difficult for practitioners to interpret and to apply a software quality approach effectively. This paper positions advanced software quality improvement approaches in a framework of frur quality domains. The framework supports and enables communication and decision making regarding the definition and the selection of software quality improvement approaches. BeJ re the quality framework is introduced some <b>definitions</b> <b>of</b> <b>software</b> quality will be addressed...|$|E
40|$|Abstract—The {{scientific}} literature on Software Architecture (SA) is extensive and dense. With no preparation, surveying this literature {{can be a}} daunting task for novices in the field. This paper resorts to the technique of Formal Concept Analysis (FCA) in organizing and structuring such a body of knowledge. We start by surveying a set of 38 papers bearing in mind the following questions: “What are the most supported <b>definitions</b> <b>of</b> <b>software</b> architecture?”, “What {{are the most popular}} research topics in software architecture?”, “What are the most relevant quality attributes of a software architecture? ” and “What are the topics that researchers point out as being more interesting to explore in the future?”. To answer these questions we classify each paper with appropriate keywords and apply FCA to such a classification. FCA allows us to structure our survey in the form of lattices of concepts which give evidence of main relationships involved. We believe our results will help in guiding a more comprehensive, in-depth study of the field, to be carried out in the future. Keywords-Introductory and Survey; Software Architectures...|$|E
30|$|Finally, to {{complement}} our strategy, we defined a practical guide to organizations to perform software measurement suitable for SPC: the Body <b>of</b> Recommendations for <b>Software</b> Measurement Suitable for SPC (BRSM). The BRSM is composed by recommendations related to eighteen aspects organized in five groups, namely: (i) recommendations related to software measurement preparation, (ii) recommendations {{related to the}} alignment between software measurement and organizational goals, (iii)recommendations related to the <b>definition</b> <b>of</b> <b>software</b> measures, (iv) recommendations related to the execution <b>of</b> <b>software</b> measurement, and (v) recommendations related to software measurement analysis.|$|R
40|$|Security in {{software}} networks relies on technology, law, and economics. As the cost <b>of</b> <b>software</b> security breaches becomes more apparent, {{there has been}} greater interest in developing and implementing solutions for {{different parts of the}} problem. In this paper, we provide the first comprehensive assessment <b>of</b> the <b>software</b> security issue that uses a law and economics framework. We begin by offering a <b>definition</b> <b>of</b> <b>software</b> security that illustrates the complexity of the problem. We then review and critique the literature assessing the costs <b>of</b> <b>software</b> security. Finally, we evaluate a number of legal, economic and technical approaches for addressing security problems. ...|$|R
40|$|Software {{sustainability}} {{has been}} identified as one of the key challenges in the development of scientific and engineering software as we move towards new paradigms of research and computing infrastructures. However, it is suggested that sustainability is not well understood within the software engineering community, which can led to ineffective and inefficient efforts to address the concept or result in its complete omission from the software system. This paper proposes a <b>definition</b> <b>of</b> <b>software</b> sustainability and considers how it can be measured empirically in the design and engineering process <b>of</b> <b>software</b> systems...|$|R
40|$|Specifications define systems. The {{definition}} of a system can be stated casually or formally. A formal specification is a mathematically precise {{definition of}} software functionality. Informal specifications are less precise <b>definitions</b> <b>of</b> <b>software</b> functionality. The benefits of formal specifications are clear. Arguments {{against the use of}} formal specifications have been refuted;Several formal specification techniques are available for specifying imperative programs, e. g., Z, VDM, and SPECS. Most specification techniques for distributed/concurrent systems concentrate on low level issues, e. g., deadlock and synchronization;Structured Analysis (SA) specifications are a popular informal specification technique, but they lack a rigorous mathematical semantics. SA specifications are based on a graphical syntax with little underlying formal structure. In this thesis, we identify and formalize those underlying structures that are represented informally, provide a formal {{definition of a}} SA specification, develop formal interpretations for those components of SA specifications that are subject to varying interpretation, and define an operational semantics for animating SA specifications. The resulting formalized SA specifications are mathematically precise and can be used to specify distributed/concurrent systems...|$|E
40|$|This talk {{began by}} {{presenting}} the Space Station Freedom Program (SSFP) <b>definitions</b> <b>of</b> <b>software</b> commonality and software reuse. Software commonality {{is the use}} of identical, interchangeable, functionally compatible, or similar software items to satisfy different sets of functionally similar requirements. The Software Support Environment (SSE) and the Data Management System (DMS) of onboard computing facilities are examples of SSFP common software. Software reuse {{is the use of}} identical, compatible, or similar software items in either modified or unmodified form to satisfy development activities at any point in the software life cycle; in other words, taking an existing item and applying it to another development activity. Software commonality has been mandated in several critical areas (such as the SSE and DMS) and a policy directive is under review. A software reuse study group was established in May 1988 to gather background information (see Level 2 Software Reuse Study that follows by Scott Herman). The SSFP Program Definition and Requirements Document contains requirements for SSE support in the area of software reuse. The SSE is a collection of tools and rules, and provides the common environment to be used for the life cycle management of all SSFP operational software...|$|E
40|$|We present two new {{large-scale}} datasets {{aimed at}} evaluating systems designed to comprehend a natural language query and extract its answer {{from a large}} corpus of text. The Quasar-S dataset consists of 37000 cloze-style (fill-in-the-gap) queries constructed from <b>definitions</b> <b>of</b> <b>software</b> entity tags on the popular website Stack Overflow. The posts and comments on the website serve as the background corpus for answering the cloze questions. The Quasar-T dataset consists of 43000 open-domain trivia questions and their answers obtained from various internet sources. ClueWeb 09 serves as the background corpus for extracting these answers. We pose these datasets as a challenge for two related subtasks of factoid Question Answering: (1) searching for relevant pieces of text that include the correct answer to a query, and (2) reading the retrieved text to answer the query. We also describe a retrieval system for extracting relevant sentences and documents from the corpus given a query, and include these in the release for researchers wishing to only focus on (2). We evaluate several baselines on both datasets, ranging from simple heuristics to powerful neural models, and show that these lag behind human performance by 16. 4 % and 32. 1 % for Quasar-S and -T respectively. The datasets are available at [URL]...|$|E
40|$|Abstract. Currently, {{there is}} little {{understanding}} about how different types <b>of</b> <b>software</b> ecosystems must be governed for the preservation and improvement of ecosystem health. This paper explores the <b>definition</b> <b>of</b> <b>software</b> ecosystems and provides a classification model for software ecosystems. The classification model is applied to 19 cases previously explored in software ecosystem literature, and governance tools are observed for {{the different types of}} ecosystems. The governance tools are summarized in a governance model that, when used correctly, serves ecosystem coordinators in determining strategies to maintain and ultimately improve software ecosystem health. ...|$|R
5000|$|The Free Software Foundation and the Open Source Initiative both publish {{lists of}} {{licenses}} {{that they find}} to comply with their own <b>definitions</b> <b>of</b> free <b>software</b> and open-source software respectively: ...|$|R
40|$|Software {{engineering}} as {{a discipline}} is still evolving and not yet stable. The people associated with computer field often face problems with the software. Software Requirements and estimation provides software professionals {{the information they need}} to address requirements engineering and estimation. Requirements form the basis of the initial estimates and plans on which the software product is built and validated. This paper recapitulates the <b>definition</b> <b>of</b> <b>software</b> requirement engineering. This paper discusses the basic concepts and provocations for requirement engineering and estimation...|$|R
