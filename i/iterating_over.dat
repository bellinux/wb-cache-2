161|445|Public
25|$|Where and ForEach method syntax {{provides}} an alternate method of filtering and <b>iterating</b> <b>over</b> objects.|$|E
2500|$|A {{counting}} loop can be simulated by <b>iterating</b> <b>over</b> an incrementing list or generator, for instance, Python's range (...) [...]|$|E
2500|$|Maple has {{two forms}} of for-loop, one for iterating {{of a range of}} values, and the other for <b>iterating</b> <b>over</b> the {{contents}} of a container. The value range form is as follows: ...|$|E
50|$|Foreach loops, called Fast enumeration, are {{supported}} starting in Objective-C 2.0. They {{can be used}} to <b>iterate</b> <b>over</b> any object that implements the NSFastEnumeration protocol, including NSArray, NSDictionary (<b>iterates</b> <b>over</b> keys), NSSet, etc.|$|R
5000|$|Python {{dictionaries}} (a form of associative array) {{can also}} be directly <b>iterated</b> <b>over,</b> when the dictionary keys are returned; or the items method of a dictionary can be <b>iterated</b> <b>over</b> where it yields corresponding key,value pairs as a tuple: ...|$|R
50|$|Another {{distinction}} is between image order algorithms, which <b>iterate</b> <b>over</b> pixels {{of the image}} plane, and object order algorithms, which <b>iterate</b> <b>over</b> objects in the scene. Generally object order is more efficient, as there are usually fewer objects in a scene than pixels.|$|R
2500|$|Enhanced {{for each}} loop: the for loop syntax is {{extended}} with special syntax for <b>iterating</b> <b>over</b> {{each member of}} either an array or any , such as the standard [...] classes (specified by [...] ) ...|$|E
2500|$|DOK {{consists}} of a dictionary that maps -pairs {{to the value of}} the elements. [...] Elements that are missing from the dictionary are taken to be zero. [...] The format is good for incrementally constructing a sparse matrix in random order, but poor for <b>iterating</b> <b>over</b> non-zero values in lexicographical order. [...] One typically constructs a matrix in this format and then converts to another more efficient format for processing.] ...|$|E
2500|$|Dynamic {{programming}} {{makes it}} possible to count the number of solutions without visiting them all. Imagine backtracking values for the first row – what information would we require about the remaining rows, {{in order to be able}} to accurately count the solutions obtained for each first row value? We consider [...] boards, where , whose [...] rows contain [...] zeros and [...] ones. The function f to which memoization is applied maps vectors of n pairs of integers to the number of admissible boards (solutions). There is one pair for each column, and its two components indicate respectively the number of zeros and ones that have yet to be placed in that column. We seek the value of [...] ( [...] arguments or one vector of [...] elements). The process of subproblem creation involves <b>iterating</b> <b>over</b> every one of [...] possible assignments for the top row of the board, and going through every column, subtracting one from the appropriate element of the pair for that column, depending on whether the assignment for the top row contained a zero or a one at that position. If any one of the results is negative, then the assignment is invalid and does not contribute to the set of solutions (recursion stops). Otherwise, we have an assignment for the top row of the [...] board and recursively compute the number of solutions to the remaining [...] board, adding the numbers of solutions for every admissible assignment of the top row and returning the sum, which is being memoized. The base case is the trivial subproblem, which occurs for a [...] board. The number of solutions for this board is either zero or one, depending on whether the vector is a permutation of [...] and [...] pairs or not.|$|E
5000|$|... // <b>iterate</b> <b>over</b> the valuesfor(String number : phoneBook) {System.out.println(number);} ...|$|R
25|$|Alternatively, it is {{possible}} to <b>iterate</b> <b>over</b> all keys of an array.|$|R
30|$|It <b>iterates</b> <b>over</b> the {{frequent}} itemsets in transaction databases by iterating method.|$|R
5000|$|<b>Iterating</b> <b>over</b> the {{elements}} in order (linear time, good cache performance) ...|$|E
5000|$|Support {{of logical}} {{structures}} (such as conditions, loops, or <b>iterating</b> <b>over</b> arrays) ...|$|E
5000|$|... forAllInOrder - {{execute a}} {{sequence}} of instructions sequentially <b>iterating</b> <b>over</b> the given collection ...|$|E
50|$|Alternatively, it is {{possible}} to <b>iterate</b> <b>over</b> all keys of an array.|$|R
50|$|Swift {{uses the}} … {{construct}} to <b>iterate</b> <b>over</b> {{members of a}} collection.|$|R
5000|$|A {{more complex}} example <b>iterates</b> <b>over</b> an {{associative}} array of arrays of integers: ...|$|R
5000|$|Where and ForEach method syntax {{provides}} an alternate method of filtering and <b>iterating</b> <b>over</b> objects.|$|E
5000|$|Iteration - One of {{the most}} {{powerful}} features of Lodash is its support for <b>iterating</b> <b>over</b> collections.|$|E
5000|$|A {{counting}} loop can be simulated by <b>iterating</b> <b>over</b> an incrementing list or generator, for instance, Python's [...]|$|E
5000|$|Constraint {{propagation}} enforcing directional arc consistency <b>iterates</b> <b>over</b> variables {{from the}} last to the first, enforcing at each step the arc consistency of every variable of lower index with it. If {{the order of the}} variables is , this algorithm <b>iterates</b> <b>over</b> variables from [...] to for variable , it enforces arc consistency of every variable of index lower than [...] with [...]|$|R
50|$|After all {{waveforms}} {{have been}} <b>iterated</b> <b>over</b> all voxels, the basic SAR processing is complete.|$|R
5000|$|Most {{interesting}} hypothesis {{spaces are}} {{too large to}} <b>iterate</b> <b>over,</b> {{as required by the}} [...]|$|R
5000|$|Sass {{allows for}} <b>iterating</b> <b>over</b> {{variables}} using , [...] and , {{which can be}} used to apply different styles to elements with similar classes or ids.|$|E
5000|$|<b>Iterating</b> <b>over</b> a map:// {{over both}} keys and valuesfor key, value := range phone_book { fmt.Printf("Number for %s: %s\n", key, value)}// over just keysfor key := range phone_book { fmt.Printf("Name: %s\n", key)} ...|$|E
5000|$|Maple has {{two forms}} of for-loop, one for iterating {{of a range of}} values, and the other for <b>iterating</b> <b>over</b> the {{contents}} of a container. The value range form is as follows: ...|$|E
5000|$|... would <b>iterate</b> <b>over</b> {{the table}} _G using the {{standard}} iterator function pairs, until it returns nil.|$|R
5000|$|... #Caption: For each loops {{are almost}} always used to <b>iterate</b> <b>over</b> items in a {{sequence}} of elements.|$|R
50|$|It is {{possible}} to suppress all XML errors when loading the document and then <b>iterate</b> <b>over</b> the errors.|$|R
5000|$|Enhanced [...] loop: the [...] loop syntax is {{extended}} with special syntax for <b>iterating</b> <b>over</b> {{each member of}} either an array or any , such as the standard [...] classes (specified by JSR 201) ...|$|E
50|$|This {{algorithm}} {{assumes a}} single connected region within the binary image and {{begins with an}} exhaustive search to locate the first foreground pixel by <b>iterating</b> <b>over</b> the columns and rows of the image.|$|E
5000|$|In this code, we {{see that}} there are three tasks (F0, F1 and F2) inside a loop <b>iterating</b> <b>over</b> [...] for 1 to [...] Following is a list of {{dependencies}} in the code: ...|$|E
5000|$|<b>Iterate</b> <b>over</b> the {{pigeonhole}} array in order, and put {{elements from}} non-empty pigeonholes {{back into the}} original array.|$|R
5000|$|Set up Fixture: A tool like PHPUnit {{will then}} <b>iterate</b> <b>over</b> {{fixtures}} and do insertions into the database.|$|R
40|$|A {{class of}} {{discrete}} equations is considered {{from three perspectives}} corresponding to three measures {{of the complexity of}} solutions: the (hyper-) order of meromorphic solutions in the sense of Nevanlinna, the degree growth of <b>iterates</b> <b>over</b> a function field and the height growth of <b>iterates</b> <b>over</b> the rational numbers. In each case, low complexity implies a form of singularity confinement which results in a known discrete Painlevé equation. Comment: 12 page...|$|R
