537|105|Public
2500|$|To {{reduce the}} number of {{functionality}} bugs, a separate hardware verification group will take the RTL and design testbenches and systems to check that the RTL actually is performing the same steps under many different conditions, classified as the domain of <b>functional</b> <b>verification.</b> Many techniques are used, none of them perfect but all of them useful [...] extensive logic simulation, formal methods, hardware emulation, lint-like code checking, code coverage, and so on.|$|E
5000|$|In {{electronic}} design automation, <b>functional</b> <b>verification</b> is {{the task}} of verifying that the logic design conforms to specification. In everyday terms, <b>functional</b> <b>verification</b> attempts {{to answer the question}} [...] "Does this proposed design do what is intended?" [...] This is a complex task, and takes the majority of time and effort in most large electronic system design projects. <b>Functional</b> <b>verification</b> is a part of more encompassing design verification, which, besides <b>functional</b> <b>verification,</b> considers non-functional aspects like timing, layout and power.|$|E
5000|$|P1647 Standard for the <b>Functional</b> <b>Verification</b> Language 'e' (eWG) ...|$|E
40|$|Abstract—This {{document}} gives a quick tutorial {{introduction to}} a <b>functional</b> program <b>verification.</b> In the <b>functional</b> program <b>verification,</b> a program {{is viewed as}} a mathematical function from one program state to another, and proving its correctness is essentially comparing two mathematical functions, the function computed by the program and the specification of the program, called an intended function. The reader is assumed to have some programming experience and to be familiar with such mathematical concepts as sets and functions. I...|$|R
40|$|Abstract—In Cleanroom-style <b>functional</b> program <b>verification,</b> {{a program}} {{is viewed as}} a {{mathematical}} function from one program state to another, and the program is verified by comparing two functions, the implemented and the expected behaviors. The technique requires a minimal mathematical background and supports forward reasoning, but it doesn’t support assertions such as class invariants. However, class invariants are not only a practical programming tool but also {{play a key role in}} the correctness proof of a program by specifying conditions and constraints that an object has to satisfy and thus defining valid states of the object. We suggest a way to integrate the notion of class invariants in <b>functional</b> program <b>verification</b> by using CleanJava as a specification notation and a verification framework as well; CleanJava is a formal annotation language for Java to support Cleanroom-style <b>functional</b> program <b>verification...</b>|$|R
40|$|Abstract—Unlike Hoare-style program <b>verification,</b> <b>functional</b> program <b>verification</b> {{supports}} {{forward reasoning}} by viewing a {{program as a}} mathematical function from one program state to another and proving its correctness by essentially comparing two mathematical functions, the function computed by the program and its specification. Since it requires a minimal mathematical background and reflects the way programmers reason about the correctness of a program informally, it can be taught and practiced effectively. However, there is no formal notation supporting the <b>functional</b> program <b>verification.</b> In this paper, we propose a formal notation for writing functional program specifications for Java programs. The notation, called CleanJava, {{is based on the}} Java expression syntax and is extended with a mathematical toolkit consisting of sets and sequences. The vo-cabulary of CleanJava can also be enriched by introducing user...|$|R
5000|$|Janick Bergeron: Writing Testbenches: <b>Functional</b> <b>Verification</b> of HDL Models, Second Edition, Kluwer Academic Publishers, 2003, ...|$|E
5000|$|It is {{now part}} of the Cadence's <b>functional</b> <b>verification</b> suite, [...] "Incisive Enterprise Simulator", {{although}} Specman can still be licensed as a standalone product.|$|E
50|$|In {{high-level}} synthesis, behavioral/algorithmic {{designs in}} ANSI C/C++/SystemC code is synthesized to RTL, {{which is then}} synthesized into gate level through logic synthesis. <b>Functional</b> <b>verification</b> is the task to make sure a design at RTL or gate level conforms to a specification. As logic synthesis matures, most <b>functional</b> <b>verification</b> is done at the higher abstraction, i.e. at RTL level, the correctness of logic synthesis tool in the translating process from RTL description to gate netlist is a less concern today.|$|E
40|$|In a Cleanroom-style <b>functional</b> program <b>verification,</b> {{a program}} {{is viewed as}} a {{mathematical}} function from one program state to another, and a verification is done by comparing two functions, the implemented and the expected behaviors of a program. The technique requires a minimal mathematical background and supports forward reasoning, but it doesn 2 ̆ 7 t support assertions such as class invariants. However, assertions such as class invariants are not only a practical programming tool but also {{play a key role in}} the correctness proof of a program by specifying conditions and constraints that an object has to satisfy and thus defining valid states of an object. We suggest a way to integrate the notion of a class invariant in a <b>functional</b> program <b>verification</b> by using CleanJava as a specification notation and a verification framework. CleanJava is a formal annotation language for Java to support a Cleanroom-style <b>functional</b> program <b>verification.</b> We propose a small extension to CleanJava to specify a class invariant and also to its proof logic to verify the invariant. Our extension closely reflects the way programmers specify and reason about the correctness of a program informally. It allows one to use a class invariant in the framework of a Cleanroom-style <b>functional</b> specification and <b>verification...</b>|$|R
40|$|Unlike Hoare-style program <b>verification,</b> <b>functional</b> program <b>verification</b> {{supports}} {{forward reasoning}} by viewing a {{program as a}} mathematical function from one program state to another and proving its correctness by essentially comparing two mathematical functions, the function computed by the program and its specification. Since it requires a minimal mathematical background and reflects the way that programmers reason about the correctness of a program informally, it can be taught and practiced effectively. However, there is no formal notation supporting the <b>functional</b> program <b>verification.</b> In this article, we describe a formal notation for writing functional program specifications for Java programs. The notation, called CleanJava, {{is based on the}} Java expression syntax and is extended with a mathematical toolkit consisting of sets and sequences. The vocabulary of CleanJava can also be enriched by introducing user-specified definitions such as user-defined mathematical functions and specification-only methods. We believe that CleanJava is a good notation fo...|$|R
40|$|Abstract—Unlike a Hoare-style program <b>verification,</b> a <b>functional</b> program <b>verification</b> {{supports}} {{forward reasoning}} by viewing a {{program as a}} mathematical function from one program state to another and proving its correctness by essentially comparing two mathematical functions, the function computed by the program and its specification. Since it requires a minimal mathematical background and reflects the way programmers reason about the correctness of a program informally, it can be taught and practiced effectively. However, there is no formal notation supporting the <b>functional</b> program <b>verification.</b> In this paper, we propose a formal notation for writing functional program specifications for Java programs. The notation, called CleanJava, {{is based on the}} Java expression syntax and is extended with a mathematical toolkit consisting of sets and sequences. The vocabulary of CleanJava can also be enriched by introducing user-specified definitions such as user-defined mathematical functions and specification-only methods. We believe that CleanJava is a good notation for writing functional specifications and expect it to promote the use of <b>functional</b> program <b>verifications</b> by being able to specify a wide range of Java programs...|$|R
50|$|Logic design: Architecture is {{implemented}} in a register transfer level (RTL) language, then simulated {{to verify that}} it performs the desired functions. This includes <b>functional</b> <b>verification.</b>|$|E
5000|$|DVinsight: Design Verification Editor Checker for System Verilog [...] and Universal Verification Methodology, {{a product}} that {{provides}} Universal Verification Methodology editing and checking for <b>functional</b> <b>verification</b> engineers.|$|E
50|$|SystemC {{is applied}} to {{system-level}} modeling, architectural exploration, performance modeling, software development, <b>functional</b> <b>verification,</b> and high-level synthesis. SystemC {{is often associated with}} electronic system-level (ESL) design, and with transaction-level modeling (TLM).|$|E
40|$|AbstractSingle-flank and double-flank rolling {{tests are}} <b>functional</b> <b>verifications</b> to obtain {{representative}} {{parameters of the}} future gear behavior under operating conditions. The reliability of the results are questioned due to the great number of error sources together {{with a lack of}} norms that could provide a standard traceability procedure. Currently, there are not commercial machines that integre both tests. In this work, the development of an equipment which combines single-flank and double-flank rolling tests for worm-worm gear is presented. Consequently, complete studies about principal influences and relation between both types of test can be performed. The results obtained will allow to develop a traceable calibration procedure to stablish measurement uncertainty of gear rolling testers...|$|R
40|$|The Microwave Limb Sounder {{instrument}} was launched aboard NASA's EOS AURA satellite in July, 2004. The overall scientific objectives for MLS are to measure temperature, pressure, and several important chemical {{species in the}} upper troposphere and stratosphere relevant to ozone processes and climate change. MLS consists of a suite of radiometers designed to operate from 11 8 GHz to 2. 5 THz, with two antennas (one for 2. 5 THz, the other for the lower frequencies) that scan vertically through the atmospheric limb, and spectrometers with spectral resolution of 6 MHz at spectral line centers. This paper describes the on-orbit commissioning the MLS instrument which includes activation and engineering <b>functional</b> <b>verifications</b> and calibrations. 1...|$|R
40|$|This paper {{explores the}} concept of design {{diversity}} redundancy applied to mixed-signal (MS) circuit blocks, as a proposal to increase system reliability. Three different implementations of a second order low-pass filter (which perform the same transfer function) associated to a majority voter are used to build a diversity TMR scheme. The whole system is prototyped by using a single programmable mixed-signal device. <b>Functional</b> <b>verifications</b> and a fault injection campaign are performed, {{and the effectiveness of}} the voting system to detect single faults is investigated. Based on these results, analytical calculations were done to estimate the behavior of the system under the occurrence of double faults. Results show a very good ability of the system to tolerate double faults from the considered model...|$|R
5000|$|The Reference Verification Methodology (RVM) is a {{complete}} set of metrics and methods for performing <b>Functional</b> <b>verification</b> of complex designs such as for Application-specific integrated circuits or other semiconductor devices. It was published by Synopsys in 2003.|$|E
50|$|Random test {{generators}} (often abbreviated RTG or ISG for Instruction Stream Generator) are a type {{of computer}} software that is used in <b>functional</b> <b>verification</b> of microprocessors. Their primary use lies in providing input stimulus to a device under test.|$|E
5000|$|Suitability for {{purpose is}} {{verified}} by <b>functional</b> <b>verification.</b> This may include such techniques as logic simulation, formal verification, emulation, or creating an equivalent pure software model (see Simics, for example). Each technique has advantages and disadvantages, and often several methods are used.|$|E
40|$|<b>Functional</b> formal <b>verification</b> on {{designs of}} pSeries {{microprocessors}} and communication subsystems This paper discusses our experiences {{and results in}} applying <b>functional</b> formal <b>verification</b> (FFV) techniques {{to the design of}} the IBM pSeriest microprocessor and communication subsystem. We describe the evolution of FFV deployment across several generations of this product line, including tool and algorithmic improvements, as well as methodological improvements for prioritizing the portions of the design that should be considered for formal verification coverage. Improvements made in the formal verification toolset, including the introduction of semiformal verification and bounded-model-checking algorithms, have allowed increasingly larger partitions to become candidates for formal coverage. Other tool enhancements, such as phaseabstraction techniques to deal with clock gating schemes, are presented. Overall, numerous complex design defects were discovered using formal techniques across the microprocessor and communication subsystem, many of which would likely have escaped to the test floor. 1...|$|R
40|$|Analog {{and mixed}} signal (AMS) {{circuits}} {{play an important}} role in system on chip designs. They pose, however, many challenges in the verification of the overall system due to their complex behaviors and expensive consumption of simulation resources. Besides functionality, AMS systems also suffer from stochastic processes such as random noise which exhibits statistical properties. Among many developed verification techniques, runtime verification has been shown to be effective by experimenting finite executions instead of going through the whole state space. In this thesis, we propose a methodology for the verification of AMS designs using functional and statistical runtime <b>verification.</b> <b>Functional</b> runtime <b>verification</b> is used to check the functional behavior of the AMS design. A system of recurrence equation (SRE) is used to model the AMS design and construct a functional property monitor. This <b>functional</b> runtime <b>verification</b> is carried out in an online fashion. Statistical runtime verification is used to verify the statistical properties of the AMS design. Hypothesis test, which is a method to make statistical decisions about rejecting or accepting some statement about the information of a sample, is used to verify the statistical properties. We use Monte Carlo simulation for the hypothesis test and for evaluating its performance. The proposed methodology is applied to a phase lock loop based frequency synthesizer where several functional properties and stochastic noise properties are verified...|$|R
40|$|Formal program {{verification}} {{can be used}} as {{a complementary}} technique to software testing. It allows checking the correctness of all the states of a program which may be impossible using only software testing as a verification technique. One software development process that relies on formal verification is Cleanroom Software Engineering. Cleanroom 2 ̆ 7 s main principles are to certify the software with respect to its specification and to produce zero-fault or near-zero-fault software. Cleanroom has being tested primarily in safety-critical systems that require a high level of correctness by development teams in places such as NASA and IBM, demonstrating lower fault rates and improved reliability. One of the techniques derived from Cleanroom is <b>functional</b> program <b>verification.</b> <b>Functional</b> program <b>verification</b> consists of calculating the function computed by the code (code function) and comparing it with its formal specification (intended function). A program is correct with respect to its specification if both functions are equivalent. CleanJava is a formal annotation language for the Java language that supports Cleanroom-style <b>functional</b> program <b>verification.</b> CleanJava has two main purposes: to promote the use of <b>functional</b> program <b>verification</b> (especially in the academia) and to serve as a platform for the development of techniques and tools that enable automatic or semi-automatic <b>functional</b> program <b>verification.</b> ^ Currently there are no support tools for the CleanJava language. The main step towards building CleanJava tools is the creation of a language checker that parses CleanJava specifications and performs static analysis such as syntax and type checking on those specifications. However, developing a checker for CleanJava poses several interesting challenges. The checker needs to be sufficiently flexible and extensible since the CleanJava language is still under development requiring constant experimentation and implementation of new language features. The checker will serve as a base platform to more advanced tools such as fully automated theorem provers, so it needs to support extension mechanisms and integration with other development tools. Because CleanJava notation is based on the Java language syntax and CleanJava annotations are embedded in Java programs, the checker needs to understand and process Java code as well. This would require building yet another Java compiler or ideally extending an existing Java compiler. ^ In this thesis I describe a series of solutions to address the above mentioned challenges related to developing a CleanJava checker (CJC). A key element in my solutions is to implement the CJC tool as an extension of an existing Java compiler that provides extensibility features. JastAddJ was used as the base code to support extensibility and avoid building a new Java compiler. JastAddJ is an extensible Java compiler that allows creating Java language extensions in a modular way. JastAddJ extensibility capabilities are provided by JastAdd, a meta-compilation system for creating modular and extensible compilers. Another key element in my solution approach was to build a set of tools that facilitate the creation of CleanJava language features including JastAdd specification file generators using XML templates. The current implementation of CJC supports most of the CleanJava language features and {{can be used as}} an alternative to a Java compiler such as javac. ...|$|R
50|$|Nusym Technology, Inc. is {{a company}} that {{produces}} intelligent verification software products, also known as intelligent testbench products, which are a form of <b>functional</b> <b>verification</b> that targets and maximizes test coverage of a logic design by automatically adapting the verification testbenches to changes in register transfer level code.|$|E
50|$|Note {{that this}} is very {{different}} from functional testing, which attempts to validate that the circuit under test functions according to its functional specification. This is closely related to <b>functional</b> <b>verification</b> problem of determining if the circuit specified by the netlist meets the functional specifications, assuming it is built correctly.|$|E
5000|$|Specman is an EDA {{tool that}} {{provides}} advanced automated <b>functional</b> <b>verification</b> of hardware designs. It provides an environment for working with, compiling, and debugging testbench environments {{written in the}} e Hardware Verification Language. Specman also offers automated testbench generation to boost productivity {{in the context of}} block, chip, and system verification.|$|E
40|$|Abstract—In Cleanroom-style <b>functional</b> program <b>verification,</b> {{a program}} {{is viewed as}} a {{mathematical}} function from one program state to another, and the program is verified by comparing two functions, the implemented and the expected behaviors of a program. The technique requires a minimal mathematical background and supports forward reasoning, but it doesn’t support assertions such as class invariants. However, class invariants are not only a practical programming tool bu...|$|R
40|$|AbstractThe paper {{discusses}} the constructive framework for writing hypervisor {{on the top}} of the VM. Hypervisor plays a vital role in monitoring VM in cloud. Hypervisors are system programs that virtualizes the running of the architecture. These are critical, safe, small and hard program to write and debug or evaluate. Hypervisors are system software programs that virtualize the architecture they run on. They are typically small, safety-critical, and hard to debug, which makes them a feasible and interesting target for formal <b>verification.</b> Previous <b>functional</b> <b>verifications</b> of system software were all based on interactive theorem proving, requiring substantial human effort complemented by expert proven knowledge. In this paper we present the frame work of a hypervisor and basic implementation module of hypervisor and simulator module of hypervisor. The virtual environment is controlled and managed by software known as the hypervisor. The hypervisor executes at a higher privilege level than the “guest” operating systems; the hypervisor can access any memory assigned to any guest operating system. Furthermore, a guest operating system cannot access resources in the system unless permitted to do so by the hypervisor...|$|R
40|$|System Level Analysis {{calls for}} a {{language}} comprehensible to experts with different background and yet precise enough to support meaningful analyses. SysML is emerging as an effective balance between such conflicting goals. In this paper we outline some the results obtained as for SysML based system level <b>functional</b> formal <b>verification</b> by an ESA/ESTEC study, with a collaboration among INTECS and La Sapienza University of Roma. The study focuses on SysML based system level functional requirements techniques. 1...|$|R
50|$|High-level {{verification}} (HLV), or electronic system-level (ESL) verification, is {{the task}} to verify ESL designs at high abstraction level, i.e., it {{is the task}} to verify a model that represents hardware above register-transfer level (RTL) abstract level. For high-level synthesis (HLS or C synthesis), HLV is to HLS as <b>functional</b> <b>verification</b> is to logic synthesis.|$|E
50|$|EVE/ZeBu is a {{provider}} of hardware-assisted verification tools for <b>functional</b> <b>verification</b> of Application-specific integrated circuits (ASICs) and system on chip (SOC) designs and for validation of embedded software (software driver, Operating System and Application software) ahead of implementation in silicon. EVE's hardware acceleration and hardware emulation products work in conjunction with Verilog, SystemVerilog, and VHDL-based simulators from Synopsys, Cadence Design Systems and Mentor Graphics. EVE's flagship product is ZeBu.|$|E
50|$|Analog {{verification}} is {{a methodology}} for performing <b>functional</b> <b>verification</b> on analog, mixed-signal and RF integrated circuits and systems on chip. Discussion of analog verification began in 2005 {{when it started}} to become recognized that the analog portion of large mixed-signal chips had become so complex that a significant and ever increasing number of these chips were being designed with functional errors in the analog portion that prevented them from operating correctly.|$|E
40|$|Abstract—A formal {{correctness}} {{proof of}} code containing loops such as while statements typically uses {{the technique of}} proof-by-induction, and often {{the most difficult part}} of carrying out an inductive proof is formulating a correct induction hypothesis, a specification for a loop statement. An incorrect induction hypothesis will surely lead to a proof failure. In this paper we propose a systematic way for identifying specifications of while statements. The key idea of our approach is to categorize and document common patterns of while statements along with their specifications. This is based on our observation that similarly-structured while statements frequently have similarly-structured specifications. Thus, a catalog of code and specification patterns can be used as a good reference for finding and formulating a specification of a while statement. We explain our approach using <b>functional</b> program <b>verification</b> in which a program is viewed as a mathematical function from one program state to another, and a correctness proof is done by comparing two functions, the implemented and the specified. However, we believe our approach is applicable to other verification techniques such as Hoare logic using pre- and post-conditions. Keywords—code and specification patterns, <b>functional</b> program <b>verification,</b> intended function, specification, while statement...|$|R
40|$|This paper {{demonstrates}} a formal verificationplanning process and presents associated verification strategy {{that we believe}} is an essential (yet often neglected) step in an ASIC or SoC <b>functional</b> formal <b>verification</b> flow. Our contribution is to present a way to apply the verification planning process {{and a set of}} abstraction techniques on a non-trivial open-source example (the Sun OpenSPARC ™ DDR 2 controller). The process and verification strategy can be applied to DDR 2 controllers in particular and generalized for other designs. 1...|$|R
40|$|In {{the process}} of {{software}} evolution, {{it is an important}} concern to prevent the introduction of unwanted behavior or bugs (known as regressions) due to updates or when a new feature is implemented in the software. Regression testing is one common solution to identify regressions; a complementary approach that has the same goals as regression testing, but applies methods from formal verification is called regression verification. Usually, both regression testing and <b>verification</b> only consider <b>functional</b> properties, e. g., the results produced by a program. In this thesis, non-functional regressions are considered, in particular detection of modifications that adversely affect program run-time. Applying the method of regression verification, it is shown that two versions of a program produce the same output for all inputs, as well as verified that the two versions are equal with respect to run-time. For the latter step, programs are instrumented to count the number of executed instructions (weighted by the cost of instructions); those counters can then be compared using <b>functional</b> regression <b>verification.</b> Experiments show that this combination of <b>functional</b> regression <b>verification</b> and instrumentation can effectively analyze non-functional Equivalence properties for a range of example programs. In the experiments, the REVE tool, is used to determine functional equivalence after instrumentation...|$|R
