36|15|Public
2500|$|The V60/V70/V80 mostly {{shared a}} common architecture. They had thirty-two 32-bit {{general-purpose}} registers, although the last three of these were commonly used as stack pointer, <b>frame</b> <b>pointer</b> and argument pointer. The V60 and V70 had a 119-instruction set, slightly extended to 123 instructions for the V80. The instructions have variable-length between one and 22 bytes, and they take two operands, both {{of which can be}} memory locations. After studying the V60's reference manual, Paul Vixie described it as [...] "a very vax-ish arch, with a V20/V30 emulation mode (which, if you recall, means it can run Intel 8086/8088 software)".|$|E
2500|$|The {{subroutine}} {{establishes a}} call frame using register A6 as the <b>frame</b> <b>pointer.</b> This kind of calling convention supports reentrant and recursive code and is typically used by languages like C and C++. The subroutine then retrieves the parameters passed to it ( [...] and [...] ) from the stack. It then loops, reading an ASCII character (a single byte) from the [...] string, checking {{whether it is}} an alphabetic character, and if so, converting it into a lower-case character, then writing the character into the [...] string. Finally, it checks whether the character was a null character; if not, it repeats the loop, otherwise it restores the previous stack frame (and A6 register) and returns. Note that the string pointers (registers A0 and A1) are auto-incremented in each iteration of the loop.|$|E
5000|$|Where the {{previous}} {{value of the}} <b>frame</b> <b>pointer</b> is stored, {{which is used to}} restore the <b>frame</b> <b>pointer</b> when the routine ends (in the stack frame, or in some register) ...|$|E
50|$|Some Burroughs stack {{machines}} do support up-level refs {{directly in}} the hardware, with specialized address modes and a special 'display' register file holding the frame addresses of all outer scopes. No subsequent computer lines have done this in hardware. When Niklaus Wirth developed the first Pascal compiler for the CDC 6000, he {{found that it was}} faster overall to pass in the <b>frame</b> <b>pointers</b> as a chain, rather than constantly updating complete arrays of <b>frame</b> <b>pointers.</b> This software method also adds no overhead for common languages like C which lack up-level refs.|$|R
50|$|Computers {{commonly}} provide direct, efficient {{access to}} the program's global variables and to the local variables of only the current innermost procedure or function, the topmost stack frame. 'Up level' addressing {{of the contents of}} callers' stack frames is usually not needed and not supported as directly by the hardware. If needed, compilers support this by passing in <b>frame</b> <b>pointers</b> as additional, hidden parameters.|$|R
50|$|In a {{language}} with free pointers or non-checked array writes (such as in C), {{the mixing of}} control flow data which affects the execution of code (the return addresses or the saved <b>frame</b> <b>pointers)</b> and simple program data (parameters or return values) in a call stack is a security risk, possibly exploitable through stack buffer overflows as {{the most common type}} of buffer overflows.|$|R
5000|$|Example call: push EAX pass some {{register}} result push byteEBP+20 pass some {{memory variable}} (FASM/TASM syntax) push 3 pass some constant call calc the returned result {{is now in}} EAXTypical callee structure: (some or all (except ret) of the instructions below may be optimized away in simple procedures)calc: push EBP save old <b>frame</b> <b>pointer</b> mov EBP,ESP get new <b>frame</b> <b>pointer</b> sub ESP,localsize reserve place for locals [...] [...] perform calculations, leave result in EAX [...] mov ESP,EBP free space for locals pop EBP restore old <b>frame</b> <b>pointer</b> ret paramsize free parameter space and return ...|$|E
50|$|These {{changes were}} {{primarily}} {{aimed at improving}} the efficiency of a data stack implementation. If FSR2 is used either as the stack pointer or <b>frame</b> <b>pointer,</b> stack items may be easily indexed allowing more efficient re-entrant code. Microchip's MPLAB C18 C compiler chooses to use FSR2 as a <b>frame</b> <b>pointer.</b>|$|E
5000|$|... a6 is the <b>frame</b> <b>pointer,</b> {{which can}} be {{disabled}} by a compiler option ...|$|E
50|$|Process state {{data are}} those pieces of {{information}} that define {{the status of a}} process when it is suspended, allowing the OS to restart it later and still execute correctly. This always includes the content of the CPU general-purpose registers, the CPU process status word, stack and <b>frame</b> <b>pointers</b> etc. During context switch, the running process is stopped and another process is given a chance to run. The kernel must stop the execution of the running process, copy out the values in hardware registers to its PCB, and update the hardware registers with the values from the PCB of the new process.|$|R
5000|$|MP {{marks the}} {{beginning}} of the active stack <b>frame</b> (the mark <b>pointer).</b>|$|R
5000|$|... which allocates a {{requested}} {{number of}} bytes on the call stack. No corresponding deallocation function exists, as typically the memory is deallocated {{as soon as the}} calling function returns. [...] was present on Unix systems as early as 32/V (1978), but its use can be problematic in some (e.g., embedded) contexts. [...] While supported by many compilers, it {{is not part of the}} ANSI-C standard and therefore may not always be portable. It may also cause minor performance problems: it leads to variable-size stack frames, so that both stack and <b>frame</b> <b>pointers</b> need to be managed (with fixed-size stack frames, one of these is redundant). [...] Larger allocations may also increase the risk of undefined behavior due to a stack overflow. [...] C99 offered variable-length arrays as an alternative stack allocation mechanism - however, this feature was relegated to optional in the later C11 standard.|$|R
5000|$|In most systems a stack frame has a {{field to}} contain the {{previous}} value of the <b>frame</b> <b>pointer</b> register, the value it had while the caller was executing. For example, the stack frame of [...] would have a memory location holding the <b>frame</b> <b>pointer</b> value that [...] uses (not shown in the diagram above). The value is saved upon entry to the subroutine and restored upon return. Having such a field in a known location in the stack frame enables code to access each frame successively underneath the currently executing routine's frame, and also allows the routine to easily restore the <b>frame</b> <b>pointer</b> to the caller's frame, just before it returns.|$|E
50|$|The {{locations}} {{of all other}} fields in the frame can be defined relative either {{to the top of}} the frame, as negative offsets of the stack pointer, or relative {{to the top of the}} frame below, as positive offsets of the <b>frame</b> <b>pointer.</b> The location of the <b>frame</b> <b>pointer</b> itself must inherently be defined as a negative offset of the stack pointer.|$|E
5000|$|A {{function}} prologue typically {{does the}} following actions if the architecture has a base pointer (also known as <b>frame</b> <b>pointer)</b> and a stack pointer: ...|$|E
40|$|It {{has been}} {{proposed}} that allocating procedure activation records on a garbage collected heap is more efficient than stack allocation. However, previous comparisons of heap vs. stack allocation have been over-simplistic, neglecting (for example) <b>frame</b> <b>pointers,</b> or the better locality of reference of stacks. We present a comprehensive analysis of all the components of creation, access, and disposal of heap-allocated and stack-allocated activation records. Among our results are: ffl Although stack frames {{are known to have}} a better cache read-miss rate than heap frames, our simple analytical model (backed up by simulation results) shows that the difference is too trivial to matter. ffl The cache write-miss rate of heap frames is very high; we show that a variety of miss-handling strategies (exemplified by specific modern machines) can give good performance, but not all can. ffl The write-miss policy of the primary cache is much more important than the write-miss policy of the second [...] ...|$|R
40|$|Abstract: Due to {{shrinking}} structure sizes {{on memory}} chips, {{the probability of}} memory failures, such as spontaneous bit flips, is increasing. Especially {{in the domain of}} massproduced cheap embedded systems, hardware solutions are not affordable. Therefore, {{there is a need for}} cost-efficient software-based fault-tolerance mechanisms. In this paper we focus on such a mechanism for the protection of CPU stacks. A baseline assessment conducted with 21 benchmark and test programs shows that the stack is the most fault-susceptible data memory region – even more critical than the OS kernel’s scheduler data structure, for instance. Our mechanism, which is based on profiling and a generic aspect-oriented implementation, supports detection and correction of bit flips in return addresses and <b>frame</b> <b>pointers</b> on the stack. It thereby reduces the number of stack-related program failures by 48. 7 % and the number of all RAM-related failures by 13. 3 % on the average over all benchmarks. The average code size overhead is 3. 76 %, and a runtime overhead is only measurable for the subset of short-running benchmarks. ...|$|R
40|$|Despite {{the fact}} that {{protection}} mechanisms like StackGuard, ASLR and NX are widespread, the development on new defense strategies against stack-based buffer overflows has not yet come to an end. In this article, we present a novel compiler-level protection called SCADS: Separated Control and Data Stacks that protects return addresses and saved <b>frame</b> <b>pointers</b> on a separate stack, called the control stack. In common computer programs, a single user mode stack is used to store control information next to data buffers. By separating control information from the data stack, we can protect sensitive pointers of a program’s control flow from being overwritten by buffer overflows. To substantiate the practicability of our approach, we provide SCADS as an open source patch for the LLVM compiler infrastructure. Focusing on Linux and FreeBSD running on the AMD 64 architecture, we show compatibility, security and performance results. As we make control flow information simply unreachable for buffer overflows, many exploits are stopped {{at an early stage}} of progression with only negligible performance overhead...|$|R
5000|$|The System V ABI, {{which most}} modern Unix-like systems follow, passes {{the first six}} {{arguments}} in [...] "in" [...] registers %i0 through %i5, reserving %i6 for the <b>frame</b> <b>pointer</b> and %i7 for the return address.|$|E
50|$|When stack {{frame sizes}} can differ, such as between {{different}} functions or between invocations {{of a particular}} function, popping a frame off the stack does not constitute a fixed decrement of the stack pointer. At function return, the stack pointer is instead restored to the <b>frame</b> <b>pointer,</b> {{the value of the}} stack pointer just before the function was called. Each stack frame contains a stack pointer {{to the top of the}} frame immediately below. The stack pointer is a mutable register shared between all invocations. A <b>frame</b> <b>pointer</b> of a given invocation of a function is a copy of the stack pointer as it was before the function was invoked.|$|E
50|$|If frame {{pointers}} {{are being}} used, the prologue will typically set the new {{value of the}} <b>frame</b> <b>pointer</b> register from the stack pointer. Space on the stack for local variables can then be allocated by incrementally changing the stack pointer.|$|E
40|$|Contents 3 Frames 1 3. 1 Frames : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 5 3. 2 <b>Frame</b> <b>Pointers</b> : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 6 3. 3 Registers : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 7 3. 4 Instructions : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 8 3. 5 Instruction Blocks : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 9 3. 5. 1 Routine Blocks : : : : : : : : : : : : : : : : : : : : : : : : : : 10 3. 5. 2 Case Blocks : : : : : : : : : : : : : : : : : : : : : : : : : : : : 11 3. 5. 3 Iteration Blocks : : : : : : : : : : : : : : : : : : : : : : : : : : 14 3. 5. 4 FINISHED and DISABLE Flags : : : : : : : : : : : : : : : : : 15 3. 5. 5 EXCEPTION and PROTECT Flags : : : : : : : : : : : : : : 16 3. 6 Instruction Group...|$|R
40|$|AbstractUsing a {{predicate}} transformer semantics of programs, we introduce statements for heap {{operations and}} separation logic operators for specifying programs that manipulate pointers. We prove a powerful Hoare total correctness rule for mutually recursive procedures manipulating pointers. The rule combines earlier proof rules for (mutually) recursive procedures with the <b>frame</b> rule for <b>pointer</b> programs. The theory, including the proofs, is {{implemented in the}} theorem prover PVS. In this implementation program variables and addresses can store values of almost any type of the theorem prover...|$|R
40|$|A {{transmission}} signal having {{a sequence of}} logical frames embed therein, is constructed such that each logical frame comprises a useful data section, wherein consecutive access units of an access unit stream are consecutively inserted into the useful data section of the sequence of logical frames, wherein each logical frame (20) into which a begin (32) of an access unit (28) falls, comprises an access unit table (30) comprising, per begin (32) of the access units falling into the respective logical <b>frame</b> (20), a <b>pointer</b> (40) pointing thereto...|$|R
50|$|On some systems (little endian {{architectures}} in particular) {{this can}} result in the overwriting of the least significant byte of the <b>frame</b> <b>pointer.</b> This can cause an exploitable condition where an attacker can hijack the local variables for the calling routine.|$|E
5000|$|On both O32 and N32/N64 {{the stack}} grows downwards, however the N32/N64 ABIs require 64-bit {{alignment}} for all stack entries. The <b>frame</b> <b>pointer</b> ($30) is optional and in practice rarely used except when the stack allocation in a function is determined at runtime, for example, by calling alloca (...) [...]|$|E
50|$|For the N32 and N64 ABIs, a {{function}} must preserve the $S0-$s7 registers, the global pointer ($gp or $28), the stack pointer ($sp or $29) and the <b>frame</b> <b>pointer</b> ($30). The O32 ABI {{is the same}} except the calling function is required to save the $gp register instead of the called function.|$|E
5000|$|There was ROM {{memory in}} the {{cartridge}} and ROM memory {{built into the}} console. Popping out the cartridge while executing code in the console ROM created garbage references in the stack <b>frames</b> and invalid <b>pointers,</b> which caused the strange patterns to be drawn. ... The Bally Astrocade was unique among cartridge games {{in that it was}} designed to allow users to change game cartridges with power-on. When pressing the reset button, it was possible to remove the cartridge from the system and induce various memory dump pattern sequences. Digital TV Dinner is a collection of these curious states of silicon epilepsy set to music composed and generated upon this same platform.|$|R
40|$|In this paper, {{the current}} state of {{hardware}} profiling on networked clusters is examined in some depth, with some conjecture about the near future. Next, an implementation of a simple Unix command-line tool Ichnaea is given. Ichnaea automates the process of clusterwide profiling. Finally, we examine opportunities for extension and further work. Profiling Background Traditionally, a profiler is a piece of code that runs alongside a target program while logging the interesting actions (for some user-defined concept of interesting action) of the target program. Many profilers also include a tool that generates a human-readable report from these log files. There is an important distinction to be made between deterministic profilers and statistical profilers: a deterministic profiler records each action taken by a program (variables initialized, memory allocations, function calls, exceptions, etc.) with full precision and consistency, whereas a statistical profiler uses a sampling-based method to log snapshots of the stack <b>frame</b> and instruction <b>pointer</b> during program execution. ...|$|R
5000|$|Within {{the topic}} of stack buffer overflows, an often {{discussed}} but rarely seen architecture {{is one in which}} the stack grows in the opposite direction. This change in architecture is frequently suggested as a solution to the stack buffer overflow problem because any overflow of a stack buffer that occurs within the same stack frame can not overwrite the return pointer. Further investigation of this claimed protection finds it to be a naive solution at best. Any overflow that occurs in a buffer from a previous stack frame will still overwrite a return pointer and allow for malicious exploitation of the bug. For instance, in the example above, the return pointer for [...] will not be overwritten because the overflow actually occurs within the stack frame for [...] However, because the buffer that overflows during the call to [...] resides in a previous stack <b>frame,</b> the return <b>pointer</b> for [...] will have a numerically higher memory address than the buffer. This means that instead of the return pointer for [...] being overwritten, the return pointer for [...] will be overwritten. At most this means that growing the stack in the opposite direction will change some details of how stack buffer overflows are exploitable, but it will not reduce significantly the number of exploitable bugs.|$|R
50|$|Example 1:Within a {{subroutine}} {{a programmer}} will mainly {{be interested in}} the parameters and the local variables, which will rarely exceed 64 KB, for which one base register (the <b>frame</b> <b>pointer)</b> suffices. If this routine is a class method in an object-oriented language, then a second base register is needed which points at the attributes for the current object (this or self in some high level languages).|$|E
50|$|The prologue will {{commonly}} {{save the}} return address {{left in a}} register by the call instruction by pushing the value onto the call stack. Similarly, the current stack pointer and/or <b>frame</b> <b>pointer</b> values may be pushed. Alternatively, some instruction set architectures automatically provide comparable functionality {{as part of the}} action of the call instruction itself, and in such an environment the prologue need not do this.|$|E
50|$|The {{randomization}} of {{the stack}} base {{has an effect on}} payload delivery during shellcode and return-to-libc attacks. Shellcode attacks modify the return pointer field to the address of the payload; while return-to-libc attacks modify the stack <b>frame</b> <b>pointer.</b> In either case, the probability of success is diminished significantly; the position {{of the stack}} is unpredictable, and missing the payload likely causes the program to crash.|$|E
50|$|If the nested {{function}} or {{functions are}} (mutually) recursive, it becomes {{hard for the}} compiler to know exactly where on the call stack the non-local variable was allocated, as the <b>frame</b> <b>pointer</b> only points to the local variable of the nested function itself and there can be an arbitrary number of activation records on the stack in between. This is generally solved using access links or display registers.|$|E
50|$|In Unix-like {{operating}} systems, fork {{bombs are}} generally written {{to use the}} fork system call. As forked processes are also copies of the first program, once they resume execution from the next address at the <b>frame</b> <b>pointer,</b> they also seek to create a copy of themselves; this {{has the effect of}} causing an exponential growth in processes. As modern Unix systems generally use copy-on-write when forking new processes, a fork bomb generally will not saturate such a system's memory.|$|E
5000|$|The {{following}} {{example of}} KSR assembly performs an indirect procedure call to an address {{held in the}} procedure's constant block, saving the return address in register [...] It also saves the <b>frame</b> <b>pointer,</b> loads integer register zero with the value 3, and increments integer register 31 without changing the condition codes. Most instructions have a delay slot of 2 cycles and the delay slots are not interlocked, so must be scheduled explicitly, else the resulting hazard means wrong values are sometimes loaded.|$|E
