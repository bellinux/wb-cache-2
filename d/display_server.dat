137|74|Public
25|$|Besides {{externally}} visible components, such as X window managers, a non-obvious {{but quite}} central role {{is played by}} the programs hosted by freedesktop.org, such as D-Bus or PulseAudio; both major desktop environments (GNOME and KDE) include them, each offering graphical front-ends written using the corresponding toolkit (GTK+ or Qt). A <b>display</b> <b>server</b> is another component, which {{for the longest time}} has been communicating in the X11 <b>display</b> <b>server</b> protocol with its clients; prominent software talking X11 includes the X.Org Server and Xlib. Frustration over the cumbersome X11 core protocol, and especially over its numerous extensions, has {{led to the creation of}} a new <b>display</b> <b>server</b> protocol, Wayland.|$|E
25|$|Wayland is a <b>display</b> <b>server</b> {{protocol}} {{intended as}} a replacement for the X11 protocol; , it has not received wider adoption. Unlike X11, Wayland does not need an external window manager and compositing manager. Therefore, a Wayland compositor takes the role of the <b>display</b> <b>server,</b> window manager and compositing manager. Weston is the reference implementation of Wayland, while GNOME's Mutter and KDE's KWin are being ported to Wayland as standalone display servers. Enlightenment has already been successfully ported since version 19.|$|E
25|$|In the beginning, Matthias Ettrich {{chose to}} use Trolltech’s Qt {{framework}} for the KDE project. Other programmers quickly started developing KDE/Qt applications, and by early 1997, a few applications were being released. On 12 July 1998 {{the first version of}} the desktop environment, called KDE 1.0, was released. The original GPL licensed version of this toolkit only existed for platforms which used the X11 <b>display</b> <b>server,</b> but with the release of Qt 4, LGPL licensed versions are available for more platforms. This allowed KDE software based on Qt 4 or newer versions to theoretically be distributed to Microsoft Windows and OS X.|$|E
5000|$|GS-35F-0311R (Information Technology): Includes computers, cables, connectors, <b>displays,</b> <b>servers,</b> printers, {{software}} and rugged instruments and more.|$|R
5000|$|... evdev is {{primarily}} used by <b>display</b> <b>servers</b> like X.org (via xf86-input-evdev driver and libevdev) and Weston.|$|R
5000|$|Direct Graphics Access is a plug-in for the X <b>display</b> <b>servers</b> {{that allows}} client {{programs}} {{direct access to}} the frame-buffer.|$|R
25|$|Separate {{projects}} that interface with the kernel provide {{much of the}} system's higher-level functionality. The GNU userland {{is an important part}} of most Linux-based systems, providing the most common implementation of the C library, a popular CLI shell, and many of the common Unix tools which carry out many basic operating system tasks. The graphical user interface (or GUI) used by most Linux systems is built on top of an implementation of the X Window System. More recently, the Linux community seeks to advance to Wayland as the new <b>display</b> <b>server</b> protocol in place of X11.|$|E
50|$|The Mir <b>display</b> <b>server</b> {{comes with}} its own Mir <b>display</b> <b>server</b> {{protocol}} which is different from those used by X11 and Wayland. Mir additionally supports the X11 protocol. It was developed by Canonical and {{was intended to be}} the <b>display</b> <b>server</b> of choice for Ubuntu. As of 2017, it has been replaced with the Wayland <b>display</b> <b>server</b> for desktop editions of Ubuntu.|$|E
50|$|The main {{component}} of any windowing system is usually called the <b>display</b> <b>server,</b> although alternative denominations such as window server or compositor {{are also in}} use. Any application that runs and presents its GUI in a window, is a client of the <b>display</b> <b>server.</b> The <b>display</b> <b>server</b> and its clients {{communicate with each other}} over a communications protocol, which is usually called <b>display</b> <b>server</b> protocol, the <b>display</b> <b>server</b> being the mediator between the clients and the user. It receives all the input from the kernel, that the kernel receives from all attached input devices, such as keyboard, pointing devices, or touchscreen and transmits it to the correct client. The <b>display</b> <b>server</b> is also responsible for the output of the clients to the computer monitor. The output of sound is usually not managed by the <b>display</b> <b>server,</b> but the sound volume, is usually handled through GUI applets and it is the <b>display</b> <b>server</b> who decides which applications are on top. A windowing system enables the computer user to work with several programs at the same time. Each program presents its GUI in its own window, which is generally a rectangular area of the screen.|$|E
5000|$|... #Caption: Illustration of the Linux {{graphics}} stack: DRM, KMS driver, & libDRM, Mesa 3D. <b>Display</b> <b>servers</b> are {{a component}} of the windowing system and not required for playing video games.|$|R
5000|$|Associate all <b>display</b> <b>servers</b> {{with the}} same VT: any user can switch VTs {{and in that case}} all users switch to the new VT. This makes VT {{switching}} (and thus fast user switching) impractical. X.Org Server command-line option ...|$|R
50|$|The Linux console {{is capable}} of {{supporting}} any VGA-style text mode, but the kernel itself has very limited means to set these modes up. SVGATextMode helps to enable more complex text modes than the standard EGA and VGA modes. It is fully compatible with Console Tools, but has some conflicts with dosemu, SVGAlib and <b>display</b> <b>servers.</b>|$|R
50|$|With {{the release}} of GNOME 3.16 in March 2015, GDK {{obtained}} an experimental back-end for the Mir <b>display</b> <b>server</b> protocol. The Mir <b>display</b> <b>server</b> protocol is a product by Canonical for their Ubuntu distribution of Linux, which they intend {{to compete with the}} Wayland <b>display</b> <b>server</b> protocol; so far, it is implemented only in Ubuntu.|$|E
50|$|A <b>display</b> <b>server</b> or window server is {{a program}} whose primary task is to {{coordinate}} the input and output of its clients {{to and from the}} rest of the operating system, the hardware, and each other. The <b>display</b> <b>server</b> communicates with its clients over the <b>display</b> <b>server</b> protocol, a communications protocol, which can be network-transparent or simply network-capable.|$|E
50|$|Notable {{examples}} of display servers implementing the X11 <b>display</b> <b>server</b> protocol are X.Org Server, XFree86, XQuartz and Cygwin/X, while client libraries implementing the X11 <b>display</b> <b>server</b> protocol are Xlib and XCB.|$|E
50|$|Besides 3D {{applications}} such as games, modern <b>display</b> <b>servers</b> (X.org's Glamor or Wayland's Weston) use OpenGL/EGL; therefore all graphics typically go through Mesa. Proprietary graphics drivers (e.g. Nvidia GeForce driver and AMD Catalyst for Radeon) replace all of Mesa, providing their own implementation of a graphics API, rather than providing a driver that Mesa talks to. While Nvidia today promotes its proprietary driver for gaming, AMD promotes their Mesa drivers (radeon and radeonSI) over the deprecated AMD Catalyst (formerly fglrx).|$|R
40|$|The X Window System {{has become}} widely {{accepted}} by many manufacturers. X provides network transparent access to <b>display</b> <b>servers,</b> allowing local and remote client programs to access a user's display. X {{is used on}} high performance workstation displays as well as terminals, and client programs run on everything from micro to super computers. This paper describes the tradeo s and basic design decisions made during the design of X Version 11. We presume familiarity with the paper describing X Version 10...|$|R
5000|$|Software like MediaWiki uses [...] "magic words" [...] to make system {{information}} available to templates and editors, such as , which <b>displays</b> the <b>server</b> time: , see [...]|$|R
50|$|If one seat's <b>display</b> <b>server</b> {{is running}} on VT 7 and another seat's <b>display</b> <b>server</b> is running on VT 8, then {{only one of}} these two seats can be used at a time. To use the other seat, a VT switch must be initiated.|$|E
5000|$|... #Subtitle level 2: Available <b>display</b> <b>server</b> {{communications}} protocols ...|$|E
5000|$|... default {{standard}} is implemented Wayland (<b>display</b> <b>server</b> protocol) ...|$|E
50|$|A {{basic set}} of servers for a {{general-purpose}} microkernel includes file system servers, device driver <b>servers,</b> networking <b>servers,</b> <b>display</b> <b>servers,</b> and user interface device servers. This set of servers (drawn from QNX) provides roughly {{the set of}} services offered by a Unix monolithic kernel. The necessary servers are started at system startup and provide services, such as file, network, and device access, to ordinary application programs. With such servers running in the environment of a user application, server development is similar to ordinary application development, rather than the build-and-boot process needed for kernel development.|$|R
40|$|Users are {{increasingly}} nomadic, carrying computing power with them. To gain rich input and output, users could annex displays and input devices when available, but annexing via VGA cable is insufficient. This article introduces XICE, which uses wireless networks to connect portable devices to <b>display</b> <b>servers.</b> Network connections eliminate cables, allow multiple people {{to share a}} display, and ease input annexation. XICE mitigates potentially malicious input, and facilitates comfortable viewing {{on a variety of}} displays via view-independent coordinates. The XICE-distributed graphics model greatly reduces portable device CPU usage and extends portable device battery life...|$|R
40|$|A {{method is}} {{proposed}} to facilitate visually-driven interactions between two devices, {{which we call}} the client, such as a mobile phone or personal digital assistant (PDA), which must be equipped with a camera, and the server, such as a personal computer (PC) or intelligent display. The technique that we describe here requires a camera on the client to view the <b>display</b> on the <b>server,</b> such that either the client or the server (or both) can compute exactly which part of the <b>server</b> <b>display</b> is being viewed. The <b>server</b> <b>display</b> and the clients image of the <b>server</b> <b>display,</b> which can be written onto (part of) the client’s display are then registered. This basic principle, which we call “display registration ” supports a very broad range of interactions (depending on {{the context in which}} the system is operating) and it will make these interactions significantly quicker, easier and more intuitive for the user to initiate and control. In addition, either the client or the server (or both) can compute the six degree-of-freedom (6 DOF) position of the client camera with respect to the <b>server</b> <b>display.</b> We have built a prototype which proves the principle and usefulness of display registration. This system employs markers on the <b>server</b> <b>display</b> for fast registration and it has been used to demonstrate a variety of operations, such as selecting and zooming into images. ...|$|R
50|$|Display servers that {{implement}} the Wayland <b>display</b> <b>server</b> protocol, are called Wayland compositors. Like any <b>display</b> <b>server,</b> a Wayland compositor {{is responsible for}} handling input and output for its clients and - in contrast to X11 - additionally for the compositing. Examples are Weston, Mutter, KWin or Enlightenment.|$|E
50|$|Aqua {{is powered}} by the <b>display</b> <b>server</b> Quartz Compositor.|$|E
50|$|The Wayland <b>display</b> <b>server</b> {{protocol}} {{is named}} after the town.|$|E
2500|$|On desktop systems, {{the most}} popular user {{interfaces}} are the GUI shells, packaged together with extensive desktop environments, such as the K Desktop Environment (KDE), GNOME, MATE, Cinnamon, Unity, LXDE, Pantheon and Xfce, though a variety of additional user interfaces exist. Most popular user interfaces {{are based on the}} X Window System, often simply called [...] "X". It provides network transparency and permits a graphical application running on one system to be displayed on another where a user may interact with the application; however, certain extensions of the X Window System are not capable of working over the network. Several X <b>display</b> <b>servers</b> exist, with the reference implementation, X.Org Server, being {{the most popular}}.|$|R
50|$|Many {{providers}} {{also provide}} a Web-based interface or a mobile application where a user creates an account, logs in and supplies a source number, destination number and the bogus caller ID information to be <b>displayed.</b> The <b>server</b> then places a call {{to each of the}} two endpoint numbers and bridges the calls together.|$|R
5000|$|Network Time Protocol time <b>servers</b> <b>display</b> the refid {{identifier}} [...]DCFa. (amplitude modulation) or [...]DCFp. (phase modulation) when {{a standard}} DCF77 time receiver {{is used as}} the reference time source.|$|R
5000|$|... #Caption: X11-clients use xlib to {{communicate}} with the <b>display</b> <b>server.</b>|$|E
50|$|Xvfb or X virtual framebuffer is a <b>display</b> <b>server</b> {{implementing}} the X11 <b>display</b> <b>server</b> protocol. In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output. From {{the point of}} view of the client, it acts exactly like any other X <b>display</b> <b>server,</b> serving requests and sending events and errors as appropriate. However, no output is shown. This virtual server does not require the computer it is running on to have any kind of graphics adapter, a screen or any input device. Only a network layer is necessary.|$|E
5000|$|... eXodus is a <b>display</b> <b>server</b> {{implementing}} the X11 <b>display</b> <b>server</b> protocol that was originally developed by White Pine Software. White Pine founders began {{development in the}} fall of 1987, and released Version 1.0 in April 1989. Version 1.0 was only built for the Macintosh platform, but versions for Windows, DOS, and NeXT would follow in the coming years.|$|E
40|$|Large-scale and {{high-resolution}} displays {{are increasingly}} being used for next-generation interactive 3 D graphics applications, including large-scale data visualization, immersive virtual environments, and collaborative design. These systems must include a very highperformance and scalable 3 D rendering subsystem in order to generate high-resolution images at real-time frame rates. We are investigating how to build such a system using only inexpensive commodity components in a PC cluster. The main challenge is to develop scalable algorithms to partition and distribute rendering tasks effectively under the bandwidth, processing, and storage constraints of a distributed system. In this paper, we compare three different approaches that differ {{in the type of}} data transmitted from client to display servers: control, primitives, or pixels. For each approach, we describe our initial experiments with a working prototype system driving a multi-projector display wall with a PC cluster. We find that different approaches are suitable for different system architectures, with the best choice depending on the communication bandwidth, storage capacity, and processing power of the clients and <b>display</b> <b>servers.</b> ...|$|R
5000|$|The VNC server is {{the program}} on the machine that shares some screen (and may not be related to a {{physical}} <b>display</b> - the <b>server</b> can be [...] "headless"), and allows the client to share control of it.|$|R
50|$|A display manager can run on {{the same}} {{computer}} where the user sits—starting one or more X <b>servers,</b> <b>displaying</b> the login screen {{at the beginning and}} (optionally) every time the user logs out—or on a remote one, working according to the XDMCP protocol.|$|R
