193|373|Public
25|$|Pointers are not {{exposed by}} default. There {{is no need}} for the {{programmer}} to keep track of and mark names for referencing or <b>dereferencing.</b>|$|E
25|$|Peek can {{generally}} be implemented very easily in simple routine taking O(1) time and no added space, {{by a simple}} variant of the pop operation. Most sequential data types are implemented by a data structure containing {{a reference to the}} end, and thus peek is simply implemented by <b>dereferencing</b> this. In some cases it is more complicated, however.|$|E
25|$|Both {{concepts}} {{have their}} advantages and disadvantages. Objects are useful when {{the data is}} large, like the description of a window or {{the contents of a}} document. In these cases, access to that data is provided by copying a 32- or 64-bit value, versus copying an entire data structure. However, smaller values like integers are the same size as pointers (typically both are one word), so there is no advantage to passing a pointer, versus passing the value. Also, pass-by-reference inherently requires a <b>dereferencing</b> operation, which can produce noticeable overhead in some operations, typically those used with these basic value types, like mathematics.|$|E
40|$|Many {{analysis}} {{techniques have}} been proposed to determine when a potentially null value may be <b>dereferenced.</b> But we have observed in practice that not every potential null <b>dereference</b> is a “bug ” that developers want to fix. In this {{paper we discuss some}} of the challenges of using a null <b>dereference</b> analysis in practice, and reasons why developers may not feel it necessary to change code to prevent ever possible null <b>dereference.</b> We revisit previous work on XYLEM, an interprocedural null <b>dereference</b> analysis for Java, and discuss the challenge of comparing the results of different static analysis tools. We also report experimental results for XYLEM, Coverity Prevent, Fortify SCA, Eclipse and FindBugs, and observe that the different tools tradeoff the need to flag all potential null <b>dereferences</b> with the need to minimize the number of cases that are implausible in practice. We conclude by discussing whether {{it would be useful to}} extend the Java type system to distinguish between nullable and nonnull types, and prohibit unchecked <b>dereferences</b> of nullable types...|$|R
40|$|This paper {{examines}} the architectural issues in building storage systems for object-oriented database management systems #OO DBMSs# and persistent languages. We survey techniques for placing {{small and large}} objects on disk and disk space management, and we present client-server architectures for OO DBMSs. We describe alternatives in making a programming language persistent and in particular, we discuss pointers and three pointer <b>dereference</b> mechanisms: import#export, software <b>dereference,</b> and hardware <b>dereference.</b> ...|$|R
25|$|Null pointer <b>dereference.</b>|$|R
25|$|Windows {{specific}} compiler {{support is}} also needed for Structured Exception Handling (SEH). This system serves two purposes: {{it provides a}} substrate on which language-specific exception handling can be implemented, and it is how the kernel notifies applications of exceptional conditions such as <b>dereferencing</b> an invalid pointer or stack overflow. The Microsoft/Borland C++ compilers {{had the ability to}} use this system {{as soon as it was}} introduced in Windows 95 and NT, however the actual implementation was undocumented and had to be reverse engineered for the Wine project and free compilers. SEH is based on pushing exception handler frames onto the stack, then adding them to a linked list stored in thread local storage (the first field of the thread environment block). When an exception is thrown, the kernel and base libraries unwind the stack running handlers and filters as they are encountered. Eventually, every exception unhandled by the application will be dealt with by the default backstop handler, which pops up the Windows common crash dialog.|$|E
500|$|On May 27, 2014, Perl 5.20 was released. Notable new {{features}} include subroutine signatures, hash slices/new slice syntax, postfix <b>dereferencing</b> (experimental), Unicode 6.3, rand (...) using consistent random number generator.|$|E
5000|$|A call to [...] {{is handled}} by <b>dereferencing</b> 's [...] vpointer, looking up the [...] {{entry in the}} vtable, and then <b>dereferencing</b> that pointer to call the code.|$|E
5000|$|The {{following}} code {{includes a}} null pointer <b>dereference,</b> but when compiled will often {{not result in}} a segmentation fault, as the value is unused and thus the <b>dereference</b> will often be optimized away by dead code elimination:int *ptr = NULL;*ptr; ...|$|R
5000|$|One of the {{advantages}} of using Uniform Resource Identifier (URIs) is that they can be <b>dereferenced</b> using the HTTP protocol. According to the so-called Linked Open Data principles, such a <b>dereferenced</b> URI should result in a document that offers further data about the given URI. In this example, all URIs, both for edges and nodes (e.g. , , [...] ) can be <b>dereferenced</b> and will result in further RDF graphs, describing the URI, e.g. that Dresden is a city in Germany, or that a person, in the sense of that URI, can be fictional.|$|R
5000|$|... #Subtitle level 4: Array, Procedure, <b>Dereference</b> and {{coercion}} operations ...|$|R
50|$|It only finds basic bugs (f.ex. {{null pointer}} <b>dereferencing).</b>|$|E
5000|$|Automatic {{building}} and <b>dereferencing</b> of pointers from type context.|$|E
5000|$|<b>Dereferencing</b> null {{pointers}} - this is special-cased by {{memory management}} hardware ...|$|E
5000|$|Servers do not <b>dereference</b> aliases when {{processing}} a delete request ...|$|R
40|$|We propose null-pointer <b>dereferences</b> as {{a target}} for finding bugs in {{concurrent}} programs using testing. A null-pointer <b>dereference</b> prediction engine observes an execution of a concurrent program under test and predicts alternate interleavings {{that are likely to}} cause null-pointer <b>dereferences.</b> Though accurate scalable prediction is intractable, we provide a carefully chosen novel set of techniques to achieve reasonably accurate and scalable prediction. We use an abstraction to the shared-communication level, take advantage of a static lock-set based pruning, and finally, employ precise and relaxed constraint solving techniques that use an SMT solver to predict schedules. We realize our techniques in a tool, ExceptioNULL, and evaluate it over 13 benchmark programs and find scores of nullpointer <b>dereferences</b> by using only a single test run as the prediction seed for each benchmark. D. 2. 4 [Software Engineer-D. 2. 5 [Software Engineer...|$|R
5000|$|Kernel mode {{null pointer}} <b>dereference</b> exploit {{affecting}} FreeBSD 7.0 to 7.2.|$|R
5000|$|Values in a hash {{reference}} are accessed {{using the}} <b>dereferencing</b> operator: ...|$|E
50|$|<b>Dereferencing</b> the NULL pointer {{typically}} {{results in}} an attempted read or write from memory that is not mapped - triggering a segmentation fault or access violation. This may represent itself to the developer as a program crash, or be transformed into an exception that can be caught. There are, however, certain circumstances where {{this is not the}} case. For example, in x86-real mode, the address 0000:0000 is readable and usually writable, hence <b>dereferencing</b> the null pointer is a perfectly valid but typically unwanted action that may lead to undefined but non-crashing behaviour in the application. Note also that there are occasions when <b>dereferencing</b> the NULL is intentional and well defined; for example BIOS code written in C for 16-bit real-mode x86 devices may write the IDT at physical address 0 of the machine by <b>dereferencing</b> a NULL pointer for writing. It is also possible for the compiler to optimize away the `NULL` pointer dereference, avoiding a segmentation fault but causing other undesired behavior.|$|E
5000|$|<b>Dereferencing</b> or {{assigning}} to an uninitialized pointer (wild pointer, which {{points to a}} random memory address) ...|$|E
5000|$|... {{takes that}} memory address and <b>dereferences</b> it {{to access the}} value.|$|R
5000|$|... {{and they}} are <b>dereferenced</b> automatically, so no special symbol required. In ...|$|R
5000|$|...L, <b>dereference</b> the {{symbolic}} link that {{points to an}} existing file or directory.|$|R
5000|$|In {{both cases}} the {{function}} object can be used either using the <b>dereferencing</b> arrow syntax $ref->(@arguments): ...|$|E
5000|$|<b>Dereferencing</b> or {{assigning}} to a freed pointer (dangling pointer, which points to memory {{that has been}} freed/deallocated/deleted) ...|$|E
5000|$|Null pointer dereference - <b>dereferencing</b> {{an invalid}} pointer or a pointer to memory {{that has not}} been {{allocated}} ...|$|E
5000|$|Limit pointer use to {{a single}} <b>dereference,</b> and do not use {{function}} pointers.|$|R
50|$|<b>Dereferences</b> of null {{pointers}} lead to undefined {{values and}} usually raise an exception immediately.|$|R
5000|$|...h, do not <b>dereference</b> {{symbolic}} {{links that}} point to an existing file or directory.|$|R
5000|$|Use after free - <b>dereferencing</b> a {{dangling}} pointer storing {{the address}} of an object that has been deleted.|$|E
50|$|<b>Dereferencing</b> a bad pointer {{within a}} driver will crash the driver process, but {{will have no}} effect on the system as a whole. The reincarnation server will restart the crashed driver automatically. For some drivers (e.g., disk and network) {{recovery}} is transparent to user processes. For others (e.g., audio and printer), the user may notice. In monolithic kernels, <b>dereferencing</b> a bad pointer in a driver normally leads to a system crash.|$|E
50|$|The unary * operator, {{as defined}} in C and C++, {{can be used in}} {{compositions}} in cases of multiple indirection, where multiple acts of <b>dereferencing</b> are required. Pointers can of course reference other pointers, and in such cases, multiple applications of the dereference operator are needed. Similarly, the Java dot operator can be used in compositions forming quite sophisticated statements that require substantial <b>dereferencing</b> of pointers behind the scenes during evaluation.|$|E
5000|$|... /* <b>Dereference</b> {{it as an}} int pointer, {{causing an}} unaligned access */ *iptr = 42; ...|$|R
50|$|Using foreign keys, the {{database}} will automatically <b>dereference</b> {{the values of}} the UserPermissions table to their own tables.|$|R
40|$|International audienceFixing a {{software}} error requires understanding its root cause. In this paper, we introduce causality traces, crafted execution traces augmented {{with the information}} needed to reconstruct the causal chain from {{the root cause of}} a bug to an execution error. We propose an approach and a tool, called Casper, based on code transformation, which dynamically constructs causality traces for null <b>dereference</b> errors. The core idea of Casper is to replace null values with special objects, called “ghosts”, that track the propagation of the nulls from inception to their error-triggering <b>dereference.</b> Causality traces are extracted from these ghosts. We evaluate our contribution by providing and assessing the causality traces of 14 real null <b>dereference</b> bugs collected over six large, popular open-source projects...|$|R
