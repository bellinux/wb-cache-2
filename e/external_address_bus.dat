18|670|Public
25|$|NOR {{memory has}} an <b>external</b> <b>address</b> <b>bus</b> for reading and {{programming}}. For NOR memory, reading and programming are random-access, and unlocking and erasing are block-wise. For NAND memory, reading and programming are page-wise, and unlocking and erasing are block-wise.|$|E
2500|$|The 68000 has a 24-bit <b>external</b> <b>address</b> <b>bus</b> and two byte-select signals [...] "replaced" [...] A0. These 24 lines can {{therefore}} address 16 MB of physical memory with byte resolution. Address storage and computation uses 32 bits internally; however, the 8 high-order address bits are ignored {{due to the}} physical lack of device pins. This allows it to run software written for a logically flat 32-bit address space, while accessing only a 24-bit physical address space. [...] Motorola's intent with the internal 32-bit address space was forward compatibility, making it feasible to write 68000 software that would {{take full advantage of}} later 32-bit implementations of the 68000 instruction set.|$|E
2500|$|NAND flash {{has reduced}} erase and write times, and {{requires}} less chip area per cell, thus allowing greater storage density and lower cost per bit than NORflash; {{it also has}} up to 10 times the endurance of NORflash. However, the I/O interface of NANDflash {{does not provide a}} random-access <b>external</b> <b>address</b> <b>bus.</b> Rather, data must be read on a block-wise basis, with typical block sizes of hundreds to thousands of bits. This makes NANDflash unsuitable as a drop-in replacement for program ROM, since most microprocessors and microcontrollers require byte-level random access. In this regard, NANDflash is similar to other secondary data storage devices, such as hard disks and optical media, and is thus highly suitable for use in mass-storage devices, such as memory cards. The first NAND-based removable media format was SmartMedia in 1995, and many others have followed, including: ...|$|E
50|$|Micro-controllers may not {{implement}} an <b>external</b> <b>address</b> or data <b>bus</b> as they integrate RAM and {{non-volatile memory}} {{on the same}} chip as the CPU. Using fewer pins, the chip can {{be placed in a}} much smaller, cheaper package.|$|R
5000|$|... eZ80Acclaim! is {{a family}} of eZ80 single chip {{computers}} labeled as [...] "application-specific standard products" [...] (ASSP) that feature up to 128 KB of flash memory, up to 8 KB of SRAM, and can operate at speeds of up to 20 MHz. Like other eZ80 variants, it has an <b>external</b> <b>address</b> and data <b>bus</b> and can thus {{be used as a}} general purpose microprocessor as well.|$|R
5000|$|... eZ80AcclaimPlus! is {{a family}} of {{connectivity}} ASSPs that feature up to 256 KB of flash memory, 16 KB of SRAM, can operate at speeds of up to 50 MHz. It adds an integrated 10/100BaseT Ethernet MAC, TCP/IP stack over the eZ80Acclaim! line. Like other eZ80 variants, it has an <b>external</b> <b>address</b> and data <b>bus</b> and can thus {{be used as a}} general purpose microprocessor as well.|$|R
50|$|It is a 32-bit {{processor}} with 32-bit internal and <b>external</b> <b>address</b> <b>bus</b> (24-bit <b>external</b> <b>address</b> <b>bus</b> for EZ and VZ variants) and 32-bit data bus. It has many built-in functions, like a color and grayscale display controller, PC speaker sound, serial port with UART and IRDA support, UART bootstrap, real time clock, {{is able to}} directly access DRAM, Flash ROM, mask ROM, and has built-in support for touch screens.|$|E
50|$|NOR {{memory has}} an <b>external</b> <b>address</b> <b>bus</b> for reading and {{programming}}. For NOR memory, reading and programming are random-access, and unlocking and erasing are block-wise. For NAND memory, reading and programming are page-wise, and unlocking and erasing are block-wise.|$|E
50|$|CPU: 8-bit HuC6280A, a {{modified}} 65SC02 running at 1.79, or 7.16 MHz (switchable by software). Features integrated bankswitching hardware (driving a 21-bit <b>external</b> <b>address</b> <b>bus</b> from a 6502-compatible 16-bit address bus), an integrated general-purpose I/O port, a timer, block transfer instructions, and dedicated move instructions for {{communicating with the}} HuC6270A VDC.|$|E
5000|$|The Intel 8008 ("eight-thousand-eight" [...] or [...] "eighty-oh-eight") is {{an early}} byte-oriented {{microprocessor}} designed and manufactured by Intel and introduced in April 1972. It was an 8-bit CPU with an <b>external</b> 14-bit <b>address</b> <b>bus</b> that could <b>address</b> 16 KB of memory. Originally known as the 1201, the chip was commissioned by Computer Terminal Corporation (CTC) to implement an instruction set of their design for their Datapoint 2200 programmable terminal. As the chip was delayed and did not meet CTC's performance goals, the 2200 ended up using CTC's own TTL-based CPU instead. An agreement permitted Intel to market the chip to other customers after Seiko {{expressed an interest in}} using it for a calculator.|$|R
25|$|Because of {{the series}} {{connection}} and removal of wordline contacts, a large grid of NANDflash memory cells will occupy perhaps only 60% of the area of equivalent NOR cells (assuming the same CMOS process resolution, for example, 130nm, 90nm, or 65nm). NANDflash's designers realized that the area of a NAND chip, and thus the cost, could be further reduced by removing the <b>external</b> <b>address</b> and data <b>bus</b> circuitry. Instead, external devices could communicate with NANDflash via sequential-accessed command and data registers, which would internally retrieve and output the necessary data. This design choice made random-access of NANDflash memory impossible, but the goal of NANDflash was to replace mechanical hard disks, not to replace ROMs.|$|R
50|$|Because of {{the series}} {{connection}} and removal of wordline contacts, a large grid of NAND flash memory cells will occupy perhaps only 60% of the area of equivalent NOR cells (assuming the same CMOS process resolution, for example, 130 nm, 90 nm, or 65 nm). NAND flash's designers realized that the area of a NAND chip, and thus the cost, could be further reduced by removing the <b>external</b> <b>address</b> and data <b>bus</b> circuitry. Instead, external devices could communicate with NAND flash via sequential-accessed command and data registers, which would internally retrieve and output the necessary data. This design choice made random-access of NAND flash memory impossible, but the goal of NAND flash was to replace mechanical hard disks, not to replace ROMs.|$|R
50|$|A MC68HC24 port {{replacement}} unit {{is available}} for the HC11. When placed on the <b>external</b> <b>address</b> <b>bus,</b> it replicates the original functions of B and C. Port A has input capture, output compare, pulse accumulator, and other timer functions; port D has serial I/O, and port E has an {{analog to digital converter}} (ADC).|$|E
50|$|However, the {{opposite}} is often true for newer 32-bit designs. For example, the Pentium Pro processor is a 32-bit machine, with 32-bit registers and instructions that manipulate 32-bit quantities, but the <b>external</b> <b>address</b> <b>bus</b> is 36 bits wide, giving a larger address space than 4 GB, and the external data bus is 64 bits wide, primarily in order to permit a more efficient prefetch of instructions and data.|$|E
5000|$|The Hudson Soft HuC6280 is a {{modified}} 65C02 with an effective clock rate of 1.79 or 7.16 MHz (switchable by software). The integrated components of this 8-bit processor include a timer, general-purpose I/O port, and bankswitching hardware (which drives a 21-bit <b>external</b> <b>address</b> <b>bus</b> from a 6502-compatible 16-bit address bus). It {{is capable of}} block transfer instructions, as well as dedicated move instructions for communicating with the TurboDuos video display controller, the HuC6270A.|$|E
40|$|In this paper, we {{introduce}} {{a class of}} irredundant low power encoding techniques for memory address buses. The basic idea is to partition the memory space {{into a number of}} sectors. These sectors can, for example, represent address spaces for the code, heap, and stack segments of one or more application programs. Each address is first dynamically mapped to the appropriate sector and then is encoded with respect to the sector head. Each sector head is updated based on the last accessed address in that sector. The result of this sector-based encoding technique is a {{reduction in the number of}} bus transitions when encoding consecutive addresses that access different sectors. Our proposed techniques have small power and delay overhead when compared with many of the existing methods in the literature. One of our proposed techniques is very suitable for encoding addresses that are sent from an on-chip cache to the main memory when multiple application programs are executing on the processor in a time-sharing basis. For a computer system without an on-chip cache, the proposed techniques decrease the switching activity of data address and multiplexed address buses by an average of 55 % and 67 %, respectively. For a system with on-chip cache, up to 55 % transition reduction is achieved on a multiplexed <b>address</b> <b>bus</b> between the internal cache and the external memory. Assuming a 10 pf per line bus capacitance, we show that power reduction of up to 52 % for an <b>external</b> data <b>address</b> <b>bus</b> and 42 % for the multiplexed bus between cache and main memory is achieved using our methods...|$|R
50|$|Systems {{that have}} more than one bus master have {{additional}} control bus signals that control which bus master drives the <b>address</b> <b>bus,</b> avoiding bus contention on the <b>address</b> <b>bus.</b>|$|R
50|$|Earlier {{models of}} DVK series {{were based on}} K1801VM1 or K1801VM2 {{microprocessors}} with 16 bit <b>address</b> <b>bus.</b> In the later models, the KM1801VM3 microprocessor (with 22 bit extended <b>address</b> <b>bus)</b> was used.|$|R
50|$|The console's CPU is a Hudson Soft HuC6280 8-bit {{microprocessor}} {{operating at}} 1.79 MHz and 7.16 MHz. It features integrated bank-switching hardware (driving a 21-bit <b>external</b> <b>address</b> <b>bus</b> from a 6502-compatible 16-bit address bus), an integrated general-purpose I/O port, a timer, block transfer instructions, and dedicated move instructions for {{communicating with the}} HuC6270A VDC. Its 16-bit graphics processor and video color encoder chip were also developed by Hudson Soft. It holds 8 kB of work RAM and 64 kB of video RAM.|$|E
5000|$|The 8088 {{processor}} of the IBM PC and IBM PC/XT {{could address}} one Megabyte (MB or 220 bytes) of memory. It inherited this limit from the 20-bit <b>external</b> <b>address</b> <b>bus</b> of the Intel 8086. The designers of the PC allocated the lower 640 kB (655,360 bytes) of address space for read-write program memory (RAM), called [...] "conventional memory", {{and the remaining}} 384 kB of memory space was reserved for uses such as the system BIOS, video memory, and memory on expansion peripheral boards.|$|E
50|$|Bank {{switching}} can {{be considered}} as a way of extending the address bus of a processor with some external register. For example, a processor with a 16-bit <b>external</b> <b>address</b> <b>bus</b> can only address 216 = 65536 memory locations. If an external latch was added to the system, it could be used to control which of two sets of memory devices, each with 65536 addresses, could be accessed. The processor could change which set is in current use by setting or clearing the latch bit.|$|E
50|$|The Z80 {{was officially}} {{described}} as supporting 16-bit (64 KB) memory addressing, and 8-bit (256 ports) I/O-addressing. All I/O instructions actually assert the entire 16-bit <b>address</b> <b>bus.</b> OUT (C),reg and IN reg,(C) places {{the contents of}} the entire 16 bit BC register on the address bus; OUT (n),A and IN A,(n) places {{the contents of the}} A register on b8-b15 of the <b>address</b> <b>bus</b> and n on b0-b7 of the <b>address</b> <b>bus.</b> A designer could choose to decode the entire 16 bit <b>address</b> <b>bus</b> on I/O operations in order {{to take advantage of this}} feature, or use the high half of the <b>address</b> <b>bus</b> to select subfeatures of the I/O device. This feature has also been used to minimise decoding hardware requirements, such as in the Amstrad CPC/PCW and ZX81.|$|R
50|$|An <b>address</b> <b>bus</b> is a {{computer}} bus (a series of lines connecting two or more devices) {{that is used to}} specify a physical address. When a processor or DMA-enabled device needs to read or write to a memory location, it specifies that memory location on the <b>address</b> <b>bus</b> (the value to be read or written is sent on the data bus). The width of the <b>address</b> <b>bus</b> determines the amount of memory a system can address. For example, a system with a 32-bit <b>address</b> <b>bus</b> can <b>address</b> 232 (4,294,967,296) memory locations. If each memory location holds one byte, the addressable memory space is 4 GB.|$|R
50|$|More {{complex systems}} have a multi-master bus -- {{not only do}} they have many devices that each drive the data bus, but also have many bus masters that each drive the <b>address</b> bus.The <b>address</b> <b>bus</b> as well as the data bus in bus {{snooping}} systems is required to be a bidirectional bus, often implemented as a three-state bus.To prevent bus contention on the <b>address</b> <b>bus,</b> a bus arbiter selects which particular bus master is allowed to drive the <b>address</b> <b>bus</b> during this bus cycle.|$|R
5000|$|The 68000 has a 24-bit <b>external</b> <b>address</b> <b>bus</b> and two byte-select signals [...] "replaced" [...] A0. These 24 lines can {{therefore}} address 16 MB of physical memory with byte resolution. Address storage and computation uses 32 bits internally; however, the 8 high-order address bits are ignored {{due to the}} physical lack of device pins. This allows it to run software written for a logically flat 32-bit address space, while accessing only a 24-bit physical address space. Motorola's intent with the internal 32-bit address space was forward compatibility, making it feasible to write 68000 software that would {{take full advantage of}} later 32-bit implementations of the 68000 instruction set.|$|E
50|$|The {{original}} 32016 had a 16-bit external databus, a 24-bit <b>external</b> <b>address</b> <b>bus,</b> {{and a full}} 32-bit instruction set. It {{also included}} a coprocessor interface, allowing coprocessors such as FPUs and MMUs to be attached as peers to the main processor. The MMU was based on demand paging Virtual Memory, which was the most unusual feature compared to the segmented memory approach used by competition, and has become the standard for how microprocessors are designed today. The architecture supported an instruction restart mechanism on a page fault, which was much cleaner than the Motorola approach to dump the internal status on a page fault, {{which had to be}} read back, before the instruction was continued.Again, the Series 32000 approach has become the standard behavior.|$|E
5000|$|NAND flash {{has reduced}} erase and write times, and {{requires}} less chip area per cell, thus allowing greater storage density and lower cost per bit than NOR flash; {{it also has}} up to 10 times the endurance of NOR flash. However, the I/O interface of NAND flash {{does not provide a}} random-access <b>external</b> <b>address</b> <b>bus.</b> Rather, data must be read on a block-wise basis, with typical block sizes of hundreds to thousands of bits. This makes NAND flash unsuitable as a drop-in replacement for program ROM, since most microprocessors and microcontrollers require byte-level random access. In this regard, NAND flash is similar to other secondary data storage devices, such as hard disks and optical media, and is thus highly suitable for use in mass-storage devices, such as memory cards. The first NAND-based removable media format was SmartMedia in 1995, and many others have followed, including: ...|$|E
5000|$|Microcontroller devices with {{integrated}} I/O {{and memory}} on-chip sometimes had no, or a small, <b>address</b> <b>bus</b> available for <b>external</b> devices. For example, a microcontroller family available with a 2 kilobyte address space {{might have a}} variant that brought out an 11 line <b>address</b> <b>bus</b> for an <b>external</b> ROM; this could be done by reassigning I/O pins as <b>address</b> <b>bus</b> pins. Some general-purpose processors with integrated ROM split a 16-bit address space between internal ROM and an external 15-bit memory bus.|$|R
5000|$|... 16-bit <b>address</b> <b>bus</b> (providing an <b>address</b> {{space of}} 64 K bytes) ...|$|R
5000|$|... #Subtitle level 2: Memory data {{organization}} of low energy <b>address</b> <b>bus</b> ...|$|R
5000|$|All {{internal}} registers, {{as well as}} {{internal and}} external data buses, are 16 bits wide, which firmly established the [...] "16-bit microprocessor" [...] identity of the 8086. A 20-bit <b>external</b> <b>address</b> <b>bus</b> provides a 1 MB physical address space (220 = 1,048,576). This address space is addressed by means of internal memory [...] "segmentation". The data bus is multiplexed with the address bus in order to fit all of the control lines into a standard 40-pin dual in-line package. It provides a 16-bit I/O address bus, supporting 64 KB of separate I/O space. The maximum linear address space is limited to 64 KB, simply because internal address/index registers are only 16 bits wide. Programming over 64 KB memory boundaries involves adjusting the segment registers (see below); this difficulty existed until the 80386 architecture introduced wider (32-bit) registers (the memory management hardware in the 80286 did not help in this regard, as its registers are still only 16 bits wide).|$|E
40|$|The energy {{consumption}} at the I/O pins {{is a significant}} part of the overall chip consumption. This paper presents a method for encoding an <b>external</b> <b>address</b> <b>bus</b> which lowers its activity and, thus, decreases the energy. This method relies on the locality of memory references. Since applications favor a few working zones of their address space at each instant, for an address to one of these zones only the offset of this reference with respect to the previous reference to that zone needs to be sent over the bus, along with an identifier of the current working zone. This is combined with a modified one-hot encoding for the offset. An estimate of the area and energy overhead of the encoder/decoder are given; their effect is small. The approach has been applied to two memory-intensive examples, obtaining a bus-activity reduction of about 2 / 3 in both of them. Comparisons are given with previous methods for bus encoding, showing significant improvement. I. Introduction The research on low-en [...] ...|$|E
40|$|The energy {{consumption}} due to input [...] output pins {{is a substantial}} part of the overall chip consumption. To reduce this energy, this work presents the working-zone encoding (WZE) method for encoding an <b>external</b> <b>address</b> <b>bus,</b> based on the conjecture that programs favor a few working zones of their address space at each instant. In such cases, the method identifies these zones and sends through the bus only the offset of this reference with respect to the previous reference to that zone, along with an identifier of the current working zone. This is combined with a one-hot encoding for the offset. Several improvements to this basic strategy are also described. The approach has been applied to several address streams, broken down into instructiononly, data-only, and instruction-data traces, to evaluate the effect on separate and shared address buses. Moreover, the effect of instruction and data caches is evaluated. For the case without caches, the proposed scheme is specially beneficial for [...] ...|$|E
50|$|The 68EC020 is a {{microprocessor}} from Motorola. It is {{a lower cost}} version of the Motorola 68020. The main {{difference between the two}} is that the 68EC020 only has a 24-bit <b>address</b> <b>bus,</b> rather than the 32-bit <b>address</b> <b>bus</b> of the full 68020, and thus is only able to address 16 MB of memory.|$|R
50|$|The {{content of}} the refresh {{register}} R is sent out on {{the lower half of}} the <b>address</b> <b>bus</b> along with a refresh control signal while the CPU is decoding and executing the fetched instruction. During refresh the contents of the Interrupt register I are sent out on the upper half of the <b>address</b> <b>bus.</b>|$|R
5000|$|The {{sideband}} <b>address</b> <b>bus</b> SBA7:0 and SB_STB (and SB_STB# in AGP 2.0) ...|$|R
