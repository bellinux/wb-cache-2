899|377|Public
5|$|The RPython {{language}} can be compiled to C, Java bytecode, or Common <b>Intermediate</b> <b>Language,</b> {{and is used}} to build the PyPy interpreter of Python.|$|E
5|$|HipHop Virtual Machine (HHVM) {{developed}} at Facebook and available as open source, it converts PHP code into a high-level bytecode (commonly {{known as an}} <b>intermediate</b> <b>language),</b> which is then translated into x86-64 machine code dynamically at runtime by a just-in-time (JIT) compiler, resulting in up to 6× performance improvements.|$|E
25|$|Some {{high-level}} languages (Eiffel, Esterel) optimize {{their programs}} {{by using an}} <b>intermediate</b> <b>language.</b>|$|E
50|$|A popular {{format for}} <b>intermediate</b> <b>languages</b> is three-address code.|$|R
50|$|The Standard ML {{compiler}} MLton uses SSA {{in one of}} its <b>intermediate</b> <b>languages.</b>|$|R
40|$|We {{describe}} a definition language for ASM which describe the operational semantics. We restrict the ASM formalism {{in order to}} relate independently defined specifications of source and <b>intermediate</b> <b>languages.</b> On the one hand, this simplifies the specification of languages and allows for the reuse of predefined transformations. On the other hand, {{we are able to}} combine arbitrary source and <b>intermediate</b> <b>languages.</b> The language AL is extensible. Therefore, we update this report whenever new extensions were defined...|$|R
25|$|There {{have been}} {{proposals}} to use Lojban as an <b>intermediate</b> <b>language</b> {{in machine translation}} and knowledge representation.|$|E
25|$|LHC is a whole-program {{optimizing}} backend for GHC, {{based on}} Urban Boquist’s compiler <b>intermediate</b> <b>language,</b> GRIN. Older versions of LHC {{were based on}} Jhc rather than GHC.|$|E
25|$|The Common Language Specification (CLS) is {{specified}} in chapter 6 of ECMA-335 and defines the interface to the CLI, such as conventions like the underlying types for Enum. The Mono compiler generates {{an image that}} conforms to the CLS. This is the Common <b>Intermediate</b> <b>Language.</b> The Mono runtime takes this image and runs it. The ECMA standard formally defines a library that conforms to the CLS as a framework.|$|E
5000|$|The GNU Compiler Collection (GCC) uses several <b>intermediate</b> <b>languages</b> {{internally}} {{to simplify}} portability and cross-compilation. Among these languages are ...|$|R
5000|$|While most <b>intermediate</b> <b>languages</b> are {{designed}} to support statically typed <b>languages,</b> the Parrot <b>intermediate</b> representation is designed to support dynamically typed languages—initially Perl and Python.|$|R
5000|$|TILT {{is a full}} {{certifying}} compiler for SML. It uses typed <b>intermediate</b> <b>languages</b> {{to optimize}} code and ensure correctness, and can compile to Typed assembly language.|$|R
500|$|Phalanger compiles PHP into Common <b>Intermediate</b> <b>Language</b> (CIL) {{bytecode}} ...|$|E
500|$|By design, C# is the {{programming}} language that most directly reflects the underlying Common Language Infrastructure(CLI). [...] Most of its intrinsic types correspond to value-types {{implemented by the}} CLI framework. However, the language specification does not state the code generation requirements of the compiler: that is, it does not state that a C# compiler must target a Common Language Runtime, or generate Common <b>Intermediate</b> <b>Language</b> (CIL), or generate any other specific format. Theoretically, a C# compiler could generate machine code like traditional compilers of C++ or Fortran.|$|E
2500|$|... (IL To CPU) is an AOT {{compiler}} that {{is written}} using a Common <b>Intermediate</b> <b>Language</b> compliant language (C#). It translates Common <b>Intermediate</b> <b>Language</b> to machine code.|$|E
50|$|Static {{analysis}} tools often use an intermediate representation. For instance, radare2 is a toolbox for binary files analysis and reverse-engineering. It uses the <b>intermediate</b> <b>languages</b> ESIL et REIL to analyze binary files.|$|R
50|$|P-Code is a {{name for}} several of Microsoft's {{proprietary}} <b>intermediate</b> <b>languages.</b> They provided an alternate binary format to machine code. At various times, Microsoft have said p-code is an abbreviation for either packed code or pseudo code.|$|R
40|$|We {{present a}} {{certified}} compiler from the simply-typed lambda calculus to assembly language. The compiler is certified {{in the sense}} that it comes with a machine-checked proof of semantics preservation, performed with the Coq proof assistant. The compiler and the terms of its several <b>intermediate</b> <b>languages</b> are given dependent types that guarantee that only well-typed programs are representable. Thus, type preservation for each compiler pass follows without any significant “proofs ” of the usual kind. Semantics preservation is proved based on denotational semantics assigned to the <b>intermediate</b> <b>languages.</b> We demonstrate how working with a type-preserving compiler enables type-directed proof search to discharge large parts of our proof obligations automatically. Categories and Subject Descriptors F. 3. 1 [Logics and meaning...|$|R
2500|$|Altimesh Hybridizer {{created by}} Altimesh compiles Common <b>Intermediate</b> <b>Language</b> to CUDA binaries. It {{supports}} generics and virtual functions. Debugging and profiling is integrated to [...] and [...] It's {{available as a}} Visual Studio Extension on [...]|$|E
2500|$|As JavaScript is {{the most}} widely {{supported}} client-side language that can run within a Web browser, {{it has become an}} <b>intermediate</b> <b>language</b> for other languages to target. This has included both newly created languages and ports of existing languages. Some of these include: ...|$|E
2500|$|Microsoft {{released}} Visual Studio [...]NET (VS.NET), codenamed Rainier (for Washington's Mount Rainier), in February 2002 (the {{beta version}} was released via Microsoft Developer Network in 2001). The biggest change was {{the introduction of}} a managed code development environment using the [...]NET Framework. Programs developed using [...]NET are not compiled to machine language (like C++ is, for example) but instead to a format called Microsoft <b>Intermediate</b> <b>Language</b> (MSIL) or Common <b>Intermediate</b> <b>Language</b> (CIL). When a CIL application executes, it is compiled while being executed into the appropriate machine language for the platform it is being executed on, thereby making code portable across several platforms. Programs compiled into CIL can be executed only on platforms which have an implementation of Common Language Infrastructure. It is possible to run CIL programs in Linux or Mac OS X using non-Microsoft [...]NET implementations like Mono and DotGNU.|$|E
40|$|Abstract. In answer set {{programming}} (ASP), {{a search}} problem is solved by describing its solutions in the input language {{of an answer}} set solver which is then used to compute solutions to the problem. Usually, the problem is converted to an intermediate representation before the actual computation of solutions starts. The current ASP systems employ a number of simplified languages (file formats or like) for this purpose. In this paper, we review a number of <b>intermediate</b> <b>languages</b> and analyse their properties. The goal is to identify best features of such languages {{to be used as}} the basis of new designs and thus pave the way for the standardisation of <b>intermediate</b> <b>languages</b> in ASP. ...|$|R
5000|$|The first section, [...] "The European game" [...] ("Le jeu européen des langues"), {{contains}} the essays [...] "The Role of <b>Intermediate</b> <b>Languages</b> in Translations from Chinese into German" [...] by Wolfgang Bauer and [...] "Italian Translations of Chinese Literature" [...] by Federico Masini.|$|R
40|$|Sets of lexical items {{sharing a}} {{significant}} {{aspect of their}} meaning (concepts) are fundamental in linguistics and NLP. Manual concept compilation is labor intensive, error prone and subjective. We present a web-based concept extension algorithm. Given a set of terms specifying a concept in some language, we translate them {{to a wide range}} of <b>intermediate</b> <b>languages,</b> disambiguate the translations using web counts, and discover additional concept terms using symmetric patterns. We then translate the discovered terms back into the original language, score them, and extend the original concept by adding backtranslations having high scores. We evaluate our method in 3 source <b>languages</b> and 45 <b>intermediate</b> <b>languages,</b> using both human judgments and WordNet. In all cases, our cross-lingual algorithm significantly improves high quality concept extension. ...|$|R
2500|$|For {{computer}} programs {{to run on}} CLI, {{they need to be}} compiled into Common <b>Intermediate</b> <b>Language</b> (CIL) – as opposed to being compiled into machine code. Upon execution, an architecture-specific just-in-time compiler (JIT) turns the CIL code into machine code. To improve performance, however, [...]NET Framework comes with Native Image Generator (NGEN), which performs ahead-of-time compilation.|$|E
2500|$|The use of {{bytecode}} as an <b>intermediate</b> <b>language</b> permits Java {{programs to}} run on any platform that has a virtual machine available. [...] The use of a JIT compiler means that Java applications, after a short delay during loading and once they have [...] "warmed up" [...] by being all or mostly JIT-compiled, tend to run about as fast as native programs.|$|E
2500|$|The Java {{platform}} {{consists of}} several programs, {{each of which}} provides a portion of its overall capabilities. [...] For example, the Java compiler, which converts Java source code into Java bytecode (an <b>intermediate</b> <b>language</b> for the JVM), is provided {{as part of the}} Java Development Kit (JDK). [...] The Java Runtime Environment (JRE), complementing the JVM with a just-in-time (JIT) compiler, converts intermediate bytecode into native machine code on the fly. The Java platform also includes an extensive set of libraries.|$|E
40|$|<b>Intermediate</b> <b>languages</b> are a {{paradigm}} to separate concerns in software verification systems when {{bridging the gap}} between (realworld) programming languages and the logics understood by theorem provers. While such <b>intermediate</b> <b>languages</b> traditionally only offer rather simple type systems, this paper argues that it is both advantageous and feasible to integrate richer type systems with features like (higherranked) polymorphism and quantification over types. As a concrete solution, the paper presents the type system of the Boogie 2 language, which is used in several program verifiers. The paper gives two encodings of types and formulae in simply typed (or untyped) logic such that ordinary theorem provers and SMT solvers {{can be used to}} discharge verification conditions. Extensive empirical evidence is provided showing that the impact of the additional typing information on the verification performance is negligible...|$|R
5000|$|As {{with other}} OSF offerings, ANDF was {{specified}} {{through an open}} selection process. OSF issued a Request for Technology for architecture-neutral software distribution technologies in April, 1989. [...] Fifteen proposals were received, based {{on a variety of}} technical approaches, including obscured source code, compiler <b>intermediate</b> <b>languages,</b> and annotated executable code.|$|R
50|$|Those who had {{at least}} an <b>intermediate</b> level <b>language</b> exam weren't {{required}} to pass a language exam at Matura, but has become compulsory since 2006. In language training classes, a student must pass an <b>intermediate</b> level <b>language</b> exam in the second year, and the same level Matura in the third year.|$|R
2500|$|Once {{the code}} is complete, {{it may be}} {{compiled}} using [...]NET compiler. This converts the application from the original source code (C# or otherwise) into Common <b>Intermediate</b> <b>Language</b> (CIL), the native language of [...]NET Framework. Next the application is run, showing the Cosmos Builder Window, which presents the developer with options which determine exactly how the project is compiled. These options include how to boot the project - via emulators such as Quick Emulator (QEMU), Virtual PC, and VMWare, writing to a disk image (ISO) file that can later be written to a CD-ROM, or via Preboot Execution Environment (PXE) network booting - as well as debug options using Cosmos' built-in debugger, and other options.|$|E
2500|$|The APLNext VisualAPL {{system is}} a {{departure}} from a conventional APL system in that VisualAPL is a true [...]NET language which is fully interoperable with other [...]NET languages such as VB.NET and C#. VisualAPL is inherently object-oriented and Unicode-based. While VisualAPL incorporates most {{of the features of}} standard APL implementations, the VisualAPL language extends standard APL to be [...]NET-compliant. VisualAPL is hosted in the standard Microsoft Visual Studio IDE and as such, invokes compilation in a manner identical to that of other [...]NET languages. By producing Common <b>Intermediate</b> <b>Language</b> (CIL) code, it utilizes the Microsoft just-in-time compiler (JIT) to support 32-bit or 64-bit hardware. Substantial performance speed-ups over standard APL have been reported, especially when (optional) strong typing of function arguments is used.|$|E
2500|$|Cosmos {{encompasses}} an AOT compiler named IL2CPU {{to translate}} Common <b>Intermediate</b> <b>Language</b> (CIL) into native instructions. [...] Cosmos compiles user-made programs and associated libraries using IL2CPU {{to create a}} bootable native executable that can be run with no support. [...] The resulting output can be booted from a USB flash drive, CD-ROM, over a network via Preboot Execution Environment (PXE), or inside a virtual machine. Recent releases also allow deploying to certain x86 embedded devices over Universal Serial Bus (USB). [...] While C# is the primary language used by developers (both on the backend and by end users of Cosmos), many CLI languages can be used, provided they compile to pure CIL {{without the use of}} Platform Invocation Services (P/Invokes). [...] Cosmos is mainly intended for use with [...]NET Framework, with Mono support in the works.|$|E
5000|$|Standard Portable Intermediate Representation, an <b>intermediate</b> shader <b>language</b> by Khronos Group ...|$|R
50|$|C-- (pronounced cee minus minus) is a C-like {{programming}} language. Its creators, {{functional programming}} researchers Simon Peyton Jones and Norman Ramsey, designed {{it to be}} generated mainly by compilers for very high-level languages rather than written by human programmers. Unlike many other <b>intermediate</b> <b>languages,</b> its representation is plain ASCII text, not bytecode or another binary format.|$|R
40|$|In {{the past}} few years a large body of work has {{developed}} on the use of typed <b>intermediate</b> <b>languages</b> in compilers. It has become apparent that the retention of type information in the intermediate representation of a program is useful for ensuring compiler correctness and facilitating optimizations. The use of <b>intermediate</b> <b>languages</b> resembling typed -calculus in the compilation of functional languages like ML and Haskell has been particularly successful, but not much has been done on using this kind of intermediate format for non-functional languages. Meanwhile, TOOPL, TOIL and LOOM have been developed as object-oriented programming languages with static type-safety and semantic foundations firmly in mind. Encodings for the object and class constructs of these languages in -calculus are known, and consideration of these encodings has proved fruitful in their design and implementation. In this thesis, our intention is to exploit the work on the semantic foundations of objectoriented la [...] ...|$|R
