23|98|Public
50|$|Another {{alternative}} to the status register is for processor instructions to deposit status information in a <b>general-purpose</b> <b>register</b> when the program requests it. MIPS, AMD 29000, DEC Alpha, and RISC-V are examples of architectures that provide comparison instructions that store the comparison result in a <b>general-purpose</b> <b>register,</b> as a single bit or a numeric value of 0 or 1. Conditional branches act based on the value in the <b>general-purpose</b> <b>register.</b>|$|E
50|$|In contrast, {{register}} machines hold temporary {{values in}} a small, fast array of registers. Accumulator machines {{have only one}} <b>general-purpose</b> <b>register.</b> Belt machines use a FIFO queue to hold temporary values. Memory-to-memory machines that have no temporary registers usable by a programmer.|$|E
5000|$|The second way {{leaves a}} {{computed}} {{value on the}} data stack, duplicating it as needed. This uses operations to copy stack entries. The stack must be depth shallow enough for the CPU's available copy instructions. Hand-written stack code often uses this approach, and achieves speeds like <b>general-purpose</b> <b>register</b> machines. Unfortunately, algorithms for optimal [...] "stack scheduling" [...] are not in wide use by programming languages.|$|E
5000|$|The IBM System/360 has a 32-bit {{architecture}} with 16 <b>general-purpose</b> <b>registers,</b> {{but most}} of the System/360 implementations actually use hardware that implemented a much simpler underlying microarchitecture; for example, the System/360 Model 30 has 8-bit data paths to the arithmetic logic unit (ALU) and main memory and implemented the <b>general-purpose</b> <b>registers</b> in a special unit of higher-speed core memory, and the System/360 Model 40 has 8-bit data paths to the ALU and 16-bit data paths to main memory and also implemented the <b>general-purpose</b> <b>registers</b> in a special unit of higher-speed core memory. The Model 50 has full 32-bit data paths and implements the <b>general-purpose</b> <b>registers</b> in a special unit of higher-speed core memory. [...] The Model 65 through the Model 195 have larger data paths and implement the <b>general-purpose</b> <b>registers</b> in faster transistor circuits. In this way, microprogramming enabled IBM to design many System/360 models with substantially different hardware and spanning a wide range of cost and performance, while making them all architecturally compatible. This dramatically reduces the number of unique system software programs that must be written for each model.|$|R
5000|$|In {{addition}} to these 32 <b>general-purpose</b> <b>registers,</b> the CPU has a few special-purpose registers: ...|$|R
25|$|MIPS I has thirty-two 32-bit <b>general-purpose</b> <b>registers.</b> Register $0 is {{hardwired}} to {{zero and}} writes to it are discarded. Register $31 is the link register. For integer multiplication and division instructions, which run asynchronously from other instructions, {{a pair of}} 32-bit registers, HI and LO, are provided. There is a small set of instructions for copying data between the <b>general-purpose</b> <b>registers</b> and the HI/LO registers.|$|R
50|$|The {{memory map}} is as follows:If RAM is not banked, then R15 (S) {{is just another}} <b>general-purpose</b> <b>register.</b> If RAM is banked, then the low half of the data address space (addresses 0x00-7F) is {{directed}} to a RAM bank selected by S. The special purpose registers in the high half of the data address space are always visible. The data registers at 0xFx {{can be used to}} copy data between banks.|$|E
50|$|The CDC 1700 was a 16-bit word minicomputer, {{manufactured}} by the Control Data Corporation with deliveries beginning in May 1966. The 1700 used ones' complement arithmetic and an ASCII-based character set, and supported memory write protection {{on an individual}} word basis. It had one <b>general-purpose</b> <b>register</b> and two indexing registers (one of which was implemented as a dedicated memory location). The instruction set was fairly simple and supported seven storage addressing modes, including multilevel (chained) indirect addressing.|$|E
5000|$|... # alow = blow + clow addu alow, blow, clow # set tmp = 1 if alow < clow, else 0 sltu tmp, alow, clow addu ahigh, bhigh, chigh addu ahigh, ahigh, tmpThe [...] {{instruction}} sets [...] to 1 or 0 {{based on}} the specified comparison of its two other operands. (Here, the <b>general-purpose</b> <b>register</b> [...] is not used as a status register to govern a conditional jump; rather, the possible value of 1, indicating overflow from the low-order addition, {{is added to the}} high-order word.) ...|$|E
5000|$|In {{addition}} to the standard SIC registers, there are also four additional <b>general-purpose</b> <b>registers</b> specific to the SIC/XE machine: ...|$|R
5000|$|<b>General-purpose</b> <b>registers</b> (GPRs) {{can store}} both data and addresses, i.e., they are {{combined}} data/address registers and rarely the register file is unified to include floating point as well.|$|R
5000|$|In {{addition}} to increasing {{the size of}} the <b>general-purpose</b> <b>registers,</b> the number of named <b>general-purpose</b> <b>registers</b> is increased from eight (i.e. eax, ecx, edx, ebx, esp, ebp, esi, edi) in x86 to 16 (i.e. rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15). It is therefore possible to keep more local variables in registers rather than on the stack, and to let registers hold frequently accessed constants; arguments for small and fast subroutines may also be passed in registers to a greater extent.|$|R
50|$|Relative to {{conventional}} register machine or stack machine architecture, yet similar to Intel's Itanium architecture, a temporal register addressing scheme {{has been proposed}} by Ivan Godard and company that is intended to greatly reduce the complexity of CPU hardware (specifically the number of internal registers and the resulting huge multiplexer trees). While somewhat harder to read and debug than <b>general-purpose</b> <b>register</b> names, it aids understanding to view the belt as a moving conveyor belt where the oldest values drop off the belt and vanish. It is implemented in the Mill architecture.|$|E
5000|$|An {{indirect}} {{jump instruction}} can choose among {{more than two}} branches. Some processors have specialized indirect branch predictors. Newer processors from Intel and AMD can predict indirect branches by using a two-level adaptive predictor. This kind of instruction contributes more than one bit to the history buffer. The zBC12 and later z/Architecture processors from IBM support a [...] instruction that can preload the branch predictor entry for a given instruction with a branch target address constructed by adding {{the contents of a}} <b>general-purpose</b> <b>register</b> to an immediate displacement value.|$|E
5000|$|An operand is two bytes long, {{typically}} representing {{an address}} as a 4-bit nibble denoting a base register and a 12-bit displacement {{relative to the}} contents of that register, in the range 000 - FFF (shown here as hexadecimal numbers). The address corresponding to that operand is {{the contents of the}} specified <b>general-purpose</b> <b>register</b> plus the displacement. For example, an MVC instruction that moves 256 bytes (with length code 255 in hexadecimal as FF) from base register 7, plus displacement 000, to base register 8, plus displacement 001, would be coded as the 6-byte instruction [...] "D2FF 8001 7000" [...] (operator/length/address1/address2).|$|E
5000|$|With {{the advent}} of the 32-bit 80386 processor, the 16-bit <b>general-purpose</b> <b>registers,</b> base registers, index registers, {{instruction}} pointer, and FLAGS register, but not the segment registers, were expanded to 32 bits. The nomenclature represented this by prefixing an [...] "E" [...] (for [...] "extended") to the register names in x86 assembly language. Thus, the AX register corresponds to the lowest 16 bits of the new 32-bit EAX register, SI corresponds to the lowest 16 bits of ESI, and so on. The <b>general-purpose</b> <b>registers,</b> base registers, and index registers can all be used as the base in addressing modes, and all of those registers except for the stack pointer can be used as the index in addressing modes.|$|R
50|$|The SHARC has {{two full}} sets of <b>general-purpose</b> <b>registers.</b> Code can {{instantly}} switch between them, allowing for fast context switches between an application and an OS or between two threads.|$|R
50|$|EVEX coding {{can address}} 8 operand mask <b>{{registers}},</b> 16 <b>general-purpose</b> <b>registers</b> and 32 vector registers in 64-bit mode (otherwise, 8 general-purpose and 8 vector), and can support up to 4 operands.|$|R
50|$|Memory-mapped I/O is {{preferred}} in x86-based architectures because the instructions that perform port-based I/O {{are limited to}} one register: EAX, AX, and AL are the only registers that data can be moved into or out of, and either a byte-sized immediate value in the instruction or a value in register DX determines which port is the source or destination port of the transfer. Since any <b>general-purpose</b> <b>register</b> can send or receive data to or from memory and memory-mapped I/O, memory-mapped I/O uses fewer instructions and can run faster than port I/O. AMD did not extend the port I/O instructions when defining the x86-64 architecture to support 64-bit ports, so 64-bit transfers cannot be performed using port I/O.|$|E
5000|$|In later x86 implementations, like Nehalem {{and later}} processors, both integer and {{floating}} point registers are now {{incorporated into a}} unified octa-ported (six read and two write) <b>general-purpose</b> <b>register</b> file (8 + 8 in 32-bit and 16 + 16 in x64 per file), while the register file extended to 2 with enhanced [...] "Shadow Register File Architecture" [...] in favorite of executing hyper threading and each thread uses independent register files for its decoder. Later Sandy bridge and onward replaced shadow register table and architectural registers with much large and yet more advance physical register file before decoding to the reorder buffer. Randered that Sandy Bridge and onward no longer carry an architectural register.|$|E
50|$|In stage three, {{instructions}} in the instruction queues that {{are ready for}} execution have their operands read from the register files. The <b>general-purpose</b> <b>register</b> file contains 48 registers, of which 32 are general-purpose registers and 16 are rename registers for register renaming. To {{reduce the number of}} ports required to provide data and receive results, the general purpose register file is duplicated so that there are two copies, the first supporting three integer execution units and the second supporting the two load/store units. This scheme was similar to a contemporary microprocessor, the DEC Alpha 21264, but was simpler as it did not require an extra clock cycle to synchronize the two copies due to the POWER3's higher cycle times. The floating-point register file contains 56 registers, of which 32 are floating-point registers and 24 rename registers. Compared to the PowerPC 620, there were more rename registers, which allowed more instructions to be executed out of order, improving performance.|$|E
5000|$|Most {{instructions}} {{can access}} only the 12 <b>general-purpose</b> <b>registers</b> r0-r11. In general, {{they are completely}} interchangeable, except that some instructions use r11 implicitly. There are also 4 base registers usable by some instructions: ...|$|R
50|$|Most Sigma systems {{included}} {{two or more}} blocks of 16 <b>general-purpose</b> <b>registers.</b> Switching blocks is accomplished by a single instruction (LPSD), providing fast context switching, since registers {{do not have to}} be saved and restored.|$|R
3000|$|We can {{see that}} {{individual}} data transport to operand (denoted with [...].o suffix) registers and trigger registers (.t) from the <b>general-purpose</b> <b>registers</b> (rX or RX) are explicitly defined. In the same manner, the data transport from the result <b>register</b> (.r) to <b>general-purpose</b> <b>registers</b> are explicit. It {{is worth noting that}} the timing of data transport is not fixed. For instance, register r 4 is written to the operand register of add one cycle before register R 3 is written to the trigger register of add, starting actual computation. Similarly, the operand write of mul is two cycles before the trigger write of the same operation starts execution.|$|R
5000|$|One copy of 8 x87 FP {{push down}} stack by default, MMX {{register}} were virtually simulated from x87 stack and require x86 register to supplying MMX instruction and aliases to exist stack. On P6, the instruction independently {{can be stored}} and executed in parallel in early pipeline stages before decoding into micro-operations and renaming in out-of-order execution. Beginning with P6, all register files do not require additional cycle to propagate the data, register files like architectural and floating point are located between code buffer and decoders, called [...] "retire buffer", Reorder buffer and OoOE and connected within the ring bus (16 bytes). The register file itself still remains one x86 register file and one x87 stack and both serve as retirement storing. Its x86 register file increased to dual ported to increase bandwidth for result storage. Registers like debug/condition code/control/unnamed/flag were stripped from the main register file and placed into individual files between the micro-op ROM and instruction sequencer. Only inaccessible registers like the segment register are now separated from the <b>general-purpose</b> <b>register</b> file (except the instruction pointer); they are now located between the scheduler and instruction allocator, {{in order to facilitate}} register renaming and out-of-order execution. The x87 stack was later merged with the floating-point register file after a 128-bit XMM register debuted in Pentium III, but the XMM register file is still located separately from x86 integer register files.|$|E
50|$|Unlike Alpha, Sparc, and MIPS {{that only}} allows one {{register}} file to load/fetch one operand at the time; {{it would require}} multiple register files to achieve superscale. The ARM processor {{on the other hand}} does not integrate multiple register files to load/fetch instructions. All GPRs hold no special purpose to the instruction set (the ARM ISA does not require accumulator, index, and stack/base points. Registers do not have an accumulator and base/stack point can only be used in thumb mode). Any GPRs can propagate and store multiple instructions independently in smaller code size that is small {{enough to be able to}} fit in one register and its architectural register act as a table and shared with all decoder/instructions with simple bank switching between decoders. The major difference between ARM and other designs is that ARM allows to run on the same <b>general-purpose</b> <b>register</b> with quick bank switching without requiring additional register file in superscalar. Despite x86 sharing the same mechanism with ARM that its GPRS can store any data individually, x86 will confront data dependency if more than three non-related instructions are stored, as its GPRs per file are too small (eight in 32 bit mode and 16 in 64 bit, compared to ARM's 13 in 32 bit and 31 in 64 bit) for data, and it is impossible to have superscalar without multiple register files to feed to its decoder (x86 code is big and complex compared to ARM). Because most of x86's front-end become much larger and much more power hungry than the ARM processor in order to be competitive (example: Pentium M & Core 2 duo, bay trail). Some third-party x86 equivalent processor even became noncompetitive to ARM due having no dedicated register file architecture. Particularly for AMD, Cyrix and VIA that cannot bring any reasonable performance without register renaming and out of order execution, which leave only Intel Atom to be the only in-order x86 processor core in the mobile competition. This was until x86 in Nehalem merged both of its integer and floating point register into one single file and the introduction of a large physical register table and enhanced allocator table in its front-end before renaming in its out-of-order internal core.|$|E
40|$|This paper {{presents}} the Reduced Instruction Set Computer (RISC) system using VHDL {{and the results}} are analyzed in an FPGA system. This paper presents a RISC processor designing to achieve OR, AND, NAND, NOR, XOR, XNOR, ADD, SUBTRACT, NOT, INCREMENT, DECREMENT, etc operations. The 20 -bit RISC system has high <b>general-purpose</b> <b>register</b> (GPR) orthogonality and communicates to peripheral devices via a serial bus...|$|E
50|$|Their first {{computer}} was the 16-bit MODCOMP III, introduced {{shortly after the}} company was founded. This had 15 <b>general-purpose</b> <b>registers,</b> and was initially offered with a 16-kilobyte, 18-mil magnetic core memory with an 800ns cycle time, expandable to 128 kilobytes. The MODCOMP I followed for smaller applications, with only 3 <b>general-purpose</b> <b>registers</b> and a maximum of 64 kilobytes of core. These machines were based on SSI and MSI TTL logic.The MODCOMP II, introduced in 1972, maintained compatibility with the Modcomp III, while using some LSI circuits.The core architecture of the 16-bit machines included blocks of uncommitted opcodes and provisions for physical modularity that hint at the reasoning behind the company name.|$|R
30|$|In addition, when {{parallel}} execution requires {{access to}} several <b>general-purpose</b> <b>registers</b> {{in the same}} cycle, register files need to provide enough read and write ports to allow such access, leading to increased complexity and higher energy requirements of register files.|$|R
50|$|CPU {{architectures}} {{always have}} more than one possible calling convention. With many <b>general-purpose</b> <b>registers</b> and other features, the potential number of calling conventions is large, although some architectures are formally specified to use only one calling convention, supplied by the architect.|$|R
40|$|An {{instruction}} set architecture (ISA) suitable for future microprocessor design constraints is proposed. The ISA has hierarchical register files {{with a small}} number of accumulators at the top. The instruction stream is divided into chains of dependent instructions (strands) where intra -strand dependences are passed through the accumulator. The <b>general-purpose</b> <b>register</b> file is used for communication between strands and for holding global values that have many consumers...|$|E
30|$|We {{can observe}} direct data {{transports}} from the result to operand or trigger registers. Data transports from the result register to the <b>general-purpose</b> <b>register</b> are completely scraped for both additions (dead result move elimination), as {{the results are}} used just once in multiplication, where they are transported directly from the result register of the adder. Compared to the first RISC-like example, we can observe that all the registers denoted with capital RX have disappeared, while {{the amount of work}} function units performed remains the same.|$|E
30|$|In this paper, {{we propose}} {{the use of}} a {{compiler}} optimization technique called software bypassing, suitable for architectures with exposed data paths, as a tool for improving energy efficiency. By allowing the compiler to schedule data transfers directly between function unit outputs and inputs, reading the value of previous computation from the register file becomes unnecessary. This helps reduce unnecessary energy costs of register files. In addition, in the case where all of the uses of produced values can be bypassed directly, the actual write of value to <b>general-purpose</b> <b>register</b> can be discarded during compilation (dead result move elimination), reducing the total number of data transfers on the interconnection network and further contributing to reduction in processor energy consumption.|$|E
25|$|Has 31 <b>general-purpose</b> 64-bit <b>registers.</b>|$|R
50|$|MMIX is a big-endian 64-bit RISC, with 256 64-bit <b>general-purpose</b> <b>registers,</b> 32 64-bit {{special-purpose}} registers, fixed-length 32-bit {{instructions and}} a 64-bit virtual address space. The MMIX instruction set comprises 256 opcodes, {{one of which}} is reserved for future expansion. MMIX uses IEEE 754 floating-point numbers.|$|R
5000|$|A similar {{concept is}} zero extension. On x64, most {{instructions}} that {{write to the}} lower 32 bits of the <b>general-purpose</b> <b>registers</b> will zero {{the upper half of}} the destination register. For example, the instruction [...] will clear the upper 32 bits of the rax register.|$|R
