45|10000|Public
5|$|Another {{method of}} {{constructing}} hash functions with both high quality and practical speed is tabulation hashing. In this method, the hash value for a key {{is computed by}} using each byte of the key as an index into a table of random numbers (with a different table for each byte position). The numbers from those table cells are then combined by a bitwise <b>exclusive</b> <b>or</b> <b>operation.</b> Hash functions constructed this way are only 3-independent. Nevertheless, linear probing using these hash functions takes constant expected time per operation. Both tabulation hashing and standard methods for generating 5-independent hash functions are limited to keys that have a fixed number of bits. To handle strings or other types of variable-length keys, {{it is possible to}} compose a simpler universal hashing technique that maps the keys to intermediate values and a higher quality (5-independent or tabulation) hash function that maps the intermediate values to hash table indices.|$|E
25|$|The {{key idea}} of {{tabulation}} hashing is {{to view a}} key as a vector of t r-bit numbers, use a lookup table filled with random values to compute a hash value {{for each of the}} r-bit numbers representing a given key, and combine these values with the bitwise binary <b>exclusive</b> <b>or</b> <b>operation.</b> The choice of r should be made {{in such a way that}} this table is not too large; e.g., so that it fits into the computer's cache memory.|$|E
2500|$|There are {{arithmetic}} {{operations on}} ordinals {{by virtue of}} the one-to-one correspondence between ordinals and nimbers. [...] Three common operations on nimbers are nimber addition, nimber multiplication, and minimum excludance (mex). [...] Nimber addition is a generalization of the bitwise <b>exclusive</b> <b>or</b> <b>operation</b> on natural numbers. [...] The [...] of a set of ordinals is the smallest ordinal not present in the set.|$|E
25|$|In {{practice}} CRC calculations {{most closely}} resemble long division in binary, {{except that the}} subtractions involved do not borrow from more significant digits, and thus become <b>exclusive</b> <b>or</b> <b>operations.</b>|$|R
25|$|In {{computer}} science, tabulation hashing is {{a method}} for constructing universal families of hash functions by combining table lookup with <b>exclusive</b> <b>or</b> <b>operations.</b> It was first studied {{in the form of}} Zobrist hashing for computer games; later work by Carter and Wegman extended this method to arbitrary fixed-length keys. Generalizations of tabulation hashing have also been developed that can handle variable-length keys such as text strings.|$|R
40|$|In this paper, {{we propose}} {{a simple but}} {{powerful}} on-line availability upgrade mechanism, Supplementary Parity Augmentations (SPA), to address the availability issue for parity-based RAID systems. The basic idea of SPA is to store and update the supplementary parity units on {{one or a few}} newly augmented spare disks for on-line RAID systems in the operational mode, thus achieving the goals of improving the reconstruction performance while tole-rating multiple disk failures and latent sector errors simultaneously. By applying the <b>exclusive</b> <b>OR</b> <b>operations</b> ap...|$|R
2500|$|For the {{sequential}} burst mode, later {{words are}} accessed in increasing address order, wrapping {{back to the}} start of the block when the end is reached. So, for example, for a burst length of four, and a requested column address of five, the words would be accessed in the order 5-6-7-4. If the burst length were eight, the access order would be 5-6-7-0-1-2-3-4. This is done by adding a counter to the column address, and ignoring carries past the burst length. The interleaved burst mode computes the address using an <b>exclusive</b> <b>or</b> <b>operation</b> between the counter and the address. [...] Using the same starting address of five, a four-word burst would return words in the order 5-4-7-6. [...] An eight-word burst would be 5-4-7-6-1-0-3-2. [...] Although more confusing to humans, this can be easier to implement in hardware, and is preferred by Intel for its microprocessors.|$|E
50|$|Since this math {{is done in}} Rijndael's Galois field, the {{addition}} above is actually an <b>exclusive</b> <b>or</b> <b>operation,</b> and multiplication is a complicated operation.|$|E
50|$|Here highbit(S) {{denotes the}} most {{significant}} bit of S; the '*' operator denotes unsigned integer multiplication with lost overflow; '^' is the bitwise <b>exclusive</b> <b>or</b> <b>operation</b> applied to words; and P is a suitable fixed word.|$|E
2500|$|... {{uses the}} same idea of using <b>exclusive</b> <b>or</b> <b>operations</b> to combine random values from a table, with a more {{complicated}} algorithm based on expander graphs for transforming the key bits into table indices, to define hashing schemes that are k-independent for any constant or even logarithmic value of k. However, the number of table lookups needed to compute each hash value using Siegel's variation of tabulation hashing, while constant, is still too large to be practical, {{and the use of}} expanders in Siegel's technique also makes it not fully constructive.|$|R
5000|$|Computation of a cyclic {{redundancy}} check {{is derived from the}} mathematics of polynomial division, modulo two. In practice, it resembles long division of the binary message string, with a fixed number of zeroes appended, by the [...] "generator polynomial" [...] string except that <b>exclusive</b> <b>OR</b> <b>operations</b> replace subtractions. Division of this type is efficiently realised in hardware by a modified shift register, and in software by a series of equivalent algorithms, starting with simple code close to the mathematics and becoming faster (and arguably more obfuscated) through byte-wise parallelism and space-time tradeoffs.|$|R
3000|$|... 2 {{transmit}} to the relay R separately {{over the first}} two phases. After decoding the received signals, the relay R performs bit-level <b>exclusive</b> <b>OR</b> (XOR) <b>operations</b> and then broadcasts the XOR-coded bits to the two source nodes in the third phase.|$|R
5000|$|... (Similarly, a {{universal}} family can be XOR universal if , the value [...] is uniformly distributed in [...] where [...] is the bitwise <b>exclusive</b> <b>or</b> <b>operation.</b> This is only possible if [...] {{is a power}} of two.) ...|$|E
5000|$|There are {{arithmetic}} {{operations on}} ordinals {{by virtue of}} the one-to-one correspondence between ordinals and nimbers. Three common operations on nimbers are nimber addition, nimber multiplication, and minimum excludance (mex). Nimber addition is a generalization of the bitwise <b>exclusive</b> <b>or</b> <b>operation</b> on natural numbers. The [...] of a set of ordinals is the smallest ordinal not present in the set.|$|E
50|$|In a {{synchronous}} {{stream cipher}} {{a stream of}} pseudo-random digits is generated independently of the plaintext and ciphertext messages, and then combined with the plaintext (to encrypt) or the ciphertext (to decrypt). In the most common form, binary digits are used (bits), and the keystream is combined with the plaintext using the <b>exclusive</b> <b>or</b> <b>operation</b> (XOR). This is termed a binary additive stream cipher.|$|E
5000|$|Coins [...] {{are used}} for C-NOT operation, also known as XOR (<b>exclusive</b> <b>or).</b> The <b>operation</b> is applied in the {{following}} manner: , which means that [...] is computed and replaces the old value of , and [...] remain unchanged. More specifically, the following operation is applied: ...|$|R
40|$|In this paper, {{we propose}} an {{architectural}} approach, Supplementary Partial Parity (SPP), to addressing the availability issue of parity encoded RAID systems. SPP exploits free storage space and idle time to generate and update {{a set of}} partial parity units that cover a subset of disks (or data stripe units) during failure-free and idle/lightly-loaded periods, thus supplementing the existing full parity units for improved availability. By applying the <b>exclusive</b> <b>OR</b> <b>operations</b> appropriately among partial parity, full parity and data units, SPP can reconstruct the data on the failed disks with {{a fraction of the}} original overhead that is proportional to the partial parity coverage, thus significantly reducing the overhead of data regeneration...|$|R
500|$|The GNU C library, {{a set of}} {{standard}} routines available for use in computer programming, contains a function—memfrob (...) —which has a similar purpose to ROT13, although it is intended for use with arbitrary binary data. The function operates by combining each byte with the binary pattern 00101010 (42) using the <b>exclusive</b> <b>or</b> (XOR) <b>operation.</b> This effects a simple XOR cipher. Like ROT13, XOR (and therefore memfrob (...) [...] ) is self-reciprocal, and provides a similar, virtually absent, level of security.|$|R
5000|$|The <b>exclusive</b> <b>or</b> <b>operation</b> masks off {{the higher}} order bits {{for which the}} two {{coordinates}} are identical. Since the shuffle interleaves bits from higher order to lower order, identifying the coordinate with the largest most significant bit, identifies the first bit in the shuffle order which differs, and that coordinate {{can be used to}} compare the two points. [...] This is shown in the following Python code: ...|$|E
5000|$|... "Avis Durgan" [...] is the ASCII-string {{on which}} an <b>exclusive</b> <b>OR</b> <b>operation</b> (XOR) was {{performed}} {{in the text of}} the vintage Sierra Entertainment AGI adventure games to keep the gamers from snooping for clues in these games' resource files. In earlier versions of AGI games that booted directly from diskette, the [...] "Avis Durgan" [...] string was also used to encrypt sections of code as a copy-protection scheme.|$|E
5000|$|The cube-{{connected}} {{cycles of}} order n (denoted CCCn) {{can be defined}} as a graph formed from a set of n2n nodes, indexed by pairs of numbers (x, y) where 0 ≤ x < 2n and 0 ≤ y < n. Each such node is connected to three neighbors: (x, (y + 1) mod n), (x, (y &minus; 1) mod n), and (x ⊕ 2y, y), where [...] "⊕" [...] denotes the bitwise <b>exclusive</b> <b>or</b> <b>operation</b> on binary numbers.|$|E
40|$|We perform decoy-state quantum key {{distribution}} between a low-Earth-orbit satellite and multiple ground stations located in Xinglong, Nanshan, and Graz, which establish satellite-to-ground secure keys with ~kHz rate per passage of the satellite Micius over a ground station. The satellite thus establishes a secure key between itself and, say, Xinglong, and another key between itself and, say, Graz. Then, upon request from the ground command, Micius acts as a trusted relay. It performs bitwise <b>exclusive</b> <b>OR</b> <b>operations</b> between the two keys and relays the result {{to one of the}} ground stations. That way, a secret key is created between China and Europe at locations separated by 7600 km on Earth. These keys are then used for intercontinental quantum-secured communication. This was on the one hand the transmission of images in a one-time pad configuration from China to Austria as well as from Austria to China. Also, a videoconference was performed between the Austrian Academy of Sciences and the Chinese Academy of Sciences, which also included a 280 km optical ground connection between Xinglong and Beijing. Our work points towards an efficient solution for an ultralong-distance global quantum network, laying the groundwork for a future quantum internet...|$|R
50|$|The {{process of}} {{generating}} a Kasami sequence is initiated by generating a {{maximum length sequence}} a(n), where n=1..2N-1. Maximum length sequences are periodic sequences with a period of exactly 2N-1. Next, a secondary sequence {{is derived from the}} initial sequence via cyclic decimation sampling as b(n) = a(q*n), where q = 2N/2+1. Modified sequences are then formed by adding a(n) and cyclically time shifted versions of b(n) using modulo-two arithmetic, which is also termed the <b>exclusive</b> <b>or</b> (xor) <b>operation.</b> Computing modified sequences from all 2N/2 unique time shifts of b(n) forms the Kasami set of code sequences.|$|R
5000|$|Although {{tabulation}} hashing {{as described}} above ("simple tabulation hashing") is only 3-independent, variations of this method {{can be used to}} obtain hash functions with much higher degrees of independence. [...] uses the same idea of using <b>exclusive</b> <b>or</b> <b>operations</b> to combine random values from a table, with a more complicated algorithm based on expander graphs for transforming the key bits into table indices, to define hashing schemes that are k-independent for any constant or even logarithmic value of k. However, the number of table lookups needed to compute each hash value using Siegel's variation of tabulation hashing, while constant, is still too large to be practical, and the use of expanders in Siegel's technique also makes it not fully constructive. provides a scheme based on tabulation hashing that reaches high degrees of independence more quickly, in a more constructive way.He observes that using one round of simple tabulation hashing to expand the input keys to six times their original length, and then a second round of simple tabulation hashing on the expanded keys, results in a hashing scheme whose independence number is exponential in the parameter r, the number of bits per block in the partition of the keys into blocks.|$|R
5000|$|A bitwise XOR {{takes two}} bit {{patterns}} of equal length and performs the logical <b>exclusive</b> <b>OR</b> <b>operation</b> on {{each pair of}} corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same. For example: ...|$|E
5000|$|In {{computer}} science, Luby transform codes (LT codes) are {{the first}} class of practical fountain codes that are near-optimal erasure correcting codes. They were invented by Michael Luby in 1998 and published in 2002. Like some other fountain codes, LT codes depend on sparse bipartite graphs to trade reception overhead for encoding and decoding speed. The distinguishing characteristic of LT codes is in employing a particularly simple algorithm based on the <b>exclusive</b> <b>or</b> <b>operation</b> (...) to encode and decode the message.|$|E
50|$|Note {{that any}} {{published}} (or otherwise accessible) random data table is unsuitable for cryptographic purposes since {{the accessibility of}} the numbers makes them effectively predictable, and hence their effect on a cryptosystem is also predictable. By way of contrast, genuinely random numbers that are only accessible to the intended encoder and decoder allow literally unbreakable encryption of a similar or lesser amount of meaningful data (using a simple <b>exclusive</b> <b>OR</b> <b>operation)</b> in a method known as the one-time pad, which has often insurmountable problems that are barriers to implementing this method correctly.|$|E
40|$|In this correspondence, an {{efficient}} {{implementation of the}} D-homomorphism for generating de Bruijn sequences is presented. The number of <b>exclusive</b> [...] <b>or</b> <b>operations</b> required to generate the next bit for de Bruijn sequences of order from a de Bruijn function of order k is shown to be approximately k(2 W (n 0 k) 0 1), where W (r) {{is the number of}} one's in the binary representation of r: therefore, the number of required operations can be reduced to k if the de Bruijn function is selected appropriately. As an application, the stream cipher is indicated. Index Terms [...] -De Bruijn sequences, D-homomorphism, nonlinear feedback shift register sequences...|$|R
40|$|In this paper, {{we propose}} an {{architectural}} approach, Supplementary Partial Parity (SPP), to addressing the availability issue of parity encoded RAID systems. SPP exploits free storage space and idle time to generate and update {{a set of}} partial parity units that cover a subset of disks (or data stripe units) during failure-free and idle/lightly-loaded periods, thus supplementing the existing full parity units for improved availability. By applying the <b>exclusive</b> <b>OR</b> <b>operations</b> appropriately among partial parity, full parity and data units, SPP can reconstruct the data on the failed disks with {{a fraction of the}} original overhead that is proportional to the partial parity coverage, thus significantly reducing the overhead of data regeneration, especially under heavy workload. By providing redundant parity coverage, SPP can potentially tolerate more than one disk failure with much better flexibility, thus significantly improving the system’s reliability and availability. Due to its supplementary nature, SPP provides a more efficient and flexible redundancy protection mechanism than the conventional full parity approach. SPP offers multiple optional levels depending on partial parity coverage and performance/cost targets. According to the actual workload and the available re-source, the SPP approach can be adaptively and dynamically activated, deactivated and adjusted while the original RAID system continues to serve user requests on-line. We conduct extensive trace-driven experiments to evaluate the performance of the SPP approach. The experiments results demonstrate that SPP significantly improves the reconstruction time and user response time simultaneously...|$|R
40|$|In this study, we {{consider}} {{the design of a}} network coded non-orthogonal interleave-division multiple-access (IDMA) user cooperation system. Based on <b>eXclusive</b> <b>OR</b> (XOR) <b>operation</b> at relays, the source messages are re-transmitted forward to the destination simultaneously. At destination, a network coding aided iterative Multi-User Detection (MUD) scheme is proposed. And, a multi-user soft network decoding algorithm is developed. Over Nakagami-m fading channels, we examine the BER performance of the proposed network coded cooperative (NetCC) IDMA scheme in various scenarios. Simulation results confirm that NetCC IDMA scheme can provide significant BER improvement compared to the existing IDMA scheme. In addition, based on the EXtrinsic Information Transfer (EXIT) chart technique, the convergence behavior of NetCC IDMA scheme is studied. Simulations also reveal that the proposed scheme can support more users than existing IDMA scheme...|$|R
5000|$|Cover-coding is a {{technique}} for obscuring the data that is transmitted over an insecure link, to reduce the risks of snooping. An example of cover-coding {{would be for the}} sender to perform a bitwise XOR (exclusive OR) of the original data with a password or random number which is known to both sender and receiver. The resulting cover-coded data is then transmitted from sender to the receiver, who uncovers the original data by performing a further bitwise XOR (<b>exclusive</b> <b>OR)</b> <b>operation</b> on the received data using the same password or random number.|$|E
50|$|Tabulation hashing is a {{technique}} for mapping keys to hash values by partitioning each key into bytes, using each byte as the index into a table of random numbers (with a different table for each byte position), and combining {{the results of these}} table lookups by a bitwise <b>exclusive</b> <b>or</b> <b>operation.</b> Thus, it requires more randomness in its initialization than the polynomial method, but avoids possibly-slow multiplication operations. It is 3-independent but not 4-independent. Variations of tabulation hashing can achieve higher degrees of independence by performing table lookups based on overlapping combinations of bits from the input key, or by applying simple tabulation hashing iteratively.|$|E
5000|$|So far {{the article}} has covered {{how to turn}} bits on and turn bits off, but not both at once. Sometimes it does not really matter what the value is, {{but it must be}} made the {{opposite}} of what it currently is. This can be achieved using the [...] (<b>exclusive</b> <b>or)</b> <b>operation.</b> [...] returns [...] if and only if an odd number of bits are [...] Therefore, if two corresponding bits are , the result will be a , but if only one of them is , the result will be [...] Therefore inversion of the values of bits is done by ing them with a [...] If the original bit was , it returns [...] If the original bit was [...] it returns [...] Also note that [...] masking is bit-safe, meaning that it will not affect unmasked bits because , just like an [...]|$|E
40|$|Recently, a novel image {{encryption}} scheme {{based on}} improved hyperchaotic sequences was proposed. A pseudo-random number sequence, generated by a hyper-chaos system, is used to determine two involved encryption functions, bitwise <b>exclusive</b> <b>or</b> (XOR) <b>operation</b> and modulo addition. It was reported that the scheme can be broken with some pairs of chosen plain-images and the corresponding cipherimages. This paper re-evaluates {{the security of the}} encryption scheme and finds that the encryption scheme can be broken with only one known plain-image. The performance of the known-plaintext attack, in terms of success probability and computation load, become even much better when two known plain-images are available. In addition, security defects on insensitivity of the encryption result with respect to changes of secret key and plain-image are also reported. Comment: 6 page...|$|R
40|$|Secret sharing schemes {{are very}} {{important}} techniques for the key management. To provide more efficient and flexible alternatives for the applications of secret sharing, this paper presents a dynamic multi-secret sharing scheme. A significant characteristic of the proposed scheme is that each participant has to keep only one master secret share {{which can be used}} to reconstruct different group secrets according to the number of threshold values. By applying successive one-way hash functions and the <b>exclusive</b> <b>OR</b> (XOR) <b>operation,</b> the proposed scheme is secure against the notorious conspiracy attack even though the pseudo secret shares are compromised. Further, when one of the group secrets is updated with a new one, each participant’s master secret share is still unchanged, i. e., these master secret shares are truly multi-use instead of one-time-use...|$|R
25|$|Differential {{cryptanalysis}} {{is usually}} a chosen plaintext attack, meaning that the attacker {{must be able to}} obtain ciphertexts for some set of plaintexts of their choosing. There are, however, extensions that would allow a known plaintext or even a ciphertext-only attack. The basic method uses pairs of plaintext related by a constant difference; difference can be defined in several ways, but the <b>eXclusive</b> <b>OR</b> (XOR) <b>operation</b> is usual. The attacker then computes the differences of the corresponding ciphertexts, hoping to detect statistical patterns in their distribution. The resulting pair of differences is called a differential. Their statistical properties depend upon the nature of the S-boxes used for encryption, so the attacker analyses differentials (ΔX, ΔY), where ΔY = S(X ⊕ ΔX) ⊕ S(X) (and ⊕ denotes <b>exclusive</b> <b>or)</b> for each such S-box S. In the basic attack, one particular ciphertext difference is expected to be especially frequent; in this way, the cipher can be distinguished from random. More sophisticated variations allow the key to be recovered faster than exhaustive search.|$|R
