12|46|Public
5000|$|The [...] class {{supports}} {{random access}} {{reading and writing}} of files. The class uses a <b>file</b> <b>pointer</b> that represents a byte-offset within the file for the next read or write operation. The <b>file</b> <b>pointer</b> is moved implicitly by reading or writing and explicitly by calling the [...] or [...] methods. The current position of the <b>file</b> <b>pointer</b> is returned by the [...] method.|$|E
5000|$|... fopen uses string flags such as , , [...] and [...] {{and returns}} a <b>file</b> <b>pointer</b> used with fgets, fputs and fclose.|$|E
50|$|Images {{stored on}} the server are being encrypted, {{and it is}} not {{possible}} to mass-decrypt images by an administrator. Unless presented with URL, that contains <b>file</b> <b>pointer</b> and decryption key, the file itself cannot be decrypted.|$|E
50|$|Workflow (or {{concrete}} workflow) containing information both on {{the graph}} structure and on the configuration parameters (input <b>files</b> <b>pointers,</b> output <b>files</b> <b>pointers,</b> executable code and target DCI of workflow nodes).|$|R
50|$|At File system level, ISO 9660 or Universal Disk Format (UDF), no <b>file</b> <b>pointers</b> to {{the label}} area are present.|$|R
50|$|In the C {{programming}} language, {{the standard}} input, output, and error streams {{are attached to}} the existing Unix file descriptors 0, 1 and 2 respectively. In a POSIX environment the <unistd.h> definitions STDIN_FILENO, STDOUT_FILENO or STDERR_FILENO should be used instead rather than magic numbers. <b>File</b> <b>pointers</b> stdin, stdout, and stderr are also provided.|$|R
50|$|The same file may {{be opened}} {{simultaneously}} by several processes, and {{even by the}} same process (resulting in several file descriptors for the same file) depending on the file organization and filesystem. Operations on the descriptors such as moving the <b>file</b> <b>pointer</b> or closing it are independent (they do not affect other descriptors for the same file). Operations on the file (like a write) {{can be seen by}} operations on the other descriptors (a posterior read can read the written data).|$|E
50|$|On the server, eyeOS uses XML {{files to}} store information. This makes it simple for a user {{to set up}} on the server, as it {{requires}} zero configuration other than the account information for the first user, making it simple to deploy. To avoid bottlenecks that flat files present, each user's information and settings are stored in different files, preventing resource starvation from occurring; Though this in turn may create issues in high volume user environments due to host operating system open <b>file</b> <b>pointer</b> limits.|$|E
40|$|While the I/O {{functions}} {{described in}} the MPI standard included shared <b>file</b> <b>pointer</b> support from the beginning, the performance and portability of these functions have been subpar at best. ROMIO [1], which provides the MPI-IO functionality for most MPI libraries, to this day uses a separate file to manage the shared <b>file</b> <b>pointer.</b> This file provides the shared location that holds the cur-rent value of the shared <b>file</b> <b>pointer.</b> Unfortunately, each access to the shared <b>file</b> <b>pointer</b> involves file lock management and updates to the file contents. Further-more, support for shared file pointers is not universally available because few file systems support native shared file pointers [5] and a few file systems do not support file locks [3]. Application developers rarely use shared file pointers, even though many ap-plications can benefit from this file I/O capability. These applications are typi-cally loosely coupled and rarely exhibit application-wide synchronization. Exam-ples include application tracing toolkits [8, 4] and many-task computing applica...|$|E
40|$|Increasingly, file {{systems for}} multiprocessors are {{designed}} with parallel access to multiple disks, to keep I/O from becoming a serious bottleneck for parallel applications. Although file system software can transparently provide high-performance access to parallel disks, a new file system interface is needed to facilitate parallel access to a file from a parallel application. We describe the difficulties faced when using the conventional (Unix-like) interface in parallel applications, and then outline ways to extend the conventional interface to provide convenient access to the file for parallel programs, while retaining the traditional interface for programs that have no need for explicitly parallel file access. Our interface includes a single naming scheme, a multiopen operation, local and global <b>file</b> <b>pointers,</b> mapped <b>file</b> <b>pointers,</b> logical records, multifiles, and logical coercion for backward compatibility. 1 Introduction Multiprocessors have increased in computational power to [...] ...|$|R
5000|$|Since {{a single}} {{entry in the}} grid <b>file</b> {{contains}} <b>pointers</b> to all records indexed by the specified keys: ...|$|R
5000|$|The middle tier of the gUSE {{architecture}} {{contains the}} high-level gUSE services. The Workﬂow Storage stores {{every piece of}} information {{that is needed to}} define a workflow (graph structure description, input <b>files</b> <b>pointers,</b> output <b>files</b> <b>pointers,</b> executable code, and target DCI of workflow nodes) except the input files of the workflow. The local input files and the local output files created during workflow execution are stored in the File Storage. The Workﬂow Interpreter is responsible for the execution of workflows, which are stored in the Workﬂow Sto-rage. the Information System holds information for users about workflows running and job status. Users of WS-PGRADE gateways work in isolated workspace, i.e., they see only their own workflows. In order to enable collaboration among the isolated users, the Application Repository stores the WS-PGRADE workflows in one of their five possible stages. (Physically all the five categories are stored as zip files.) The five categories of stored workflows are as follows, and the collaboration among the gateway users is possible via all these categories: ...|$|R
40|$|The ROMIO {{implementation}} of the MPI-IO standard provides a portable infrastructure for use {{on top of a}} variety of underlying storage targets. These targets vary widely in their capabilities, and in some cases additional effort is needed within ROMIO to support all MPI-IO semantics. Two aspects of the interface that can be problematic to implement are MPI-IO atomic mode and the shared <b>file</b> <b>pointer</b> access routines. Atomic mode requires enforcing strict consistency semantics, and shared <b>file</b> <b>pointer</b> routines require communication and coordination in order to atomically update a shared resource. For some file systems, native locks may be used to implement these features, but not all file systems have lock support. In this work, we describe algorithms for implementing efficient mutex lock...|$|E
40|$|One {{feature that}} the MPI-IO {{interface}} provides is shared file pointers. Ashared <b>file</b> <b>pointer</b> is an offset that is updated by any process accessing the file in this mode. This feature organizes accesses to a file {{on behalf of}} the applicationin such a way that subsequent accesses do not overwrite previous ones. This is particularly useful for logging purposes: it eliminates the need for the applicationto coordinate access to a log file...|$|E
40|$|Abstract. The ROMIO {{implementation}} of the MPI-IO standard provides a portable infrastructure for use on top of any number of different underlying storage targets. These targets vary widely in their capabilities, {{and in some cases}} additional effort is needed within ROMIO to support all MPI-IO semantics. The MPI- 2 standard defines a class of file access routines that use a shared <b>file</b> <b>pointer.</b> These routines require communication internal to the MPI-IO implementation in order to allow processes to atomically update this shared value. We discuss a technique that leverages MPI- 2 one-sided operations and can be used to implement this concept without requiring any features from the underlying file system. We then demonstrate through a simulation that our algorithm adds reasonable overhead for independent accesses and very small overhead for collective accesses. ...|$|E
25|$|Because of the {{particular}} characteristics of flash memory, it is best used with either a controller to perform wear leveling and error correction or specifically designed flash file systems, which spread writes over the media {{and deal with the}} long erase times of NORflash blocks. The basic concept behind flash file systems is the following: when the flash store is to be updated, the file system will write a new copy of the changed data to a fresh block, remap the <b>file</b> <b>pointers,</b> then erase the old block later when it has time.|$|R
5000|$|In July 2014 <b>Pointer</b> <b>filed</b> {{for divorce}} from Bowen, citing [...] "irreconcilable differences." ...|$|R
5000|$|Twelve {{pointers}} {{that directly}} point to {{blocks of the}} <b>file's</b> data (direct <b>pointers)</b> ...|$|R
40|$|Unlike {{previous}} LANDSAT computer compatible tape (CCT) formats, {{the standard}} format of CCT's now includes a comprehensive field location and data description information superstructure composed of four records. The volume descriptor record, the text record, and the <b>file</b> <b>pointer</b> record reside in a volume directory file, which generally describes the data configuration and provides pointers to each data file. The file descriptor record for each data file describes the data structure within the file and provides pointers to certain fields within the file. These superstructure records primarily supply {{information about the}} data on the CCT as opposed to carrying the data themselves. The EROS Data Center's LANDSAT CCT version 1. 0 product is presented which conforms to the concepts of the standard format as much as is possible with existing EDC systems...|$|E
40|$|High-level {{programming}} languages, including C* and High-Performance Fortran, do {{not currently}} have constructs for parallel i/o. Parallel i/o, if done at all, is performed via vendor specific facilities. We present a brief design for extensions to the data-parallel programming model to support parallel i/o. Our planned extensions {{are based on}} the notion of a data-parallel file, which encapsulates a set of i/o streams in a single abstraction. Language constructs supporting this extended programming model will be developed and implemented in the UNH C* compiler. 1 Data-Parallel I/O Primitives Our planned extensions {{are based on the}} notion of a data-parallel file, which encapsulates a set of i/o streams in a single abstraction. Each virtual processor provided by the underlying data-parallel programming language has its own <b>file</b> <b>pointer.</b> Each input operation reads a set of values and each output operation writes a set of values. A file on a storage device will consist of both data and cont [...] ...|$|E
40|$|A SAS {{index is}} a search file {{associated}} with a data file. Given a key, the file is searched and, if the key is found, its record ID is returned and used to retrieve the data file record. For many practical tasks, this works sufficiently fast. But fast is never fast enough- SAS indexes are disk-resident and so leave much room for acceleration. SAS automaintains its indexes, which is splendid. But oftentimes the trade-off is programmatic rigidity. When either overweighs the pain to program, the indexing scheme suddenly appears to virtually lend itself to custom crafting. Being no longer tied to a particular search algorithm or storage medium, you can let your programming fancy fly, {{the power of the}} SAS language being at your disposal. The pain disappears. The disk-resident index file yields to a memory-based look-up returning a <b>file</b> <b>pointer.</b> B-trees are defenestrated in favor of search algorithms chosen for speed and/or to fit a particular key structure. This is a how-to paper about “external ” indexing. Whys and whens are discussed. Coding details are furnished in all gore...|$|E
50|$|Primitive {{data types}} in ICI include integers, reals, strings, <b>files,</b> safe <b>pointers,</b> and regular expressions. Aggregate data types are arrays, sets, and {{associative}} tables. Sets can be heterogeneous, nested, {{and support the}} usual set operations: union, intersection, etc.|$|R
40|$|Thanks to MPI [9], writing {{portable}} {{message passing}} parallel programs {{is almost a}} reality. One of the remaining problems is file I/ 0. Although parallel file systems support similar interfaces, {{the lack of a}} standard makes developing a truly portable program impossible. Further, {{the closest thing to a}} standard, the UNIX file interface, is ill-suited to parallel computing. Working together, IBM Research and NASA Ames have drafted MPI-I 0, a proposal to address the portable parallel I/ 0 problem. In a nutshell, this proposal is based on the idea that I/ 0 can be modeled as message passing: writing to a file is like sending a message, and reading from a file is like receiving a message. MPI-IO intends to leverage the relatively wide acceptance of the MPI interface in order to create a similar I/ 0 interface. The above approach can be materialized in different ways. The current proposal represents the result of extensive discussions (and arguments), but is by no means finished. Many changes can be expected as additional participants join the effort to define an interface for portable I/ 0. This document is organized as follows. The remainder of this section includes a discussion of some issues that have shaped the style of the interface. Section 2 presents an overview of MPI-IO as it is currently defined. It specifies what the interface currently supports and states what would need to be added to the current proposal to make the interface more complete and robust. The next seven sections contain the interface definition itself. Section 3 presents definitions and conventions. Section 4 contains functions for file control, most notably open. Section 5 includes functions for independent I/O, both blocking and nonblocking. Section 6 includes functions for collective I/O, both blocking and nonblocking. Section 7 presents functions to support system-maintained <b>file</b> <b>pointers,</b> and shared <b>file</b> <b>pointers.</b> Section 8 presents constructors that can be used to define useful filetypes (the role of filetypes is explained in Section 2 below). Section 9 presents how the error handling mechanism of MPI is supported by the MPI-IO interface. All this is followed by a set of appendices, which contain information about issues that have not been totally resolved yet, and about design considerations. The reader can find there the motivation behind some of our design choices. More information on this would definitely be welcome and will be included in a further release of this document. The first appendix contains a description of MPI-I 0 's 'hints' structure which is used when opening a file. Appendix B is a discussion of various issues in the support for <b>file</b> <b>pointers.</b> Appendix C explains what we mean in talking about atomic access. Appendix D provides detailed examples of filetype constructors, and Appendix E contains a collection of arguments for and against various design decisions...|$|R
5000|$|PHP: PHP {{originally}} implemented serialization {{through the}} built-in [...] and [...] functions. PHP can serialize {{any of its}} data types except resources (<b>file</b> <b>pointers,</b> sockets, etc.). The built-in [...] function is often dangerous when used on completely untrusted data. For objects, there are two [...] "magic methods" [...] that can be implemented within a class — [...] and [...] — that are called from within [...] and , respectively, that can clean up and restore an object. For example, it may be desirable to close a database connection on serialization and restore the connection on deserialization; this functionality would be handled in these two magic methods. They also permit the object to pick which properties are serialized. Since PHP 5.1, there is an object-oriented serialization mechanism for objects, the [...] interface.|$|R
40|$|This paper {{describes}} how the multimedia mark-up languages SMIL and HTML+TIME were used to publish three types of online presentations of multi-modal artwork by mental health service users. This technology {{has the potential to}} bring the work of artists working with mental health services to a wider audience, at low cost, with fuller participation and also offers a number of new creative possibilities. The presentations included artwork, biography and audio transcripts in static files with the aim of reducing the info-exclusion of multimedia service user artists. The potential of server-side scripting integrating MySQL database contents dynamically into SMIL templates was investigated for its capacity to generate random or topical art displays 'on the fly'. In two prototype server-side applications, PHP scripts used user input to activate multimedia <b>file</b> <b>pointers</b> contained in the database. The feasibility of server-side scripting in terms of browser/player support and other issues is discussed...|$|R
5000|$|As {{mentioned}} in Section 3.2 above, a directory entry contains only {{a name for}} the associated <b>file</b> and a <b>pointer</b> to the <b>file</b> itself. This <b>pointer</b> is an integer called the i-number (for index number) of the file. When the file is accessed, its i-number is used as an index into a system table (the i-list) stored in a known part of the device on which the directory resides. The entry found thereby (the file's i-node) contains the description of the file:... The UNIX Time-Sharing System, The Bell System Technical Journal, 1978 ...|$|R
40|$|We {{describe}} {{the design and}} use of monadic I/O in Haskell 1. 3, the latest revision of the lazy functional programming language Haskell. Haskell 1. 3 standardises the monadic I/O mechanisms now available in many Haskell systems. The new facilities allow fairly sophisticated text-based application programs to be written portably in Haskell. The standard provides implementors with a flexible framework for extending Haskell to incorporate new language features. Apart {{from the use of}} monads, the main advances over the previous standard are: character I/O based on handles (analogous to ANSI C <b>file</b> <b>pointers),</b> an error handling mechanism, terminal interrupt handling and a POSIX interface. Apart from a tutorial description of the new facilities we include a worked example: a derived monad for combinator parsing. 1 Introduction Haskell 1. 3 improves on previous versions of Haskell [12] by adopting an I/O mechanism based on monads [19]. This paper explains the structure of this monadic I/O mechanis [...] ...|$|R
40|$|We {{discuss the}} issues {{involved}} in implementing MPI-IO portably on multiple machines and file systems and also achieving high performance. One way to implement MPI-IO portably is to implement {{it on top of}} the basic Unix I/O functions (open, lseek, read, write, and close), which are themselves portable. We argue that this approach has limitations in both functionality and performance. We instead advocate an implementation approach that combines a large portion of portable code and a small portion of code that is optimized separately for different machines and file systems. We have used such an approach to develop a high-performance, portable MPI-IO implementation, called ROMIO. In addition to basic I/O functionality, we consider the issues of supporting other MPI-IO features, such as 64 -bit file sizes, noncontiguous accesses, collective I/O, asynchronous I/O, consistency and atomicity semantics, user-supplied hints, shared <b>file</b> <b>pointers,</b> portable data representation, and file preallocation. We describe how we implemented each of these features on various machines and file systems. The machines we consider are the HP Exemplar...|$|R
50|$|The {{base level}} MIX format has four files: a {{metadata}} file, an index file, a status file, and some set of message data files. The metadata file contains base-level data {{applicable to the}} entire mailbox; i.e., the UID validity, last assigned UID, and list of keywords. The index <b>file</b> contains <b>pointers</b> to each unexpunged message in the message data files, along with flags, size, and IMAP internaldate data. The status file contains per-message flags and keywords.|$|R
40|$|This {{report is}} a {{technical}} and user manual {{for a computer}} program generating automated form documents. This automated form document generation provides the reader with a technical description of the programs, files, and procedures required to design and process form documents, such as found in the legal profession. Each section details the structure {{of one of the}} four programs that make up the total system. The system consists of four major programs, Text Program, Text Parameter Program, Special Format Program, and Execution Program, and seven files, Text Reference Point File, Text File, Text Parameter <b>File,</b> Special Format <b>Pointer</b> <b>File,</b> Special Format Parameter File, Error File, and Input File. A user???s manual that describes the features {{and the use of the}} program is contained in the appendix...|$|R
5000|$|Because {{the class}} file {{contains}} variable-sized items {{and does not}} also contain embedded <b>file</b> offsets (or <b>pointers),</b> it is typically parsed sequentially, from the first byte toward the end. At the lowest level the file format is {{described in terms of}} a few fundamental data types: ...|$|R
5000|$|The most {{significant}} legal fact about inline linking, relative to copyright law considerations, {{is that the}} inline linker does not place {{a copy of the}} image file on its own Internet server. Rather, the inline linker places a pointer on its Internet server that points to the server on which the proprietor of the image has placed the image <b>file.</b> This <b>pointer</b> causes a user's browser to jump to the proprietor's server and fetch the image file to the user's computer. US courts have considered this a decisive fact in copyright analysis. Thus, in Perfect 10, Inc. v. Amazon.com, Inc., the United States Court of Appeals for the Ninth Circuit explained why inline linking did not violate US copyright law: ...|$|R
25|$|The C++ {{standard}} {{consists of}} two parts: the core language and the standard library. C++ programmers expect the latter on every major implementation of C++; it includes vectors, lists, maps, algorithms (find, for_each, binary_search, random_shuffle, etc.), sets, queues, stacks, arrays, tuples, input/output facilities (iostream, for reading from and writing to the console and <b>files),</b> smart <b>pointers</b> for automatic memory management, regular expression support, multi-threading library, atomics support (allowing a variable to be read or written to by at most one thread at a time without any external synchronisation), time utilities (measurement, getting current time, etc.), a system for converting error reporting that doesn't use C++ exceptions into C++ exceptions, a random number generator and a slightly {{modified version of the}} C standard library (to make it comply with the C++ type system).|$|R
40|$|The {{subject of}} this thesis is {{the design of a}} FORTRAN {{compiler}} for the PDP- 11 / 34 minicomputer owned by the Dept. of Mathematical Sciences of Ball State University, Muncie, Indiana. At the time that this project was undertaken, only the BASIC and ASSEMBLY languages were available on this machine. The problem consisted of writing a two-pass processer. The function of the first pass was to recognize FORTRAN statements, analyze them syntactically and semantically, build symbol tables, and construct an output <b>file</b> containing <b>pointers</b> to the symbol table, flags, and operators. The second pass used the output file of the first part and the symbol tables to build ASSEMBLY language instructions equivalent to the FORTRAN instructions in function. Ball State UniversityMuncie, IN 47306 Thesis (M. S.) [...] Ball State University...|$|R
50|$|The C++ {{standard}} {{consists of}} two parts: the core language and the standard library. C++ programmers expect the latter on every major implementation of C++; it includes vectors, lists, maps, algorithms (find, for_each, binary_search, random_shuffle, etc.), sets, queues, stacks, arrays, tuples, input/output facilities (iostream, for reading from and writing to the console and <b>files),</b> smart <b>pointers</b> for automatic memory management, regular expression support, multi-threading library, atomics support (allowing a variable to be read or written to by at most one thread at a time without any external synchronisation), time utilities (measurement, getting current time, etc.), a system for converting error reporting that doesn't use C++ exceptions into C++ exceptions, a random number generator and a slightly {{modified version of the}} C standard library (to make it comply with the C++ type system).|$|R
50|$|In {{computer}} science, a smart pointer is {{an abstract}} data type that simulates a pointer while providing added features, such as automatic memory management or bounds checking. Such features are intended to reduce bugs caused by the misuse of pointers, while retaining efficiency. Smart pointers typically {{keep track of the}} memory they point to, and may also be used to manage other resources, such as network connections and <b>file</b> handles. Smart <b>pointers</b> originated in the programming language C++.|$|R
