203|1788|Public
5000|$|An {{intuitive}} {{explanation for}} this question is: if [...] represents an <b>error</b> <b>state,</b> then any state containing {{it should also be}} regarded as an <b>error</b> <b>state.</b> If a well-quasi-order can be found that models this [...] "containment" [...] of states and which also fulfills the requirement of monotonicity with respect to the transition relation, then this question can be answered.|$|E
5000|$|Instead of one minimal <b>error</b> <b>state</b> , one {{typically}} considers {{an upward}} closed set [...] of error states.|$|E
5000|$|Active Error Flag: six {{dominant}} bits - Transmitted by a node detecting {{an error}} {{on the network}} that is in <b>error</b> <b>state</b> [...] "error active".|$|E
40|$|Embedded Navigation Filter Automatic Designer (ENFAD) is a {{computer}} program being developed to automate the most difficult tasks in designing embedded software to implement a Kalman filter in a navigation system. The most difficult tasks are selection of <b>error</b> <b>states</b> of the filter and tuning of filter parameters, which are timeconsuming trial-and-error tasks that require expertise and rarely yield optimum results. An optimum selection of <b>error</b> <b>states</b> and filter parameters depends on navigation-sensor and vehicle characteristics, and on filter processing time. ENFAD would include a simulation module that would incorporate all possible <b>error</b> <b>states</b> {{with respect to a}} given set of vehicle and sensor characteristics. The first of two iterative optimization loops would vary the selection of <b>error</b> <b>states</b> until the best filter performance was achieved in Monte Carlo simulations. For a fixed selection of <b>error</b> <b>states,</b> the second loop would vary the filter parameter values until an optimal performance value was obtained. Design constraints would be satisfied in the optimization loops. Users would supply vehicle and sensor test data that would be used to refine digital models in ENFAD. Filter processing time and filter accuracy would be computed by ENFAD...|$|R
40|$|We {{provide a}} full {{characterization}} of computational <b>error</b> <b>states</b> for information systems. The {{class of errors}} considered is general enough to include human rational processes, logical reasoning, scientific progress and data processing in some functional programming languages. The aim is to reach a full taxonomy of <b>error</b> <b>states</b> by analysing the recovery and processing of data. We conclude by presenting machine-readable checking and resolve algorithms...|$|R
40|$|Abstract. Directed model {{checking}} is {{a well-established}} technique {{to tackle the}} state explosion problem when {{the aim is to}} find <b>error</b> <b>states</b> in large systems. In this approach, the state space traversal is guided through a function that estimates the distance to nearest <b>error</b> <b>states.</b> States with lower estimates are preferably expanded during the search. Obviously, the challenge is to develop distance functions that are efficiently computable {{on the one hand and}} as informative as possible on the other hand. In this paper, we introduce the causal graph structure to the context of directed model checking. Based on causal graph analysis, we first adapt a distance estimation function from AI planning to directed model checking. Furthermore, we investigate an abstraction that is guaranteed to preserve <b>error</b> <b>states.</b> The experimental evaluation shows the practical potential of these techniques. ...|$|R
50|$|The server returns a 422 (Unprocessable Entity) {{response}} when the server understands the PATCH document but {{is unable to}} modify the requested resource either because it causes the resource to become invalid or it results in some other <b>error</b> <b>state.</b>|$|E
5000|$|Abobo {{drops into}} the hole and becomes [...] "Mega Mabobo", {{proceeding}} through a stage patterned after the Mega Man games. The stage boss of Mega Mabobo is a robot double of Abobo called Mechabobo; upon being defeated, Mechabobo enters an <b>error</b> <b>state</b> and prints out a message indicating that Aboboy was taken through the Jungle.|$|E
50|$|Although {{the term}} split-brain {{typically}} {{refers to an}} <b>error</b> <b>state,</b> Split-brain DNS (or Split-horizon DNS) is sometimes used to describe a deliberate situation where internal and external DNS services for a corporate network are not communicating, so that separate DNS name spaces are to be administrated for external computers and for internal ones. This requires a double administration, {{and if there is}} domain overlap in the computer names, there is a risk that the same fully qualified domain name (FQDN), may ambiguously occur in both name spaces referring to different computer IP addresses.|$|E
50|$|A {{trigger element}} {{controls}} the states (both regular and <b>error</b> <b>states)</b> and checks whether an action element {{has to be}} triggered.|$|R
40|$|Abstractâ€”The {{ability to}} recover from errors is {{necessary}} for robots to cope with unexpected situations in a dynamic environment. Efficient error recovery should allow the robot to utilise existing knowledge of the task and learn new error recovery strategies from observation. This paper proposes an automatic error recovery procedure that allows the robot to handle both known and unknown <b>error</b> <b>states</b> using a Petri net representation of the task. For known <b>error</b> <b>states,</b> the robot can directly adjust the sequencing of actions using the Petri net representation to complete the task, while for unknown <b>error</b> <b>states,</b> the robot {{can learn how to}} perform error recovery from a human demonstrator by extending the existing Petri net. The proposed method is verified on a real robot performing a block stacking task. I...|$|R
5000|$|Retail {{customers}} report {{slow and}} indifferent service on bugs. Examples include a faulty <b>error</b> message <b>stating</b> current subscriptions had expired. Users received an <b>error</b> <b>stating</b> [...] "Your virus protection cannot be updated." [...] This error occurred after an update to {{the software and}} refused to allow daily updates. Though the bug was reported in 2004, it was not corrected for the 2005 or 2006 versions.|$|R
50|$|Microsoft {{retained}} {{rights to}} OS/2 technologies, including the HPFS filesystem, after they ceased collaboration with IBM. Since Windows NT 3.1 {{was designed for}} more rigorous (enterprise-class) use than previous versions of Windows, it included support for HPFS (and NTFS) giving it a larger storage capacity than the FAT12 and FAT16 filesystems. However, since HPFS lacks a journal, any recovery after an unexpected shutdown or other <b>error</b> <b>state</b> takes progressively longer as the filesystem grows. A utility such as CHKDSK would need to scan each entry in the filesystem to ensure no errors are present, a problem which is vastly reduced on NTFS where the journal is simply replayed.|$|E
5000|$|This formula {{says that}} any {{call to the}} next (...) method must be {{immediately}} preceded by a call to hasNext (...) method that returns true. The property here is parametric in the Iterator i. Conceptually, this means {{that there will be}} one copy of the monitor for each possible Iterator in a test program, although runtime verification systems need not implement their parametric monitors this way. The monitor for this property would be set to trigger a handler when the formula is violated (equivalently when the finite state machine enters the <b>error</b> <b>state),</b> which will occur when either next (...) is called without first calling hasNext (...) , or when hasNext (...) is called before next (...) , but returned false.|$|E
5000|$|The Java Iterator {{interface}} {{requires that}} the hasNext (...) method be called and return true before the next (...) method is called. If thisdoes not occur, it is very possible that a user will iterate [...] "off the end of" [...] a Collection. The figure to the right shows a finite state machine that defines a possible monitor for checking and enforcing this property with runtime verification. From the unknown state, it is always an error to call the next (...) method because such an operation could be unsafe. If hasNext (...) is called and returns true, {{it is safe to}} call next (...) , so the monitor enters the more state. If, however, the hasNext (...) method returns false, there are no more elements, and the monitor enters the none state. In the more and none states, calling the hasNext (...) method provides no new information. It is safe to call the next (...) method from the more state, but it becomes unknown if more elements exist, so the monitor reenters the initial unknown state. Finally, calling the next (...) method from the none state results in entering the <b>error</b> <b>state.</b> What follows is a representation of this property using parametric past time linear temporal logic.|$|E
30|$|In the {{closed-loop}} system, we will {{design the}} control input u_i(t) {{to make sure}} that the <b>error</b> <b>states</b> converge to the origin and all signals remain bounded. To reach this goal, the following assumptions are needed.|$|R
50|$|The film credits {{contains}} a grave <b>error</b> <b>stating</b> that the opera aria Di Provenza il Mar heard {{early in the}} movie corresponds to the opera Aida from Verdi, when in fact {{it belongs to the}} opera La Traviata by Verdi.|$|R
40|$|A {{concurrent}} learning (CL) -based parameter estimator {{is developed}} {{to identify the}} unknown parameters in a linearly parameterized uncertain control-affine nonlinear system. Unlike state-of-the-art CL techniques that assume knowledge of the state-derivative or rely on numerical smoothing, CL is implemented using a dynamic state-derivative estimator. A novel purging algorithm is introduced to discard possibly erroneous data recorded during the transient phase for concurrent learning. Since purging results in a discontinuous parameter adaptation law, the closed-loop error system is modeled as a switched system. Asymptotic convergence of the <b>error</b> <b>states</b> to the origin is established under a persistent excitation condition, and the <b>error</b> <b>states</b> are shown to be ultimately bounded under a finite excitation condition. Simulation results are provided to demonstrate {{the effectiveness of the}} developed parameter estimator...|$|R
40|$|This paper {{presents}} a Kalman filter using a seven-component attitude state vector comprising the angular momentum components in an inertial reference frame, the angular momentum {{components in the}} body frame, and a rotation angle. The relatively slow variation of these parameters makes this parameterization advantageous for spinning spacecraft attitude estimation. The filter accounts for the constraint that {{the magnitude of the}} angular momentum vector is the same in the inertial and body frames by employing a reduced six-component <b>error</b> <b>state.</b> Four variants of the filter, defined by different choices for the reduced <b>error</b> <b>state,</b> are tested against a quaternion-based filter using simulated data for the THEMIS mission. Three of these variants choose three of the components of the <b>error</b> <b>state</b> to be the infinitesimal attitude error angles, facilitating the computation of measurement sensitivity matrices and causing the usual 3 x 3 attitude covariance matrix to be a submatrix of the 6 x 6 covariance of the <b>error</b> <b>state.</b> These variants differ in their choice for the other three components of the <b>error</b> <b>state.</b> The variant employing the infinitesimal attitude error angles and the angular momentum components in an inertial reference frame as the <b>error</b> <b>state</b> shows the best combination of robustness and efficiency in the simulations. Attitude estimation results using THEMIS flight data are also presented...|$|E
3000|$|... p 3 {{property}} for both light driver (l 3) and point driver (rdh 2) timed automata states that <b>error</b> <b>state</b> (error) in timed automata is always reached when clock (x) value in these timed automata is six or greater. Conversely p 4 property states that <b>error</b> <b>state</b> is never reached when the clock value {{is less than}} six.|$|E
30|$|FigureÂ  1 and FigureÂ  2 {{show the}} {{simulation}} results. For the case Ïƒ= 2, FigureÂ  1 {{shows that the}} state trajectories of (x(t),xÌ‚(t)) and the <b>error</b> <b>state</b> e(t) converge to zero smoothly. FigureÂ  2 shows that the state trajectories of (x(t),xÌ‚(t)) and the <b>error</b> <b>state</b> e(t) do not converge to an equilibrium point in case of Ïƒ= 5. Hence, the effect of leakage delay in the dynamical system cannot be neglected.|$|E
40|$|The {{pneumatic}} {{system is a}} domain of engineering which uses pressurized air or gas, This master thesis analysis the {{pneumatic system}} according to a given facility sketch and pneumatic control system drawing, and discuss the advantages and disadvantages, in addition designs the possible changesto this system in nowadays for innovation purposes, Also explains possible <b>error</b> <b>states</b> at the facility and their management. The pneumatic system is a domain of engineering which uses pressurized air or gas, This master thesis analysis the pneumatic system according to a given facility sketch and pneumatic control system drawing, and discuss the advantages and disadvantages, in addition designs the possible changesto this system in nowadays for innovation purposes, Also explains possible <b>error</b> <b>states</b> at the facility and their management...|$|R
40|$|Abstract. De Alfaro and Henzinger {{advocated}} interface automata {{to model}} and study behavioural types, which describe communication patterns of systems while abstracting e. g. from data. They {{come with a}} specific parallel composition: if, in some state, one component tries to make an output, which the other one cannot receive, the state is regarded as an <b>error.</b> <b>Error</b> <b>states</b> are removed along with some states leading to them. As refinement relation an alternating simulation is introduced. In this report, we study to what degree this refinement relation is justified by the desires to avoid <b>error</b> <b>states</b> and to support modular refinement. For this, we leave the <b>error</b> <b>states</b> in place and mark them as such instead of removing them in the composition. Our Error-I-O-Transition systems are slightly more general than Interface automata, which are restricted to input determinism. Our basic requirement is: an implementation must be error free, if the specification is. For two different notions of error freeness, we determine the coarsest precongruences contained in the respective basic refinement relations. We characterize these best refinement relations meeting our desirables with trace sets. Thus our precongruences are less discriminating than simulation-based ones. Along the way we point out an error in an early paper by de Alfaro and Henzinger. ...|$|R
40|$|ABSTRACT: New {{users of}} high-function {{application}} systems can become frustrated and {{confused by the}} errors they make {{in the early stages}} of learning. A training interface for a commercial word processor was designed to make typical and troublesome <b>error</b> <b>states</b> "unreachable," thus eliminating the sources of some new-user learning problems. Creating a training environment from the basic function of the system itself afforded substantially faster learning coupled with better learning achievement and better performance on a comprehension post-test. A control group spent almost a quarter of their time recovering from the <b>error</b> <b>states</b> that the training interface blocked off. We speculate on how this training strategy might be refined, 1. and more generally, on how function should be organized in a user interface. Empirical characterizations of computer novices learning to use application systems paint a dreary picture of side tracks and error tangles from which recovery, or even diagnosis, is difficult (e. g., [6]). In this paper, we show that a "training wheels " interface [...] designed to block typical side tracks and <b>error</b> <b>states</b> [...] can facilitate the learning process for new users. THE TRAINING WHEELS INTERFACE We studied a stand-alone, commercial word processing system and observed new users, people who had never used a computer before, trying to learn the system's 2...|$|R
40|$|A {{well known}} {{property}} of the Beveridge Nelson decomposition is that the innovations in the permanent and transitory components are perfectly correlated. We use a single source of <b>error</b> <b>state</b> space model to exploit this property and perform a Beveridge Nelson decomposition. The single source of <b>error</b> <b>state</b> space approach to the decomposition is computationally simple, and in contrast to other methods of performing the Beveridge-Nelson decomposition, it incorporates the direct estimation of the long-run multiplier. Beveridge Nelson decomposition; Long-run multiplier; Single source of error; State-space models. ...|$|E
40|$|I {{would like}} to thank my {{supervisors}} Niels KjÃ¸lstad and Ole Ravn for their help and moral support when things looked the darkest. Their knowledge and calm attitudes helped me find the way through the maze of the project. A great thanks also goes to Martin Jensen for great support, critical ques-tions and calm attitude through several projects through the years. And last, but not least, the staff and fellow students at the automation section for making the Institute a pleasant place to study. 2 In this project an <b>Error</b> <b>State</b> model for use in an <b>Error</b> <b>State</b> Kalman Filter is developed. The scope of this filter is to estimate the error sources present in the navigational system of differentially driven mobile robots and thus improve the performance by correcting them. In comparison to the classic way of implementing the Kalman Filter in navigation system, the <b>Error</b> <b>State</b> Filter is unable show en par performance...|$|E
30|$|DR- 9 Must {{be able to}} be {{inserted}} or removed from the host PC at any time without causing either the host or the TED to enter an <b>error</b> <b>state.</b>|$|E
40|$|De Alfaro and Henzinger {{advocated}} interface automata {{to model}} and study behavioural types, which describe communication patterns of systems while abstracting e. g. from data. They {{come with a}} specific parallel composition: if, in some state, one component tries to make an output, which the other one cannot receive, the state is regarded as an <b>error.</b> <b>Error</b> <b>states</b> are removed along with some states leading to them. As refinement relation an alternating simulation is introduced. In this report, we study to what degree this refinement relation is justified by the desires to avoid <b>error</b> <b>states</b> and to support modular refinement. For this, we leave the <b>error</b> <b>states</b> in place and mark them as such instead of removing them in the composition. Our Error-I-O-Transition systems are slightly more general than Interface automata, which are restricted to input determinism. Our basic requirement is: an implementation must be error free, if the specification is. For two different notions of error freeness, we determine the coarsest precongruences contained in the respective basic refinement relations. We characterize these best refinement relations meeting our desirables with trace sets. Thus our precongruences are less discriminating than simulation-based ones. Along the way we point out an error in an early paper by de Alfaro and Henzinger...|$|R
50|$|RT-components {{also have}} state, so the RT-components behaves as state machines. The states that RT-components can have are CREATED, INACTIVE, ACTIVE, and <b>ERROR.</b> <b>States</b> and {{behaviors}} {{are controlled by}} the execution-context. If developers {{want to change the}} behavior of their RT-components, the execution-context can be replaced at runtime.|$|R
5000|$|In the 2000 United States Census, the {{community}} of Lisco was mistakenly called [...] "Cisco" [...] by the Census Bureau. The surrounding census county division (CCD) was still called Lisco. By 2005, the Census Bureau had realized its <b>error,</b> <b>stating</b> that [...] "Lisco census designated place (CDP) is erroneously shown...with the name 'Cisco.'" ...|$|R
40|$|National audienceGiven an LR(1) automaton, {{what are}} the states in which an error can be detected? For each such " <b>error</b> <b>state</b> ", what is a minimal input {{sentence}} that causes an error in this state? We propose an algorithm that answers these questions. Such an algorithm allows building a collection of pairs of an erroneous input sentence and a diagnostic message, ensuring that this collection covers every <b>error</b> <b>state,</b> and maintaining this property as the grammar evolves. We report on an application of this technique to the CompCert ISO C 99 parser, and discuss its strengths and limitations...|$|E
40|$|Finding {{quantitative}} {{aspects of}} quantum phenomena which cannot {{be explained by}} any classical model has foundational importance for understanding the boundary between classical and quantum theory. It also has practical significance for identifying information processing tasks for which those phenomena provide a quantum advantage. Using the framework of generalized noncontextuality as our notion of classicality, we find one such nonclassical feature within the phenomenology of quantum minimum <b>error</b> <b>state</b> discrimination. Namely, we identify quantitative limits on the success probability for minimum <b>error</b> <b>state</b> discrimination in any experiment described by a noncontextual ontological model. These constraints constitute noncontextuality inequalities that are violated by quantum theory, and this violation implies a quantum advantage for state discrimination relative to noncontextual models. Furthermore, our noncontextuality inequalities are robust to noise and are operationally formulated, so that any experimental violation of the inequalities is a witness of contextuality, independently {{of the validity of}} quantum theory. Along the way, we introduce new methods for analyzing noncontextuality scenarios, and demonstrate a tight connection between our minimum <b>error</b> <b>state</b> discrimination scenario and a Bell scenario. Comment: 18 pages, 9 figure...|$|E
3000|$|A Kalman filter {{can only}} {{contribute}} to a limited extend to the total accuracy of the pose estimates. The estimate can only be made more accurate when the filter model is accurate enough; that is, that the acceleration/angular speed is predictable, and that the inertia sensors are accurate enough. A bias in the sensorsâ€”for instance caused by a systematic estimation error or an unknown delay {{in the time of}} measurementâ€”will prevent the filter from giving a more accurate result than the camera alone. We minimized the errors introduced by the Kalman filter by using robust methods to represent the orientation and time update of the orientation, and decreased the nonlinearity be using a nonadditive <b>error</b> <b>state</b> Kalman filter in which the <b>error</b> <b>state</b> is combined with the real state using a nonlinear function (see the transfer of the orientation error in Figure 8). We used Quaternions [45] for a stable differentiable representation. To make the orientation model more linear, we used an indirect Kalman filter setup where the error states are estimated instead of the actual state. Due to this choice the error-state update is independent of the real state. Effectively we created an extended kalman Filter for the <b>error</b> <b>state.</b> If the <b>error</b> <b>state</b> is kept at zero rotation by transferring the error-state estimate to the real state estimate immediately after each measurement update, the linearization process for the Extended Kalman Filter [46] becomes very simple and accurate. In addition, we convert all orientation measurements to error-quaternions: [...]...|$|E
40|$|This {{document}} defines additional Layer 2 Tunneling Protocol Version 3 (L 2 TPv 3) bit {{values to}} be used within the "Circuit Status " Attribute Value Pair (AVP) to communicate finer-grained <b>error</b> <b>states</b> for Attachment Circuits (ACs) and pseudowires (PWs). It also generalizes the Active bit and deprecates {{the use of the}} New bit in the Circui...|$|R
50|$|The {{investigation}} report into the crash {{was released on}} December 13, 2010. It blamed pilot <b>error,</b> <b>stating</b> that the pilot's overconfidence in executing an aggressive right-turn maneuver led to a low-altitude stall and subsequent crash, despite the warnings correctly provided by the aircraft's stall-warning system, to which neither the pilot nor any other crew member responded effectively.|$|R
40|$|Abstractâ€”Neuromuscular {{electrical}} stimulation (NMES) is a prescribed treatment for various neuromuscular disorders, where an electrical stimulus is provided to elicit a muscle contraction. Barriers {{to the development}} of NMES controllers exist because the muscle response to an {{electrical stimulation}} is nonlinear and the muscle model is uncertain. Efforts in this paper focus on the development of an adaptive inverse optimal NMES controller. The controller yields desired limb trajectory tracking while simulta-neously minimizing a cost functional that is positive in the <b>error</b> <b>states</b> and stimulation input. The development of this framework allows tradeoffs to be made between tracking performance and control effort by putting different penalties on <b>error</b> <b>states</b> and control input, depending on the clinical goal or functional task. The controller is examined through a Lyapunov-based analysis. Experiments on able-bodied individuals are provided to demon-strate the performance of the developed controller. Index Termsâ€”Functional electrical stimulation (FES), inverse optimal control, Lyapunov stability, neural network (NN), neuro-muscular electrical stimulation, nonlinear system control...|$|R
