37|152|Public
25|$|Create a {{superposition}} of states. This {{can be done}} {{by applying}} Hadamard gates to all qubits in the <b>input</b> <b>register.</b> Another approach would be to use the quantum Fourier transform (see below).|$|E
5000|$|... (Input): The {{contents}} of <b>input</b> <b>register</b> specified by address {{are placed in}} Accumulator A. The <b>input</b> <b>register</b> is either set to zero or remains unchanged (depending upon the selected register).|$|E
5000|$|... <b>input</b> <b>register</b> numbers {{start with}} 3 and span from 30001 to 39999, ...|$|E
40|$|AbstractOur {{computational}} {{model is a}} random access machine with n read only <b>input</b> <b>registers</b> each containing clogn bits of information and a read and write memory. We measure the time {{by the number of}} accesses to the <b>input</b> <b>registers.</b> We show that for all k there is an ε> 0 so that if n is sufficiently large then the elements distinctness problem cannot be solved in time kn with εn bits of read and write memory; that is, there is no machine with this value of the parameters which decides whether there are two different <b>input</b> <b>registers</b> whose contents are identical...|$|R
5000|$|... #Subtitle level 3: Function code 4 (read <b>input</b> <b>registers)</b> and {{function}} code 3 (read holding registers) ...|$|R
5000|$|By comparison, the Sun Microsystems SPARC {{architecture}} provides simultaneous visibility {{into four}} sets of eight registers each. Three sets of eight registers each are [...] "windowed". Eight registers (i0 through i7) form the <b>input</b> <b>registers</b> to the current procedure level. Eight registers (L0 through L7) are local to the current procedure level, and eight registers (o0 through o7) are the outputs from the current procedure level {{to the next level}} called. When a procedure is called, the register window shifts by sixteen registers, hiding the old <b>input</b> <b>registers</b> and old local registers and making the old output <b>registers</b> the new <b>input</b> registers.The common <b>registers</b> (old output <b>registers</b> and new <b>input</b> <b>registers)</b> are used for parameter passing. Finally, eight registers (g0 through g7) are globally visible to all procedure levels.|$|R
5000|$|... #Subtitle level 2: Coil, {{discrete}} input, <b>input</b> <b>register,</b> {{holding register}} numbers and addresses ...|$|E
5000|$|The double dabble {{algorithm}} {{might look}} like this when implemented in C. Notice that this implementation is designed to convert an [...] "input register" [...] of any width, by taking an array as its parameter and returning a dynamically allocated string. Also notice that this implementation does not store an explicit copy of the <b>input</b> <b>register</b> in its scratch space, as {{the description of the}} algorithm did; copying the <b>input</b> <b>register</b> into the scratch space was just a pedagogical device.|$|E
5000|$|Create a {{superposition}} of states. This {{can be done}} {{by applying}} Hadamard gates to all qubits in the <b>input</b> <b>register.</b> Another approach would be to use the quantum Fourier transform (see below).|$|E
50|$|Some {{conventions}} govern how {{access to}} Modbus entities (coils, discrete <b>inputs,</b> <b>input</b> <b>registers,</b> holding registers) are referenced.|$|R
40|$|Our {{computational}} {{model is a}} random access machine with n read only <b>input</b> <b>registers</b> each containing c log n bits of information and a read and write memory. We measure the time {{by the number of}} accesses to the <b>input</b> <b>registers.</b> We show that for all k there is an epsilon > 0 so that if n is sufficiently large then the elements distinctness problem cannot be solved in time kn with epsilon n bits of read and write memory, that is, there is no machine with this values of the parameters which decides whether there are two different <b>input</b> <b>registers</b> whose contents are identical. We also show that there is a simple decision problem that can be solved in constant time (actually in two steps) using non-deterministic computation, while there is no deterministic linear time algorithm with epsilon n log n bits read and write memory which solves the problem. More precisely if we allow kn time for some fixed constant k, then there is an epsilon > 0 so that the problem cannot be solved with epsilon n log n bits of read and write memory if n is sufficiently large. The decision problem is the following: "Find two different <b>input</b> <b>registers,</b> so that the Hamming distance of their contents is at most c log n"...|$|R
40|$|In two-party quantum {{communication}} complexity, Alice and Bob receive some classical inputs and wish to compute some function {{that depends on}} both these inputs, while minimizing the communication. This model has found numerous applications {{in many areas of}} computer science. One question that has received a lot of attention recently is whether it is possible to perform such protocols in a private way. We show that defining privacy for quantum protocols is not so straightforward and it depends on whether we assume that the registers where Alice and Bob receive their classical inputs are in fact classical registers (and hence unentangled {{with the rest of the}} protocol) or quantum registers (and hence can be entangled with the rest of the protocol or the environment). We provide new quantum protocols for the Inner Product function and for Private Information Retrieval, and show that the privacy assuming classical <b>input</b> <b>registers</b> can be exponentially smaller than the privacy assuming quantum <b>input</b> <b>registers.</b> We also argue that the right notion of privacy of a communication protocol is the one assuming classical <b>input</b> <b>registers,</b> since otherwise the players can deviate considerably from the protocol...|$|R
5000|$|PINx: <b>Input</b> <b>{{register}},</b> {{used to read}} {{an input}} signal. On some devices, this register {{can be used for}} pin toggling: writing a logic one to a PINx bit toggles the corresponding bit in PORTx, irrespective of the setting of the DDRx bit.|$|E
5000|$|The {{contents}} x = x1, ..., xm ofthe classical <b>input</b> <b>register</b> {{are used}} to initialize the qubitregister in some way. Ideally, this would {{be done with the}} computational basisstate where there are r-m underbraced zeroed inputs. Nevertheless,this perfect initialization is completely unrealistic. Let us assumetherefore that the initialization is a mixed state given by some density operator S which is near the idealized input in some appropriate metric, e.g.|$|E
50|$|The W65C21S PIA is {{organized}} into two independent sections {{referred to as}} the A Side and the B Side. Each section consists of Control Register (CRA, CRB), Data Direction Register (DDRA, DDRB), Output Register (ORA, ORB), Interrupt Status Control (ISCA, ISCB) and the buffers necessary to drive the Peripheral Interface buses. Data Bus Buffers (DBB) interface data from the two sections to the data bus, while the Date <b>Input</b> <b>Register</b> (DIR) interfaces data from the DBB to the PIA registers. Chip Select and RWB control circuitry interface to the processor bus control lines.|$|E
50|$|A further {{method of}} {{filtering}} disturbances is multiple read of <b>input</b> <b>registers.</b> The read-in values are then checked for consistency. If the values are consistent, {{they can be}} considered valid. A definition of a value range and/or the calculation of a mean value can improve the results for some applications.|$|R
40|$|DAC) {{especially}} {{developed to}} be used together with the NJM 3771, Precision Stepper Motor driver in micro-stepping applications. The NJU 39610 has a set of <b>input</b> <b>registers</b> connected to an 8 -bit data port for easy interfacing directly to a microprocessor. The NJU 39610 is well suited for highspeed micro-stepping application...|$|R
40|$|System {{of square}} loop {{magnetic}} cores associated with code <b>input</b> <b>registers</b> {{to react to}} input code patterns by reference {{to a group of}} control cores in such a manner that errors are canceled and patterns containing errors are accepted for amplification and processing. This technique improves reception capabilities in PCM telemetry systems...|$|R
50|$|It {{is assumed}} that the <b>input</b> <b>{{register}},</b> A and the output register B occupy the first k and last k spins along the chain, and that all spins along the chain are prepared {{to be in the}} spin down state in the z direction. The parties then use all k of their spin states to encode/decode a single qubit. The motivation for this method is that if all k spins were allowed to be used, we would have a k-qubit channel, which would be too complex to be completely analyzed. Clearly, a more effective channel would make use of all k spins, but by using this inefficient method, it is possible to look at the resulting maps analytically.|$|E
5000|$|...- /SBA: Program Details --===================================================---- Snippet: 16 bit Binary to BCD {{converter}}-- Version: 0.1-- Date: 2016/12/28-- Author: Miguel A. Risco-Castillo-- Description: 16 bit to BCD converter using [...] "Double Dabble" [...] algorithm.-- Before {{call you}} must fill [...] "bin_in" [...] {{with the appropriate}} value, after called,-- the snippet put into the variable [...] "bcd_out" [...] the BCD result of the conversion.-- Put the snippet in the routines section of the user program.-- /SBA: End Program Details ----------------------------------------------------- /SBA: User Registers and Constants --======================================-- variable bin_in : unsigned(15 downto 0); -- 16 bit <b>input</b> <b>register</b> variable bcd_out : unsigned(19 downto 0); -- 20 bit output register-- /SBA: End User Registers and Constants ---------------------------------------- /SBA: User Program --======================================================---- /L:Bin2BCD=> bcd_out := (others=>'0'); if bin_in=0 then SBARet; end if; -- if zero then return=> bcd_out(2 downto 0) := bin_in(15 downto 13); -- shl 3 bin_in := bin_in(12 downto 0) & [...] "000";=> for j in 0 to 12 loop for i in 0 to 3 loop -- for nibble 0 to 3, last nibble do not need adjust if bcd_out(3+4*i downto 4*i)>4 then -- is nibble > 4? bcd_out(3+4*i downto 4*i):=bcd_out(3+4*i downto 4*i)+3; -- add 3 to nibble end if; end loop; bcd_out := bcd_out(18 downto 0) & bin_in(15); --shl bin_in := bin_in(14 downto 0) & '0'; end loop; SBARet; -- return to main program-- /SBA: End User Program ------------------------------------------------------ ...|$|E
40|$|The {{standard}} method of Quantum State Tomography (QST) {{relies on the}} measurement {{of a set of}} noncommuting observables, realized in a series of independent experiments. Ancilla Assisted QST (AAQST) proposed by Nieuwenhuizen and co-workers (Phys. Rev. Lett., 92, 120402 (2004)) greatly reduces the number of independent measurements by exploiting an ancilla register in a known initial state. In suitable conditions AAQST allows mapping out density matrix of an <b>input</b> <b>register</b> in a single experiment. Here we describe methods for explicit construction of AAQST experiments in multi-qubit registers. We also report nuclear magnetic resonance studies on AAQST of (i) a two- qubit <b>input</b> <b>register</b> using a one-qubit ancilla in an isotropic liquid-state system and (ii) a three-qubit <b>input</b> <b>register</b> using a two-qubit ancilla register in a partially oriented system. The experimental results confirm the effectiveness of AAQST in such many-qubit registers. Comment: 7 pages, 6 figure...|$|E
5000|$|On the {{assumption}} that each instruction bundle reads its <b>input</b> <b>registers</b> before writing its output registers, this code is correct. At {{the start of the}} replicated loop body, [...] holds the value of [...] from the previous replicated loop iteration. Since [...] has been incremented by 2 in the meantime, this is actually the value of [...] in this replicated loop iteration.|$|R
40|$|A circuit {{for high}} {{resolution}} decoding of multi-anode microchannel array detectors consisting of <b>input</b> <b>registers</b> accepting transient <b>inputs</b> from the anode array; anode encoding logic circuits {{connected to the}} input registers; midpoint pipeline registers connected to the anode encoding logic circuits; and pixel decoding logic circuits connected to the midpoint pipeline registers is described. A high resolution algorithm circuit operates in parallel with the pixel decoding logic circuit and computes a high resolution least significant bit to enhance the multianode microchannel array detector's spatial resolution by halving the pixel size and doubling the number of pixels in each axis of the anode array. A multiplexer {{is connected to the}} pixel decoding logic circuit and allows a user selectable pixel address output according to the actual multi-anode microchannel array detector anode array size. An output register concatenates the high resolution least significant bit onto the standard ten bit pixel address location to provide an eleven bit pixel address, and also stores the full eleven bit pixel address. A timing and control state machine is connected to the <b>input</b> <b>registers,</b> the anode encoding logic circuits, and the output register for managing the overall operation of the circuit...|$|R
30|$|Several 32 -bit {{asynchronous}} RCAs {{were constructed}} in a semi-custom design fashion at the gate-level by utilizing different strong-indication, weak-indication, and early output asynchronous full adders separately. The structural {{integrity of the}} different asynchronous full adders and RCAs was preserved during physical realization (i.e., technology mapping) {{to pave the way}} for legitimate comparison after synthesis. They were implemented using the elements of the 32 / 28  nm digital cell library (Synopsys 2012). The 2 -input C-element was alone designed manually using the AO 222 gate by incorporating feedback and was made available to realize the various asynchronous full adders and RCAs, registers, and the completion detector. Logic decomposition of higher fan-in C-element(s), where necessary, was performed according to the safe quasi-delay-insensitive logic decomposition procedure put forward in (Balasubramanian and Mastorakis 2011). The asynchronous system implemented, as shown in Fig.  1, comprises the RCA for the function block, the <b>input</b> <b>registers,</b> and the completion detection circuit. The <b>input</b> <b>registers</b> and the completion detector of various RCAs are identical, and only their asynchronous function blocks (i.e., RCAs) differ in their physical composition. Hence the differences between the simulation results obtained for the various asynchronous RCAs can be directly attributed to the physical differences between their constituent full adders.|$|R
3000|$|... is fed {{back and}} latched in the <b>input</b> <b>register</b> {{for the use}} of next degrouping cycle. This {{approach}} achieves the fixed throughput with one clock cycle per sample.|$|E
30|$|As {{long as the}} {{connections}} between elements (I/O pin to register) remain short enough and with small length dispersion {{to stay within the}} clock sampling time window, it is possible to implement a standard synchronous pipeline architecture. The pins transmission directly to an <b>input</b> <b>register</b> helps to maximize the timing performance and allows faster setup times.|$|E
40|$|The MAX 5352 /MAX 5353 {{combine a}} low-power, voltage-output, 12 -bit digital-to-analog {{converter}} (DAC) and a precision output amplifier in an 8 -pin µMAX or DIP pack-age. The MAX 5352 operates {{from a single}} + 5 V supply, and the MAX 5353 operates from a single + 3. 3 V supply. Both devices draw less than 280 µA of supply current. The output amplifier’s inverting input is available to the user, allowing specific gain configurations, remote sensing, and high output current capability. This makes the MAX 5352 /MAX 5353 ideal {{for a wide range}} of appli-cations, including industrial process control. Other fea-tures include a software shutdown and power-on reset. The serial interface is compatible with SPI™/QSPI™ and Microwire™. The DAC has a double-buffered input, organized as an <b>input</b> <b>register</b> followed by a DAC regis-ter. A 16 -bit serial word loads data into the input regis-ter. The DAC register can be updated independently or simultaneously with the <b>input</b> <b>register.</b> All logic inputs are TTL/CMOS-logic compatible and buffered with Schmitt triggers to allow direct interfacing to opto-couplers...|$|E
3000|$|The 3.8 [*]Gbps {{throughput}} {{required by}} the WirelessHD [...] "high-rate PHY" [...] places the FFT and decoding blocks under the most computational strain relative to the other system components. The FFT computation must be completed in about 200 [*]ns. For a WirelessHD modem with 512 subcarriers, this means that 2304 complex multiplications, 4608 complex additions and the ancillary operations such as loading the data into the <b>input</b> <b>registers</b> of the FFT processor must be completed in that time. This is a demanding deadline. In [5], a review of FFT execution times was carried out. The fastest quoted FFT speed was 5.5 [*] [...]...|$|R
50|$|VPPERM is {{a single}} {{instruction}} that combines the SSSE3 instruction PALIGNR and PSHUFB and adds more to both. Some compare it the Altivec instruction VPERM. It takes three <b>registers</b> as <b>input,</b> the first two are source registers and the third the selector register. Each byte in the selector selects one of the bytes {{in one of the}} two <b>input</b> <b>registers</b> for the output. The selector can also apply effects on the selected bytes such as setting it to 0, reverse the bit order, and repeating most signicating bit. All of the effects or the input can in addition be inverted.|$|R
5000|$|Ports 0-2 {{can produce}} {{interrupts}} when <b>inputs</b> change. Additional <b>registers</b> configure this ability: ...|$|R
40|$|Let N be a (large) {{positive}} integer, and let b < N be {{a positive}} integer relatively prime to N whose order modulo N is large. Let QC be a quantum computer whose <b>input</b> <b>register</b> has the size specified in Shor's original description of his order-finding algorithm. We show that when Shor's algorithm is implemented on QC, then the probability of obtaining a divisor {{of the order of}} b modulo N exceeds 70 percent. Typically, this probability has been estimated to be bounded below by 40 percent...|$|E
40|$|Fitness {{distributions}} (landscapes) {{of programs}} tend to a limit {{as they get}} bigger. Markov minorization gives upper bounds ((15. 3 + 2. 30 m) / log I) {{on the length of}} program run on random or average computing devices. I is the size of the instruction set and m size of output register. Almost all programs are constants. Convergence is exponential with 90 % of programs of length 1. 6 n 2 yielding constants (n = size <b>input</b> <b>register</b> and size of memory = N). This is supported by experiment...|$|E
40|$|Abstract: Let N be a {{positive}} integer, let b < N be {{a positive}} integer relatively prime to N, and let r be the order of b modulo N. Finally, let QC be a quantum computer whose <b>input</b> <b>register</b> has the size specified in Shor’s original description of his order-finding algorithm. We prove that when Shor’s algorithm is implemented on QC, then the probability P of obtaining a (nontrivial) divisor of r exceeds. 7 whenever N ≥ 2 11 and r ≥ 40, and we establish that. 7736 is an asymptotic lower bound for P. When N is not a power of an odd prime, Gerjuoy has shown that P exceeds 90 percent for N and r sufficiently large. We give easily checked conditions on N and r for this 90 percent threshold to hold, and we establish an asymptotic lower bound for P of 2 Si(4 π) /π ≈. 9499 in this situation. More generally, for any nonnegative integer q, we show that when QC(q) is a quantum computer whose <b>input</b> <b>register</b> has q more qubits than does QC, and Shor’s algorithm is run on QC(q), then an asymptotic lower bound on P is 2 Si(2 q+ 2 π) /π (if N is not a power of an odd prime). Our arguments are elementary and our lower bounds on P are carefully justified. ...|$|E
5000|$|C bus: {{connected}} to {{the output of the}} shifter and to the <b>input</b> of the <b>registers.</b>|$|R
5000|$|User <b>registers,</b> <b>inputs</b> {{their phone}} number, and the {{provider}} sends them an SMS with a PIN ...|$|R
40|$|A fast {{multiple}} <b>input</b> signature <b>register</b> (MISR) computation algorithm for signature simulation is proposed. Based on {{the linear}} compaction algorithm the modularity property {{of a single}} <b>input</b> signature <b>register</b> (SISR), and the sparsity of the error-domain input, some new accelerating schemes - partial input look-up tables and reverse zero-checking policy - are developed to boost the signature computation speed. Mathematical analysis and simulation results show that this algorithm has {{an order of magnitude}} speedup without extra memory requirement compared with the linear compaction algorithm. Though originally derived for SISR, this algorithm is applicable to MISR by a simple conversion procedure or a bit-adjusting scheme with little effort. Consequently, a very fast MISR signature simulation can be achieved. link_to_subscribed_fulltex...|$|R
