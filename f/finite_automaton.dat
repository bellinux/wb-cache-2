1353|524|Public
25|$|Every regular grammar {{corresponds}} {{directly to}} a nondeterministic <b>finite</b> <b>automaton,</b> so {{we know that this}} is a regular language.|$|E
25|$|NFAs {{have been}} {{generalized}} in multiple ways, e.g., nondeterministic <b>finite</b> <b>automaton</b> with ε-moves, finite state transducers, pushdown automata, alternating automata, ω-automata, and probabilistic automata.|$|E
25|$|An {{example of}} an {{accepting}} state appears in Fig.5: a deterministic <b>finite</b> <b>automaton</b> (DFA) that detects whether the binary input string contains an even number of 0s.|$|E
5000|$|State models {{including}} Turing machine, pushdown <b>automaton,</b> <b>finite</b> state <b>automaton,</b> and PRAM ...|$|R
40|$|The thesis {{explains}} several algorithms for pattern matching. Algorithms work in both {{software and}} hardware. A {{part of the}} thesis is dedicated to extensions of <b>finite</b> <b>automatons.</b> The second part explains hashing and introduces concept of perfect hashing and CRC. The thesis also includes a suggestion of possible structure of a pattern matching unit based on deterministic <b>finite</b> <b>automatons</b> in FPGA. Experiments for determining the structure and size of resulting automatons were done in this thesis...|$|R
40|$|We {{study the}} pseudorandomness of {{automatic}} sequences {{in terms of}} well-distribution and correlation measure of order 2. We detect non-random behavior which can be derived either from the functional equations satisfied by their generating functions or from their generating <b>finite</b> <b>automatons,</b> respectively...|$|R
25|$|Since NFAs are {{equivalent}} to nondeterministic <b>finite</b> <b>automaton</b> with ε-moves (NFA-ε), the above closures are proved using closure properties of NFA-ε. The above closure properties imply that NFAs only recognize regular languages.|$|E
25|$|A Deterministic <b>finite</b> <b>automaton</b> (DFA) {{can be seen}} as {{a special}} kind of NFA, in which for each state and alphabet, the {{transition}} function has exactly one state. Thus, it is clear that every formal language that can be recognized by a DFA can be recognized by a NFA.|$|E
25|$|A nondeterministic <b>finite</b> <b>automaton</b> (NFA), or nondeterministic finite state machine, {{does not}} need to obey these restrictions. In particular, every DFA is also an NFA. Sometimes the term NFA is used in a {{narrower}} sense, referring to a NDFA that is not a DFA, but not in this article.|$|E
40|$|There the {{necessary}} and sufficient conditions of two-check-ability of functional elements and <b>finite</b> <b>automatons</b> have been obtained. Number of mathematical simulators of contrallable combination and sequence circuits has been constructed {{on the basis}} of these conditionsAvailable from VNTIC / VNTIC - Scientific & Technical Information Centre of RussiaSIGLERURussian Federatio...|$|R
5000|$|... #Subtitle level 3: DAFSAs (deterministic acyclic <b>finite</b> state <b>automaton)</b> ...|$|R
40|$|FASTUS is a (slightly permuted) {{acronym for}} <b>Finite</b> State <b>Automaton</b> Text Understanding System. It {{is a system}} for extracting {{information}} from free text in English, and potentially other languages as well, for entry into a database, and potentially for other applications. It works essentially as a cascaded, nondeterministic <b>finite</b> state <b>automaton...</b>|$|R
25|$|In {{the example}} shown, keys {{are listed in}} the nodes and values below them. Each {{complete}} English word has an arbitrary integer value associated with it. A trie {{can be seen as a}} tree-shaped deterministic <b>finite</b> <b>automaton.</b> Each finite language is generated by a trie automaton, and each trie can be compressed into a deterministic acyclic finite state automaton.|$|E
25|$|Nondeterministic <b>finite</b> <b>automaton</b> with ε-moves (NFA-ε) is {{a further}} {{generalization}} to NFA. This automaton replaces the transition function with the one that allows the empty string ε as a possible input. The transitions without consuming an input symbol are called ε-transitions. In the state diagrams, they are usually labeled with the Greek letter ε. ε-transitions provide a convenient way of modeling the systems whose current states are not precisely known.|$|E
25|$|For every NFA a {{deterministic}} <b>finite</b> <b>automaton</b> (DFA) can {{be found}} that accepts the same language. Therefore, {{it is possible to}} convert an existing NFA into a DFA for the purpose of implementing a (perhaps) simpler machine. This can be performed using the powerset construction, which may lead to an exponential {{rise in the number of}} necessary states. For a formal proof of the powerset construction, please see the Powerset construction article.|$|E
50|$|In automata theory, {{a branch}} of {{theoretical}} computer science, an ω-automaton (or stream automaton) is a variation of <b>finite</b> <b>automatons</b> that runs on infinite, rather than finite, strings as input. Since ω-automata do not stop, they {{have a variety of}} acceptance conditions rather than simply a set of accepting states.|$|R
5000|$|The tagger can be {{implemented}} as a <b>finite</b> state <b>automaton</b> (Mealy machine) ...|$|R
40|$|We {{define a}} deontic logic of regular {{action as a}} {{characterization}} within a modal µ-calculus of action. First a semantics of deontic notions for regular action is given in terms of conditions on modal action structures. Then modal µ-calculus formulas characterizing these conditions are constructed by closely following the structure of deterministic <b>finite</b> <b>automatons</b> for regular action...|$|R
25|$|In the 1960s, Thompson {{also began}} work on regular expressions. Thompson had {{developed}} the CTSS version of the editor QED, which included regular expressions for searching text. QED and Thompson's later editor ed (the standard text editor on Unix) contributed greatly to the eventual popularity of regular expressions, and regular expressions became pervasive in Unix text processing programs. Almost all programs that work with regular expressions today use some variant of Thompson's notation. He also invented Thompson's construction algorithm used for converting regular expression into nondeterministic <b>finite</b> <b>automaton</b> {{in order to make}} expression matching faster.|$|E
2500|$|In automata theory, {{a finite}} state machine is called a {{deterministic}} <b>finite</b> <b>automaton</b> (DFA), if ...|$|E
2500|$|... is {{the initial}} state, {{an element of}} [...] In a nondeterministic <b>finite</b> <b>automaton,</b> [...] {{is a set of}} initial states.|$|E
40|$|Arden's Lemma is a {{classical}} result in language theory allowing the computation of a rational expression denoting the language recognized by a <b>finite</b> string <b>automaton.</b> In this paper we generalize this important lemma to the rational tree languages. Moreover, we propose also a {{construction of a}} rational tree expression which denotes the accepted tree language of a <b>finite</b> tree <b>automaton...</b>|$|R
5000|$|An {{important}} kind of noncommutative signal-flow graph is a <b>finite</b> state <b>automaton</b> over an alphabet [...]|$|R
40|$|Abstract—The {{location}} of distribution centers plays {{a vital role}} in logistics planning. This paper presents a new method for solving the location problems. The mechanism of <b>finite</b> state <b>automaton</b> is combined to the standard GA to diversify location strategies and accelerate the convergence speed of the method. The experiment results demonstrate the proposed method outperforms the standard GA in terms of computational cost. Keywords-facility location; genetic algorithm; <b>finite</b> state <b>automaton</b> I...|$|R
2500|$|... is the state-transition function: [...] (in a nondeterministic <b>finite</b> <b>automaton</b> {{it would}} be , i.e., [...] would return a set of states).|$|E
2500|$|Finding {{a regular}} {{expression}} denoting the regular language accepted by a <b>finite</b> <b>automaton</b> (Kleene's algorithm, a closely related generalization of the Floyd–Warshall algorithm) ...|$|E
2500|$|A <b>finite</b> <b>automaton</b> {{with access}} to two stacks is a more {{powerful}} device, equivalent in power to a Turing machine. [...] A linear bounded automaton is a device which is more powerful than a pushdown automaton but less so than a Turing machine.|$|E
40|$|ABSTRACT: This article {{presents}} a novel way to model safety critical systems hierarchically. An information flow diagram as high level and <b>finite</b> <b>automatons</b> as low level model are combined. With these models, scenarios leading to dangerous failures {{as well as}} spurious shutdowns can be generated. Furthermore, we will show how to extract the different scenarios out of the model in a very efficient way using different BDD-techniques. Finally, we will present some related work. ...|$|R
40|$|This article {{presents}} {{a new way}} to model safety critical systems hierarchically. An information flux diagram as high level and <b>finite</b> <b>automatons</b> as low level model are combined. With these models, scenarios leading to dangerous failures as well as spurious trips can be generated. Furthermore, we will show how to extract the different scenarios out of the model in a very efficient way using different BDD-techniques. Finally, a theoretical complexity analysis for the used algorithms is given. ...|$|R
50|$|An {{important}} yardstick {{for describing}} the relative expressive power of formalisms {{in this area}} is the Chomsky hierarchy. It says, for instance, that regular expressions, nondeterministic <b>finite</b> <b>automatons</b> and regular grammars have equal expressive power, while that of context-free grammars is greater; {{what this means is that}} the sets of sets of strings described by the first three formalisms are equal, and a proper subset of the set of sets of strings described by context-free grammars.|$|R
2500|$|A {{deterministic}} <b>finite</b> <b>automaton</b> may {{be interpreted}} as a directed graph in which each vertex has the same out-degree , and in which the edges are -colored {{in such a way that}} every two edges with the same source vertex have distinct colors. The road coloring problem is the problem of edge-coloring a directed graph with uniform out-degrees, in such a way that the resulting automaton has a synchronizing word. [...] solved the road coloring problem by proving that such a coloring can be found whenever the given graph is strongly connected and aperiodic.|$|E
2500|$|A finite-state machine (FSM) or finite-state {{automaton}} (FSA, plural: automata), <b>finite</b> <b>automaton,</b> {{or simply a}} state machine, is a mathematical model of computation. [...] It is an abstract machine that can be in exactly one of {{a finite number of}} states at any given time. [...] The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.|$|E
2500|$|The Floyd–Warshall {{algorithm}} {{is an example}} of dynamic programming, and was published in its currently recognized form by Robert Floyd in 1962. [...] However, it is essentially the same as algorithms previously published by Bernard Roy in 1959 and also by Stephen Warshall in 1962 for finding the transitive closure of a graph, and is closely related to Kleene's algorithm (published in 1956) for converting a deterministic <b>finite</b> <b>automaton</b> into a regular expression. The modern formulation of the algorithm as three nested for-loops was first described by Peter Ingerman, also in 1962.|$|E
40|$|This thesis {{deals with}} the problem of {{approximate}} string matching, ie. string matching allowing errors. Initially, we will define the problem itself and demonstrate variety of it's applications, followed by short survey of different approaches to cope with this problem. The remaining part of the work is focused on algorithms based on the use of deterministic <b>finite</b> <b>automatons.</b> Main algorithms in this area will be presented. Those will be implemented in Python programming language and thoroughly compared in series of experiments...|$|R
40|$|Let β > 1, d a {{positive}} integer, and Z_β,d={z_ 1 z_ 2 [...] . |∑_i> 1 z_i β^-i= 0, z_i ∈{-d, [...] ., d}} be {{the set of}} infinite words having value 0 in base β on the alphabet {-d, [...] ., d}. Based on a recent result of Feng on spectra of numbers, we prove that if the set Z_β,β - 1 is recognizable by a <b>finite</b> Büchi <b>automaton</b> then β is a Pisot number. As a consequence of previous results, the set Z_β, d is recognizable by a <b>finite</b> Büchi <b>automaton</b> for every positive integer d {{if and only if}} Z_β, d is recognizable by a <b>finite</b> Büchi <b>automaton</b> for one d >β - 1. These conditions are equivalent to the fact that β is a Pisot number. The bound β - 1 cannot be further reduced...|$|R
40|$|It {{is known}} that nonregular {{languages}} can be accepted by finite state probabilistic automata. For many years it was not known whether a <b>finite</b> state probabilistic <b>automaton</b> existed that would accept a context sensitive language that is not context free. Such a <b>finite</b> state probabilistic <b>automaton</b> is constructed...|$|R
