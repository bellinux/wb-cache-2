5|231|Public
5000|$|The VNC {{protocol}} (RFB protocol) is very simple, {{based on}} transmitting one <b>graphic</b> <b>primitive</b> from server to client ("Put a rectangle of pixel data at the specified X,Y position") and event messages from client to server.|$|E
40|$|Most of the {{previous}} multiresolution models use exclusively the triangle <b>graphic</b> <b>primitive</b> both in the data structure and in the rendering stage. Only a few models use another <b>graphic</b> <b>primitive</b> in this rendering process and just one uses the triangle fan as the basic primitive of the model. In this paper we present the first multiresolution model, Multiresolution Triangle Strips, that uses the triangle strip in the data structure and in the rendering stage. Each triangle strip is represented as a graph and all levels-of-detail of this strip are stored in it. The extraction algorithm traverses the graph to obtain the triangle strip at the demanded resolution. The use of this primitive speeds up the rendering process {{as the number of}} vertices sent to the graphic system is reduced...|$|E
40|$|Parallel {{visualization}} of large datasets in GeoFEM is described. Our visualization subsystem supports concurrent visualization with computation, and outputs a simplified small <b>graphic</b> <b>primitive</b> set, {{which can be}} displayed by a basic viewer on clients. This subsystem provides many kinds of parallel visualization algo-rithms for the users to visualize their data from scalar, vector to tensor. Scalar field topology analysis, flow field topology and semi-automatic parameter design are employed {{to improve the quality}} of visualization results. We also present a simplification algorithm to reduce the number of output graphic primitives, ac-counting for both shape attribute and color attribute. The experimental results show the effectiveness of our subsystem...|$|E
50|$|Galaksija Plus {{featured}} {{new software}} additions: <b>Graphic</b> <b>primitives</b> in BASIC language - commands to draw lines, boxes, circles, other <b>graphic</b> <b>primitives</b> {{as well as}} drawing text on graphical screen with different font. Additional firmware (ROM C) also featured Full Screen Source Editor and soft scrolling.|$|R
50|$|Winters, Terry. <b>Graphic</b> <b>Primitives.</b> New York: Matthew Marks Gallery, 1999.|$|R
5000|$|... termcap-style {{terminal}} control functions, <b>graphics</b> <b>primitives</b> such as line and circle drawing; ...|$|R
40|$|Virtual Network Computing {{abbreviated}} as V. N. C. is a stupendous technology adverted for {{remote desktop}} sharing. It is envisioned as an open source research {{project in the}} late 1990 ’s which was spawned at the Oracle Research Lab. It is an intelligible protocol, based on a <b>graphic</b> <b>primitive.</b> This efficacious application is mainly contemplated for triggering and controlling remote desktop with in a network. This protocol is intrinsically used for prospecting Graphical User Interface desktops on remote machines within a LAN or over a WAN and providing access to home computing environments. Usually applications on a network can be accessed and executed by users as per the permissions ascribed by the administrator but impotent to access the desktop. The "VNC" is one such application that helps in catering the imperative facilities for inducing specific applications on a remote machine. The ingenuousness and candor makes this protocol competent, robust and puissant. The VNC protocol is utterly independent of operating system, windowing system, and applications dissonant from other remote display protocols such as the XWindow System and Citrix's ICA. The VNC server is used for sharing and dispensing its screen where as, the VNC client ganders and collaborates with the server...|$|E
40|$|Weng et al. {{introduced}} {{the notion of}} conditional proxy re-encryption (or C-PRE, for short), whereby only the ciphertext satisfying one condition set by the delegator can be transformed by the proxy and then decrypted by delegatee. Nonetheless, they left an open problem on how to construct CCA-secure C-PRE schemes with anonymity. Fang et al. answered this question by presenting a construction of anonymous condi- tional proxy re-encryption (C-PRE) scheme without requiring random oracle. Nev- ertheless, Fang et al. 2 ̆ 7 s scheme only satises the RCCA-security (which is a weaker variant of CCA-security assuming a harmless mauling of the challenge ciphertext is tolerated). Hence, it remains an open problem whether CCA-secure C-PRE schemes that satisfy both anonymity and full CCA-security can really be realized. Shao et al. introduced a new cryptographic primitive, called proxy re-encryption with keyword search (PRES), which {{is a combination of}} PRE and public key encryption with key- word search (PEKS), and they left an open problem on how to design an efficient unidirectional PRES scheme. In this paper, we answer the above open problems by proposing a new crypto- <b>graphic</b> <b>primitive</b> called conditional proxy re-encryption with keyword search (C- PRES), which combines C-PRE and PEKS. We note that there are subtleties in combining these two notions to achieve a secure scheme, and hence, the combination is not trivial. We propose a denition of security against chosen ciphertext attacks for C-PRES schemes with keyword anonymity, and thereafter present a scheme that satises the denition. The performance of our scheme outperforms Weng et al. 2 ̆ 7 s construction, which has been regarded as the most efficient C-PRE scheme to date...|$|E
5000|$|QuickDraw [...] - [...] 2D <b>graphics</b> <b>primitives.</b> Deprecated since Mac OS X v10.4, {{in favor}} of Quartz 2D.|$|R
40|$|We {{develop a}} voxel-based {{approach}} to volume modeling, {{in which the}} 3 D object is represented {{as a set of}} voxels rather than a collection of surfaces. Interpretation with voxel-based representations is an intuitive paradigm, which {{has been shown to be}} theoretically sound and possesses enormous computational advantages over modeling with surface-based representations of 3 D objects. However, there is no efficient algorithm for volume modeling of <b>graphics</b> <b>primitives.</b> In this paper, we attempt to bridge the gap by an efficient projective voxelization technique suitable for all existing 3 D <b>graphics</b> <b>primitives...</b>|$|R
25|$|In 1979, William Yerazunis wrote {{a partial}} version of APL in Prime Computer FORTRAN, {{extended}} it with <b>graphics</b> <b>primitives,</b> and released it. This {{was also the}} subject of his Masters thesis.|$|R
50|$|The TMS34010 {{card was}} {{developed}} by Andrew Morton for Keno Computer Systems. The 34010 was a bit-addressable graphics processor with instructions for two-dimensional <b>graphics</b> <b>primitives</b> and arbitrary width arithmetic operations on pixel data.|$|R
50|$|DrawBot is an {{open source}} {{application}} for OS X that allows users to write simple Python scripts to generate two-dimensional graphics. The builtin <b>graphics</b> <b>primitives</b> support rectangles, ovals, (bezier) paths, polygons, text objects and transparency.|$|R
40|$|A {{method is}} {{developed}} for distributing the computation of <b>graphics</b> <b>primitives</b> on a parallel processing network. Off-the-shelf transputer boards {{are used to}} perform the graphics transformations and scan-conversion tasks that would normally be assigned to a single transputer based display processor. Each node in the network performs a single <b>graphics</b> <b>primitive</b> computation. Frequently requested tasks can be duplicated on several nodes. The {{results indicate that the}} current distribution of commands on the graphics network shows a performance degradation when compared to the graphics display board alone. A change to more computation per node for every communication (perform more complex tasks on each node) may cause the desired increase in throughput...|$|R
40|$|We {{present the}} {{architecture}} of a system, based on a PC, covering real-time video processing by integration of live video and computer graphics. The video processing and integration is realized by generating and evaluation of an on-line MIPmap video texture. This new application of a known filtering technique for still textures {{in the field of}} live video processing permits an easy and high performance integration of video and graphics to speed up the video processing. The video texture is then mapped on surfaces defined by <b>graphics</b> <b>primitives.</b> The <b>graphics</b> <b>primitives</b> are processed by a standard graphics pipeline with special hardware support for the rendering part...|$|R
5000|$|Super-ellipsoids as {{computer}} <b>graphics</b> <b>primitives</b> were popularized by Alan H. Barr (who used the name [...] "superquadrics" [...] {{to refer to}} both superellipsoids and supertoroids). However, while some super-ellipsoids are superquadrics, neither family is contained in the other.|$|R
50|$|The Utah Teapot is a {{standard}} reference object of the computer graphics community, comparable to Hello, World for its popularity. It is included as a <b>graphics</b> <b>primitive</b> in many <b>graphics</b> packages, including AutoCAD, POV-Ray, OpenGL, Direct3D, and 3ds Max.|$|R
40|$|This course {{introduces}} {{points as}} a powerful and versatile <b>graphics</b> <b>primitive.</b> Speakers present their latest concepts for the acquisition, representation, modeling, processing, and rendering of point sampled geometry along with applications and research directions. We describe algorithms and discuss current problems and limitations...|$|R
50|$|Built on <b>graphics</b> <b>primitives</b> like QuickDraw that Bill Atkinson had {{originally}} {{developed for the}} Apple Lisa computer, MacPublisher included WYSIWYG layout for multi-column text and graphics. QuickDraw was incorporated in the Pascal toolbox for the new Macintosh and had been the basis for MacPaint.|$|R
50|$|Almost {{as complex}} as PostScript itself is its {{handling}} of fonts. The font system uses the PS <b>graphics</b> <b>primitives</b> to draw glyphs as curves, which can then be rendered at any resolution. A number of typographic issues had to be considered with this approach.|$|R
50|$|An X server has a {{tremendous}} amount of functionality that must be implemented to support the X core protocol. This includes code tables, glyph rasterization and caching, XLFDs, and the entire core rendering API that draws stippled lines, polygons, wide arcs and many more state-of-the-1980s style <b>graphics</b> <b>primitives.</b>|$|R
25|$|These early {{efforts to}} use GPUs as {{general-purpose}} processors required reformulating computational problems {{in terms of}} <b>graphics</b> <b>primitives,</b> as supported by the two major APIs for graphics processors, OpenGL and DirectX. This cumbersome translation was obviated by the advent of general-purpose programming languages and APIs such as Sh/RapidMind, Brook and Accelerator.|$|R
50|$|Caltech Intermediate Form (CIF) is a {{file format}} for {{describing}} integrated circuits.CIF provides a limited set of <b>graphics</b> <b>primitives</b> that {{are useful for}} describing the two-dimensionalshapes on the different layers of a chip.The format allows hierarchical description, which makes the representation concise.In addition, it is a terse but human-readable text format.|$|R
50|$|These early {{efforts to}} use GPUs as {{general-purpose}} processors required reformulating computational problems {{in terms of}} <b>graphics</b> <b>primitives,</b> as supported by the two major APIs for graphics processors, OpenGL and DirectX. This cumbersome translation was obviated by the advent of general-purpose programming languages and APIs such as Sh/RapidMind, Brook and Accelerator.|$|R
40|$|We {{present a}} {{syntactic}} approach to technical drawing dimensions analysis. A specific grammar {{is used to}} describe dimensions of drawings. This grammar can be graphically designed by combining different <b>graphic</b> <b>primitives.</b> The algorithm used for analysis can start at different points of the grammar. The analysis proceeds bottom-up and top-down according to previously obtained results. ...|$|R
50|$|Geometry shaders are a {{relatively}} new type of shader, introduced in Direct3D 10 and OpenGL 3.2; formerly available in OpenGL 2.0+ {{with the use of}} extensions. This type of shader can generate new <b>graphics</b> <b>primitives,</b> such as points, lines, and triangles, from those primitives that were sent {{to the beginning of the}} graphics pipeline.|$|R
50|$|Graphics32 {{provides}} fast {{operations for}} pixels and <b>graphic</b> <b>primitives</b> and {{is almost a}} hundred times faster in per-pixel and about 2-5 times faster in drawing lines access than the standard components by Embarcadero which are wrappers for the Windows GDI. Additionally, it provides alpha blending, anti-aliasing as well as filters for resampling and deforming bitmaps.|$|R
40|$|Goal of {{this thesis}} is to {{implement}} interactive 3 D editor {{able to work}} with unorganized point-clouds. Nontraditional <b>graphics</b> <b>primitive</b> needs nontraditional editing tools, author should propose and implement several instruments and verify their behavior in real editing tasks. Particular problems to be solved: efficient data representation and persistence, normal vector computation, dynamic level-of-detail, isotropic point density, etc...|$|R
40|$|Solving {{the hidden}} surface removal is an {{essential}} problem since the early time of computer graphics. Most of the algorithms designed, like z-buffer or BSP-tree, are not output-sensitive what means, that their time complexity {{is proportional to the}} total number of <b>graphic</b> <b>primitives</b> in the model. However, in many complex models most their parts are invisible to an observer while located in certain region. This observation yields a search to design output-sensitive algorithms with the runtime complexity (time of rendering) proportional to the number of visible <b>graphic</b> <b>primitives.</b> We present one such algorithm together withe an empirical evidence of the asset of the visibility determination. The method presented in this paper subdivides the model into smaller parts (cells) continuing with determination of visibility relations between them. To describe potentially visible sets a tree data structure is used, where edges correspond to tight approximations of potentially visible frustrums. K [...] ...|$|R
50|$|INT 10h, INT 10H or INT 16 is {{shorthand}} for BIOS interrupt call 10hex, the 17th interrupt vector in an x86-based computer system. The BIOS typically {{sets up a}} real mode interrupt handler at this vector that provides video services. Such services include setting the video mode, character and string output, and <b>graphics</b> <b>primitives</b> (reading and writing pixels in graphics mode).|$|R
50|$|The VNC {{protocol}} is pixel based. Although {{this leads}} to great flexibility (e.g., any type of desktop can be displayed), it is often less efficient than solutions that {{have a better understanding}} of the underlying graphic layout, like X11. Those protocols send <b>graphic</b> <b>primitives</b> or high-level commands in a simpler form (e.g., open window), whereas RFB just sends the raw pixel data.|$|R
50|$|Performer {{consists}} {{primarily of}} two libraries: the lower-level libpr and the higher-level libpf. The libpr library provides an object-oriented interface to high-speed rendering functions {{based on the}} concept of a pfGeoSet and a pfGeoState. A pfGeoSet is a collection of <b>graphics</b> <b>primitives,</b> such as polygons or lines. A pfGeoState encapsulates properties pertaining to a given pfGeoSet such as lighting, transparency, and texturing.|$|R
5000|$|... wxWidgets is best {{described}} as a native mode toolkit as it provides a thin abstraction to a platform's native widgets, contrary to emulating the display of widgets using <b>graphic</b> <b>primitives.</b> Calling a native widget on the target platform results in a more native looking interface than toolkits such as Swing (for Java), as well as offering performance and other benefits.|$|R
5000|$|Web 3D Service (W3DS): This type {{of service}} handles geodata access and mapping to {{computer}} <b>graphics</b> <b>primitives</b> such as scene graphs with textured 3D geometry models {{as well as their}} delivery to the requesting client applications. The client applications are responsible for the 3D rendering of delivered scene graphs, i.e., they are responsible for the interactive display using their own 3D graphics hardware.|$|R
40|$|We {{present the}} design and {{implementation}} of Collaborative Spray or CSpray (pronounced 'sea spray'). CSpray is a CSCW (Computer Supported Cooperative Work) application geared towards supporting multiple users in a collaborative scientific visualization setting. Scientists are allowed to share data sets, <b>graphics</b> <b>primitives,</b> images, and create visualization products within a view independent shared workspace. CSpray supports incremental updates to reduce network traffic, separates large data streams from smaller command streams with a two level communication strategy, provides different service levels according to client's resources, enforces permissions for different levels of sharing, distinguishes private from public resources, and provides multiple fair and intuitive floor control schemes for shared objects. Off the shelf multimedia tools such as nv and vat can be used concurrently. CSpray {{is based on the}} spray rendering visualization interaction technique to generate contours, surfaces, particles, and other <b>graphics</b> <b>primitives</b> from scientific data sets such as those found in oceanography and meteorology...|$|R
40|$|Based on {{the recent}} {{improvements}} in the price/performance of PC-based graphics accelerators, it is compelling to consider approaches that combine multiple PCs together into a high performance, high resolution, low cost parallel rendering system. We are investigating sort-first approaches to build such {{a system in which}} one or more client PCs distribute 3 D <b>graphics</b> <b>primitives</b> to multiple server PCs that render images for separate 2 D tiles for projection on a display surface. A fundamental challenge in implementing such a system is developing a method to classify 3 D <b>graphics</b> <b>primitives</b> according to their overlaps with the 2 D screenspace tiles so that every server PC is not required to process every 3 D primitive. In this paper, we describe several overlap classification algorithms based on different bounding volume approximations, different transformation sequences, different primitive aggregation methods, and different primitive sizes. We built a prototype sort-first system with one clie [...] ...|$|R
