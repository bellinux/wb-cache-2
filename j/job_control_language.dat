80|3640|Public
2500|$|It is also {{possible}} to use solely the macro processing abilities of an assembler to generate code written in completely different languages, for example, to generate a version of a program in COBOL using a pure macro assembler program containing lines of COBOL code inside assembly time operators instructing the assembler to generate arbitrary code. IBM OS/360 uses macros to perform system generation. The user specifies options by coding a series of assembler macros. [...] Assembling these macros generates a job stream to build the system, including <b>job</b> <b>control</b> <b>language</b> and utility control statements.|$|E
2500|$|Making {{the command}} {{interpreter}} an ordinary user-level program, with additional commands provided as separate programs, was another Multics innovation popularized by Unix. The Unix shell {{used the same}} language for interactive commands as for scripting (shell scripts– there was no separate <b>job</b> <b>control</b> <b>language</b> like IBM's JCL). Since the shell and OS commands were [...] "just another program", the user could choose (or even write) his own shell. New commands could be added without changing the shell itself. Unix's innovative command-line syntax for creating modular chains of producer-consumer processes (pipelines) made a powerful programming paradigm (coroutines) widely available. Many later command-line interpreters {{have been inspired by}} the Unix shell.|$|E
50|$|The System/3 came {{standard}} with a RPG II compiler, {{and used}} a simple <b>job</b> <b>control</b> <b>language</b> called OCL, which was superficially similar to the famous (or infamous) <b>Job</b> <b>Control</b> <b>Language.</b>|$|E
5000|$|... {{the other}} for the lineage from OS/360 to z/OS, the latter now {{including}} JES extensions, <b>Job</b> Entry <b>Control</b> <b>Language</b> (JECL).|$|R
40|$|The user {{interface}} {{is that part}} of a computer system through which human user and computer communicate. With the increasing prevalence of interactive personal computer systems the importance of human communication is growing steadily, and many systems now stand or fall on the quality of their interfaces. Interfaces consume a large amount of software construction and maintenance effort—estimates of the fraction of an interactive system’s code devoted to the {{user interface}} vary from one third to almost two thirds. User interfaces evolved from the <b>job</b> <b>control</b> <b>languages</b> available on batch computing systems that allowed users to describe to the system the requirements of their tasks. These provided facilities for users to identify themselves to the system for security and accounting purposes; inform the computer about the resources required by tasks; specify input/output devices and files needed; and determine what action the computer should take in the event of error. Interactive systems renamed their <b>job</b> <b>control</b> <b>languages</b> command languages. These environments simplified some aspects of the human/computer interface. A stream of commands could be submitted and interpreted one line at a time, which allowed users to respond to evolving situations rather tha...|$|R
5000|$|An early {{version of}} <b>Job</b> Entry <b>Control</b> <b>Language</b> for OS/360 Remote Job Entry (Program Number 360S-RC-536) used the {{identifier}} [...] in columns 1 - 2 of the input record and consisted of a single <b>control</b> statement: [...] (<b>Job</b> Entry Definition). [...] "Workstation Commands" [...] such as , , and [...] also began with [...]|$|R
50|$|The <b>job</b> <b>control</b> <b>language</b> was {{the same}} on {{terminals}} or in batch jobs and included conditional operations and macro operations. In contrast to Unix systems the <b>job</b> <b>control</b> <b>language</b> {{was part of the}} operating system rather than being a user level shell process.|$|E
50|$|The George 2 <b>job</b> <b>control</b> <b>language</b> allowed use of stored macros with {{conditional}} facilities.|$|E
50|$|JECL is {{distinct}} from <b>job</b> <b>control</b> <b>language</b> (JCL), which instructs the operating system how to run the job.|$|E
5000|$|On IBM {{mainframe}} systems <b>Job</b> Entry <b>Control</b> <b>Language</b> or JECL is the set {{of command}} <b>language</b> <b>control</b> statements that provide information for the spooling subsystem [...] - [...] JES2 or JES3 on z/OS or VSE/POWER for z/VSE. JECL statements may [...] "specify on which network computer to run the job, when to run the job, and where to send the resulting output." ...|$|R
5000|$|For VSE JECL {{statements}} {{start with}} [...] (note the single space). The <b>Job</b> Entry <b>Control</b> <b>Language</b> defines {{the start and}} end lines of JCL jobs. It advises VSE/POWER how this job is handled. JECL statements define the job name (used by VSE/POWER), the class in which the job is processed, and the disposition of the job (i.e. , , , [...] ).|$|R
50|$|A {{scripting}} or script {{language is}} a programming language that supports scripts: programs written for a special run-time environment that automate the execution of tasks that could alternatively be executed one-by-one by a human operator. Scripting languages are often interpreted (rather than compiled). Primitives are usually the elementary tasks or API calls, and the language allows them to be combined into more complex programs. Environments that can be automated through scripting include software applications, web pages within a web browser, the shells of operating systems (OS), embedded systems, as well as numerous games. A scripting language {{can be viewed as}} a domain-specific language for a particular environment; in the case of scripting an application, this is also known as an extension language. Scripting languages are also sometimes referred to as very high-level programming languages, as they operate at a high level of abstraction, or as <b>control</b> <b>languages,</b> particularly for <b>job</b> <b>control</b> <b>languages</b> on mainframes.|$|R
5000|$|These {{utilities}} are usually invoked via <b>Job</b> <b>Control</b> <b>Language</b> (JCL). They {{tend to use}} common JCL DD identifiers for their data sets: ...|$|E
5000|$|The same JCL (<b>Job</b> <b>Control</b> <b>Language,</b> for {{initiating}} batch jobs), {{which was}} more flexible and easier to use, though more complex, than that of DOS/360.|$|E
50|$|Early {{mainframe}} computers (in the 1950s) were non-interactive, instead using batch processing. IBM's <b>Job</b> <b>Control</b> <b>Language</b> (JCL) is the {{archetype of}} languages {{used to control}} batch processing.|$|E
5000|$|This is {{much more}} recognizably a typed {{high-level}} programming <b>language</b> than the <b>job</b> <b>control</b> or shell <b>languages</b> found in most other operating systems: it can be likened to scripting languages such as JavaScript, though its surface syntax is derived from Algol 68.|$|R
50|$|Now that Sintran {{has mostly}} {{disappeared}} as an operating system {{there are very}} few references to it, however a <b>job</b> <b>control</b> or batch <b>language</b> was available called JEC, believed to be known as Job Execution Controller, this could be used to set up batch jobs to compile COBOL programs etc.|$|R
40|$|Abstract. Globus {{has become}} a {{standard}} {{in the construction of}} Grid computing environments. However, it still needs more work and research to satisfy re-quirements from various grid applications such as workflow services. We pro-pose a Meta Scheduling Framework (MSF) for workflow service management based on the Globus toolkit. The MSF provides an XML-based <b>Job</b> <b>Control</b> Markup <b>Language</b> (JCML) for describing information and procedures of appli-cations including dependencies of jobs, a workflow management engine for scheduling complicated job flow, and an execution environment without the need for code modification or wrapping. ...|$|R
5000|$|H: Jobs on HOLD - either {{waiting to}} be {{released}} into Input or Output or actual copies of job JCL (<b>Job</b> <b>Control</b> <b>Language)</b> or previously executed jobs.|$|E
50|$|Custom {{programs}} can access VSAM datasets through Data Definition (DD) statements in <b>Job</b> <b>Control</b> <b>Language</b> (JCL), via dynamic allocation or in online regions {{such as in}} Customer Information Control System (CICS).|$|E
50|$|<b>Job</b> <b>Control</b> <b>Language</b> (JCL) is a {{name for}} {{scripting}} languages used on IBM mainframe operating systems to instruct the system on {{how to run a}} batch job or start a subsystem.|$|E
40|$|The mouse—the {{computer}} mouse, that is—was {{invented in}} the mid- 1960 s and was first demonstrated in a computer-based editing system in 1968. The videotape of that demonstration, which, like much else now, {{may be found}} on the “Web ” (NLS:demo, 2004), is fascinating and enlightening. The demonstration introduced not only the mouse, but also cut-and-paste editing, hypertext, and many other technologies currently employed by all those who use computer systems for work or play. Douglas Engelbart invented the mouse, and his research group at SRI International (then the Stanford Research Institute) engineered an editing system and document preparation environment called NLS (OnLine System) that is the predecessor of today’s computer editing systems (Engelbart and English, 1968). The name of this research group, “The Augmentation Research Center, ” reflected Engelbart’s goal of constructing systems able to “augment human intellect,” (Engelbart, 1962). The system features he envisioned were far ahead of that time; some remain elusive even now. Menus along with icons as a way of communicating were integrated with windows into editing systems at Xerox PARC in the early 1970 s (Xerox:history, 2004). Together, mice and menus enable, indeed were designed to enable, “ordinary people ” to get computers to do tasks for them without requiring that they know how to program. For any who struggled with assembly <b>language</b> programming or <b>job</b> <b>control</b> <b>languages</b> 2 and the like, this new technology represented enormous progress...|$|R
40|$|A {{language}} {{has been created}} to facilitate the automatic execution of simulations for purposes of enabling parametric study and test and evaluation. Its function is similar in nature to a job-control language, but more capability is provided in that the language extends the notion of literate programming to <b>job</b> <b>control.</b> Interwoven markup tags self document and define the <b>job</b> <b>control</b> process. The <b>language</b> works in tandem with another language used to describe physical systems. Both languages are implemented in the Extensible Markup Language (XML). A user describes a physical system for simulation and then creates a set of instructions for automatic execution of the simulation. Support routines merge the instructions with the physical-system description, execute the simulation the specified number of times, gather the output data, and document the process and output for the user. The language enables the guided exploration of a parameter space {{and can be used}} for simulations that must determine optimal solutions to particular problems. It is generalized enough that it can be used with any simulation input files that are described using XML. XML is shown to be useful as a description language, an interchange language, and a self-documented language...|$|R
40|$|Does <b>job</b> <b>control</b> {{act as a}} stress-buffer when {{employees}} 2 ̆ 7 {{type and}} level of work self-determination is taken into account? It was anticipated that <b>job</b> <b>control</b> would only be stress-buffering for employees high in self-determined and low in non-self-determined work motivation. In contrast, <b>job</b> <b>control</b> would be stress-exacerbating for employees who were low in self-determined and high in non-self-determined work motivation. Employees of a health insurance organization (N = 123) completed a Survey on perceptions of role overload, <b>job</b> <b>control,</b> work self-determination, {{and a range of}} strain and engagement indicators. Results revealed that, when individuals high in self-determination perceived high <b>job</b> <b>control,</b> they experienced greater engagement (in the form of dedication to their work). In addition, when individuals high in non-self-determination perceived high job demands, they experienced more health complaints. A significant 3 -way interaction demonstrated that, for individuals low in non-self-determination, high <b>job</b> <b>control</b> had the anticipated stress-buffering effect on engagement (in the form of absorption in their work). In addition, low <b>job</b> <b>control</b> was stress-exacerbating. However, contrary to expectations, for those high in non-self-determination, high <b>job</b> <b>control</b> was just as useful as low <b>job</b> <b>control</b> as a stress-buffer. The practical applications of these findings to the organizational context are discussed. (C) 2009 Elsevier Inc. All rights reserved...|$|R
50|$|SSG {{is used to}} {{generate}} RUN-Streams (corresponding to IBM's <b>Job</b> <b>Control</b> <b>Language),</b> apply and administer symbolic changes to program sources {{as a form of}} version control, and for many other purposes.|$|E
50|$|The {{other two}} job entry {{subsystems}} {{have very little}} in common, and in fact jobs written to run on one usually require small <b>Job</b> <b>Control</b> <b>Language</b> changes {{before they can be}} run on the other.|$|E
5000|$|JEM, the BEE is a Java, cloud-aware {{application}} which implements a Batch Execution Environment, to {{help and}} manage the execution of jobs, described by a <b>Job</b> <b>Control</b> <b>Language</b> (JCL). JEM, the BEE performs the following functions: ...|$|E
5000|$|<b>Job</b> <b>control,</b> command aliasing, {{and command}} history {{designed}} after the corresponding C shell features. <b>Job</b> <b>control</b> {{was added to}} the Bourne Shell in 1989.|$|R
5000|$|In Unix and Unix-like {{operating}} systems, <b>job</b> <b>control</b> {{refers to}} <b>control</b> of <b>jobs</b> by a shell, especially interactively, where a [...] "job" [...] is a shell's representation for a process group. Basic <b>job</b> <b>control</b> features are the suspending, resuming, or terminating of all {{processes in the}} job/process group; more advanced features can be performed by sending signals to the <b>job.</b> <b>Job</b> <b>control</b> {{is of particular interest}} in Unix due to its multiprocessing, and should be distinguished from <b>job</b> <b>control</b> generally, which is frequently applied to sequential execution (batch processing).|$|R
50|$|Robert Blauner {{found that}} <b>job</b> <b>control</b> is closely linked with {{occupational}} prestige and job satisfaction. Job satisfaction and <b>job</b> <b>control</b> {{tend to be}} higher for managerial and professional workers than for unskilled workers.|$|R
5000|$|Other {{mainframe}} batch systems {{had some}} form of <b>job</b> <b>control</b> <b>language,</b> whether called that or not; their syntax was completely different from IBM versions, but they usually provided similar capabilities. Interactive systems include [...] "command languages" [...] - command files (such as PCDOS [...] ".bat" [...] files) can be run non-interactively, but these usually do not provide as robust an environment for running unattended jobs as JCL. On some computer systems the <b>job</b> <b>control</b> <b>language</b> and the interactive command language may be different. For example, TSO on z/OS systems uses CLIST or Rexx as command languages along with JCL for batch work. On other systems these may be the same.|$|E
5000|$|In {{programming}} languages like PL/1 and Assembler used on IBM mainframe systems, {{as well as}} JCL (<b>Job</b> <b>Control</b> <b>Language),</b> the # symbol (along with $ and @) {{are used}} as additional letters in identifiers, labels and data set names.|$|E
5000|$|... "WTO" [...] is an {{assembler}} macro {{that generates}} an operating system call. Because of saving registers and later restoring and returning, this small program is usable as a batch program invoked {{directly by the}} operating system <b>Job</b> <b>control</b> <b>language</b> (JCL) like this: ...|$|E
40|$|Purpose: To {{investigate}} {{the influence of}} high job demands, low <b>job</b> <b>control,</b> and high social support on need for recovery (NFR) among computer workers. Methods: Data was obtained from a longitudinal cohort study, including 5 consecutive measurements, with an in-between period of 6 months. General estimating equations analyses were performed to assess the risk for high NFR 6 months later. Odds ratios (ORs) for high NFR were calculated for high job demands, low <b>job</b> <b>control</b> and low social support, separately. Likewise, ORs were calculated for combinations of job demands and <b>job</b> <b>control,</b> {{as well as for}} combinations of <b>job</b> demands, <b>job</b> <b>control</b> and social support. Results: High job demands resulted in an increased risk for high NFR 6 months later, particularly in older workers. Low social support showed also an increased risk for future high NFR, but {{this was not the case}} for low <b>job</b> <b>control.</b> Furthermore, a combination of high job demands and low <b>job</b> <b>control,</b> as well as a combination of high job demands, low <b>job</b> <b>control</b> and low social support demonstrated an increased risk for future high NFR where older workers showed higher risks. Conclusion: This study demonstrated that adverse psychosocial work characteristics predicted future NFR among computer workers. © 2013 Springer-Verlag Berlin Heidelberg...|$|R
40|$|In {{the present}} study, nursing and allied health employee's {{perceptions}} of <b>job</b> <b>control</b> {{and the relationship}} to performance evaluation were explored. Supervisor perceptions of their subordinate's level of <b>job</b> <b>control</b> was assessed with subordinate perceptions of <b>job</b> <b>control,</b> {{to determine the effects}} of perceptual congruence on reactions to performance evaluation. In addition, supervisor attributions to subordinate performance was assessed to test the relationship with subordinate responses to performance evaluation. One hundred and forty-four participants including forty-five matched supervisor-subordinate pairs in a large Queensland health care organisation were surveyed. The measures included perceptions of <b>job</b> <b>control,</b> supervisor attributions to subordinate performance and the effects of subordinate reactions to performance evaluation. The results indicated that there were no differences in the perceptions the supervisor held of their employee's <b>job</b> <b>control</b> and the perceptions the subordinate held in relation to their own levels of <b>job</b> <b>control.</b> In addition, it was found that <b>job</b> <b>control</b> significantly contributed to positive reactions to performance evaluation and when there was a close match between supervisor and subordinate perceptions of level of control, there was a resulting positive reaction to performance evaluation. Furthermore, supervisor internal attributions to subordinate performance predicted positive reactions to performance evaluation, when the employee was evaluated as having performed successfully...|$|R
40|$|The {{purpose of}} the present study was to {{investigate}} whether a curvilinear relationship between <b>job</b> <b>control</b> and well-being is be moderated by desire for control, such that the relationship is curvilinear in the shape of an inverted U for individuals with low desire for control, and positive and linear for individuals with high desire for control. This study was designed to provide clarification as to why researchers have produced mixed evidence in support of Warr’s (1987, 1994) Vitamin model, which states that <b>job</b> <b>control</b> and well-being are curvilinearly related in the shape of an inverted U. A total of 165 individuals from a variety of occupations participated in this study via online survey. The results did not provide any evidence that a curvilinear relationship between <b>job</b> <b>control</b> and well-being was moderated by desire for control. Furthermore, there was no evidence of any type of curvilinear relationship between <b>job</b> <b>control</b> and well-being, or any interaction between <b>job</b> <b>control</b> and desire for control. Instead, there was only evidence of a positive and linear relationship between <b>job</b> <b>control</b> and well-being. The major implication of the findings is that more research is needed to provide an explanation for the mixed evidence in support of a curvilinear relationship between <b>job</b> <b>control</b> and well-being...|$|R
