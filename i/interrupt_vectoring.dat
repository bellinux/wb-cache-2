0|103|Public
5000|$|An [...] "interrupt vector table" [...] (IVT) is a data {{structure}} that associates {{a list of}} interrupt handlers {{with a list of}} interrupt requests in a table of <b>interrupt</b> <b>vectors.</b> Each entry of the <b>interrupt</b> <b>vector</b> table, called an <b>interrupt</b> <b>vector,</b> is the address of an interrupt handler. While the concept is common across processor architectures, IVTs may be implemented in architecture-specific fashions. For example, a dispatch table is one method of implementing an <b>interrupt</b> <b>vector</b> table.|$|R
50|$|On the PC, the BIOS (and thus also DOS) {{traditionally}} maps {{the master}} 8259 interrupt requests (IRQ0-IRQ7) to <b>interrupt</b> <b>vector</b> offset 8 (INT08-INT0F) and the slave 8259 (in PC/AT and later) interrupt requests (IRQ8-IRQ15) to <b>interrupt</b> <b>vector</b> offset 112 (INT70-INT77). This was done despite the first 32 (INT00-INT1F) <b>interrupt</b> <b>vectors</b> being reserved by the processor for internal exceptions (this was ignored {{for the design}} of the PC for some reason). Because of the reserved vectors for exceptions most other operating systems map (at least the master) 8259 IRQs (if used on a platform) to another <b>interrupt</b> <b>vector</b> base offset.|$|R
5000|$|Vector pull (VPB) output {{indicates}} when <b>interrupt</b> <b>vectors</b> {{are being}} addressed ...|$|R
50|$|<b>Interrupt</b> <b>vectors</b> are {{blocks of}} two 16-bit words in low kernel address space (which {{normally}} corresponded to low physical memory) between 0 and 776. The first {{word of the}} <b>interrupt</b> <b>vector</b> contains {{the address of the}} interrupt service routine and the second word the value to be loaded into the PSW (priority level) on entry to the service routine.|$|R
5000|$|Vector Pull (VPB) {{output to}} {{indicate}} when an <b>interrupt</b> <b>vector</b> is being addressed.|$|R
50|$|Most {{processors}} have an <b>interrupt</b> <b>vector</b> table, including chips from Intel, AMD, Infineon, Microchip Atmel, Freescale, etc.|$|R
5000|$|Take {{complete}} control of an interrupt by not calling other TSRs that had previously altered the same <b>interrupt</b> <b>vector.</b>|$|R
5000|$|The NEC V33A (μPD70136A) {{differs from}} the NEC V33 in that it has <b>interrupt</b> <b>vector</b> numbers {{compatible}} with intel 80X86 processors.|$|R
50|$|Message-signalled <b>interrupt</b> <b>vectors</b> can be shared, to {{the extent}} that the {{underlying}} communication medium can be shared. No additional effort is required.|$|R
5000|$|An <b>interrupt</b> <b>vector</b> {{table is}} used in the three most popular methods of finding the {{starting}} address of the interrupt service routine: ...|$|R
5000|$|By {{chaining}} the <b>interrupt</b> <b>vectors</b> TSR {{programs could}} take {{complete control of}} the computer. A TSR could have one of two behaviors: ...|$|R
50|$|When the CPU is {{affected}} by an interrupt, it looks up the interrupt handler in the <b>interrupt</b> <b>vector</b> table, and transfers control to it.|$|R
5000|$|... 0x1100-0xFFFF : Up to 60 {{kilobytes}} {{of program}} ROM. Smaller ROMs start at higher addresses. The last 16 or 32 bytes are <b>interrupt</b> <b>vectors.</b>|$|R
5000|$|The [...] "predefined" [...] method loads {{the program}} counter (PC) {{directly}} with the address of some entry inside the <b>interrupt</b> <b>vector</b> table. The jump table itself contains executable code. While in principle an extremely short interrupt handler could be stored entirely inside the <b>interrupt</b> <b>vector</b> table, in practice the code at each entry is a single jump instruction that jumps to the full interrupt service routine (ISR) for that interrupt. The Atmel AVR and all 8051 and Microchip microcontrollers use the predefined approach.|$|R
2500|$|Supports {{speculative}} pre-fetching of the <b>interrupt</b> <b>vector</b> address. Reduces {{the number}} of interrupt service cycles by overlapping memory accesses with pipeline flushes and exception prioritization ...|$|R
50|$|During an {{interrupt}} cycle, a fifth {{style of}} transfer was automatically invoked to convey an <b>interrupt</b> <b>vector</b> from the <b>interrupting</b> device to the interrupt-fielding processor.|$|R
5000|$|Supports {{speculative}} pre-fetching of the <b>interrupt</b> <b>vector</b> address. Reduces {{the number}} of interrupt service cycles by overlapping memory accesses with pipeline flushes and exception prioritization ...|$|R
50|$|The typical {{method of}} {{utilizing}} an <b>interrupt</b> <b>vector</b> involves reading its present value (the address), storing {{it within the}} memory space of the TSR, and installing a pointer to its own code. The stored address is called {{before or after the}} TSR has received the interrupt and has finished its processing, in effect forming a singly linked list of interrupt handlers, also called interrupt service routines, or ISRs. This procedure of installing ISRs is called chaining or hooking an interrupt or an <b>interrupt</b> <b>vector.</b>|$|R
5000|$|At boot time, all BIOS {{services}} are available, {{and the memory}} below address [...] contains the <b>interrupt</b> <b>vector</b> table. BIOS POST has initialized the system timers 8253 or 8254 IC), interrupt controller(s), DMA controller(s), and other motherboard/chipset hardware as necessary to bring all BIOS services to ready status. DRAM refresh for all system DRAM in conventional memory and extended memory, but not necessarily expanded memory, {{has been set up}} and is running. The <b>interrupt</b> <b>vectors</b> corresponding to the BIOS interrupts have been set to point at the appropriate entry points in the BIOS, hardware <b>interrupt</b> <b>vectors</b> for devices initialized by the BIOS have been set to point to the BIOS-provided ISRs, and some other interrupts, including ones that BIOS generates for programs to hook, have been set to a default dummy ISR that immediately returns. The BIOS maintains a reserved block of system RAM at addresses [...] with various parameters initialized during the POST. All memory at and above address [...] can be used by the boot program; it may even overwrite itself.|$|R
50|$|The Interrupt Descriptor Table (IDT) is a data {{structure}} {{used by the}} x86 architecture to implement an <b>interrupt</b> <b>vector</b> table. The IDT {{is used by the}} processor to determine the correct response to interrupts and exceptions.|$|R
5000|$|Cascade {{with other}} TSRs {{by calling the}} old <b>interrupt</b> <b>vector.</b> This could be done before or after they {{executed}} their actual code. This way TSRs could form a chain of programs where each one calls the next one.|$|R
2500|$|The context {{register}} made {{no distinction}} between user and supervisor states. [...] Interrupts and traps did not switch contexts which required that all valid <b>interrupt</b> <b>vectors</b> always be mapped in page 0 of context, {{as well as the}} valid supervisor stack.|$|R
2500|$|The [...] "exception table" [...] (<b>interrupt</b> <b>vector</b> table <b>interrupt</b> <b>vector</b> {{addresses}}) {{is fixed}} at addresses 0 through 1023, permitting 256 32-bit vectors. The first vector (RESET) consists of 2 vectors, namely the starting stack address, and the starting code address. Vectors 3 through 15 {{are used to}} report various errors: bus error, address error, illegal instruction, zero division, CHK and CHK2 vector, privilege violation (to block privilege escalation), and some reserved vectors that became line 1010 emulator, line 1111 emulator, and hardware breakpoint. Vector 24 starts the real interrupts: spurious interrupt (no hardware acknowledgement), and level 1 through level 7 autovectors, then the 16 TRAP vectors, then some more reserved vectors, then the user defined vectors.|$|R
5000|$|In the 8086 processor, the {{interrupt}} {{table is}} called IVT (<b>interrupt</b> <b>vector</b> table). The IVT always resides {{at the same}} location in memory, ranging from [...] to , and consists of 256 four-byte real mode far pointers (256 × 4 = 1024 bytes of memory).|$|R
50|$|INT 13h is {{shorthand}} for BIOS interrupt call 13hex, the 20th <b>interrupt</b> <b>vector</b> in an x86-based computer system. The BIOS typically {{sets up a}} real mode interrupt handler at this vector that provides sector-based hard disk and floppy disk read and write services using cylinder-head-sector (CHS) addressing.|$|R
50|$|Form infects {{the boot}} sector. When a {{computer}} is booted from an infected sector, Form goes resident, hooks the <b>interrupt</b> <b>vector</b> table, and runs the original boot sector which it's hidden {{in an area}} it flags as defective. It will subsequently infect any media inserted into the machine.|$|R
5000|$|The {{original}} call, INT 27h, {{is called}} [...] "terminate but stay resident", {{hence the name}} [...] "TSR". Using this call, a program can make up to 64 KB of its memory resident. MS-DOS version 2.0 introduced an improved call, INT 21h/function 31h ('Keep Process'), which removed this limitation and let the program return an exit code. Before making this call, the program can install one or several interrupt handlers pointing into itself, {{so that it can}} be called again. Installing a hardware <b>interrupt</b> <b>vector</b> allows such a program to react to hardware events. Installing a software <b>interrupt</b> <b>vector</b> allows it to be called by the currently running program. Installing a timer interrupt handler allows a TSR to run periodically (see ISA and programmable interval timer, especially the section [...] "IBM PC compatible").|$|R
50|$|INT 16h, INT 16H or INT 22 is {{shorthand}} for BIOS interrupt call 16hex, the 22nd <b>interrupt</b> <b>vector</b> in an x86-based computer system. The BIOS typically {{sets up a}} real mode interrupt handler at this vector that provides keyboard services. This interruption is responsible {{for control of the}} PC keyboard.|$|R
5000|$|Every {{computer}} system has parts that cannot be functionally pure because they exist to distribute CPU cycles or other resources to different modules. For example, most systems have an [...] "initialization" [...] section that starts up the modules. Other well-known examples are the <b>interrupt</b> <b>vector</b> {{table and the}} main loop.|$|R
5000|$|... # For GAS [...]text [...]global _start [...] _start: movl $1, %eax [...] # System {{call number}} 1: exit (...) movl $0, %ebx [...] # Exits with exit status 0 int $0x80 [...] # Passes control to <b>interrupt</b> <b>vector</b> [...] # invokes system call—in this case system call [...] # number 1 with {{argument}} 0 ...|$|R
50|$|The PDP-11 {{supports}} hardware interrupts at four priority levels. Interrupts are {{serviced by}} software service routines, which could specify whether they themselves could be interrupted (achieving interrupt nesting). The event {{that causes the}} interrupt is indicated by the device itself, as it informs the processor of the address of its own <b>interrupt</b> <b>vector.</b>|$|R
50|$|CR16 has 16 {{general purpose}} {{registers}} of 16 bits, and address registers of 21 bits wide. There are 8 special registers: program counter, interrupt stack pointer ISP, <b>interrupt</b> <b>vector</b> address register INTBASE, status register PSR, configuration register and 3 debug registers. Status register implements flags: C, T, L, F, Z, N, E, P, I.|$|R
50|$|Interrupts are not {{dispatched}} through <b>interrupt</b> <b>vectors,</b> as {{with nearly}} all other Freescale processors. RS08 interrupts can wake the processor from a WAIT or STOP condition (where execution is temporarily halted), but otherwise {{do not change}} program flow. In essence, RS08 runs any thread of programming to completion. The effect is vaguely similar to cooperative multitasking in operating systems.|$|R
50|$|When {{generating}} a software interrupt, the processor calls {{one of the}} 256 functions pointed to by the interrupt address table, which {{is located in the}} first 1024 bytes of memory while in real mode (See <b>Interrupt</b> <b>vector).</b> It is therefore entirely possible to use a far-call instruction to start the interrupt-function manually after pushing the flag register.|$|R
5000|$|The [...] "fetch" [...] method loads the PC indirectly, {{using the}} address of some entry inside the <b>{{interrupt}}</b> <b>vector</b> table to pull an address out of that table, and then loading the PC with that address. Each and every entry of the IVT is {{the address of}} an interrupt service routine. All Motorola/Freescale microcontrollers use the fetch method.|$|R
5000|$|The xHCI {{architecture}} allows large {{maximum values}} {{for the number of}} USB devices, ports, <b>interrupt</b> <b>vectors,</b> etc. supported, however an implementation only needs to define the number necessary to meet its marketing requirements. For instance, a vendor could choose {{to limit the number of}} USB devices that it supported for a tablet xHCI implementation to 16 devices.|$|R
