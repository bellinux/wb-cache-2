3|100|Public
50|$|The {{client side}} of VisualCron is a {{graphical}} program {{which allows the}} administrator to manage jobs and view logs of the software's activities. The log viewer also allows searching for events based on queries, defining event type, time of <b>execution,</b> <b>message</b> content and other parameters.|$|E
50|$|PACCS, {{in later}} variants, {{included}} an Airborne Launch Control System (ALCS) capability, which provided an alternate means for <b>execution</b> <b>message</b> delivery to missile combat crews and a back-up launch control center, forcing the Soviet Union to target each missile silo, {{rather than just}} the launch control centers to incapacitate the Minuteman force.|$|E
50|$|A {{variant of}} Coral 66 was {{developed}} during the late 1970s/early 1980s by the British GPO, in conjunction with GEC, STC and Plessey, for use on the System X digital telephone exchange control computers, known as PO-CORAL. This was later renamed BT-CORAL when British Telecom was spun off from the Post Office. Unique features of this language were the focus on real-time <b>execution,</b> <b>message</b> processing, limits on statement execution between waiting for input, and a prohibition on recursion to remove {{the need for a}} stack.|$|E
40|$|This paper, {{targeting}} the large variety of Web APIs, presents an approach towards automated invocation of Web APIs. This approach applies a data schema, to the SAWSDL lowering schema mapping, a grounding mechanism {{that connects the}} ontological representations of Web APIs with their <b>execution</b> <b>messages.</b> It is intuitive to existing standard efforts and effective in coping with the heterogeneities witnessed {{by a majority of}} Web APIs...|$|R
5000|$|Primary LCC (PLCC): perform <b>execution</b> {{and rapid}} <b>message</b> {{processing}} ...|$|R
50|$|Timing {{failure is}} a failure of a process, or part of a process, in a {{synchronous}} distributed system or real-time system to meet limits set on <b>execution</b> time, <b>message</b> delivery, clock drift rate, or clock skew.|$|R
50|$|In {{computer}} programming, a usage message or {{help message}} {{refers to a}} brief message displayed by a program that utilizes a command-line interface for <b>execution.</b> This <b>message</b> usually consists of the correct command line usage for the program and includes {{a list of the}} correct command-line arguments or options acceptable to said program.|$|R
5000|$|Father Antoine [...] - [...] A Lazarist priest, {{a devoted}} {{follower}} of Father Vincent. He served as confessor just before Jeoffrey's <b>execution</b> and relayed <b>messages</b> between Jeoffrey and Angélique.|$|R
40|$|Introduction Minix is a modular {{operating}} system {{designed for use}} in teaching of {{operating system}}s [3, 4]. In Minix, the operating system is structured as multiple independent processes. These processes communicate with each other, and with user mode processes, via message passing. While the modular structure of Minix simplifies the individual components, the message passing patterns that occur at run-time can be complex. The interaction network has been proposed {{as a way of}} representing all processing (process <b>execution</b> and <b>message</b> passing) that is the direct result of a single user input [2]. An interaction network is an acyclic digraph. Each vertex in the graph represents an event and each edge represents a period of thread <b>execution,</b> or <b>message</b> progression, between two events. Message patterns are shown very well in displays of interaction networks. In this paper, we use displays of interaction networks to illustrate some of the complex message patterns that occur in Min...|$|R
50|$|The {{order of}} <b>execution</b> for <b>messages</b> {{traversing}} through {{the graph of}} objects {{is defined by the}} visual organization of the objects in the patcher itself. As a result of this organizing principle, Max is unusual in that the program logic and the interface as presented to the user are typically related, though newer versions of Max provide several technologies for more standard GUI design.|$|R
40|$|Abstract. This paper, {{targeting}} the large variety of Web APIs, presents an approach towards automated invocation of Web APIs. This approach applies a data schema, to the SAWSDL lowering schema mapping, a grounding mechanism {{that connects the}} ontological representations of Web APIs with their <b>execution</b> <b>messages.</b> It is intuitive to existing standard efforts and effective in coping with the heterogeneities witnessed {{by a majority of}} Web APIs. 1. Invocation of Linked Web APIs In recent years, the world of service on the Web has witnessed an increasing dominance of Web APIs over “classical ” Web services characterized by WSDL and SOAP [1]. The Semantic Web Service (SWS) community, aiming to increase the level of automation for tasks like discovery, composition and invocation through semantic descriptions, is challenged by the large variety of Web APIs, {{particularly when it comes to}} automated invocation. Not only are Web APIs heterogeneous in the forms of elements essential to their invocation, such as address URI, but they also lack machine processable descriptions to address this heterogeneity [1]. hRESTS,...|$|R
50|$|Specific tools {{may be used}} to simulate, {{visualize}} {{and understand}} the performance of message passing on computer clusters. Before a large computer cluster is assembled, a trace-based simulator can use a small number of nodes to help predict the performance of message passing on larger configurations. Following test runs on a small number of nodes, the simulator reads the <b>execution</b> and <b>message</b> transfer log files and simulates the performance of the messaging subsystem when many more messages are exchanged between a much larger number of nodes.|$|R
40|$|Task: {{sequential}} {{program and}} its local storage Parallel computation: {{two or more}} tasks executing concurrently Communication channel: link between two tasks over which messages can be sent and received send is nonblocking: sending task resumes execution immediately receive is blocking: receiving task blocks <b>execution</b> until requested <b>message</b> is availabl...|$|R
2500|$|Inter-process {{communication}} works via a shared-nothing asynchronous {{message passing}} system: every process has a [...] "mailbox", a queue of messages {{that have been}} sent by other processes and not yet consumed. A process uses the receive primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed and removed from the mailbox the process resumes <b>execution.</b> A <b>message</b> may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.|$|R
5000|$|In 2006, Morris became CEO of the Boston Options Exchange Group, an {{automated}} equity options stock exchange. As CEO, Morris continued his engineering work, developing <b>execution</b> speed and <b>messaging</b> capacity for hedge funds and algorithmic traders. He also worked to extend equal opportunities to all market members, openly stating that: ...|$|R
40|$|Abstract. Prediction of speedup {{obtained}} from parallelization {{plays an important}} role in converting serial applications into parallel ones. Several parameters affect the execution time of an application. In this paper we experimentally and theoretically study the effect of some of these parameters on the <b>execution</b> time of <b>Message</b> Passing Interface based application...|$|R
50|$|Dante Cesa from Engadget, in his review, {{praised the}} “brilliance” in Apple's <b>execution</b> of <b>Messages.</b> He complimented the way Messages {{did not change}} the earlier SMS UI and would {{automatically}} convert an SMS/MMS to iMessage if the recipient was registered; and from iMessage to SMS/MMS if they stopped using the service. Dan Moren from Macworld was also in praise of Apple execution saying that “...there’s no having to explain to your less technically savvy friends how they can send you a free message instead of an SMS; it’s all done automatically.” This feature was widely praised.|$|R
40|$|Abstract- An {{effective}} resolution multiprocessor can be {{built from}} distributed processing, logic programming, and interface elements. Widely used, portable, components can be modularly composed into a portable parallel system that displays good resistance to premature obsolescence by software evolution. A virtual multiprocessor offering common message passing and configuration services integrates a dis-tributed mesh of sequential resolution engines. Users configure and control the resolution engines and virtual multiprocessor through a GUI using an embedded command language to drive its facilities. Prolog programs either explicitly control parallel <b>execution</b> through <b>message</b> passing or would {{have to rely on}} program transformation techniques to extract parallelism implicitly. Prolog PVM X Window TCL/TK Expect...|$|R
40|$|The {{traditional}} {{mutual exclusion}} problem in distributed systems occurs when only one process should access a shared resource. The mutual exclusion algorithm performance is calculated {{by the number}} of messages exchange per critical section <b>execution</b> called <b>Message</b> complexity and the delay between successive executions of the critical section, known as Synchronization delay. For designing mutual exclusion algorithm, one has to compromise either for the message complexity or for the synchronization delay. Hence a comparative study based on these two metrics is performed. An organized approach is essential to solve Mutual exclusion problem. This study will provide a suitable context for technical and clear assessment of existing algorithms...|$|R
50|$|This path is {{also known}} as the {{peripheral}} route to persuasion. Empirical research in the pure affect sphere suggests that advertising messages {{do not need to be}} informative to be effective, however consumers must like the advertising <b>execution</b> for the <b>message</b> to be effective. In addition, ad liking and advertiser credibility, may be especially important for corporate image advertising (compared to product-related advertising).|$|R
40|$|TR-COSC 08 / 95 Minix is a modular {{operating}} system {{designed for use}} in teaching of {{operating system}}s [3, 4]. In Minix, the operating system is structured as multiple independent processes. These processes communicate with each other, and with user mode processes, via message passing. While the modular structure of Minix simplifies the individual components, the message passing patterns that occur at run-time can be complex. The interaction network has been proposed {{as a way of}} representing all processing (process <b>execution</b> and <b>message</b> passing) that is the direct result of a single user input [2]. An interaction network is an acyclic digraph. Each vertex in the graph represents an event and each edge represents a period of thread <b>execution,</b> or <b>message</b> progression, between two events. Message patterns are shown very well in displays of interaction networks. In this paper, we use displays of interaction networks to illustrate some of the complex message patterns that occur in Minix. The interaction networks were all recorded for SunOS Minix, a version of Minix that has been ported to run as a SunOS process [1]. The interaction networks selected show the message passing that occurs in the following situations: Input of character that is part of a command line. Process creation and termination. Execution of a new process image. Two user processes communicating through a pipe. We show the value of the interaction network as a tool for understanding distributed processing by using it to provide insights into the messages exchanged in a number of situations that frequently arise in Minix...|$|R
40|$|This paper {{describes}} {{the design of}} a fault-tolerant group remote procedure call system based on the IS 0 RPC international standard ISO/IEC 11578. The system extends the original model providing detection and handling of orphan computations caused by process crashes or network partitioning. A group communication protocol supports replicated procedure <b>execution</b> preserving total <b>message</b> ordering among nodes. An X 500 directory service is also used to provide transparent service location...|$|R
50|$|Isabel Bucaram (Guayaquil, Ecuador) is the Director of VIP Planning Production, Public Relations and Marketing liaison for CNN en Español.1 Bucaram {{has been}} {{responsible}} for building and executing multilevel communications plans for CNN en Español’s property with measurable hallmarks. The key targets include general consumer media; specialized media; general news, business, technology, entertainment, internationals, relevant trade media, and opinion leaders, to position the company in the U.S. Hispanic and general market. Her role included developing communications strategy and overseeing <b>execution</b> of <b>messaging</b> related to the CNN en Español’ s business, talent, programming portfolio and industry position. She provides strategic direction and advisory to the executive management team via campaigns strategy, research, and daily editorial planning. She worked with Cala and now with Camilo.|$|R
30|$|Using {{parallel}} computing to decompose the computational workload {{to accelerate the}} <b>execution</b> time, the <b>message</b> passing interface (MPI) paradigm is well suited for handling computations when a task is divided into subtasks. For MPI programs, {{it is common to}} have most of the processors for computation, and a few processors or just one processor for task scheduling management. Generally, the manager is called the “master” and the rest are called the “workers” or “slaves” [15].|$|R
40|$|International audiencePartial {{correctness}} {{is perhaps}} the most important functional property of algo-rithmic programs. It can be broadly stated as: on all terminating executions, a given relation holds between a program's inputs and outputs. It has been formalised in several logics, from, e. g, Hoare logics [1] to temporal logics [2]. Partial correctness is also a relevant property for any class of specification that has a notion of terminating execution. For example, communication protocols have both nonterminating <b>executions</b> (all <b>messages</b> are forever lost and resent) and terminating <b>executions</b> (all <b>messages</b> sent are properly received). Here, partial correctness may, for instance, require that on all terminating executions, the set of messages corresponding to the transmission of a given file are received and the reception of every message is acknowledged. How can one naturally specify such generic partial-correctness properties, and how can one verify them in a maximally trustworthy manner? One possibility would be to use Hoare logics, but that solution is not optimal because Hoare logics intrinsically require programs (as their deduction rules focus on how program-instructions modify logical predicates), and we are targeting systems specified in formalisms that are not programs but more abstract models, e. g., one more naturally specifies communication protocols in some version of state-transition systems. Another possibility is to state partial-correctness properties in temporal logic and to use a model checker to prove the temporal formula on a state-transition system specification. This is a better solution, since it stays at a model-abstraction level; however, as we are aiming at trustworthy verification, this is not satisfactory as even in case of a successful verification, one's trust in the result is limited as one does not get independently-checkable verification certificates. Moreover, model checkers are limited to essentially finite-state systems (perhaps up to some data abstraction), a limitation we want to avoid...|$|R
40|$|Information {{has several}} {{meanings}} in everyday life. It is important, for example, {{to distinguish between}} a statistical notion of information linked to uncertainty and a semantic notion of information referring {{to the content of}} a message and the consequences it elicits. In biology, both aspects are useful: (i) The syntactic aspect deals with the molecular structure and the capacity of biological information carriers and (ii) the semantic aspect is concerned with the evaluation and <b>execution</b> of <b>messages.</b> “Meaning ” and “purpose” are difficult notions in evolutionary biology since they can only be defined and discussed a posteriori. The message, the machinery processing the message, and the context in which The concept of information has its origin in communication theory and science of computation. In biology the notion of information provide...|$|R
40|$|Message passing {{programs}} commonly use buffers {{to avoid}} unnecessary synchronizations {{and to improve}} performance by overlapping communication with computation. Unfortunately, using buffers makes the program no longer portable, potentially unable to complete on systems without {{a sufficient number of}} buffers. Effective buffer use entails that the minimum number needed for a safe execution be allocated. We explore a variety of problems related to buffer allocation for safe and efficient <b>execution</b> of <b>message</b> passing programs. We show that determining the minimum number of buffers or verifying a buffer assignment are intractable problems. However, we give a polynomial time algorithm to determine the minimum number of buffers needed to allow for asynchronous execution. We extend these results to several different buffering schemes, which in some cases make the problems tractable. Comment: 35 Pages, lots of figure...|$|R
40|$|The Message-Passing Interface (MPI) Standard defines an {{asynchronous}} {{message passing}} functionality through primitive nonblocking {{send and receive}} operations. Applications which use asynchronous message passing within MPI must assume responsibility for managing the MPI nonblocking send and receive primitives. For an application with dynamic interprocessor communication requirements, asynchronous message management is a complex task. The asynchronous message Management for MPI (MMPI) library described in this report has been developed to simplify dynamic asynchronous message passing with MPI. 1 Introduction A family of parallel applications developed at the Texas Institute for Computational and Applied Mathematics (TICAM) use large irregular distributed data structures. Runtime modification and redistribution of these data structures occurs at various phases during the applications' <b>execution.</b> The <b>message</b> passing patterns associated with accessing these irregular, dynamic, and distrib [...] ...|$|R
50|$|With {{asynchronous}} message passing, {{the sending}} {{system does not}} wait for a response. Continuing the function call analogy, asynchronous message passing would be a function call that returns immediately, without waiting for the called function to execute. Such an asynchronous function call would merely deliver the arguments, if any, to the called function, and tell the called function to execute, {{and then return to}} continue its own <b>execution.</b> Asynchronous <b>message</b> passing simply sends the message to the message bus. The bus stores the message until the receiving process requests messages sent to it. When the receiving process arrives at the result, it sends the result to the message bus, and the message bus holds the message until the original process (or some designated next process) picks up its messages from the message bus.|$|R
40|$|A {{protocol}} {{is given}} {{that allows a}} set of n servers to cooperate and produce an ElGamal ciphertext encrypted under one key from an ElGamal ciphertext encrypted under another, but without plaintext ever becoming available. The protocol is resilient to ⌊(n − 1) / 3 ⌋ of the servers being compromised and requires no assumptions about <b>execution</b> speeds or <b>message</b> delivery delays. Two new building blocks employed—a distributed blinding protocol and verifiable dual encryption proofs—could have uses beyond re-encryption protocols...|$|R
40|$|APSS, a {{proactive}} secret sharing (PSS) protocol for asynchronous systems, is derived and proved correct. A PSS protocol enables {{a set of}} secret shares to be periodically refreshed with a new, independent set, thereby thwarting so-called mobile adversary attacks. APSS tolerates certain attacks that PSS protocols for synchronous systems cannot, because protocols for asynchronous systems are inherently less vulnerable to denial of service attacks, which slow processor <b>execution</b> or impede <b>message</b> delivery and thus violate the defining assumptions of a synchronous system...|$|R
40|$|Abstract A {{protocol}} {{is given}} {{that allows a}} set of n servers to cooperate and produce an ElGamalciphertext encrypted under one key from an ElGamal ciphertext encrypted under another, but without plaintext ever becoming available. The protocol is resilient to b(n- 1) / 3 c of the serversbeing compromised and requires no assumptions about <b>execution</b> speeds or <b>message</b> delivery delays. Two new building blocks employed [...] a distributed blinding protocol and verifiable dualencryption proofs [...] could have uses beyond re-encryption protocols...|$|R
40|$|Abstract APSS, a {{proactive}} secret sharing (PSS) protocol for asynchronous systems, is derived and proved correct. A PSS protocol enables {{a set of}} secret shares to be periodically refreshed with a new, independent set, thereby thwarting so-called mobile adversary attacks. APSS tolerates certain attacks that PSS protocols for synchronous systems cannot, because protocols for asynchronous systems are inherently less vulnerable to denial of service attacks, which slow processor <b>execution</b> or impede <b>message</b> delivery and thus violate the defining assumptions of a synchronous system...|$|R
40|$|In {{multiprogramming}} systems, parallel processes {{compete for}} access to shared resources and cooperate by exchanging information. Semaphores are a useful means for controlling competition and synchronizing <b>execution</b> and inter-process <b>messages</b> are useful for communication. Neither semaphores nor inter-process message, however, are natural for solving both problems. This paper introduces a new approach, message classes, which combines and extends features of both semaphores and message passing. Using message classes, numerous mutual exclusion, producer/consumer, process communication, and resource allocation problems can be readily solved...|$|R
40|$|We {{outline the}} design {{principles}} underlying the ParPre library of parallel preconditioners. ParPre {{is a message}} passing library of distributed preconditioners for linear systems, written using MPI and Petsc. It comprises Schwarz methods, Schur system domain decompositioning, various parallel incomplete factorisations, and multilevel methods. 1 Introduction ParPre is a library for largely black-box generation of distributed memory parallel preconditioners, implemented using the MPI and Petsc libraries. In this paper, we describe the design issues resulting from our choice for black-box methods, and from the requirement of <b>execution</b> on <b>message</b> passing parallel computers. Although preconditioners are typically used to solve linear systems deriving from partial differential equations, that is, systems from differential operators on some physical domain, we take a black-box approach and disregard all knowledge of the domain and the operator. The ParPre preconditioners are then completely d [...] ...|$|R
40|$|Creating robust {{communication}} protocols for distributed systems is an inherently difficult task {{due to the}} many possible <b>executions</b> and <b>message</b> orderings. In this paper we describe a communication protocol development environment based on a discrete-event simulator. We have used this development environment in testing and debugging a fault-tolerant totally ordered multicast protocol suite that operates over a network of multiple interconnected local-area networks (LANs). Each LAN is simulated by a processor participating in the testbed, and a virtual gateway mechanism is used to interconnect the LANs. The resulting distributed simulation environment allows the developer to create reproducible test scenarios, to inject faults such as network partitions, to single-step protocol execution and, in general, to observe and analyze protocol behavior within the network. W. J. Chun is currently with Sun Microsystems, Inc., and D. A. Agarwal is with Lawrence Berkeley National Laboratory. This [...] ...|$|R
