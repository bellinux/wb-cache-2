0|388|Public
5000|$|<b>Application</b> <b>Entity.</b> A task {{within a}} DAP {{directly}} involved with exchanging application information with other DAPs.|$|R
50|$|Association Control Service Element (ACSE) is the OSI {{method for}} {{establishing}} a call between two application programs. ACSE checks the identities and contexts of the <b>application</b> <b>entities,</b> and could apply an authentication security check.|$|R
3000|$|... where wi is {{the weight}} 1 of the ith {{requirement}} of the <b>application</b> <b>entity,</b> f_i^d [...] is the application’s required value for the ith requirement and f_i^s [...] is the value for the service’s corresponding feature.|$|R
5000|$|The Application Protocol Convergence (APC) Layer, which accepts frames (usually in Ethernet format) {{from the}} upper layer (<b>Application</b> <b>Entity)</b> and encapsulates them into G.hn APC {{protocol}} data units (APDUs). The maximum payload of each APDU is 214 bytes.|$|R
50|$|The {{interface}} between the <b>Application</b> <b>Entity</b> and the Data Link Layer is called A-interface. The {{interface between}} the Data Link Layer {{and the physical}} layer is called Medium Independent Interface (MII). The interface between the physical layer and the actual transmission medium is called Medium Dependent Interface (MDI).|$|R
50|$|End-users <b>invoke</b> the <b>applications</b> {{from their}} browsers (for web applications), or {{directly}} from their mobile devices (e.g. for native iPhone applications).|$|R
5000|$|... a login {{service that}} will <b>invoke</b> your <b>application</b> callbacks {{to ask the}} user things like {{username}} and password. It returns a new Subject ...|$|R
50|$|The server or gateway <b>invokes</b> the <b>application</b> {{callable}} {{once for}} each request it receives from an HTTP client that {{is directed at}} the application.|$|R
50|$|Work {{management}}: Work management {{enables a}} resource adapter {{to do work}} (monitor network endpoints, <b>invoke</b> <b>application</b> components, and so on) by submitting work instances to an application server for execution. The application server dispatches threads to execute submitted work instances. This allows a resource adapter to avoid creating or managing threads directly, and allows an application server to efficiently pool threads and have more control over its runtime environment. The resource adapter can control the transaction context with which work instances are executed.|$|R
40|$|The {{last few}} years have shown a steady {{increase}} in applying graph-theoretic models to computational linguistics. In many NLP <b>applications,</b> <b>entities</b> can be naturally represented as nodes in a graph and relations between them can be represented as edges. There have been extensive research showing that graph-based representations of linguistic units such as words, sentences and documents give ris...|$|R
40|$|In {{a variety}} of {{conferencing}} scenarios, a local communication channel is desirable for conference-related information exchange between co- located but otherwise independent <b>application</b> <b>entities,</b> for example those taking part in application sessions that {{belong to the same}} conference. In loosely coupled conferences such a mechanism allows for coordination of <b>applications</b> <b>entities</b> to e. g. implement synchronization between media streams or to configure entities without user interaction. It {{can also be used to}} implement tightly coupled conferences enabling a conference controller to enforce conference wide control within a end system. The local Message Bus (Mbus) provides a means to achieve the Ott, et. al. Expires January 12, 2001 [Page 1] Internet-Draft A Message Bus for Local Coordination July 2000 necessary amount of coordination between co-located conferencing applications for virtually any type of conference as postulated in a a companion requirement document[11]. The Message Bus c [...] ...|$|R
5000|$|... oneM2M {{standard}} {{employs a}} simple horizontal, platform architecture that fits within a three layer model comprising applications, services and networks. In {{the first of}} these layers, <b>Application</b> <b>Entities</b> (AEs) reside within individual device and sensor applications. They provide a standardized interface to manage and interact with <b>applications.</b> Common Services <b>Entities</b> (CSEs) play a similar role in the services layer which resides between the applications layer and the in the network layer. The network layer ensures that devices and sensors and applications are able to function in a network-agnostic manner.|$|R
40|$|Recent {{years have}} shown an {{increased}} interest in bringing the field of graph theory into Natural Language Processing. In many NLP <b>applications</b> <b>entities</b> can be naturally represented as nodes in a graph and relations between them can be represented as edges. Recent {{research has shown that}} graphbased representations of linguistic units as diverse as words, sentences and documents give rise to nove...|$|R
5000|$|... to create, delete {{and modify}} <b>application</b> data (<b>entity</b> instance, {{attribute}} values, aggregates and their members) ...|$|R
40|$|Status of this Memo This memo {{provides}} {{information for the}} Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2004). This memo defines an architecture that enables {{the creation of an}} application service in which a data provider, a data consumer, and zero or more <b>application</b> <b>entities</b> cooperatively implement a data stream service...|$|R
50|$|Simple Gateway Monitoring Protocol (SGMP) {{defined in}} RFC 1028, allows {{commands}} {{to be issued}} to <b>application</b> protocol <b>entities</b> to set or retrieve values (integer or octet string types) for use in monitoring the gateways on which the <b>application</b> protocol <b>entities</b> reside. Messages are exchanged using UDP and utilize unreliable transport methods. Authentication takes place on UDP port 153. Some examples of {{things that can be}} monitored are listed below.|$|R
30|$|However, {{we already}} stated that only 3 TCAC modules are synchronized. Therefore, the SSs may have {{completely}} different clock values {{compared to their}} managing RSs. To address this issue, we propose to use the already computed delay value {{in order to synchronize}} the SS and its managing RS. In more detail, on receiving the first QoS-RSP message, the RS- 3 TCAC generates a QoS-Sync message and then sends it to its <b>application</b> <b>entity.</b>|$|R
40|$|This paper {{analyses}} {{the state}} of the art in workflow management systems and then presents a cooperative workflow management model based on agents (COWBA), which has three levels of architecture. The first is the process definition level that defines properties related to activities; the second is the workflow enactment service level that includes instantiated agent, cooperative agent and activity agent; the third is the user interface and <b>invoked</b> <b>application</b> level. By utilizing agent and object-oriented technology, a cooperative agent, instantiated agent and activity agent can be built on the basis of the object-oriented workflow meta-process model. Therefore, the ability of self-organization, self-learning and coordination has been enhancedIEE...|$|R
5000|$|US patent 5,838,906, titled [...] "Distributed {{hypermedia}} {{method for}} automatically <b>invoking</b> external <b>application</b> providing interaction and display of embedded objects within a hypermedia document," [...] was filed on October 17, 1994 and granted on November 17, 1998.|$|R
40|$|Abstract—Quality of Service (QoS) is {{becoming}} {{an integral part of}} currently ubiquitous distributed multimedia applications. How-ever, before any QoS-related mechanisms and policies, such as ad-mission control, resource reservation, enforcement, and adapta-tion, can be <b>invoked,</b> <b>applications</b> need to express their QoS re-quirements. A considerable amount of research has been done in QoS-aware Application Programming Interface (API) design and QoS specification language development for multimedia systems. In this paper, we present an extensive survey of existing QoS spec-ification languages, and a taxonomy to classify and compare them. The paper provides readers with a global and insightful knowl-edge of this important area; knowing how to evaluate QoS lan-guages, and what aspects are most relevant when designing new languages. I...|$|R
25|$|The US {{spectrum}} is managed {{either by the}} FCC for non-governmental applications or by the NTIA for governmental applications. For shared <b>application,</b> both <b>entities</b> should agree.|$|R
30|$|These {{two modes}} of {{operation}} cover the necessary features and functionality to enable support for both COMPSs [27] enabled applications (packaged as Java Tomcat Web Services) invoked via the Programming Model Plug-in and more generic cloud applications (such as a n-tier web <b>application)</b> <b>invoked</b> via the <b>Application</b> Packager Plug-in, while minimising the time to create an image. The remainder of this paper concentrates on the more flexible and challenging online mode.|$|R
40|$|In {{distributed}} systems, {{group communication}} among multiple entities {{is required in}} addition to the conventional one-to-one communication. Group communication protocols provide multiple entities with reliable data transmission service, i. e. messages are delivered to all the destination entities in the group. It is also important to guarantee that every <b>application</b> <b>entity</b> can receive messages in a well-defined order in the presence of multiple entities sending messages. This paper discusses logical properties of the group communication. We present communication protocols to provide various kinds of group communication services and evaluate the protocols...|$|R
40|$|Workflow Management Systems (WfMS) {{have been}} adopted as a {{practical}} solution to automate the execution of business processes {{in order to use}} resources efficiently and make organizations more competitive. Workflow activities usually have a very coarse granularity, are long-lived and business process dependent. The semantics of activities, including the semantics of associated <b>invoked</b> <b>applications</b> and resources, are not known by the WfMS. As a result, inconsistencies may arise from the concurrent use of shared applications/resources by the workflow activities. Thus, we propose a workflow activity synchronization mechanism to deal with these inconsistencies using a component-based solution. We present the specification of a software component called Synchronization Manager Component, a prototype implementation and a case study carried out {{within the context of the}} WorkToDo environment...|$|R
5000|$|The PCS leverages {{software}} separation {{to enable}} <b>application</b> layer <b>entities</b> to enforce, manage, and control application layer security policies {{in such a}} manner that the application layer security policies are: ...|$|R
40|$|Distributed systems form an {{integral}} part of human life—from ATMs to the Domain Name Service. Typical distributed systems consist of distributed services interacting through messages. Failures in these systems are often the causes of huge financial loss or human catastrophes. Efficient fault detection and diagnosis of cascaded non fail-silent failures is extremely challenging because of legacy code, black-box nature of <b>application</b> <b>entities,</b> scalability and state space explosion. Current error detection and diagnosis protocols suffer from {{one or more of the}} following problems—very specific to one application, require intrusive changes to the application, lack of scalability, impose additional load on the application, are offline and cannot detect (or diagnose) the failures at runtime. ^ In this thesis, we propose Monitor, a scalable, autonomous, fault detection and diagnosis framework. The Monitor only observes the external messages between the components of the application and is unaware of any internal transition of the <b>application</b> <b>entities.</b> The Monitor uses a rule base of allowable behavior and does fast matching of incoming messages. We propose a sampling approach which adjusts a sampling rate in accordance with the incoming rate of packets such that the breakdown in the Monitor capacity is avoided. We use a distributed deployment of Monitors across the Purdue WAN to demonstrate its effectiveness. We compare the performance of the Monitor in diagnosing faults with Pinpoint, the state-of-the-art diagnosis approach. ...|$|R
40|$|When using today’s {{productivity}} applications, people {{rely heavily}} on graphical controls (GUI widgets) as the way to <b>invoke</b> <b>application</b> functions and to obtain feedback. Yet {{we all know that}} certain controls can be difficult or tedious to find and use. As an alternative, a customizable physical interface lets an end-user easily bind a modest number of physical controls to similar graphical counterparts. The user can then use the physical control to invoke the corresponding graphical control’s function, or to display its graphical state in a physical form. To show how customizable physical interfaces work, we present examples that illustrate how our combined phidgets ® and widget tap packages are used to link existing application widgets to physical controls. While promising, our implementation prompts a number of issues relevant to others pursuing interface customization...|$|R
5000|$|SOAP (Simple Object Access Protocol) is the {{preferred}} means by which an <b>application</b> <b>invokes</b> a web service. The protocol itself is written in XML.|$|R
40|$|We {{present an}} {{approach}} and architecture for implementing scalable and maintainable {{clinical decision support}} at the Partners HealthCare System. The architecture integrates a business rules engine that executes declarative if-then rules stored in a rule-base referencing objects and methods in a business object model. The rules engine executes object methods by invoking services implemented on the clinical data repository. Specialized inferences that support classification of data and instances into classes are identified and an approach to implement these inferences using an OWL based ontology engine is presented. Alternative representations of these specialized inferences as if-then rules or OWL axioms are explored {{and their impact on}} the scalability and maintenance of the system is presented. Architectural alternatives for integration of clinical decision support functionality with the <b>invoking</b> <b>application</b> and the underlying clinical data repository; and their associated trade-offs are discussed and presented...|$|R
40|$|Abstract—In this paper, we {{investigate}} {{the benefits of}} adding autonomic capabilities inside the operating system. We have developed and implemented a solution that focuses on three use cases (continuous file permission compliance, dynamic disk cleanup, and accidental removal protection) for the file system, and encapsulates all the respective file system monitoring, trou-bleshooting and error remedial operations in a Linux kernel module. The main benefits of this approach are the capability to detect issues instantly when they occur, and fix these issues transparently, with the <b>invoking</b> <b>applications</b> being unaware of their occurence. These capabilities are not present in external agent architectures, including contemporary configuration man-agement systems, like Puppet, Chef, or CFEngine. We have built a prototype and evaluated {{the performance of the}} most resource intensive use case, dynamic disk cleanup, using the FileBench file system benchmarking tool. I...|$|R
40|$|GUIDE is an {{interactive}} graphical system for designing and generating graphical user interfaces. It provides flexibility {{to the system}} designer while minimizing the amount of code which the designer must write. The GUIDE methodology includes the notions of 2 ̆ 2 tool, 2 ̆ 2 2 ̆ 2 task, 2 ̆ 2 and 2 ̆ 2 context. 2 ̆ 2 GUIDE encourages designers to tailor their systems to individual users by inclusion of 2 ̆ 2 user profiles, 2 ̆ 2 allowing different control paths based on the user 2 ̆ 7 s characteristics. GUIDE also provides a method for <b>invoking</b> <b>application</b> routines with parameters. Parameters may be based on user inputs and are computed at invocation time. Help messages are created along with the objects to which they refer. GUIDE handles the overhead required to display help messages...|$|R
40|$|In {{this paper}} we {{describe}} a Palm system call logging tool called Palmist. Palmist allows the practitioner to selectively collect statistics {{such as the}} system call <b>invoked,</b> <b>application</b> that <b>invoked</b> the system call, {{the time of the}} call and the call arguments. The logging mechanism adds a latency of about 10 msec per call to collect the log. On an average, the system uses about 20 bytes of memory on the PDA to store the log record. The mechanism has limitations in collecting logs for system calls that are needed by the collection mechanism itself. Our logging mechanism works for about 80 % (707 of 881) of Palm OS 3. 5 system calls. Our system can be utilized by system developers to customize their application behavior to optimize system parameters such as energy consumption, ease of use etc. 1...|$|R
5000|$|The PieBuyer object, an Agent, {{contains}} a single method, , the standard startup method used by all Agents. Simply creating a PieBuyer and invoking {{it will cause}} the [...] method to be called, in a fashion similar to the [...] operation found in most OO languages, although this method is called after setup. The * replaces what is more commonly implemented as [...] or , referring to the object itself, {{in this case the}} PieBuyer agent. The code basically says that when it is created, the object should send itself (*.go) to the location sent to it during creation (*.destination). Once there, it should tell the matching place object, in this case a PieSeller, to sellPie. When that command is complete, the agent will return to its place of origin. The <b>invoking</b> <b>application</b> can then examine the results by inspecting the myPie variable.|$|R
40|$|With the {{emergence}} of web-based social and information <b>applications,</b> <b>entity</b> similarity search in information networks, aiming to find entities with high similarity to a given query entity, has gained wide attention. However, due to the diverse semantic meanings in heterogeneous information networks, which contain multi-typed entities and relationships, similarity measurement can be ambiguous without context. In this paper, we investigate entity similarity search and the resulting ambiguity problems in heterogeneous information networks. We propose to use a meta-path-based ranking model ensemble to represent semantic meanings for similarity queries, exploit {{the possibility of using}} using user-guidance to understand users query. Experiments on real-world datasets show that our framework significantly outperforms competitor methods...|$|R
40|$|Abstract. The {{challenging}} {{context of}} Ambient Assisted Living (AAL) {{demands for a}} service-oriented technological shift {{in the field of}} ubiqui-tous computing. Recently, novel paradigms have been proposed, most of them envisioning arbitrary pairs of peer <b>application</b> <b>entities</b> communi-cating and providing services directly with each other and to users. In order to enforce these paradigms even to systems which include devices with limited processing and storage resources, lightweight middleware components are required. JXTA-SOAP, a portable software component supporting peer-to-peer sharing of Web Services, is a suitable solution. We illustrate its features and a possible deployment to enable AAL ser-vices. Key words: ubiquitous computing, ambient assisted living, services, peer-to-peer...|$|R
40|$|Abstract. The synergy of {{ubiquitous}} computing and service-oriented technologies {{may lead to}} efficient, pervasive and dependable solutions in the challenging context of emergency management. Recently, novel paradigms have been proposed, most of them envisioning arbitrary pairs of peer <b>application</b> <b>entities</b> communicating and providing services di-rectly {{with each other and}} to users. In order to enforce these paradigms even to systems which include devices with limited processing and stor-age resources, lightweight middleware components are required. We il-lustrate how this is provided by JXTA-SOAP, a portable software com-ponent supporting peer-to-peer sharing of Web Services, and we show how {{it can be used to}} implement disaster response software applications...|$|R
