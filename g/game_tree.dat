513|375|Public
25|$|The <b>game</b> <b>tree</b> size is {{the total}} number of {{possible}} games that can be played: the number of leaf nodes in the <b>game</b> <b>tree</b> rooted at the game's initial position.|$|E
25|$|The <b>game</b> <b>tree</b> is {{typically}} vastly {{larger than the}} state space because the same positions can occur in many games by making moves in a different order (for example, in a tic-tac-toe game with two X and one O on the board, this position could have been reached in two different ways depending on where the first X was placed). An upper bound for {{the size of the}} <b>game</b> <b>tree</b> can sometimes be computed by simplifying the game in a way that only increases the size of the <b>game</b> <b>tree</b> (for example, by allowing illegal moves) until it becomes tractable.|$|E
25|$|Combinatorial {{game theory}} has several ways of {{measuring}} game complexity. This article describes five of them: state-space complexity, <b>game</b> <b>tree</b> size, decision complexity, game-tree complexity, and computational complexity.|$|E
5000|$|For solving <b>game</b> <b>trees</b> with proof-number search {{family of}} algorithms, <b>game</b> <b>trees</b> {{are to be}} mapped to and-or trees. MAX-nodes (i.e. maximizing player to move) are {{represented}} as OR nodes, MIN-nodes map to AND nodes. The mapping is possible, when the search is done with only a binary goal, which usually is [...] "player to move wins the game".|$|R
40|$|The {{main goal}} {{of this paper is}} to {{describe}} a new pruning method for solving decision <b>trees</b> and <b>game</b> <b>trees.</b> The pruning method for decision trees suggests a slight variant of decision trees that we call scenario trees. In scenario trees, we do not need a conditional probability for each edge emanating from a chance node. Instead, we require a joint probability for each path from the root node to a leaf node. We compare the pruning method to the traditional rollback method for decision <b>trees</b> and <b>game</b> <b>trees.</b> For problems that require Bayesian revision of probabilities, a scenario tree representation with the pruning method is more efficient than a decision tree representation with the rollback method. For <b>game</b> <b>trees,</b> the pruning method is more efficient than the rollback method. ...|$|R
5000|$|Root parallelization, i.e. {{building}} independent <b>game</b> <b>trees</b> {{in parallel}} {{and making the}} move basing on the root-level branches of all these trees.|$|R
25|$|However, {{for games}} where {{the number of}} moves is not limited (for example {{by the size of}} the board, or by a rule about {{repetition}} of position) the <b>game</b> <b>tree</b> is infinite.|$|E
25|$|A Go endgame {{begins when}} {{the board is}} divided into areas that are {{isolated}} from all other local areas by living stones, such that each local area has a polynomial size canonical <b>game</b> <b>tree.</b> In the language of combinatorial game theory, it happens when a Go game decomposes into a sum of subgames with polynomial size canonical game trees.|$|E
25|$|A simple {{upper bound}} for {{the size of the}} <b>game</b> <b>tree</b> is 9! = 362,880. (There are nine {{positions}} for the first move, eight for the second, and so on.) This includes illegal games that continue after one side has won. A more careful count gives 255,168 possible games. When rotations and reflections of positions are considered the same, there are only 26,830 possible games.|$|E
50|$|Quiescence {{search is}} an {{algorithm}} typically {{used to evaluate}} minimax <b>game</b> <b>trees</b> in game-playing computer programs. It is a remedy for the horizon problem faced by AI engines for various games like chess and Go.|$|R
40|$|Abstract. Forming winning {{strategies}} for board games requires good heuristics and fast search algorithms on <b>game</b> <b>trees.</b> High branching factors {{and the need}} for looking deeper in <b>game</b> <b>trees</b> are overwhelming, even for today’s high performance PC’s. Therefore, better game-plays are only available with better algorithms and heuristics for an ordinary player, not with faster machines. Abalone is a recent two-person strategy game. Initial evaluations point out that the branching factor is larger than the chess. In this paper, a new heuristic used by a simple intelligent agent for playing Abalone game, named as ABLA is introduced. ABLA’s performance is promising as compared to existing computerized Abalone players. ...|$|R
40|$|Use of minimal windows {{enhances the}} aB {{algorithm}} in practical applications {{as well as}} in the search of artificially constructed <b>game</b> <b>trees.</b> Nevertheless, there exists no theoretical model to measure the strengths and weaknesses of minimal window search. In particular, it is not known which tree ordering properties are favorable for minimal window search. This paper presents a quantitative analysis of minimal window search based on recursive equations which assess the influence of static node values on the dynamic search process. The analytical model is computationally simple, easily extendible and gives a realistic estimate of the expected search time for averagely ordered <b>game</b> <b>trees.</b> ...|$|R
25|$|The {{computational}} {{complexity of}} tic-tac-toe {{depends on how}} it is generalized. A natural generalization is to m,n,k-games: played on an m by n board with winner being {{the first player to}} get k in a row. It is immediately clear that this game can be solved in DSPACE(mn) by searching the entire <b>game</b> <b>tree.</b> This places it in the important complexity class PSPACE. With some more work it can be shown to be PSPACE-complete.|$|E
25|$|Because of the {{simplicity}} of tic-tac-toe, it is often used as a pedagogical tool for teaching the concepts of good sportsmanship and the branch of artificial intelligence that deals with the searching of game trees. It is straightforward to write a computer program to play tic-tac-toe perfectly, to enumerate the 765 essentially different positions (the state space complexity), or the 26,830 possible games up to rotations and reflections (the <b>game</b> <b>tree</b> complexity) on this space.|$|E
25|$|Capt. Walter Lingo, of LaRue, Ohio, {{developed}} the Oorang Airedale strain. The name {{came from a}} line of bench champions, headed by King Oorang 11, a dog which {{was said to have}} been the finest utility dog. King could retrieve waterfowl and upland <b>game,</b> <b>tree</b> raccoons, drive cattle and sheep, and bay mountain lions, bears, and wolves. King even fought one of the best fighting bull terriers, and killed his opponent. He also trained in Red Cross work, and served the American Expeditionary Force at the front in France.|$|E
40|$|For {{the class}} of <b>tree</b> <b>games,</b> a new {{solution}} called the average tree solution has been proposed recently. We provide a characterization of this solution. This characterization underlines an important difference, in terms of symmetric treatment of the agents, between the average tree solution and the Myerson value for {{the class of}} <b>tree</b> <b>games.</b> <b>tree,</b> graph <b>games,</b> Myerson value, Shapley value...|$|R
40|$|Abstract. Alpha-beta pruning is the {{algorithm}} {{of choice for}} searching <b>game</b> <b>trees</b> with position values taken from a totally ordered set, such as the set of real numbers. We generalize to <b>game</b> <b>trees</b> with position values taken from a partially ordered set, and prove necessary and sufficient conditions for alpha-beta pruning to be valid. Specifically, we show that shallow pruning is possible {{if and only if}} the value set is a lattice, and full alphabeta pruning is possible if and only if the value set is a distributive lattice. We show that the resulting technique leads to substantial improvements in the speed of algorithms dealing with card play in contract bridge. 1...|$|R
40|$|Making {{efficient}} AI {{models for}} games with imperfect {{information can be}} a particular challenge. Considering {{the large number of}} possible moves and the incorporated uncertainties building <b>game</b> <b>trees</b> for these <b>games</b> becomes very difficult due to the exponential growth of the number of nodes at each level. This effort is focused on presenting a method of combined Case Based Reasoning (CBR) with AI Planning which drastically reduces the size of <b>game</b> <b>trees.</b> Instead of looking at all possible combinations we can focus only on the moves that lead us to specific strategies in effect discarding meaningless moves. These strategies are selected by finding similarities to cases in the CBR database. The strategies are formed by a set of desired goals. The AI planning is responsible for creating a plan to reach these goals. The plan is basically a set of moves that brings the player to this goal. By following these steps and not regarding the vast number of other possible moves the model develops <b>Game</b> <b>Trees</b> which grows slower so they can be built with more feature moves restricted by the same amount of memory...|$|R
25|$|Given {{the rules}} of any two-person game with {{a finite number of}} positions, one can always trivially {{construct}} a minimax algorithm that would exhaustively traverse the <b>game</b> <b>tree.</b> However, since for many non-trivial games such an algorithm would require an infeasible amount of time to generate a move in a given position, a game is not considered to be solved weakly or strongly unless the algorithm can be run by existing hardware in a reasonable time. Many algorithms rely on a huge pre-generated database, and are effectively nothing more.|$|E
2500|$|Each {{terminal}} (leaf) node of the <b>game</b> <b>tree</b> has an n-tuple of payoffs, meaning {{there is}} one payoff for each player {{at the end of}} every possible play ...|$|E
2500|$|Trivially {{strongly}} solvable {{because of}} the small <b>game</b> <b>tree.</b> [...] The game is a draw if no mistakes are made, with no mistake possible on the opening move.|$|E
25|$|This {{is proven}} by {{converting}} the Quantified Boolean Formula problem, which is PSPACE-complete, into a sum of small (with polynomial size canonical <b>game</b> <b>trees)</b> Go subgames. Note {{that the paper}} does not prove that Go endgames are in PSPACE, so {{they might not be}} PSPACE-complete.|$|R
40|$|In {{recent years}} Monte-Carlo Tree Search (MCTS) {{has become a}} popular and {{effective}} search method in games, surpassing traditional αβ methods in many domains. The question of why MCTS does better in some domains than in others remains, however, relatively open. In here we identify some general properties that are encountered in <b>game</b> <b>trees</b> and measure how these properties affect the success of MCTS. We do this by running it on custom-made games {{that allow us to}} parameterize various game properties in order for trends to be discovered. Our experiments show how MCTS can favor either deep, wide or balanced <b>game</b> <b>trees.</b> They also show how the level of game progression relates to playing strength and how disruptive Optimistic Move can be...|$|R
40|$|This paper {{draws upon}} {{experiences}} gained {{during the development}} of programs which search chess <b>game</b> <b>trees.</b> Over the past decade major enhancements to the alpha-beta algorithm have been developed by people building game-playing programs, {{and many of these}} methods will be surveyed and compared here. The balance of the paper contains a study of contemporary methods for searching chess <b>game</b> <b>trees</b> in parallel, using an arbitrary number of independent processors. To make efficient use of these processors, one must have a clear understanding of the basic properties of the trees actually traversed when alpha-beta cutoffs occur. This paper provides such insights and concludes with a brief description of our own refinement to a standard parallel search algorithm for this problem...|$|R
2500|$|A rough {{estimate}} {{of the number of}} nodes in the <b>game</b> <b>tree</b> can be obtained as an exponential function of the average branching factor and the average number of plies in a game thus: b'd where d is the ply depth and b is the branching factor. [...] In Hex, the average branching factor {{is a function of the}} ply depth. It has been stated that the average branching factor is about 100; that implies an average ply depth of 43 (there will be 121 open spaces on the board when the first player is to make his first move, and 79 when he is to make his 22nd move, the 43rd ply - the average number of open spaces, i.e. branching factor, during the game is (121+120+...+79)/43=100). [...] Therefore, the <b>game</b> <b>tree</b> size has an upper bound of approximately 10043 = 1086.. [...] The bound includes some number of illegal positions due to playing on when there is a complete chain for one player or the other, as well as excludes legal positions for games longer than 43 ply. [...] Another researcher obtained a state space estimate of 1057 and a <b>game</b> <b>tree</b> size of 1098 using an upper limit of 50 plies for the game. This compares to 10123 node <b>game</b> <b>tree</b> size of chess.|$|E
2500|$|A {{partition}} of the non-terminal nodes of the <b>game</b> <b>tree</b> in n+1 subsets, {{one for each}} (rational) player, and with a special subset for a fictitious player called Chance (or Nature). Each player's subset of nodes {{is referred to as}} the [...] "nodes of the player". (A game of complete information thus has an empty set of Chance nodes.) ...|$|E
2500|$|Combinatorial games include {{well-known}} games such as chess, checkers, and Go, {{which are}} regarded as non-trivial, and tic-tac-toe, which is considered as trivial {{in the sense of}} being [...] "easy to solve". Some combinatorial games may also have an unbounded playing area, such as infinite chess. In CGT, the moves in these and other games are represented as a <b>game</b> <b>tree.</b>|$|E
50|$|Using {{a binary}} goal (e.g. first player wins the <b>game),</b> <b>game</b> <b>trees</b> of two-person perfect-information games can be mapped to an and-or tree. Maximizing nodes become OR-nodes, {{minimizing}} nodes are mapped to AND-nodes. For all nodes proof and disproof numbers are stored, and updated during the search.|$|R
40|$|Abstract- Many {{enhancements}} to the alpha-beta algorithm {{have been}} proposed to help {{reduce the size of}} minimax trees. A recent enhancement, the history heuristic, is described that improves the order in which branches are considered at interior nodes. A comprehensive set of experiments is reported which tries all combinations of enhancements to determine which one yields the best performance. Previous work on assessing their performance has concentrated on the benefits of individual enhancements or a few combina-tions. However, each enhancement should not be taken in isolation; one would like to find the combination that provides the greatest reduction in tree size. Results indicate that the history heuristic and transposition tables significantly out-perform other alpha-beta enhancements in application generated <b>game</b> <b>trees.</b> For trees up to depth 8, when taken together, they account for over 99 % of the possible reductions in tree size, with the other enhancements yielding insignificant gains. Index Terms- Alpha-beta search, minimax search, <b>game</b> <b>trees,</b> history heuristic, transposition tables, minimal window search, killer heuristic...|$|R
40|$|Abstract. The max n {{algorithm}} (Luckhardt and Irani, 1986) {{for playing}} multiplayer games is flexible, {{but there are}} only limited techniques for pruning max n <b>game</b> <b>trees.</b> This paper presents other theoretical limitations of the max n algorithm, namely that tie-breaking strategies are crucial to max n, and that zerowindow search is not possible in max n <b>game</b> <b>trees.</b> We also present quantitative results derived from playing max n and the paranoid algorithm (Sturtevant and Korf, 2000) against each other on various multi-player game domains, showing that paranoid widely outperforms max n in Chinese Checkers, by a lesser amount in Hearts {{and that they are}} evenly matched in Spades. We also confirm the expected results for the asymptotic branching factor improvements of the paranoid algorithm over max n. ...|$|R
2500|$|Defection by {{the first}} player is the unique subgame perfect {{equilibrium}} and required by any Nash equilibrium, it can be established by backward induction. [...] Suppose two players reach {{the final round of}} the game; the second player will do better by defecting and taking a slightly larger share of the pot. [...] Since we suppose the second player will defect, the first player does better by defecting in the second to last round, taking a slightly higher payoff than she would have received by allowing the second player to defect in the last round. [...] But knowing this, the second player ought to defect in the third to last round, taking a slightly higher payoff than he would have received by allowing the first player to defect in the second to last round. [...] This reasoning proceeds backwards through the <b>game</b> <b>tree</b> until one concludes that the best action is for the first player to defect in the first round. [...] The same reasoning can apply to any node in the <b>game</b> <b>tree.</b>|$|E
2500|$|By contrast, [...] "strong" [...] proofs often proceed by brute force—using a {{computer}} to exhaustively search a <b>game</b> <b>tree</b> {{to figure out what}} would happen if perfect play were realized. The resulting proof gives an optimal strategy for every possible position on the board. However, these proofs are not as helpful in understanding deeper reasons why some games are solvable as a draw, and other, seemingly very similar games are solvable as a win.|$|E
2500|$|A perfect {{information}} two-player {{game over}} a <b>game</b> <b>tree</b> (as defined in combinatorial game theory and artificial intelligence) {{can be represented}} as an extensive form game with outcomes (i.e. win, lose, or draw). Examples of such games include tic-tac-toe, chess, and infinite chess. A game over an expectminimax tree, like that of backgammon, has no imperfect information (all information sets are singletons) but has moves of chance. For example, poker has both moves of chance (the cards being dealt), and imperfect information (the cards secretly held by other players).|$|E
40|$|This is an {{investigation}} of the Combinatorial Perfect Information Game Beans and Pots. The Conway number system will be explained and used to calculate values of Beans and Pots configurations. Known theorems are included, as well as new results. The Appendices contain <b>game</b> <b>trees</b> as well as calculations for a number of configurations...|$|R
5000|$|<b>Game</b> Score: <b>Tree</b> Cutters: 2 Tree Planters: 13 Punishment: Blue Stained ...|$|R
50|$|NegaMax {{operates}} {{on the same}} <b>game</b> <b>trees</b> as those used with the minimax search algorithm. Each node and root node in the <b>tree</b> are <b>game</b> states (such as game board configuration) of a two player game. Transitions to child nodes represent moves available to a player who's about to play from a given node.|$|R
