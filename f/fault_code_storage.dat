0|627|Public
50|$|The 1987 Charger GLHS uses 1986 {{electronics}} & <b>fault</b> <b>codes.</b>|$|R
25|$|Simple <b>fault</b> <b>code</b> readers/reset {{tools are}} mostly {{aimed at the}} {{consumer}} level.|$|R
5000|$|Ability {{to write}} data back to vehicle, e.g. to clear <b>fault</b> <b>codes.</b>|$|R
5000|$|Simple <b>fault</b> <b>code</b> readers/reset {{tools are}} mostly {{aimed at the}} {{consumer}} level.|$|R
50|$|OBDuino {{does not}} display or reset engine <b>fault</b> <b>codes</b> (which are {{available}} over the OBD interface).|$|R
5000|$|When {{the system}} detects a fault, a {{corresponding}} <b>fault</b> <b>code</b> {{is stored in}} the ECU's nonvolatile memory. <b>Fault</b> <b>codes</b> may only be cleared by commanding the ECU via the diagnostic port. Testing of MEMS equipped cars was originally possible with the [...] "COBEST", [...] "Microcheck", and [...] "Microtune" [...] test equipment provided to Rover dealerships and service centers. The Rover TestBook system later became available to provide similar functionality as well.|$|R
5000|$|... #Subtitle level 2: Separating source <b>code</b> <b>storage</b> and {{presentation}} ...|$|R
5000|$|... in {{software}} engineering, type of faults: specification faults, design <b>faults,</b> and <b>code</b> <b>faults</b> ...|$|R
5000|$|Certain <b>fault</b> <b>codes</b> is set (Faulty {{throttle}} position sensor (TPS), pressure sensor, pre ignition/pinging signal or charging pressure regulation) or low battery voltage.|$|R
40|$|A long-standing body of {{research}} supports the existence of separable short- and long-term memory systems, relying on phonological and semantic codes, respectively. The aim {{of the current study}} was to measure the contribution of long-term knowledge to short-term memory performance by looking for evidence of phonologically and semantically <b>coded</b> <b>storage</b> within a short-term recognition task, among developmental samples. Each experimental trial presented 4 -item lists. In Experiment 1 typically developing children aged 5 to 6 years old showed evidence of phonologically <b>coded</b> <b>storage</b> across all 4 serial positions, but evidence of semantically <b>coded</b> <b>storage</b> at Serial Positions 1 and 2. In a further experiment, a group of individuals with Down syndrome was investigated as a test case that might be expected to use semantic coding to support short-term storage, but these participants showed no evidence of semantically <b>coded</b> <b>storage</b> and evidenced phonologically <b>coded</b> <b>storage</b> only at Serial Position 4, suggesting that individuals with Down syndrome have a verbal short-term memory capacity of 1 item. Our results suggest that previous evidence of semantic effects on “short-term memory performance” does not reflect semantic coding in short-term memory itself, and provide an experimental method for researchers wishing to take a relatively pure measure of verbal short-term memory capacity, in cases where rehearsal is unlikely...|$|R
40|$|Current {{projections}} {{indicate that}} the worldwide data center (DC) industry will require a quadrupling of capacity by the year 2020 [1]. Modern DCs can manage up {{to hundreds of thousands}} of servers, storing petabytes of data and concurrently serving thousands of users. <b>Coded</b> <b>storage</b> is a strategy proposed in the last decade, which may be able to improve performance of these growing systems. Broadly, we classify storage systems into those that can be modeled as static, or as traffic-agnostic, and those that are modeled as high-traffic networks, which experience significant traffic congestion. Prior work on <b>coded</b> <b>storage</b> has focused on code construction and traffic-agnostic performance analysis. " Traffic-agnostic coded storage: Significant work exists on code construction and on traffic-agnostic performance analysis of <b>coded</b> <b>storage</b> at the network level. Intuitive examples, problem frameworks, performance bounds, and a plethora of practical codes exist in this setting. The vast majority of work in this area considers <b>coded</b> <b>storage</b> for single data repair events, in which drives permanently fail, as per the seminal work of Dimakis et al. [2, 3], and recent work considers probabilistic drive failures, where failures are independent of incoming traffic. " <b>Coded</b> <b>storage</b> in high-traffic networks: This thesis proposes <b>coded</b> <b>storage</b> as a traffic congestion mitigation strategy, and seeks to explore the potential benefits in doing so. To the author's knowledge, this is the first thesis on <b>coded</b> <b>storage</b> in high-traffic networks, by which we mean networks with significant traffic congestion. When this thesis began, this sub-area had no prior work. In particular, this area had no intuitive examples, problem formulations, models, nor results. We will argue that some kind of queueing model can be applied to high-traffic networks that use <b>coded</b> <b>storage.</b> Strictly speaking, such queueing models could also be applied to networks without significant traffic congestion, but they may not be necessary for analytical purposes. As of May 2014, a handful of papers on <b>coded</b> <b>storage</b> to reduce traffic congestion have been published by various authors. Each paper will be referenced and discussed in the most closely relevant technical thesis chapter. This thesis combines academic literature from queueing theory, <b>coding</b> theory, and <b>storage</b> systems engineering. Broadly, in each technical chapter, contributions are threefold: " We develop models and tools for high-traffic networks that allow tractable analysis of <b>coded</b> <b>storage.</b> " Using various queueing models, we explore mechanisms by which <b>coded</b> <b>storage</b> could improve user management, and quantify this potential. The <b>coded</b> <b>storage</b> schemes we propose code across chunks as they are commonly laid out on drives today, and are generally application-agnostic. Coding structures are not optimized (with the exception of Chapter 5). " In addition, in Chapter 5, we explore <b>coded</b> <b>storage</b> structures that are application-specific, and propose a multi-resolution coding approach for video streaming. Metrics considered include blocking probability, saturation probability, average delay, and maximum stable throughput. No claim is made about the best or most general metric. Keeping results DC-centric and relatively application-agnostic also allows us to make fewer application-specific assumptions, which may make it easier for our insights to be applied to a larger set of DC types, such as single- and multi-tenant DCs, or those with and without outsourced server operations. Further, this thesis focuses on understanding the mechanisms for <b>coded</b> <b>storage</b> gains, and quantifying them, i. e., it is a first cut at answering the question of "is it worth doing <b>coded</b> <b>storage</b> in high-traffic networks at all?" This is in contrast to a different but related problem that is to optimize coding structures, independent of absolute performance. To guide the reader through the thesis, see Appendix A for a summary roadmap of technical assumptions made in each thesis chapter. Specific contributions divided by chapter follow. In Chapter 1 we introduce the reader to <b>coded</b> <b>storage</b> and high-traffic networks. We review the current storage technological landscape, detail related work, and present the intuition behind this thesis. In Chapter 2 we introduce the reader to queueing analysis for <b>coded</b> <b>storage.</b> We present a blocking drive model, which can provide simple and exact analytical solutions to blocking performance in various drive networks. We analyze the blocking performance of uncoded and <b>coded</b> <b>storage</b> systems, and demonstrate how to apply such analysis to striped file systems. This analysis holds when incoming read requests are for individual chunks and when the performance metric is system blocking probability. Blocking probability savings of up to an order of magnitude are observed. Building upon and extending Chapter 2, in Chapter 3 we present a system model for bulk, as opposed to individual read requests. In this model, individual drives have the blocking characteristics of Chapter 1, and because arrivals come in bulk, we consider the average scheduling delay as our performance metric, and for analytical tractability we consider only one chunk per drive. We analyze a block-based code and a stochastic scheduling algorithm which is beneficial in the case of continuous chunk read patterns. In particular, we demonstrate that in systems with continuous chunk reads, when drive blocking is either independent of traffic or caused by traffic congestion, block <b>coded</b> <b>storage</b> can reduce average download time by 10 - 66 %, given modern system parameters. However, a distinction should be made between systems with continuous and those with interrupted chunk read patterns. For interrupted chunk read systems, given an allocation algorithm that performs well for continuous reads, block <b>coded</b> <b>storage</b> performance can be worse than replication; numerical illustrations show relative losses over 66 %. In Chapter 4 we extend Chapter 3 to consider optimal scheduling and rate region (RR) analysis. We develop a queued cross-bar network (QCN) model {{that can be used to}} map a storage network with arbitrary file layouts across drives into a moded queueing network. All results in this chapter assume drives with deterministic read times. Our QCN model also considers drive-to-user transmission traffic patterns, which prior chapters do not. Chapter 4 presents an offline scheduling algorithm that is rate optimal for uncoded <b>storage.</b> For <b>coded</b> <b>storage,</b> we develop a RR upper bound, for which we provide an intuitive interpretation, and we show that this bound is achievable for particular code structures. Numerical results illustrate that the RR of <b>coded</b> <b>storage</b> can subsume that of uncoded storage, with increases in volume averaging 50 % across traffic patterns. Chapter 5 departs from prior chapters in considering application-specific structures. We explore alternative coding structures and propose a multi-resolution (MR) <b>coded</b> <b>storage</b> system for video streaming. These results hold for drives with general service distributions. Due to inherent asymmetry in MR video traffic statistics, in this chapter we optimize chunk layout strategies as a function of incoming traffic statistics. We are interested in saturation probability as our performance metric, a variation on blocking probability that accounts for asymmetry in MR demand statistics. Numerical results illustrate an order of magnitude reduction in saturation probability. Chapter 6 wraps up the thesis by taking a systems engineering view of the potential energy and operating cost financial savings that <b>coded</b> <b>storage</b> may have in enterprise DCs owing to blocking probability savings. Finally, Chapter 7 discusses potential future research extensions, and concludes the thesis. by Ulric John Ferner. Thesis: Ph. D., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2014. Cataloged from PDF version of thesis. Includes bibliographical references (pages 167 - 175) ...|$|R
40|$|Coding {{techniques}} may {{be useful}} for data center data survivability {{as well as for}} reducing traffic congestion. We present a queued cross-bar network (QCN) method {{that can be used for}} traffic analysis of both replication/uncoded and <b>coded</b> <b>storage</b> systems. We develop a framework for generating QCN rate regions (RRs) by analyzing their conflict graph stable set polytopes (SSPs). In doing so, we apply recent results from graph theory on the characterization of particular graph SSPs. We characterize the SSP of QCN conflict graphs under a variety of traffic patterns, allowing for their efficient RR computation. For uncoded systems, we show how to compute RRs and find rate optimal scheduling algorithms. For <b>coded</b> <b>storage,</b> we develop a RR upper bound, for which we provide an intuitive interpretation. We show that the <b>coded</b> <b>storage</b> RR upper bound is achievable in certain coded systems in which drives store sufficient coded information, as well in certain dynamic coding systems. Numerical illustrations show that <b>coded</b> <b>storage</b> can result in gains in RR volume of approximately 50 %, averaged across traffic patterns...|$|R
5000|$|Scangauge is a {{commercial}} trip computer using the OBD interface. In {{addition to the}} trip-computer-style features in OBDuino, the Scangauge also includes features for displaying and resetting engine <b>fault</b> <b>codes.</b>|$|R
5000|$|ATmega169V AVR 8-bit CPU, {{including}} 16 Kbyte of Flash {{memory for}} <b>code</b> <b>storage</b> and 512 bytes of EEPROM for data storage ...|$|R
40|$|Error {{detectable}} {{and error}} correctable coding in Hamming space was researched to discover possible <b>fault</b> tolerant <b>coding</b> constellations, which can implement Boolean logic with fault tolerant property. Basic logic operators of the Boolean algebra {{were developed to}} apply <b>fault</b> tolerant <b>coding</b> in the logic circuits. It was shown that application of three-bit <b>fault</b> tolerant <b>codes</b> have provided the digital system skill of auto-recovery without need for designing additional-fault tolerance mechanisms...|$|R
2500|$|Mode $0A lists emission-related [...] "permanent" [...] {{diagnostic}} trouble codes stored. As per CARB, any diagnostic trouble {{codes that}} is commanding MIL on and stored into non-volatile memory shall be logged as a permanent <b>fault</b> <b>code.</b>|$|R
40|$|Scania’s {{vehicles}} are market leaders {{when it comes}} to quality. Despite this, more or less serious errors occasionally occur in the vehicles. These errors generate the so called <b>fault</b> <b>codes.</b> The more you know about the errors the easier it is to prevent them and fix them. It would therefore be an advantage to know the position of the vehicles when the <b>fault</b> <b>codes</b> (DTCs) are created. The purpose of this master thesis is to create a method to determine the position of DTCs and then use these positions to present information about the environment in which the DTCs are created. This is then visualized in a demonstrator. DTCs and positions are gathered from two separate systems which are used by different departments at Scania. The two closest positions are taken for a chosen <b>fault</b> <b>code.</b> Linear interpolation is used to determine the DTC’s position from these positions. However, some complement cases were used {{due to the lack of}} data and bad matching in data, in addition to the interpolation method. Data were collected from both internal (Scania) and external sources. The data includes operational data from the vehicles, weather and traffic data, UV and altitude data. A demonstrator was created in form of two interfaces. One focuses on a specific occurrence of a DTC and presents it in form of a geographical plot. The other one focuses on all occurrences of a DTC and presents them in form of data tables and statistics. Whether the method for determining the position of a DTC is accurate enough depends on how and for what purpose the position is used. A more accurate determination of DTCs positions requires better map data and a more sophisticated interpolation method. However, the used environmental data and created demonstrator are to be considered as a good start for the useage of <b>fault</b> <b>code</b> positioning. There are possibilities to continue with this thesis work, yet again depending on what the purpose is. Some approaches for future work are suggested.  fault <b>code,</b> <b>fault</b> <b>code</b> positioning, demonstrator, environmental dat...|$|R
50|$|Specialty {{flash memory}} {{includes}} the Concurrent SuperFlash (CSF), Many-Time Programmable and Small-Sector Flash (SSF) families. Available in commercial, extended and industrial grade temperatures, {{these products are}} marketed for space and power-constrained <b>code</b> <b>storage</b> applications.|$|R
5000|$|The 14CUX {{is capable}} of storing {{diagnostic}} trouble codes in a 32-byte segment of its internal memory that is maintained (even while vehicle ignition is off) by applying 5VDC (regulated down from 12VDC from the vehicle's battery.) Because of this maintainer voltage, the ECU is always drawing {{a small amount of}} current. <b>Fault</b> <b>codes</b> can be cleared by disconnecting the battery {{for a short period of}} time. Diagnostic trouble codes can be retrieved from the ECU via a small electronic display referred to as the [...] "Fault Code Display Unit". This unit contains two seven-segment displays that together show a single two-digit <b>fault</b> <b>code.</b> When connected to the 14CUX wiring harness, the ECU detects its presence and reconfigures the RDATA and TDATA lines to work as an I2C link to this device.|$|R
25|$|Each of the EOBD <b>fault</b> <b>codes</b> {{consists}} of five characters: a letter, followed by four numbers. The letter {{refers to the}} system being interrogated e.g. Pxxxx would refer to the powertrain system. The next character would be a 0 if complies to the EOBD standard. So it should look like P0xxx.|$|R
50|$|The light {{generally}} has two stages: steady (indicating a minor fault) and flashing (indicating a severe fault). When the MIL is lit, the {{engine control unit}} stores a <b>fault</b> <b>code</b> related to the malfunction, which can be retrieved - although in many models this {{requires the use of}} a scan tool.|$|R
50|$|The Fairchild VES was the world's first CPU-based {{video game}} console, {{introducing}} the cartridge-based game <b>code</b> <b>storage</b> format. It {{was released by}} Fairchild Semiconductor in November 1976. When Atari released their VCS the next year, Fairchild quickly renamed it to the Fairchild Channel F.|$|R
40|$|Abstract. Configuration of {{on board}} {{diagnostics}} system and diagnostic communication module ELM 327 were introduced. According to elements of ELM 327 and Keyword 2000 protocols, an OBDII diagnostic procedure was developed based on LabVIEW program. It was conducted on {{a certain type of}} K-Line communication engine. These procedures laid a foundation for engine testing to read real-time data and <b>fault</b> <b>codes...</b>|$|R
50|$|Cam timers don't {{have the}} {{greater degree of}} {{flexibility}} that CPU-based controllers provide. As well as offering more wash program variations, a CPU based washing machine controller can respond to malfunctions, automatically initiate test cycles, reducing manufacturing costs, and provide <b>fault</b> <b>codes</b> in the field, again reducing repair costs, and providing feedback on real world failure rates and causes. All of these reduce manufacture and business costs.|$|R
50|$|The Motronic 1.1 and 1.3 {{systems are}} largely similar, the main {{improvement}} being the increased diagnostic capabilities of Motronic 1.3. The 1.3 ECM can store many more detailed <b>fault</b> <b>codes</b> than 1.1, {{and has a}} permanent 12-volt feed from the vehicle's battery which allows it to log intermittent faults in memory across several trips. Motronic 1.1 can only advise of a few currently-occurring faults.|$|R
5000|$|The SAML 1.1 SOAP binding {{is built}} on top of version 1.1 of SOAP (the {{numbering}} is purely coincidental). A SAML requester wraps a SAML [...] element within {{the body of a}} SOAP message. Similarly, a SAML responder returns a SAML [...] element within the body of a returned SOAP message. If there is an error, the responder returns a SOAP <b>fault</b> <b>code</b> instead.|$|R
5000|$|They {{specify the}} {{services}} provided by the escrow agent beyond a simple custody of the source code. Specialised agents may, for instance, verify that the source <b>code</b> <b>storage</b> media is readable, or even build the software based on the source code, verifying that its features match the binary version used by the licensee.|$|R
40|$|Abstract: This paper briefly {{introduces}} {{remote monitoring}} {{system of the}} electric vehicle, and digital hardware system of vehicle information terminal development. This system consists of the core processing module, power supply module, CAN communication module, serial communication module, communication module and 3 G communication module. All modules work together, they realize the function of remotely gathering data of vehicle under various operating conditions together, and diagnose fault through {{the analysis of the}} <b>fault</b> <b>code</b> and the diagnosis...|$|R
40|$|This text {{wants to}} compare the main {{differences}} between the <b>Faults</b> <b>Code</b> and Coexistence Code of the Province of Córdoba (Argentina) taking young people as empirical subjects of reflection, which are the most affected by the regulations. From the content analysis and critical discourse analysis, {{the differences between the}} two standards were found. Here are detailed only some of them that allow us to infer changes in the penal system maintaining the violation of rights of young people...|$|R
40|$|Abstract. According to {{principles}} of aero-engine fault diagnosis and flight data,this paper introduces a fault diagnosis method based on reformative ART 1 neural network. After data pretreatment,it uses four-circumscription and quadratic-estimation to build <b>fault</b> <b>codes</b> and eliminate inveracious fault,and also ameliorate input layer of ART 1 network. So this network can diagnoses not only gusty fault,but also gradual fault. It is proved that this method has high precision,strong restrain against noises,and {{low rate of}} inveracious alarms. Foreword With in-depth development in comprehensive integrated control of flight-propeller system for modern airplane, especially battle plane, flight data play a bigger role than ever. By availing and {{making full use of}} information on operating condition of airplane reflected by flight data, potential airplane fault can be discovered and removed in early stage with favorable safety reliability and redundancy for longer lifecycle of airplane and aero-engine on board. However, due to impact from external foul flight environment, aging of relevant sensors, as well as causes such as random noise interference in fight data recording system and etc, certain error exists with flight data. To deal with it, a set of <b>fault</b> <b>code</b> extracting method is designed herein, an...|$|R
40|$|In {{this paper}} we {{describe}} a well documented, compactly <b>coded,</b> <b>storage</b> efficient, thoroughly tested, {{and easy to}} use set of FORTRAN IV subroutines for use in Kalman filter or least-squares applications. The package contains both the UDU covariance factorization and the square root information filter algorithms developed at the Jet Propulsion Laboratory. Numerical reliability of the algorithms is a key feature of the package...|$|R
40|$|Methods {{for data}} analysis, data {{compression}} including universal <b>coding,</b> <b>storage</b> and retrieval on random access storage devices, and display were developed and implemented on the GSFC Interdata computer. The original 64 bit per frequency band representation {{was reduced to}} 10 bits through source coding/universal coding, a compression ratio of 6. 4, prior to storage. Rapid encoding/decoding was achieved by the algorithms used so that rapid random access is retained...|$|R
3000|$|The {{insufficient}} retention {{prevents the}} resistive {{random access memory}} from intended application, such as <b>code</b> <b>storage,</b> FPGA, encryption, and others. The retention characteristics of high resistance state (HRS) switching from different low resistance state (LRS) were investigated in a 1 -kb array with one transistor and one resistor configuration. The HRS degradation was found strongly dependent on the LRS: the lower the resistance of the LRS (R [...]...|$|R
5000|$|The {{fact that}} the JMS {{instruction}} used the word just before the code of the subroutine to deposit the return address prevented reentrancy and recursion without additional work by the programmer. It also {{made it difficult to}} use ROM with the PDP-8 because read-write return-address storage was commingled with read-only <b>code</b> <b>storage</b> in the address space. Programs intended to be placed into ROMs approached this problem in several ways: ...|$|R
40|$|Euler {{diagrams}} (EDs) are {{a popular}} means of visualizing set-based relationships. We describe {{the advancement of}} EulerSketch, based on a novel encoding of EDs. In partic- ular, EulerSketch allows a user to sketch and interact with EDs and automatically produce a code representation for them. It also enables <b>code</b> <b>storage</b> and retrieval and permits to automatically re-draw an ED from its code representa- tion. Some features are inspired by earlier works [4, 6, 3]...|$|R
40|$|In today's epoch, most of {{the means}} of secure data and <b>code</b> <b>storage</b> and {{distribution}} rely on using cryptographic Schemes, such as certificates or encryption keys. This paper is devoted to the security and attack aspects of cryptographic techniques with new symmetric key algorithm TORDES. This algorithm is proposed to achieve the different goals of security i. e., Availability, Confidentiality and Integrity. We will also discuss the security threats in this algorithm...|$|R
