122|31|Public
25|$|SpiderMonkey is a {{cross-platform}} engine {{written in}} C++ which implements ECMAScript, a standard developed from JavaScript. It comprises an interpreter, several just-in-time compilers, a <b>decompiler</b> and a garbage collector. Products which embed SpiderMonkey include Firefox, Thunderbird, SeaMonkey, and many non-Mozilla applications.|$|E
2500|$|Managed CIL {{bytecode}} {{is easier}} to reverse-engineer than native code, unless obfuscated. [...] <b>decompiler</b> programs enable developers with no reverse-engineering skills to view the source code behind unobfuscated [...]NET assemblies. In contrast, apps compiled to native machine code are much harder to reverse-engineer, and source code is almost never produced successfully, mainly because of compiler optimizations and lack of reflection. This creates concerns {{in the business community}} over the possible loss of trade secrets and the bypassing of license control mechanisms. To mitigate this, Microsoft has included Dotfuscator Community Edition with Visual Studio [...]NET since 2002. Third-party obfuscation tools are also available from vendors such as VMware, V.i. Labs, Xenocode, and Red Gate Software. Method-level encryption tools for [...]NET code are available from vendors such as SafeNet.|$|E
50|$|Jad (Java <b>Decompiler)</b> is, , an unmaintained <b>decompiler</b> for the Java {{programming}} language.Jad {{provides a}} command-line user interface to extract source code from class files.|$|E
40|$|Java {{developers}} {{often use}} <b>decompilers</b> to aid reverse engineering and obfuscators to prevent it. <b>Decompilers</b> translate low-level class files to Java source and can pro-duce “good ” output. Obfuscators transform class files into semantically-equivalent versions that are either: (1) diffi-cult to decompile, or (2) decompilable, but result in “hard-to-understand ” Java source. We present {{a set of}} metrics developed to quantify the ef-fectiveness of <b>decompilers</b> and obfuscators. The metrics in-clude some selective size and counting metrics and an ex-pression complexity metric. We have applied these metrics to evaluate a collection of <b>decompilers</b> and obfuscators. By quantitatively comparing original Java source against de-compiled and obfuscated code respectively, we show which <b>decompilers</b> produce “good ” code and whether obfusca-tions result in “hard-to-understand ” code. ...|$|R
50|$|<b>Decompilers</b> can {{be thought}} of as {{composed}} of a series of phases each of which contributes specific aspects of the overall decompilation process.|$|R
40|$|Abstract—Decompilation of Java {{bytecode}} is the act {{of transforming}} Java bytecode to Java source code. Although easier than that of decompilation of machine code, problems still arise in Java bytecode decompilation. These include type inference of local variables and exception-handling. Since the last such evaluation (2003) several new commercial, free and open-source Java <b>decompilers</b> have appeared {{and some of the}} older ones have been updated. In this paper, we evaluate the currently available Java bytecode <b>decompilers</b> using an extension of the criteria that were used in the original study. Although there has been a slight improvement since this study, it was found that none passed all the tests, each of which were designed to target different problem areas. We give reasons for this lack of success and suggest methods by which future Java bytecode <b>decompilers</b> could be improved. Keywords-java; bytecode; decompilation; I...|$|R
50|$|JD (Java <b>Decompiler)</b> is a <b>Decompiler</b> for the Java {{programming}} language. JD {{is provided}} as a GUI tool {{as well as}} in the form of plug-ins for the Eclipse (JD-Eclipse) and IntelliJ IDEA (JD-IntelliJ) integrated development environments.|$|E
50|$|The {{final phase}} is the {{generation}} of the high level code in {{the back end of}} the <b>decompiler.</b> Just as a compiler may have several back ends for generating machine code for different architectures, a <b>decompiler</b> may have several back ends for generating high level code in different high level languages.|$|E
5000|$|An HP48 {{emulator}} - <b>decompiler</b> for Unix/Linux or Windows (using Cygwin) by Paul Courbis ...|$|E
2500|$|Assemblies {{compiled}} {{using the}} C++/CLI compiler are termed mixed-mode assemblies, since they contain native and managed code {{in the same}} DLL. Such assemblies are more complex to reverse engineer, since [...]NET <b>decompilers</b> such as [...]NET Reflector reveal only the managed code.|$|R
40|$|High-level bytecodes used by {{object-oriented}} managed execution environments {{make it easy}} to decompile them. This paper {{studies the}} reasons that make bytecode <b>decompilers</b> such efficient and presents basic obfuscation techniques as an efficient protection against binary code reverse engineering. basic obfuscation, reverse engineering, object-oriented execution...|$|R
5000|$|As {{with all}} {{intermediate}} language compiled code such as Flash and Microsoft [...]NET, once an SWF file is saved locally, {{it can be}} decompiled into its source code and assets. Some <b>decompilers</b> are capable of nearly full reconstruction of the original source file, down to the actual code that was used during creation (although results vary on a case-by-case basis).|$|R
50|$|Mocha is a Java <b>decompiler,</b> {{which allows}} programmers to {{translate}} a program's bytecode into source code.|$|E
5000|$|A {{program that}} {{translates}} from a low-level language {{to a higher}} level one is a <b>decompiler.</b>|$|E
50|$|JEB 2.3 {{introduced}} {{native code}} decompilers. The current beta version ships with a MIPS 32-bit interactive <b>decompiler.</b>|$|E
40|$|Decompilation of Java {{bytecode}} is the act {{of transforming}} Java bytecode to Java source code. Although easier than that of decompilation of machine code, problems still arise in Java bytecode decompilation. These include type inference of local variables and exception-handling. We evaluate the currently available Java bytecode <b>decompilers</b> using {{an extension of the}} criteria used in a previous original study. Although there has been a slight improvement since this study, it was found that none passed all of the tests, each of which were designed to target different problem areas. Decompilation and other attacks on software are problems for the software industry, with the global revenue loss due to software piracy estimated to be more than $ 50 billion in 2008. We present a survey of a specific software protection techniques- software watermarking- in the context of Java <b>decompilers.</b> Software watermarks can be used to prove ownership of stolen software. However, many watermarks are easily removed rendering their protection useless...|$|R
40|$|In general, Java {{bytecode}} {{programs can}} be decompiled into source code. From the standpoint of protecting intellectual properties, bytecode should not be cracked by third person. We propose a technique including several methods to obfuscate bytecode by code-scrambling. Our technique makes bytecode illegible for man and resilient to many existing <b>decompilers.</b> We have also implemented a simple obfuscator and measured execution overheads of our obfuscated programs. ...|$|R
5000|$|Any {{solution}} that combines programs at runtime has to provide views that segregate them properly {{to maintain the}} programmer's segregated model. Java's bytecode support for multiple source files enables any debugger to step through a properly woven [...]class file in a source editor. However, some third-party <b>decompilers</b> cannot process woven code because they expect code produced by Javac rather than all supported bytecode forms (see also [...] "Criticism", below).|$|R
50|$|The {{internal}} function {{library was}} programmed in BASIC itself {{and could be}} extracted with a BASIC <b>decompiler.</b>|$|E
50|$|Although JEB is branded as a <b>decompiler,</b> it also {{provides}} a full APK view (manifest, resources, certificates, etc.).|$|E
50|$|The {{following}} {{is an example of}} ActionScript 3.0 code generated by a <b>decompiler</b> program, before and after obfuscation.|$|E
40|$|Reverse {{engineering}} {{is defined by}} Chikosfky and Cross as the process of analyzing a subject system to identify the system’s components and their relationships, and to create representations of the system in another form or {{at a higher level}} of abstraction. The process of reverse {{engineering is}} accomplished using specific tools that, for the 32 -bit Microsoft Windows environment, are categorized as hex editors, disassemblers/debuggers, <b>decompilers,</b> or related technologies such as code obfuscators, unpackers, and PE editors. An evaluation of each tool is provided that identifies its domain of applicability and usability...|$|R
40|$|Software {{applications}} which {{run in a}} compromised {{environment and}} perform sensitive operations, such as providing a secure communication channel between two individuals, require protection {{in order to prevent}} them being run by an unauthorised adversary. This paper looks at how to build in some protection against an adversary who wishes to modify an application so that it no longer authenticates the user before running. This protection works against a casual observer, that is someone who has access only to standard debugging tools, visualisation tools, and <b>decompilers.</b> The tricks given in the paper do not work against an all powerful adversary. The paper treats the problem of protecting the code fragments dealing with authentication as equivalent to encrypting plaintext without revealing the secret key...|$|R
40|$|Different {{software}} tools, such as <b>decompilers,</b> code quality analyzers, recognizers of packed executable files, authorship analyzers, and malware detectors, {{search for}} patterns in binary code. The use of machine learning algorithms, trained with programs {{taken from the}} huge number of applications in the existing open source code repositories, allows finding patterns not detected with the manual approach. To this end, we have created a versatile platform for the automatic extraction of patterns from native code, capable of processing big binary files. Its implementation has been parallelized, providing important runtime performance benefits for multicore architectures. Compared to the single-processor execution, the average performance improvement obtained with the best configuration is 3. 5 factors over the maximum theoretical gain of 4 factors...|$|R
5000|$|To make VBT <b>decompiler</b> (to read VBT.dat binary {{format and}} convert into human {{readable}} form - already done), ...|$|E
50|$|Krakatau Bytecode Tools, {{currently}} contains three tools: a <b>decompiler</b> and disassembler for Java classfiles and an assembler {{to create}} classfiles.|$|E
50|$|In {{opposition}} to the decompilers, ActionScript obfuscators have been introduced, which transform code into a form that breaks <b>decompiler</b> output while preserving the functionality {{and structure of the}} program. Higher-quality obfuscators implement lexical transformations such as identifier renaming, control flow transformation, and data abstraction transformation which collectively make it harder for decompilers to generate output likely to be useful to a human. Less robust obfuscators insert traps for decompilers. Such obfuscators either cause the <b>decompiler</b> software to crash unexpectedly or to generate unintelligible source code.|$|E
40|$|This thesis {{deals with}} reverse {{engineering}} of Android and Java. It contains a description of existing tools and techniques, including techniques of defense. The first part {{is focused on}} available research about the topic. The next part discusses usage of reverse engineering in software development. The next chapters describe Android operating system and concept of a virtual machine on both platforms. Both kinds of architectures are compared (register-based vs stack-based machine). Core {{of the work is}} focused on static analysis (content of APK file, disassembling, decompilation). Available <b>decompilers</b> of class and dex files are compared. Testing is made with various versions of Java. The final chapter contains techniques and tools of defense against reverse engineering including a description of pros and cons. Two popular obfuscators are tested (Proguard, DashO) ...|$|R
40|$|Analysis of {{malicious}} software {{is an essential}} task in computer security, it provides the necessary understanding to devise effective countermeasures and mitigation strategies. The level of sophistication and complexity of current malware continues to evolve significantly, as the recently discovered "Regin" malware family strikingly illustrates. This complexity makes the already tedious and time-consuming task of manual malware reverse engineering even more difficult and challenging. Decompilation can accelerate this process by enabling analysts to reason about a high-level, more abstract from of binary code. While significant advances have been made, state-of-the-art <b>decompilers</b> still produce very complex and unreadable code and malware analysts still frequently go back to analyzing the assembly code. In this paper, we present several semantics-preserving code transformations to make the decompiled code more readable, thus helping malware analysts understand and combat malware...|$|R
40|$|The {{inherent}} {{differences between}} C++ and Java programs dictate that {{the methods used}} for reverse engineering their compiled executables will be language-specific. This paper looks at the history of <b>decompilers,</b> disassemblers, and obfuscators in C++ and Java and presents {{the current state of the}} art for binary reverse engineering. An experimentation framework for evaluating tools is described, including methodology, benchmark programs, metrics, and reverse engineering tasks. Preliminary results of experiments conducted so far to assess the capability of a small select set of chosen popular tools are given. These results reveal language-specific differences in the feasibility of the binary reverse engineering tasks on input programs with varying degrees of obfuscation (e. g., stripped vs. unstripped binaries). In addition, the results reveal the relative effort required to complete a task and an assessment of the value of the tools and techniques...|$|R
50|$|Although not a compiler, the Boomerang <b>decompiler</b> uses SSA form in its {{internal}} representation. SSA {{is used to}} simplify expression propagation, identifying parameters and returns, preservation analysis, and more.|$|E
50|$|Decompilation using a <b>decompiler,</b> {{a process}} that tries, with varying results, to {{recreate}} the source code in some high-level language for a program only available in machine code or bytecode.|$|E
5000|$|He built Anakrino, a <b>decompiler</b> for [...]NET {{available}} in 2002. He co-authored a paper published in 2005 about a [...] "Java runtime event specification and monitoring library." [...] He {{has worked with}} Brian Fox on multiple freelance projects.|$|E
5000|$|Up to 1990 {{there were}} {{quite a few}} {{proposed}} methods for eliminating gotos from existing program, while preserving most of their structure. The various approaches to this problem also proposed several notions of equivalence, which are stricter than simply Turing equivalence, {{in order to avoid}} output like the folk theorem discussed above. The strictness of the chosen notion of equivalence dictates the minimal set of control flow structures needed. The 1988 JACM paper by Lyle Ramshaw surveys the field up to that point, as well proposing its own method. Ramshaw's algorithm was used for example in some Java <b>decompilers</b> because the Java virtual machine code has branch instructions with targets expressed as offsets, but the high-level Java language only has multi-level [...] and [...] statements. Ammarguellat (1992) proposed a transformation method that goes back to enforcing single-exit.|$|R
40|$|Abstract. Analysis or {{verification}} of low-level code {{is useful for}} minimizing the disconnect between what is verified and what is actually executed and is necessary when source code is unavailable or is, say, intermingled with inline assembly. We present a modular framework for building pipelines of cooperating <b>decompilers</b> that gradually lift {{the level of the}} language to something appropriate for source-level tools. Each decompilation stage contains an abstract interpreter that encapsulates its findings about the program by translating the program into a higherlevel intermediate language. We provide evidence for the modularity of this framework through the implementation of multiple decompilation pipelines for both x 86 and MIPS assembly produced by gcc, gcj, and coolc (a compiler for a pedagogical Java-like language) that share several low-level components. Finally, we discuss our experimental results that apply the BLAST model checker for C and the Cqual analyzer to decompiled assembly. ...|$|R
40|$|Reverse {{engineering}} of {{binary code}} {{is an essential}} step for malware analysis. However, it is a tedious and time-consuming task. Decompilation facilitates this process by transforming machine code into a high-level representation that is more concise and easier to understand. This paper describes REcompile, an efficient and extensible decompilation framework. REcompile uses the static single assignment form (SSA) as its intermediate representation and performs three main classes of analysis. Data flow analysis removes machine-specific details from code and transforms it into a concise high-level form. Type analysis finds variable types based on how those variables are used in code. Control flow analysis identifies high-level control structures such as conditionals, loops, and switch statements. These steps enable REcompile to produce well-readable decompiled code. The overall evaluation, using real programs and malware samples, shows that REcompile achieves a comparable {{and in many cases}} better performance than state-of-the-art <b>decompilers...</b>|$|R
