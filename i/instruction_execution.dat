280|302|Public
5|$|A {{word in the}} computer's memory {{could be}} read, written, or refreshed, in 360microseconds. An {{instruction}} took four times as long to execute as accessing a word from memory, giving an <b>instruction</b> <b>execution</b> rate of about 700 per second. The main store was refreshed continuously, a process which took 20milliseconds to complete, as each of the SSEM's 32words had to be read and then refreshed in sequence.|$|E
25|$|In theory, real-mode {{applications}} {{could be}} directly executed in 16-bit protected mode if certain rules (newly proposed {{with the introduction}} of the 80286) were followed; however, as many DOS programs did not conform to those rules, protected mode was not widely used until the appearance of its successor, the 32-bit Intel 80386, which was designed to go back and forth between modes easily and to provide an emulation of real mode within protected mode. When Intel designed the 286, it was not designed to be able to multitask real-mode applications; real mode was intended to be a simple way for a bootstrap loader to prepare the system and then switch to protected mode; essentially, in protected mode the 80286 was designed to be a new processor with many similarities to its predecessors, while real mode on the 80286 was offered for smaller-scale systems that could benefit from a more advanced version of the 80186 CPU core, with advantages such as higher clock rates, faster <b>instruction</b> <b>execution</b> (measured in clock cycles), and unmultiplexed buses, but not the 24-bit (16 MB) memory space.|$|E
2500|$|In user mode, {{programs}} {{usually have}} access to a restricted set of microprocessor instructions, and generally cannot execute any instructions that could potentially cause disruption to the system's operation. [...] In supervisor mode, <b>instruction</b> <b>execution</b> restrictions are typically removed, allowing the kernel unrestricted access to all machine resources.|$|E
5000|$|Pause switch. The switch {{activated}} hardware {{suspension of}} <b>instructions</b> <b>execution</b> in the processor. The pause switch was useful for pausing games, {{most of which}} {{did not have a}} pause key. A few games, however, did not behave gracefully after being returned from the suspension, because the programmable hardware timer built into the processor chip was still running while the <b>instructions</b> <b>execution</b> was suspended. BK also had a software shortkey combination for pause.|$|R
50|$|Since {{instructions}} inside loops can {{be executed}} repeatedly, it is frequently {{not possible to}} give a bound {{on the number of}} <b>instruction</b> <b>executions</b> that will be impacted by a loop optimization. This presents challenges when reasoning about the correctness and benefits of a loop optimization, specifically the representations of the computation being optimized and the optimization(s) being performed.|$|R
40|$|A {{well-known}} code transformation {{for improving}} the execution performance of a program is loop unrolling. The most obvious benefit of unrolling a loop is that the transformed loop usually, but not always, requires fewer <b>instruction</b> <b>executions</b> than the original loop. The reduction in <b>instruction</b> <b>executions</b> comes from two sources: the number of branch instructions executed is reduced, and the index variable is modified fewer times. In addition, for architectures with features designed to exploit instruction-level parallelism, loop unrolling can expose greater levels of instructionlevel parallelism. Loop unrolling is an effective code transformation often improving the execution performance of programs that {{spend much of their}} execution time in loops by ten to thirty percent. Possibly because of the effectiveness of a simple application of loop unrolling, it has not been studied as extensively as other code improvements such as register allocation or common subexpression elimination. The r [...] ...|$|R
2500|$|The ARMv7 {{architecture}} defines basic debug {{facilities at}} an architectural level. These include breakpoints, watchpoints and <b>instruction</b> <b>execution</b> in a [...] "Debug Mode"; similar facilities were also available with EmbeddedICE. Both [...] "halt mode" [...] and [...] "monitor" [...] mode debugging are supported. The actual transport mechanism used {{to access the}} debug facilities is not architecturally specified, but implementations generally include JTAG support.|$|E
5000|$|Program Trace Macrocell and CoreSight Design Kit for non-intrusive tracing of <b>instruction</b> <b>execution.</b>|$|E
5000|$|Program Trace Macrocell and CoreSight Design Kit for {{unobtrusive}} tracing of <b>instruction</b> <b>execution</b> ...|$|E
50|$|Techniques {{to predict}} out-of-order {{execution}} and prepare subsequent <b>instructions</b> for <b>execution</b> outside the regular sequence.|$|R
40|$|This {{paper is}} devoted to the design of dual core crypto {{processor}} for executing both Prime field and binaryfield instructions. The proposed design is specifically optimized for Field programmable gate array(FPGA) platform. Combination of two different field(prime field GF(p) and Binary field GF(2 m)) <b>instructions</b> <b>execution</b> is analysed. The design is implemented in Spartan 3 E and virtex 5. Both theperformance results are compared. The implementation result shows the execution of parallelism usingdual field instruction...|$|R
40|$|International audienceMicroprocessors {{performances}} {{have increased}} {{by more than}} five orders of magnitude in the last three decades. As technology scales down, these components become inherently unreliable posing major design and test challenges. This paper proposes an instruction-checking architecture to detect erroneous <b>instruction</b> <b>executions</b> caused by both permanent and transient errors in the internal logic of a microprocessor. Monitoring the correct activation sequence of a set of predefined microprocessor control/status signals allow distinguishing between correctly and not correctly executed instructions...|$|R
50|$|The CPU {{design was}} quite complex - using three way {{interleaving}} of <b>instruction</b> <b>execution</b> (later called instruction pipeline) to improve throughput. Each instruction {{would go through}} an indexing phase, an actual <b>instruction</b> <b>execution</b> phase and an output phase. While an instruction {{was going through the}} indexing phase, the previous instruction was in its execution phase and the instruction before it was in its output phase.|$|E
50|$|<b>Instruction</b> <b>execution</b> time 1 or 2 {{instruction}} cycles (10.8 or 21.6 µs), 46300 to 92600 instructions per second.|$|E
5000|$|The 3083 Model CX has an <b>instruction</b> <b>execution</b> rate {{of about}} 0.75 times that of a 3083 Model EX.|$|E
3000|$|Fine-grained {{multithreading}} {{within the}} pipeline is in principle {{not an issue}} for WCET analysis. The scheduling algorithm of the threads needs to be known and must {{not depend on the}} state of the threads. Round-robin scheduling is a time-predictable option. The execution time for simple instructions simply increases by a factor equal to the number of threads. The benefit of hiding pipeline stalls due to data dependencies or branches results in a lower factor for these <b>instructions.</b> <b>Execution</b> of [...]...|$|R
40|$|The {{behaviour}} {{produced by}} an <b>instruction</b> sequence under <b>execution</b> is a behaviour {{to be controlled}} by some execution environment: each step performed actuates the processing of an <b>instruction</b> by the <b>execution</b> environment and a reply returned at completion of the processing determines how the behaviour proceeds. The increasingly occurring case where the processing takes place remotely involves the generation of a stream of instructions to be processed and a remote execution unit that handles the processing of this stream of instructions. We use process algebra to describe the behaviours produced by <b>instruction</b> sequences under <b>execution</b> and to describe two protocols implementing these behaviours in the case of remote processing. We also show that all finite-state behaviours considered in process algebra can be produced by <b>instruction</b> sequences under <b>execution...</b>|$|R
40|$|In this paper, {{we define}} a {{hardware}} Evaluation Stack for MSIL and we propose a conservative implementation over the EPIC architecture. This new hardware evaluation stack, named virtual stack, {{is based upon}} the EPIC architecture’s register files. An additional register renaming logic, to offload the run-time type checking performed by the Common Language Runtime is also proposed. Finally, we introduce a mechanism to overcome the sequential nature of the evaluation stack allowing the code generator to better use the parallel <b>instructions</b> <b>execution</b> of <b>instruction</b> bundles. The virtual stack’s final purpose is to simplify the implementation of fast one-pass JIT compiler...|$|R
50|$|A {{re-order}} buffer (ROB) {{is used in}} a Tomasulo algorithm for out-of-order <b>instruction</b> <b>execution.</b> It allows {{instructions to}} be committed in-order.|$|E
50|$|<b>Instruction</b> <b>execution</b> times (including average {{memory access}} times) were 5.25-5.75 {{milliseconds}} for addition and subtraction, and 21.25 ms for multiplication and division.|$|E
50|$|The 360/85 uses {{microcode}} {{to control}} <b>instruction</b> <b>execution,</b> unlike the completely-hardwired 360/75 and 360/91; the high-end models of System/370 are also microcoded.|$|E
50|$|The issue widths (and peak <b>instruction</b> <b>executions</b> per cycle) of a Jaguar, K10, and Bulldozer core are 2, 3, and 4 respectively. This made Bulldozer a more superscalar design {{compared}} to Jaguar/Bobcat. However, due to K10s somewhat wider core (in {{addition to the}} lack of refinements and optimizations in a first generation design) the Bulldozer architecture typically performed with somewhat lower IPC {{compared to}} its K10 predecessors. It was not until the refinements made in Piledriver and Steamroller, that the IPC of the Bulldozer family distinctly began to exceed that of K10 processors such as Phenom II.|$|R
50|$|When the LOAD {{button on}} the 1402 Card Read-Punch was pressed, a card was read into memory {{locations}} 001-080, a word mark was set in location 001, the word marks in locations 002-080 were cleared, and execution started with the instruction at location 001. That was always the dyadic Set Word Mark (it was the only instruction not requiring a following word mark) to set word marks for the two following <b>instructions.</b> <b>Execution</b> of <b>instructions</b> in the card deck continued, loading the program into memory, setting word marks, and then branching to the program's start address.|$|R
50|$|Some {{projects}} use BPF <b>instruction</b> sets or <b>execution</b> techniques {{different from}} the originals.|$|R
5000|$|The 3083 Models B and BX have an <b>instruction</b> <b>execution</b> rate {{ranging from}} 1.4 to 1.5 times the 3083 Models E and EX, respectively.|$|E
5000|$|The 3083 Models J and JX have an <b>instruction</b> <b>execution</b> rate {{ranging from}} 1.8 to 2.0 times the 3083 Models E and EX, respectively.|$|E
50|$|Post-Turing machine—minimalist one-tape, two-direction, 1 symbol { blank, mark } Turing-like machine {{but with}} default {{sequential}} <b>instruction</b> <b>execution</b> {{in a manner}} similar to the basic 3-instruction counter machines.|$|E
40|$|Abstract. The {{behaviour}} {{produced by}} an <b>instruction</b> sequence under <b>execution</b> is a behaviour {{to be controlled}} by some execution environment: each step performed actuates the processing of an <b>instruction</b> by the <b>execution</b> environment and a reply returned at completion of the processing determines how the behaviour proceeds. In this paper, we are concerned with the case where the processing takes place remotely. We describe a protocol to deal with the case where the behaviour produced by an <b>instruction</b> sequence under <b>execution</b> leads to the generation of a stream of instructions to be processed and a remote execution unit handles the processing of that stream of instructions...|$|R
40|$|We study {{several aspects}} of the {{behaviours}} produced by <b>instruction</b> sequences under <b>execution</b> {{in the setting of}} the algebraic theory of processes known as ACP. We use ACP to describe the behaviours produced by <b>instruction</b> sequences under <b>execution</b> and to describe two protocols implementing these behaviours in the case where the processing of instructions takes place remotely. We also show that all finite-state behaviours considered in ACP can be produced by <b>instruction</b> sequences under <b>execution.</b> Comment: 36 pages, consolidates material from arXiv: 0811. 0436 [cs. PL], arXiv: 0902. 2859 [cs. PL], and arXiv: 0905. 2257 [cs. PL]; abstract and introduction rewritten, examples and proofs adde...|$|R
40|$|The {{behaviour}} {{produced by}} an <b>instruction</b> sequence under <b>execution</b> is a behaviour {{to be controlled}} by some execution environment: each step performed actuates the processing of an <b>instruction</b> by the <b>execution</b> environment and a reply returned at completion of the processing determines how the behaviour proceeds. In this paper, we are concerned with the case where the processing takes place remotely. We describe a protocol to deal with the case where the behaviour produced by an <b>instruction</b> sequence under <b>execution</b> leads to the generation of a stream of instructions to be processed and a remote execution unit handles the processing of that stream of instructions. Comment: 15 page...|$|R
5000|$|The IBM System/360 Model 85 used {{microcode}} {{to control}} <b>instruction</b> <b>execution,</b> unlike the completely-hardwired 360/75 and 360/91; the high-end models of System/370 were also microcoded. Some describe the 360/85 {{as a bridge}} to the 370/165.|$|E
50|$|For the Dreamcast, Hitachi {{developed}} the SH-4 architecture. Superscalar (2-way) <b>instruction</b> <b>execution</b> and a vector floating point unit (particularly suited to 3d graphics) were {{the highlights of}} this architecture. SH-4 based standard chips were introduced around 1998.|$|E
5000|$|... 803B had 4 or 8K of 39 bit {{words of}} memory. The single data path was split into several shorter (48 bit long) serial paths to reduce <b>instruction</b> <b>execution</b> time. A {{hardware}} floating point option was available.|$|E
50|$|In {{addition}} to standalone memory chips, blocks of semiconductor memory are integral parts of many computer and data processing integrated circuits. For example, the microprocessor chips that run computers contain cache memory to store <b>instructions</b> awaiting <b>execution.</b>|$|R
40|$|The ALU {{is one of}} {{the most}} {{frequently}} accessed modules in a CPU and is utilized during most <b>instruction</b> <b>executions.</b> Hence the power consumption of the ALU is a major concern. In this paper a low power 16 bit ALU is designed using VHDL. Lower power consumption is achieved by using clock gating technique and the results are compared with conventional ALU design. A carry skip adder with variable block length is used for the arithmetic unit to achieve better performance. The design is then implemented inXilinx Spartan 3 E FPGA. The ALU achieves a maximum frequency of 65. 19 MHzwith a dynamic power dissipation of 1. 98 mW when operated at 15 MHz...|$|R
40|$|AbstractA RAM {{program is}} said to run within a “strong” time bound T if on every {{sequence}} of n inputs it terminates within T(n) <b>instruction</b> <b>executions.</b> There are some programs whose execution time in this sense is a non-computable function of n. It is shown that such programs are essential {{in the sense that}} some functions can be computed within a non-computable time bound but not within any computable time bound. Nevertheless, strong time bounds are subject to a powerful hierarchy theorem. The condition such as being time constructable which normally applies to the “lower” function in such theorems is replaced by a condition of being the minimum strong time bound for some program...|$|R
