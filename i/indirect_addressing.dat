218|130|Public
25|$|Counter machine – {{the most}} {{primitive}} and reduced theoretical {{model of a}} computer hardware. Lacks <b>indirect</b> <b>addressing.</b> Instructions are in the finite state machine {{in the manner of}} the Harvard architecture.|$|E
25|$|Random access machine (RAM) – {{a counter}} machine with <b>indirect</b> <b>addressing</b> and, usually, an {{augmented}} instruction set. Instructions {{are in the}} finite state machine {{in the manner of}} the Harvard architecture.|$|E
2500|$|RAM and RASP: <b>indirect</b> <b>addressing</b> available, {{immediate}} operands typical ...|$|E
5000|$|... #Subtitle level 2: The {{notion of}} <b>indirect</b> <b>address</b> {{register}} [...] "N" ...|$|R
5000|$|... bit 17: I (sr. Indirektno) - {{multi-level}} memory <b>indirect</b> (note: the <b>address</b> {{is loaded}} from specified location and, should it also specify [...] "I" [...] flag the <b>indirect</b> <b>address</b> calculation continues) ...|$|R
50|$|The {{standard}} assembler places {{constant values}} for arithmetic {{in the current}} page. Likewise, cross-page jumps and subroutine calls use an <b>indirect</b> <b>address</b> in the current page.|$|R
2500|$|He defines <b>indirect</b> <b>addressing</b> for {{his model}} (p.288) and {{provides}} {{two examples of}} its use (p.89); his [...] "proof" [...] (p.290-292) that his model is Turing equivalent is so sketchy that the reader cannot tell {{whether or not he}} intended the <b>indirect</b> <b>addressing</b> to be a requirement for the proof.|$|E
2500|$|Counter machine: no <b>indirect</b> <b>addressing,</b> {{immediate}} operands {{possible in}} highly atomized models ...|$|E
2500|$|Elgot-Robinson {{investigate}} {{the possibility of}} allowing their RASP model to [...] "self modify" [...] its program instructions. The idea was an old one, proposed by Burks-Goldstine-von Neumann (1946-7), and sometimes called [...] "the computed goto." [...] Melzak (1961) specifically mentions the [...] "computed goto" [...] by name but instead provides his model with <b>indirect</b> <b>addressing.</b>|$|E
5000|$|Register then {{indirect}} (RI): Perform {{the address}} modification as in Register modification, {{use the word}} at the effective <b>address</b> as an <b>indirect</b> <b>address</b> of the operand.|$|R
50|$|If {{our model}} has an {{unbounded}} accumulator can we bound {{all the other}} registers? Not until we {{provide for at least}} one unbounded register from which we derive our <b>indirect</b> <b>addresses.</b>|$|R
50|$|The x86 {{assembly}} has an {{unconditional jump}} operation, , which can take an immediate address, a register or an <b>indirect</b> <b>address</b> as a parameter (note that most RISC processors only support a link register or short immediate displacement for jumping).|$|R
2500|$|The ENIAC was {{programmed}} using subroutines, nested loops, and <b>indirect</b> <b>addressing</b> {{for both}} data locations and jump destinations. [...] During her work programming the ENIAC, Kay McNulty {{is credited with}} {{the invention of the}} subroutine. [...] Her colleague, Jean Jennings, recalled when McNulty proposed the idea to solve the problem where the logical circuits did not have enough capacity to compute some trajectories. [...] The team collaborated on the implementation.|$|E
2500|$|But Elgot and Robinson {{solve the}} problem: They augment their P0 RASP with an indexed set of instructions—a {{somewhat}} more complicated (but more flexible) form of <b>indirect</b> <b>addressing.</b> Their P'0 model addresses the registers {{by adding the}} contents of the [...] "base" [...] register (specified in the instruction) to the [...] "index" [...] specified explicitly in the instruction (or vice versa, swapping [...] "base" [...] and [...] "index"). Thus the indexing P'0 instructions have one more parameter than the non-indexing P0 instructions: ...|$|E
2500|$|The papers: The papers {{begin with}} Wang (1957) and his {{dramatic}} simplification of the Turing machine. [...] Turing (1936), Kleene (1952), Davis (1958) {{and in particular}} Post (1936) are cited in Wang (1957); in turn, Wang is referenced by Melzak (1961), Minsky (1961) and Shepherdson-Sturgis (1961-3) as they independently reduce the Turing tapes to [...] "counters". Melzak (1961) provides his pebble-in-holes counter machine model with indirection but doesn't carry the treatment further. The work of Elgot-Robinson (1964) define the RASP—the computer-like random access stored program machines—and {{appear to be the}} first to investigate the failure of the bounded counter machine to calculate the mu-recursive functions. This failure—except with the draconian use of Gödel numbers in the manner of Minsky (1961))—leads to their definition of [...] "indexed" [...] instructions (i.e. <b>indirect</b> <b>addressing)</b> for their RASP model. Elgot-Robinson (1964) and more so Hartmanis (1971) investigate RASPs with self-modifying programs. Hartmanis (1971) specifies an instruction set with indirection, citing lecture notes of Cook (1970). For use in investigations of computational complexity Cook and his graduate student Reckhow (1973) provide the definition of a RAM (their model and mnemonic convention are similar to Melzak's, but offer him no reference in the paper). The pointer machines are an offshoot of Knuth (1968, 1973) and independently Schönhage (1980).|$|E
50|$|Modified <b>Indirect</b> Data <b>Address</b> Words (MIDAWs) are {{a channel}} {{programming}} {{capability of the}} IBM System z9 processor. The MIDAW facility is an extension to the pre-existing <b>Indirect</b> Data <b>Address</b> Word (IDAW) channel programming capability, providing support for more efficient FICON channel programs.|$|R
50|$|When {{indexing}} is specified, {{the register}} {{defined in the}} instruction becomes the index register, and the source/destination is implicitly Register zero. For indirect indexing, Post indexing is used, i.e. the <b>indirect</b> <b>address</b> is first fetched from memory and then the index is added to it.|$|R
40|$|This {{document}} {{explores the}} computer techniques used to execute software whose parts are compiled and linked separately. The computer techniques include using a branch table or <b>indirect</b> <b>address</b> table {{to connect the}} parts. Methods of storing the information in data structures are discussed as well as differences between C and C++...|$|R
5000|$|Unlike Fortran and ALGOL 60, APL (Address {{programming}} language) supported <b>indirect</b> <b>addressing</b> {{and addressing}} of higher ranks. <b>Indirect</b> <b>addressing</b> is a mechanism {{that appeared in}} other programming languages much later (1963-65 in PL/1).|$|E
50|$|<b>Indirect</b> <b>addressing</b> or field {{selection}} was selected if the one-bit field (i/a) was set. Both <b>indirect</b> <b>addressing</b> and a base register could be {{selected in the}} indirect address in memory. Only a base register could be selected in the field selector in memory.|$|E
50|$|In {{the least}} {{significant}} digit of 5-digit addresses it was set for <b>indirect</b> <b>addressing</b> (an option on the 1620 I, standard on the 1620 II). Multi-level indirection could be used (you could even put the machine in an infinite <b>indirect</b> <b>addressing</b> loop).|$|E
5000|$|... e = Extend <b>indirect</b> jump/call <b>address</b> with EIND (0=0:Z, 1=EIND:Z) ...|$|R
5000|$|Also, {{as part of}} the DAT announcement, {{channels}} were {{upgraded to}} have <b>Indirect</b> Data <b>Address</b> Lists (a form of I/O MMU).|$|R
50|$|If {{the word}} size {{is larger than}} the address, then the word {{referenced}} for memory-indirect addressing could itself have an indirect flag set to indicate another memory indirect cycle. This flag is referred to as an indirection bit, and the resulting pointer is a tagged pointer, the indirection bit tagging whether it is a direct pointer or an indirect pointer. Care is needed to ensure that a chain of <b>indirect</b> <b>addresses</b> does not refer to itself; if it does, one can get an infinite loop while trying to resolve an address.|$|R
50|$|<b>Indirect</b> <b>addressing</b> may be {{used for}} code or data. It can make {{implementation}} of pointers, references, or handles much easier, and can also make it easier to call subroutines which are not otherwise addressable. <b>Indirect</b> <b>addressing</b> does carry a performance penalty due to the extra memory access involved.|$|E
5000|$|RAM and RASP: <b>indirect</b> <b>addressing</b> available, {{immediate}} operands typical ...|$|E
5000|$|Random access machine—RAM: {{counter machine}} with added <b>indirect</b> <b>addressing</b> {{capability}} ...|$|E
5000|$|Read the {{effective}} address: In {{case of a}} memory instruction (direct or indirect) the execution phase {{will be in the}} next clock pulse. If the instruction has an <b>indirect</b> <b>address,</b> {{the effective}} address is read from main memory, and any required data is fetched from main memory to be processed and then placed into data registers (Clock Pulse: T3). If the instruction is direct, nothing is done at this clock pulses. If this is an I/O instruction or a Register instruction, the operation is performed (executed) at clock Pulse.|$|R
5000|$|<b>Indirect</b> {{register}} access (<b>address</b> register, {{data register}} in mapped memory) ...|$|R
50|$|Some of {{the density}} of Burroughs B6700 code was due to moving vital operand {{information}} elsewhere, to 'tags' on every data word or into tables of pointers. The Add instruction itself was generic or polymorphic. It had to fetch the operand to discover whether this was an integer add or floating point add. The Load instruction could find itself tripping on an <b>indirect</b> <b>address,</b> or worse, a disguised call to a call-by-name thunk routine. The generic opcodes required fewer opcode bits but made the hardware more like an interpreter, with less opportunity to pipeline the common cases.|$|R
5000|$|He defines <b>indirect</b> <b>addressing</b> for {{his model}} (p. 288) and {{provides}} {{two examples of}} its use (p. 89); his [...] "proof" [...] (p. 290-292) that his model is Turing equivalent is so sketchy that the reader cannot tell {{whether or not he}} intended the <b>indirect</b> <b>addressing</b> to be a requirement for the proof.|$|E
5000|$|Counter machine: no <b>indirect</b> <b>addressing,</b> {{immediate}} operands {{possible in}} highly atomized models ...|$|E
5000|$|... #Subtitle level 3: Elgot-Robinson (1964) and {{the problem}} of the RASP without <b>indirect</b> <b>addressing</b> ...|$|E
2500|$|In some regions, {{such as the}} Southern United States, [...] "Doctor" [...] is {{traditionally}} added to the first name of people holding doctorates, where it is used in either direct or <b>indirect</b> familiar <b>address.</b>|$|R
5000|$|This type of {{reference}} {{can be applied}} to all r-values including non-l-values as well as l-values. Some processors provide one or more instructions which take an immediate value, sometimes referred to as [...] "immediate" [...] for short. An immediate value is stored as part of the instruction which employs it, usually to load into, add to, or subtract from, a register. The other parts of the instruction are the opcode, and destination. The latter may be implicit. (A non-immediate value may reside in a register, or be stored elsewhere in memory, requiring the instruction to contain a direct or <b>indirect</b> <b>address</b> index register address to the value.) ...|$|R
50|$|The {{programmed}} operator facility {{allows the}} instruction code field {{to indicate a}} call to a vector of subroutine addresses. The six bit instruction code allows up to 64 programmed operators (octal 00 through 77). If the P bit is set, an instruction code of xx is treated as a call to location 1xx (octal). The location of the POP instruction is saved in location zero. Bit zero of location zero is set to the current value of the overflow indicator and the indicator is reset. Bit 9 of location zero is set to '1'b to indicate an <b>indirect</b> <b>address,</b> allowing the programmed operator routine to indirectly access the data specified in {{the address of the}} POP instruction.|$|R
