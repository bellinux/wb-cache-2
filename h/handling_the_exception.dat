3|10000|Public
5000|$|... default: /* {{fall through}} */ memcpy({{exception}}_env, my_env, sizeof exception_env); /* restore exception stack */ longjmp(exception_env, exception_type); /* continue <b>handling</b> <b>the</b> <b>exception</b> */ ...|$|E
40|$|Abstract. Exception {{handling}} patterns {{can raise}} the abstraction level of processes, facilitating their writing and understanding. In this paper, we identify several useful, general purpose exception handling patterns and demonstrate their applicability in software development process definition. We present these patterns using the Little-JIL language, which incorporates an exception handling construct that allows corrective {{actions to be taken}} in the case of exceptions, and flexible ways of defining how the process should continue after <b>handling</b> <b>the</b> <b>exception...</b>|$|E
40|$|While {{exception}} handling mechanisms are very useful for implementing systems, they are equally useful when building business models. The standard method of modeling exceptions in UML is to include them in class diagrams {{as a kind}} of signal, as stereotyped classes. However this alone is insucient, since by the very nature of exceptions, the circumstances under which particular exceptions may be raised, as well as the details of what actions the class <b>handling</b> <b>the</b> <b>exception</b> will perform in doing so, tend to be rather complex and in general dicult to express pictorially. In this paper, we consider how this information may be speci ed using the Object Constraint Language (OCL). We illustrate our approach by applying it to a simple example...|$|E
50|$|If the {{preference}} is to <b>handle</b> <b>the</b> <b>exception,</b> then based on handling preferences such as memory search depth, the error interception utility extracts memory values from heap and stack memories. This snapshot then produces {{the equivalent of}} a debugger screen (as {{if there had been a}} debugger) at the moment of <b>the</b> <b>exception.</b>|$|R
50|$|Weak rule utilitarianism (WRU) {{attempts}} to handle SRU counterexamples as legitimate exceptions. One such response is two-level utilitarianism; more systematic WRUs {{attempt to create}} sub-rules to <b>handle</b> <b>the</b> <b>exceptions.</b> But as David Lyons and others have argued, this will necessarily tend to collapse into act utilitarianism. Rules will require as many sub-rules as there are exceptions, thus many <b>exceptions</b> will make <b>the</b> more-sophisticated rule computational intractable. Rational agents will then satisfice that intractability by seeking outcomes produces the maximum utility.|$|R
5000|$|The ON-unit is {{a single}} {{statement}} or [...] -block introduced by an [...] Executing the ON statement enables the condition specified, e.g., [...] When <b>the</b> <b>exception</b> for this condition occurs and the condition is enabled, the ON-unit for the condition is executed. ON-units are inherited down the call chain. When a block, procedure or ON-unit is activated, the ON-units established by the invoking activation are inherited by the new activation. They may be over-ridden by another [...] and can be reestablished by <b>the</b> [...] <b>The</b> <b>exception</b> can be simulated using the [...] - e.g. to help debug <b>the</b> <b>exception</b> handlers. <b>The</b> dynamic inheritance principle for ON-units allows a routine to <b>handle</b> <b>the</b> <b>exceptions</b> occurring within <b>the</b> subroutines it uses.|$|R
5000|$|In {{a case of}} an {{exception}} in a user mode code, the operating system parses the thread's _EXCEPTION_REGISTRATION_RECORD list and calls each exception handler in sequence until a handler signals it has <b>handled</b> <b>the</b> <b>exception</b> (by return value) or the list is exhausted. The last one in the list is always the [...] which displays the General protection fault error message. Then the list is traversed once more giving handlers a chance to clean up any resources used. Finally, the execution returns to kernel mode where the process is either resumed or terminated.|$|R
50|$|Large coal-fueled vessels {{also had}} {{individuals}} working as coal trimmers, who delivered coal from the coal bunkers to the stokers. They {{were responsible for}} all coal <b>handling</b> with <b>the</b> <b>exception</b> of <b>the</b> actual fueling of the boilers.|$|R
40|$|Thehealthcare {{services}} {{are among the}} fastest growing service markets deploying wireless technologies. As healthcare organizations continue to become more distributed, mobile handheld devices and their associated support {{has evolved into a}} viable platform for these organizations. However, one factor that hinders the deployment of the handheld technology is the lack of support for exception handling over mobile handheld devices in current workflow management systems. In this paper, we propose an extended architecture and scheme for <b>handling</b> <b>the</b> <b>exceptions.</b> Theproposed scheme scans through earlier exception records from a dynamic knowledge base, evaluates and suggests an appropriate solution for <b>the</b> current <b>exception</b> on <b>the</b> mobile handheld device. The scheme is evaluated in terms of time and accuracy compared withpreviously known schemes [6]...|$|R
40|$|Abstract—The {{overall goal}} of this {{research}} is to study reasoning under uncertainty by combining Bayesian Networks and Case-Based Reasoning through constructing an experimental decision support system for classification of cancer pain. We have experimentally analysed a medical dataset in order to reveal properties of the data with respect to properties of the two reasoning methods. We also preprocessed our medical data with help from a clinical expert, which resulted in four data sets with different characteristics. This culminates in a hybrid system architecture, where CBR <b>handles</b> <b>the</b> <b>exceptions</b> or outliers with respect to the distribution of the data and the target class, while BN <b>handles</b> <b>the</b> more common situations. Through a set of experiments under varying conditions we show that a hybrid BN+CBR system is favorable over each single method...|$|R
40|$|The Java {{language}} specification {{requires that}} all array references be checked for validity. If a reference is invalid, an exception must be thrown. Furthermore, the environment {{at the time}} of <b>the</b> <b>exception</b> must be preserved and made available to whatever code <b>handles</b> <b>the</b> <b>exception.</b> Performing <b>the</b> checks at run-time incurs a large penalty in execution time. In this paper we describe a collection of transformations that can dramatically reduce this overhead in the common case (when the access is valid) while preserving the program state {{at the time of}} an <b>exception.</b> <b>The</b> transformations allow trade-offs {{to be made in the}} efficiency and size of the resulting code, and are fully compliant with the Java language semantics. Preliminary evaluation of the effectiveness of these transformations show that performance improvements of 10 times and more can be achieved for array-intensive Java programs...|$|R
40|$|In this thesis, we {{evaluate}} {{the feasibility of}} exposing elements in a processor's datapath to the compiler {{in order to reduce}} energy consumption. We focus on eliminating register file traffic by exposing the latches in the bypass network, as our study shows that there is potential for significant benefit by doing this. We present the idea of software restart markers to <b>handle</b> <b>the</b> <b>exception</b> management overhead that results from exposing additional processor state. We then implement our proposed techniques and observe an average energy savings of 7. 0 % across a range of benchmarks when compared to a low-power MIPS processor. We also explore the implications of changing the pipeline structure to both improve performance and expose more machine state...|$|R
2500|$|Software <b>exception</b> <b>handling</b> and <b>the</b> support {{provided}} by software tools differs somewhat {{from what is}} understood under exception in hardware, but similar concepts are involved. In programming language mechanisms for <b>exception</b> <b>handling,</b> <b>the</b> term <b>exception</b> is typically used in a specific sense to denote a data structure storing information about an exceptional condition. One mechanism to transfer control, or raise an exception, {{is known as a}} throw. <b>The</b> <b>exception</b> is said to be thrown. Execution is transferred to a [...] "catch".|$|R
2500|$|The 68000 is also {{unable to}} easily support virtual memory, which {{requires}} {{the ability to}} trap and recover from a failed memory access. The 68000 does provide a bus error exception {{which can be used}} to trap, but it does not save enough processor state to resume the faulted instruction once the operating system has <b>handled</b> <b>the</b> <b>exception.</b> Several companies did succeed in making 68000-based Unix workstations with virtual memory that worked by using two 68000 chips running in parallel on different phased clocks. When the [...] "leading" [...] 68000 encountered a bad memory access, extra hardware would interrupt the [...] "main" [...] 68000 to prevent it from also encountering the bad memory access. This interrupt routine would <b>handle</b> <b>the</b> virtual memory functions and restart the [...] "leading" [...] 68000 in the correct state to continue properly synchronized operation when the [...] "main" [...] 68000 returned from the interrupt.|$|R
40|$|Workflow {{technology}} {{has not yet}} {{lived up to its}} expectations not only because of social problems but also because of technical problems, like inflexible and rigid process specification and execution mechanisms and insufficient possibilities to <b>handle</b> <b>exceptions.</b> <b>The</b> aim {{of this paper is to}} present a workflow model which significantly facilitates the design and reliable management of complex business processes supported by an automatic mechanism to <b>handle</b> <b>exceptions.</b> <b>The</b> strength of the model is its simplicity and the application independent transaction facility (advanced control mechanism for workflow units) which guarantees reliable execution of workflow activities. ...|$|R
50|$|Normally, an {{application}} that was linked against a DLL’s import library {{will fail to}} start if the DLL cannot be found, because Windows will not run the application unless it can find all of the DLLs that the application may need. However {{an application}} may be linked against an import library to allow delayed loading of the dynamic library.In this case the operating system will not try to find or load the DLL when the application starts; instead, a stub {{is included in the}} application by the linker which will try to find and load the DLL through LoadLibrary and GetProcAddress when one of its functions is called. If the DLL cannot be found or loaded, or the called function does not exist, the application will generate an exception, which may be caught and <b>handled</b> appropriately. If <b>the</b> application does not <b>handle</b> <b>the</b> <b>exception,</b> it will be caught by the operating system, which will terminate the program with an error message.|$|R
5000|$|Error hiding {{is one of}} {{the more}} common anti-patterns to {{encounter}} in languages that support the paradigm of checked exceptions including Java. This type of <b>exception</b> forces <b>the</b> programmer to <b>handle</b> <b>the</b> <b>exception</b> even if <b>the</b> programmer has no means to effectively do so. The problem becomes more egregious in large or complex systems. For example, a programmer implementing function A may require the service of another component B. Component B may then in turn delegate to component C to fulfill that request. If component C encounters a failure during that service it may indicate this by throwing a checked exception to component B. Component B after recovering from the error but unable to fulfill the request from Function A may indicate this by re-throwing the error from C. Function A, having no recourse to handle an error from component C has three options: ...|$|R
5000|$|... #Caption: Snooty and handler on his 63rd birthday, July 2011. The {{aquarium}} strongly discourages {{human interaction}} with manatees, but Snooty {{was too old}} to be released into the wild, and his <b>handling</b> was <b>the</b> only <b>exception</b> made.|$|R
40|$|AbstractThis paper {{presents}} a Hoare-like {{system for the}} language Lexc containing typical statements, recursive procedures and an <b>exception</b> <b>handling</b> mechanism. <b>The</b> <b>exception</b> <b>handling</b> mechanism supports both termination and resumption as handler responses to an <b>exception</b> <b>The</b> semantics of the language is defined by a copy rule. The Hoare-like system {{is based on the}} system defined in Olderog (1981) for an Algol-like language. It is relatively complete for programs with a finite C-index (C stands for a copy rule). The example of a correctness proof fo a simple program is presented...|$|R
40|$|Virtual Organizations (VOs) {{consist of}} groups of agents that {{collaborate}} towards achieving their specified goals. VO Partners are independent, autonomous, and heterogeneous, thus often exhibiting complex behaviors in co-working. Frictional behavior demonstrated by {{even a few}} partners, may cause drastic results and total failure of the VO. Therefore, {{it is necessary to}} model and analyze VO partners’ behavior. This paper introduces the VO Supervision Assistance Tool (VOSAT), developed based on leveraging partners’ commitments/promises, to monitor partners’ behavior against the synergetic norms in the VO. For this purpose, three kinds of behavioral norms are defined, including: socio-legal norms, functional norms, and activity-related norms. Additionally, a fuzzy norm is introduced to indicate agents’ trustworthy behavior. The functionalities supported in VOSAT enable the VO coordinator with identifying the high risk tasks and the weak or weakest points in the flow of VO planned operations. It further assists the coordinator with finding suitable candidate partners for <b>handling</b> <b>the</b> <b>exceptions</b> that arise during the VO operation phase. These in turn improve the success rate of the VOs...|$|R
40|$|Part 2 : Behaviour and CoordinationInternational audienceVirtual Organizations (VOs) {{consist of}} groups of agents that {{collaborate}} towards achieving their specified goals. VO Partners are independent, autonomous, and heterogeneous, thus often exhibiting complex behaviors in co-working. Frictional behavior demonstrated by {{even a few}} partners, may cause drastic results and total failure of the VO. Therefore, {{it is necessary to}} model and analyze VO partners’ behavior. This paper introduces the VO Supervision Assistance Tool (VOSAT), developed based on leveraging partners’ commitments/promises, to monitor partners’ behavior against the synergetic norms in the VO. For this purpose, three kinds of behavioral norms are defined, including: socio-legal norms, functional norms, and activity-related norms. Additionally, a fuzzy norm is introduced to indicate agents’ trustworthy behavior. The functionalities supported in VOSAT enable the VO coordinator with identifying the high risk tasks and the weak or weakest points in the flow of VO planned operations. It further assists the coordinator with finding suitable candidate partners for <b>handling</b> <b>the</b> <b>exceptions</b> that arise during the VO operation phase. These in turn improve the success rate of the VOs...|$|R
40|$|In {{this short}} note we study the {{semantics}} of two basic computational effects, exceptions and states, {{from a new}} point of view. In <b>the</b> <b>handling</b> of <b>exceptions</b> we dissociate <b>the</b> control from the elementary operation which recovers from <b>the</b> <b>exception.</b> In this way it becomes apparent {{that there is a}} duality, in the categorical sense, between exceptions and states...|$|R
40|$|Managed {{programming}} languages {{have improved}} the robustness of software by reducing some classes of errors. Despite these improvements, programs still contain errors. Even {{with help from}} existing static and dynamic analysis tools, the errors are often difficult to detect and can be {{even more difficult to}} successfully eliminate. This work introduces a new approach, called dynamic error remediation, that further improves the robustness of software, by tolerating some null pointer exceptions until a patch can be created to fix <b>the</b> <b>exception.</b> This paper describes dynamic error remediation, and its effectiveness, with different strategies for <b>handling</b> <b>the</b> <b>exceptions.</b> We show that dynamic error remediation is successful in allowing programs to continue execution and to do meaningful work in many cases. We then describe the bug suite created to test dynamic error remediation, as well as providing a methodology for creating other bug suites. Finally, we describe origin tracking, a JVM modification which exposes the origin of null values that cause null pointer exceptions. Because dynamic error remediation is successful in many cases, we assert that it is a viable strategy for increasing availability and reliability in many programs. While increasing availability over correctness is not ideal in all cases, we show that there are real examples where it is preferred, and we provide dynamic error remediation as a tool for developers and users to survive null pointer exception bugs. ...|$|R
5000|$|Microsoft Structured <b>Exception</b> <b>Handling</b> is <b>the</b> native <b>exception</b> <b>handling</b> {{mechanism}} for Windows and a forerunner technology to Vectored Exception Handling (VEH). It features the [...] mechanism {{not present in}} standard С++ exceptions (but present in most imperative languages introduced later). SEH is set up and handled separately for each thread of execution.|$|R
50|$|Error <b>handling</b> {{refers to}} <b>the</b> {{programming}} practice of anticipating and coding for error conditions that may arise when <b>the</b> program runs. <b>Exception</b> <b>handling</b> is {{a programming language}} construct or hardware mechanism designed to <b>handle</b> <b>the</b> occurrence of <b>exceptions,</b> special conditions that change the normal flow of program execution. Fault tolerance {{is a collection of}} techniques that increase software reliability by detecting errors and then recovering from them if possible or containing their effects if recovery is not possible.|$|R
40|$|During the {{development}} of the component-based energy system simulator DNA (Dynamic Network Analysis), several obstacles to easy use of the program have been observed. Some of these {{have to do with the}} nature of the program being based on a modelling language, not a graphical user interface (GUI). Others have to do with the interaction between models of the nature of the substances in an energy system (e. g., fuels, air, flue gas), models of the components in a system (e. g., heat exchangers, turbines, pumps), and the solver for the system of equations. This paper proposes that the interaction between models and solvers should be made more robust by making more robust component models which <b>handle</b> <b>the</b> <b>exceptions</b> of <b>the</b> equations inside them, instead of or in addition to trying to remedy these by adding features to the numerical solvers. Improving the robustness of a component model may be more or less difficult depending on the mathematical expressions creating <b>the</b> <b>exceptions.</b> <b>The</b> proposed idea suggests that the solvers may be helped by exception handling leading it back on the right track. The original equation of the model is substituted by an algorithm, so the original equation is only evaluated where it is defined. Outside this region an algorithm is introduced, so the model iterates back to the feasible region. It is shown how this can be done for four different model of energy system component models: turbine constant, gasifier, heat exchanger effectiveness, and heat exchanger heat transfer coefficient...|$|R
40|$|Abstract. This paper {{discusses}} issues, {{possibilities and}} existing approaches for fitting an exception handling mechanism (EHM) in CSP-based process-oriented software architectures. After giving a survey on properties desired for a concurrent EHM, specific problems {{and a few}} principal ideas for including exception handling facilities in CSP-designs are discussed. As one of the CSP-based frameworks for concurrent software, we extend CT (Communicating Threads) library with <b>the</b> <b>exception</b> <b>handling</b> facilities. <b>The</b> extensions result in two different EHM models whose compliance with the most important demands of concurrent EHMs (<b>handling</b> simultaneous <b>exceptions,</b> <b>the</b> mechanism formalization and efficient implementation) are observed...|$|R
40|$|Supply {{networks}} {{are becoming increasingly}} collaborative, {{with more and more}} data being shared and decisions taken through intense deliberations. With increased collaboration comes a greater risk of exceptions, which can undermine <b>the</b> collaborative advantages. <b>Handling</b> <b>the</b> <b>exceptions</b> is essential to make such a collaboration system scalable. One such instance that occurs in the operative layer of the supply network is when two entities in a supply network make separate forecasts for orders to satisfy demand for a specific period of time, and run into a <b>exception</b> in <b>the</b> form of a forecast mismatch. In this work, an exception handling mechanism is introduced to resolve such exceptions, by making decisions dynamically based on past performances of each entity 2 ̆ 7 s forecasts, making this system a co-system. The main contribution from this work will be a new measure, defined as Forecast Viability, to determine the usefulness of the forecast methods used in the co-system. The performance, in terms of costs, of this mechanism is calculated and then compared with the retailer system and with the performance of a system using a simple average of forecasts as an exception resolution mechanism. In the experiments, when comparing the costs from using the Forecast Viability measure against the retailer system, the new measure yileded reduction in costs of upto 10...|$|R
40|$|Non-coercive power, {{trust and}} {{exceptions}} handling positively {{impact on the}} collaborative efforts berween a distributor and dealers. Non-coercive power influences the level of trust and <b>the</b> effectiveness of <b>exception</b> <b>handling.</b> Human collaboration and e-collaboration enhance trust and <b>the</b> <b>handling</b> of <b>exceptions.</b> Such human collaboration is improved {{by the use of}} formal/informal meetings, telephones, and SMS. E-collaboration is enhanced using Web-based applications, e-mail, text based chat programmes, video conferences and Web-cameras...|$|R
40|$|Abstract. Today's {{workflow}} management systems (WFMSs) are only applicable in a secure and safe manner if the business process (BP) {{to be supported}} is well-structured {{and there is no}} need for ad hoc deviations at runtime. As only few BPs are static in this sense, this significantly limits the applicability of current workflow (WF) technology. On the other hand, to support dynamic deviations from premodeled task sequences must not mean that the responsibility for the avoidance of consistency problems and run-time errors is now completely shifted to the (naive) end user. In this paper we present a formal foundation for the support of dynamic structural changes of running WF instances. Based upon a formal WF model (ADEPT), we define a complete and minimal set of change operations (ADEPTflex) that support users in modifying the structure of a running WF, while maintaining its (structural) correctness and consistency. The correctness properties defined by ADEPT are used to determine whether a specific change can be applied to a given WF instance or not. If these properties are violated, the change is either rejected or the correctness must be restored by <b>handling</b> <b>the</b> <b>exceptions</b> resulting from <b>the</b> change. We discuss basic issues with respect to the management of changes and the undoing of temporary changes at the instance level. Recently we have started the design and implementation of ADEPTworkflow, the ADEPT workflow engine, which will make use of the change facilities presented in this paper...|$|R
2500|$|It {{has been}} argued that rule utilitarianism collapses into act utilitarianism, because for any given rule, in the case where {{breaking}} the rule produces more utility, the rule can be refined by the addition of a sub-rule that <b>handles</b> cases like <b>the</b> <b>exception.</b> This process holds for all cases of <b>exceptions,</b> and so <b>the</b> [...] "rules" [...] have as many [...] "sub-rules" [...] as there are exceptional cases, which, in the end, makes an agent seek out whatever outcome produces the maximum utility.|$|R
40|$|In Android systems, inter-process {{communication}} {{relies heavily}} on intent, which {{can be understood as}} a message between apps. However, (i) intents can be hijacked when they are transmitted from senders to receivers. Even if received securely, due to developer's underestimation of intent data complexity, (ii) intents can cause exceptions in their receivers. An app is at the risk of losing response, and even crashing if it fails to <b>handle</b> <b>the</b> <b>exceptions</b> properly. To deal with the two potential problems above, we added an Android framework-layer module to reject the installation of suspicious apps that may hijack intents during transmission. In addition, we proposed and implemented FuzzingDroid, a utility tool that generates various relevant intents to fuzz test publicly-accessible intent receivers in apps. The tool is important because it helps developers detect the weakness of their incoming intent handling code before they release their apps. At its core, FuzzingDroid relies on our instrumented Android framework-layer module to generate the variant parts in fuzzing intents. The outcome of using FuzzingDroid is pretty good: after analyzing 47 highly-downloaded apps from Google Play Store, 46 highly-downloaded apps from other popular online app markets, 45 core system apps from LG Nexus 5 and 32 core system apps from XiaoMi phone respectively, we found 49 of the total 170 apps were crashed due to various intent handling deficiencies. FuzzingDroid is also a very efficient tool. It takes about 1 minute to fuzz an app completely with only 5 % increase in CPU utilization and 24 MB increase in memory utilization...|$|R
40|$|In this thesis, {{we propose}} a bundled {{solution}} {{to address the}} limitations of peer-to- peer (P 2 P) workflow management systems such as the architectural weakness and the lack to support exception handling at instance level. The aim is to conceptualise, formalise, implement and validate this bundled solution. After an in-depth analysis of the above mentioned problems, a novel decentralized P 2 P workflow architecture (P-FLOW) has been developed. Then, an innovative mechanism is proposed to <b>handle</b> <b>the</b> instance level <b>exceptions</b> in P-FLOW. This mechanism ensures <b>the</b> <b>handling</b> of <b>exceptions</b> in a coordinated manner and separates <b>the</b> <b>exception</b> logic from <b>the</b> business logic. Furthermore, we proposed a novel feasible and flexible intelligent problem solving approach which facilitates more common understanding and exception handling experience sharing in P 2 P WFMSs. In our approach, a case- based reasoning (CBR) based exception handling mechanism with integrated human involvement is used. The CBR enhances <b>the</b> <b>exception</b> <b>handling</b> capabilities by capturing and collecting experience in handling exceptions and storing them {{in the form of}} cases. Then, these cases will be retrieved and reused for new similar situations. This mechanism allows the workflow participants to handle exceptions which need to be managed in similar way, but may occur in different instances. In our work, the workflow participants describe <b>the</b> <b>exceptions</b> in flexible way using natural language and store them as cases in case repository for future use. Then natural language processing techniques such as sentence similarity measures are used to retrieve the relevant information within CBR methodology. The feasibility of the main concepts presented in this thesis has been demonstrated using a prototype implementation. Further work has been discussed to apply the proposed P-FLOW in inter-organizational workflow scenario and potential system enhancement using agent technology. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
40|$|<b>The</b> <b>handling</b> of <b>exceptions</b> in multiclass {{problems}} {{is a tricky}} issue in inductive logic programming (ILP). In this {{paper we propose a}} new formalization of the ILP problem which accounts for default reasoning, and is encoded with first-order possibilistic logic. We show that this formalization allows us to handle rules with exceptions, and to prevent an example to be classified in more than one class. The possibilistic logic view of ILP problem, can be easily <b>handled</b> at <b>the</b> algorithmic level as an optimization problem. ...|$|R
50|$|Lionsgate Television {{produced}} such series as Nashville, Anger Management, The Dead Zone, 5ive Days to Midnight, Weeds, Nurse Jackie, Boss, Tyler Perry's House of Payne and the Emmy Award-winning Mad Men. Lionsgate also acquired TV syndication firm Debmar-Mercury in 2006 with 20th Television <b>handling</b> ad-sales with <b>the</b> <b>exception</b> for Meet <b>the</b> Browns, as <b>the</b> ad-sales are <b>handled</b> by Disney-ABC Domestic Television and Turner Television co-distributing the series. Lionsgate also co-owns Pop with CBS Corporation. In March 2013, Lionsgate {{signed with}} Mars One (a Dutch nonprofit with space agency and aerospace backers intent on colonizing Mars) {{to produce a}} reality TV show.|$|R
40|$|International audienceException {{handling}} is {{a practical}} and important way to improve the availability and reliability of a component-based system. <b>The</b> classical code-level <b>exception</b> <b>handling</b> approach is usually applied {{to the inside of}} a component, while some exceptions can only or properly be <b>handled</b> outside of <b>the</b> components. In this paper, we propose a middleware-enabled approach for exception handling at architecture level. Developers specify what exceptions should be handled and how to <b>handle</b> them with <b>the</b> support of middleware in an exception handling model, which is complementary to software architecture of the target system. This model will be interpreted at runtime by a middleware-enabled exception handling framework, which is responsible for catching and <b>handling</b> <b>the</b> specified <b>exceptions</b> mainly based on the common mechanisms provided by the middleware. Though the approach is general enough for almost all middleware-enabled systems, the framework is specific to the concrete middleware. Consequently, we demonstrate the approach in JEE (Java Platform Enterprise Edition) application servers and experiment on JEE benchmark system. We believe that this architecture-level exception handling approach, together with the classical code-level approach, can handle exceptions in component-based systems in a sufficient, efficient and flexible manner...|$|R
