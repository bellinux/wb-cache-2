533|1171|Public
25|$|Packet routing: This is {{the basic}} task of sending packets of data (<b>datagrams)</b> from source to {{destination}} by forwarding them to the next network router closer to the final destination.|$|E
25|$|The {{link layer}} defines the {{networking}} methods {{within the scope}} of the local network link on which hosts communicate without intervening routers. This layer includes the protocols used to describe the local network topology and the interfaces needed to effect transmission of Internet layer <b>datagrams</b> to next-neighbor hosts.|$|E
25|$|OpenBSD randomizes various {{behaviors}} of applications, making them less predictable {{and thus more}} difficult to attack. For example, PIDs are created and associated randomly to processes; the bind system call uses random port numbers; files are created with random inode numbers; and IP <b>datagrams</b> have random identifiers. This approach also helps expose bugs in the kernel and in user space programs.|$|E
50|$|Send <b>Datagram</b> - send a <b>datagram</b> to {{a remote}} NetBIOS name.|$|R
5000|$|<b>Datagram</b> sockets, {{also known}} as {{connectionless}} sockets, which use User <b>Datagram</b> Protocol (UDP).|$|R
50|$|Receive <b>Datagram</b> - {{wait for}} a packet to arrive from a Send <b>Datagram</b> operation.|$|R
25|$|The {{original}} DNS protocol {{had limited}} provisions for extension with new features. In 1999, Paul Vixie published in RFC 2671 an extension mechanism, called Extension mechanisms for DNS (EDNS) that introduced optional protocol elements without increasing overhead {{when not in}} use. This was accomplished through the OPT pseudo-resource record that only exists in wire transmissions of the protocol, but not in any zone files. Initial extensions were also suggested (EDNS0), such as increasing the DNS message size in UDP <b>datagrams.</b>|$|E
25|$|The {{internet}} layer {{provides an}} unreliable datagram transmission facility between hosts located on potentially different IP networks by forwarding the transport layer <b>datagrams</b> to an appropriate next-hop router for further relaying to its destination. With this functionality, the internet layer makes possible internetworking, the interworking of different IP networks, and it essentially establishes the Internet. The Internet Protocol {{is the principal}} component of the internet layer, and it defines two addressing systems to identify network hosts' computers, and to locate them on the network. The original address system of the ARPANET and its successor, the Internet, is Internet Protocol version 4 (IPv4). It uses a 32-bit IP address and is therefore capable of identifying approximately four billion hosts. This limitation was eliminated in 1998 by the standardization of Internet Protocol version 6 (IPv6) which uses 128-bit addresses. IPv6 production implementations emerged in approximately 2006.|$|E
2500|$|The {{internet}} layer has {{the task}} of exchanging <b>datagrams</b> across network boundaries. It provides a uniform networking interface that hides the actual topology (layout) of the underlying network connections. [...] It is therefore {{also referred to as}} the layer that establishes internetworking, indeed, it defines and establishes the Internet. This layer defines the addressing and routing structures used for the TCP/IP protocol suite. The primary protocol in this scope is the Internet Protocol, which defines IP addresses. Its function in routing is to transport <b>datagrams</b> to the next IP router that has the connectivity to a network closer to the final data destination.|$|E
50|$|Send Broadcast <b>Datagram</b> - send a <b>datagram</b> to all NetBIOS {{names on}} the network.|$|R
50|$|Receive Broadcast <b>Datagram</b> - {{wait for}} a packet to arrive from a Send Broadcast <b>Datagram</b> operation.|$|R
5000|$|The time-to-live value can {{be thought}} of as an upper bound on the time that an IP <b>datagram</b> can exist in an Internet system. The TTL field is set by the sender of the <b>datagram,</b> and reduced by every router on the route to its destination. If the TTL field reaches zero before the <b>datagram</b> arrives at its destination, then the <b>datagram</b> is {{discarded}} and an ICMP error <b>datagram</b> (11 - Time Exceeded) is sent back to the sender. The purpose of the TTL field is to avoid a situation in which an undeliverable <b>datagram</b> keeps circulating on an Internet system, and such a system eventually becoming swamped by such [...] "immortals".|$|R
2500|$|Unlike other routing protocols, OSPF {{does not}} carry data via a {{transport}} protocol, {{such as the}} User Datagram Protocol (UDP) or the Transmission Control Protocol (TCP). Instead, OSPF forms IP <b>datagrams</b> directly, packaging them using protocol number 89 for the IP Protocol field. OSPF defines five different message types, for various types of communication: ...|$|E
2500|$|The {{robustness}} principle states: [...] "In general, an implementation must {{be conservative}} in its sending behavior, and liberal in its receiving behavior. That is, {{it must be}} careful to send well-formed <b>datagrams,</b> but must accept any datagram that it can interpret (e.g., not object to technical errors where the meaning is still clear)." [...] "The {{second part of the}} principle is almost as important: software on other hosts may contain deficiencies that make it unwise to exploit legal but obscure protocol features." [...] Postel famously summarized the principle as, [...] "Be conservative in what you do, be liberal in what you accept from others"—a saying that {{came to be known as}} [...] "Postel's Law." ...|$|E
50|$|In IPv4, hosts {{must make}} a {{best-effort}} attempt to reassemble fragmented IP <b>datagrams</b> with a total reassembled size of up to 576 bytes. They may also attempt to reassemble fragmented IP <b>datagrams</b> larger than 576 bytes, {{but they are also}} permitted to silently discard such larger <b>datagrams.</b> Applications are recommended to refrain from sending <b>datagrams</b> larger than 576 bytes unless they have prior knowledge that the remote host is capable of accepting or reassembling them.|$|E
50|$|In {{both the}} cases, the router MUST NOT tunnel the <b>datagram.</b> Instead it should discard the <b>datagram.</b>|$|R
50|$|The sending of UDP {{broadcasts}} on {{a network}} are always enabled on a <b>datagram</b> socket. In order to receive broadcast packets, a <b>datagram</b> socket should be bound to the wildcard address. Broadcast packets may also be received when a <b>datagram</b> socket is bound to a more specific address.|$|R
50|$|<b>Datagram</b> mode is connectionless; the {{application}} {{is responsible for}} error detection and recovery. In NBT, the <b>datagram</b> service runs on UDP port 138.|$|R
50|$|A {{datagram}} {{is a basic}} {{transfer unit}} associated with a packet-switched network. <b>Datagrams</b> are typically structured in header and payload sections. <b>Datagrams</b> provide a connectionless communication service across a packet-switched network. The delivery, arrival time, and order of arrival of <b>datagrams</b> need not be guaranteed by the network.|$|E
50|$|Receiving hosts {{must make}} a {{best-effort}} attempt to reassemble fragmented IP <b>datagrams</b> that, after reassembly, contain up to 1500 bytes. Hosts are permitted to make an attempt to reassemble fragmented <b>datagrams</b> larger than 1500 bytes, {{but they are also}} permitted to silently discard any datagram after it becomes apparent that the reassembled packet would be larger than 1500 bytes. Therefore, senders should avoid sending fragmented IP <b>datagrams</b> with a total reassembled size larger than 1500 bytes, unless they have previous assurance that the receiver is capable of reassembling such large <b>datagrams.</b>|$|E
50|$|IP <b>datagrams</b> are {{encapsulated}} in datalink frames, and, therefore, {{the link}} MTU affects larger IP <b>datagrams</b> and {{forces them to}} be split into pieces equal to or smaller than the MTU size.|$|E
50|$|Wireless <b>Datagram</b> Protocol (WDP) {{defines the}} {{movement}} of information from receiver to the sender and resembles the User <b>Datagram</b> Protocol in the Internet protocol suite.|$|R
25|$|Historically, TLS {{has been}} used {{primarily}} with reliable transport protocols such as the Transmission Control Protocol (TCP). However, {{it has also been}} implemented with datagram-oriented transport protocols, such as the User <b>Datagram</b> Protocol (UDP) and the <b>Datagram</b> Congestion Control Protocol (DCCP), usage of which has been standardized independently using the term <b>Datagram</b> Transport Layer Security (DTLS).|$|R
5000|$|UDP: When {{used for}} testing UDP capacity, Iperf allows {{the user to}} specify the <b>datagram</b> size and {{provides}} results for the <b>datagram</b> throughput and the packet loss.|$|R
5000|$|IP {{fragmentation}} buffer full: The IP fragmentation buffer full exploit {{occurs when}} there is an excessive amount of incomplete fragmented traffic detected on the protected network. This could be due to an excessive number of incomplete fragmented <b>datagrams,</b> a large number of fragments for individual <b>datagrams</b> or a combination of quantity of incomplete <b>datagrams</b> and size/number of fragments in each datagram. This type of traffic is most likely an attempt to bypass security measures or Intrusion Detection Systems by intentional fragmentation of attack activity.|$|E
50|$|IP {{protocol}} 41 indicates IPv4 packets which encapsulate IPv6 <b>datagrams.</b> Some routers or {{network address}} translation devices may block protocol 41. To pass through these devices, UDP packets {{may be used to}} encapsulate IPv6 <b>datagrams.</b> Other encapsulation schemes, such as AYIYA or Generic Routing Encapsulation, are also popular.|$|E
5000|$|The Internet Protocol is {{responsible}} for addressing hosts, encapsulating data into <b>datagrams</b> (including fragmentation and reassembly) and routing <b>datagrams</b> from a source host to a destination host across one or more IP networks. For these purposes, the Internet Protocol defines the format of packets and provides an addressing system.|$|E
30|$|IP-in-IP is a {{protocol}} by which an IP <b>datagram</b> may be encapsulated (carried as payload) within an IP <b>datagram,</b> {{by adding a}} second IP header to each encapsulated <b>datagram.</b> GRE is another tunnelling method that encapsulates any network layer packet. GRE requires an IP-in-IP header to encapsulate the information and also a GRE header {{to be added to}} the packet.|$|R
50|$|<b>Datagram</b> Transport Layer Security (DTLS) is a {{communications}} protocol that provides security for datagram-based applications {{by allowing them}} to communicate {{in a way that is}} designed to prevent eavesdropping, tampering, or message forgery. The DTLS protocol is based on the stream-oriented Transport Layer Security (TLS) protocol and is intended to provide similar security guarantees. The DTLS protocol <b>datagram</b> preserves the semantics of the underlying transport — the application does not suffer from the delays associated with stream protocols, but has to deal with packet reordering, loss of <b>datagram</b> and data larger than the size of a <b>datagram</b> network packet.|$|R
5000|$|Flags: 3 bits R: 1 bitThis bit is {{reserved}} {{and should be}} 0.DF: 1 bitThis field specifies whether the <b>datagram</b> can be fragmented or not. If this bit is set to 1 in the inner header, then the outer header also have this bit set to 1 saying that this <b>datagram</b> cannot be fragmented. If this bit is set to 0 in the inner header, then the outer header may set to 0/1.MF: 1 bitThis field is required when the <b>datagram</b> is fragmented saying whether the <b>datagram</b> contains some more fragments. This field is not copied from inner header.|$|R
50|$|Datagram {{service is}} often {{compared}} to a mail delivery service, the user only provides the destination address, but receives no guarantee of delivery, and no confirmation upon successful delivery. Datagram service is therefore considered unreliable. Datagram service routes <b>datagrams</b> without first creating a predetermined path. Datagram service is therefore considered connectionless. There is also no consideration given to {{the order in which}} it and other <b>datagrams</b> are sent or received. In fact, many <b>datagrams</b> in the same group can travel along different paths before reaching the same destination.|$|E
5000|$|In IPv6, hosts {{must make}} a {{best-effort}} attempt to reassemble fragmented <b>datagrams</b> with a total reassembled size of up to 1500 bytes, larger than IPv6's minimum MTU of 1280 bytes. [...] Fragmented <b>datagrams</b> with a total reassembled size larger than 1500 bytes may optionally be silently discarded. Applications relying upon IPv6 fragmentation to overcome a path MTU limitation must explicitly fragment the datagram {{at the point of}} origin; however, they should not attempt to send fragmented <b>datagrams</b> with a total size larger than 1500 bytes unless they know in advance that the remote host is capable of reassembly.|$|E
50|$|The Internet Protocol (IP) defines {{standards}} for {{several types of}} <b>datagrams.</b>|$|E
50|$|The Gateway-to-Gateway Protocol was {{designed}} as an Internet Protocol (IP) <b>datagram</b> service similar to the Transmission Control Protocol (TCP) and the User <b>Datagram</b> Protocol (UDP). However, it is classified as an Internet Layer protocol.|$|R
5000|$|Because an IP {{internet}} can be connectionless, fragments {{from one}} <b>datagram</b> may be interleaved {{with those from}} another at the destination. The [...] "Identification field" [...] uniquely identifies the fragments of a particular <b>datagram.</b>|$|R
5000|$|Given a {{destination}} IP address, D, and network prefix, N:if ( [...] N matches a directly connected network address [...] ) Deliver <b>datagram</b> to D over that network link;else if ( [...] The routing table contains a route for N [...] ) Send <b>datagram</b> to the next-hop address {{listed in the}} routing table;else if ( [...] a default route exists [...] ) Send <b>datagram</b> to the default route;else Send a forwarding error message to the originator; ...|$|R
