174|321|Public
25|$|The {{ability of}} DOS {{versions}} 5.0 {{and later to}} move their own system core code into the high memory area (HMA) through the DOS=HIGH command gave another boost to <b>free</b> <b>memory.</b>|$|E
25|$|Seizing {{an entry}} from a pre-allocated array is faster than using dynamic memory {{allocation}} for each node, since dynamic memory allocation typically requires {{a search for}} a <b>free</b> <b>memory</b> block of the desired size.|$|E
500|$|In {{addition}} to custom songs, {{players of the}} Xbox 360, PlayStation 3, and Wii versions are able to download new licensed songs for the game. This is the first game in the Guitar Hero series to support download functionality on the Wii. Wii users are able to store downloaded songs on either the Wii's internal memory or on an SD Card in a [...] "Rock Archive," [...] and then are able to add songs to playlists from this. When playing tracks stored on an SD Card, each song is automatically copied to a [...] "content cache" [...] on the Wii's flash memory for play and then deleted after the song is finished. This requires about 200 <b>free</b> <b>memory</b> blocks on the Wii.|$|E
50|$|Insure++ can {{automatically}} find erroneous accesses to <b>freed</b> <b>memory</b> (use-after-free situations), array-bounds violations, <b>freeing</b> unallocated <b>memory</b> (which {{often happens}} when a programmer <b>frees</b> the same <b>memory</b> twice, or when he frees global or stack memory), and many others.|$|R
50|$|This {{instruction}} succeeds {{because it}} finds top == ret (both are A), so it sets top to next (which is B). As B has been deleted {{the program will}} access <b>freed</b> <b>memory</b> when it tries {{to look at the}} first element on the stack. In C++, as shown here, accessing <b>freed</b> <b>memory</b> is undefined behavior: this may result in crashes, data corruption or even just silently appear to work correctly. ABA bugs such as this can be difficult to debug.|$|R
5000|$|... a = malloc(sizeof(int)); /* {{allocate}} {{memory and}} assign {{it to the}} pointer */ [...] return 0; /* we exited the program without <b>freeing</b> <b>memory</b> */ ...|$|R
2500|$|An MMU also {{mitigates}} {{the problem}} of fragmentation of memory. [...] After blocks of memory have been allocated and freed, the <b>free</b> <b>memory</b> may become fragmented (discontinuous) so that the largest contiguous block of <b>free</b> <b>memory</b> may be {{much smaller than the}} total amount. [...] With virtual memory, a contiguous range of virtual addresses can be mapped to several non-contiguous blocks of physical memory; this non-contiguous allocation is {{one of the benefits of}} paging.|$|E
2500|$|Jobs {{stated that}} because [...] "customization really is mostly {{software}} now ... {{most of the}} options in other computers are in Mac", unlike the Apple II the Macintosh 128K did not need slots, which he described as costly and requiring larger size and more power. It was not upgradable by the user and only Apple service centers were permitted to open the case. All accessories were external, such as the MacCharlie that added IBM PC compatibility. There was no provision for adding internal storage, more RAM or any upgrade cards, however some of the Macintosh engineers objected to Jobs's ideas and secretly developed workarounds for them. As an example, the Macintosh {{was supposed to have}} only 17 address lines on the motherboard, enough to support 128k of system RAM, but the design team added an additional two address lines without Jobs's knowledge, making it possible to expand the computer to 512k, although the actual act of upgrading system RAM was difficult and required piggybacking additional RAM chips overtop the onboard 4164 chips. In September 1984, after months of complaints over the Mac's inadequate RAM, Apple released an official 512k machine. Although this had always been planned from the beginning, Steve Jobs maintained if the user desired more RAM than the Mac 128 provided, he should simply pay extra money for a Mac 512 rather than upgrade the computer himself. When the Mac 512 was released, Apple rebranded the original model as [...] "Macintosh 128k" [...] and modified the motherboard to allow easier RAM upgrades. Improving on the hard-wired RAM thus required a motherboard replacement (which was priced similarly to a new computer), or a third-party chip replacement upgrade, which was not only expensive but would void Apple's warranty. The difficulty of fitting software into its limited <b>free</b> <b>memory,</b> coupled with the new interface and event driven programming model, discouraged software vendors from supporting it, leaving the 128K with a relatively small software library. Whereas the Macintosh Plus, {{and to a lesser extent}} the Macintosh 512K, are compatible with much later software, the 128K is limited to specially crafted programs. A stock Mac 128K with the original 64K ROM is neither compatible with Apple's external 800 KB drive with HFS nor with Apple's Hard Disk 20. A Mac 128K that has been upgraded with the newer 128K ROM (called a Macintosh 128Ke) can use internal and external 800 KB drives with HFS, as well as the HD20. Both can print on an AppleShare network, but neither can do file sharing because of their limited RAM.|$|E
5000|$|Frequent garbage collection, due {{to failure}} to {{allocate}} memory for an object, due to insufficient <b>free</b> <b>memory</b> or insufficient contiguous <b>free</b> <b>memory</b> due to memory fragmentation {{is referred to}} as heap thrashing.|$|E
50|$|One of the {{key factors}} in solving these {{problems}} {{is the use of}} DCE/RPC as the underlying RPC mechanism behind DCOM. DCE/RPC has strictly defined rules regarding marshalling and who is responsible for <b>freeing</b> <b>memory.</b>|$|R
5000|$|Thread {{execution}} {{starts at}} the beginning of the function [...] To terminate the thread correctly, [...] must call [...] or end with [...] "return 0", <b>freeing</b> <b>memory</b> allocated by the run time library to support the thread.|$|R
50|$|QEMM {{provides}} up to 635K <b>free</b> conventional <b>memory</b> (RAM under 640K), {{far better}} than pure MS-DOS EMM386, FreeDOS JEMM386, UMBPCI and many other memory manager programs. QEMM maximum RAM is 635K <b>free</b> conventional <b>memory</b> with up to 256MB XMS/256MB EMS shared.|$|R
50|$|CleanGenius {{allows the}} users to {{manually}} release the inactive memory in the Mac and reclaim more memory. The Mac OS X does not release inactive memory until <b>free</b> <b>memory</b> runs out. When <b>free</b> <b>memory</b> {{is not enough}} for the fresh application, OS will release part of the inactive memory for the new demand. This mechanism would hit the performance of the application which launches {{for the first time with}} the insufficient <b>free</b> <b>memory.</b>|$|E
50|$|Fragmentation of 0% {{means that}} all the <b>free</b> <b>memory</b> is in a single large block; {{fragmentation}} is 90% (for example) when 100 MB <b>free</b> <b>memory</b> is present but largest free block of memory for allocation is just 10 MB.|$|E
5000|$|Phone memory 20 MB (Actual <b>free</b> <b>memory</b> {{may vary}} due to phone pre-configuration) ...|$|E
5000|$|... /* <b>free</b> used <b>memory</b> */ mpz_clear(x); mpz_clear(y); mpz_clear(result); ...|$|R
50|$|This program builds {{an array}} of objects, {{processes}} them in some arbitrary way, and then deletes them. Assuming that the process_items function is free of errors, {{it is clear that}} the program is safe: it never references <b>freed</b> <b>memory,</b> and it deletes all the objects that it has constructed.|$|R
50|$|In {{computer}} science, coalescing is {{the act of}} merging two adjacent <b>free</b> {{blocks of}} <b>memory.</b> When an application <b>frees</b> <b>memory,</b> gaps can fall in the memory segment that the application uses. Among other techniques, coalescing is used to reduce external fragmentation, but is not totally effective. Coalescing can be done as soon as blocks are freed, {{or it can be}} deferred until some time later (known as deferred coalescing), or it might not be done at all.|$|R
5000|$|Split a <b>free</b> <b>memory</b> slot {{larger than}} the {{requested}} memory size into half ...|$|E
5000|$|Internal memory : 16 MB (actual <b>free</b> <b>memory</b> {{may vary}} due to phone pre-configuration) ...|$|E
5000|$|Migrating {{processes}} from {{slower to}} faster nodes and from nodes that {{run out of}} <b>free</b> <b>memory.</b>|$|E
5000|$|Whereas {{the current}} swsusp (and uswsusp) {{implementations}} support writing {{the image to}} one swap device only, TuxOnIce supports multiple devices in any combination of swap files and swap partitions. It can also write the image to an ordinary file, thereby avoiding potential race issues in <b>freeing</b> <b>memory</b> when preparing to suspend.|$|R
5000|$|A memory {{swapping}} {{mechanism that}} yielded more <b>free</b> conventional <b>memory</b> ...|$|R
5000|$|OmegaT â€” OmegaT is a <b>free</b> {{translation}} <b>memory</b> application {{written in}} Java.|$|R
5000|$|Memory metrics: Memory usage, Evictions, Amount of <b>free</b> <b>memory</b> {{available}} on the host, Swap Usage, Memory fragmentation ratio ...|$|E
50|$|An MMU also {{mitigates}} {{the problem}} of fragmentation of memory. After blocks of memory have been allocated and freed, the <b>free</b> <b>memory</b> may become fragmented (discontinuous) so that the largest contiguous block of <b>free</b> <b>memory</b> may be {{much smaller than the}} total amount. With virtual memory, a contiguous range of virtual addresses can be mapped to several non-contiguous blocks of physical memory; this non-contiguous allocation is {{one of the benefits of}} paging.|$|E
50|$|Blazer is a {{web browser}} {{available}} for Palm handhelds running Palm OS 3.1 or higher with 8MB of <b>free</b> <b>memory</b> available.|$|E
5000|$|... /* {{return to}} main, having {{forgotten}} to <b>free</b> the <b>memory</b> we malloc'd */} ...|$|R
5000|$|... free(a); /* we <b>free</b> the <b>memory</b> we {{allocated}} so we don't have leaks */ muntrace (...) ...|$|R
25|$|Use-after-free error, where a pointer is used {{after the}} system has <b>freed</b> the <b>memory</b> it references.|$|R
5000|$|Mismatched free - when {{multiple}} allocators are in use, {{attempting to}} <b>free</b> <b>memory</b> with a deallocation {{function of a}} different allocator ...|$|E
5000|$|An Imported {{function}} {{shall not}} free the memory allocated by SystemVerilog code nor expect SystemVerilog code to <b>free</b> <b>memory</b> allocated by Foreign code or (Foreign Compiler).|$|E
50|$|Another {{reason to}} avoid dynamic memory {{allocation}} is memory fragmentation. With frequent allocation and releasing of small chunks of memory, a situation may {{occur when the}} memory is divided into several sections, {{in which case the}} RTOS cannot allocate a large continuous block of memory, although there is enough <b>free</b> <b>memory.</b> Secondly, speed of allocation is important. A standard memory allocation scheme scans a linked list of indeterminate length to find a suitable <b>free</b> <b>memory</b> block, which is unacceptable in an RTOS since memory allocation has to occur within a certain amount of time.|$|E
5000|$|... 384 KB of <b>free</b> {{conventional}} <b>memory</b> (real mode), 1 MB (Standard Mode), or 2 MB (Enhanced Mode) ...|$|R
5000|$|National Memory Screening Day, {{an annual}} event that offers <b>free,</b> {{confidential}} <b>memory</b> screenings and educational materials at community sites ...|$|R
50|$|Dr. Memory is an {{open-source}} memory debugging tool {{built on}} DynamoRIO and released under an LGPL license. Dr. Memory monitors memory allocations and memory accesses using shadow memory. It detects memory-related programming errors such as accesses of uninitialized <b>memory,</b> accesses to <b>freed</b> <b>memory,</b> heap overflow and underflow, and memory leaks. Its feature set {{is similar to}} that of the Valgrind-based Memcheck tool, though it operates on Windows as well as Linux and is twice as fast as Memcheck.|$|R
