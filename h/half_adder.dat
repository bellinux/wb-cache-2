76|36|Public
5000|$|The <b>half</b> <b>adder</b> adds two single {{binary digits}} A and B. It has two outputs, sum (S) and carry (C). The carry signal {{represents}} an overflow {{into the next}} digit of a multi-digit addition. The value of the sum in decimal system is [...] The simplest half-adder design, pictured on the right, incorporates an XOR gate for S and an AND gate for C. The Boolean logic for the sum (in this case S) will be AB+AB whereas for carry (C) will be AB. With the addition of an OR gate to combine their carry outputs, two half adders can be combined to make a full adder.The <b>half</b> <b>adder</b> adds two input bits and generates a carry and sum, which are the two outputs of a <b>half</b> <b>adder.</b> The input variables of a <b>half</b> <b>adder</b> are called the augend and addend bits. The output variables are the sum and carry. The truth table for the <b>half</b> <b>adder</b> is: ...|$|E
5000|$|Add a <b>half</b> <b>adder</b> {{for weight}} 2, outputs: 1 weight-2 wire, 1 weight-4 wire ...|$|E
5000|$|Add a <b>half</b> <b>adder</b> {{for weight}} 32, outputs: 1 weight-32 wire, 1 weight-64 wire ...|$|E
5000|$|Reduce {{the number}} of partial {{products}} to two by layers of full and <b>half</b> <b>adders.</b>|$|R
5000|$|Add a {{full adder}} for weight 8, and <b>half</b> <b>adders</b> for weights 4, 16, 32, 64 ...|$|R
5000|$|Reduce {{the number}} of partial {{products}} by stages of full and <b>half</b> <b>adders</b> until {{we are left with}} at most two bits of each weight.|$|R
5000|$|... #Caption: Decimal 4-digit ripple carry adder. FA = full adder, HA = <b>half</b> <b>adder.</b>|$|E
5000|$|If {{there are}} two wires of the same weight left, input them into a <b>half</b> <b>adder.</b>|$|E
5000|$|... #Caption: The {{circuit diagram}} for a binary <b>half</b> <b>adder,</b> which adds two bits together, {{producing}} sum and carry bits.|$|E
40|$|Abstract — In {{high speed}} applications, {{multipliers}} and their associated circuits like accumulators, <b>half</b> <b>adders,</b> and full adders consume a significant portion. Therefore, {{it is necessary}} to increase their performance as well as size efficiency. In order to reduce the hardware complexity which ultimately reduces an area and power, energy efficient full adders plays crucial role in Wallace tree multiplier. Reduced Complexity Wallace multiplier (RCWM) will have fewer adders than Standard Wallace multiplier (SWM). The Reduced complexity reduction method greatly reduces the number of <b>half</b> <b>adders</b> with 75 - 80 % reduction in an area of <b>half</b> <b>adders</b> than standard Wallace multipliers. In RCWM and SWM, at the last stage Carry Propagating Adder (CPA) is used. This paper proposes use of high speed, low power full adder based on Carbon Nanotube technology in reduced complexity Wallace Multiplier at the place of Conventional Full adder in order to reduce power, area and improvement in speed...|$|R
30|$|No {{function}} module fault: Let us {{assume that}} <b>half</b> <b>adders</b> 1, 2 and 3 are fault-free. Hence the respective outputs of the <b>half</b> <b>adders</b> are equivalent, i.e. Sum 1  = Sum 2  = Sum 3 and Cout 1  = Cout 2  = Cout 3. Given this, NR 1  = NR 2  =  1 / 0 and AD 1  = AD 2  =  0 / 1 respectively. As a result, NR 3  = NR 4  =  0, {{which leads to}} EFW =  0. Also, XR 1 up to XR 6 would equate to 1, and hence MD 1  = MD 2  = MD 3  =  1, resulting in ERROR =  0. Thus, EFW = ERROR =  0 which reflects the perfect healthy state of the TMR system.|$|R
50|$|Combinational {{logic is}} used in {{computer}} circuits to perform Boolean algebra on input signals and on stored data. Practical computer circuits normally contain a mixture of combinational and sequential logic. For example, the part of an arithmetic logic unit, or ALU, that does mathematical calculations is constructed using combinational logic. Other circuits used in computers, such as <b>half</b> <b>adders,</b> full <b>adders,</b> <b>half</b> subtractors, full subtractors, multiplexers, demultiplexers, encoders and decoders are also made by using combinational logic.|$|R
50|$|XOR {{can also}} be viewed as {{addition}} modulo 2. As a result, XOR gates are used to implement binary addition in computers. A <b>half</b> <b>adder</b> consists of an XOR gate and an AND gate. Other uses include subtractors, comparators, and controlled inverters.|$|E
50|$|A {{conditional}} sum adder is a recursive structure {{based on}} the carry-select adder. In the conditional sum adder, the MUX level chooses between two n/2-bit inputs that are themselves built as conditional-sum adder. The bottom level of the tree consists of pairs of 2-bit adders (1 <b>half</b> <b>adder</b> and 3 full adders) plus 2 single-bit multiplexers.|$|E
5000|$|It is {{possible}} to create a logical circuit using multiple full adders to add N-bit numbers. Each full adder inputs a Cin, which is the Cout of the previous adder. This kind of adder is called a ripple-carry adder, since each carry bit [...] "ripples" [...] to the next full adder. Note that the first (and only the first) full adder may {{be replaced by a}} <b>half</b> <b>adder</b> (under the assumption that Cin = 0).|$|E
40|$|One of {{the most}} severe short-comings of {{currently}} available equiva-lence checkers is their inability to verify integer multipliers. In this paper, we present a bit level reverse-engineering technique that can be integrated into standard equivalence checking flows. We propose a Boolean mapping algorithm that extracts a network of <b>half</b> <b>adders</b> from the gate netlist of an addition circuit. Once the arithmetic bit level representation of the circuit is obtained, equivalence checking can be performed using simple arithmetic operations. Experimental results show the promise of our approach. ...|$|R
40|$|This paper {{proposes a}} new theory of adder and its basic structure. The new adder of {{asynchronous}} structure constructed by <b>half</b> <b>adders,</b> called Parallel Feedback Carry Adder (PFCA) as its carry mode is parallel feedback. In theory, the area consumption of n-bit PFCA is close to O(n) and {{the average length of}} carry chain is O(log n). A CMOS gate implementation scheme is implemented. HSPICE simulation results show that PFCA has obvious advantages over RCA, CLA, CSeA in speed and area, especially when n is bigger...|$|R
40|$|Background: Current {{technologies}} {{results in}} gradual increase in sensitiveness towards faults causing malfunctioning of the circuit. This paper presents the novel design of Built-In-Self-Test (BIST) using self-checking circuits for bit array multipliers. Methods: The design of BIST comprises of self-checking full adder which ensures fault detection {{on the same}} chip area. Each regular full <b>adders</b> and <b>half</b> <b>adders</b> in bit array multipliers are replaced by self-checking full adder so that any transient or permanent faults can be detected and recovered. The proposed BIST design also allows power savin...|$|R
5000|$|We {{can view}} a full adder as a 3:2 lossy compressor: it sums three one-bit inputs and returns the result {{as a single}} two-bit number; that is, it maps 8 input values to 4 output values. Thus, for example, a binary input of 101 results in an output of [...] (decimal number 2). The {{carry-out}} represents bit one of the result, while the sum represents bit zero. Likewise, a <b>half</b> <b>adder</b> {{can be used as}} a 2:2 lossy compressor, compressing four possible inputs into three possible outputs.|$|E
5000|$|A {{full adder}} can be {{constructed}} from two half adders by connecting A and B to the input of one <b>half</b> <b>adder,</b> connecting the sum from that to an input to the second adder, connecting Ci to the other input and OR the two carry outputs.The critical path of a full adder runs through both XOR-gates and ends at the sum bit [...] Assumed that an XOR-gate takes 1 delays to complete, the delay imposed by the critical path of a full adder is equal toThe critical path of a carry runs through 1 XOR-gate in adder and through 2 gates (AND and OR) in carry-block and therefore, if AND- or OR-gates takes 1 delay to complete, has a delay of ...|$|E
50|$|To {{reduce the}} {{computation}} time, engineers devised faster ways to add two binary numbers by using carry-lookahead adders.They work by creating two signals (P and G) for each bit position, {{based on whether}} a carry is propagated through from a less significant bit position (at least one input is a 1), generated in that bit position (both inputs are 1), or killed in that bit position (both inputs are 0). In most cases, P is simply the sum output of a <b>half</b> <b>adder</b> and G is the carry output of the same adder. After P and G are generated, the carries for every bit position are created. Some advanced carry-lookahead architectures are the Manchester carry chain, Brent-Kung adder, and the Kogge-Stone adder.|$|E
40|$|Abstract—The paper {{describes}} an algebraic approach to functional verification of arithmetic circuits specified at bit level. The circuit is {{represented as a}} network of <b>half</b> <b>adders,</b> full adders, and inverters, and modeled as a system of linear equations. The proof of functional correctness of the design is obtained by computing its algebraic signature using standard LP solver and comparing it with the reference signature provided by the designer. Initial experimental results and comparison with SMT solvers show that the method is efficient, scalable and applicable to large arithmetic designs, such as multipliers. I...|$|R
40|$|The Architecture {{used for}} {{matching}} the data protected with an error-correcting code (ecc) presented in my project {{to reduce the}} latency and complexity. The proposed architecture parallelizes the comparison of the data {{and that of the}} parity information. A new butterfly-formed weight accumulator (BWA) is proposed for the efficient computation of the Hamming distance. The basic function of the BWA is to count the number of 1 ’s among its input bits. It consists of multiple stages of <b>half</b> <b>adders.</b> The proposed architecture checks whether the incoming data matches with the stored data...|$|R
50|$|The XOR {{logic gate}} {{can be used}} as a one-bit adder that adds any two bits {{together}} to output one bit. For example, if we add 1 plus 1 in binary, we expect a two-bit answer, 10 (i.e. 2 in decimal). Since the trailing sum bit in this output is achieved with XOR, the preceding carry bit is calculated with an AND gate. This is the main principle in <b>Half</b> <b>Adders.</b> A slightly larger Full Adder circuit may be chained together in order to add ever longer binary numbers.|$|R
50|$|This {{application}} {{was developed by}} Greg Snider of Hewlett-Packard and employs crossbar latches to replicate the functions of a <b>half</b> <b>adder,</b> which {{form the basis of}} modern computational architectures. In this application a crossbar tile is formed of a layer of horizontal row wires and a layer of vertical column wires in which memristor or similar materials are sandwiched between the horizontal and vertical wire layers. Each intersection or junction of the crossbar tile is configurable to be at a high-resistance state in which {{there is little or no}} current between the horizontal and vertical wires or at a low-resistance state in which current is permitted. Fig. 1 illustrates the configuration of a half-adder using a crossbar tile, as taught by Snider, with the nodes identifying junctions of the crossbar tile configured as low-resistance states. By setting different logic inputs A, NOT A, B, and NOT B to different row wires this configuration produces the sum and carry outputs typical for a half-adder. Connections between multiple half-adders may then be used to form full adders in accordance with conventional arithmetic architectures.|$|E
40|$|We {{have already}} {{proposed}} SFQ with Resettable Latch (SFQ-RL). SFQ-RL was proposed {{as a new}} SFQ logic, which consists of “L-gate”, “Confluence buffer”, and “Splitter”. We can realize the pipelined circuits easily using SFQ-RL, because the pipelined circuits are constructed by connecting L-gates in series. As the application of SFQ-RL to the complicated circuits with a pipelined structure, we have designed pipelined <b>Half</b> <b>Adder</b> and pipelined Carry Save Serial Adder. We have confirmed the full operation of <b>Half</b> <b>Adder.</b> The obtained bias margin was ± 15 %. We have also confirmed the partial operation of Carry Save Serial Adder...|$|E
40|$|As we {{are aware}} that carry select adder is the fastest one amongdata {{processing}} element, {{on the other hand}} due to having pairs of ripple carry adder structure traditional carry select adder consumes more area. So proposed scheme is to developa low power and low area <b>half</b> <b>adder</b> based (CSLA) using simple using common Boolean logic (CBL), where it employs one half adders to perform the summation operation for the common Boolean logic (CBL) and carry zero respectively. <b>Half</b> <b>adder</b> and CBL have to be designed where <b>half</b> <b>adder</b> requires one XOR gate, one AND gate where CBL requires only one NOT as well as one OR gate. Here also architecures like 8 -bit, 16 -bit, 32 -bit, 64 -bit square root carry select adder (SQRT CSLA) is compared with regular one and modified also. The results show there is a great reduction in area and power consumption. Our work shows the better performance in case of minimized delay, less area and low power. The obtained results from the simulation clearly proves our proposed CSLAscheme is dominates the regular SQRT CSLA...|$|E
40|$|Abstract- Multiplication of two bits {{produces}} an output which is {{twice that of}} the original bit. It is usually needed to truncate the partial product bits to the required precision to reduce area cost. Fixed-width multipliers, a subset of truncated multipliers, compute only n-most significant bits (MSBs) of the 2 n-bit product for n × n multiplication and use extra correction/compensation circuits to reduce truncation errors. Truncated multipliers provides significant improvements in area, delay, and power. The proposed method finally reduces the number of full <b>adders</b> and <b>half</b> <b>adders</b> during the tree reduction. The output {{is in the form}} of LSB and MSB. Finall...|$|R
30|$|Here in this study, we {{have chosen}} 8 [*]×[*] 8 RCMB {{multiplier}} to explain our idea. From the consolidated changes, it is revealed that we entail (N/ 2)[*]+[*] 3 multiplexers and verified for various bit width multiples of eight as outlined in Table  2. The earlier work [2] utilises N[*]+[*] 3 multiplexers for the selection of appropriate signals. Since multiplier structure is the interconnection of full <b>adders</b> and <b>half</b> <b>adders,</b> the adders involved in the critical path {{have to wait for}} the previous carry signal to produce output sum bit S. Implementation of our proposed algorithm for obtaining TP in RCMB results in less multiplexers utilisation which has its impacts on area, delay and power that are analysed in the Results and discussion section. Because of this drastic reduction in multiplexers, the area, delay and power of TP multiplier are reduced compared to prior work of implementing TP in modified booth algorithm [2].|$|R
40|$|Despite the {{progress}} of the last decades in electronic design automation, arithmetic circuits have always received way less attention than other classes of digital circuits. Logic synthesisers, which play a fundamental role in design today, play a minor role on most arithmetic circuits, performing some local optimisations but hardly improving the overall structure of arithmetic components. Architectural optimisations have been often studied manually, and only in the case of very common building blocks such as fast adders and multi-input adders, ad-hoc techniques have been developed. A notable case is multi-input addition, which is the core of many circuits such as multipliers, etc. The most common technique to implement multi-input addition is using compressor trees, which are often composed of carry-save adders (based on (3 : 2) counters, i. e., full adders). A large body of literature exists to implement compressor trees using large counters. However, all the large counters were built by using full and <b>half</b> <b>adders</b> recursively. In this paper we give some definite answers to issues related to the use of large counters. We present a general technique to implement large counters whose performance is much better than the ones composed of full and <b>half</b> <b>adders.</b> Also we show that it is not always useful to use larger optimised counters and sometimes a combination of various size counters gives the best performance. Our results show 15 % improvement in the critical path delay. In some cases even hardware area is reduced by using our counters. 1...|$|R
40|$|We gratefully {{acknowledge}} nancial {{support from the}} European Union (FPVII, 2007 - 2013) under grant agreement no 256959 NANOPOWER and grant agreement no 318287 LANDAUER {{as well as from}} the state of Bavaria. In this paper we demonstrate two realizations of a <b>half</b> <b>adder</b> based on a voltage-rectifying mechanism involving two Coulomb-coupled quantum dots. First, we examine the ranges of operation of the half adder's individual elements, the AND and XOR gates, for a single rectifying device. It allows a switching between the two gates by a control voltage and thus enables a clocked <b>half</b> <b>adder</b> operation. The logic gates are shown to be reliably operative in a broad noise amplitude range with negligible error probabilities. Subsequently, we study the implementation of the <b>half</b> <b>adder</b> in a combined double-device consisting of two individually tunable rectifiers. We show that this double device allows a simultaneous operation of both relevant gates at once. The presented devices draw their power solely from electronic fluctuations and are therefore an advancement in the field of energy efficient and autonomous electronics. PostprintPeer reviewe...|$|E
40|$|ABSTRACT: As we {{are aware}} that carry select adder is the fastest one amongdata {{processing}} element, {{on the other hand}} due to having pairs of ripple carry adder structure traditional carry select adder consumes more area. So proposed scheme is to developa low power and low area <b>half</b> <b>adder</b> based (CSLA) using simple using common Boolean logic (CBL), where it employs one half adders to perform the summation operation for the common Boolean logic (CBL) and carry zero respectively. <b>Half</b> <b>adder</b> and CBL have to be designed where <b>half</b> <b>adder</b> requires one XOR gate, one AND gate where CBL requires only one NOT as well as one OR gate. Here also architecures like 8 -bit, 16 -bit, 32 -bit, 64 -bit square root carry select adder (SQRT CSLA) is compared with regular one and modified also. The results show there is a great reduction in area and power consumption. Our work shows the better performance in case of minimized delay, less area and low power. The obtained results from the simulation clearly proves our proposed CSLA scheme is dominates the regular SQRT CSLA. Keywords:ASIC, Power, area and delay efficient, BEC, SQRT CSLA. I...|$|E
40|$|Reversible logic {{has emerged}} as one of the most {{important}} approaches for power optimization with its application in low power VLSI design. Reversible or information lossless circuits have applications in nanotechnology, digital signal processing, communication, computer graphics and cryptography. They are also a fundamental requirement in the emerging field of quantum computing. In this paper, two newoptimized universal gates are proposed. One of them has an ability to operate as a reversible <b>half</b> <b>adder</b> and half subtractor imultaneously. Another one acts only as <b>half</b> <b>adder</b> with minimum transistor count. The reversible gates are evaluated in terms of number of transistor count, critical path, garbage outputs and one to one mapping. Here transistor implementation of the proposed gates is done by using Virtuoso tool of cadence. Based on the results of the analysis, some of the trade-offs are made in the design to improve the efficiency...|$|E
40|$|ABSTRACT: Truncated {{multipliers}} offers {{significant improvements}} in area, delay, and power. The proposed method finally reduces the number of full <b>adders</b> and <b>half</b> <b>adders</b> during the tree reduction. While using this proposed method experimentally, area can be saved. The output {{is in the form}} of LSB and MSB. Finally the LSB part is compressed by using operations such as deletion, reduction, truncation, rounding and final addition. In previous related papers, to reduce the truncation error by adding error compensation circuits. In this project truncation error is not more than 1 ulp (unit of least position). So there is no need of error compensation circuits, and the final output will be précised. To further extend the work the design is realized in a FIR filter...|$|R
40|$|This thesis {{describes}} an efficient method for speeding up functional verification of arithmetic circuits namely linear network such as wallace trees, counters using linear algebra techniques. The circuit is {{represented as a}} network of <b>half</b> <b>adders,</b> full adders and inverters, and modeled as a system of linear equations. The proof of functional correctness of the design is obtained by computing its algebraic signature using standard linear programming (LP) solver and comparing it with the reference signature provided by the designer. Initial experimental results and comparison with Satisfiability Modulo Theorem (SMT) solvers show that the method is efficient, scalable and applicable to complex arithmetic designs, including large multipliers. It is intended to provide a new front end theory/engine to enhance SMT solvers...|$|R
40|$|Abstract- Reversible {{logic is}} a {{promising}} {{field of research}} that finds applications in low power computing, quantum computing, optical computing, and other emerging computing technologies. Further, floating point multiplication {{is one of the}} major operations in image and digital signal processing applications. The single precision floating-point multiplier requires the design of efficient 24 x 24 bit integer multiplier. In this work, we propose a new reversible design of single precision floating point multiplier based on operand decomposition approach. To design the reversible 24 x 24 (AxB) bit multiplier (assume A and B are of 24 bits each), the operands are decomposed into three partitions of 8 bits each. Thus, the 24 x 24 bit reversible multiplication is performed through nine reversible 8 x 8 bit Wallace tree multipliers, whose outputs are then summed. We propose a new reversible design of the 8 x 8 bit Wallace tree multiplier that has been optimized in terms of quantum cost, delay, and number of garbage outputs. Wallace tree multiplication consists of three conceptual stages: Partial product generation, partial product compression using 4 : 2 compressors, full <b>adders,</b> and <b>half</b> <b>adders,</b> and then the final addition stage to generate the product. In this work we perform optimization at each of these three stages. For the first stage, we have proposed a new generalized reversible partial product generation circuitry. For the second stage we have proposed a new reversible 4 : 2 compressor design for use in the compression tree. Finally, for the summation stage we have carefully chosen and arranged the reversible <b>half</b> <b>adders</b> and full adders in such a way to yield an efficient multiplier optimized in terms of quantum cost, delay, and garbage outputs. We have also illustrated the reversible design of 24 x 24 bit multiplier using the proposed 8 x 8 bit reversible Wallace tree multiplier. I...|$|R
