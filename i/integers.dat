10000|10000|Public
5|$|If the {{function}} f {{corresponds to a}} norm function, such as that used to order the Gaussian <b>integers</b> above, then the domain is known as norm-Euclidean. The norm-Euclidean rings of quadratic <b>integers</b> are exactly those where D=−11, −7, −3, −2, −1, 2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57 or 73. The quadratic <b>integers</b> with D=−1 and −3 are known as the Gaussian <b>integers</b> and Eisenstein <b>integers,</b> respectively.|$|E
5|$|For any two <b>integers</b> a and b, the sum a + b {{is also an}} integer. That is, {{addition}} of <b>integers</b> always yields an integer. This property is known as closure under addition.|$|E
5|$|Many of {{the other}} {{applications}} of the Euclidean algorithm carry over to Gaussian <b>integers.</b> For example, {{it can be used}} to solve linear Diophantine equations and Chinese remainder problems for Gaussian integers; continued fractions of Gaussian <b>integers</b> can also be defined.|$|E
5000|$|... struct <b>integer</b> { int i; [...] integer(int j = 0) : i(j) {} [...] <b>integer</b> operator*(const <b>integer</b> &k) const;}; <b>integer</b> integer::operator*(const <b>integer</b> &k) const { return integer(i * k.i);} ...|$|R
5000|$|Add 0.5 to the JD = 1956583.5I <b>integer</b> part = 1956583decimal number F {{fraction}} part = 0.5if I > 2299160 (Gregorian?) calculate <b>integer</b> A = (I - 1867216.25) / 36524.25; calculate <b>integer</b> B = I + 1 + A - <b>integer</b> part of(A / 4.0);else <b>integer</b> B = I = 1956583 calculate <b>integer</b> C = B + 1524 = 1958107calculate <b>integer</b> D = (C - 122.1) / 365.25 = 5360calculate <b>integer</b> E = 365.25 * D = 5360 = 1956583calculate <b>integer</b> G = (C - E) / 30.6001 = 11decimal number day = C - E + F - <b>integer</b> part of(30.6001 * G) = 31.5 noon on the 31stif G < 13.5 <b>integer</b> month = G - 1 = 11 Novemberelse <b>integer</b> month = G - 13if month > 2.5 <b>integer</b> year = D - 4716 = 644 ADelse <b>integer</b> year = D - 4715 ...|$|R
40|$|Abstract. In this invited {{contribution}} a brief review will {{be presented}} of the <b>integer</b> estimation theory as developed by the author {{over the last decade}} and which started with the introduction of the LAMBDA method in 1993. The re-view discusses three different, but closely related classes of ambiguity estimators. They are the <b>integer</b> estimators, the <b>integer</b> aperture estimators and the <b>integer</b> equivariant estimators. <b>Integer</b> estimators are <b>integer</b> aperture estima-tors and <b>integer</b> aperture estimators are <b>integer</b> equivari-ant estimators. The reverse is not necessarily true how-ever. Thus of the three types of estimators the <b>integer</b> es-timators are the most restrictive. Their pull-in regions are translational invariant, disjunct and they cover the ambi-guity space completely. Well-known examples are <b>integer</b> rounding, <b>integer</b> bootstrapping and <b>integer</b> least-squares...|$|R
5|$|The <b>integers</b> form a {{commutative}} ring whose {{elements are}} the <b>integers,</b> and the combining operations are addition and multiplication. Any pair of <b>integers</b> {{can be added}} or multiplied, always resulting in another integer, and the first operation, addition, is commutative, i.e., for any elements a and b in the ring, a+b = b+a. The second operation, multiplication, also is commutative, but that need not be true for other rings, meaning that a combined with b might be different from b combined with a. Examples of noncommutative rings include matrices and quaternions. The <b>integers</b> do not form a division ring, because the second operation cannot always be inverted; there is no integer a such that 3×a=1.|$|E
5|$|Thus, Euclid's algorithm, which computes the GCD of two <b>integers,</b> suffices to {{calculate}} the GCD of arbitrarily many <b>integers.</b>|$|E
5|$|A {{classic example}} of a random walk {{is known as the}} simple random walk, which is a {{stochastic}} process in discrete time with the <b>integers</b> as the state space, and is based on a Bernoulli process, where each iid Bernoulli variable takes either the value positive one or negative one. In other words, the simple random walk takes place on the <b>integers,</b> and its value increases by one with probability, say, , or decreases by negative one with probability , so index set of this random walk is the natural numbers, while its state space is the <b>integers.</b> If the , this random walk is called a symmetric random walk.|$|E
5000|$|... struct <b>integer</b> { int i; integer(int j = 0) : i(j) {} <b>integer</b> operator*(const <b>integer</b> &k) const [...] { return <b>integer</b> (i + k.i); }}; ...|$|R
50|$|In other words, a non-{{positive}} <b>integer</b> x≤0 {{is mapped}} {{to an even}} <b>integer</b> −2x, while a positive <b>integer</b> x>0 is mapped to an odd <b>integer</b> 2x−1.|$|R
25|$|Brahmagupta {{quadrilateral}}, a cyclic quadrilateral with <b>integer</b> sides, <b>integer</b> diagonals, and <b>integer</b> area.|$|R
5|$|A {{closely related}} problem {{concerns}} sets of <b>integers</b> {{in which each}} integer in the set is a divisor, but not necessarily a proper divisor, of one plus {{the product of the}} other <b>integers</b> in the set. This problem {{does not seem to have}} been named in the literature, and will be referred to as the improper Znám problem. Any solution to Znám's problem is also a solution to the improper Znám problem, but not necessarily vice versa.|$|E
5|$|Although the Euclidean {{algorithm}} {{is used to}} find the greatest common divisor of two natural numbers (positive <b>integers),</b> it may be generalized to the real numbers, and to other mathematical objects, such as polynomials, quadratic <b>integers</b> and Hurwitz quaternions. In the latter cases, the Euclidean {{algorithm is}} used to demonstrate the crucial property of unique factorization, i.e., that such numbers can be factored uniquely into irreducible elements, the counterparts of prime numbers. Unique factorization is essential to many proofs of number theory.|$|E
5|$|By {{allowing}} u to vary {{over all}} possible <b>integers,</b> an infinite family of solutions {{can be generated}} from a single solution (x1,y1). If the solutions are required to be positive <b>integers</b> (x>0,y>0), only {{a finite number of}} solutions may be possible. This restriction on the acceptable solutions allows some systems of Diophantine equations with more unknowns than equations to have a finite number of solutions; this is impossible for a system of linear equations when the solutions can be any real number (see Underdetermined system).|$|E
40|$|We {{study the}} {{reformulation}} of <b>integer</b> linear programs {{by means of}} a mixed <b>integer</b> linear program with fewer <b>integer</b> variables. Such reformulations can be solved efficiently with mixed <b>integer</b> linear programming techniques. We exhibit examples that demonstrate how <b>integer</b> programs can be reformulated using far fewer <b>integer</b> variables. To this end, we introduce a generalization of total unimodularity called the affine TU-dimension of a matrix and study related theory and algorithms for determining the affine TU-dimension of a matrix. We also present bounds on the number of <b>integer</b> variables needed to represent certain <b>integer</b> hulls...|$|R
5000|$|... <b>integer</b> operator*(const <b>integer</b> &k) const { <b>integer</b> m; m.i = i + k.i; return m;} ...|$|R
50|$|In number theory, {{the prime}} factors of a {{positive}} <b>integer</b> are the prime numbers that divide that <b>integer</b> exactly. The prime factorization {{of a positive}} <b>integer</b> {{is a list of}} the <b>integer's</b> prime factors, together with their multiplicities; the process of determining these factors is called <b>integer</b> factorization. The fundamental theorem of arithmetic says that every positive <b>integer</b> has a single unique prime factorization.|$|R
5|$|Bézout's {{identity}} {{states that}} the greatest common divisor g of two <b>integers</b> a and b can be represented as a linear sum of the original two numbers a and b. In other words, it is always possible to find <b>integers</b> s and t such that g = sa + tb.|$|E
5|$|C# is more type safe than C++. The only {{implicit}} conversions {{by default}} {{are those that}} are considered safe, such as widening of <b>integers.</b> This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and <b>integers,</b> nor between enumeration members and <b>integers</b> (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default.|$|E
5|$|In number theory, Znám's problem asks {{which sets}} of k <b>integers</b> have the {{property}} that each integer {{in the set}} is a proper divisor of {{the product of the}} other <b>integers</b> in the set, plus 1. Znám's problem is named after the Slovak mathematician Štefan Znám, who suggested it in 1972, although other mathematicians had considered similar problems around the same time. One closely related problem drops the assumption of properness of the divisor, and will be called the improper Znám problem hereafter.|$|E
5000|$|In number theory, the <b>integer</b> {{square root}} (isqrt) of a {{positive}} <b>integer</b> n is the positive <b>integer</b> m which is the greatest <b>integer</b> {{less than or equal}} to the square root of n, ...|$|R
50|$|For GOM six {{additional}} modes are added: CHARACTER, SHORT <b>INTEGER,</b> BYTE <b>INTEGER,</b> LONG <b>INTEGER,</b> POINTER, and DYNAMIC RECORD.|$|R
5000|$|... <b>integer</b> p = rq(x) + rq(y) * (0); <b>integer</b> p = rq(x) + 0; <b>integer</b> p = rq(x); ...|$|R
5|$|In the 19th century, the Euclidean {{algorithm}} led to {{the development}} of new number systems, such as Gaussian <b>integers</b> and Eisenstein <b>integers.</b> In 1815, Carl Gauss used the Euclidean algorithm to demonstrate unique factorization of Gaussian <b>integers,</b> although his work was first published in 1832. Gauss mentioned the algorithm in his Disquisitiones Arithmeticae (published 1801), but only as a method for continued fractions. Peter Gustav Lejeune Dirichlet seems to have been the first to describe the Euclidean algorithm as the basis for much of number theory. Lejeune Dirichlet noted that many results of number theory, such as unique factorization, would hold true for any other system of numbers to which the Euclidean algorithm could be applied. Lejeune Dirichlet's lectures on number theory were edited and extended by Richard Dedekind, who used Euclid's algorithm to study algebraic <b>integers,</b> a new general type of number. For example, Dedekind was the first to prove Fermat's two-square theorem using the unique factorization of Gaussian <b>integers.</b> Dedekind also defined the concept of a Euclidean domain, a number system in which a generalized version of the Euclidean algorithm can be defined (as described below). In the closing decades of the 19th century, the Euclidean algorithm gradually became eclipsed by Dedekind's more general theory of ideals.|$|E
5|$|PHP stores <b>integers</b> in a platform-dependent range, {{either a}} 64-bit or 32-bit signed integer {{equivalent}} to the C-language long type. Unsigned <b>integers</b> are converted to signed values in certain situations; this behavior {{is different from that}} of other programming languages. Integer variables can be assigned using decimal (positive and negative), octal, hexadecimal, and binary notations.|$|E
5|$|September 22, 2009: The {{identifier}} {{exceeded the}} limit for 32-bit unsigned <b>integers</b> (4,294,967,296 total messages) again breaking some third-party clients.|$|E
5000|$|... s0 is {{the nearest}} <b>integer</b> to E2; s1 is the nearest <b>integer</b> to E4; s2 is the nearest <b>integer</b> to E8; for sn, take E2, square it n more times, {{and take the}} nearest <b>integer.</b>|$|R
50|$|For every <b>integer</b> a, {{there is}} an <b>integer</b> b such that a + b = b + a = 0. The <b>integer</b> b is called the inverse element of the <b>integer</b> a and is denoted −a.|$|R
50|$|An <b>integer</b> {{sequence}} is a computable sequence, if there exists an algorithm which given n, calculates an, for all n > 0. An <b>integer</b> {{sequence is}} a definable sequence, if there exists some statement P(x) {{which is true}} for that <b>integer</b> sequence x and false for all other <b>integer</b> sequences. The set of computable <b>integer</b> sequences and definable <b>integer</b> sequences are both countable, with the computable sequences a proper subset of the definable sequences (in other words, some sequences are definable but not computable). The set of all <b>integer</b> sequences is uncountable (with cardinality {{equal to that of}} the continuum); thus, almost all <b>integer</b> sequences are uncomputable and cannot be defined.|$|R
5|$|The Gaussian <b>integers</b> {{are complex}} {{numbers of the}} form α=u+vi, where u and v are {{ordinary}} <b>integers</b> and i is the square root of negative one. By defining an analog of the Euclidean algorithm, Gaussian <b>integers</b> can {{be shown to be}} uniquely factorizable, by the argument above. This unique factorization is helpful in many applications, such as deriving all Pythagorean triples or proving Fermat's theorem on sums of two squares. In general, the Euclidean algorithm is convenient in such applications, but not essential; for example, the theorems can often be proven by other arguments.|$|E
5|$|The {{generalized}} Euclidean algorithm {{requires a}} Euclidean function, i.e., a mapping f from R into {{the set of}} nonnegative <b>integers</b> such that, for any two nonzero elements a and b in R, there exist q and r in R such that a = qb + r and f(r) < f(b). An example of this mapping is the norm function used to order the Gaussian <b>integers</b> above. The function f can be {{the magnitude of the}} number, or the degree of a polynomial. The basic principle is that each step of the algorithm reduces f inexorably; hence, if f can be reduced only a finite number of times, the algorithm must stop in a finite number of steps. This principle relies heavily on the natural well-ordering of the non-negative integers; roughly speaking, this requires that every non-empty set of non-negative <b>integers</b> has a smallest member.|$|E
5|$|The {{group of}} <b>integers</b> modulo n is written Zn or Z/nZ.|$|E
50|$|An <b>integer</b> {{relation}} {{algorithm is}} an algorithm for finding <b>integer</b> relations. Specifically, given {{a set of}} real numbers known to a given precision, an <b>integer</b> relation algorithm will either find an <b>integer</b> relation between them, or will determine that no <b>integer</b> relation exists with coefficients whose magnitudes are less than a certain upper bound.|$|R
500|$|For every <b>integer</b> a, {{there is}} an <b>integer</b> b such that a + b = b + a = 0. The <b>integer</b> b [...] is called the inverse element of the <b>integer</b> a and is denoted −a.|$|R
50|$|Cramer's rule {{can be used}} {{to prove}} that an <b>integer</b> {{programming}} problem whose constraint matrix is totally unimodular and whose right-hand side is <b>integer,</b> has <b>integer</b> basic solutions. This makes the <b>integer</b> program substantially easier to solve.|$|R
