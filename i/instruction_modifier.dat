4|5|Public
5000|$|The {{presence}} of the Horizontal Fine Scroll Display List <b>Instruction</b> <b>Modifier.</b>|$|E
50|$|Fine {{scrolling}} requires setup {{to define}} the horizontal scrolling region. The {{first step is to}} start with a Display List using the LMS <b>instruction</b> <b>modifier</b> to specify starting address of each Mode line. This is done to organize screen memory as long rows of data for the display. The next step is setting the Horizontal Scroll (HS) modifier bit in all Display List Mode line instructions for the scrolling region.|$|E
5000|$|Vertical coarse {{scrolling}} is {{the easiest}} feature to exercise. The first Text or Map Mode instruction in every Display List always includes the LMS <b>instruction</b> <b>modifier</b> specifying the start of screen memory. As it generates the display, ANTIC automatically increments its memory scan pointer from Mode line to Mode line to display memory contiguously. Therefore, a display can be [...] "moved" [...] by merely updating the initial LMS modifier's address; adding the number of bytes used for {{a line in the}} current Text or Map Mode shifts the screen contents up one line while subtracting the same amount moves the screen down. So, the display is actually a view port that is moved to look at a different areas of memory rather than moving the memory into a fixed screen map.|$|E
50|$|The {{earliest}} published {{version of}} Redcode defined only eight instructions. The ICWS-86 standard {{increased the number}} to 10 while the ICWS-88 standard increased it to 11. The currently used ICWS-94 standard has 16 instructions. However, Redcode supports {{a number of different}} addressing modes and (from ICWS-94) <b>instruction</b> <b>modifiers</b> which increase the actual number of operations possible to 7168. The Redcode standard leaves the underlying instruction representation undefined and provides no means for programs to access it. Arithmetic operations may be done on the two address fields contained in each instruction, but the only operations supported on the instruction codes themselves are copying and comparing for equality.|$|R
5000|$|Map and Character mode <b>instructions</b> have {{additional}} <b>modifiers</b> {{that can be}} enabled with the instruction: ...|$|R
50|$|Naturally, that trivial {{example is}} of limited usefulness. Many {{scrolling}} implementations scroll {{only part of}} the screen while other sections remain fixed. This problem is solved by the inherent capabilities of the ANTIC Display List. In this situation the Display List would add Mode <b>instructions</b> using LMS <b>modifiers</b> on the first mode line of the screen sections that should not move which effectively locks these parts of the display while the LMS modifier address for the scrolling section is updated.|$|R
50|$|Instructions {{and data}} {{are based on}} a 39-bit word length with binary {{representation}} in 2's complement arithmetic. The instruction set operates on a single address and single accumulator register, with an additional auxiliary register for double length integer multiply and divide. Although it is believed that the single length divide and square root instructions were only enabled in 803s destined for process control applications, the one remaining operational 803B has been found to have these instructions enabled, probably because it was used by a software house to develop real time and process control applications. An instruction is composed of a 6-bit instruction (conventionally represented in octal) and a 13 bit address. This gives 64 instructions organised as 8 groups of 8 instructions. The 13 bit memory address field gives an addressable range of 8192 words. These 19-bit instructions are packed two to a word with an additional 39th bit between them, the so-called B-line or B digit (the term is a legacy from the Ferranti Mark 1 computer, where the A-line represented the accumulator and the B-line an <b>instruction</b> <b>modifier,</b> both displayed on a Williams tube). Setting the B digit has the effect of adding the contents of the memory address of the first instruction to the second instruction at execution time, enabling indirect addressing and other run-time instruction modifications. The bit time is 6 microseconds, jumps execute in 288 microseconds and simple arithmetic instructions in 576 microseconds. Floating point operations take several milliseconds. IO is direct and there are no interrupts.|$|E
50|$|Note {{that when}} {{updating}} display control values {{care must be}} taken to ensure ANTIC is not currently using them. If ANTIC is processing the Display List containing an Instruction with the DLI modifier, then an interrupt could be dispatched while changing the VDSLST address, potentially crashing the system. If a Display List uses multiple interrupts, and interrupts are enabled in NMIEN after ANTIC has already passed Mode <b>Instructions</b> with DLI <b>modifiers,</b> then the Display List Interrupts will be started out of order, causing unexpected results.|$|R
40|$|Graduation date: 1969 An {{instruction}} set and programming examples are described for a Distributed Logic Memory computer organization. The computer {{is designed to}} take advantage of the economies of very large-scale circuit integration. In addition, the computer can grow in an orderly way. As it grows there is increased parallelism possible so that the amount of spare real time in a control application is not greatly reduced. Finally, such an organization should permit stored program control in relatively small applications where up to now control by a conventionally organized computer has been prohibitively expensive. The computer consists of a linear array of identical, small, sequential machines, or cells. The structure is similar to that of the Distributed Logic Memory originally proposed by C. Y. Lee. It was demonstrated by J. N. Sturman that the addition of sequential logic to each cell permits the memory to become a self-contained computing system. It is the purpose of this thesis to produce an application-oriented process control computer design based on the concepts of Lee and Sturman. It was found necessary to increase the length of the memory word in each cell. The ability to store instructions and data in cells is retained. Increasing the memory word length of each cell permits an expanded instruction repertoire. The low-ordered three bits of every memory word are arranged to identify a cell as one of eight possible types. A program <b>instruction</b> includes <b>modifier</b> bits which specify the types of cells on which the instruction is to operate. This facility enhances the efficiency of programs. The logic design of the cell is complete enough to permit estimating gate count per cell. An analysis of the sensitivity of gate count to changes in the {{instruction set}} is included. A program simulation of the Distributed Logic Memory computer assisted in its development and later permitted verification of programs written for the computer. The existence of a compiler permitted such programs to be written in a convenient, symbolic form. A data multiplexer is developed as a practical application for the Distributed Logic Memory computer structure. The necessary data multiplexer program, which consists of about 100 instructions, is shown...|$|R

