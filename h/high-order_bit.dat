24|64|Public
50|$|Omission of the <b>high-order</b> <b>bit</b> of the divisor polynomial: Since the <b>high-order</b> <b>bit</b> {{is always}} 1, and since an n-bit CRC must {{be defined by}} an (n + 1)-bit divisor which {{overflows}} an n-bit register, some writers assume that it is unnecessary to mention the divisors <b>high-order</b> <b>bit.</b>|$|E
50|$|Further we {{consider}} that the little-order bit {{is located at the}} left of a block, and the <b>high-order</b> <b>bit</b> at the right.|$|E
5000|$|PSW.4: RS1 Register select 1. The <b>high-order</b> <b>bit</b> of the {{register}} bank. Set when banks at 0x10 or 0x18 are in use.|$|E
5000|$|... "analog" [...] contexts, {{consisting}} of the <b>high-order</b> <b>bits</b> of previous 8- or 16-bit words (useful for multimedia files); ...|$|R
40|$|Abstract⎯The {{amount of}} {{information}} recorded in the prediction tables of the proposed address predictors {{turns out to be}} comparable to the current on-chip cache sizes; for instance, a last-address predictor that records 4. 096 64 -bit effective addresses uses a 32 Kbytes storage space. Area cost of address predictors is proportional to address width. To reduce their area cost, we will take advantage of the spatial-locality property of the memory references, that is, the <b>high-order</b> <b>bits</b> of several effective addresses recorded in the prediction table are equal. Then, the effective addresses are split in two parts: the <b>high-order</b> <b>bits</b> and the low-order bits. The High-Address Table records the <b>high-order</b> <b>bits</b> and the Low-Address Table records the low-order bits and a link between tables. This organization allows addresses with the same <b>high-order</b> <b>bits</b> to share one entry in the High-Address Table. We use this organization in a last-address predictor and our evaluations show that it produces significant area-cost reductions (28 %- 60 %) without performance losses. Keywords⎯address prediction, address locality, area cost A I...|$|R
5000|$|Most {{baseline}} core devices, {{and some}} mid-range core devices, use the <b>high-order</b> <b>bits</b> of the file select register {{to select the}} current register bank.|$|R
50|$|If the <b>high-order</b> <b>bit</b> is 0, {{the lower}} 16 {{bits of the}} address refer to a {{location}} in the first 64K words of main memory; if the <b>high-order</b> <b>bit</b> is 1, the lower 16 bits of the address refer to a location in a 64K-word block of memory specified by the Extension Address in bits 42-47 of the Program Status Doubleword, with the Extension Address being concatenated with the lower 16 bits of the reference address to form the physical address.|$|E
5000|$|For the Sigma 9, when real {{extended}} addressing is enabled, the reference address field is interpreted differently {{depending on whether}} the <b>high-order</b> <b>bit</b> is 0 or 1: ...|$|E
50|$|The program loader {{uses the}} <b>high-order</b> <b>bit</b> of the instruction, ignored by all models, as a flag {{indicating}} that the instruction currently being loaded is to be relocated.|$|E
50|$|In {{order to}} {{represent}} the bit combination (bitto kumiawase) of a one-byte code, two decimal numbers - a column number and a line number - are used. Three <b>high-order</b> <b>bits</b> out of seven or four <b>high-order</b> <b>bits</b> out of eight, counting from zero to seven or from zero to fifteen respectively, form the column number. Four low-order bits counting from zero to fifteen form the line number. Each number corresponds to one hexadecimal digit, but is conventionally written in decimal.|$|R
40|$|Abstract. : The {{amount of}} {{information}} recorded in the prediction tables of the address predictors {{turns out to be}} comparable to current on-chip cache sizes. To reduce their area cost, we consider the spatial-locality property of memory references. We propose to split the addresses in two parts (<b>high-order</b> <b>bits</b> and low-order bits) and record them in different tables. This organization allows to record only once every unique <b>high-order</b> <b>bits.</b> We use it in a last-address predictor and our evaluations show that it produces significant area-cost reductions (28 %- 60 %) without performance decreases. ...|$|R
5000|$|... 20-bit {{operations}} use {{the length}} suffix [...] "A" [...] (for address) instead of [...]B or [...]W[...]W {{is still the}} default. In general, shorter operations clear the <b>high-order</b> <b>bits</b> of the destination register.|$|R
5000|$|The {{desire to}} retain the <b>high-order</b> <b>bit</b> as a [...] "control or escape bit." [...] In particular, the {{standard}} subroutine calling convention marked the final parameter word by setting its high bit.|$|E
50|$|The ICMPv6 packet {{consists}} of a header and the protocol payload. The header contains only three fields: type (8 bits), code (8 bits), and checksum (16 bits). type specifies the type of the message. Values {{in the range from}} 0 to 127 (<b>high-order</b> <b>bit</b> is 0) indicate an error message, while values in the range from 128 to 255 (<b>high-order</b> <b>bit</b> is 1) indicate an information message. The code field value depends on the message type and provides an additional level of message granularity. The checksum field provides a minimal level of integrity verification for the ICMP message.|$|E
50|$|Early {{microcomputer}} software {{relied upon}} {{the fact that}} ASCII codes do not use the <b>high-order</b> <b>bit,</b> and set it to indicate {{the end of a}} string. It must be reset to 0 prior to output.|$|E
50|$|The 4 <b>high-order</b> <b>bits</b> of TA1 (8th MSbit to 5th LSbit) encode fmax and Fi as:(*) Historical note: in ISO/IEC 7816-3:1989, {{this was}} {{assigned}} to cards with internal clock, with no assigned Fi or f(max).|$|R
50|$|TDi encodes in its 4 <b>high-order</b> <b>bits</b> the {{presence}} of at most 4 other interface bytes: TAi+1 (resp. TBi+1, TCi+1, TDi+1) follow, in that order, if the 5th (resp. 6th, 7th, 8th) bit of TDi is.|$|R
5000|$|The three <b>high-order</b> <b>bits</b> of the 12-bit {{instruction}} word (labelled bits 0 through 2) are the operation code. For the six operations that refer to memory, bits 5 through 11 provide a 7-bit address. Bit 4, if set, says {{to complete the}} address using the 5 <b>high-order</b> <b>bits</b> of the PC; if clear, zeroes are used. Bit 3 specifies indirection; if set, the address obtained as described so far points to a 12-bit value in memory that gives the actual effective address for the instruction. (The JMP instruction does not operate on a memory word, except if indirection is specified, but has the same bit fields.) ...|$|R
5000|$|The caller {{passes the}} address of a list of {{argument}} addresses in register 1. The last address has the <b>high-order</b> <b>bit</b> set to indicate {{the end of the}} list. This limits programs using this convention to 31-bit addressing.|$|E
50|$|In computing, {{the most}} {{significant}} bit (MSB, also called the <b>high-order</b> <b>bit)</b> is the bit position in a binary number having the greatest value. The MSB is {{sometimes referred to as}} the left-most bit due to the convention in positional notation of writing more significant digits further to the left.|$|E
5000|$|Omission of the low-order {{bit of the}} divisor polynomial: Since the low-order bit {{is always}} 1, authors such as Philip Koopman {{represent}} polynomials with their <b>high-order</b> <b>bit</b> intact, but without the low-order bit (the [...] or 1 term). This convention encodes the polynomial complete with its degree in one integer.|$|E
50|$|It also encodes in its 4 <b>high-order</b> <b>bits</b> the {{presence}} of at most 4 other interface bytes: TA1 (resp. TB1, TC1, TD1) follow, in that order, if the 5th (resp. 6th, 7th, 8th) bit of T0 is.|$|R
25|$|Sorting order: The chosen {{values of}} the leading bytes {{and the fact that}} the {{continuation}} bytes have the <b>high-order</b> <b>bits</b> first means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.|$|R
5000|$|Sorting order: The chosen {{values of}} the leading bytes {{and the fact that}} the {{continuation}} bytes have the <b>high-order</b> <b>bits</b> first means that sorting a list of UTF-8 strings will produce the same order as sorting the equivalent UTF-32 strings.|$|R
5000|$|One {{historically}} prominent {{example of}} offset-64 (excess-64) notation {{was in the}} floating point (exponential) notation in the IBM System/360 and System/370 generations of computers. The [...] "characteristic" [...] (exponent) {{took the form of}} a seven-bit excess-64 number (The <b>high-order</b> <b>bit</b> of the same byte contained the sign of the significand).|$|E
5000|$|Many early {{communications}} protocol standards, such as , , [...] for SMTP, [...] for NNTP, , , , {{were designed to}} work over such [...] "7-bit" [...] communication links. They specifically mention the use of ASCII character set [...] "transmitted as a 8-bit byte with the <b>high-order</b> <b>bit</b> cleared to zero" [...] and some of theseexplicitly restrict all data to 7-bit characters.|$|E
50|$|One notable way {{in which}} ISO {{character}} sets differ from code pages is that the character positions 128 to 159, corresponding to ASCII control characters with the <b>high-order</b> <b>bit</b> set, are specifically unused and undefined in the ISO standards, though they had often been used for printable characters in proprietary code pages, a breaking of ISO standards that was almost universal.|$|E
5000|$|The mapping from zone punches to <b>high-order</b> <b>bits.</b> All codes {{translate}} no zone punches to a {{bit pattern}} of 00, but some encode the zone punches in 12-11-0 order, preserving alphabetical order, while others use 0-11-12 order, {{resulting in a}} partially reversed alphabet.|$|R
5000|$|Extended instruction, not {{available}} on most 12-bit PICs. Of the models with extended RAM, most (e.g. 16C5x, 16F5x) extend the register address space using the <b>high-order</b> <b>bits</b> of the FSR. A few (e.g. PIC12F529T39A) {{have a separate}} bank select register which can be set with this instruction.|$|R
5000|$|Queue {{a request}} with the given low-order address bits A14:3 and length 8×(L2:0+1). The command and <b>high-order</b> <b>bits</b> are as {{previously}} specified. Any number of requests may be queued by sending only this pattern, {{as long as}} the command and higher address bits remain the same.|$|R
5000|$|An IBM program RPQ {{added support}} for the IBM 3330 direct access storage facility, and this RPQ was applied by most users of ATS/360 which had {{migrated}} to early IBM System/370 processors. Essentially, this RPQ appended selected instances of the cannonical Load Halfword (LH) instruction (which implicitly featured [...] "sign extension" [...] from the halfword's <b>high-order</b> <b>bit,</b> conceptually bit 15 to the remaining 16 bits of the specified general purpose register, conceptually bits 31 to 16) with a logical and (N) instruction which specified a [...] "mask" [...] of 0x0000ffff, and which eliminated {{the effect of the}} <b>high-order</b> <b>bit</b> extension. This, then, allowed for 16-bit disk block addresses, which could later be converted into the expected and required CCHHR format. This approach was also applicable to IBM 3350 direct access storage facilities which were operated in 3330 compatibility mode, and which sacrificed 117 MB of the 3350's 317 MB total capacity in order to implement compatibility mode (two 3300 equivalent drives on one 3350 drive).|$|E
5000|$|The IEEE Standard for Floating-Point Arithmetic (IEEE 754) uses {{various sizes}} of exponent, but also uses offset {{notation}} for {{the format of}} each precision. Unusually however, instead of using [...] "excess 2n−1" [...] it uses [...] "excess 2n−1 − 1" [...] (i.e. excess-15, excess-127, excess-1023, excess-16383) which means that inverting the leading (<b>high-order)</b> <b>bit</b> of the exponent will not convert the exponent to correct twos complement notation.|$|E
50|$|Positive {{numbers are}} the same simple, binary system used by two's {{complement}} and sign-magnitude. Negative values are the bit complement of the corresponding positive value. The largest positive value {{is characterized by the}} sign (<b>high-order)</b> <b>bit</b> being off (0) and all other bits being on (1). The smallest negative value is characterized by the sign bit being 1, and all other bits being 0. The table below shows all possible values in a 4-bit system, from −7 to +7.|$|E
50|$|One {{case where}} this problem cannot arise {{is if the}} {{initiator}} knows somehow (presumably because the addresses share sufficient <b>high-order</b> <b>bits)</b> that the second transfer is addressed to the same target as the previous one. In that case, it may perform back-to-back transactions. All PCI targets must support this.|$|R
5000|$|Many {{communication}} protocols apply serial number arithmetic to packet sequence numbers in their {{implementation of a}} sliding window protocol. Some versions of TCP use [...] protection against wrapped sequence numbers (PAWS). PAWS applies the same serial number arithmetic to packet timestamps, using the timestamp {{as an extension of}} the <b>high-order</b> <b>bits</b> of the sequence number.|$|R
50|$|The <b>high-order</b> nine <b>bits</b> {{specify the}} {{operation}} {{to be performed}} (with bit 15 generally selecting word versus byte addressing). (There are not as many operations as it seems, as most combinations of the <b>high-order</b> four <b>bits</b> are taken by the double-operand instructions.) A single group of six bits specifies mode and register, as defined above, for the single operand.|$|R
