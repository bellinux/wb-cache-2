25|207|Public
40|$|Keywords Aspect-oriented programming, {{predicate}} dispatching, <b>incremental</b> <b>programming,</b> extensibility, {{separation of}} concerns 1. INTRODUCTION <b>Incremental</b> <b>programming</b> {{is defined by}} Cook and Palsberg as {{the construction of new}} program components by specifying how they differ from existing components [9]. A language that supports <b>incremental</b> <b>programming</b> allows for clean separation of concerns, because a component that involves multiple concerns can be expressed as a sequence of components, one per concern, each one extending or overriding the behavior in the previous components without requiring modification or duplication of code. This can improve the understanding, maintenance, and re-use of software. Object-oriented programming (OOP) languages typically support <b>incremental</b> <b>programming</b> with inheritance and dyTo appear in the 1 st International Conference on Aspect-Oriented SoftwareDevelopment (AOSD), April 2002, Enschede, The Netherlands...|$|E
40|$|Languages {{that support}} <b>incremental</b> <b>programming,</b> that is, the {{construction}} of new program components by specifying how they differ from existing components, allow for clean separation of concerns. Object-oriented languages support <b>incremental</b> <b>programming</b> with inheritance and dynamic dispatch features: whenever a message is sent, a decision occurs, but the branches of the decision can be specified in separate components. Aspect-oriented programming and predicate dispatching both introduce language mechanisms that improve on this support by allowing an extensible decision to depend on information about the message send other than just the dynamic type of the receiver or arguments. A small prototype language is presented that unifies the best features of these mechanisms, providing uniform support for <b>incremental</b> <b>programming</b> whether concerns are crosscutting or not. The language is demonstrated with a running example, a small data structure library that is incrementally extended with optimizations and new operations...|$|E
40|$|In {{this paper}} a new {{language}} for Knowledge Engineering is presented. Its main characteristics are: modularity, <b>incremental</b> <b>programming</b> of KB's, partial evaluation and modular uncertainty treatment. The partial evaluation {{is presented as a}} good mechanism to provide richer communication patterns of the system and the final users. It allows to give more explanatory answers that the classical inference mechanisms employed in expert systems. A rough description of the language MILORD II is presented stressing its modularity structures that allow to define generic modules and <b>incremental</b> <b>programming</b> operations between the modules. Some examples obtained from the applications developed using this language are presented...|$|E
40|$|Given {{a program}} f and an input change ⊕, {{we wish to}} obtain an <b>incremental</b> <b>program</b> that computes f(x⊕ y) {{efficiently}} by making use {{of the value of}} f(x), the intermediate results computed in computing f(x), and auxiliary information about x that can be inexpensively maintained. Obtaining such <b>incremental</b> <b>programs</b> {{is an essential part of}} the transformational-programming approach to software development and enhancement. This paper presents a systematic approach that discovers a general class of useful auxiliary information, combines it with useful intermediate results, and obtains an efficient <b>incremental</b> <b>program</b> that uses and maintains these intermediate results and auxiliary information. We give a number of examples from list processing, VLSI circuit design, image processing, etc...|$|R
40|$|To evolve {{structured}} programs we introduce H-PIPE, {{a hierarchical}} extension of Probabilistic <b>Incremental</b> <b>Program</b> Evolution (PIPE - Sa/lustowicz and Schmidhuber, 1997). Structure is induced by "hierarchical instructions" (HIs) limited to top-level, structuring program parts. "Skip nodes" (SNs) inspired by biology's introns (non-coding segments) allow for switching program parts on and off. In our experiments H-PIPE outperforms PIPE, and SNs facilitate synthesis of certain structured programs but not unstructured ones. We conclude that introns {{can be particularly}} useful {{in the presence of}} structural bias. Keywords: Probabilistic <b>Incremental</b> <b>Program</b> Evolution, Structured Programs, Hierarchical Programs, Introns, Non-Coding Segments. 1 Introduction and Previous Work Overview. Hierarchical Probabilistic <b>Incremental</b> <b>Program</b> Evolution (H-PIPE) is a novel method for synthesizing structured programs. It uses the PIPE paradigm (Sa/lustowicz and Schmidhuber, 1997) to iteratively generate succes [...] ...|$|R
40|$|To evolve {{structured}} programs we introduce H-PIPE, {{a hierarchical}} extension of Probabilistic <b>Incremental</b> <b>Program</b> Evolution (PIPE). Structure is induced by "hierarchical instructions" (HIs) limited to top-level, structuring program parts. "Skip nodes" (SNs) allow for switching program parts on and off. They facilitate synthesis of certain structured programs. In our experiments HPIPE outperforms PIPE: structural bias can speed up program synthesis. Keywords: Probabilistic <b>Incremental</b> <b>Program</b> Evolution, Structured Programs, Hierarchical Programs, Non-Coding Segments. 1 Introduction Overview. Automatic program synthesis {{is of interest}} because it addresses the problem of searching in general algorithm space as opposed to more limited search spaces like those of, say, feedforward neural networks. Hierarchical Probabilistic <b>Incremental</b> <b>Program</b> Evolution (H-PIPE) is a novel method for synthesizing structured programs. It uses the PIPE paradigm (Sa/lustowicz and Schmidhuber, 1997) to iterativ [...] ...|$|R
40|$|International audienceMixin modules are a {{framework}} for modular programming that supports code parameterization, <b>incremental</b> <b>programming</b> via late binding and redefinitions, and cross-module recursion. In this paper, we develop a language of mixin modules that supports call-by-value evaluation, and formalize a reduction semantics and a sound type system for this language...|$|E
40|$|Much of {{the elegance}} {{and power of}} Smalltalk comes from its {{programming}} environment and tools, but despite the passage of more than 20 years, the Smalltalk browser {{is much the same}} today as when it was first introduced. We have extended this browser with features that dramatically improve its support for <b>incremental</b> <b>programming</b> by employing real-time analysis of the code being modified. We illustrate these improvements by example, and summarize the algorithms used to implement them efficiently...|$|E
40|$|Ada  9 X-the revised {{definition}} of the Ada programming language-provides support for object-oriented programming. This course examines the new, object-oriented features of the language, their use, and how they fit into Ada's strong type system and genericity mechanisms. Basic object-oriented mechanisms are covered, such as: extension, inheritance, and polymorphism. We then show how to integrate these mechanisms into good programming practice; topics include <b>incremental</b> <b>programming,</b> heterogeneous data structures, and mixin inheritance. The running theme is design for reuse...|$|E
40|$|A {{systematic}} approach is given for symbolically caching intermediate results useful for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. We exploit {{a number of}} program analysis and transformation techniques, centered around effective caching based on its utilization in deriving <b>incremental</b> <b>programs,</b> {{in order to increase}} the degree of incrementality not otherwise achievable by using only the return values of programs that are of direct interest. Our method can be applied straightforwardly to provide a {{systematic approach}} to program improvement via caching...|$|R
40|$|A {{systematic}} approach is given for symbolically caching intermediate results useful for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. We exploit {{a number of}} program analysis and transformation techniques, centered around effective caching based on its utilization in deriving <b>incremental</b> <b>programs,</b> {{in order to increase}} the degree of incrementality not otherwise achievable by using only the return values of programs that are of direct interest. Our method can be applied straightforwardly to provide a {{systematic approach}} to program improvement via caching. 1 Introduction <b>Incremental</b> <b>programs</b> take advantage of repeated computations on inputs that differ only slightly from one another, making use of the old output in computing a new output rather than computing from scratch. Methods of incremental computation have widespread application, e. g., optimizing compilers [2, 9, 11], transformational programming [29, 32, 42], interactive editing systems [4, 38], etc. In this paper, [...] ...|$|R
40|$|A {{systematic}} stepwise transformational {{approach is}} given for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. We exploit partial evaluation, other static analysis and transformation techniques, and domain-specific knowledge {{in order to}} provide a degree of incrementality not otherwise achievable by a generic incremental evaluator. The generality of our model of incremental computation is discussed and compared with related work. Illustrative examples using the transformational approach are given. 1 Introduction <b>Incremental</b> <b>programs</b> take advantage of repeated computations on inputs that differ only slightly from one another, avoiding unnecessary duplication of common computations. Given a computation of f(x) with result r and a new input x Φ ffix to the <b>program</b> f, an <b>incremental</b> <b>program</b> f 0 computes the result of f(x Φ ffix) by making use of r, avoiding computations previously done by f(x). Methods of incremental computation have widespread application throughout s [...] ...|$|R
40|$|This paper {{proposes a}} new model of programming, in which the {{behavior}} of a program can be defined as separate decision point branches. Allowing more precise expression of the condition determining when a branch should be chosen at a decision point leads to better support for <b>incremental</b> <b>programming.</b> This model {{can be viewed as a}} fundamental mechanism underlying both OOP and AOP, which can serve as lower-level building blocks that can be put together into the higher-level constructs present in many AOP systems. ...|$|E
40|$|Ada  9 X -the revised {{definition}} of the Ada programming language- provides support for object-oriented programming. This course examines the new, object-oriented features of the language, their use, and how they fit into Ada's strong type system and genericity mechanisms. Basic object-oriented mechanisms are covered, such as: extension, inheritance, and polymorphism. We then show how to integrate these mechanisms into good programming practices; topics will include <b>incremental</b> <b>programming,</b> heterogeneous data structures, mixin inheritance, and design for reuse. We will also compare standard object-oriented idioms as implemented in Ada vs. other object-oriented languages (e. g. C++, Eiffel) ...|$|E
40|$|Much of {{the elegance}} {{and power of}} Smalltalk comes from its {{programming}} environment and tools. First introduced more than 20 years ago, the Smalltalk browser enables programmers to "home in" on particular methods using a hierarchy of manually-defined classifications. By its nature, this classification scheme {{says a lot about}} the desired state of the code, but little about the actual state of the code as it is being developed. We have extended the Smalltalk browser with dynamically computed virtual categories that dramatically improve the browser's support for <b>incremental</b> <b>programming.</b> We illustrate these improvements by example, and describe the algorithms used to compute the virtual categories efficiently...|$|E
40|$|Incremental {{computation}} {{takes advantage}} of repeated computations on inputs that differ slightly from one another, computing each output efficiently by exploiting the previous output. This paper gives an overview of a general and systematic approach to incrementalization. Given a program f and an operation Φ, the approach yields an <b>incremental</b> <b>program</b> that computes f(x Φ y) efficiently by using the result of f(x), the intermediate results of f(x), and auxiliary information about f(x) that can be inexpensively maintained. Since every non-trivial computation proceeds by iteration or recursion, the approach {{can be used for}} achieving efficient computation in general, by computing each iteration incrementally using an appropriate <b>incremental</b> <b>program.</b> This method has been applied to problems in interactive systems, optimizing compilers, transformational programming, etc. The design and implementation of a prototype system, CACHET, for deriving <b>incremental</b> <b>programs</b> is also described. Ke [...] ...|$|R
40|$|A {{systematic}} approach is given for symbolically caching intermediate results useful for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. We exploit {{a number of}} program analysis and transformation techniques, centered around e ective c a c hing based on its utilization in deriving <b>incremental</b> <b>programs,</b> {{in order to increase}} the degree of incrementality not otherwise achievable by using only the return values of programs that are of direct interest. Our method can be applied straightforwardly to provide a {{systematic approach}} to program improvement via caching. ...|$|R
40|$|A {{systematic}} approach is given for symbolically caching intermediate results useful for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. Our method {{can be applied}} straightforwardly to provide a {{systematic approach}} to program improvement via caching. 1 Introduction <b>Incremental</b> <b>programs</b> take advantage of repeated computations on inputs that differ only slightly from one another, making use of the old output in computing a new output rather than computing from scratch. Methods of incremental computation have widespread application, e. g., optimizing compilers [2, 9, 11], transformational programming [30, 33, 43], interactive editing systems [4, 39], etc. Deriving <b>incremental</b> <b>programs.</b> Given a program f and an input change Φ, a program f 0 that computes the result of f(x Φ y) efficiently by making use {{of the value of}} f(x) is called an incremental version of f under Φ. Liu and Teitelbaum [27] give a systematic transformational approach for deriving an incremental p [...] ...|$|R
40|$|International audienceThe ML module system {{provides}} powerful parameterization facilities, but lacks {{the ability to}} split mutually recursive definitions across modules, and does not provide enough facilities for <b>incremental</b> <b>programming.</b> A promising approach to solve these issues is Ancona and Zucca's mixin modules calculus CMS. However, the straightforward way to adapt it to ML fails, because it allows arbitrary recursive definitions to appear at any time, which ML does not support. In this paper, we enrich CMS with a refined type system that controls recursive definitions {{through the use of}} dependency graphs. We then develop a separate compilation scheme, directed by dependency graphs, that translates mixin modules down to a CBV lambda-calculus extended with a non-standard let rec construct...|$|E
40|$|Ada  95 -the revised {{definition}} of the Ada programming language- provides support for object-oriented programming. This course offers a comprehensive view of object-oriented programming with Ada; it is divided in four parts. First, we examine the object-oriented features of the language, their use, and how they fit into Ada's strong type system and genericity mechanisms. Basic object-oriented mechanisms are covered: extension, inheritance, and polymorphism. Second, we show how to integrate these mechanisms into good programming practices; topics include <b>incremental</b> <b>programming,</b> heterogeneous data structures, mixin and sibling inheritance. We then demonstrate {{the proper use of}} these features in order to design for reuse, and to transition smoothly from Ada 83 to Ada 95. Finally, we compare standard object-oriented idioms in Ada vs. major object-oriented languages (e. g. C++, Smalltalk, Eiffel) ...|$|E
40|$|Abstract. Object-orientation {{supports}} code reuse and <b>incremental</b> <b>programming.</b> Multiple inheritance {{increases the}} power of code reuse, but complicates the bind-ing of method calls and thereby program analysis. Behavioral subtyping allows program analysis under an open world assumption; i. e., {{under the assumption that}} class hierarchies are extensible. However, method redefinition is severely re-stricted by behavioral subtyping, and multiple inheritance often leads to conflict-ing restrictions from independently designed superclasses. This paper presents an approach to incremental reasoning for multiple inheritance under an open world assumption. The approach, based on a notion of lazy behavioral subtyping, is less restrictive than behavioral subtyping and fits well with multiple inheritance, as it incrementally imposes context-dependent behavioral constraints on new sub-classes. We formalize the approach as a calculus, for which we show soundness. ...|$|E
40|$|A {{systematic}} approach is given for deriving <b>incremental</b> <b>programs</b> that exploit caching. The cache-and-prune method {{presented in the}} article consists of three stages: (I) the original program is extended to cache the results of all its intermediate subcomputations {{as well as the}} final result, (II) the extended program is incrementalized so that computation on a new input can use all intermediate results on an old input, %using existing techniques, and (III) unused results cached by the extended program and maintained by the <b>incremental</b> <b>program</b> are pruned away, leaving a pruned extended program that caches only useful intermediate results and a pruned <b>incremental</b> <b>program</b> that uses and maintains only the useful results. All three stages utilize static analyses and semantics-preserving transformations. Stages I and III are simple, clean, and fully automatable. The overall method has a kind of optimality with respect to the techniques used in Stage II. The method can be applied straightforwardly to provide a {{systematic approach}} to program improvement via caching...|$|R
50|$|Static {{approaches}} {{attempt to}} derive an <b>incremental</b> <b>program</b> from a conventional program P using, e.g., either manual design and refactoring, or automatic program transformations. These program transformations occur before any inputs or input changes are provided.|$|R
40|$|We {{propose a}} new model of {{restricted}} branching programs specific to solving GEN problems, which we call <b>incremental</b> branching <b>programs.</b> We show that syntactic <b>incremental</b> branching <b>programs</b> capture previously studied models of computation for the problem GEN, namely marking machines [Co 74] and Poon’s extension [Po 93] of jumping automata on graphs [CoRa 80]. We then prove exponential size lower bounds for our syntactic incremental model, and for some other variants of branching program computation for GEN. We further show that nondeterministic syntactic <b>incremental</b> branching <b>programs</b> are provably stronger than their deterministic counterpart when solving a natural NL-complete GEN subproblem. It remains open if syntactic <b>incremental</b> branching <b>programs</b> are as powerful as unrestricted branching programs for GEN problems...|$|R
40|$|Ada  9 X -the revised {{definition}} of the Ada programming language- provides support for object-oriented programming. This course offers a comprehensive view of object-oriented programming with Ada; it is divided in four parts. First, we examine the object-oriented features of the language, their use, and how they fit into Ada's strong type system and genericity mechanisms. Basic object-oriented mechanisms are covered: extension, inheritance, and polymorphism. Second, we show how to integrate these mechanisms into good programming practices; topics include <b>incremental</b> <b>programming,</b> heterogeneous data structures, mixin and sibling inheritance. We then give a complete application to demonstrate {{the proper use of}} these features in order to design for reuse, and to transition smoothly from Ada 83 to Ada 9 X. Finally, we compare standard object-oriented idioms in Ada vs. major object-oriented languages (e. g. C++, Smalltalk, Eiffel) ...|$|E
40|$|International audienceIn {{order to}} make Australian Indigenous kinship {{vocabulary}} from hundreds of sources comparable, searchable and accessible for research and community purposes, we have developed a database that collates these resources. The creation of such a database brings with it technical, theoretical and practical challenges, some of which also apply to other research projects that collect and compare large amounts of Australian language data, and some of which apply to any database project in the humanities or social sciences. Our project has sought to overcome these challenges by adopting a modular, object-oriented, <b>incremental</b> <b>programming</b> approach, by keeping metadata, data and analysis sharply distinguished, and through ongoing consultation between programmers, linguists and communities. In this paper {{we report on the}} challenges and solutions we have come across and the lessons that can be drawn from our experience for other social science database projects, particularly in Australia...|$|E
40|$|GARF is {{an object}} {{oriented}} system aimed {{to support the}} design and the programming of reliable distributed applications {{on top of a}} network of workstations. The specificity of GARF resides in its <b>incremental</b> <b>programming</b> model, and its extensible library of generic components. In this paper, we first give an overview of GARF. Then we assess its features with respect to its programming model, its abstraction library, and the implementation of its prototype. We finally present the perspectives of future design and implementation. 1 Introduction 1. 1 Distribution and reliability Programming distributed reliable applications is a hard task. The complexity of such applications is due to their behavioral features, i. e. concurrency expression and concurrency control, distribution and replication. Several reliable distributed toolkits provide primitives that deal with such behavioral features. Isis [2], Psync [19], Transis [1] and Phoenix [16] are examples of such toolkits. Although powerful, [...] ...|$|E
40|$|The {{ability to}} {{construct}} <b>programs</b> in an <b>incremental</b> fashion is a premise of popular programming paradigms such as modular programming, object-oriented programming, and interactive <b>programming.</b> <b>Incremental</b> <b>program</b> development amounts to filling the holes of well-planned program contexts with new experimental components, or assembling new programs from previously developed and thoroughly tested components, {{or a combination}} of both. Its popularity lies in the flexibilities it provides for reusing existing program components and program structures. The benefits of constructing programs incrementally are reduced demand on human and computing resources, faster turn-around time, and enhanced program reliability. We present a schema for enhancing <b>programming</b> languages with <b>incremental</b> <b>program</b> construction capabilities based on the notion of program contexts. By perceiving fully-evolved program contexts (proper parse trees) as compiled code, partiallyevolved program contexts (improper parse tre [...] ...|$|R
40|$|A {{systematic}} transformational {{approach is}} given for deriving <b>incremental</b> <b>programs</b> from non-incremental programs. We exploit partial evaluation, other static analysis and transformation techniques, and domain-specific knowledge {{in order to}} provide a degree of incrementality not otherwise achievable by a generic incremental evaluator. Illustrative examples using the transformation approach are given...|$|R
40|$|Probabilistic <b>Incremental</b> <b>Program</b> Evolution (PIPE) {{is a novel}} {{technique}} for automatic program synthesis. We combine probability vector coding of program instructions [Schmidhuber, 1997], PopulationBased Incremental Learning (PBIL) [Baluja and Caruana, 1995] and tree-coding of programs used in variants of Genetic Programming (GP) [Cramer, 1985; Koza, 1992]. PIPE uses a stochastic selection method for successively generating better and better programs according to an adaptive "probabilistic prototype tree". No crossover operator is used. We compare PIPE to Koza's GP variant on a function regression problem and the 6 -bit parity problem. 1 Introduction Probabilistic <b>Incremental</b> <b>Program</b> Evolution (PIPE) synthesizes programs which compute solutions to a given problem. PIPE is inspired by recent work on learning with probabilistic programming languages [Schmidhuber, 1997] and by Population-Based Incremental Learning (PBIL) [Baluja and Caruana, 1995]. PIPE evolves tree-coded programs such a [...] ...|$|R
40|$|This thesis {{develops}} a semantic model of inheritance and investigates its {{applications for the}} analysis and design of programming languages. Inheritance is a mechanism for <b>incremental</b> <b>programming</b> {{in the presence of}} self-reference. This interpretation of inheritance is formalized using traditional techniques of fixed-point theory, resulting in a compositional model of inheritance that is directly applicable to object-oriented languages. Novel applications of inheritance revealed by the model are illustrated to show that inheritance has wider significance beyond object-oriented class inheritance. Constraints induced by self-reference and inheritance are investigated using type theory and yield a formal characterization of abstract classes and a demonstration that the subtype relation is a direct consequence of the basic mechanism of inheritance. The model is proven equivalent to the operational semantics of inheritance embodied by the interpreters of object-oriented languages like Smalltalk. Concise descriptions of inheritance behavior in several object-oriented languages, including Smalltalk, Beta, Simula, and Flavors, are presented in a common framework that facilitates direct comparison of their features...|$|E
40|$|Being that {{software}} is still {{becoming more and}} more complex, the problems to be solved by software technology are becoming harder and the circumstances of software development call for a much more efficient process. This led focus of research in software engineering on finding methods that make software more easily maintainable. For software tools to become truly useful in aiding software developers, they {{need to be able to}} automate the everyday tasks of developers, they need to better automate the maintenance activities. There exist techniques such as separation of concerns and <b>incremental</b> <b>programming,</b> which help software developers to build applications by allowing them to consider new features as independent increments of the application’s basic service. This thesis is about modeling concerns of software products and about the interactions that occur between these concerns. We will see approaches of concern modeling and will put a focus on concern interaction. To be able to maintain a piece of software it is necessary to find such interactions because concern interaction coincides with a bette...|$|E
40|$|Object-orientation {{supports}} code reuse and <b>incremental</b> <b>programming.</b> Multiple inheritance {{increases the}} possibilities for code reuse, but complicates the binding of method calls and thereby program analysis. Behavioral subtyping allows program analysis under an open world assumption; i. e., {{under the assumption that}} class hierarchies are extensible. However, method redefinition is severely restricted by behavioral subtyping, and multiple inheritance may lead to conflicting restrictions from independently designed superclasses. This paper presents a more liberal approach to incremental reasoning for multiple inheritance under an open world assumption. The approach, based on lazy behavioral subtyping, is well-suited for multiple inheritance, as it incrementally imposes context-dependent behavioral constraints on new subclasses. We first present the approach for a simple language and show how incremental reasoning can be combined with flexible code reuse. Then this language is extended with a hierarchy of interface types which is independent of the class hierarchy. In this setting, flexible code reuse can be combined with modular reasoning about external calls in the sense that each class is analyzed only once. We formalize the approach as a calculus and show soundness for both languages...|$|E
40|$|A {{systematic}} approach is given for deriving <b>incremental</b> <b>programs</b> from non-incremental programs {{written in a}} standard functional programming language. We exploit a number of program analysis and transformation techniques and domain-specific knowledge, centered around effective utilization of caching, {{in order to provide}} a degree of incrementality not otherwise achievable by a generic incremental evaluator...|$|R
40|$|We {{propose a}} new model of {{restricted}} branching programs which we call <b>incremental</b> branching <b>programs.</b> This is in line with the program proposed by Cook in [Co 74] as an approach for separating the class P of problems solvable in polynomial time from the class L of problems solvable in logarithmic space, focusing on the P-complete problem GEN and increasingly stronger models of computation. As in other restricted branching program models, we consider syntactic and semantic versions of the model. We show that syntactic <b>incremental</b> branching <b>programs</b> capture previously studied structured models of computation for GEN, namely marking machines [Co 74] and Poon’s extension [Po 93] of jumping automata on graphs [CoRa 80]. We then prove exponential size lower bounds for our syntactic incremental model, and for some other restricted branching program models as well. We further show that nondeterministic syntactic <b>incremental</b> branching <b>programs</b> are provably stronger than their deterministic counterpart when solving a natural NL-complete GEN subproblem. It remains open if syntactic <b>incremental</b> branching <b>programs</b> are as powerful as unrestricted branching programs for GEN problems. So far we are unable to prove lower bounds for semantic <b>incremental</b> branching <b>programs,</b> and we propose studyin...|$|R
40|$|This paper {{presents}} a program analysis approach that discovers a general class of auxiliary informaton and latent <b>program</b> structure for <b>incremental</b> <b>program</b> comprehension. It combines traditional program analysis technology and comprehension mechanism for efficient incrementality of program understanding. The auxiliary {{information can be}} used in software maintenance and other possible applications. KEYWORDS:program understanding; software maintenace support; high-level information...|$|R
