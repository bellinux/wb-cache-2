33|162|Public
5000|$|... #Subtitle level 3: Differentiating the <b>inverse</b> <b>cosine</b> {{function}} ...|$|E
5000|$|... where arccos and arctan are the <b>inverse</b> <b>cosine</b> and tangent {{functions}} respectively.|$|E
5000|$|Inverse cosine: Using an <b>inverse</b> <b>cosine</b> table, {{find two}} angles [...] and [...] whose cosines are our two values.|$|E
50|$|MuPad {{does not}} follow the NIST 4.37 {{definition}} for <b>inverse</b> hyperbolic <b>cosine.</b>|$|R
5000|$|MPEG-C (2006): MPEG video technologies. (ISO/IEC 23002) (e.g., Accuracy {{requirements}} for implementation of integer-output 8x8 <b>inverse</b> discrete <b>cosine</b> transform and others) ...|$|R
5000|$|The <b>inverse</b> sine or <b>cosine</b> of {{a number}} that is less than −1 or greater than +1.|$|R
5000|$|The {{angle of}} {{apparent}} wind (...) {{can be calculated}} from the measured velocity {{of the boat and}} wind using the <b>inverse</b> <b>cosine</b> in degrees (...) ...|$|E
5000|$|The last {{function}} {{is equal to}} the <b>inverse</b> <b>cosine</b> trigonometric function [...] in the entire complex domain. Hence, [...] is an elementary function.|$|E
50|$|Algorithms {{using the}} other {{formulas}} are similar, but each using different tables (sine, inverse sine, cosine, and <b>inverse</b> <b>cosine)</b> in different places. The first two are the easiest because they each only require two tables. Using the second formula, however, has the unique advantage that {{if only a}} cosine table is available, {{it can be used}} to estimate inverse cosines by searching for the angle with the nearest cosine value.|$|E
50|$|AMD intends {{developers}} to employ AMD APP SDK to utilize Video Coding Engine hybrid mode to create hybrid encoders that pair custom motion estimation, <b>inverse</b> discrete <b>cosine</b> transform and motion compensation with the hardware entropy encoding to achieve faster than real-time encoding.|$|R
50|$|The 2700G {{performs}} Inverse Zig-Zag, <b>Inverse</b> Discrete <b>Cosine</b> Transform, and Motion Compensation {{to speed}} up MPEG-1, MPEG-2, MPEG-4 and WMV video decoding. The accelerator can decode MPEG-1, 2 and WMV at 720×480 (DVD Resolution) and MPEG-4 at 640×480, both at over 30 frames per second.|$|R
30|$|Remark 4 By {{a similar}} {{approach}} to that presented in the next section, we can procure similar monotonicity results and inequalities for the <b>inverse</b> hyperbolic <b>cosine</b> and other <b>inverse</b> trigonometric functions. For {{more information on this}} topic, please refer to [2, 4 – 10] and closely related references therein.|$|R
50|$|Vt and Va appear {{equal in}} figure 3, where Vy is about 1.4x Vt. This {{is not the}} general case. The more {{efficient}} the yacht, the smaller β is, and the closer to a beam reach is the optimum speed sailing course. The ultimate ratio of yacht speed to wind speed therefore also gives rise to β by <b>inverse</b> <b>cosine,</b> e.g., speed-sailing at twice the wind speed corresponds to a 30° apparent wind angle, i.e., β = 30°.|$|E
50|$|An I-frame is a {{compressed}} {{version of}} a single uncompressed (raw) frame. It takes advantage of spatial redundancy and of {{the inability of the}} eye to detect certain changes in the image. Unlike P-frames and B-frames, I-frames do not depend on data in the preceding or the following frames. Briefly, the raw frame is divided into 8 pixel by 8 pixel blocks. The data in each block is transformed by the discrete cosine transform (DCT). The result is an 8 by 8 matrix of coefficients. The transform converts spatial variations into frequency variations, but it does not change the information in the block; the original block can be recreated exactly by applying the <b>inverse</b> <b>cosine</b> transform. The advantage of doing this is that the image can now be simplified by quantizing the coefficients. Many of the coefficients, usually the higher frequency components, will then be zero. The penalty of this step is the loss of some subtle distinctions in brightness and color. If one applies the inverse transform to the matrix after it is quantized, one gets an image that looks very similar to the original image but that is not quite as nuanced. Next, the quantized coefficient matrix is itself compressed. Typically, one corner of the quantized matrix is filled with zeros. By starting in the opposite corner of the matrix, then zigzagging through the matrix to combine the coefficients into a string, then substituting run-length codes for consecutive zeros in that string, and then applying Huffman coding to that result, one reduces the matrix to a smaller array of numbers. It is this array that is broadcast or that is put on DVDs. In the receiver or the player, the whole process is reversed, enabling the receiver to reconstruct, to a close approximation, the original frame.|$|E
3000|$|Therefore, {{we need to}} {{show that}} the {{pairwise}} geodesic distance function ρ(x,y) (or, the <b>inverse</b> <b>cosine</b> function arccos(x [...]...|$|E
50|$|In {{probability}} theory and statistics, the hyperbolic secant distribution is a continuous probability distribution whose probability density function and characteristic function are {{proportional to the}} hyperbolic secant function. The hyperbolic secant function {{is equivalent to the}} <b>inverse</b> hyperbolic <b>cosine,</b> and thus this distribution is also called the inverse-cosh distribution.|$|R
40|$|The H. 264 /AVC is {{the most}} recent {{standard}} of video compression/decompression for future broadband network. This standard was developed through the Joint Video Team (JVT) from the ITU-T Video Coding Experts Group and the ISO/IEC MPEG standardization committee. In this project H. 264 decoder functional block such as Context based Binary arithmetic coding (CABAC), Inverse Quantization and <b>Inverse</b> Discrete <b>Cosine</b> Transform are designed using Verilog. CABAC includes three basic building blocks of context modeling, binary arithmetic coding and Inverse binarization. Here the compressed bit-stream from NAL unit is expanded by CABAC module to generate various syntax elements. Here the basic arithmetic decoding circuit units are designed to share efficiently by all syntax elements. Inverse Quantization and <b>Inverse</b> Discrete <b>Cosine</b> Transform functional blocks are used to reconstruct the original image pixels value...|$|R
50|$|The {{lines of}} this model are the open line {{segments}} of the ambient projective space which lie in Un. The distance between two points x and y in Un is defined byThis is well-defined on projective space, since the ratio under the <b>inverse</b> hyperbolic <b>cosine</b> is homogeneous of degree 0.|$|R
3000|$|... where arccos(·):[− 1, 1]→[0,π] is the <b>inverse</b> <b>cosine</b> {{function}} [18]. The great-circle {{distance between}} two manifold points is unique.|$|E
40|$|Recently, a {{nonlinear}} {{transformation of}} autocorrelation coefficients named Phase AutoCorrelation (PAC) coefficients {{has been considered}} for feature extraction [1]. PAC based features show improved robustness to additive noise {{as a result of}} two operations, performed during the computation of PAC, namely energy normalization and <b>inverse</b> <b>cosine</b> transformation. In spite of the improved robustness achieved for noisy speech, these two operations lead to some degradation in recognition performance for clean speech. In this paper, we try to alleviate this problem, first by introducing the energy information back into the PAC based features, and second by studying alternatives to <b>inverse</b> <b>cosine</b> function. Simply appending the frame energy as an additional coefficient in the PAC features has resulted in noticeable improvement in the performance for clean speech. Study of alternatives to <b>inverse</b> <b>cosine</b> transformation leads to a conclusion that linear transformation is the best for clean speech, while nonlinear functions help to improve robustness in noise...|$|E
40|$|A new {{algorithm}} for computing <b>inverse</b> <b>cosine</b> transforms or {{for designing}} zero-phase FIR filters from nonuniform frequency samples is presented. The algorithm is simple, fast, recursive {{and can be}} used in 1 -D or 2 -D applications. Based on the three-term recursive relation of the Chebyshev polynomials, the cosine matrix is decomposed into LU products using parallel computations. Two alternative approaches [...] a direct and a progressive-suitable for serial computations are also derived. Given N samples, the direct version requires 2. 5 N 2 + O(N) flops for computing the <b>inverse</b> <b>cosine</b> transforms or for calculating the filter coefficients, whereas the progressive version neds only O(5 N) flops when the next N + 1 th sample appears. The algorithm guarantees real results and produces accurate solutions even in cases of designing high-order 1 -D or 2 -D FIR filters or when the interpolation matrix is ill conditioned. It can be also used in LU-factorization and can be extended to m-D filter design...|$|E
40|$|This paper {{describes}} fixed-point design methodologies {{and several}} resulting implementations of the <b>Inverse</b> Discrete <b>Cosine</b> Transform (IDCT) contributed {{by the authors}} to MPEG’s work on defining the new 8 x 8 fixed point IDCT standard – ISO/IEC 23002 - 2. The algorithm currently specified in the Final Committee Draft (FCD) of this standard is also described herein...|$|R
30|$|The three above steps will be {{repeated}} until the minutiae vector SSS is completely embedded in transition frames. To obtain the stego frames (the watermarked signal), <b>Inverse</b> Discrete <b>Cosine</b> Transformation (IDCT) {{will be applied}} to each block before combining all together. Afterwards the H. 264 /AVC encoder will {{be applied to the}} synthesized frames to obtain stego H. 264 /AVC video.|$|R
50|$|Currently, the {{portions}} {{capable of being}} offloaded by VDPAU onto the GPU are motion compensation (mo comp), <b>inverse</b> discrete <b>cosine</b> transform (iDCT), VLD (variable-length decoding) and deblocking for MPEG-1, MPEG-2, MPEG-4 ASP (MPEG-4 Part 2), H.264/MPEG-4 AVC and VC-1, WMV3/WMV9 encoded videos. Which specific codecs of these that can be offloaded to the GPU depends on the generation version of the GPU hardware.|$|R
40|$|International audienceGiven the {{relation}} y = cos x, where x {{lies in the}} interval [10, 14], interval arithmetic will readily allow us to compute the possible values for y by considering the monotonic subdomains of the cosine function over [10, 14]: y ∈ [cos 10, 1] ≈ [- 0. 84, 1]. On the other hand, what is the possible domain for an unknown x if the domain for y is [- 0. 3, 0. 2]? Most interval arithmetic libraries will fix it at [acos 0. 2, acos - 0. 3] ≈ [1. 36, 1. 87] because they consider branch cuts of the multivalued <b>inverse</b> <b>cosine</b> to return principal values in the domain [0, π] only. Now, what if we know that x lies in the domain [20, 26]? The aforementioned <b>inverse</b> <b>cosine</b> interval function would not be of much help here, while considering a multivalued <b>inverse</b> <b>cosine</b> would permit restricting the domain of x to [6 π + acos 0. 2, 8 π – acos 0. 2] ≈ [20. 22, 23. 77]. Such a use of relations between variables together with domains of possible values to infer tighter consistent domains is the core principle of Constraint Programming. Since Cleary's seminal work on relational arithmetic for Logic Programming languages, interval multivalued inverse functions have been repeatedly used in algorithms of increasing sophistication to solve systems of (in-) equations over real-valued variables. Using these functions as both a starting and rallying point, we present an overview of these constraint programming algorithms, and we draw parallels with classical numerical algorithms (most notably Gauss-Seidel). The implementation of interval multivalued inverse functions in the gaol C++ library is also discussed...|$|E
40|$|ACL 2 (r) {{supports}} {{the definition of}} real-valued functions. In this paper, we introduce a theory of inverse functions into description of inverse functions, to a still abstract but more tractable treatment of the inverse of continuous functions. A macro is introduced to simplify the introduction of concrete inverse functions. We illustrate the approach by defining some inverse functions in ACL 2, including the square root, natural logarithm, inverse sine, and <b>inverse</b> <b>cosine</b> functions...|$|E
40|$|We propose and {{demonstrate}} a computational imaging technique that uses structured illumination {{based on a}} two-dimensional discrete cosine transform to perform imaging with a single-pixel detector. A scene is illuminated by a projector with two sets of orthogonal patterns, then by applying an <b>inverse</b> <b>cosine</b> transform to the spectra obtained from the single-pixel detector a full-color image is retrieved. This technique can retrieve an image from sub-Nyquist measurements, and the background noise is easily canceled to give excellent image quality. Moreover, the experimental setup is very simple. Comment: 7 pages, 4 figure...|$|E
40|$|This paper {{experiments}} with a methodology for mapping the 8 x 8 row-column <b>Inverse</b> Discrete <b>Cosine</b> Transform on general-purpose Very Long Instruction Word architectures. By exploiting the parallelism {{inherent in the}} algorithm, the results obtained indicate that such processors, using sufficiently advanced compilers, can provide satisfactory performance at low cost without need to resort to special-purpose hardware or timeconsuming hand-tuning of codes...|$|R
50|$|However, {{most of the}} {{important}} hardware decoding functions of ATI Avivo HD are provided by the accompanied Unified Video Decoder (UVD) and the Advanced Video Processor (AVP) which supports hardware decoding of H.264/AVC and VC-1 videos (and included bitstream processing/entropy decoding which was absent in last generation ATI Avivo). For MPEG-1, MPEG-2, and MPEG-4/DivX videos, motion compensation and iDCT (<b>inverse</b> discrete <b>cosine</b> transform) will be done instead.|$|R
40|$|This paper {{presents}} the generalized lapped biorthogonal transform embedded <b>inverse</b> discrete <b>cosine</b> transform (ge-IDCT) {{as an alternative}} to the IDCT. The ge-IDCT with nonlinear weighting in the embedded transform domain can reconstruct the signal with alleviated blockishness. Additional complexity, imposed by the replacement, is trivial thanks to an efficient lattice structure. The proposed ge-IDCT is applied in the JPEG still image compression standard to demonstrate its validityope...|$|R
40|$|The {{standard}} neo-classical {{model of}} economic growth entails a rate of income growth proportional to the income gapyet,in the most dramatic periods of economic transformation, a process of cumulative circular causation {{could be expected to}} lead to accelerating growth. Modelling the rate of change of income growth, instead of income growth itself, as proportional to the income gap gives testable predictions concerning the <b>inverse</b> <b>cosine</b> of the income gap. Estimates of real GDP per capita for six Western European nations,for which GDP data are available over the period 1830 to 1913, conform to these predictions...|$|E
40|$|Abstract. The {{two-dimensional}} discrete cosine transform (2 D-DCT) is at {{the core}} of image encoding and compres-sion applications. We present a new architecture for the 2 D-DCT which is based on row-column decomposition. An efficient architecture to compute the one-dimensional fast direct (1 D-DCT) and <b>inverse</b> <b>cosine</b> (1 D-IDCT) transforms, which is based in reordering the butterflies after their computation, is also discussed. The architectures designed exploit locality, allowing pipelining between stages and saving memory (in-place). The result is an effi-cient architecture for high speed computation of the (1 D, 2 D) -DCT that significantly reduces the area required for VLSI implementation. 1...|$|E
40|$|The {{implementation}} of inverse functions provided by most interval arithmetic software libraries {{is restricted to}} bijective functions and to the principal branch of multivalued functions. On the other hand, some algorithms—most notably, constraint propagation algorithms—require multivalued inverse functions as well. We present in details in this paper the algorithms to implement interval arithmetic extensions of the following multivalued inverse functions: the inverse integral power, the <b>inverse</b> <b>cosine,</b> the inverse sine, the inverse tangent, the inverse hyperbolic cosine, and the inverse multiplication. The issues raised by their effective as well as efficient implementation with floating-point numbers in the gaol C++ library are carefully addressed...|$|E
40|$|This paper proposes an {{algorithm}} {{that uses}} the parallel computational ability to process Variable Length Decoding, Inverse Zigzag, Inverse Quantization and <b>Inverse</b> Discrete <b>Cosine</b> Transform simultaneously. When this method is used, combined clock cycles for VLD, IZ, IQ and IDCT are roughly 35 % shorter than those resulting from conventional methods. Moreover, this effect is especially pronounced for that this assay is easily applied to other compressio...|$|R
40|$|This paper {{describes}} the mapping of a two-dimensional <b>inverse</b> discrete <b>cosine</b> transform (2 -D IDCT) onto a wordlevel reconfigurable Montium Processor. This {{shows that the}} IDCT is mapped onto the Montium tile processor (TP) with reasonable effort and presents performance numbers in terms of energy consumption, speed and silicon costs. The Montium results are compared with the IDCT implementation on three other architectures: TI DSP, ASIC and ARM...|$|R
5000|$|... #Caption: The entropy {{encoding}} block of the VCE ASIC is also separately accessible, enabling [...] "hybrid mode". In [...] "hybrid mode" [...] {{most of the}} computation {{is done by the}} 3D engine of the GPU. Using AMD's Accelerated Parallel Programming SDK and OpenCL developers can create hybrid encoders that pair custom motion estimation, <b>inverse</b> discrete <b>cosine</b> transform and motion compensation with the hardware {{entropy encoding}} to achieve faster than real-time encoding.|$|R
