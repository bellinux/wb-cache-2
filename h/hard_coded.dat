162|179|Public
25|$|ENIAC {{could be}} {{programmed}} to perform complex sequences of operations, including loops, branches, and subroutines. However, instead of the stored program computers that exist today, ENIAC was just a large collection of arithmetic machines, which had programs <b>hard</b> <b>coded</b> into the machines with function tables that each contained 1200 ten way switches. The task of taking a problem and mapping it onto the machine was complex, and usually took weeks. Due {{to the complexity of}} mapping programs onto the machine, programs were only changed after huge numbers of tests of the current program. After the program was figured out on paper, the process of getting the program into ENIAC by manipulating its switches and cables could take days. This was followed by a period of verification and debugging, aided by the ability to execute the program step by step. A programming tutorial for the modulo function using an ENIAC simulator gives an impression of what a program on the ENIAC looked like.|$|E
500|$|The Family Edition adds parental {{controls}}. Parental {{controls are}} {{backed by a}} quality control team of 10 searching the web for inappropriate content. Found content is categorized in subject matter and placed on a blacklist of about 36,000 sites. A designed administrator can add blocked sites, however the pre-supplied blacklist cannot be viewed or edited since it is <b>hard</b> <b>coded.</b> Administrators can block certain subject matters. Another option is to block all sites, then create a whitelist of allowed sites. Family Edition can also block transmission of specified personal information. Such information is replaced with the letter [...] "X". However, CNN noted X-rated sites are retrieved when personal information is queried by a search engine.|$|E
500|$|The user {{interface}} design (UI) for The Last of Us underwent various different iterations throughout development. User interface designer Alexandria Neonakis {{originally intended to}} integrate the weapon upgrade system into the weapon slotting system, in order to constantly remind players to upgrade their weapons. Upon further iterations, Neonakis discovered that this integration resulted in a cluttered interface. Ultimately, {{it was decided that}} the upgrade system would be integrated in the form of upgrade benches, occasionally found throughout the game's world; this also solved another problem that Neonakis witnessed, in which players would upgrade to the lowest possible option, as opposed to saving parts for the higher options. Once it was decided to split the upgrade and slotting systems, the initial design was to select the weapons from a circle. This design, eventually considered [...] "clunky and slow", was replaced in preference of a list system. Neonakis has identified that the main problem with the list design was that it forced players to focus on navigating through menus during intense combat. This led to the final design, which allows players to swap and slot weapons in the same menu. To integrate the UI into the game, Neonakis separated the individual elements and changed their format. User interface programmer Paul Burg provided Neonakis with tools to move elements using their coordinates. All animated transitions were <b>hard</b> <b>coded,</b> which led to difficulty in creating smooth transitions. [...] "This was tedious and at times incredibly frustrating, but it also meant that we all had to be pretty creative in how things were designed," [...] Neonakis said. The game's crafting system was implemented into immediate gameplay, in order for players to feel involved. [...] "We needed to make it streamlined and fast enough that you felt like you could take just that moment and be able to craft that thing that's going to mean your survival in the next thirty seconds, or your failure to survive," [...] lead game designer Jacob Minkoff said.|$|E
50|$|<b>Hard</b> <b>coding</b> is {{especially}} problematic {{in preparing the}} software for translation to other languages.|$|R
40|$|The <b>hard</b> <b>coding</b> {{of input}} data or {{constants}} into spreadsheet formulas is widely recognised as poor spreadsheet model design. However, {{the importance of}} avoiding such practice appears to be underestimated perhaps {{in light of the}} lack of quantitative error at the time of occurrence and the recognition that this design defect may never result in a bottom-line error. The paper examines both the academic and practitioner view of such <b>hard</b> <b>coding</b> design flaws. The practitioner or industry viewpoint is gained indirectly through a review of commercial spreadsheet auditing software. The development of an automated (electronic) means for detecting such <b>hard</b> <b>coding</b> is described together with a discussion of some results obtained through analysis of a number of student and practitioner spreadsheet models. Comment: 10 Pages, 5 Table...|$|R
40|$|Creating a file {{date for}} each input file, when {{one does not}} exist in the file, becomes a tedious task as the number of files grows. Different methods can be used, such as reading in all the files at once, using a file counter, the Job File Control Block (JFCB), and {{implementing}} macros. The key was to find a solution that reduces both the programmer’s time and CPU time. When all methods were compared to reading in each file in its own data step, the file counter and JFCB both increased CPU time, but decreased the amount of <b>hard</b> <b>coding</b> necessary, while using a macro decreased the amount of <b>hard</b> <b>coding</b> and CPU time. This made the macro the most efficient solution when looking at both the programmer’s time and CPU time. This method can be used if the file date is anywhere in the filename. When the need arises to do analysis based on the file date of the file, it can be time consuming to <b>hard</b> <b>code</b> the file date in for each file. This is especially true when the analysis is needed covering multiple years on a file that is submitted every month. There are different techniques available to accomplish this task without having to <b>hard</b> <b>code</b> the file date. One of the techniques, the Job File Control Block, is specific to working on the mainframe. The other...|$|R
500|$|The Secret of Monkey Island was {{the fifth}} Lucasfilm Games project powered by the SCUMM engine, {{originally}} developed for Maniac Mansion. The company had gradually modified the engine since its creation. For Maniac Mansion, the developers <b>hard</b> <b>coded</b> verb commands in the SCUMM scripting language. These commands become more abstract in subsequent versions of the engine. The developers carried over the practice of referring to individual segments of the gameworld as [...] "rooms", even though the areas in Monkey Island were outdoors. The game uses the same version of the engine used in Indiana Jones and the Last Crusade, with minor changes. A dialog tree was added, which facilitated conversation options and the sword-fighting puzzles. The developers removed the [...] "What is" [...] option (an input command that describes an on-screen object to the player) in favor of allowing the player to simply highlight the object with the mouse cursor. The game's improved interface became the standard for the company's later titles. The game also introduced logical verb shortcuts, which could be performed with the mouse; for example, clicking on a character defaults to the [...] "talk" [...] action, the most obvious action in the situation. SCUMM's visuals were updated for the game—the original EGA version had a 320x200pixel resolution rendered in 16colors. According to artist Steve Purcell, that became a major limitation for the art team; due to a low number of [...] "ghastly" [...] colors, they often chose bizarre tones for backgrounds. They chose black and white for Guybrush's outfit for the same reason. The VGA version of the game later corrected these issues by implementing 256 color support, which allowed for more advanced background and character art. The VGA (and other platform releases) removed the infamous [...] "stump joke" [...] from the game, which was a joke in the EGA version in which the [...] player would examine a tree stump in the forest. Guybrush would exclaim {{that there is an}} opening to a system of catacombs and attempt to enter, but this would result in a message stating the player needed to insert disc 22, then 36, then 114 in order to continue. The joke resulted in numerous calls to the LucasArts hotline asking about missing discs. As a result, the joke was removed from later editions and is a mentioned as a conversation option for the LucasArts Hint Hotline in the sequel.|$|E
2500|$|After 6 December 2003, various system {{messages}} {{shown to}} Wikipedia users {{were no longer}} <b>hard</b> <b>coded,</b> allowing Wikipedia [...] to modify certain parts of MediaWiki's interface, such as the message shown to blocked users.|$|E
2500|$|Most MUDs {{restrict}} player versus player combat, often abbreviated as PK (Player Killing). [...] This {{is accomplished}} through <b>hard</b> <b>coded</b> restrictions and {{various forms of}} social intervention. [...] MUDs without these restrictions {{are commonly known as}} PK MUDs. [...] Taking this a step further are MUDs devoted solely to this sort of conflict, called pure PK MUDs, the first of which was Genocide in 1992. [...] Genocide ideas were influential in the evolution of player versus player online gaming.|$|E
40|$|The {{performance}} requirements imposed on (<b>hard)</b> realtime <b>code</b> resp. non real-time code differ. As a consequence, conventional coding strategies as {{used to develop}} non realtime software are not suited for <b>hard</b> real-time <b>code.</b> This paper shows why non real-time coding is not suited for hard real-time systems and presents WCET-oriented programming as a strategy that avoids these shortcomings. It further discusses components of an infrastructure that support the WCET-oriented development of <b>hard</b> real-time <b>code.</b> ...|$|R
40|$|In {{programming}} {{activities during}} clinical trial reporting, situations can arise when {{a change in}} a portion of SAS ® code is warranted after the programs are finalized and moved into a production environment. It is a very common situation during the clinical trial reporting process. There may be one minor change in the SAS ® code to be applied repeatedly to {{a large number of}} programs. One way to achieve this is by changing the <b>hard</b> <b>code</b> to each of the programs. However, if the number of programs is sufficiently large, then the risk of making mistakes due to <b>hard</b> <b>coding</b> increases. Therefore, it is always better to avoid repeated <b>hard</b> <b>coding,</b> instead it should be coded only once and the SAS ® macro tool should automatically find that string of code and go into each of the programs and make the necessary changes. That way the error due to <b>hard</b> <b>coding</b> is minimized. This SAS ® macro program tool first identifies the number of programs residing in a certain library and then goes to each program one by one, identifies the lines or string of text to be modified and finally makes necessary changes. Then it automatically saves the modified program in another output library. This SAS ® macro tool is created for the PC platform of Microsoft Windows and also for MVS Mainframe. This macro minimizes risk of errors due to typing. Furthermore, it could be applied to a large number of programs in need of modification...|$|R
50|$|<b>Hard</b> <b>coding</b> {{requires}} the program's source code {{to be changed}} any time the input data or desired format changes, when {{it might be more}} convenient to the end user to change the detail by some means outside the program.|$|R
50|$|Dentrix G6 uses <b>Hard</b> <b>Coded</b> Credentials.|$|E
50|$|Circuits are not <b>hard</b> <b>coded</b> {{to perform}} a {{specific}} task.|$|E
50|$|The initialism HC in some {{releases}} {{refers to}} <b>hard</b> <b>coded</b> subtitles.|$|E
50|$|The {{first two}} options of {{creating}} or looking up dependencies are not optimal because they <b>hard</b> <b>code</b> the dependency to the component. This makes it difficult, if not impossible, {{to modify the}} dependencies. This is especially problematic in tests, where it is often desirable to provide mock dependencies for test isolation.|$|R
50|$|<b>Hard</b> <b>coding</b> (also hard-coding or hardcoding) {{refers to}} the {{software}} development practice of embedding an input or configuration data directly into the source code of a program or other executable object, or fixed formatting of the data, instead of obtaining that data from external sources or generating data or formatting in the program itself with the given input.|$|R
5000|$|Asking for {{dependencies}} {{solves the}} issue of <b>hard</b> <b>coding,</b> {{but it also means}} that the injector needs to be passed throughout the application. Passing the injector breaks the Law of Demeter. To remedy this, we use a declarative notation in our HTML templates, to hand the responsibility of creating components over to the injector, as in this example: ...|$|R
5000|$|Keyboard driver with {{predefined}} English and Spanish/Catalan keymap layout (<b>hard</b> <b>coded).</b>|$|E
5000|$|Untranslated {{messages}} {{in the original}} language may be left <b>hard</b> <b>coded</b> in the source code.|$|E
5000|$|Inline data (ID) - Measures {{the amount}} of effort spent on the {{embedding}} <b>hard</b> <b>coded</b> data ...|$|E
5000|$|One {{important}} case of <b>hard</b> <b>coding</b> is when strings {{are placed}} {{directly into the}} file, which forces translators to edit the source code to translate a program. (There is a tool called [...] that permits strings to be left in files, but lets translators translate them without changing the source code; it effectively de-hard codes the strings.) ...|$|R
40|$|This paper {{describes}} {{a program that}} compiles BURS tables into a combination of <b>hard</b> <b>code</b> and data. Hard-coding exposed important opportunities for compression that were previously hidden in the tables, so the hard-coded code generators are not just faster but also significantly smaller than their predecessors. A VAX code generator takes 21. 4 Kbytes and identifies optimal assembly code in about 50 VAX instructions per nod...|$|R
40|$|Thread-LevelSpeculation(TLS) hasbeenproposedtofacilitate the extractionof {{parallel}} threadsfromsequentialapplications. Most prior work on TLS {{has focused}} on architecturalfeaturesdirectlyrelatedto supportingthe mainTLS operations. Inthisworkwe,instead,investigatehowacommon microarchitectural feature, namely branch prediction, interactswithTLS. We showthatbranchpredictionforTLS {{is even more important}} than it is for sequential execution. Unfortunately, branch prediction for TLS systems is also inherently <b>harder.</b> <b>Code</b> partitioning and re-executions of squashedthreadspollutethebranchhistorymakingitharder forpredictorstobeaccurate. We thus propose to augment the hardware, so as to accommodate Multi-Path Execution (MP) within the existin...|$|R
50|$|A {{few times}} Butcher talk ("Rechtub klat") is spoken. At those times <b>hard</b> <b>coded</b> {{subtitles}} are used.|$|E
5000|$|... the SDP's service agility (that is {{the product}} and {{services}} being offered are <b>hard</b> <b>coded</b> into the SDP so that new services cause code upgrades) and; ...|$|E
50|$|In some {{situations}} MSOs have millions of lines of <b>hard</b> <b>coded</b> product and service management flows in their systems and {{are unable to}} move to the newer converged service dimensions easily.|$|E
50|$|Individual modules {{are added}} to a creature. These modules modify the creature's {{behaviors}} and characteristics either directly, by <b>hard</b> <b>coding</b> into the simulation (leg type A increases speed and metabolism), or indirectly, through the emergent interactions between a creature's modules (leg type A moves {{up and down with}} a frequency of X, which interacts with other legs to create motion). Generally these are simulators which emphasize user creation and accessibility over mutation and evolution.|$|R
30|$|The soft or <b>hard</b> (soft/hard) <b>coded</b> bits {{which are}} the metric values that are {{generally}} used for the iterative process [15].|$|R
2500|$|Individual modules {{are added}} to a creature. [...] These modules modify the creature's {{behaviors}} and characteristics either directly, by <b>hard</b> <b>coding</b> into the simulation (leg type A increases speed and metabolism), or indirectly, through the emergent interactions between a creature's modules (leg type A moves {{up and down with}} a frequency of X, which interacts with other legs to create motion). [...] Generally these are simulators which emphasize user creation and accessibility over mutation and evolution.|$|R
5000|$|After 6 December 2003, various system {{messages}} {{shown to}} Wikipedia users {{were no longer}} <b>hard</b> <b>coded,</b> allowing Wikipedia [...] to modify certain parts of MediaWiki's interface, such as the message shown to blocked users.|$|E
50|$|While {{this will}} make current Rainbow tables useless, if the salt is <b>hard</b> <b>coded</b> into a popular product that salt can be {{extracted}} and a new Rainbow table can be generated using that salt.|$|E
5000|$|Conveyors: {{automated}} conveyors {{allow the}} input of containers in one area of the warehouse, and either through <b>hard</b> <b>coded</b> rules or data input allow destination selection. The container will later appear at the selected destination.|$|E
50|$|Data {{correlation}} is {{the process}} by which RPT ensures continuity between test actions. Often in a performance test a value is created at one step of a test and subsequently used during a later step. Whenever such a value is created, RPT stores that value in a variable, and uses that variable later on the test when the data is accessed. This prevents <b>hard</b> <b>coding</b> of values, and ensures that tests will play back correctly in dynamic data environments.|$|R
40|$|International audienceThis paper {{presents}} a new data structure, the Data Decision Diagrams, {{equipped with a}} mechanism allowing the definition of application-specific operators. This mechanism is based on combination of inductive linear functions offering a large expressiveness while alleviating for the user the burden of <b>hard</b> <b>coding</b> traversals in a shared data structure. We demonstrate the pertinence of our system through {{the implementation of a}} verification tool for various classes of Petri nets including self modifying and queuing nets...|$|R
5000|$|JMyron (aka WebcamXtra) is an {{external}} library [...] for Processing that allows image manipulation {{without having to}} <b>hard</b> <b>code</b> everything. This is great because we can extend {{what we saw in}} the Video Library tutorial and add other aspects to it like motion tracking and color tracking. To use JMyron, you have to download the JAR {{and put them in the}} path/to/Processing/libraries folder. You must then import the library in each Processing sketch where JMyron objects will be used.|$|R
