185|355|Public
5|$|When players deal enough {{damage to}} an enemy, they can {{activate}} an <b>execution</b> <b>sequence.</b> Once the <b>execution</b> <b>sequence</b> has been initiated, enemies {{involved in the}} execution are highlighted automatically with colors by the game, and players can perform a series of quick time events by pressing the appropriate buttons. These execution sequences serve to grant additional resources to players, depending on how well the execution is performed. At any time prior to initiating an execution, the player can select one of four categories of executions to perform upon weakened enemies; the selected type of execution determines the type of resource that will be granted when an enemy is executed. Upon completing a successful <b>execution</b> <b>sequence,</b> players are granted the type of execution that was selected. There are four perks available for players. One boosts the player's damage {{for a short period}} after the execution; one refills the player's Focus bar; one allows players to regain lost health, and the last significantly boosts the amount of experience points received from the kill. These experience points can be used to purchase upgrades for various attributes, such as health, damage, or Focus bar capacity, and to unlock additional execution moves. The game still automatically completes and finishes these execution sequences when players fail to press the highlighted buttons, but provides a much smaller reward. Lining up two or more weakened enemies in close proximity allows the player to perform a double <b>execution</b> <b>sequence,</b> which greatly increases the reward granted.|$|E
25|$|Assignment statements, in {{imperative}} paradigm, {{perform an}} operation on information located in memory and store {{the results in}} memory for later use. High-level imperative languages, in addition, permit the evaluation of complex expressions, which may consist {{of a combination of}} arithmetic operations and function evaluations, and the assignment of the resulting value to memory. Looping statements (as in while loops, do while loops, and for loops) allow a sequence of statements to be executed multiple times. Loops can either execute the statements they contain a predefined number of times, or they can execute them repeatedly until some condition changes. Conditional branching statements allow a sequence of statements to be executed only if some condition is met. Otherwise, the statements are skipped and the <b>execution</b> <b>sequence</b> continues from the statement following them. Unconditional branching statements allow an <b>execution</b> <b>sequence</b> to be transferred to another part of a program. These include the jump (called goto in many languages), switch, and the subprogram, subroutine, or procedure call (which usually returns to the next statement after the call).|$|E
500|$|There was {{debate about}} {{the merits of the}} producer's {{decision}} to avoid depicting the two battles between the Starks and Lannisters. Ryan criticized it and confessed being [...] "a little disappointed that many of the major characters are caught up in a war and we're not seeing it." [...] Sims regretted not seeing the fight, and although he claimed to understand the budget constrictions, he felt that [...] "all this off-screen fighting is just getting my blood rushing for some on-screen fighting." [...] Sepinwall concludes: [...] "Ideally, we'd get a few epic, Braveheart-level battle scenes at some point, but I also respect the demands of time and budget here. Those kinds of sequences cost a fortune, and they eat up a lot of screen time, and I think ultimately I'd have rather had the time, say, that we spent in Tyrion's tent the night before the battle, with the mortifying story of his ex-wife, and then whatever it cost to make the <b>execution</b> <b>sequence</b> look as good as it did, than for the episode to have given us one or two long fight scenes." ...|$|E
40|$|Compile-time code transformations which expose instruction-level {{parallelism}} (ILP) typically {{take into}} account the constraints imposed byallexecution scenarios in the program. However, there areaddi tional opportunities to increase ILP along some <b>execution</b> <b>sequences</b> if the constraints from alternative <b>execution</b> <b>sequences</b> can be ignored. Traditionally, pro le information has been used to identify important <b>execution</b> <b>sequences</b> for aggressive compiler optimization and scheduling. This paper presents a set of static program analysis heuristics used in the IMPACT compiler to identify <b>execution</b> <b>sequences</b> for aggressive optimization. We show that the static program analysis heuristics identify <b>execution</b> <b>sequences</b> without hazardous conditions that tend to prohibit compiler optimizations. As a result, the static program analysis approach often achieves optimization results comparable to pro le information in spite of its inferior branch prediction accuracies. This observation makes a strong case for using static program analysis with or without pro le information to facilitate aggressive compiler optimization and scheduling...|$|R
5000|$|EXHIBITOR, which {{searches}} for <b>execution</b> <b>sequences</b> matching a given regular expression ...|$|R
40|$|Stepwise {{refinement}} of programs {{has proven to}} be a suitable method for developing parallel and distributed programs. We examine and compare a number of different notions of program refinement for Unity. Two of these notions are based on <b>execution</b> <b>sequences.</b> Refinement corresponds to the reduction of the set of <b>execution</b> <b>sequences,</b> i. e. reducing the amount of nondeterminism. The other refinement notions are based on Unity properties as introduced by Chandy and Misra. The Unity approach is to refine specifications. Although it has proven a suitable formalism for deriving algorithms, it seems less suitable for handling implementation details. Following Sanders and Singh, we formalize program refinement in the Unity framework as the preservation of Unity properties. We show that Unity properties are not powerful enough to characterize <b>execution</b> <b>sequences.</b> As a consequence, the notion of property-preserving refinement differs from the notion of reducing the set of <b>execution</b> <b>sequences.</b> Keyw [...] ...|$|R
2500|$|If the [...] key is {{held down}} {{at a certain point}} in the <b>execution</b> <b>sequence,</b> Windows Vista invokes the AutoPlay dialog {{regardless}} of any AutoPlay settings to the contrary. Previous versions of Windows do not execute the AutoRun task. It is essential that the left Shift key is used for this purpose as holding down the right Shift key for eight seconds invokes FilterKeys.|$|E
50|$|When players deal enough {{damage to}} an enemy, they can {{activate}} an <b>execution</b> <b>sequence.</b> Once the <b>execution</b> <b>sequence</b> has been initiated, enemies {{involved in the}} execution are highlighted automatically with colors by the game, and players can perform a series of quick time events by pressing the appropriate buttons. These execution sequences serve to grant additional resources to players, depending on how well the execution is performed. At any time prior to initiating an execution, the player can select one of four categories of executions to perform upon weakened enemies; the selected type of execution determines the type of resource that will be granted when an enemy is executed. Upon completing a successful <b>execution</b> <b>sequence,</b> players are granted the type of execution that was selected. There are four perks available for players. One boosts the player's damage {{for a short period}} after the execution; one refills the player's Focus bar; one allows players to regain lost health, and the last significantly boosts the amount of experience points received from the kill. These experience points can be used to purchase upgrades for various attributes, such as health, damage, or Focus bar capacity, and to unlock additional execution moves. The game still automatically completes and finishes these execution sequences when players fail to press the highlighted buttons, but provides a much smaller reward. Lining up two or more weakened enemies in close proximity allows the player to perform a double <b>execution</b> <b>sequence,</b> which greatly increases the reward granted.|$|E
5000|$|Gruesome Gertie {{appeared}} in the film Monster's Ball for the <b>execution</b> <b>sequence.</b> These scenes with the chair were filmed in the actual execution chamber at Louisiana State Penitentiary, where Gruesome Gertie had been used for real executions a decade earlier.|$|E
40|$|We {{examine the}} {{expressive}} power of Unity properties {{in relation to}} <b>execution</b> <b>sequences</b> of Unity programs. One might expect that if two programs have the same unless and leadsto properties, then {{they have the same}} <b>execution</b> <b>sequences.</b> We show that this is not true. We examine whether this difference vanishes if we adopt a stronger notion of fairness, or use ensures properties instead of leadsto properties (possibly adopting a stronger fairness notion also). We show by a simple example that both approaches are not successful. Hence, properties are not expressive enough to characterize <b>execution</b> <b>sequences,</b> and {{it is not clear what}} execution model corresponds to Unity properties. As a consequence, the notion of property preserving program refinement differs from the notion of decreasing nondeterminism. Keywords Stepwise refinement, Unity, program refinement, program specification. 1 Preliminaries The Unity framework, introduced by Chandy and Misra in [2], consists of a programming langua [...] ...|$|R
30|$|Devices {{with less}} {{capabilities}} can be configured to use simplified <b>execution</b> <b>sequences</b> which contain less network services. Alternatively, they can negotiate with neighboring nodes to use simplified {{versions of the}} required network services.|$|R
40|$|This paper revisit {{and extends}} results about the Safety-Progress {{classification}} of properties introduced by Chang, Manna, and Pnueli [1]. Our work {{is motivated by}} runtime verification, as so {{we believe that this}} general classification is a good basis for specifying properties. In runtime verification, a major and distinguishing feature is the interest of finite <b>execution</b> <b>sequences</b> representation of incremental chunks of a program <b>execution.</b> These <b>executions</b> <b>sequences</b> are fed to a monitor, i. e. a mechanism designed to state appraisal wrt. a desired property under scrutiny. We show in this paper, that the four views originally dedicated to infinitary properties can be uniformly extended to finitary ones...|$|R
5000|$|A core trace {{provides}} detailed {{visibility of}} the program execution on an embedded core. Trace data are generated for the instruction <b>execution</b> <b>sequence</b> (sometimes referred to as instruction trace) and/or data transfers (sometimes referred to as data trace). A SoC may contain several core traces.|$|E
5000|$|From Windows Vista, at the Dialogs and {{decisions}} {{point of the}} AutoPlay <b>execution</b> <b>sequence,</b> there is a {{check to see if}} the [...] key is currently being held down. If so, any automatic user preferences are ignored and the AutoPlay dialog is always shown.|$|E
5000|$|Analytica {{has several}} {{features}} as {{a programming language}} designed {{to make it easy}} to use for quantitative modeling: It is a visual programming language, where users view programs (or [...] "models") as influence diagrams, which they create and edit visually by adding and linking nodes. It is a declarative language, meaning that a model declares a definition for each variable without specifying an <b>execution</b> <b>sequence</b> as required by conventional imperative languages. Analytica determines a correct and efficient <b>execution</b> <b>sequence</b> using the dependency graph. It is a referentially transparent functional language, in that execution of functions and variables have no side effects i.e. changing other variables. Analytica is an array programming language, where operations and functions generalize to work on multidimensional arrays.|$|E
50|$|The {{applications}} of minimum path covers include software testing. For example, if the graph G represents all possible <b>execution</b> <b>sequences</b> {{of a computer}} program, then a path cover {{is a set of}} test runs that covers each program statement at least once.|$|R
50|$|The {{selection}} structure {{contains two}} <b>execution</b> <b>sequences,</b> each {{preceded by a}} double colon. One sequence from the list will be executed. A sequence can be selected only if its first statement is executable. The first statement of a control sequence is called a guard.|$|R
40|$|A {{key problem}} in {{designing}} parallel programs that achieve a desired performance goal {{is the ability}} to analyze exactly program performance, given a specification of the process syncronization structure and the execution timings of all code segments. The problem solved in this paper is to derive, for all possible process starting times, the set of all possible limit cycle <b>execution</b> <b>sequences</b> in which a process blocks. This paper makes two contributions. First, it employs a novel analysis method that derives timed <b>execution</b> <b>sequences</b> from a geometric model of program execution, called timed progress graphs. Second, it solves the timed progress graph not by a computational geometric algorithm, as employed by most solutions in the literature to untimed progress graphs, but by an analytic solution...|$|R
5000|$|If the [...] key is {{held down}} {{at a certain point}} in the <b>execution</b> <b>sequence,</b> Windows Vista invokes the AutoPlay dialog {{regardless}} of any AutoPlay settings to the contrary. Previous versions of Windows do not execute the AutoRun task. It is essential that the left Shift key is used for this purpose as holding down the right Shift key for eight seconds invokes FilterKeys.|$|E
5000|$|From the Actor {{point of}} view, {{sequential}} computations are {{a special case}} of concurrent computations, distinguishable by their event diagrams. The event diagram of a sequential computation has an initial event, and no event activates more than one event. In other words, the activation ordering of a sequential computation is linear; the event diagram is essentially a conventional <b>execution</b> <b>sequence.</b> This means that the finite elements of Diagrams ...|$|E
50|$|Assignment statements, in {{imperative}} paradigm, {{perform an}} operation on information located in memory and store {{the results in}} memory for later use. High-level imperative languages, in addition, permit the evaluation of complex expressions, which may consist {{of a combination of}} arithmetic operations and function evaluations, and the assignment of the resulting value to memory. Looping statements (as in while loops, do while loops, and for loops) allow a sequence of statements to be executed multiple times. Loops can either execute the statements they contain a predefined number of times, or they can execute them repeatedly until some condition changes. Conditional branching statements allow a sequence of statements to be executed only if some condition is met. Otherwise, the statements are skipped and the <b>execution</b> <b>sequence</b> continues from the statement following them. Unconditional branching statements allow an <b>execution</b> <b>sequence</b> to be transferred to another part of a program. These include the jump (called goto in many languages), switch, and the subprogram, subroutine, or procedure call (which usually returns to the next statement after the call).|$|E
40|$|Compilers for superscalar and VLIW {{processors}} must expose sufficient instruction-level parallelism {{in order}} to achieve high performance. Compiletime code transformations which expose instruction-level parallelism typically take into account the constraints imposed by all execution scenarios in the program. However, there are additional opportunities to increase instructionlevel parallelism along the frequent execution scenario {{at the expense of the}} less frequent <b>execution</b> <b>sequences.</b> Profile information identifies these important <b>execution</b> <b>sequences</b> in a program. In this paper, two major categories of profile information are studied: control-flow and memory-dependence. Profilebased transformations have been incorporated into the IMPACT compiler. These transformations include global optimization, acyclic global scheduling, and software pipelining. The effectiveness of these profile-based techniques is evaluated for a range of superscalar and VLIW processors. 1 Introduction Compile-time [...] ...|$|R
40|$|This paper {{makes the}} idea of memory {{shadowing}} (Bryant and Velev, 1997) applicable to symbolic ternary simulation. Memory shadowing, an extension of Burch and Dill 2 ̆ 7 s (1994) pipeline verification method to the bit level, is a technique for providing on-the-fly identical initial memory state to two different memory <b>execution</b> <b>sequences.</b> We also present an algorithm which compares the final states of two memories for ternary correspondence, {{as well as an}} approach for generating efficiently the initial state of memories. These techniques allow us to verify that a pipelined circuit has behavior corresponding to that of its unpipelined specification by simulating two symbolic ternary <b>execution</b> <b>sequences</b> and comparing their memory states. Experimental results show the potential of the new idea...|$|R
40|$|Abstract. This paper extends Burch and Dill’s {{pipeline}} {{verification method}} [4] to the bit level. We introduce {{the idea of}} memory shadowing, a new technique for providing on-the-fly identical initial memory state to two different memory <b>execution</b> <b>sequences.</b> We also present an algorithm which compares the final states of two memories for equality. Memory shadowing and the com-parison algorithm build on the Efficient Memory Model (EMM) [13], a behavioral memory model where the number of symbolic variables used to characterize the initial state of a memory {{is proportional to the}} number of distinct symbolic locations accessed. These techniques allow us to verify that a pipelined circuit has equivalent behavior to its unpipelined specification by simu-lating two memory <b>execution</b> <b>sequences</b> and comparing their final states. Experimental results show the potential of the new ideas...|$|R
5000|$|In Britain, Labour M.P. David Blunkett {{called for}} the show to be banned, saying [...] "I'm horrified by his {{behaviour}} - it goes {{beyond the bounds of}} entertainment". The controversy spilled over into the German segment of the tour, with the German government actually succeeding in having some of the gorier segments of the performance removed. It was also during the London leg of the tour that Cooper met with a near fatal accident during the hanging <b>execution</b> <b>sequence</b> {{at the end of the}} show.|$|E
50|$|Analyses are {{presented}} and recorded graphically {{in the form}} of a calculation graph (the so-called Workmaps). The structures can be saved in conjunction with the data and thus are reusable with similar data to perform the same analyses with refreshed or new data in the same structure. The software interactively combines all created objects in a logical <b>execution</b> <b>sequence</b> (live linking). That allows to actively connect the results and affect selections in all corresponding visualizations. In addition, changes in data get propagated to all dependent analyses and graphics.|$|E
5000|$|To make {{concurrent}} programs repeatable, {{an external}} scheduler is used. The program under test is instrumented to add calls to this scheduler. Such calls are {{made at the}} beginning and end of each thread as well as before every synchronization request. This scheduler selectively blocks threads of execution by maintaining a semaphore associated with each thread, such that only one thread is ready for execution at any given time. Thus, it converts parallel non-deterministic application into a serial <b>execution</b> <b>sequence</b> in order to achieve repeatability. The number of scheduling decisions made by the serializing scheduler is given by - ...|$|E
40|$|Simulation-based {{analysis}} of formal models of distributed systems {{with respect to}} certain required system properties often fails due to {{the large number of}} possible <b>execution</b> <b>sequences.</b> In general, the number of possible <b>execution</b> <b>sequences</b> of some fixed length grows exponentially with the degree of concurrency. In the approach suggested in this paper models of distributed information systems are represented as highlevel Petri nets. A new kind of Petri net simulation is proposed which does not create sequences of transitions or sequences of sets of transitions but instead creates partially ordered sets of transition occurrences, so-called processes. In this paper the basic simulation concepts are described and a Prolog-based implementation is surveyed. This work {{is part of a larger}} project which aims at providing methodological support for an evolutionary and cooperative strategy for the development of distributed information systems...|$|R
40|$|Amal J. Ahmed Andrew W. Appel # Roberto Virga Princeton University {amal,appel,rvirga}@cs. princeton. edu Abstract We {{demonstrate}} a semantic model of general references [...] - that is, mutable memory cells that may contain values of any (statically-checked) closed type, including other references. Our model is {{in terms of}} <b>execution</b> <b>sequences</b> on a von Neumann machin...|$|R
40|$|We {{summarize}} and reorganize some of {{the last}} decade's research on real-time extensions of temporal logic. Our main focus is on tableau constructions for model checking linear temporal formulas with timing constraints. In particular, we find that {{a great deal of}} real-time verification can be performed in polynomial space, but also that considerable care must be exercised {{in order to keep the}} real-time verification problem in polynomial space, or even decidable. 1 Introduction The execution of a reactive system results in an infinite sequence of observations. Requirements on <b>execution</b> <b>sequences</b> can be specified in (linear) temporal logic. 3 The model-checking problem asks, given a reactive system and a temporal formula, if all <b>execution</b> <b>sequences</b> of the system satisfy the formula. Temporal logic is a popular specification language for two reasons. First, temporal logic is reasonably expressive. In practice, temporal logic allows the specification of important requirements such as in [...] ...|$|R
5000|$|Now the set {{of initial}} {{segments}} of execution sequences of a given nondeterministic program , starting from a given state, will form a tree. The branching points will correspond to the choice points in the program. Since there are always only finitely many alternatives at each choice point, the branching factor of the tree is always finite. That is, the tree is finitary. Now König's lemma says that if every branch of a finitary tree is finite, then so is the tree itself. In the present case this means that if every <b>execution</b> <b>sequence</b> of [...] terminates, then there are only finitely many execution sequences. So if an output set of [...] is infinite, it must contain nonterminating computation.|$|E
5000|$|There was {{debate about}} {{the merits of the}} producer's {{decision}} to avoid depicting the two battles between the Starks and Lannisters. Ryan criticized it and confessed being [...] "a little disappointed that many of the major characters are caught up in a war and we're not seeing it." [...] Sims regretted not seeing the fight, and although he claimed to understand the budget constrictions, he felt that [...] "all this off-screen fighting is just getting my blood rushing for some on-screen fighting." [...] Sepinwall concludes: [...] "Ideally, we'd get a few epic, Braveheart-level battle scenes at some point, but I also respect the demands of time and budget here. Those kinds of sequences cost a fortune, and they eat up a lot of screen time, and I think ultimately I'd have rather had the time, say, that we spent in Tyrion's tent the night before the battle, with the mortifying story of his ex-wife, and then whatever it cost to make the <b>execution</b> <b>sequence</b> look as good as it did, than for the episode to have given us one or two long fight scenes." ...|$|E
30|$|The {{corresponding}} NuSMV <b>execution</b> <b>sequence</b> is as follows.|$|E
40|$|This paper extends Burch and Dill's {{pipeline}} {{verification method}} [4] to the bit level. We introduce {{the idea of}} memory shadowing, a new technique for providing on-the-fly identical initial memory state to two different memory <b>execution</b> <b>sequences.</b> We also present an algorithm which compares the final states of two memories for equality. Memory shadowing and the comparison algorithm build on the Efficient Memory Model (EMM) [13], a behavioral memory model where the number of symbolic variables used to characterize the initial state of a memory {{is proportional to the}} number of distinct symbolic locations accessed. These techniques allow us to verify that a pipelined circuit has equivalent behavior to its unpipelined specification by simulating two memory <b>execution</b> <b>sequences</b> and comparing their final states. Experimental results show the potential of the new ideas. Keywords: pipelined microprocessor verification, memory shadowing, Efficient Memory Model (EMM), circuit correspondence che [...] ...|$|R
40|$|The Internet-based desktop {{environment}} {{as defined in}} this paper consists of a cross-platform browser, a number of server icons (host nodes), a number of application icons (program nodes) {{and a number of}} data icons (file nodes). In contrast to typical desktops of today, where data icons may be dragged and dropped onto application icons for execution, this environment allows (1) user-defined and reconfigurable <b>execution</b> <b>sequences</b> by creating dependency edges between program nodes (application icons) and file nodes (data icons); (2) data-dependent <b>execution</b> <b>sequences</b> by dynamic scheduling of path as well as loop executions; (3) host-transparency as to the location of applications and data (both can reside on any host with a unique IP address). We argue that the Internet-based workflow paradigm is suitable for creation of dynamically reconfigurable desktop environments. The summary of 450 Internet-based experiments demonstrates (1) the value of making the desktop recordable, and (2) the [...] ...|$|R
5000|$|D0 , if <b>execution</b> of the <b>sequence</b> [...] is {{possible}} and leads to the state , then <b>execution</b> of the <b>sequence</b> [...] {{is possible}} and will lead to state ...|$|R
