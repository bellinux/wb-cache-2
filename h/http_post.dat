79|34|Public
2500|$|First {{discovered}} in 2009, the <b>HTTP</b> <b>POST</b> attack sends a complete, legitimate <b>HTTP</b> <b>POST</b> header, {{which includes a}} 'Content-Length' field to specify {{the size of the}} message body to follow. However, the attacker then proceeds to send the actual message body at an extremely slow rate (e.g. 1 byte/110 seconds). Due to the entire message being correct and complete, the target server will attempt to obey the 'Content-Length' field in the header, and wait for the entire body of the message to be transmitted, which can take a very long time. The attacker establishes hundreds or even thousands of such connections, until all resources for incoming connections on the server (the victim) are used up, hence making any further (including legitimate) connections impossible until all data has been sent. It is notable that unlike many other (D)DoS attacks, which try to subdue the server by overloading its network or CPU, a <b>HTTP</b> <b>POST</b> attack targets the logical resources of the victim, which means the victim would still have enough network bandwidth and processing power to operate. Further combined with the fact that Apache will, by default, accept requests up to 2GB in size, this attack can be particularly powerful. <b>HTTP</b> <b>POST</b> attacks are difficult to differentiate from legitimate connections, and are therefore able to bypass some protection systems. OWASP, an open source web application security project, has released a [...] to test the security of servers against this type of attacks.|$|E
50|$|When a {{web form}} is {{submitted}} to a server through an <b>HTTP</b> <b>POST</b> request, a web user that attempts to refresh the server response in certain user agents can cause {{the contents of the}} original <b>HTTP</b> <b>POST</b> request to be resubmitted, possibly causing undesired results, such as a duplicate web purchase.|$|E
5000|$|<b>HTTP</b> <b>POST</b> has {{different}} vulnerability to CSRF, depending on detailed usage scenarios: ...|$|E
5000|$|Web Service - A {{web service}} that accepts <b>http</b> <b>posts</b> of check results (beta) ...|$|R
5000|$|SensorThings API {{defines the}} {{following}} resources. As SensorThings is a RESTful web service, each entity can be CREATE, READ, UPDATE, and DELETE with standard <b>HTTP</b> verbs (<b>POST,</b> GET, PATCH, and DELETE): ...|$|R
5000|$|<b>HTTP</b> 1.1. GET, <b>POST,</b> PUT, DELETE, HEAD {{including}} file upload operations; ...|$|R
50|$|For Web Browser SSO, the HTTP Redirect Binding and the <b>HTTP</b> <b>POST</b> Binding are {{commonly}} used. For example, the service provider may use HTTP Redirect {{to send a}} request while the identity provider uses <b>HTTP</b> <b>POST</b> to transmit the response. This example illustrates that an entity's choice of binding is independent of its partner's choice of binding.|$|E
50|$|User agents (such as browsers) store {{only the}} URI of an HTTP request as a bookmark. Because of this, an <b>HTTP</b> <b>POST</b> request {{that results in}} a {{response}} based {{on the body of}} the <b>HTTP</b> <b>POST</b> request cannot be bookmarked. By using the PRG pattern, the URI of the request can safely be bookmarked by a web user.|$|E
5000|$|POST/XML: {{using the}} <b>HTTP</b> <b>POST</b> {{protocol}} for transferring XML data and binary coverage data.|$|E
5000|$|Webmention, {{a modern}} re-implementation of PingBack using <b>HTTP</b> and x-www-urlencoded <b>POST</b> data.|$|R
50|$|An Enterprise {{edition of}} the {{application}} includes advanced extraction and automation features for specific or large volume extractions, sending series of automatically generated <b>HTTP</b> or <b>POST</b> queries and uploading scraped data to FTP servers.|$|R
5000|$|All items have {{a unique}} URI that gets exposed via HTTP. It uses the <b>HTTP</b> methods <b>POST,</b> GET, PUT and DELETE for the four basic CRUD (Create, Read, Update, Delete) {{operations}} on all resources.|$|R
5000|$|The client opens a {{connection}} to the server and sends the program name (via <b>HTTP</b> <b>Post).</b>|$|E
50|$|This {{reorganization}} provides tremendous flexibility: taking just Web Browser SSO {{alone as}} an example, a service provider {{can choose from}} four bindings (HTTP Redirect, <b>HTTP</b> <b>POST</b> and two flavors of HTTP Artifact), while the identity provider has three binding options (<b>HTTP</b> <b>POST</b> plus two forms of HTTP Artifact), {{for a total of}} twelve (12) possible deployments of the SAML 2.0 Web Browser SSO Profile.|$|E
5000|$|Generic {{code for}} making network connections, {{transmitting}} {{objects to the}} database, parsing user input via <b>HTTP</b> <b>POST</b> events, etc.|$|E
5000|$|Additional Resources: With an <b>HTTP</b> verb like <b>POST,</b> GET, PATCH, PUT, or DELETE) ...|$|R
5000|$|Restful {{controllers}} {{provide an}} optional way for separating the logic behind serving <b>HTTP</b> GET and <b>POST</b> requests.|$|R
5000|$|Resources can be created, modified, deleted {{and read}} using {{standard}} <b>HTTP</b> methods (i.e., <b>POST,</b> PUT, PATCH, DELETE, GET) ...|$|R
5000|$|LoadVars - A Load Variables object {{allows for}} the storing and send of <b>HTTP</b> <b>POST</b> and HTTP GET {{variables}} ...|$|E
50|$|Curl {{offers many}} other features, {{including}} proxy support, user authentication, FTP upload, <b>HTTP</b> <b>post,</b> SSL connections, cookies, file transfer resume, and Metalink.|$|E
50|$|Deepfish was retired on 30 September 2008 while {{important}} features including JavaScript, AJAX, cookies, ActiveX controls and <b>HTTP</b> <b>POST</b> were not implemented.|$|E
50|$|Static {{and dynamic}} web pages can be {{retrieved}} by <b>posting</b> <b>HTTP</b> requests to the remote web server using socket programming.|$|R
50|$|Methods {{which are}} {{declared}} remote {{may also be}} invoked via an <b>HTTP</b> GET or <b>POST</b> request. Consider the GET request as shown.|$|R
5000|$|... cURL [...] - [...] {{command line}} tool and library for {{transferring}} (including getting) data with URLs supporting {{a wide range}} of <b>http</b> methods (GET, <b>POST,</b> cookies, etc.) ...|$|R
5000|$|Send the {{username}} and password (encoded as form fields) {{along with}} the cookie via an <b>HTTP</b> <b>POST</b> to the security check URL.|$|E
5000|$|To export a page {{which may}} cause side effects, {{accessible}} only via <b>HTTP</b> <b>POST,</b> include one argument {{of the page}} handler of type Basis.postBody.|$|E
5000|$|IPP {{uses the}} {{traditional}} client-server model, with clients sending IPP request messages with the MIME media type [...] "application/ipp" [...] in <b>HTTP</b> <b>POST</b> requests to an IPP printer. IPP request messages consist of key/value pairs using a custom binary encoding {{followed by an}} [...] "end of attributes" [...] tag and any document data required for the request. The IPP response is {{sent back to the}} client in the <b>HTTP</b> <b>POST</b> response, again using the [...] "application/ipp" [...] MIME media type.|$|E
50|$|HTTP Flood {{is a type}} of Distributed Denial of Service (DDoS) {{attack in}} which the {{attacker}} manipulates <b>HTTP</b> and <b>POST</b> unwanted requests in order to attack a web server or application. These attacks often use interconnected computers that have been taken over with the aid of malware such as Trojan Horses. Instead of using malformed packets, spoofing and reflection techniques, HTTP floods require less bandwidth to attack the targeted sites or servers.|$|R
50|$|In {{the case}} of <b>HTTP</b> PUT or <b>POSTs,</b> the user-submitted data are {{provided}} to the program via the standard input. The Web server creates {{a subset of the}} environment variables passed to it and adds details pertinent to the HTTP environment.|$|R
50|$|Publishers expose {{their content}} with the {{inclusion}} of hub references in the <b>HTTP</b> headers. They <b>post</b> notifications to those referenced hubs whenever they publish something. Thus, when a publication event occurs, the publisher calls its hubs and the hubs call their subscribers.|$|R
50|$|Communication between {{clients and}} a JSON-WSP server {{is carried out}} using <b>HTTP</b> <b>POST</b> {{requests}} and responses, with the JSON objects as data with the content-type application/json.|$|E
5000|$|If a {{web user}} refreshes before the initial {{submission}} has completed because of server lag, {{resulting in a}} duplicate <b>HTTP</b> <b>POST</b> request in certain user agents.|$|E
50|$|Gentoox uses a {{modified}} version of the Xbox-Linux BIOS known as Cromwell. Gentoox Loader has advanced features such as the ability to flash the Xbox's BIOS via <b>HTTP</b> <b>POST</b> and even the ability to boot a Linux kernel via <b>HTTP</b> <b>POST</b> or GET. Gentoox compiles all new software, safely optimizing it for the Xbox's architecture. While this may increase the performance of the compilation output, it means that installing new software can take large amounts of time (e.g. compiling open office takes around 24 hours).|$|E
50|$|This {{prototype}} developer {{service is}} an implementation of HTTP-based FeedSync endpoint. Applications can use <b>HTTP</b> GET and <b>POST</b> commands to synchronize feeds, where the latter performs the FeedSync merge operation on the feed {{hosted by the}} FeedSync Service. The service is not active anymore.|$|R
5000|$|Hypertext Transfer Protocol (HTTP) is stateless: {{a client}} {{computer}} running {{a web browser}} must establish a new Transmission Control Protocol (TCP) network connection to the web server with each new <b>HTTP</b> GET or <b>POST</b> request. The web server, therefore, cannot rely on an established TCP network connection for longer than a single <b>HTTP</b> GET or <b>POST</b> operation. Session management is the technique used by the web developer to make the stateless HTTP protocol support session state. For example, once a user has been authenticated to the web server, the user's next HTTP request (GET or POST) should not cause the web server {{to ask for the}} user's account and password again. For a discussion of the methods used to accomplish this see HTTP cookie and Session ID ...|$|R
50|$|In some networks, {{the use of}} CONNECT {{method is}} {{restricted}} to some trusted sites. In such cases, an HTTP tunnel can still be implemented using only the usual <b>HTTP</b> methods as <b>POST,</b> GET, PUT and DELETE. This {{is similar to the}} approach used in Bidirectional-streams Over Synchronous HTTP (BOSH).|$|R
