2|15|Public
40|$|Polyamide fibre {{containing}} amber particles was fabricated. The amber particles {{were obtained}} by grinding technology using planetary ball-mills. Scanning electron microscopy and granulometry testing were used to characterise the structure {{and the size of}} prepared amber particles. Fourier transform infrared spectroscopy was used to analyse the chemical structure of the amber particles. The amber particles were characterised with average size up to 3 μm. The chemical composition of amber before and after the grinding remained unchanged. The amber particles were melt-extruded using polyamide 6 as the matrix. Melt spinning processing was used to fabricate polyamide-amber filaments. Pre-oriented yarns and fully drawn yarns were obtained after <b>hotdrawing</b> experiments. Reported experimental findings of amber composite fibre could be important for textile applications...|$|E
40|$|Imogolite/poly (vinyl alcohol) (PVA) {{composite}} fibers {{were obtained}} by the conventional wet-spinning used Na 2 SO 4 as coagulation solution. Imogolite is a rod shaped rigid inorganic polymer composed of alumina-silicate {{and is expected to}} from ordered structure when extruded through a nozzle because of its shape. PVA molecule is also expected to be ordered through intermolecular interaction between the OH groups of imogolite and PVA. Although an imogolite content to PVA is as low as 6. 9 wt%, the wide angle X-ray diffraction diagram from fiber of imogolite/PVA system shows the high intenstity in the equatorial direction in Debye-Scherrer rings from both components, suggesting that both imogolite and PVA molecules were oriented to the extruded direction without <b>hotdrawing.</b> The mechanical properties of composite fiber, however, shows no positive effect of imogolite. According to the scanning electron microscopic observation, the cross section of composite fiber reveals aggregates which seems to be composed of imogolite...|$|E
40|$|We {{show how}} a new {{technique}} called use case maps helps humans to understand, capture, analyze, reuse, and change high-level behaviour patterns in complex software. We do so through the example of reengineering an objectoriented framework, a type of software that is well known {{to be difficult to}} understand. In the framework we studied (<b>HotDraw),</b> we trace scenarios through the software and express the behaviour patterns we see with use case maps. These maps express high-level behaviour patterns in terms of cause-effect paths, above the detailed level of messages. We find some unexpected, irregular patterns in <b>Hotdraw's</b> use case maps, redraw the maps, and make resulting changes to the software. The contribution of this paper is intended to be, not changes to <b>Hotdraw,</b> but the techniques we used to aid human understanding and communication of high-level behaviour patterns...|$|R
40|$|Constraints {{have long}} been championed {{as a tool for}} user {{interface}} construction. However, while certain constraint systems have established a user community, constraint -based user interfaces have not yet been widely adopted. The premise of this paper is that a major stumbling block to their pervasive use has been the emphasis on designing new interface toolkits rather than augmenting existing ones. The thesis of the work described in this paper is that it is possible, and practical, to convert an existing user interface written in an imperative programming language into a similar user interface implemented with constraints. This thesis is proved by example: the conversion of <b>HotDraw</b> into CoolDraw. KEYWORDS user interface toolkits, constraints, conversion, <b>HotDraw,</b> CoolDraw, direct manipulation MOTIVATION Constraints {{have long been}} championed as a tool for user interface construction. The user interface research and development community has developed constraint algorithms, interfa [...] ...|$|R
40|$|As {{frameworks}} evolve, it {{is common}} for reuse by inheritance to be replaced by reuse by composition. This has happened recently to <b>HotDraw,</b> a structured drawing editor framework for Smalltalk. Class Tool, which once was frequently subclassed, has been broken into several smaller components, and new tools can now be defined entirely by composing other objects. Although creating a new tool might require creating a new component, the amount of code necessary to create a new tool has decreased significantly, and it is easier to learn how to create a new tool. This is not only important for users of <b>HotDraw,</b> but illustrates a design technique {{that can be used in}} other programs. 1 Introduction As frameworks evolve, {{it is common}} for reuse by inheritance to be replaced by reuse by composition. One reason that inheritance is used first might be that Smalltalk offers better support for inheritance than it does for composition. Another reason might be that it is easier to think about incrementall [...] ...|$|R
40|$|Go, a new {{programming}} language backed by Google, {{has the potential}} for widespread use: it deserves an evaluation. Design patterns are records of idiomatic programming practice and inform programmers about good program design. In this study, we evaluate Go by implementing design patterns, and porting the “patterndense” drawing framework <b>HotDraw</b> into Go, producing GoHot-Draw. We show how Go’s language features affect the implementation of Design Patterns, identify some potential Go programming patterns, and demonstrate how studying design patterns can contribute to the evaluation of a {{programming language}}. D. 3. 0 [Programming Lan-Categories and Subject Descriptor...|$|R
40|$|Current {{refactoring}} tools {{only provide}} support for performing selected refactorings. We show how tool support can be provided for the preparatory phases of refactoring as well, by determining when a software application should be refactored and which refactoring(s) in particular should be applied. We implemented a tool to detect bad smells and to propose adequate refactorings based on these smells, and validated this tool by carrying out experiments in three concrete case studies: the Soul application, the Smalltalk Collection hierarchy, and the <b>HotDraw</b> application framework. We also show how our tool complements the Smalltalk Refactoring Browser...|$|R
40|$|Abstract: The {{documentation}} for {{a framework}} must meet several requirements. These requirements {{can all be}} met by structuring the documentation {{as a set of}} patterns, sometimes called a “pattern language”. Patterns can describe the purpose of a framework, can let application programmers use a framework without having to understand in detail how it works, and can teach many of the design details embodied in the framework. This paper shows how to use patterns to document a framework, and includes a set of patterns for <b>HotDraw</b> as an example. Christopher Alexander, an architect, developed the idea of a “pattern language ” to enable people to design their own homes and communitie...|$|R
40|$|The paper {{presents}} the essential {{features of a}} new member of the UML language family that supports working with object-oriented frameworks. This UML extension, called UML-F, allows the explicit representation of framework variation points. The paper discusses some of the relevant aspects of UML-F, {{which is based on}} standard UML extension mechanisms. A case study shows how {{it can be used to}} assist framework development. A discussion of additional tools for automating framework implementation and instantiation rounds out the paper. 1 Introduction Object-oriented (OO) frameworks and product line architectures have become popular in the software industry during the 1990 s. Numerous frameworks have been developed in industry and academia for various domains, including graphical user interfaces (e. g. Java's Swing and other Java standard libraries, Microsoft's MFC), graph-based editors (<b>HotDraw,</b> Stingray's Objective Views), business applications (IBM's San Francisco), network server [...] ...|$|R
40|$|Introduction An {{object-oriented}} {{framework is}} an OO class hierarchy augmented {{with a built-in}} model which defines how the objects derived from the hierarchy interact with one another. Thus, a framework {{is more than a}} class library: it is a generic solution within a problem domain because the model of interaction is domain-specific. A framework is tailored to solve a particular problem by customizing its abstract and concrete classes. The framework architecture is reused by all specific solutions in that problem domain. By providing both design and infrastructure for developing applications, the framework approach promises to develop applications faster [Lew 95]. The most popular frameworks are in the GUI application domain (e. g., MacApp, ET++, CommonPoint) and in the drawing domain (e. g., <b>HotDraw,</b> UniDraw), but frameworks have also been developed in other domains such as multimedia, manufacturing, financial trade, and data access. Developing an application by using a framework...|$|R
40|$|Adequate {{documentation}} of an object-oriented framework is the prerequisite to its {{success as a}} reusable component. The overall design of a framework and its intended method of reuse are not obvious from the source code and thus {{have to be addressed}} in the documentation. Most importantly, the {{documentation of}} a framework has to be structured {{in such a way that}} it guarantees the adequate support of three major audiences: users selecting a framework, users learning to develop typical applications based on the selected framework, and users intending to modify its architecture. This paper presents a model for structuring the documentation of an object-oriented framework. The model integrates existing approaches such as patterns, hypertext, program-understanding tools, and formal approaches into a single structure that is geared towards supporting the three audiences. The model will be illustrated using <b>HotDraw,</b> a Smalltalk framework for drawing editors, as an example. We also give a preli [...] ...|$|R
40|$|Despite their {{potential}} applications in software comprehension, {{it appears that}} dynamic visualisation tools are seldom used outside the research laboratory. This paper presents an empirical evaluation of five dynamic visualisation tools - AVID, Jinsight, jRMTool, Together ControlCenter diagrams and Together ControlCenter debugger. The tools were evaluated {{on a number of}} general software comprehension and specific reverse engineering tasks using the <b>HotDraw</b> objectoriented framework. The tasks considered typical comprehension issues, including identification of software structure and behaviour, design pattern extraction, extensibility potential, maintenance issues, functionality location, and runtime load. The results revealed that the level of abstraction employed by a tool affects its success in different tasks, and that tools were more successful in addressing specific reverse engineering tasks than general software comprehension activities. It was found that no one tool performs well in all tasks, and some tasks were beyond the capabilities of all five tools. This paper concludes with suggestions for improving the efficacy of such tools...|$|R
40|$|The {{documentation}} for {{a framework}} must meet several requirements. These requirements {{can all be}} met by structuring the documentation {{as a set of}} patterns, sometimes called a "pattern language". Patterns can describe the purpose of a framework, can let application programmers use a framework without having to understand in detail how it works, and can teach many of the design details embodied in the framework. This paper shows how to use patterns to document a framework, and includes a set of patterns for <b>HotDraw</b> as an example. Christopher Alexander, an architect, developed the idea of a "pattern language" to enable people to design their own homes and communities [Alexander et. al. ]. A pattern language is a set of patterns, each of which describes how to solve a particular kind of problem. His pattern language starts at a very large scale, explaining how the world should be broken into nations and nations into smaller regions, and goes on to explain how to arrange roads, parking, sho [...] ...|$|R
40|$|In {{recent years}} {{object-oriented}} frameworks {{have been identified}} as having the potential to provide the benefits of large-scale software reuse. In this paper we describe an exploratory case study that investigates one of the main challenges in framework usage [...] effective understanding. The study gathered a mixture of quantitative and qualitative data as subjects learned to use a Java version of the <b>HotDraw</b> framework over a 12 -week period. The main findings are that subjects had difficulty: understanding the dynamic structure of the framework, mapping their chosen solutions onto the framework architecture, and choosing between alternative solution strategies. A number of aids to understanding were found to be helpful, with practical exercise solutions and example applications being the most effective. We compare these findings to recent work by Schull, Lanubile and Basili, supporting their hypothesis that examples are well suited for framework learning by novices, but arguing that both hierarchical and dynamic models also seem critically important. The challenge is to identify the minimum contribution required from each of these approaches, how to integrate them, and how to provide effective tool support...|$|R
40|$|Abstract: The {{documentation}} for {{a framework}} must meet several requirements. These requirements {{can all be}} met by structuring the documentation {{as a set of}} patterns, sometimes called a “pattern language”. Patterns can describe the purpose of a framework, can let application programmers use a framework without having to understand in detail how it works, and can teach many of the design details embodied in the framework. This paper shows how to use patterns to document a framework, and includes a set of patterns for <b>HotDraw</b> as an example. Christopher Alexander, an architect, developed the idea of a “pattern language ” to enable people to design their own homes and communities [Alexander et. al. ]. A pattern language is a set of patterns, each of which describes how to solve a particular kind of problem. His pattern language starts at a very large scale, explaining how the world should be broken into nations and nations into smaller regions, and goes on to explain how to arrange roads, parking, shopping, places to work, homes, and places of worship. The patterns focus on finer and finer levels of detail, passing though a discussion of how to arrange rooms in a house, and finally describing the type of material to use for walls, how to decorate rooms, and how to provide lighting. Alexander's pattern language {{is supposed to be a}} document that non-architects can use to design their own communities and homes. No specialized training is needed to use it. It focuses on common design problems that non-architects will encounter, like how to build bedrooms and row houses, rather than uncommon ones, like how to build concert halls and cathedrals. To be presented at OOPSLA’ 92...|$|R
40|$|CONTENTS 1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 1 2 <b>HotDraw</b> : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3 2. 1 Drawing : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3 2. 2 Figures : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 4 2. 3 Tools : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 5 2. 4 Meta-Figures : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 5 3 What InVaider Can Do : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 7 3. 1 Pert Chart : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 7 3. 2 FlowKit : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 9 3. 3 Digital Logic Circuit Simulator<F 4. 03...|$|R
40|$|Although Model-View-Controller {{architecture}} and MVC++ support building object-oriented and modular applications, designing and implementing the model data handling in view and controller layers {{requires a lot}} of work. If an abstraction about the generic behaviour of the model layer can be constructed, an object-oriented framework could be designed to provide automatic handling and presentation of model layer data. This thesis presents a design of such a framework as well as some early usage experiences. The presented framework succeeds in supporting presentation and modifications of already existing data, but can not offer good support for object creation and removal. Experimenting with test programs and prototypes has been encouraging, but has also revealed some typical problems of framework design, implementation and usage. As a conclusion, one can say that a framework reaching beyond MVC++ functionality can provide partly automatic data handling for MVC++ applications. The presented Model Presentation Framework undoubtedly needs more work to reach the maturity level found in more advanced frameworks. Keywords: frameworks, object-oriented design, design patterns, Model-View-Controller architecture, MVC++ 1. Introduction	 1 2. Model-View-Controller Architecture	 3 2. 1. Principles of Model-View-Controller Architecture	 3 2. 1. 1. Parts of Model-View-Controller Architecture	 3 2. 1. 2. Loose Coupling with Dynamic Binding 6 2. 2. Applying MVC++ in Practise	 7 2. 3. Laborious MVC++	 8 2. 3. 1 MVC Architecture requires many Classes 8 2. 3. 2 Domain Object Parameters in MVC++ Model Part	 9 2. 4. Reducing the MVC++ Overhead	 10 3. Object-Oriented Frameworks	 12 3. 1. Framework Definition	 12 3. 2. Frameworks and Class Libraries	 13 3. 3. Frameworks and Design Patterns	 14 3. 4. White-box and Black-box Frameworks	 15 3. 5. Deploying multiple Frameworks	 16 3. 6. Framework Benefits and Pitfalls	 17 3. 7. Framework Life Span	 17 4. Developing Object-Oriented Frameworks 19 4. 1. Identifying Abstractions	 19 4. 2. Designing a Framework	 20 4. 3. Framework Implementation	 22 4. 4. Testing and Supporting the Framework 23 4. 5. Framework Maintenance	 24 4. 6. Framework Development Tools 25 4. 7. Summary	 26 5. Model Presentation Framework	 27 5. 1. Motivation behind the Model Presentation Framework	 27 5. 2. Model Presentation Framework Overview	 28 5. 3. Model Presentation Framework Architecture	 31 5. 3. 1. Attribute Encapsulation	 31 5. 3. 2. Model Interface	 32 5. 3. 3. Model Object Encapsulation	 35 5. 3. 4. User Interface Component Adaptation 37 5. 3. 5. Customised User Interface Components 38 5. 3. 6. Editing Support	 39 6. Utilising the Model Presentation Framework	 42 6. 1. Roles of the Model Presentation Framework in Applications	 42 6. 2. Displaying the Data	 42 6. 3. Modification through the Model Presentation Framework	 43 6. 4. Creating new Objects	 45 6. 5. Sample Application	 46 6. 6. Filtering and Sorting	 49 6. 7. Status of the Model Presentation Framework	 50 7. Applicability of MPF	 51 7. 1. Achieved Benefits	 51 7. 2. Drawbacks	 52 7. 3. Existing Usage Experiences	 53 7. 4. Comparison to other Frameworks	 55 7. 4. 1. ET++	 55 7. 4. 2. <b>HotDraw</b>	 56 7. 4. 3. Comparison Summary	 58 8. Conclusion	 59 References	 6...|$|R

