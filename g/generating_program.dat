58|2844|Public
5000|$|Quiz/exam <b>generating</b> <b>program</b> allows {{professors to}} design tests {{in a variety}} of formats ...|$|E
50|$|SMT solvers {{are useful}} both for verification, proving the {{correctness}} of programs, software testing based on symbolic execution, and for synthesis, <b>generating</b> <b>program</b> fragments by searching over {{the space of}} possible programs.|$|E
50|$|Aside {{from these}} reach-out activities, the Community Extension Service of SRCB {{extended}} its expertise through different {{programs such as}} SRCB Trisikad Livelihood Project, MISTP Trainers' Financial Loan Program, Micro-Entrepreneurs' Loan Program and Women's Income <b>Generating</b> <b>Program.</b>|$|E
5000|$|There {{are many}} fractal <b>generating</b> <b>programs</b> available, both free and commercial. Notable fractal <b>generating</b> <b>programs</b> include: ...|$|R
40|$|In {{order to}} {{increase}} the readability of the <b>generated</b> <b>programs,</b> a decompiling system has been implemented which integrates a decompiler, dcc, and an automatic signature generator, dccSign. Signatures for libraries and compilers are stored in a database that is read by the decompiler, thus, the <b>generated</b> <b>programs</b> can make use of known library names, such as WriteLn() and printf() ...|$|R
40|$|Robustness is {{essential}} for <b>programs</b> <b>generated</b> by Genetic <b>Programming</b> (GP). This paper presents a method to improve the robustness. The method employs non-determinism in two ways: one is to evolve robot programs in noisy environments and another is to use probabilistic branch in the function set. The experiment is carried out on robot navigation problems. The result of the experiment shows that the robustness of robot programs has been improved. The analysis shows that the robustness {{is caused by the}} acquired "experience" and the amount of reuse of this experience while performing the task. Key words: Robustness, Robot programs, Non-determinism, Evolutionary Computation, Genetic Programming 1. Introduction Artificial Intelligence (AI) has been widely used to automatically <b>generate</b> <b>programs.</b> Genetic Programming (GP) [1] is one of methods that becomes popular in automatic <b>generating</b> <b>programs.</b> Our experiment use GP to <b>generate</b> <b>programs</b> for controlling a robot. GP is performed [...] ...|$|R
5000|$|He is {{well known}} for his [...] "catchphrase", [...] "Buggrit, {{millennium}} hand an' shrimp...", which was the result of Pratchett feeding a random text <b>generating</b> <b>program</b> with a Chinese takeaway menu and the lyrics to They Might Be Giants' song Particle Man.|$|E
50|$|During the 1960s and 1970s, Ontario Hydro's nuclear <b>generating</b> <b>program</b> {{expanded}} {{with the}} building of the first four units of the Pickering Nuclear Generating Station followed by stations at Bruce Nuclear Generating Station and a second four units at Pickering. By the late 1980s, Ontario Hydro operated one of the largest fleets of nuclear-powered generating stations in the world.|$|E
50|$|Fractint is a {{freeware}} {{computer program}} that can render and display {{many kinds of}} fractals. The program originated on the MS-DOS platform, but has since been ported to Linux and Microsoft Windows. Additionally Tim Gilman has ported Fractint to the Macintosh. FractInt {{is one of the}} oldest freeware programs still being maintained. During the early 1990s the program was the definitive fractal <b>generating</b> <b>program</b> for personal computers.|$|E
50|$|Similarly, forms {{generators}} manage online {{interactions with}} the application system users or <b>generate</b> <b>programs</b> to do so.|$|R
40|$|Run-time {{specialization}} (RTS) is {{a technique}} that e#ciently <b>generates</b> specialized <b>programs</b> with respect to runtime values. For e#ciently <b>generating</b> specialized <b>programs,</b> RTS constructs compiled native code fragments called templates at compile-time, and <b>generates</b> a specialized <b>program</b> by merely copying the templates. The <b>generated</b> <b>programs</b> are, on the other hand, less e#cient, since the technique prevents many optimizations. This study proposes bytecode specialization (BCS), which <b>generates</b> <b>programs</b> in a bytecode language, and then translates the generated bytecode into native code by using Just-In-Time (JIT) compilers. The advantages of BCS are: (1) e#cient specialization processes {{that are similar to}} RTS, (2) e#cient specialized programs thanks to the optimizations of JIT compilers, and (3) independence of source-to-bytecode compilers and of bytecode-to-native compilers thanks to our proposed binding-time analysis, which directly handles bytecode programs. Thus far, we have implement [...] ...|$|R
2500|$|Jhc, a Haskell {{compiler}} {{written by}} John Meacham, emphasizes speed {{and efficiency of}} <b>generated</b> <b>programs</b> and exploring new program transformations.|$|R
50|$|The PowerVR chipset uses {{a method}} of 3D {{rendering}} known as tile-based deferred rendering (often abbreviated as TBDR) which is tile-based rendering combined with PowerVR's proprietary method of Hidden Surface Removal (HSR) and Hierarchical Scheduling Technology (HST). As the polygon <b>generating</b> <b>program</b> feeds triangles to the PowerVR (driver), it stores them in memory in a triangle strip or an indexed format. Unlike other architectures, polygon rendering is (usually) not performed until all polygon information has been collated for the current frame. Furthermore, the expensive operations of texturing and shading of pixels (or fragments) is delayed, whenever possible, until the visible surface at a pixel is determined — hence rendering is deferred.|$|E
50|$|The Vienna Development Method (VDM) {{is one of}} the longest-established formal {{methods for}} the {{development}} of computer-based systems. Originating in work done at the IBM Laboratory Vienna in the 1970s, it has grown to include a group of techniques and tools based on a formal specification language—the VDM Specification Language (VDM-SL). It has an extended form, VDM++, which supports the modeling of object-oriented and concurrent systems. Support for VDM includes commercial and academic tools for analyzing models, including support for testing and proving properties of models and <b>generating</b> <b>program</b> code from validated VDM models. There is a history of industrial usage of VDM and its tools and {{a growing body of research}} in the formalism has led to notable contributions to the engineering of critical systems, compilers, concurrent systems and in logic for computer science.|$|E
5000|$|Economists Ricardo Hausmann of Harvard University and Roberto Rigobón of the MIT Sloan School of Management {{performed}} a statistical analysis at Súmate's request, analyzing how fraud could have {{occurred during the}} referendum. They concluded that the vote samples audited by the government were not a random representation of all precincts, noting that the Chávez-backed CNE had [...] "refused to use the random number <b>generating</b> <b>program</b> offered by the Carter Center for the 18 August audit and instead used its own program installed in its own computer and initialed with their own seed." [...] They also noted that opposition witnesses and international observers were not allowed near the computer hub on election day. [...] According to the Wall Street Journal, a computer-science professor at Johns Hopkins University said, [...] "The Hausmann/Rigobon study is more credible {{than many of the}} other allegations being thrown around." [...] The Carter Center looked into the allegations and released a paper with a statistical analysis in response; this stated that the audit sample data, in particular the statistical correlation between the number of [...] "Yes" [...] voters and the number of petition signatories in each audited voting centre, were consistent with nationwide results, and reaffirmed the Carter Center's earlier conclusions. The Center for Economic and Policy Research drew on the Carter Center analysis and elaborated on the issue, criticising Hausmann and Rigobón's statistical model.|$|E
5000|$|Frieder Nake: On {{generative}} aesthetics - two picture <b>generating</b> <b>programs.</b> Proc. of the International Symposium Computer Graphics, Uxbridge: Brunel University 1970 ...|$|R
5000|$|Jhc is a Haskell {{compiler}} {{written by}} John Meacham emphasising speed {{and efficiency of}} <b>generated</b> <b>programs,</b> and exploring new program transformations.|$|R
40|$|Run-time {{specialization}} (RTS) techniques e#ciently <b>generate</b> specialized <b>programs</b> {{with respect}} to run-time values. They construct compiled native-code fragments called templates at compile-time, and <b>generate</b> a specialized <b>program</b> by merely copying the templates. The <b>generated</b> <b>programs</b> are less e#cient than those generated by static partial evaluation techniques because the RTS techniques prevent many optimizations. The proposed bytecode specialization (BCS) technique is used to <b>generate</b> <b>programs</b> in a bytecode language and then translate the generated bytecode into native code by using a just-in-time (JIT) compiler. Its advantages are (1) e#cient specialization processes {{that are similar to}} those of RTS techniques, (2) e#cient specialized programs thanks to optimizations by the JIT compilers, and (3) that it is independent of the source-to-bytecode and the bytecode-to-native compilers thanks to a binding-time analysis algorithm that directly handles bytecode programs. Th [...] ...|$|R
40|$|The major {{challenge}} for present technology is to generate software more efficiently. Computers {{are being used}} in essentially all areas of human activities; even products that seemingly {{have nothing to do}} with computers contain a significant portion of computer related cost. More efficient software means three things: coding and debugging programs faster; <b>generating</b> <b>program...</b>|$|E
40|$|A {{wealth of}} recent {{research}} involves <b>generating</b> <b>program</b> monitors from declarative specifications. Doing this efficiently has proved challenging, and available implementations often produce infeasibly slow monitors. We demonstrate how to dramatically improve performance — typically reducing overheads to within {{an order of}} magnitude of the program’s normal runtime. Categories and Subject Descriptors D. 3. 4 [Programming Languages]: Processors—Compiler...|$|E
40|$|Hypermedia can be {{regarded}} as a merge between multimedia and hypertext. The paper will describe the extension of a hypermedia system with music as a new document type, {{and the development of a}} software wrapper to give an existing, music <b>generating</b> <b>program</b> the flexible, interactive and object oriented interface needed by a hypermedia system. Additionally, some consequences of the fundamental difference between static and time-based media will be discussed...|$|E
50|$|Images of fractals can {{be created}} by fractal <b>generating</b> <b>programs.</b> Because of the {{butterfly}} effect a small change in a single variable can have a unpredictable outcome.|$|R
40|$|Software {{product line}} {{engineering}} is one approach to implement sets of related programs efficiently. Software product lines (SPLs) {{can be implemented}} by code transformations which are combined in order to <b>generate</b> a <b>program.</b> A code transformation may add functionality to a base program or may alter its structure. Though implemented with less effort, <b>generated</b> <b>programs</b> are harder to debug because debug changes must effect the SPL transformations which the program was built from. In this paper, we present {{a new approach to}} debug programs (of an SPL) <b>generated</b> by <b>program</b> transformations...|$|R
50|$|The Air Force Armament Museum Foundation is a {{volunteer}} body {{that runs the}} fund <b>generating</b> <b>programs</b> of the Armament Museum and decides how funds donated to the museum are spent.|$|R
40|$|In {{order to}} support {{automatically}} generating an assemble program by combining prepared assemble program modules, we propose in this paper a general way to create multiple arranging patterns of modules obeying given arrange order relations that represent the relative arranging position of modules in a program. It is carried out with time complexity O(1 V I Z) by transforming the arrange order relations into a directed graph AOR-G and then on AOR-G giving multiple sequences of nodes, equivalent to arranging patterns of modules, through constructing a layer graph. Furthermore, to improve the search time costed in constructing the layer graph, we propose two algorithms respectively to delete extra edges from AOR-Ca whose information has been included in other arrange order relations, and to extract a related graph G r (a minimum subgraph of AOR-G) to a given node set r, representing the modules required {{to be used in}} a <b>generating</b> <b>program.</b> Finally we give three operations to reduce the related graph G r by deleting unnecessary nodes for the <b>generating</b> <b>program,</b> trying to further improve the time complexity O(1 V I 2) ...|$|E
40|$|We {{investigate}} {{the combination of}} answer set programming and qualitative optimization techniques. Answer set optimization programs (ASO programs) have two parts. The <b>generating</b> <b>program</b> Pgen produces answer sets representing possible solutions. The preference program Ppref expresses user preferences. It induces a preference relation on the answer sets of Pgen based on {{the degree to which}} rules are satisfied. We discuss possible applications of ASO programming, give complexity results and propose implementation techniques. We also analyze the relationship between ASO programs and CP-networks...|$|E
40|$|Bachelor thesis {{deals with}} a {{proposal}} of a graphic controller for FPGA circuits. Thesis describes the communication between a circuit and a monitor, RAM memory, input device (keyboard) and the manipulation with the system. Not only it includes the description of a video memory data <b>generating</b> <b>program,</b> but also it describes the communication with a monitor on the hardware level. Moreover, it suggests the possibility of controlling the video output. Finally, it discusses possible future extensions of the controller's functionality...|$|E
40|$|Abstract. In feature-oriented programming, {{a feature}} is an {{increment}} in program functionality and is implemented by a feature module. <b>Programs</b> are <b>generated</b> by composing feature modules. A <b>generated</b> <b>program</b> {{may be used}} by other client programs but occasionally must be transformed to match a particular legacy interface {{before it can be}} used. We call the mismatch of the interface of a <b>generated</b> <b>program</b> and a client-desired in-terface an incompatibility. We introduce the notion of refactoring feature modules (RFMs) that extend feature modules with refactorings. We ex-plain how RFMs reduce incompatibilities and facilitate reuse, and report our experiences on five case studies. ...|$|R
40|$|Several {{techniques}} for <b>generating</b> readable <b>programs</b> from SDL specifications are presented. These techniques {{can be used}} to produce programs in a standard object-oriented programming language which preserve the appearance of the source SDL specification. The main technique is to postpone most semantic transformations until the run-time of the generated system. We show how the so-called start-up time of the <b>generated</b> <b>program</b> {{can be used to}} restructure it from a readable form (which is used for inspections) into efficient run-time structures (which are used to execute it within the corresponding run-time support system). We present some details of the new approach and compare it with a few other code generators. We show that the application of the new techniques does not imply any loss of efficiency of the <b>generated</b> <b>programs</b> as compared to more conventional approaches [...] H...|$|R
50|$|The next day, Tiki Bar TV {{moved to}} the #1 slot in the iTunes Podcast charts, and as such Tiki Bar TV {{was one of the}} first user <b>generated</b> <b>programs</b> to gain {{worldwide}} popularity via the iTunes distribution model.|$|R
40|$|Operations {{languages}} {{are used to}} write spacecraft operations procedures. The APPAREIL tool automates the process of <b>generating</b> <b>program</b> translators between operations languages, from a specification of their language grammar annotated with extra information. From these annotated grammars the tool automatically produces a partial translator that covers most of the translation. This translator needs to be augmented manually with specific transformations, {{to deal with the}} more complicated cases. To get more confidence on the correctness of the translation, the tool offers a control-flow equivalence verification module. Anglai...|$|E
40|$|The {{human mind}} is {{functioning}} symbolically when some components of its experience – symbols – elicite beliefs, emotions, and usages, respecting other components of its experience – meaning –. The organic function-ing whereby there is {{transition from the}} symbol to the meaning will be called “symbolic reference”. (Whitehead, A. N., 1927) Abstract: A method is presented for <b>generating</b> <b>program</b> image of robotic object manipu-lation on virtually real environment models. By describing the program {{in terms of a}} priori established sensor-actuator couplings, process prototypes are realized in real world. Despit...|$|E
40|$|Abstract- In {{this paper}} we {{describe}} a spatial database benchmark for classroom application called Space Bench. In many ways this benchmark {{is similar in}} structure to the industry standard TPC-h benchmark. Space Bench, however, is designed to test {{the performance of a}} database system that supports spatial types and operations, as defined by the OpenGIS spatial specifications [1, 2]. Specifically, the benchmark includes a spatial database schema, a collection of spatial queries, and a data <b>generating</b> <b>program</b> for generating spatial data. Initial results indicate that this benchmark is very helpful when used as a project in an advanced course on spatial database systems...|$|E
30|$|This section {{shows how}} the <b>generated</b> <b>program</b> from BZR {{compiler}} is integrated into the management system. This consists in connecting the inputs of the automata to the corresponding events and the outputs of the automata to the corresponding commands or operations.|$|R
50|$|When {{she was the}} First Lady (2004-2012), she and {{her staff}} {{coordinate}} social policies for her husband's administration, <b>generating</b> <b>programs</b> of health and education for children, young people, single mothers and the family, in general, as {{a key element in}} society.|$|R
40|$|This paper {{considers}} random {{testing of}} a compiler, using randomly <b>generated</b> <b>programs</b> as inputs, and comparing their behaviour {{with and without}} optimisation. Since the <b>generated</b> <b>programs</b> must compile, {{then we need to}} take into account syntax, scope rules, and type checking during our random generation. Doing so, while attaining a good distribution of test data, proves surprisingly subtle; the main contribution of this paper is a workable solution to this problem. We used it to generate typed functions on lists, which we compiled using the Glasgow Haskell compiler, a mature production quality Haskell compiler. After around 20, 000 tests we triggered an optimiser failure, and automatically simplified it to a program with just a few constructs...|$|R
