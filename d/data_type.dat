4114|10000|Public
5|$|The null <b>data</b> <b>type</b> {{represents}} a variable {{that has no}} value; NULL is the only allowed value for this <b>data</b> <b>type.</b>|$|E
5|$|The NULL literal is untyped in SQL, {{meaning that}} it is not {{designated}} as an integer, character, or any other specific <b>data</b> <b>type.</b> Because of this, it is sometimes mandatory (or desirable) to explicitly convert Nulls to a specific <b>data</b> <b>type.</b> For instance, if overloaded functions are supported by the RDBMS, SQL {{might not be able to}} automatically resolve to the correct function without knowing the data types of all parameters, including those for which Null is passed.|$|E
5|$|Methods in {{programming}} language are {{the members of}} a class in a project, some methods have signatures and some don't have signatures. Methods can be void or can return something like string, integer, double, decimal, float and bool. If a method is void it means that the method does not return any <b>data</b> <b>type.</b>|$|E
5000|$|ActionScript {{primarily}} {{consists of}} [...] "fundamental" [...] or [...] "simple" [...] <b>data</b> <b>types</b> {{which are used}} to create other <b>data</b> <b>types.</b> These <b>data</b> <b>types</b> {{are very similar to}} Java <b>data</b> <b>types.</b> Since ActionScript 3 was a complete rewrite of ActionScript 2, the <b>data</b> <b>types</b> and their inheritances have changed.|$|R
5000|$|Many {{implementations}} of YAML {{can support}} user-defined <b>data</b> <b>types</b> for object serialization. Local <b>data</b> <b>types</b> are not universal <b>data</b> <b>types</b> but are {{defined in the}} application using the YAML parser library. Local <b>data</b> <b>types</b> use a single exclamation mark (...) [...]|$|R
50|$|The main way of {{defining}} <b>data</b> <b>types</b> in Agda is via inductive <b>data</b> <b>types</b> which {{are similar to}} algebraic <b>data</b> <b>types</b> in non-dependently typed programming languages.|$|R
5|$|In a {{practical}} implementation, the variables {{used to represent}} the indices will often be of fixed size, and this can result in an arithmetic overflow for very large arrays. If {{the midpoint of the}} span is calculated as (L + R) / 2, then the value of L + R may exceed the range of integers of the <b>data</b> <b>type</b> used to store the midpoint, even if L and R are within the range. If L and R are nonnegative, this can be avoided by calculating the midpoint as L + (R minus& L) / 2.|$|E
25|$|Define a <b>data</b> <b>type,</b> and how {{values of}} that <b>data</b> <b>type</b> are combined.|$|E
25|$|A'i is {{the number}} of <b>data</b> <b>type</b> A at sample site i, B'i {{is the number}} of <b>data</b> <b>type</b> B at sample site i, K {{is the number of}} sites sampled and || is the {{absolute}} value.|$|E
50|$|Cg also {{features}} vector and matrix <b>data</b> <b>types</b> {{that are based}} on the basic <b>data</b> <b>types,</b> such as float3 and float4x4. Such <b>data</b> <b>types</b> are quite common when dealing with 3D graphics programming. Cg also has struct and array <b>data</b> <b>types,</b> which work in a similar way to their C equivalents.|$|R
5000|$|There are {{additional}} [...] "complex" [...] <b>data</b> <b>types.</b> These are more processor and memory intensive and consist of many [...] "simple" [...] <b>data</b> <b>types.</b> For AS2, {{some of these}} <b>data</b> <b>types</b> are: ...|$|R
5000|$|A {{wide range}} of {{computational}} <b>data</b> <b>types,</b> program control <b>data</b> <b>types,</b> and forms of <b>data</b> structure (strong <b>typing).</b>|$|R
25|$|Because {{variables}} conforming only to nominal or ordinal measurements {{cannot be}} reasonably measured numerically, {{sometimes they are}} grouped together as categorical variables, whereas ratio and interval measurements are grouped together as quantitative variables, which can be either discrete or continuous, due to their numerical nature. Such distinctions can often be loosely correlated with <b>data</b> <b>type</b> in computer science, in that dichotomous categorical variables may be represented with the Boolean <b>data</b> <b>type,</b> polytomous categorical variables with arbitrarily assigned integers in the integral <b>data</b> <b>type,</b> and continuous variables with the real <b>data</b> <b>type</b> involving floating point computation. But the mapping of computer science data types to statistical data types depends on which categorization of the latter is being implemented.|$|E
25|$|Matrices as {{fundamental}} <b>data</b> <b>type.</b>|$|E
25|$|Using an {{otherwise}} valid instruction {{on the wrong}} <b>data</b> <b>type</b> (see packed decimal/binary coded decimal).|$|E
30|$|Another notable {{issue in}} {{exploring}} the AoaS layout {{is the use}} of build-in <b>data</b> <b>types.</b> CUDA has provided various build-in <b>data</b> <b>types.</b> The size requirement for alignment is automatically fulfilled. Compared to those user-defined <b>data</b> <b>types</b> in AoaS formant (see Fig.  3), we have found the counterparts of the build-in <b>data</b> <b>types</b> provided by CUDA do not achieve notable advantages. In addition, the user-defined AoaS <b>data</b> <b>types</b> are suggested to be used for the convenience in programming.|$|R
40|$|Building on Wouter Swierstra’s <b>Data</b> <b>types</b> à la carte, {{we present}} a {{comprehensive}} Haskell library of compositional <b>data</b> <b>types</b> suitable for practical applications. In this framework, <b>data</b> <b>types</b> and functions on them can be defined in a modular fashion. We extend the existing work by implementing {{a wide array of}} recursion schemes including monadic computations. Above all, we generalise recursive <b>data</b> <b>types</b> to contexts, which allow us to characterise a special yet frequent kind of catamorphisms. The thus established notion of term homomorphisms allows for flexible reuse and enables shortcut fusion style deforestation which yields considerable speedups. We demonstrate our framework in the setting of compiler construction, and moreover, we compare compositional <b>data</b> <b>types</b> with generic programming techniques and show that both are comparable in run-time performance and expressivity while our approach allows for stricter types. We substantiate this conclusion by lifting compositional <b>data</b> <b>types</b> to mutually recursive <b>data</b> <b>types</b> and generalised algebraic <b>data</b> <b>types.</b> Lastly, we compare the run-time performance of our techniques with traditional implementations over algebraic <b>data</b> <b>types.</b> The results are surprisingly good...|$|R
5000|$|Additional <b>data</b> <b>types</b> and {{attributes}} {{corresponding to}} common PC <b>data</b> <b>types</b> (e.g. [...] , [...] ).|$|R
25|$|Another {{alternative}} to OT is using sequence types of conflict-free replicated <b>data</b> <b>type.</b>|$|E
25|$|Prolog's single <b>data</b> <b>type</b> is the term. Terms {{are either}} atoms, numbers, {{variables}} or compound terms.|$|E
25|$|MIPS V {{added a new}} <b>data</b> <b>type,</b> the Paired Single (PS), which {{consisted}} of two single-precision (32-bit) floating-point numbers stored in the existing 64-bit floating-point registers. Variants of existing floating-point instructions for arithmetic, compare and conditional move were added to operate on this <b>data</b> <b>type</b> in a SIMD fashion. New instructions were added for loading, rearranging and converting PS data. It was the first instruction set to exploit floating-point SIMD with existing resources.|$|E
40|$|We {{propose to}} extend iUML-B class-diagrams to {{elaborate}} Abstract <b>Data</b> <b>Types</b> (ADTs) specified using Event-B theories. Classes {{are linked to}} <b>data</b> <b>types,</b> while attributes and associations correspond to operators of the <b>data</b> <b>types.</b> Axioms about the <b>data</b> <b>types</b> and operators are specified as constraints on the class. We illustrate our approach on a development of a control system in the railway domain...|$|R
5000|$|... {{introduced}} extended algebraic <b>data</b> <b>types</b> which combine GADTs {{together with}} the existential <b>data</b> <b>types</b> and type class constraints introduced by , [...] and [...]|$|R
5000|$|A {{sub-region}} of a dataset can {{be extracted}} by cutting or clipping with an arbitrary plane (all <b>data</b> <b>types),</b> specifying a threshold criteria to exclude cells (all <b>data</b> <b>types)</b> and/or specifying a VOI (volume of interest - structured <b>data</b> <b>types</b> only).|$|R
25|$|Create {{functions}} {{that use the}} <b>data</b> <b>type,</b> and compose them together into actions, following the rules defined in the first step.|$|E
25|$|In these {{equations}} x'ij and x'kj are {{the number}} of times the jth <b>data</b> <b>type</b> appears in the ith or kth sample respectively.|$|E
25|$|Consider {{the option}} type Maybe t, {{representing}} a value that {{is either a}} single value of type t, or no value at all. To distinguish these, there are two algebraic <b>data</b> <b>type</b> constructors: Just t, containing the value t, or Nothing, containing no value.|$|E
40|$|This paper explores a {{mechanism}} to support user-defined <b>data</b> <b>types</b> for columns in a relational data base system. Previous work suggested how to support new operators and new <b>data</b> <b>types.</b> The contribution of this work is to suggest ways to allow query optimization on commands which include new <b>data</b> <b>types</b> and operators and ways to allow access methods {{to be used for}} new <b>data</b> <b>types.</b> 1...|$|R
30|$|It must be {{possible}} to reference data by other electronic contracting elements. It is essential for safeguarding that <b>data</b> have specific <b>types</b> to allow for assured contract processing. <b>Data</b> <b>types</b> set basic constraints on the allowed values for a data element. Two classes of required <b>data</b> <b>types</b> we identify, namely standard- and special <b>data</b> <b>types.</b> The identified <b>data</b> <b>types</b> we adopt from ECML and in [44] further details and examples can be found.|$|R
40|$|The {{concept of}} dynamic {{abstract}} <b>data</b> <b>types</b> was recently proposed {{by two of}} the authors as a dynamic extension of the well-known concept of abstract <b>data</b> <b>types,</b> motivated by several recent approaches in the area of algebraic specifications, object orientation, evolving algebras, and graph transformations. The basic idea of dynamic abstract <b>data</b> <b>types</b> is to extend abstract <b>data</b> <b>types</b> by dynamic operations which are tranformations between abstract <b>data</b> <b>types.</b> In this paper we consider a specific kind of dynamic abstract <b>data</b> <b>types</b> where the transformations are defined by rules in the sense of algebraic graph transformations. The concept of attributed graph transformations is used to define this new version of dynamic abstract <b>data</b> <b>types</b> and to show some important properties of the corresponding transition category. The constructions are illustrated by a small example from the area of data bases...|$|R
25|$|A type {{constructor}} that defines, {{for every}} underlying type, how {{to obtain a}} corresponding monadic type. In Haskell's notation, {{the name of the}} monad represents the type constructor. If M {{is the name of the}} monad and t is a <b>data</b> <b>type,</b> then Mnbsp&t is the corresponding type in the monad.|$|E
25|$|In PHP, {{the triple}} equals sign (===) denotes value and type equality, meaning {{that not only}} do the two {{expressions}} evaluate to equal values, they are also of the same <b>data</b> <b>type.</b> For instance, the expression 0==false is true, but 0===false is not, because the number 0 is an integer value whereas false is a Boolean value.|$|E
25|$|For example, the C {{standard}} library defines sine functions within math.h: sin(double), sinf(float), and sinl(long double). The parameter of each is {{a floating}} point value, specifying the angle in radians. Each function returns the same <b>data</b> <b>type</b> as it accepts. Many other trigonometric functions are also defined in math.h, such as for cosine, arc sine, and hyperbolic sine (sinh).|$|E
50|$|The table below {{lists the}} {{mappings}} of XML Schema (XSD) <b>data</b> <b>types</b> to Java <b>data</b> <b>types</b> in JAXB.|$|R
40|$|AbstractEquational {{presentation}} of abstract <b>data</b> <b>types</b> is generalized to presentation by multiequations, i. e., exclusive-or's of equations, {{in order to}} capture parametric <b>data</b> <b>types</b> such as array or set. Multiinitial-algebra semantics for such <b>data</b> <b>types</b> is introduced. Classes of algebras described by multiequations are characterized...|$|R
5000|$|Tuples: Tuples are {{containers}} for a fixed number of Erlang <b>data</b> <b>types.</b> The syntax [...] denotes a tuple whose arguments are [...] The arguments can be primitive <b>data</b> <b>types</b> or compound <b>data</b> <b>types.</b> Any {{element of a}} tuple can be accessed in constant time.|$|R
