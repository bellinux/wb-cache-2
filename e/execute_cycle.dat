1|173|Public
50|$|Step 4 of the Instruction Cycle is the <b>Execute</b> <b>Cycle.</b> Here, the {{function}} of the instruction is performed. If the instruction involves arithmetic or logic, the Arithmetic Logic Unit is utilized. This is the only stage of the instruction cycle that is useful {{from the perspective of the}} end user. Everything else is overhead required to make the execute phase happen.|$|E
5000|$|It {{is highly}} efficient. As the figure {{demonstrates}} {{the number of}} peptides formed in the synthetic process (3, 9, 27, 81) increases exponentially {{with the number of}} <b>executed</b> <b>cycles.</b> Using 20 amino acids in each synthetic cycle the number of formed peptides are: 400, 8,000, 160,000 and 3,200,000, respectively. This means that the number of peptides increases exponentially with the number of the <b>executed</b> <b>cycles.</b>|$|R
40|$|Bitslice is a non-conventional way to {{implement}} algorithms using a scalar processor as a {SIMD}. It involves {{breaking down the}} algorithm into logical bit operations so that N parallel <operations are possible on a single N-bit microprocessor. It is applied to encryption algorithms, processing N consecutive blocks simultaneously, to achieve high throughput. Security applications using the {KeeLoq} algorithm are not suitable to traditional bitslice implementations because usually there are no N blocks to be processed. We propose a {KeeLoq} bitslice implementation, derived from its Algebraic Normal Form, for a single input block as a countermeasure against side-channel attacks. Our experimental results show there is no timing information leaked with an improvement factor of 3. 01 in <b>executed</b> <b>cycles.</b> However, the implementation is still vulnerable to differential side-channel analysis, so we propose a secured variation that increases the resistance against differential power analysis without timing leakage, with a lower improvement factor of 1. 21 in <b>executed</b> <b>cycles...</b>|$|R
40|$|The Very Simple CPU Simulator is an {{instructional}} aid for students studying computer architecture and CPU design, typically {{at the junior}} or senior level. It simulates a 4 -instruction CPU introduced in the textbook Computer Systems Organization and Architecture. Students first enter an assembly language program, which is assembled by the simulator. After correcting any syntax errors, the user simulates the fetch, decode, and <b>execute</b> <b>cycles</b> of each instruction. The simulato...|$|R
5000|$|... #Subtitle level 3: Operating Framework for <b>Executing</b> the Intelligence <b>Cycle</b> ...|$|R
5000|$|Single byte {{register}} R0 instructions <b>execute</b> faster (one <b>cycle</b> {{rather than}} two).|$|R
50|$|In {{automation}} production technology {{the actions}} performed by an automated process are executed by {{a program of}} instructions which is run during a work <b>cycle.</b> To <b>execute</b> work <b>cycle</b> programs, an automated system {{should be available to}} execute these advanced functions.|$|R
50|$|A {{fundamental}} {{principle of the}} scientific method and PDCA is iteration—once a hypothesis is confirmed (or negated), <b>executing</b> the <b>cycle</b> again will extend the knowledge further. Repeating the PDCA cycle can bring us closer to the goal, usually a perfect operation and output.|$|R
50|$|These two VLIW {{molecules}} {{could potentially}} <b>execute</b> in fewer <b>cycles</b> {{than the original}} instructions could on an x86 processor.|$|R
5000|$|The works {{dates to}} Carpaccio's mature period, {{when he was}} called by the [...] "scuola" [...] (guild or corporation) of the Schiavoni (Dalmatians) to <b>execute</b> a <b>cycle</b> of nine {{paintings}} on the stories of patron saints (George, Jerome and Tryphon) and evangelic episodes. The work began in 1502 and was completed in 1507.|$|R
40|$|In this paper, {{we present}} the {{analysis}} of applications from the domain of handheld and wearable computing. This analysis {{is the first step}} to derive and evaluate design parameters for dynamically reconfigurable processors. We discuss the selection of representative benchmarks for handhelds and wearables and group the applications into multimedia, communications, and cryptography programs. We simulate the applications on a cycle-accurate processor simulator and gather statistical data such as instruction mix, cache hit rates and memory requirements for an embedded processor model. A breakdown of the <b>executed</b> <b>cycles</b> into di#erent functions identifies the most compute-intensive code sections [...] the kernels. Then, we analyze the applications and discuss parameters that strongly influence the design of dynamically reconfigurable processors. Finally, we outline the construction of a parameterizable simulation model for a reconfigurable unit that is attached to a processor core...|$|R
40|$|These prior DNA nanomechanical {{devices have}} some key {{restrictions}} that restrict their usefulness: (a) {{they can only}} execute one type of motion (rotational or translational). It seems feasible to re-design these DNA nanomechanical devices to have both translational and rotational motion, but this {{still needs to be}} done (experimentally tested). (b) More importantly, these prior DNA devices do not run autonomously: to make repeated motions they either require environmental changes such as temperature cycling, or bead treatment of biotin-streptavidin beads, or require feeding more or different fuel strands to cycle the device. The technical challenge. A key challenge, which we address in this paper, is to make an autonomous DNA nanomechanical device that <b>executes</b> <b>cycles</b> of motion (either rotational or translational or both) without external environmental changes. Our results. We provide designs for two autonomous DNA nanomechanica...|$|R
40|$|Microprocessors {{typically}} have software readable counters for {{events such as}} instructions <b>executed,</b> <b>cycles,</b> instruction stalls, and cache misses. Besides their usefulness to count overall performance metrics, these counters {{can be used to}} reveal details about dynamic process behavior and hardware effects of compiler optimizations, but interference between probe code and code under test makes it difficult to interpret the counts accurately for pure application code. In this paper the problems to reduce instrumentation perturbations, to model and correct for them and then quantify the remaining uncertainties are addressed for the Pentium II. After having eliminated most operating system and interrupt interference by embedding benchmarks into Linux kernel modules, we introduce the "null instrumentation" strategy in which code under test is displaced but not removed. We report as remaining uncertainty levels the differences between results of "full" (detailed) instrumentation and 1 result [...] ...|$|R
40|$|This paper {{presents}} a technique for eliminating redundant cache-tag and cache-way accesses to reduce power consumption. The basic {{idea is to}} keep {{a small number of}} Most Recently Used (MRU) addresses in a Memory Address Buffer (MAB) and to omit redundant tag and way accesses when there is a MAB-hit. Since the approach keeps only tag and set-index values in the MAB, the energy and area overheads are relatively small even for a MAB with a large number of entries. Furthermore, the approach does not sacrifice the performance. In other words, neither the cycle time nor the number of <b>executed</b> <b>cycles</b> increases. The proposed technique has been applied to Fujitsu VLIW processor (FR-V) and its power saving has been estimated using NanoSim. Experiments for 32 kB 2 -way set associative caches show the power consumption of I-cache and D-cache can be reduced by 40 % and 50 %, respectively. ...|$|R
40|$|Abstract: In this paper, {{we present}} an interprocessor communication-aware task {{scheduling}} algorithm applicable to a multiprocessor system executing an application with dependent tasks. Our algorithm takes the application task graph and the architecture graph as inputs, assigns the tasks to processors and then schedules them. As main theoretical contribution, the algorithm we propose reduces the overall systems energy by (i) reducing the total interprocessor communication and (ii) <b>executing</b> certain <b>cycles</b> {{at a lower}} voltage level. Experimental results show that by tuning the parameter for communication awareness, a schedule using our algorithm can reduce upto 80 % interprocessor communication in a complex video/audio application (compared to a schedule which is only voltage-selection aware) without losing much {{in the number of}} <b>cycles</b> <b>executed</b> at lower voltage...|$|R
40|$|A {{practical}} implementation of high performance instruction level parallel architectures is {{constrained by the}} difficulty to build a large monolithic multi-ported register file (RF). A solution is to partition the RF into smaller RFs while keeping {{the total number of}} registers and ports equal. This paper applies RF partitioning to transport triggered architectures; these architectures are of the VLIW type. One may expect that partitioning increases the number of <b>executed</b> <b>cycles</b> because it constrains the number of ports per RF. It is shown that these performance losses are small; e. g. partitioning an RF with 24 registers and four read and four write ports into four RFs with 6 registers and one read and one write port gives a performance loss of only 5. 8 %. Partitioned RFs consume less area than monolithic RFs with the same number of ports and registers. Experiments show that, if the area saved by partitioning is spent on extra registers, partitioning does, on average, not reduce the perfo [...] ...|$|R
40|$|Submitted {{on behalf}} of EDAA ([URL] audienceThis paper {{presents}} a technique for eliminating redundant cache-tag and cache-way accesses to reduce power consumption. The basic idea is to keep {{a small number of}} Most Recently Used (MRU) addresses in a Memory Address Buffer (MAB) and to omit redundant tag and way accesses when there is a MAB-hit. Since the approach keeps only tag and set-index values in the MAB, the energy and area overheads are relatively small even for a MAB with a large number of entries. Furthermore, the approach does not sacrifice the performance. In other words, neither the cycle time nor the number of <b>executed</b> <b>cycles</b> increases. The proposed technique has been applied to Fujitsu VLIW processor (FR-V) and its power saving has been estimated using NanoSim. Experiments for 32 kB 2 -way set associative caches show the power consumption of I-cache and D-cache can be reduced by 40 % and 50 %, respectively...|$|R
5000|$|The Amber 25 has a 5-stage pipeline, {{separate}} {{data and}} instruction caches, a Wishbone interface, and {{is capable of}} 1.0 DMIPS per MHz. The Amber 25 core provides 30 to 40% better performance than the Amber 23 core and is 30 to 40% larger. Register-based instructions <b>execute</b> in one <b>cycle,</b> except for instructions involving multiplication, or complex shift operations. Load and store instructions also <b>execute</b> in one <b>cycle</b> {{unless there is a}} register conflict with a following instruction. The core's pipeline is stalled when a cache miss occurs in either cache, when an instruction conflict is detected, when a complex shift is executed, or when the core performs a Wishbone access.|$|R
50|$|For performance-critical {{systems that}} spend most CPU <b>cycles</b> <b>executing</b> a {{specific}} section of code, a user-defined peripheral can potentially offload part {{or all of}} the execution of a software-algorithm to user-defined hardware logic, improving power-efficiency or application throughput.|$|R
50|$|Compared to the ARM11 core, the Cortex-A8 is a dual-issue superscalar design, {{achieving}} roughly {{twice the}} instructions <b>executed</b> per clock <b>cycle.</b> The Cortex-A8 {{was the first}} Cortex design to be adopted {{on a large scale}} for use in consumer devices.|$|R
40|$|Wide-VDD-range {{processors}} offer {{high energy}} efficiency for varying embedded workloads. But reducing the VDD of the cache as aggressively as the VDD of the CPU logic is not straightforward, since standard 6 T SRAMs cease to operate at lower VDDs. We implement a data and instruction filter cache, using logic cells located in the CPU VDD domain, to permit the level- 1 (L 1) cache to be reliably powered at a higher SRAM VDD. On top of eliminating many energy-wasting L 1 cache accesses, the filter cache reduces {{the total number of}} <b>executed</b> <b>cycles.</b> Furthermore, the filter cache can be reconfigured as CPU VDD is reduced, to filter out an increasing proportion of cache accesses. We evaluate our approach using a 65 -nm 1. 2 -V low-leakage CMOS process, with a minimal CPU and SRAM VDD of 0. 4 and 0. 95 V, respectively. Assuming 16 kB+ 16 kB L 1 caches and 256 B+ 256 B filter caches, introducing the filter cache reduces the total cache access energy by 71 % at 1. 2 V and 87 % at 0. 4 V at an area overhead which is 13 % of the L 1 cache area...|$|R
40|$|This paper {{addresses}} {{the problem of}} Uniform Circle Formation by n > 1 transparent disc robots (fat robots). The robots <b>execute</b> repetitive <b>cycles</b> of the states look-compute-move in semi-synchronous manner where a set of robots <b>execute</b> the <b>cycle</b> simultaneously. They do not communicate by any explicit message passing. However, they can sense or observes the positions of other robots around themselves through sensors or camera. The robots are unable to recover the past actions and observations. They have no unique identity. The robots {{do not have any}} global coordinate system. They agree upon only y-axis (South and North direction). However, they do not have chirality or common orientation of Y axis with respect to X axis. Being transparent the robots do not cause any visual obstructions for other robots. But, they act as physical obstacles for other robots. This paper proposes a collision free movement strategy for the robots to form a uniform circle (in other words convex regular polygon) executing finite number of cycles. To {{the best of our knowledge}} this is the first reported results on uniform circle formation for fat robots under the considered model...|$|R
5000|$|During the 1870s through 1890s, the {{mechanically}} automated [...] "automatic" [...] {{turret lathe}} {{was developed and}} disseminated. These machines can <b>execute</b> many part-cutting <b>cycles</b> without human intervention. Thus {{the duties of the}} operator, which were already greatly reduced by the manual turret lathe, were even further reduced, and productivity increased. These machines use cams to automate the sliding and indexing of the turret and the opening and closing of the chuck. Thus, they <b>execute</b> the part-cutting <b>cycle</b> somewhat analogously {{to the way in which}} an elaborate cuckoo clock performs an automated theater show. Small- to medium-sized automatic turret lathes are usually called [...] "screw machines" [...] or [...] "automatic screw machines", while larger ones are usually called [...] "automatic chucking lathes", [...] "automatic chuckers", or [...] "chuckers".|$|R
5000|$|The latest MIPS {{architecture}} designs {{include an}} SMT system known as [...] "MIPS MT". MIPS MT provides for both heavyweight virtual processing elements and lighter-weight hardware microthreads. RMI, a Cupertino-based startup, {{is the first}} MIPS vendor to provide a processor SOC based on eight cores, each of which runs four threads. The threads can be run in fine-grain mode where a different thread can be <b>executed</b> each <b>cycle.</b> The threads can also be assigned priorities. Imagination Technologies MIPS CPUs have two SMT threads per core.|$|R
5000|$|... 8. Cybo-Soderini ChapelThe Chapel of the Crucifixion or the Cybo-Soderini Chapel was remodelled in the Baroque {{era when}} a Flemish artist, Pieter van Lint <b>executed</b> its <b>cycle</b> of frescos on the vault and the lunettes which depict Angels with the Symbols of the Passion and Prophets. Two big frescos {{on the side}} walls show scenes from The Legend of the True Cross. There is a 15th-century wooden {{crucifix}} above the main altar in a Corinthian aedicule. The chapel was restored by Lorenzo Soderini in 1825.|$|R
40|$|We provide {{designs for}} the first {{autonomous}} DNA nanomechanical devices that <b>execute</b> <b>cycles</b> of motion without external environmental changes. These DNA devices translate along a circular strand of ssDNA and rotate simultaneously. The designs use various energy sources to fuel the movements, include (i) ATP consumption by DNA ligase in conjunction with restriction enzyme operations, (ii) DNA hybridization energy in trapped states, and (iii) kinetic (heat) energy. We show {{that each of these}} energy sources can be used to fuel random bidirectional movements that acquire after n steps an expected translational deviation of O(# n). For the devices using the first two fuel sources, the rate of stepping is accelerated over the rate of random drift due to kinetic (heat) energy. Our first DNA device, which we call walking DNA, achieves random bidirectional motion around a circular ssDNA strand by use of DNA ligase and two restriction enzymes. Our other DNA device, which we call rolling DNA, achieves random bidirectional motion without use of DNA ligase or any restriction enzyme, and instead using hybridization energy. We also describe how to modify the design for the rolling DNA device to include a "latching mechanism" that fixes the wheels position at specified location along the road, so as to provide for overall unidirectional translational movement...|$|R
40|$|In situ {{high-resolution}} neutron powder diffraction {{along with}} electrochemical analysis {{was applied to}} study fatigue processes in commercial LiCoO 2 (18650 -type, 2600 mAh, 3. 0 – 4. 2 V) cells. The Rietveld refinement technique was successfully applied for structural characterization of the cell materials as function of fatigue introduced. The capacity loss determined from the electrochemical investigation has been found proportional {{to the number of}} cycles, which the cell underwent, and was 21. 9 % and 12. 8 % for the cell cycled for 1000 times at 25 ◦C and 50 ◦C, respectively. This capacity fade has a close correlation to the structural changes in cathode and anode materials with the cell fatigue. A change of the lithium occupation and lattice parameters of the LixCoO 2 were observed with proceeding battery fatigue. Transformation of the graphitic anode into LiC 6 and LiC 12 was identified after the batteries were fully charged. Their weight ratio was found to be dependent on the number of <b>executed</b> <b>cycles.</b> It was concluded that loss of the active lithium in both cathode and anode as well as microstructure changes on the anode side are important factors for the battery degradation. A favorable influence of the elevated cycling temperature on the battery performance was observed...|$|R
40|$|Conventional {{synthesis}} algorithms schedule {{multiple precision}} specifications by balancing {{the number of}} operations of every different type and width <b>executed</b> per <b>cycle.</b> However, totally balanced schedules are not always possible and therefore some hardware waste appears. In this paper a heuristic scheduling algorithm to minimize this hardware waste is presented. It successively transforms specification operations into sets of smaller ones until the most uniform distribution of the computational effort of operations among cycles is reached. In the schedules proposed some operations are executed during a set of non- consecutive cycles. 1...|$|R
40|$|Register {{renaming}} is {{a technique}} to remove false data dependencies—write after read (WAR) and write after write (WAW) — that occur in straight line code between register operands of subsequent instructions. 1 - 3 By eliminating related precedence requirements in the execution sequence of the instructions, renaming increases {{the average number of}} instructions that are available for parallel execution per cycle. This results in increased IPC (number of instructions <b>executed</b> per <b>cycle).</b> The identification and exploration of the design space of register-renaming lead to a comprehensive understanding of this intricate technique...|$|R
40|$|The {{method of}} Kryloff and Bogoliuboff {{is used to}} {{investigate}} the non-linear oscillation of a system incorporating a Hooke’s joint. It is found that the system ultimately <b>executes</b> a limit <b>cycle</b> of oscillation and that, in certain critical speed ranges, the amplitude of this oscillation is large if the system is lightly damped...|$|R
40|$|The {{original}} publication can {{be found}} at www. springerlink. comValue speculation is currently widely used in processor designs to increase the overall number of instructions <b>executed</b> per <b>cycle</b> (IPC). Current methods use sophisticated prediction techniques to speculate on the outcome of branches and execute code accordingly. Speculation can be extended to the approximation of arithmetic values. As arithmetic operations are slow to complete in pipelined execution an increase in overall IPC is possible through accurate arithmetic data value speculation. This paper will focus on integer adder units for the purposes of demonstrating arithmetic data value speculation...|$|R
50|$|The {{work of the}} Sanmicheli {{corresponding}} to the base level was the most refined of the façade, and was accomplished by the year 1500. Meanwhile, the religious building underwent rapid development, thanks to {{the growing number of}} worshippers and their alms, and was expanded to its current size. The architectural scores in the interior, characterized by decorative characters are attributed to Gasparo Cairano and his studio. The same sculptor also <b>executed</b> the <b>cycle</b> of the Apostles for the first dome, interspersed with the cycle of Angels by Tamagnino, all of which were delivered and paid for in 1489.|$|R
40|$|A Robot Scientist is a {{physically}} implemented system that applies artificial intelligence to autonomously discover new knowledge through cycles of scientific experimentation. Additionally, our Robot Scientist {{is able to}} execute experiments that have been requested by human biologists. There arises a multi-objective problem {{in the selection of}} batches of trials to be run together on the robot hardware. We describe the use of the jMetal framework to assess the suitability of a number of multi-objective metaheuristics to optimise the flow of experiments run on a Robot Scientist. Experiments are selected in batches, chosen in order to maximise the information gain and minimise the use of resources. The evolutionary multi-objective algorithms evaluated here perform well in finding solutions to this problem, either finding a long, fairly efficient Pareto optimal front, or a shorter, highly efficient Pareto optimal front. recently built Robot Scientist 1 {{is one of the most}} advanced laboratory automation systems in existence. The advances that distinguish our Robot Scientist are its AI software, the design of the hardware and the complete autonomy of the knowledge discovery process [3]. A Robot Scientist has hardware that permits it to carry out experiments (see Figure 1). These experiments may have been devised by the Robot Scientist itself or they may have been requested by human biologists. For details of how our Robot Scientist autonomously devises and <b>executes</b> <b>cycles</b> of scientific discovery, see Section 2...|$|R
50|$|A {{representative}} {{example is}} a do loop incrementing some counter until it overflows and becomes 0 again.Although the do loop executes the same increment command iteratively, so the program graph <b>executes</b> a <b>cycle,</b> in its state space is not a cycle, but a line.This results from the state being the program location (here cycling) combined with the counter value, which is strictly increasing (until the overflow), so different states are visited in sequence, until the overflow.After the overflow the counter becomes 0 again, so the initial state is revisited in the state space, closing a cycle in the state space (assuming the counter was initialized to 0).|$|R
50|$|Furthermore, modern CPUs have {{instruction}} pipelines that queue {{instructions for}} execution. A processor with multiple execution units can perform {{more than one}} instruction per cycle if more than one instruction {{is available in the}} pipeline. Branching (the use of conditionals like if) makes it harder for the processor to fill its pipeline(s) because the CPU cannot tell what it needs to do in advance. Too much branching makes the pipeline less effective and potentially reduces the number of instructions the processor can <b>execute</b> per <b>cycle.</b> Many bitboard operations require fewer conditionals and therefore increase pipelining and make effective use of multiple execution units on many CPUs.|$|R
40|$|One of {{the main}} {{concerns}} in today’s processor design is the issue logic. Instruction-level parallelism is usually favored by an out-of-order issue mechanism where instructions can issue independently of the program order. The out-of-order scheme yields the best performance {{but at the same}} time introduces important hardware costs such as an associative look-up, which might be prohibitive for wide issue processors with large instruction windows. This associative search may slow-down the clock-rate and it has an important impact on power consumption. In this work, two new issue schemes that reduce the hardware complexity of the issue logic with minimal impact on the average number of instructions <b>executed</b> per <b>cycle</b> are presented...|$|R
