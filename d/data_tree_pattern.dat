0|3853|Public
40|$|Abstract. We {{consider}} Boolean {{combinations of}} <b>data</b> <b>tree</b> <b>patterns</b> as a specification and query language for XML documents. <b>Data</b> <b>tree</b> <b>patterns</b> are <b>tree</b> <b>patterns</b> plus variable (in) equalities which express joins between attribute values. <b>Data</b> <b>tree</b> <b>patterns</b> are {{a simple and}} natural formalism for expressing properties of XML documents. We consider first the model checking problem (query evaluation), we show that it is DP-complete 1 in general and already NP-complete when we consider a single pattern. We then consider the satisfiability problem {{in the presence of}} a DTD. We show that it is in general undecidable and we identify several decidable fragments. ...|$|R
40|$|<b>Tree</b> <b>patterns</b> {{are one of}} {{the main}} abstractions used to access XML <b>data.</b> <b>Tree</b> <b>patterns</b> are used, for instance, to define XML indexes, and support a number of {{efficient}} evaluation algorithms. Unfortunately deciding whether a particular query, or query fragment, is a <b>tree</b> <b>pattern</b> is undecidable for most XML Query languages. In this paper, we identify a subset of XQuery for which the problem is decidable. We then develop a sound and complete algorithm to recognize the corresponding <b>tree</b> <b>patterns</b> for that XQuery subset. The algorithm relies on a normal form along with a set of rewriting rules that we show to be strongly normalizing. The rules have been implemented and result in a normal form which is suitable for compiling <b>tree</b> <b>patterns</b> into an appropriate XML algebra. 1...|$|R
40|$|Abstract—Two {{things are}} {{important}} in developing a fast, memory-efficient graph mining method that extracts characteristic graph structures from Web pages and other tree-structured <b>data.</b> One is <b>tree</b> <b>patterns</b> that can express the features of a graph structure {{and the other is}} <b>data</b> structures for <b>tree</b> <b>patterns</b> and for representing tree-structured data. In this paper, we first apply a depth-first unary degree sequence (DFUDS), which is one succinct data structure for an ordered tree, as a succinct <b>data</b> structure for <b>tree</b> <b>patterns</b> that express the features of a graph structure. We then propose a pattern matching algorithm that uses the DFUDS succinct data structure, {{to determine whether or not}} a given tree-structured data has features of <b>tree</b> <b>pattern.</b> We also implement the proposed algorithm on a computer and evaluate the algorithm by experiment. The results are reported and discussed. Index Terms—pattern matching algorithm, succinct representation, tree-structured data, edge-labeled ordered term tree...|$|R
30|$|We {{define the}} problem of extracting {{homomorphic}} and maximal homomorphic unordered <b>tree</b> <b>patterns</b> with descendant relationships from a single large <b>data</b> <b>tree.</b> This problem departs from previous ones which focus on mining-induced or embedded <b>tree</b> <b>patterns</b> from a set of small <b>data</b> <b>trees.</b>|$|R
40|$|Abstract. Information Extraction from semistructured data {{becomes more}} and more important. In order to extract {{meaningful}} or interesting contents from semistructured data, we need to extract common struc-tured patterns from semistructured data. Many semistructured data have irregularities such as missing or erroneous <b>data.</b> A tag <b>tree</b> <b>pattern</b> is an edge labeled tree with ordered children which has tree structures of tags and structured variables. An edge label is a tag, a keyword or a wild-card, and a variable can be substituted by an arbitrary tree. Especially, a contractible variable matches any subtree including a singleton vertex. So a tag <b>tree</b> <b>pattern</b> is suited for representing common <b>tree</b> structured <b>patterns</b> in irregular semistructured data. We present a new method for extracting characteristic tag <b>tree</b> <b>patterns</b> from irregular semistruc-tured data by using an algorithm for finding a least generalized tag <b>tree</b> <b>pattern</b> explaining given <b>data.</b> We report some experiments of applying this method to extracting characteristic tag <b>tree</b> <b>patterns</b> from irregular semistructured data. ...|$|R
40|$|Advances in Knowledge Discovery and Data Mining: 7 th Pacific-Asia Conference, PAKDD 2003, Seoul, Korea, April 30 - May 2, 2003. ProceedingsInformation Extraction from semistructured data {{becomes more}} and more important. In order to extract {{meaningful}} or interesting contents from semistructured data, we need to extract common structured patterns from semistructured data. Many semistructured data have irregularities such as missing or erroneous <b>data.</b> A tag <b>tree</b> <b>pattern</b> is an edge labeled tree with ordered children which has tree structures of tags and structured variables. An edge label is a tag, a keyword or a wildcard, and a variable can be substituted by an arbitrary tree. Especially, a contractible variable matches any subtree including a singleton vertex. So a tag <b>tree</b> <b>pattern</b> is suited for representing common <b>tree</b> structured <b>patterns</b> in irregular semistructured data. We present a new method for extracting characteristic tag <b>tree</b> <b>patterns</b> from irregular semistructured data by using an algorithm for finding a least generalized tag <b>tree</b> <b>pattern</b> explaining given <b>data.</b> We report some experiments of applying this method to extracting characteristic tag <b>tree</b> <b>patterns</b> from irregular semistructured data...|$|R
40|$|Abstract: Problem statement: This study {{introduced}} {{an application of}} <b>pattern</b> <b>tree</b> based classification technique {{in the area of}} object-oriented software quality estimation. This application explored the fault prediction accuracy of <b>pattern</b> <b>trees.</b> Approach: Similarity measures and fuzzy aggregations employed in the <b>pattern</b> <b>tree</b> technique had been used to generate tree models for fault detection in software modules. Experiments had been performed on datasets namely, KC 1 and KC 3 obtained from NASA’s metric <b>data</b> program. <b>Pattern</b> <b>tree</b> models were built using metrics from the object-oriented software datasets. Results: AND/OR, OWA and WA had been selected for <b>pattern</b> <b>tree</b> induction. <b>Pattern</b> <b>tree</b> models build using RMSE similarity measure produced higher accuracy as compared to other similarity measures. Conclusion: The proposed application succeeded in improving the quality of the object-oriented software in terms of prediction accuracy. <b>Pattern</b> <b>trees</b> models were found to be less structural complex as compared to fuzzy decision <b>trees.</b> Key words: <b>Pattern</b> <b>trees,</b> object-oriented software, fault prediction accuracy, quality estimatio...|$|R
40|$|Problem statement: This study {{introduced}} {{an application of}} <b>pattern</b> <b>tree</b> based classification technique {{in the area of}} object-oriented software quality estimation. This application explored the fault prediction accuracy of <b>pattern</b> <b>trees.</b> Approach: Similarity measures and fuzzy aggregations employed in the <b>pattern</b> <b>tree</b> technique had been used to generate tree models for fault detection in software modules. Experiments had been performed on datasets namely, KC 1 and KC 3 obtained from NASA's metric <b>data</b> program. <b>Pattern</b> <b>tree</b> models were built using metrics from the object-oriented software datasets. Results: AND/OR, OWA and WA had been selected for <b>pattern</b> <b>tree</b> induction. <b>Pattern</b> <b>tree</b> models build using RMSE similarity measure produced higher accuracy as compared to other similarity measures. Conclusion: The proposed application succeeded in improving the quality of the object-oriented software in terms of prediction accuracy. <b>Pattern</b> <b>trees</b> models were found to be less structural complex as compared to fuzzy decision trees...|$|R
40|$|With XML {{becoming}} an ubiquitous language for data interoperability purposes in various domains, efficiently querying XML data {{is a critical}} issue. This has lead {{to the design of}} algebraic frameworks based on tree-shaped patterns akin to the tree-structured data model of XML. <b>Tree</b> <b>patterns</b> are graphic representations of queries over <b>data</b> <b>trees.</b> They are actually matched against an input <b>data</b> <b>tree</b> to answer a query. Since the turn of the twenty-first century, an astounding research effort has been focusing on <b>tree</b> <b>pattern</b> models and matching optimization (a primordial issue). This paper is a comprehensive survey of these topics, in which we outline and compare the various features of <b>tree</b> <b>patterns.</b> We also review and discuss the two main families of approaches for optimizing <b>tree</b> <b>pattern</b> matching, namely <b>pattern</b> <b>tree</b> minimization and holistic matching. We finally present actual tree pattern-based developments, to provide a global overview of this significant research topic...|$|R
40|$|Abstract. <b>Tree</b> <b>pattern</b> {{matching}} is {{a fundamental}} problem that has {{a wide range of}} applications in Web data management, XML processing, and selective data dissemination. In this paper we develop efficient algorithms for the tree homeomorphism problem, i. e., the problem of matching a <b>tree</b> <b>pattern</b> with exclusively transitive (descendant) edges. We first prove that deciding whether there is a tree homeomorphism is LOGSPACE-complete, improving on the current LOGCFL upper bound. As our main result we develop a practical algorithm for the tree homeomorphism decision problem that is both space- and time efficient. The algorithm is in LOGDCFL and space consumption is strongly bounded, while the running time is linear {{in the size of the}} <b>data</b> <b>tree.</b> This algorithm immediately generalizes to the problem of matching the <b>tree</b> <b>pattern</b> against all subtrees of the <b>data</b> <b>tree,</b> preserving the mentioned efficiency properties. ...|$|R
40|$|<b>Tree</b> <b>pattern</b> {{matching}} is {{a fundamental}} problem that has {{a wide range of}} applications in Web data management, XML processing, and selective data dissemination. In this paper we develop efficient algorithms for the tree homeomorphism problem, i. e., the problem of matching a <b>tree</b> <b>pattern</b> with exclusively transitive (descendant) edges. We first prove that deciding whether there is a tree homeomorphism is LOGSPACE-complete, improving on the current LOGCFL upper bound. Furthermore, we develop a practical algorithm for the tree homeomorphism decision problem that is both space- and time efficient. The algorithm is in LOGDCFL and space consumption is strongly bounded, while the running time is linear {{in the size of the}} <b>data</b> <b>tree.</b> This algorithm immediately generalizes to the problem of matching the <b>tree</b> <b>pattern</b> against all subtrees of the <b>data</b> <b>tree,</b> preserving the mentioned efficiency properties...|$|R
30|$|We run {{extensive}} {{experiments to}} evaluate the performance and scalability of our approach on real datasets. The experimental results show that: (a) The mined maximal homomorphic <b>tree</b> <b>patterns</b> are larger on the average than maximal embedded <b>tree</b> <b>patterns</b> on the same datasets, (b) our approach mines homomorphic maximal patterns up to several orders of magnitude faster than state-of-the-art algorithms mining embedded <b>tree</b> <b>patterns</b> when applied to a large <b>data</b> <b>tree,</b> (c) our algorithm consumes {{only a small fraction}} of the memory space and scales smoothly when the size of the dataset increases, and(d) the optimization technique substantially improves the time performance of the algorithm.|$|R
30|$|Figure 1 a shows four <b>data</b> <b>trees</b> {{corresponding}} to different schemas {{to be integrated}} through the mining of large <b>tree</b> <b>patterns.</b> The frequency threshold is set to three. Figure  1 b shows induced mined <b>tree</b> <b>patterns,</b> embedded patterns and non-redundant homomorphic patterns. Figure  1 b includes the largest patterns that can be mined in each category. As one can see, the shown embedded patterns are not induced patterns, and the shown homomorphic patterns are neither embedded nor induced patterns. Further, the homomorphic patterns are larger {{than all the other}} patterns.|$|R
40|$|The {{distribution}} of kangaroo mice, genus Microdipodops (Rodentia: Heteromyidae), is limited {{exclusively to the}} hydrographic Great Basin region of western North America (Hafner, 1978; 1993). The phylogeography of populations of the Dark Kangaroo Mouse, Microdipodops megacephalus, were examined within this region using mitochondrial DNA (mtDNA) sequence data. Polymerase chain reaction (PCR) was used to amplify the 16 S rRNA gene of which we analyzed a 550 bp fragment for 42 individuals from 19 separate localities. Two phylogenetic trees, neighbor-joining distance and strict consensus parsimony, were constructed using these <b>data.</b> Both <b>trees</b> depict <b>patterns</b> of relationship that suggest a strong east-west division within the {{distribution of}} M. megacephalus...|$|R
30|$|Even if {{homomorphic}} {{patterns are}} successfully constrained to be non-redundant, their number {{can be much}} larger than that of frequent embedded patterns from the same <b>data</b> <b>tree.</b> In order for the mining algorithm to be efficient, new, much faster techniques for computing {{the support of the}} candidate homomorphic <b>tree</b> <b>patterns</b> need to be devised.|$|R
3000|$|Support We adopt for {{the support}} of <b>tree</b> <b>patterns</b> root frequency: The support of a pattern P on a <b>data</b> <b>tree</b> T is the number of {{distinct}} images (nodes in T) of the root of P under all homomorphisms of P to T. In other words, the support of P on T is the size of the occurrence list of the root of P on T.|$|R
30|$|Extracting {{frequent}} <b>tree</b> <b>patterns</b> {{which are}} hidden in <b>data</b> <b>trees</b> is central for analyzing data {{and is a}} base step for other data mining processes including association rule mining, clustering and classification. Trees have emerged {{in recent years as}} the standard format for representing, exporting, exchanging and integrating data on the web (e.g., XML and JSON). <b>Tree</b> <b>data</b> are adopted in various application areas and systems such as business process management, NoSQL databases, key-value stores, scientific workflows, computational biology and genome analysis.|$|R
30|$|Therefore, homomorphisms and {{homomorphic}} patterns {{display a}} number of advantages. First, they allow the extraction of patterns that cannot be extracted by embedded patterns. Second, extracted homomorphic patterns can be larger than embedded patterns. Finally, homomorphisms can be computed more efficiently than embeddings. Indeed, the problem of checking {{the existence of a}} homomorphism of an unordered <b>tree</b> <b>pattern</b> to a <b>data</b> <b>tree</b> is polynomial [13], while the corresponding problem for an embedding is NP-complete [12].|$|R
40|$|We study static analysis, in {{particular}} the containment problem, for analogs of conjunctive queries over XML documents. The problem has been studied for queries based on arbitrary patterns, not necessarily following the tree structure of documents. However, many applications force the syntactic shape of queries to be tree-like, as {{they are based on}} proper <b>tree</b> <b>patterns.</b> This renders previous results, crucially based on having non-tree-like features, inapplicable. Thus, we investigate static analysis of queries based on proper <b>tree</b> <b>patterns.</b> We go beyond simple navigational conjunctive queries in two ways: we look at unions and Boolean combinations of such queries as well and, crucially, all our queries handle data stored in documents, i. e., we deal with containment over <b>data</b> <b>trees.</b> We start by giving a general Π...|$|R
30|$|Finding {{interesting}} <b>tree</b> <b>patterns</b> {{hidden in}} large datasets {{is a central}} topic in data mining with many practical applications. Unfortunately, previous contributions have focused almost exclusively on mining-induced patterns from a set of small trees. The problem of mining homomorphic patterns from a large <b>data</b> <b>tree</b> has been neglected. This is mainly due to the challenging unbounded redundancy that homomorphic <b>tree</b> <b>patterns</b> can display. However, mining homomorphic patterns allows for discovering large patterns which cannot be extracted when mining induced or embedded patterns. Large patterns better characterize big trees which are important for many modern applications in particular with the explosion of big data. In this paper, we {{address the problem of}} mining frequent homomorphic <b>tree</b> <b>patterns</b> from a single large tree. We propose a novel approach that extracts non-redundant maximal homomorphic patterns. Our approach employs an incremental frequency computation method that avoids the costly enumeration of all pattern matchings required by previous approaches. Matching information of already computed patterns is materialized as bitmaps, a technique that not only minimizes the memory consumption, but also the CPU time. Our contribution also includes an optimization technique which can further reduce the search space of homomorphic patterns. We conducted detailed experiments to test the performance and scalability of our approach. The experimental evaluation shows that our approach mines larger patterns and extracts maximal homomorphic patterns from real and synthetic datasets outperforming state-of-the-art embedded tree mining algorithms applied to a large <b>data</b> <b>tree.</b>|$|R
3000|$|A {{holistic}} twig-join approach In {{order to}} compute L_X, we exploit a holistic twig-join approach (e.g., TwigStack [4]), the state-of-the-art technique for evaluating <b>tree</b> <b>pattern</b> queries on <b>tree</b> <b>data.</b> Algorithm TwigStack works in two phases. In the first phase, it computes the matches {{of the individual}} root-to-leaf paths of the pattern. In the second phase, it merge-joins the path matches to compute {{the results for the}} pattern. TwigStack ensures that each solution to each individual query root-to-leaf path is guaranteed to be merge-joinable with at least one solution of each of the other root-to-leaf paths in the pattern. Therefore, the algorithm can guarantee worst-case performance linear {{to the size of the}} <b>data</b> <b>tree</b> inverted lists (the input) and the size of the pattern matches in the <b>data</b> <b>tree</b> (the output), i.e., the algorithm is optimal.|$|R
30|$|In this paper, we have {{addressed}} the problem of mining maximal frequent homomorphic <b>tree</b> <b>patterns</b> from a single large tree. We have provided a novel definition of maximal homomorphic patterns which takes into account homomorphisms, pattern specificity and the single tree setting. We have designed an efficient algorithm that discovers all frequent non-redundant maximal homomorphic <b>tree</b> <b>patterns.</b> Our approach employs an incremental stack-based frequency computation method that avoids the costly enumeration of all pattern occurrences required by previous approaches. An originality of our method is that matching information of already computed patterns is materialized as bitmaps, which greatly reduces both memory consumption and computation costs. An optimization technique further prunes the search space of candidate patterns. We have conducted extensive experiments to compare our approach with tree mining algorithms that mine embedded patterns when applied to a large <b>data</b> <b>tree.</b> Our results show that maximal homomorphic patterns are fewer and larger than maximal embedded <b>tree</b> <b>patterns.</b> Further, our algorithm is {{as fast as the}} state-of-the-art algorithm mining embedded trees from a single tree while outperforming it in terms of memory consumption and scalability.|$|R
3000|$|DryadeParent [18] mines closed induced {{patterns}} from a set {{of small}} trees. Observing that the performances of existing algorithms are dramatically affected by the branching factor of the <b>tree</b> <b>patterns</b> to find, DryadeParent makes the assumption that no two siblings in the <b>data</b> <b>trees</b> can have the same label (similar to PathJoin). The method first computes {{a set of}} tiles, which are closed frequent patterns of depth 1. Then, it develops a hooking strategy that reconstructs the closed frequent patterns from these tiles. Similar to PathJoin, DryadeParent is designed {{based on the assumption}} that no two siblings in the <b>data</b> <b>trees</b> can have the same label. While this simplifies the problem, it limits the usage of the method in real applications.|$|R
3000|$|Mining {{patterns}} {{from a large}} <b>data</b> <b>tree</b> The type of mined {{data can}} be a collection of small trees [2, 5, 17, 26, 27] or a single large tree. Surprisingly, the problem of mining <b>tree</b> <b>patterns</b> from a single large tree has only very recently been touched even though a plethora of interesting datasets from different areas are {{in the form of}} a single large tree. Examples include encyclopedia databases like Wikipedia, bibliographic databases like PubMed, scientific and experimental result databases like UniprotKB, and biological datasets like phylogenetic trees. These datasets grow constantly with the addition of new data. Big data applications seek to extract information from large datasets. However, mining a single large <b>data</b> <b>tree</b> is more complex than mining a set of small <b>data</b> <b>trees.</b> In fact, the former setting is more general than the latter, since a collection of small trees can be modeled as a single large tree rooted at a virtual unlabeled node. Existing algorithms for mining embedded patterns from a collection of small trees [26] cannot scale well when the size of the <b>data</b> <b>tree</b> increases. Our experiments show that these algorithms cannot scale beyond some hundreds of nodes in a <b>data</b> <b>tree</b> with low-frequency thresholds.|$|R
3000|$|PathJoin [25] finds maximal unordered induced {{patterns}} from a set {{of small}} trees. PathJoin assumes that no two siblings in <b>data</b> <b>trees</b> have the same label. It first discovers the set of maximal frequent paths and then it finds the <b>tree</b> <b>patterns</b> by joining the paths. After obtaining all frequent patterns, PathJoin keeps only maximal patterns by using a post-processing pruning, which eliminates {{those that are not}} maximal. Such a strategy will suffer from a significant overhead if the number of false positive paths is very high.|$|R
3000|$|Mining {{homomorphic}} <b>tree</b> <b>patterns</b> The morphism {{determines how}} a pattern is mapped to the <b>data</b> <b>tree.</b> The morphism definition depends {{also on the}} type of pattern considered. In the literature, two types of <b>tree</b> <b>patterns</b> have been studied: patterns whose edges represent parent-child relationships (child edges) and patterns whose edges represent ancestor-descendant relationships (descendant edges). Over the years, research has evolved from considering isomorphisms for mining patterns with child edges (induced patterns) [2, 5] to considering embeddings for mining patterns with descendant edges (embedded patterns) [17, 26, 27]. Because of the descendant edges, embeddings are able to extract patterns “hidden” (or embedded) deep within large trees which might be missed by the induced pattern definition [26]. Nevertheless, embeddings are still restricted because: (a) They are injective (one-to-one), and (b) they cannot map two sibling nodes in a pattern to two nodes on the same path in the <b>data</b> <b>tree.</b> On the other hand, homomorphisms are powerful morphisms that do not have those two restrictions of embeddings. We term patterns with descendant edges, mined through homomorphisms, homomorphic patterns. Formal definitions are provided in Sect. 2. As homomorphisms are more relaxed than embeddings, the mined homomorphic patterns are a superset of the mined embedded patterns.|$|R
40|$|<b>Tree</b> <b>patterns</b> {{represent}} important {{fragments of}} XPath. In this paper, {{we show that}} some classes of <b>tree</b> <b>patterns</b> exhibit such a property that, given {{a finite number of}} <b>tree</b> <b>patterns</b> P 1, [...] ., Pn, there exists another <b>pattern</b> P (<b>tree</b> <b>pattern</b> or DAG-pattern) such that P 1, [...] ., Pn, are all contained in P, and for any <b>tree</b> <b>pattern</b> Q belonging to a given class C, P 1, [...] ., Pn, are contained in Q implies P is contained in Q...|$|R
40|$|A <b>tree</b> <b>pattern</b> is a {{structured}} pattern {{known as a}} term in formal logic, and a <b>tree</b> <b>pattern</b> language is the set of trees which are the ground instances of a <b>tree</b> <b>pattern.</b> In this paper, {{we deal with the}} class of tree languages whose language is defined as a union of at most k <b>tree</b> <b>pattern</b> languages, where k is an arbitrary fixed positive number. In particular, we present a polynomial time algorithm that, given a finite set of trees, to find a set of <b>tree</b> <b>patterns</b> that defines a minimal union of at most k <b>tree</b> <b>pattern</b> languages containing the given set. The algorithm can be considered as a natural extension of Plotkin's anti-unification algorithm, which finds a minimal single <b>tree</b> <b>pattern</b> language containing the given set. By using the algorithm, we can realize a consistent and conservative polynomial time inference machine that identifies the class of unions of k <b>tree</b> <b>pattern</b> languages in the limit from positive data for every k ? 0. 1 Introduction Inductive inference is a process to [...] ...|$|R
40|$|Abstract. Trees {{are one of}} the {{fundamental}} data structures used in Com-puter Science. We present a new kind of acyclic pushdown automata, the <b>tree</b> <b>pattern</b> pushdown automaton and the nonlinear <b>tree</b> <b>pattern</b> push-down automaton, constructed for an ordered tree. These automata accept all <b>tree</b> <b>patterns</b> and nonlinear <b>tree</b> <b>patterns,</b> respectively, which match the tree and represent a full index of the <b>tree</b> for such <b>patterns.</b> Given a <b>tree</b> with n nodes, the numbers of these distinct <b>tree</b> <b>patterns</b> and nonlinear <b>tree</b> <b>patterns</b> can be at most 2 n− 1 +n and at most (2 + v) n− 1 + 2, respec-tively, where v is the maximal number of nonlinear variables allowed in nonlinear <b>tree</b> <b>patterns.</b> The total sizes of nondeterministic versions of the two pushdown automata are O(n) and O(n 2), respectively. We discuss the time complexities and show timings of our implementations using the bit-parallelism technique. The timings show that for a given tree the run-ning time is linear {{to the size of the}} input pattern...|$|R
40|$|XQuery is the {{de facto}} {{standard}} XML query language, {{and it is important}} to have efficient query evaluation techniques available for it. It is a well-known fact that a formal bulk algebra is essential for efficient query evaluation, and the Tree Algebra for XML (TAX), among others, is invented for this purpose. It can be shown in this thesis that a substantial subset of XQuery can be expressed as TAX. An XML document is often modelled as an ordered label tree. A core opera-tion in the evaluation of XQuery is the finding of matches for specified <b>tree</b> <b>patterns</b> against the <b>data</b> <b>tree</b> (or forest), and there has been much work towards algorithms for finding such matches efficiently. Multiple XPath expressions can be evaluated by computing one or more <b>tree</b> <b>pattern</b> matches. However, because of the flexibility of XML data, the efficient evaluation of XQuery queries as a whole is much more than a <b>tree</b> <b>pattern</b> match and combining matchings of multiple <b>tree</b> <b>patterns</b> is not the most efficient evaluation plan for XQuery. In this thesis a structure called generalized <b>tree</b> <b>pattern</b> (GTP) is proposed to concisely represent a whole XQuery expression. Evaluating a query reduces to finding the matches of its GTP, which leads to more efficient evaluation plans. Algorithms are developed to translate an XQuery expression, possibly involving join, quantifiers, grouping, aggregation and nesting, to its GTP, and to generate ii efficient physical plans for a specified GTP. XML data often conforms to a schema. Relevant constraints from the schema give rise to further opportunities to optimize queries. Algorithms are given in the thesis to automatically infer structural constraints from a given schema and to sim-plify a GTP given a set of structural constraints. Finally, a detailed set of experi-ments using the TIMBER XML database system shows that plans via GTPs (with or without schema knowledge) significantly outperform plans based on navigation and straightforward plans obtained directly from the query. ii...|$|R
40|$|Abstract—A {{new kind}} of an acyclic pushdown {{automaton}} for an ordered tree is presented. The nonlinear <b>tree</b> <b>pattern</b> pushdown automaton represents a complete index of the tree for nonlinear <b>tree</b> <b>patterns</b> and accepts all nonlinear <b>tree</b> <b>patterns</b> which match the tree. Given a tree with n nodes, {{the number of such}} nonlinear <b>tree</b> <b>patterns</b> is O((2 +v) n), where v is the number of variables in the patterns. We discuss time and space complexities of the nondeterministic nonlinear <b>tree</b> <b>pattern</b> pushdown automaton and a way of its implementation. The presented pushdown automaton is input–driven and therefore can be determinised. I...|$|R
40|$|In {{this paper}} we {{consider}} the enumeration of binary trees avoiding non-contiguous binary <b>tree</b> <b>patterns.</b> We begin by computing closed formulas {{for the number of}} trees avoiding a single binary <b>tree</b> <b>pattern</b> with 4 or fewer leaves and compare these results to analogous work for contiguous <b>tree</b> <b>patterns.</b> Next, we give an explicit generating function that counts binary trees avoiding a single non-contiguous <b>tree</b> <b>pattern</b> according to number of leaves. In addition, we enumerate binary trees that simultaneously avoid more than one <b>tree</b> <b>pattern.</b> Finally, we explore connections between pattern-avoiding trees and pattern-avoiding permutations. 1 Partially supported by NSF grant DMS- 0851721 1...|$|R
40|$|Since tree-structured data such as XML {{files are}} widely used for data {{representation}} and exchange on the Internet, discovering frequent <b>tree</b> <b>patterns</b> over tree-structured <b>data</b> streams becomes an interesting issue. In this paper, we propose an online algorithm to continuously discover the current set of frequent <b>tree</b> <b>patterns</b> from the <b>data</b> stream. A novel and efficient technique is introduced to incrementally generate all candidate <b>tree</b> <b>patterns</b> without duplicates. Moreover, a framework for counting the approximate frequencies of the candidate <b>tree</b> <b>patterns</b> is presented. Combining these techniques, the proposed approach is able to compute frequent <b>tree</b> <b>patterns</b> with guarantees of completeness and accuracy...|$|R
40|$|IEICE Transactions on Information and Systems E 75 -D, 426 - 434, 1992; Proc. 2 nd International Workshop on Nonmonotonic and Inductive Logic 1991, Lecture Notes in Artificial Intelligence 659), 118 - 131, 1993. In {{this paper}} we {{consider}} the polynomial time inferability from positive data for unions of two <b>tree</b> <b>pattern</b> languages. A <b>tree</b> <b>pattern</b> is a structured pattern known as a term in logic programming and term rewriting systems, and a <b>tree</b> <b>pattern</b> language is the set of all ground instances of a <b>tree</b> <b>pattern.</b> We present a polynomial time algorithm to find a minimal union of two <b>tree</b> <b>pattern</b> languages containing given examples. Our algorithm {{can be considered as}} a natural extension of Plotkin 2 ̆ 7 s least generalization algorithm, which finds a minimal single <b>tree</b> <b>pattern</b> language. By using this algorithm we can realize a polynomial time inference machine for unions of two <b>tree</b> <b>pattern</b> languages from positive data...|$|R
30|$|The work on mining <b>tree</b> <b>patterns</b> in {{a single}} large tree or graph setting {{has so far been}} very limited. The only known papers are [8, 10, 11] which focus on mining <b>tree</b> <b>patterns</b> with only child edges from a single graph and [19] which leverages homomorphisms to mine {{embedded}} <b>tree</b> <b>patterns</b> from a single tree. To the best of our knowledge, our work is the first one for efficiently mining (maximal) homomorphic <b>tree</b> <b>patterns</b> with descendant edges from a single large tree.|$|R
40|$|Abstract — This paper {{proposes a}} new type of <b>tree</b> termed <b>pattern</b> <b>trees.</b> Like {{decision}} <b>trees,</b> <b>pattern</b> <b>trees</b> are an effective tool for classification applications. This paper discusses the difference between decision <b>trees</b> and <b>pattern</b> <b>trees,</b> and also shows that the subsethood based method and the weighted subsethood based method are two specific cases of <b>pattern</b> <b>trees.</b> A novel <b>pattern</b> <b>tree</b> induction method is proposed. The comparison to other classification methods including fuzzy decision tree induction shows that <b>pattern</b> <b>trees</b> can obtain higher accuracy rates in classifications. In addition, <b>pattern</b> <b>trees</b> are capable of generating patterns with good generality, while decision trees can easily fall into the trap of over-fitting. I...|$|R
