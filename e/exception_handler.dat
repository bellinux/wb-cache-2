88|110|Public
25|$|MIPS I has two {{instructions}} for software to signal an exception: System Call and Breakpoint. System Call {{is used by}} user mode software to make kernel calls; and Breakpoint is used to transfer control to a debugger via the kernel's <b>exception</b> <b>handler.</b> Both instructions have a 20-bit Code field that can contain operating environment-specific information for the <b>exception</b> <b>handler.</b>|$|E
25|$|Microsoft's {{implementation}} of Data Execution Prevention (DEP) mode explicitly protects the pointer to the Structured <b>Exception</b> <b>Handler</b> (SEH) from being overwritten.|$|E
25|$|In general, an {{exception}} breaks the normal flow of execution and executes a pre-registered <b>exception</b> <b>handler.</b> The {{details of how}} this is done depends on {{whether it is a}} hardware or software exception and how the software exception is implemented. Some exceptions, especially hardware ones, may be handled so gracefully that execution can resume where it was interrupted.|$|E
40|$|Workflow Management Systems are {{becoming}} more and more important to organizations for the execution of business processes. However, most current systems lack a consistent way of dealing with failures and exceptions. This paper proposes to use an exception-handling mechanism to provide `transactional' features for workflow management systems. The modeler specifies <b>exception</b> <b>handlers</b> for activities to deal with <b>exceptions.</b> These <b>exception</b> <b>handlers</b> change the workflow that is being executed to deal with exceptions as they arise. Based on this idea we discuss which <b>exceptions</b> and <b>exception</b> <b>handlers</b> should be supported and how they interact to provide transactional capabilities. 1. Introduction Workflow is a very powerful concept that provides configuration and control of business processes [1]. However, one of the problems with most current workflow products is that they do not provide transactional capabilities [2]. In contrast, database transactions are guaranteed to have the well-know [...] ...|$|R
40|$|Advanced object {{modeling}} environment (ADOME) is {{an active}} object oriented database system (OODBMS) extended with role facilities. It provides a good supporting environment for the dynamic features required for a workflow management system (WFMS), especially for online exception handling. In ADOME-WFMS, <b>exception</b> <b>handlers</b> can be procedural or declarative. Both {{of them can be}} added, deleted and modified during activity definition time before execution, or during exception occurrence at run-time. In ADOME-WFMS, mechanisms for reuse of <b>exception</b> <b>handlers</b> and types of resolution which are supported during manual or automatic exception handling are presented...|$|R
40|$|In this paper, {{we first}} present a static {{analysis}} based on set-based framework, which estimates exception propagation paths of Java programs. We construct an exception propagation graph from the static analysis information, {{which includes the}} origin of <b>exceptions,</b> <b>handler</b> of <b>exceptions,</b> and propagation paths of exceptions. We have implemented the exception propagation analysis and a visualization tool which visualizes propagation paths of exceptions using the exception propagation graph. This propagation information can guide programmers to detect uncaught exceptions, handle exceptions more specifically, and put <b>exception</b> <b>handlers</b> at appropriate places by tracing exception propagation...|$|R
25|$|In {{addition}} to those existing forms of memory protection, Internet Explorer 9 now opts-in to SEHOP (Structured <b>Exception</b> <b>Handler</b> Overwrite Protection) which works by validating {{the integrity of the}} exception handling chain before dispatching exceptions. This helps ensure that structured exception handling cannot be used as an exploit vector, even when running outdated browser add-ons that have not been recompiled to take advantage of SafeSEH.|$|E
25|$|An exception-handling {{language}} {{without this}} unwinding is Common Lisp with its Condition System. Common Lisp calls the <b>exception</b> <b>handler</b> {{and does not}} unwind the stack. This allows the program to continue the computation {{at exactly the same}} place where the error occurred (for example when a previously missing file has become available). The stackless implementation of the Mythryl programming language supports constant-time exception handling without stack unwinding.|$|E
25|$|Exception {{handling}} is used {{to communicate}} {{the existence of a}} runtime problem or error from where it was detected to where the issue can be handled.|date = 2013|accessdate = 30 August 2016|website = Cambridge Computer Laboratory - Course Materials 2013-14|publisher = |last = Mycroft|first = Alan}} It permits this to be done in a uniform manner and separately from the main code, while detecting all errors. Should an error occur, an exception is thrown (raised), which is then caught by the nearest suitable <b>exception</b> <b>handler.</b> The exception causes the current scope to be exited, and also each outer scope (propagation) until a suitable handler is found, calling in turn the destructors of any objects in these exited scopes. At the same time, an exception is presented as an object carrying the data about the detected problem.|$|E
25|$|Internet Explorer 9 uses layered {{protection}} against malware. It uses technical {{measures to protect}} its memory like the DEP/NSX protection, Safe <b>Exception</b> <b>handlers</b> (SafeSEH) and ASLR protection used in Internet Explorer 8.|$|R
50|$|An On Error goto/gosub {{structure}} {{is used in}} BASIC and {{is quite different from}} modern exception handling; in BASIC there is only one global handler whereas in modern <b>exception</b> handling, <b>exception</b> <b>handlers</b> are stacked.|$|R
25|$|The exception-causing code {{is placed}} inside a try block. The {{exceptions}} are handled in separate catch blocks (the handlers); each try block can have multiple <b>exception</b> <b>handlers,</b> {{as it is}} visible in the example below.|$|R
25|$|Windows {{specific}} compiler {{support is}} also needed for Structured Exception Handling (SEH). This system serves two purposes: {{it provides a}} substrate on which language-specific exception handling can be implemented, and it is how the kernel notifies applications of exceptional conditions such as dereferencing an invalid pointer or stack overflow. The Microsoft/Borland C++ compilers {{had the ability to}} use this system {{as soon as it was}} introduced in Windows 95 and NT, however the actual implementation was undocumented and had to be reverse engineered for the Wine project and free compilers. SEH is based on pushing <b>exception</b> <b>handler</b> frames onto the stack, then adding them to a linked list stored in thread local storage (the first field of the thread environment block). When an exception is thrown, the kernel and base libraries unwind the stack running handlers and filters as they are encountered. Eventually, every exception unhandled by the application will be dealt with by the default backstop handler, which pops up the Windows common crash dialog.|$|E
25|$|Sonic 3D Blast was {{the final}} Sonic game to be {{released}} for the Sega Genesis. Sega had discontinued official support for the Genesis in 1995, but intended all along to produce the game for the 16-bit console because games typically sell for {{one to two years}} after their platforms' discontinuation. Early on, a test build was made to help decide if a split-screen two-player mode would be viable, but split-screen would not end up in the final product. Jon Burton, programmer for the Genesis version, implemented an <b>exception</b> <b>handler</b> where, should an error occur, the game would greet the player with a secret level select screen instead of crashing; this was done so the game could easily pass Sega's approval process for publishing games. Burton also gave this version a unique full motion video intro sequence that could only fit on the 4MB cartridge by using compression and various tricks to make the low-resolution video appear higher resolution.|$|E
2500|$|Via C++'s influence, {{catch is}} the keyword {{reserved}} for declaring a pattern-matching <b>exception</b> <b>handler</b> in other languages popular today, like Java or C#. Some other languages like Ada use the keyword exception to introduce an <b>exception</b> <b>handler</b> and then may even employ a different keyword (when in Ada) for the pattern matching. A few languages like AppleScript incorporate placeholders in the <b>exception</b> <b>handler</b> syntax to automatically extract several {{pieces of information}} when the exception occurs. This approach is exemplified below by the on error construct from AppleScript: ...|$|E
5000|$|The join {{points in}} AspectJ include method or {{constructor}} call or execution, the initialization {{of a class}} or object, field read and write access, <b>exception</b> <b>handlers,</b> etc. They do not include loops, super calls, throws clauses, multiple statements, etc.|$|R
40|$|This paper {{describes}} {{an approach to}} extending the exception handling mechanisms of object-oriented languages by attaching <b>exception</b> <b>handlers</b> to classes and objects. Object and class <b>exception</b> <b>handlers</b> bring advantages of the object-oriented programming into error recovery actions and give opportunity to consider exception handling policy at {{the early stages of}} the abstract class design. Special emphasize is given to the realistic and efficient implementation suitable for statically-typed compiled languages. Discussion is based on Lemick language. The described extension is orthogonal to the existing exception handling mechanism and does not require any changes to language syntax or grammar as it is fully expressed in terms of objectoriented programming already present in the language. 1...|$|R
40|$|Exception {{specifications}} can aid in {{the tasks}} of writing correct <b>exception</b> <b>handlers</b> and understanding exceptional control flow, but current exception specification systems are impractical {{in a number of}} ways. In particular, they are too low-level, too heavyweight, and do not provide adequate support for describing exception policies...|$|R
2500|$|By {{overwriting}} {{a function}} pointer or <b>exception</b> <b>handler,</b> which is subsequently executed ...|$|E
2500|$|This default {{uncaught}} <b>exception</b> <b>handler</b> may be overridden, either globally or per-thread, {{for example}} to provide alternative logging or end-user reporting of uncaught exceptions, or to restart threads that terminate {{due to an}} uncaught exception. For example, in Java this is done for a single thread via [...] and globally via in Python this is done by modifying [...]|$|E
2500|$|Common Lisp, Dylan and Smalltalk have a {{condition}} system (see Common Lisp Condition System) that encompasses the aforementioned exception handling systems. In those languages or environments {{the advent of}} {{a condition}} (a [...] "generalisation of an error" [...] according to Kent Pitman) implies a function call, and only late in the <b>exception</b> <b>handler</b> the decision to unwind the stack may be taken.|$|E
40|$|The RTC (Real-Time Concurrency) {{programming}} {{concepts and}} language constructs for expressing timing and resource consistency constraints {{as well as}} <b>exception</b> <b>handlers</b> for recovery from constraint violations were developed in late 1980 ’s [21]. In real-time applications such as robotics, industrial control, automotive, and avionics, the correctnes...|$|R
5000|$|Ehcache is {{a widely}} used open source Java {{distributed}} cache for general purpose caching, Java EE and [...] It features , , listeners, , cache <b>exception</b> <b>handlers,</b> a gzip caching servlet filter, RESTful and SOAP APIs. Ehcache is available under an Apache open source license and is actively supported.|$|R
40|$|Aspect-oriented {{languages}} are usually formulated {{as an extension}} to existing languages, without paying any {{special attention to the}} underlying exception handling mechanisms. Consequently, aspect <b>exceptions</b> and <b>handlers</b> are no different than base <b>exceptions</b> and <b>handlers.</b> Conflation between aspect and base <b>exceptions</b> and <b>handlers</b> may inadvertently trigger execution of unintended handlers, changing the expected program behavior: aspect exceptions are accidentally caught by base handlers or vice-versa. Programmers cannot state the desired interaction between aspect and base <b>exceptions</b> and <b>handlers.</b> Specific instances of this issue have been identified by others researchers. We distill the essence of the problem and designate it as the exception conflation problem. Consequently, we propose a semantics for an aspect-oriented language with execution levels and an exception handling mechanism that solves the exception conflation problem. By default, the language ensures there is no interaction between base and aspect <b>exceptions</b> and <b>handlers,</b> and provides level-shifting operators to flexibly specify interaction between them when required. We illustrate the benefits of our proposal with a representative set of examples...|$|R
2500|$|Windows {{implements}} software DEP (without {{the use of}} the NX bit) through Microsoft's [...] "Safe Structured Exception Handling" [...] (SafeSEH). For properly compiled applications, SafeSEH checks that, when {{an exception}} is raised during program execution, the exception's handler is one defined by the application as it was originally compiled. The effect of this protection is that an attacker is not able to add his own <b>exception</b> <b>handler</b> which he has stored in a data page through unchecked program input.|$|E
2500|$|A TLB refill {{exception}} is generated {{when there are}} no entries in the TLB that match the mapped virtual address. [...] A TLB invalid {{exception is}} generated when there is a match but the entry is marked invalid. [...] A TLB modified exception is generated when there is a match but the dirty status is not set. [...] If a TLB exception occurs when processing a TLB exception, a double fault TLB exception, it is dispatched to its own <b>exception</b> <b>handler.</b>|$|E
2500|$|Many {{computer}} languages have {{built-in support}} for exceptions and exception handling. This includes ActionScript, Ada, BlitzMax, C++, C#, COBOL, D, ECMAScript, Eiffel, Java, ML, Object Pascal (e.g. Delphi, Free Pascal, and the like), PowerBuilder, Objective-C, OCaml, PHP (as of version 5), PL/1, PL/SQL, Prolog, Python, REALbasic, Ruby, Scala, Seed7, Tcl, Visual Prolog and most [...]NET languages. Exception handling is commonly not resumable in those languages, and when an exception is thrown, the program searches {{back through the}} stack of function calls until an <b>exception</b> <b>handler</b> is found.|$|E
5000|$|... "Instrumenting" [...] all {{the source}} code with {{additional}} source statements that issue a function that invokes an {{internal or external}} debug subroutine, is yet another common approach. This method increases the binary size and might adversely affect normal memory allocation and <b>exception</b> <b>handlers.</b> [...] "Debug" [...] options exist on some compilers to implement this technique semi-transparently.|$|R
50|$|IS-Basic {{adheres to}} the ANSI BASIC standard. It is a fully {{structured}} language whose wide {{set of control}} structures includes multi-line IF...THEN...ELSE, SELECT...CASE, DO...LOOP with WHILE and UNTIL conditions at the begin and/or end of the loop, and EXIT LOOP statement. Procedures and functions can have both reference and value parameters, and local variables. Errors and other exceptions are handled with <b>exception</b> <b>handlers.</b>|$|R
40|$|Abstract. This paper {{proposes a}} {{framework}} based on Service Oriented Architecture which integrates diagnostic {{services in the}} architecture of a composite service {{in order to improve}} the recovery from the occurring exceptions. Our framework supports a fine-grained selection of <b>exception</b> <b>handlers</b> suitable to repair the problem without modifying the basic mechanism offered by standard orchestration engines such as the WS-BPEL compliant ones...|$|R
50|$|Structured <b>Exception</b> <b>Handler</b> Overwrite Protection is {{a feature}} of Windows which protects against the most common stack {{overflow}} attacks, especially against attacks on a structured <b>exception</b> <b>handler.</b>|$|E
5000|$|Via C++'s influence, [...] is the keyword {{reserved}} for declaring a pattern-matching <b>exception</b> <b>handler</b> in other languages popular today, like Java or C#. Some other languages like Ada use the keyword [...] to introduce an <b>exception</b> <b>handler</b> and then may even employ a different keyword ( [...] in Ada) for the pattern matching. A few languages like AppleScript incorporate placeholders in the <b>exception</b> <b>handler</b> syntax to automatically extract several {{pieces of information}} when the exception occurs. This approach is exemplified below by the [...] construct from AppleScript: ...|$|E
50|$|On the x86 {{computer}} architecture, {{a triple}} fault {{is a special}} kind of exception generated by the CPU when an exception occurs while the CPU is trying to invoke the double fault <b>exception</b> <b>handler,</b> which itself handles exceptions occurring while trying to invoke a regular <b>exception</b> <b>handler.</b>|$|E
40|$|The article {{presents}} {{an overview of}} dynamic integration in the kernel Linux, allowed to modify (add, change) its functionality. Traditional methods of integration based on changing in the kernel code (patching), and methods based on using system capabilities (for example, LSM) are considered. Special {{attention is paid to}} interception key mechanisms of the kernel, such as <b>exception</b> <b>handlers</b> and system call dispatcher...|$|R
40|$|Constructs {{for expressing}} {{exception}} handling can greatly help to avoid clutter in code {{by allowing the}} programmer to separate the code to handle unusual situations from the code for the normal case. Handling exceptions in functional languages has received less attention mainly due to the inherent conflict between the control flow oriented approach of <b>exception</b> <b>handlers</b> and the functional style of evaluation. This has (i) resulted in loss of referential transparency, (ii) made non-strict constructs behave as strict functions, and most importantly, (iii) forced an order of evaluation on the subexpressions in a function. In this paper, we propose {{a new approach to}} embed <b>exception</b> <b>handlers</b> in functional languages. The proposed approach discards the conventional view of treating exceptions as a means of effecting a control transfer; instead, exceptions are used to change the state of an object. The two types of exceptions, Terminate and Resume, are treated differently in this paper. A Termi [...] ...|$|R
5000|$|In PL/1, {{even though}} a program itself may not be {{predominantly}} event-driven, certain abnormal events such as a hardware error, overflow or [...] "program checks" [...] may occur that possibly prevent further processing. <b>Exception</b> <b>handlers</b> may be provided by [...] "ON statements" [...] in (unseen) callers to provide housekeeping routines to clean up afterwards before termination, or to perform recovery operations {{and return to the}} interrupted procedure.|$|R
