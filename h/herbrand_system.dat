4|1|Public
40|$|In {{previous}} work, {{an attempt}} was made to apply the schematic CERES method [8] to a formal proof with an arbitrary number of Î  2 cuts (a recursive proof encapsulating the infinitary pigeonhole principle) [5]. However the derived schematic refutation for the characteristic clause set of the proof could not be expressed in the formal language provided in [8]. Without this formalization a <b>Herbrand</b> <b>system</b> cannot be algorithmically extracted. In this work, we provide a restriction of the proof found in [5], the ECA-schema (Eventually Constant Assertion), or ordered infinitary pigeonhole principle, whose analysis can be completely carried out in the framework of [8], {{this is the first time}} the framework is used for proof analysis. From the refutation of the clause set and a substitution schema we construct a <b>Herbrand</b> <b>system.</b> Comment: Submitted to IJCAR 2016. Will be a reference for Appendix material in that paper. arXiv admin note: substantial text overlap with arXiv: 1503. 0855...|$|E
40|$|We {{introduce}} a constraint system called FT. This system offers a {{theoretical and practical}} alternative to the usual <b>Herbrand</b> <b>system</b> of constraints over constructor trees. Like Herbrand, FT provides a universal data structure based on trees. However, the trees of FT (called feature trees) are more general than the constructor trees of Herbrand, and the constraints of FT are of finer grain and of different expressiveness. The essential novelty of FT is provided by functional attributes called features which allow representing data as extensible records, a more flexible way than that offered by Herbrand's fixed arity constructors. The feature tree structure determines an algebraic semantics for FT. We establish a logical semantics thanks to three axiom schemes presenting the first-order theory FT. We propose using FT as a constraint system for logic programming. We provide a test for constraint unsatisfiability, and a test for constraint entailment. The former corresponds to unification [...] ...|$|E
40|$|The {{schematic}} CERES {{method is}} a method of cut elimination for proof schemata, that is a sequence of proofs with a recursive construction. Proof schemata {{can be thought of}} as a way to circumvent the addition of an induction rule to the LK-calculus. In this work, we formalize a schematic version of the Infinitary Pigeonhole Principle (IPP), in the LKS-calculus, and analyse the extracted clause set schema. However, the refutation we find cannot be expressed as a resolution proof schema because there is no clear ordering of the terms indexing the recursion, every ordering is used in the refutation. Interesting enough, the clause set and its refutation is very close to a canonical form found in cut elimination of LK-proofs. Not being able to handle refutations of this form is problematic in that proof schema, when instantiated, are LK-proofs. Based on the structure of our refutation and structural results, we develop a generalized resolution proof schema based on recursion over a special type of list, and provide a refutation, using our generalization, of the clause set extracted from our formal proof of IPP. We also extract a <b>Herbrand</b> <b>System</b> from the refutation. Comment: Work is progress. This is the current extension of the the schematic resolution refutation formalism. A better formalism is being investigated. arXiv admin note: substantial text overlap with arXiv: 1503. 08551, arXiv: 1601. 0654...|$|E
40|$|We present {{full of the}} {{properties}} about HM(X). HM(X) is a general framework for Hindley/Milner type systems with constraints. Specific type systems {{can be obtained by}} instantiating the constraint parameter X. For instance, the Hindley/Milner type system itself can be obtained by instantiating X to the <b>Herbrand</b> constraint <b>system.</b> We give a generic type infernce algorithm for HM(X) type systems. Under sufficient condition on X we obtain type inference with principal types. 1 Introduction In this technical report one can find full proofs of {{the properties}} about HM(X). For more details about HM(X) we refer to [OSW]. Here, we present full proofs of the lemmas and theorems stated in [OSW]. We start in Section 2 with the definition of our notion of constraint systems. The HM(X) framework is introduced in Section 3. Section 4 considers alternative typing rules. Type inference in HM(X) is discussed in Section 6. Section 7 considers a specific instance of the HM(X) framework that deals with rec [...] ...|$|R
40|$|AbstractWe {{introduce}} a constraint system called FT. This system offers a {{theoretical and practical}} alternative to the usual <b>Herbrand</b> <b>system</b> of constraints over constructor trees. Like Hrerbrand, FT provides a universal data structure based on trees. However, the trees of FT (called feature trees) are more general than the constructor trees of Herbrand, and the constraints of FT are of finer grain and of different expressiveness. The essential novelty of FT is provided by functional attributes called features which allow representing data as extensible records, a more flexible way than that offered by Herbrand's fixed arity constructors. The feature tree structure determines an algebraic semantics for FT. We establish a logical semantics, thanks to three axiom schemes presenting the first-order theory FT. We propose using FT as a constraint system for logic programming. We provide a test for constraint unsatisfiability, and a test for constraint entailment. The former corresponds to unification and the latter to matching. The {{combination of the two}} is needed for advanced control mechanisms. We use the concept of relative simplification of constraints, a normalization process that decides entailment and unsatisfiability simultaneously. The two major technical contributions of this work are: (i) an incremental system performing relative simplification for FT that we prove to be sound and complete; and (ii) a proof showing that FT satisfies independence of negative constraints, the property that conjoined negative constraints may be handled independently...|$|E

