649|6989|Public
25|$|The nested <b>function</b> <b>call</b> will {{be invoked}} when {{encountered}} {{and the result}} inserted into {{the text of the}} outer <b>function</b> <b>call</b> and scanning of the outer <b>function</b> <b>call</b> resumes at the place indicated by the number of '#' characters preceding the nested call.|$|E
25|$|If the <b>function</b> <b>call</b> was prefixed by {{a single}} '#' character, then {{scanning}} will resume just before the inserted text from the <b>function</b> <b>call.</b>|$|E
25|$|During the {{collection}} of a <b>function</b> <b>call,</b> additional function calls may be encountered, for example, this.|$|E
5000|$|... 1 or 0x1: Incorrect <b>function</b> <b>called</b> or unknown <b>function</b> <b>called.</b>|$|R
40|$|Keywords:path {{coverage}} testing; finite-state machine; static <b>function</b> <b>calling</b> paths. Abstract. Path coverage testing {{based on}} thefunction calling relationship {{is an important}} criterionfor ensuring testing adequacy. The key to path testingis the determination of path number. This paper proposes an algorithm to generate static <b>function</b> <b>calling</b> paths with control logic based on thefinite-state machine (FSM). The algorithm analyzes the C++ staticsource code and extracts the program information, generating static <b>function</b> <b>calling</b> paths and <b>function</b> <b>calling</b> graphs. The experiment proves that the algorithm can accurately generatestatic <b>function</b> <b>calling</b> paths with control logic and obtain the path number of the testing program. The accurate extraction of the static <b>function</b> <b>calling</b> paths lays a solid foundation for path coverage testing based on the <b>function</b> <b>calling</b> relationship...|$|R
40|$|Keywords:test coverage;function calling path; Instrumentation;path {{generation}} Abstract. Path coverage {{testing is}} almost impossible to achieve because of the large number of paths. The <b>function</b> <b>calling</b> path coverage analysis method can guaranty adequate test coverage rate effectivelyon the precondition of unit testingcompletion. Based on <b>function</b> <b>calling</b> relations, the methods of dynamic generation <b>function</b> <b>calling</b> path is proposed. For cycle and recursive calling, design instrumentation rules and probe function, complete source code instrumentation, ensure the stub point flow can trace to the <b>function</b> <b>calling</b> relations. Thefunction calling path generationalgorithms were designed to split the stub point flow to the dynamic <b>function</b> <b>calling</b> path. Experimental results show that the dynamic <b>function</b> <b>calling</b> path generation method based instrumentation canextract the <b>function</b> <b>calling</b> paths which are executed by test casesand gain the coverage of information automatically...|$|R
25|$|If the <b>function</b> <b>call</b> was prefixed by two '#' characters, then {{scanning}} resumes {{just after}} the inserted text. This is called passive invocation.|$|E
25|$|Destroying {{an object}} whose storage is {{allocated}} {{in such a}} fashion requires some care. Because there is no placement delete expression, one cannot use it to invoke the custom deallocator. One must either write a destruction function that invokes the custom deallocator, or call the placement delete function directly, as a <b>function</b> <b>call.</b>|$|E
25|$|Under the Longs Peak API, object {{creation}} would become atomic, using templates {{to define the}} properties of an object which would be created with one <b>function</b> <b>call.</b> The object could then be used immediately across multiple threads. Objects would also be immutable; however, they could have their contents changed and updated. For example, a texture could change its image, but its size and format could not be changed.|$|E
50|$|Most basic {{examples}} of recursion, {{and most of}} the examples presented here, demonstrate direct recursion, in which a <b>function</b> <b>calls</b> itself. Indirect recursion occurs when a <b>function</b> is <b>called</b> not by itself but by another <b>function</b> that it <b>called</b> (either directly or indirectly). For example, if f calls f, that is direct recursion, but if f calls g which calls f, then that is indirect recursion of f. Chains of three or more functions are possible; for example, <b>function</b> 1 <b>calls</b> <b>function</b> 2, <b>function</b> 2 <b>calls</b> <b>function</b> 3, and <b>function</b> 3 <b>calls</b> <b>function</b> 1 again.|$|R
25|$|In {{this case}} the tree <b>function</b> <b>calls</b> the forest <b>function</b> by single recursion, but the forest <b>function</b> <b>calls</b> the tree <b>function</b> by {{multiple}} recursion.|$|R
50|$|An {{implementation}} of C providing {{all of the}} standard library <b>functions</b> is <b>called</b> a hosted implementation. Programs written for hosted implementations are required to define a special <b>function</b> <b>called</b> main, {{which is the first}} <b>function</b> <b>called</b> when a program begins executing.|$|R
25|$|On {{the other}} hand, {{efficiency}} often improves if the recursion is stopped at relatively large base cases, {{and these are}} solved non-recursively, resulting in a hybrid algorithm. This strategy avoids the overhead of recursive calls that do little or no work, and may also allow the use of specialized non-recursive algorithms that, for those base cases, are more efficient than explicit recursion. A general procedure for a simple hybrid recursive algorithm is short-circuiting the base case, also known as arm's-length recursion. In this case whether the next step {{will result in the}} base case is checked before the <b>function</b> <b>call,</b> avoiding an unnecessary <b>function</b> <b>call.</b> For example, in a tree, rather than recursing to a child node and then checking if it is null, checking null before recursing; this avoids half the function calls in some algorithms on binary trees. Since a D algorithm eventually reduces each problem or sub-problem instance to a large number of base instances, these often dominate the overall cost of the algorithm, especially when the splitting/joining overhead is low. Note that these considerations do not depend on whether recursion is implemented by the compiler or by an explicit stack.|$|E
25|$|Applications make a <b>function</b> <b>call</b> to WBTRCALL.DLL, a loader and {{requester}} interface. The loader and requester module {{verify the}} BTI.INI configuration file is correctly {{set up to}} load the client-based Btrieve engine. In turn, this loads the local interface to the btrieve engine (WBTRLOCL.DLL). If necessary, this local interface loads the Btrieve engine (WBTR32.EXE) into memory and sends the necessary database requests to it. The database engine then calls various Win32 system libraries to perform file operations on the database files.|$|E
25|$|Functions as object constructors: Functions {{double as}} object constructors, {{along with their}} typical role. Prefixing a <b>function</b> <b>call</b> with new will create an {{instance}} of a prototype, inheriting properties and methods from the constructor (including properties from the Object prototype). ECMAScript 5 offers the Object.create method, allowing explicit creation of an instance without automatically inheriting from the Object prototype (older environments can assign the prototype to null). The constructor's prototype property determines the object used for the new object's internal prototype. New methods can be added by modifying the prototype of the function used as a constructor. JavaScript's built-in constructors, such as Array or Object, also have prototypes that can be modified. While {{it is possible to}} modify the Object prototype, it is generally considered bad practice because most objects in JavaScript will inherit methods and properties from the Object prototype, and they may not expect the prototype to be modified.|$|E
5000|$|For all {{protected}} indirect <b>function</b> <b>calls,</b> the [...] <b>function</b> is <b>called,</b> which {{performs the}} following steps: ...|$|R
40|$|We develop our {{method for}} {{programs}} with arithmetic and pointerexpressions, and call-by-value <b>function</b> <b>calls.</b> For <b>function</b> <b>calls,</b> Craig interpolation offers a systematic way of generating relevantpredicates that contain only the local variables {{of the function}} and {{the values of the}} formal parameters when the <b>function</b> was <b>called.</b> We have extended our model checker...|$|R
30|$|Phrase {{components}} are calculated as {{the response to}} a critically damped second order linear filter excited with a delta <b>function</b> <b>called</b> phrase command. Accent components result from the response to a similar filter, excited with a step <b>function</b> <b>called</b> accent command.|$|R
25|$|Ordinarily, when a {{function}} in a derived class overrides {{a function}} in a base class, the function to call {{is determined by the}} type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called dynamic dispatch. Virtual member functions or methods allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using virtual function tables. If the object type is known, this may be bypassed by prepending a fully qualified class name before the <b>function</b> <b>call,</b> but in general calls to virtual functions are resolved at run time.|$|E
2500|$|... arfitness(k) = feval(strfitnessfct, arx(:,k)); % {{objective}} <b>function</b> <b>call</b> ...|$|E
2500|$|The latter {{would involve}} simply writing the {{destructor}} invocation and delete <b>function</b> <b>call</b> into the program: ...|$|E
50|$|The {{following}} examples {{show how}} to use the module and make <b>function</b> <b>calls</b> to get information about protein disorders. The first two examples make library <b>function</b> <b>calls</b> to calculate the probability of disorder for every residue in the sequence provided.|$|R
40|$|A {{method for}} {{identifying}} vulnerable system call pairs is disclosed. The method {{is based on}} a model for identifying Time-Of-Check-To-Time-Of-Use (TOCTTOU) problem (called STEM), which enumerates the potential file system call pairs (called exploitable TOCTTOU pairs) that form the check/use steps. The system <b>function</b> <b>calls</b> are classified into a plurality of predefined classes and pairs of the <b>function</b> <b>calls</b> are formed according to predefined criteria, where the <b>function</b> <b>calls</b> within a pair are associated with the same file invariant. Georgia Tech Research Corporatio...|$|R
50|$|Galloping is {{not always}} efficient. One reason is due to {{excessive}} <b>function</b> <b>calls.</b> <b>Function</b> <b>calls</b> are expensive and thus when frequent, they affect program efficiency. In some cases galloping mode requires more comparisons than a simple linear search (one at a time search). While {{for the first few}} cases both modes may require the same number of comparisons, over time galloping mode requires 33% more comparisons than linear search to arrive at the same results. Moreover, all comparisons in galloping mode are done by <b>function</b> <b>calls.</b>|$|R
2500|$|... {{where the}} {{function}} {{name and the}} arguments are arbitrary character strings not containing characters of significance: '#', '<', '>', and ';'. The function is invoked with the specified arguments and the resulting text is inserted into the original text {{in place of the}} <b>function</b> <b>call.</b>|$|E
2500|$|The {{interchangeability}} of {{code and}} data gives Lisp its instantly recognizable syntax. All program code is written as s-expressions, or parenthesized lists. A <b>function</b> <b>call</b> or syntactic form is written as a list with the function or operator's name first, and the arguments following; for instance, a function [...] that takes three arguments {{would be called}} as [...]|$|E
2500|$|Common Lisp, Dylan and Smalltalk have a {{condition}} system (see Common Lisp Condition System) that encompasses the aforementioned exception handling systems. In those languages or environments {{the advent of}} {{a condition}} (a [...] "generalisation of an error" [...] according to Kent Pitman) implies a <b>function</b> <b>call,</b> and only late in the exception handler the decision to unwind the stack may be taken.|$|E
50|$|Function {{pointers}} are invoked by {{name just}} like normal <b>function</b> <b>calls.</b> <b>Function</b> pointers are separate from pointers and void pointers.|$|R
40|$|Abstract. In 2008, M. Caldas and G. Navalagi [1] {{introduced}} {{a new class of}} generalized open <b>functions</b> <b>called</b> weakly δ-open <b>functions.</b> By introducing a new type of open <b>functions</b> <b>called</b> relatively weakly δ-open together with weakly δ-open functions, we establish a new decomposition of δ-open functions. 1...|$|R
5000|$|Lodash {{supports}} chaining <b>function</b> <b>calls</b> to {{make them}} more streamline by passing the results up the chain to the <b>calling</b> <b>function.</b>|$|R
2500|$|The {{first four}} rules [...] (variable or {{function}} access), [...] (application, i.e. <b>function</b> <b>call</b> with one parameter), [...] (abstraction, i.e. function declaration) and [...] (variable declaration) are {{centered around the}} syntax, presenting one rule {{for each of the}} expression forms. Their meaning is pretty obvious at the first glance, as they decompose each expression, prove their sub-expressions and finally combine the individual types found in the premises to the type in the conclusion.|$|E
2500|$|Implementations of {{alpha-beta pruning}} {{can often be}} {{delineated}} by whether they are [...] "fail-soft," [...] or [...] "fail-hard." [...] The pseudo-code illustrates the fail-soft variation. With fail-soft alpha-beta, the alphabeta function may return values (v) that exceed (v < α or v > β) the α and β bounds set by its <b>function</b> <b>call</b> arguments. In comparison, fail-hard alpha-beta limits its function return value into the inclusive range of α and β.|$|E
2500|$|In September 2007, Technical Report 24731, {{prepared}} by the C standards committee, was published; it specifies a set of functions {{which are based on}} the standard C library's string and I/O functions, with additional buffer-size parameters. [...] However, the efficacy of these functions for the purpose of reducing buffer overflows is disputable; it requires programmer intervention on a per <b>function</b> <b>call</b> basis that is equivalent to intervention that could make the analogous older standard library functions buffer overflow safe.|$|E
25|$|A link {{register}} supports fast leaf <b>function</b> <b>calls.</b>|$|R
5000|$|<b>Function</b> <b>calls</b> {{may be made}} via {{variable}}s, {{where the}} value of a variable contains the name of the <b>function</b> to <b>call.</b> This is illustrated in the following example: ...|$|R
5000|$|Clang {{supports}} anonymous <b>functions,</b> <b>called</b> blocks, {{which have}} the form: ...|$|R
