23|3092|Public
2500|$|APIs such as Direct3D and DirectSound need to {{interact}} with hardware, and they do this through a device driver. [...] Hardware manufacturers have to write these drivers for a particular DirectX version's <b>device</b> <b>driver</b> <b>interface</b> (or DDI), and test each individual piece of hardware to make them DirectX compatible. Some hardware devices have only DirectX compatible drivers (in other words, one must install DirectX {{in order to use}} that hardware). Early versions of DirectX included an up-to-date library of all of the DirectX compatible drivers currently available. This practice was stopped however, in favor of the web-based Windows Update driver-update system, which allowed users to download only the drivers relevant to their hardware, rather than the entire library.|$|E
50|$|Solaris Express release 6/05 {{added support}} for MSI an MSI-X {{as part of}} their new <b>device</b> <b>driver</b> <b>interface</b> (DDI) {{interrupt}} framework.|$|E
50|$|CLFS {{defines a}} <b>device</b> <b>driver</b> <b>interface</b> (DDI), via which {{physical}} storage system specific drivers plug into the CLFS API. The CLFS driver implements the ARIES recovery algorithm; other algorithms can {{be supported by}} using custom drivers.|$|E
5000|$|The {{hardware}} is also {{incorporated into}} the file hierarchy. <b>Device</b> <b>drivers</b> <b>interface</b> to user applications via an entry in the [...] or [...] directories. Process information as well is mapped to the file system through the [...] directory.|$|R
50|$|The <b>device</b> <b>driver</b> <b>interfaces</b> {{are defined}} in device.h. A given {{implementation}} of Microwindows will link {{at least one}} screen, mouse and keyboard driver into the system. The mid level routines in the device-independent graphics engine core then call the <b>device</b> <b>driver</b> directly to perform the hardware-specific operations. This setup allows varying hardware devices {{to be added to}} the Microwindows system without affecting the way the entire system works.|$|R
50|$|IO.SYS is an {{essential}} part of MS-DOS and Windows 9x. It contains the default MS-DOS <b>device</b> <b>drivers</b> (hardware <b>interfacing</b> routines) and the DOS initialization program.|$|R
5000|$|ReactOS is a clone of MS Windows {{written from}} scratch. Longene uses ReactOS code as a {{reference}} to implement some basic mechanisms of the Microsoft Windows Operating System. That involves implementing the Windows device driver framework, NDIS, the system call interface, the process management and resource management, the <b>device</b> <b>driver</b> <b>interface,</b> etc.|$|E
5000|$|Unlike other {{application}} publishing products, GO-Global {{does not}} use [...] "screen scraping" [...] technology (where bitmaps or output displays are compressed and transmitted to the remote device). Instead, GO-Global intercepts <b>Device</b> <b>Driver</b> <b>Interface</b> (DDI) or X11 calls that are interpreted and rendered by the remote display device. This enhances client pixel redraws and greatly reduces network traffic.|$|E
5000|$|Windows DDK - The {{majority}} of <b>device</b> <b>driver</b> <b>interface</b> functions and data structures have {{counterparts in the}} Linux kernel. Some functions have no exact equivalent in the Linux kernel, {{and there is a}} need to build a wrapper using Linux kernel stuff. In practice, some resource calls and references can be redirected or adapted to Linux kernel counterparts, and the rest need to be implemented from scratch.|$|E
50|$|The term nexus driver {{refers to}} a bus <b>device</b> <b>driver</b> that <b>interfaces</b> leaf <b>drivers</b> to a {{specific}} I/O bus and provides the low-level integration of this I/O bus.|$|R
50|$|WDDM {{provides}} the functionality required {{to render the}} desktop and applications using Desktop Window Manager, a compositing window manager running on top of Direct3D. It also supports new DXGI interfaces required for basic device management and creation. The WDDM specification requires at least Direct3D 9-capable video card and the display driver must implement the <b>device</b> <b>driver</b> <b>interfaces</b> for the Direct3D 9Ex runtime in order to run legacy Direct3D applications; it may optionally implement runtime interfaces for Direct3D 10/10.1 and higher.|$|R
40|$|Abstract- The {{evolutionary}} {{trends in}} windows technology tends to change since {{from the beginning}} including kernel, Graphical (GUI), <b>Device</b> <b>drivers,</b> <b>interfaces</b> etc. This paper presents a brief and comprehensive statistical analysis and view of the evolving hardware technologies, enhancements up gradations, major bugs, and technology difference of the {{different versions of the}} windows. Complete description of why there is transfer of the windows technology from one version to the enhanced /updated version. Starting from a very initial MS-Dos operating System getting upwards till the windows 7, overall innovations that are incorporated in these editions are detailed in the paper...|$|R
5000|$|For {{those early}} {{versions}} of Windows (1.0 to 3.11), the DLLs were {{the foundation for}} the entire GUI. As such, display drivers were merely DLLs with a [...]DRV extension that provided custom implementations of the same drawing API through a unified <b>device</b> <b>driver</b> <b>interface</b> (DDI), and the Drawing (GDI) and GUI (USER) APIs were merely the function calls exported by the GDI and USER, system DLLs with [...]EXE extension.|$|E
50|$|I2O's {{principal}} architectural components {{included the}} I/O processor (IOP) and a split device driver model, with an OSM (OS Module) {{running in the}} host operating system and a HDM (Hardware Device Module) running on the I/O processor. This formally separated OS-specific driver functionality from the underlying device, and the two software components used message passing for communications. This split is suggestive of another initiative in which Intel participated at the time, the Uniform Driver Interface (UDI), which sought to establish a common <b>device</b> <b>driver</b> <b>interface</b> spanning multiple software platforms.|$|E
50|$|OpenGL and Direct3D {{are both}} {{implemented}} in the display device driver. A significant difference however is that Direct3D implements the API in a common runtime (supplied by Microsoft), which in turn talks to a low-level <b>device</b> <b>driver</b> <b>interface</b> (DDI). With OpenGL, every vendor implements the full API in the driver. This means that some API functions may have slightly different behavior from one vendor to the next. The GLSL shader compilers of different vendors also show slightly different behavior.The following compares the two APIs, structured around various considerations mostly relevant to game development.|$|E
50|$|The AMD Catalyst <b>device</b> <b>driver</b> {{supports}} multiple <b>interfaces,</b> all {{designed the}} give user-space programs, such as e.g. GStreamer or HandBrake software, {{access to the}} correspondent SIP blocks.|$|R
40|$|The {{results of}} {{applications}} research directed at finding an improved method of storing and accessing information are presented. Twelve microcomputer-based expert systems shells and five laser-optical formats have been studied, {{and the general}} and specific methods of interfacing these technologies are being tested in prototype systems. Shell features and interfacing capabilities are discussed, and results {{from the study of}} five laser-optical formats are recounted including the video laser, compact, and WORM disks, and laser cards and film. Interfacing, including laser disk <b>device</b> <b>driver</b> <b>interfacing,</b> is discussed and it is pointed out that in order to control the laser device from within the expert systems application, the expert systems shell must be able to access the <b>device</b> <b>driver</b> software. Potential integrated applications are investigated and an initial list is provided including consumer services, travel, law enforcement, human resources, marketing, and education and training...|$|R
40|$|Application {{of model}} {{checking}} techniques directly to programs [1, 8, 10] has shown promise for specific verification tasks, such as, checking for concurrency errors [10] or checking <b>device</b> <b>drivers</b> for <b>interface</b> violations [1]. However, {{there are two}} related problems that hinder applicability of model checking to software in a wider scale: 1) state space explosion (i. e., exponential increase in the searc...|$|R
50|$|APIs such as Direct3D and DirectSound need to {{interact}} with hardware, and they do this through a device driver. Hardware manufacturers have to write these drivers for a particular DirectX version's <b>device</b> <b>driver</b> <b>interface</b> (or DDI), and test each individual piece of hardware to make them DirectX compatible. Some hardware devices have only DirectX compatible drivers (in other words, one must install DirectX {{in order to use}} that hardware). Early versions of DirectX included an up-to-date library of all of the DirectX compatible drivers currently available. This practice was stopped however, in favor of the web-based Windows Update driver-update system, which allowed users to download only the drivers relevant to their hardware, rather than the entire library.|$|E
5000|$|The Windows Vista Bluetooth stack is {{improved}} with support for more hardware IDs, EDR performance improvements, Adaptive frequency hopping for Wi-Fi co-existence, and Synchronous Connection Oriented (SCO) protocol support which {{is needed for}} audio profiles. The Windows Vista Bluetooth stack supports a kernel mode <b>device</b> <b>driver</b> <b>interface</b> besides the user-mode programming interface, which enables third parties to add support for additional Bluetooth Profiles. This was lacking in the Windows XP Service Pack 2 built-in Bluetooth stack, {{which had to be}} entirely replaced by a third-party stack for additional profile support. It also provides RFCOMM support using sockets besides virtual COM ports. KB942567 called Windows Vista Feature Pack for Wireless adds Bluetooth 2.1+EDR support and remote wake from S3 or S4 support for self-powered Bluetooth modules. This feature pack while initially only available to OEMs, was eventually included in Windows Vista Service Pack 2.|$|E
50|$|The Windows Vista Bluetooth stack is {{improved}} with support for more hardware IDs, EDR performance improvements, Adaptive frequency hopping for Wi-Fi co-existence, and Synchronous Connection Oriented (SCO) protocol support which {{is needed for}} audio profiles. The Windows Vista Bluetooth stack supports a kernel mode <b>device</b> <b>driver</b> <b>interface</b> besides the user-mode programming interface, which enables third parties to add support for additional Bluetooth Profiles such as SCO, SDP, and L2CAP. This was lacking in the Windows XP Service Pack 2 built-in Bluetooth stack, {{which had to be}} entirely replaced by a third-party stack for additional profile support. It also provides RFCOMM support using sockets besides virtual COM ports. KB942567 called Windows Vista Feature Pack for Wireless adds Bluetooth 2.1+EDR support and remote wake from S3 or S4 support for self-powered Bluetooth modules. This feature pack while initially only available to OEMs, was eventually included in Windows Vista Service Pack 2.|$|E
40|$|In {{this paper}} we present the {{synchronization}} and driver {{architecture of the}} DLR LWR-III, which supplies an easy to use interface for applications. For our purpose we abstracted the robot hardware entirely from the control algorithms using the common <b>device</b> <b>driver</b> concept of modern operating systems. The software architecture is split into two modular parts. On the one side, there are <b>device</b> <b>drivers</b> that communicate with the hardware components. On the other side, there are realtime ap- plications realized as Simulink Models, which provide advanced control algorithms. This ensures a clean separation between the two modules and provides a communication over a common and approved interface. Furthermore we investigated how we can ensure synchronization to the hardware over the <b>device</b> <b>driver</b> <b>interfaces</b> {{and how we can}} ensure that it meets hard realtime requirements. The main result {{of this paper is to}} realize a synchronization between LWR-III hardware and Simulink control applications while targeting small latencies with respect to hard realtime requirements. The design is implemented and verified on WindRiverTM VxWorksTM...|$|R
50|$|The WMI {{extensions}} to WDM provide kernel-level instrumentation such as publishing information, configuring device settings, supplying event notification from <b>device</b> <b>drivers</b> {{and allowing}} administrators to set data security through a WMI provider {{known as the}} WDM provider. The extensions {{are part of the}} WDM architecture; however, they have broad utility and can be used with other types of drivers as well (such as SCSI and NDIS). The WMI Driver Extensions service monitors all drivers and event trace providers that are configured to publish WMI or event trace information. Instrumented hardware data is provided by way of drivers instrumented for WMI extensions for WDM. WMI extensions for WDM provide a set of Windows <b>device</b> <b>driver</b> <b>interfaces</b> for instrumenting data within the driver models native to Windows, so OEMs and IHVs can easily extend the instrumented data set and add value to a hardware/software solution. The WMI Driver Extensions, however, are not supported by Windows Vista and later operating systems.|$|R
50|$|In the STREAMS {{computer}} networking architecture, the Data Link Provider Interface is an interface that {{a network}} <b>device</b> <b>driver</b> implements. The <b>interface</b> abstracts away low level {{details of the}} hardware and networking protocols, and provides error free delivery of bits over a communications network.|$|R
40|$|We {{present an}} {{experimental}} {{implementation of the}} Java Virtual Machine that runs inside the kernel of the Solaris operating system. The implementation was done by porting an existing small, portable JVM, Squawk, into the Solaris kernel. Our first application of this system is to allow device drivers to be written in Java. A simple device driver was ported from C to Java. Characteristics of the Java device driver and our <b>device</b> <b>driver</b> <b>interface</b> are described...|$|E
40|$|Rapid {{improvements}} in network bandwidth, cost, and ubiq-uity {{combined with the}} security hazards and high {{total cost of ownership}} of personal computers have created a growing market for thin-client computing. We introduce THINC, a virtual display architecture for high-performance thin-client computing in both LAN and WAN environments. THINC virtualizes the display at the <b>device</b> <b>driver</b> <b>interface</b> to trans-parently intercept application display commands and trans-late them into a few simple low-level commands that can be easily supported by widely used client hardware. THINC’s translation mechanism efficiently leverages display semantic information through novel optimizations such as offscreen drawing awareness, native video support, and server-side screen scaling. This is integrated with an update delivery ar...|$|E
40|$|We have {{implemented}} a parallel computer architecture based entirely upon commodity personal computer components. Using 16 Intel Pentium Pro microprocessors and switched fast ethernet as a communication fabric, we have obtained sustained performance on scientific applications {{in excess of}} one Gigaflop. During one production astrophysics treecode simulation, we performed 1 : 2 Θ 10 15 floating point operations (1. 2 Petaflops) over a three week period, with one phase of that simulation running continuously for two weeks without interruption. We report {{on a variety of}} disk, memory and network benchmarks. We also present results from the NAS parallel benchmark suite, which indicate that this architecture is competitive with current commercial architectures. In addition, we describe some software written to support efficient message passing, as well as a Linux <b>device</b> <b>driver</b> <b>interface</b> to the Pentium hardware performance monitoring registers. Keywords: Beowulf, treecode, benchmarks 1 Intr [...] ...|$|E
50|$|The DXVA {{is used by}} {{software}} video decoders {{to define}} a codec-specific pipeline for hardware-accelerated decoding and rendering of the codec. The pipeline starts at the CPU which is used for parsing the media stream and conversion to DXVA-compatible structures. DXVA specifies a set of operations that can be hardware accelerated and <b>device</b> <b>driver</b> <b>interfaces</b> (DDIs) that the graphic driver can implement to accelerate the operations. If the codec needs {{to do any of}} the defined operations, it can use these interfaces to access the hardware-accelerated implementation of these operations. If the graphic driver does not implement {{one or more of the}} interfaces, it is up to the codec to provide a software fallback for it. The decoded video is handed over to the hardware video renderer where further video post-processing might be applied to it before being rendered to the device. The resulting pipeline is usable in a DirectShow compatible application.|$|R
40|$|This report {{describes}} the program description of an interactive graphics package interfacing the Vector General Graphics Display Unit and a Digital Equipment Corporation PDP- 11 / 50 computer. The program {{was written in}} the C-programming language and designed {{to be used in the}} multiprogramming environment of the UNIX Timesharing operating system. Included is a description of the Vector General, operating system modifications, <b>device</b> <b>driver,</b> and <b>interface</b> routines. (Author) Prepared for: Naval Electronics Systems Command (ELEX 320) Washington, D. C. [URL] 59051 N...|$|R
50|$|UniDrv (Universal Printer Driver or Unidriver) is a GDI-based Microsoft Windows {{universal}} {{printer driver}} and architecture for non-PostScript printers. It {{is used to}} simplify driver development of non-PostScript printers (also called Winprinters) for printer manufacturers. Unidrv allows {{the creation of a}} printer-specific minidriver {{in the form of a}} GPD (Generic Printer Description) file, similar to a PPD file, which is much simpler than kernel mode driver development. Unidrv was introduced in Windows 2000 and replaced the Raster <b>Device</b> <b>Driver</b> (RASDD) <b>interface</b> used in Windows NT 4.0 and earlier versions.|$|R
40|$|The recent {{interest}} in Network Computers (NC) has kindled {{somewhat of a}} rebirth in as a platform for an Intel-based NC. With the bloated Workplace Shell and other Graphical User Interface (GUI) components removed, the OS/ 2 kernel makes a good foundation for a Java-based workstation. It requires the installation of a Java Virtual Machine (JVM) and the required operating system support for the Java Application Programming Interface (API). Once enabled, the system will allow for the execution of Java applets and Java applications using the underlying OS/ 2 kernel for memory management, scheduling, dispatching, and device support. In order {{to take advantage of}} the new crop of device architectures now emerging, such as Universal Serial Bus (USB), Firewire, and others, the OS/ 2 <b>device</b> <b>driver</b> <b>interface</b> must be redesigned to support both the older 16 -bit device drivers and a new crop of 32 -bit device drivers 1. In order to insure continued support, the drivers should be written with currentl...|$|E
40|$|Abstract — In this paper, {{we present}} {{the design of}} an {{autonomous}} indoor blimp. We describe the individual low-weight components of an embedded system including actors and sensors which achieve a total weight of less than 200 grams. Both, the modular hardware components {{and the use of}} generic hardware interfaces facilitate the adaption to different actor and sensor systems. Similar to the flexibility of the hardware components, the user benefits from a generic software framework. Here, an onboard Linux operating system and <b>device</b> <b>driver</b> <b>interface</b> ease the implementation of robotic applications and control tasks. The main challenge of designing a small blimp in regard to autonomous operation is the efficient interplay of the individual software and hardware components. In this work, we show approaches of how to build up such a system which can easily be applied to other robotic systems with constraints in weight and available space. We evaluate the performance of the components and demonstrate their integration in a reinforcement learning setting. Index Terms — reinforcement learning and navigation I...|$|E
40|$|Full-system {{simulation}} of systems comprising hundreds of microcontrollers, {{at the level}} of instruction execution, along with {{simulation of}} their peripherals, inter-device communication, power consumption and the like, can be tasking even on high-end workstations. To enable the partitioning of these simulations, which have a high degree of coarse-grained parallelism, over a network of workstations, a multi-platform simulation environment was implemented using the Inferno system. The implementation enables the simulation engine, written in ANSI C, and compiled as a library, to be linked against the Inferno emulator with a custom <b>device</b> <b>driver</b> <b>interface.</b> Using a glue application written in Limbo, and harnessing ideas from parallel discrete-event simulation, the framework enables simulations of networks of embedded systems to be partitioned across workstations of heterogeneous architectures. This paper presents the distributed simulation architecture, the design of the emulator device driver (the interface to the simulation engine), the graphical interface and glue application, and the packaging of the system as single-binary modules for multiple platforms. Also presented is a step-by-step guide for developers unfamiliar with Inferno for creating similar systems. 1...|$|E
40|$|ABSTRACT: Aura is a {{new sound}} {{synthesis}} system designed for portability and flexibility. Aura {{is designed to be}} used with W, a real-time object system. W provides asynchronous, priority-based scheduling, supporting a mix of control, signal, and user interface processing. Important features of Aura are its design for efficient synthesis, dynamic instantiation, and synthesis reconfiguration. performance computer graphics rendering forSoftware sound synthesis offers many benefits, animation in multimedia performances. [Dannenbergincluding the flexibility to use a variety of 93] This requires hardware support and thealgorithms, integration with control software and availability of <b>device</b> <b>drivers.</b> computer <b>interfaces,</b> and compact, portable hardwar...|$|R
40|$|<b>Device</b> <b>drivers</b> {{abstract}} {{away the}} technical details and the complexity associated with interfacing a peripheral with the controller network. This in-turn increases the simplicity {{and reliability of}} the application software, in-turn reducing the product’s time to market. <b>Device</b> <b>drivers</b> provide an <b>interface</b> platform for binding the processor-dependent physical layer and processor independent application layer. So it is corroborated that the <b>device</b> <b>driver</b> must communicate with both the layers, there-by reducing or at the most excluding the processor dependency for application development. The main objective of this work is to provide driver support for Controller Area Network (CAN) communication for a 32 -Bit RISC Architecture based Renesas Micro-Processor series, with software conformance for Automotive Open Syste...|$|R
40|$|Abstract — There is no {{dearth of}} new robots that provide both {{generalized}} and customized platforms {{for learning and}} research. Unfortunately as we attempt to adapt existing soft-ware components, {{we are faced with}} an explosion of <b>device</b> <b>drivers</b> that <b>interface</b> each hardware platform with existing frameworks. We certainly gain the efficiencies of reusing algorithms and tools developed across platforms but only once the <b>device</b> <b>driver</b> is created. We propose a domain specific language that describes the development and runtime interface of a robot and defines its link to existing frameworks. The Robot Device Interface Specification (RDIS) takes advantage of the internal firmware present on many existing devices by defining the communication mechanism, syntax and semantics in such a way to enable the generation of automatic interface links and resource discovery. We present the current domain model as it relates to differential drive robots as a mechanism to use the RDIS to link described robots to HTML 5 via web sockets and ROS (Robot Operating System). I...|$|R
