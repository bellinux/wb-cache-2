0|8710|Public
40|$|CLAN (Collapsed LAN) {{is a high}} {{performance}} userlevel network targeted at the server room. It presents a simple low-level interface to applications: connectionoriented non-coherent shared memory for data transfer, and Tripwire, a user-level programmable CAM for synchronisation. This simple interface is implemented using only <b>hardware</b> <b>state</b> <b>machines</b> on the NIC, yet is flexible enough to support many different applications and communications paradigms...|$|R
40|$|Changing {{trends in}} technologies, notably cheaper and faster memory hierarchies, {{have made it}} {{worthwhile}} to revisit many hardware-oriented design decisions made in previous decades. Hardware-oriented designs, in which one uses special-purpose hardware to perform some dedi-cated function, are {{a response to a}} high cost of executing instructions out of memory; when caches are expensive, slow, and/or in scarce supply, it is a perfectly reasonable reaction to build <b>hardware</b> <b>state</b> <b>machines</b> that do not compete with user applications for cache space and do not rely on the performance of the caches. In contrast, when the caches are large enough to withstand competition between the application and operating system, the cost of executing operating system functions out of the memory subsystem decreases significantly, and software-oriented designs become viable. Software-oriented designs, in which one dispenses with special-purpose hardware and instead per-forms the same function entirely in software, offer dramatically increased flexibility over <b>hardware</b> <b>state</b> <b>machines</b> at a modest cost in performance. This dissertation explores a software-oriented design for a virtual memory management system. It shows not only that a software design is more flexible than hardware designs, but that a software scheme can perform as well as most hardware schemes. Eliminating dedicated special...|$|R
40|$|The use of {{reconfigurable}} hardware {{for network}} security applications has recently {{made great strides}} as Field-Programmable Gate Array (FPGA) devices have provided larger and faster resources. The performance of an Intrusion Detection System is dependent on two metrics: throughput and {{the total number of}} patterns that can fit on a device. In this paper, we consider the FPGA implementation details of the bit-split string-matching architecture. The bitsplit algorithm allows large <b>hardware</b> <b>state</b> <b>machines</b> to be converted into a form with much higher memory efficiency. We extend the architecture to satisfy the requirements of the IDS state-of-the-art. We show that the architecture can be effectively optimized for FPGA implementation. We have optimized the pattern memory system parameters and developed new interface hardware for communicating with an external controller. The overall performance (bandwidth * number of patterns) is competitive with other memory-based string matching architectures implemented in FPGA...|$|R
40|$|A {{hardware}} {{implementation model}} is proposed {{that can be}} used in the design of stream ciphers, block ciphers and cryptographic hash functions. The cryptographic finite <b>state</b> <b>machine</b> (CFSM) model is no mathematical tool, but a set of criteria that have to be met by a real <b>hardware</b> finite <b>state</b> <b>machine</b> that will be used in the implementation of a cryptographic algorithm. Diffusion is studied by means of the diffusion graph and dependence matrix. For the study of confusion differential cryptanalysis is used. status: publishe...|$|R
40|$|A {{hardware}} {{implementation model}} is proposed {{that can be}} used in the design of stream ciphers, block ciphers and cryptographic hash functions. The cryptographic finite <b>state</b> <b>machine</b> (CFSM) model is no mathematical tool, but a set of criteria that have to be met by a real <b>hardware</b> finite <b>state</b> <b>machine</b> that will be used in the implementation of a cryptographic algorithm. Diffusion is studied by means of the diffusion graph and dependence matrix. For the study of confusion differential cryptanalysis is used. In the paper the design of a high-speed cryptographic coprocessor is presented called Subterranean. This coprocessor can be used for both cryptographic pseudorandom sequence generation and cryptographic hashing. It can be implemented in a straightforward way as (part of) a chip. The small gate-delay allows high clockfrequencies, and even a moderate estimation of 20 MHz leads to a (stream-) encryption speed of 0. 3 Gbit/s and hashing speed of 0. 6 Gbit/sec. Keywords: Hardware Cryptograph [...] ...|$|R
40|$|Modern {{multi-core}} microprocessors cannot function anymore without memory caches, {{in multiple}} layers, and multiple caches per microprocessor core. These caches {{must be kept}} in-sync, so that modern multi-threaded software can safely make use of multiple cores. Keeping these various caches in sync is done with a cache coherence protocol, implemented in <b>hardware</b> using <b>state</b> <b>machines.</b> One of the challenges when developing cache coherence protocols is the validation whether it is functioning correctly. To do this efficiently {{it is important to}} be able to analyse parts of the cache coherence protocol separately, together with for instance the communication infrastructure that is used between the various caches. We have developed a proces to extract the communication aspects from cache coherence protocols from a protocol description, en turn these into a more compact <b>state</b> <b>machine.</b> We have implemented this process in a tool, that makes it possible to minimize Gem 5 <b>state</b> <b>machines.</b> The output of this tool can then be used for subsequent research. With the results we have achieved with this tool we have supported the hypothesis that minimization of cache coherence protocols can be done automatically...|$|R
40|$|This thesis {{establishes}} a scalable multi-user workflow {{for the operation}} of a highly configurable, large-scale neuromorphic hardware platform. The resulting software framework provides unified low-level as well as parallel high-level access. The latter is realized by an efficient abstract neural network description library, an automated translation of networks into hardware specific configurations and an experiment server infrastructure responsible for scheduling and executing experiments. Scalability, manual guidance and a broad support for handling hardware imper- fections render the model translation process suitable for large networks as well as large-scale neuromorphic systems. Networks with local connectivity, random networks and cortical column models are explored to study the topological aptitude of the neuromorphic platform and to benchmark the workflow. Depending on the model, performance improvements {{of more than two}} orders of magnitude have been achieved over a previous implementation. Additionally, an automated defect assessment for hardware synapses is introduced, indicating that most synapses are available for model emulation. In a second study, a tempotron-based <b>hardware</b> liquid <b>state</b> <b>machine</b> has been developed and applied to different tasks, including a memory challenge and digit recognition. The trained tempotron inherently compensates for fixed pattern variations making the setup suitable for analog neuromorphic hardware. The achieved performance is comparable to reference software simulations...|$|R
5000|$|DirectX 8.0, {{released}} in November, 2000, introduced programmability {{in the form}} of vertex and pixel shaders, enabling developers to write code without worrying about superfluous <b>hardware</b> <b>state.</b> The complexity of the shader programs depended on the complexity of the task, and the display driver compiled those shaders to instructions that could be understood by the hardware. Direct3D 8.0 and its programmable shading capabilities were the first major departure from an OpenGL-style fixed-function architecture, where drawing is controlled by a complicated <b>state</b> <b>machine.</b> Direct3D 8.0 also eliminated DirectDraw as a separate API. Direct3D subsumed all remaining DirectDraw API calls still needed for application development, such as Present (...) , the function used to display rendering results.|$|R
40|$|<b>State</b> <b>machines</b> consume {{and process}} actions {{complementary}} to programs issuing actions. <b>State</b> <b>machines</b> maintain a <b>state</b> and reply with a boolean response to each action in their interface. As <b>state</b> <b>machines</b> offer {{a service to}} programs, their interface is also called a service interface. <b>State</b> <b>machines</b> can be combined with several natural operators, thus giving rise to a <b>state</b> <b>machine</b> calculus. <b>State</b> <b>machines</b> are used for abstract data type modeling...|$|R
40|$|A {{wide range}} of {{software}} units can be classified as <b>state</b> <b>machines.</b> We extend conventional <b>state</b> <b>machine</b> notations by adding regular expressions of events and unions of source <b>states</b> to <b>state</b> <b>machine</b> transitions. Reusable software components are generated from these extended <b>state</b> <b>machine</b> specifications. Component specification and generation are illustrated in Java. Keywords: finite <b>state</b> <b>machine,</b> regular expression, code generation, component, Java. ...|$|R
40|$|AbstractState {{machines}} consume {{and process}} actions complementary to programs issuing actions. <b>State</b> <b>machines</b> maintain a <b>state</b> and reply with a boolean response to each action in their interface. As <b>state</b> <b>machines</b> offer {{a service to}} programs, their interface is also called a service interface. <b>State</b> <b>machines</b> can be combined with several natural operators, thus giving rise to a <b>state</b> <b>machine</b> calculus. <b>State</b> <b>machines</b> are used for abstract data type modeling...|$|R
40|$|Abstract. The paper {{deals with}} design and {{transformation}} methodology of autosynchronous <b>state</b> <b>machines.</b> The {{result is the}} design methodology for autosynchronous <b>state</b> <b>machines</b> with one-hot and Gray encodings. On {{the basis of their}} simulation models the timing parameters are defined and conditions for the correct behavior are pointed out. In order to simplify the design of these <b>state</b> <b>machines,</b> the transformation methodology of synchronous <b>state</b> <b>machine</b> in VHDL at RTL level to autosynchronous <b>state</b> <b>machine</b> is designed. These transformed <b>state</b> <b>machines</b> are compared in their chip area, power consumption and timing...|$|R
40|$|The Flexible Peripheral Component Interconnect (PCI) Input/Output (I/O) Card is an {{innovative}} circuit board that provides functionality to interface between {{a variety of}} devices. It supports user-defined interrupts for interface synchronization, tracks system faults and failures, and includes checksum and parity evaluation of interface data. The card supports up to 16 channels of high-speed, half-duplex, low-voltage digital signaling (LVDS) serial data, and can interface combinations of serial and parallel devices. Placement of a processor within the {{field programmable gate array}} (FPGA) controls an embedded application with links to host memory over its PCI bus. The FPGA also provides protocol stacking and quick digital signal processor (DSP) functions to improve host performance. <b>Hardware</b> timers, counters, <b>state</b> <b>machines,</b> and other glue logic support interface communications. The Flexible PCI I/O Card provides an interface for a variety of dissimilar computer systems, featuring direct memory access functionality. The card has the following attributes: 8 / 16 / 32 -bit, 33 -MHz PCI r 2. 2 compliance, Configurable for universal 3. 3 V/ 5 V interface slots, PCI interface based on PLX Technology's PCI 9056 ASIC, General-use 512 K 16 SDRAM memory, General-use 1 M 16 Flash memory, FPGA with 3 K to 56 K logical cells with embedded 27 K to 198 K bits RAM, I/O interface: 32 -channel LVDS differential transceivers configured in eight, 4 -bit banks; signaling rates to 200 MHz per channel, Common SCSI- 3, 68 -pin interface connector...|$|R
5000|$|Hierarchical <b>state</b> <b>machines</b> are finite <b>state</b> <b>machines</b> whose <b>states</b> {{themselves}} can be other machines. Since a communicating finite <b>state</b> <b>machine</b> {{is characterized by}} concurrency, the most notable trait in a communicating hierarchical <b>state</b> <b>machine</b> is the coexistence of hierarchy and concurrency. This had been considered highly suitable as it signifies stronger interaction inside the machine.|$|R
50|$|The request {{processor}} {{consists of}} the server process' main loop {{and a number of}} <b>state</b> <b>machines.</b> <b>State</b> <b>machines</b> are based on a simple language developed for PVFS that manage concurrency within the server and client. A <b>state</b> <b>machine</b> consists of a number of states, each of which either runs a C state action function or calls a nested (subroutine) <b>state</b> <b>machine.</b> In either case return codes select which state to go to next. State action functions typically submit a job via the job layer which performs some kind of I/O via Trove or BMI. Jobs are non-blocking, so that once a job is issued the <b>state</b> <b>machine's</b> execution is deferred so that another <b>state</b> <b>machine</b> can run servicing another request. When Jobs are completed the main loop restarts the associated <b>state</b> <b>machine.</b> The request processor has <b>state</b> <b>machines</b> for each of the various request types defined in the PVFS request protocol plus a number of nested <b>state</b> <b>machines</b> used internally. The <b>state</b> <b>machine</b> architecture makes it relatively easy to add new requests to the server in order to add features or optimize for specific situations.|$|R
40|$|Abstract – In this paper, {{we define}} the “correctness ” of a <b>state</b> <b>machine</b> {{based on a}} {{discussion}} of the “result ” yielding from its final states. For simplicity, we define a <b>state</b> <b>machine</b> called a “calculating type <b>state</b> <b>machine</b> ” that can calculate a simple issue and show some examples of correct calculating type <b>state</b> <b>machines...</b>|$|R
40|$|Abstract. The {{notation}} of <b>state</b> <b>machines</b> {{is widely}} adopted as a formalism {{to describe the}} behaviour of systems. Usually, multiple <b>state</b> <b>machine</b> models can be developed for the very same software system. Some of these models {{might turn out to}} be equivalent, but, in many cases, different <b>state</b> <b>machines</b> describing the same system also differ in their level of abstraction. In this paper, we present an approach to actually measure the abstractness level of <b>state</b> <b>machines</b> w. r. t. a given implemented software system. A <b>state</b> <b>machine</b> is considered to be less abstract when it is conceptionally closer to the implemented system. In our approach, this distance between <b>state</b> <b>machine</b> and implementation is measured by applying coverage criteria known from software mutation testing. Abstractness of <b>state</b> <b>machines</b> can be considered as a new metric. As for other metrics as well, a known value for the abstractness of a given <b>state</b> <b>machine</b> allows to assess its quality in terms of a simple number. In model-based software development projects, the abstract metric can help to prevent model degradation since it can actually measure the semantic distance from the behavioural specification of a system in form of a <b>state</b> <b>machine</b> to the current implementation of the system. In contrast to other metrics for <b>state</b> <b>machines,</b> the abstractness cannot be statically computed based on the <b>state</b> <b>machine’s</b> structure, but requires to execute both <b>state</b> <b>machine</b> and corresponding system implementation. The article is published in the author’s wording.  </p...|$|R
3000|$|Adjust {{the final}} <b>state</b> <b>machines</b> and approve the {{compatibility}} between scenarios and <b>state</b> <b>machines</b> {{to ensure that}} the behavior of the final <b>state</b> <b>machine</b> diagrams reproduce the information contained in the scenarios (Figs.  5, 6) [...]...|$|R
40|$|Abstract: We {{introduce}} {{the concepts of}} T-generalized <b>state</b> <b>machines</b> and coverings of products of them. Also some of algebraic properties of them are investigated. Finely some products such as direct sum and sum of T-generalized <b>state</b> <b>machines</b> are introduced. An interesting distributive property of cascade product over the sum of T-generalized <b>state</b> <b>machines</b> concern to covering of T-generalized <b>state</b> <b>machines</b> is stablished...|$|R
40|$|In {{this paper}} we present {{semantic}} profiles for UML 2 <b>state</b> <b>machines,</b> {{which are based}} directly upon {{the structure of a}} <b>state</b> <b>machine</b> model, without requiring flattening or other transformations on these models. The approach addresses many of the semantic problems identified for <b>state</b> <b>machines,</b> and provides a basis for semantic analysis and proof of behavioural compatibility between <b>state</b> <b>machines.</b> ...|$|R
5000|$|The term [...] "UML state machine" [...] {{can refer}} to two kinds of state machines: {{behavioral}} <b>state</b> <b>machines</b> and protocol <b>state</b> <b>machines.</b> Behavioral <b>state</b> <b>machines</b> {{can be used to}} model the behavior of individual entities (e.g., class instances). Protocol <b>state</b> <b>machines</b> are used to express usage protocols and can be used to specify the legal usage scenarios of classifiers, interfaces, and ports.|$|R
50|$|Because the {{internal}} {{structure of a}} composite state can be arbitrarily complex, any hierarchical <b>state</b> <b>machine</b> {{can be viewed as}} an internal structure of some (higher-level) composite state. It is conceptually convenient to define one composite state as the ultimate root of <b>state</b> <b>machine</b> hierarchy. In the UML specification, every <b>state</b> <b>machine</b> has a top state (the abstract root of every <b>state</b> <b>machine</b> hierarchy), which contains all the other elements of the entire <b>state</b> <b>machine.</b> The graphical rendering of this all-enclosing top state is optional.|$|R
50|$|All <b>state</b> <b>machine</b> formalisms, {{including}} UML <b>state</b> <b>machines,</b> universally {{assume that}} a <b>state</b> <b>machine</b> completes processing of each event before it can start processing the next event. This model of execution is called run to completion, or RTC.|$|R
2500|$|A {{deterministic}} finite <b>state</b> <b>machine</b> or acceptor deterministic finite <b>state</b> <b>machine</b> is a quintuple , where: ...|$|R
40|$|UML <b>state</b> <b>machines</b> {{provide an}} {{operational}} {{view of the}} behavior of software systems. However, properties of the execution history of <b>state</b> <b>machines</b> cannot be expressed modularly. This often leads to model elements addressing the same concern scattered all over the machine. We present an initial approach to aspect-oriented <b>state</b> <b>machines,</b> which show considerably better modularity in designs of history dependent behavior than normal UML <b>state</b> <b>machines...</b>|$|R
50|$|Note, however, that RTC {{does not}} mean that a <b>state</b> <b>machine</b> has to monopolize the CPU until the RTC step is complete. The {{preemption}} restriction only applies to the task context of the <b>state</b> <b>machine</b> that is already busy processing events. In a multitasking environment, other tasks (not related to the task context of the busy <b>state</b> <b>machine)</b> can be running, possibly preempting the currently executing <b>state</b> <b>machine.</b> As long as other <b>state</b> <b>machines</b> do not share variables or other resources with each other, there are no concurrency hazards.|$|R
40|$|In this paper, {{we present}} novel notions of {{reentrant}} <b>state</b> <b>machines</b> and reentrant statecharts, which are extensions of traditional <b>state</b> <b>machines</b> and statecharts {{with the addition}} of concurrent syntax and semantics. Reentrant <b>state</b> <b>machines</b> can provide efficient concurrency support for statechart-based real-time tasks by interleaving the execution of concurrent tasks. With its well-defined syntax and semantics, the reentrant <b>state</b> <b>machine</b> is able to switch among tasks on an eventby-event basis. By keeping track of task-specific information about concurrent tasks, the reentrant <b>state</b> <b>machine</b> can ensure correct order-dependent state transitions for each individual task. Based on the notion of reentrant <b>state</b> <b>machines,</b> reentrant statecharts provide a compact and highly expressive means for constructing detailed concurrent behavior models...|$|R
40|$|Abstract. UML <b>state</b> <b>machines</b> {{are widely}} used for {{modeling}} software behavior. However, state-crosscutting behaviors, such as execution history dependence or synchronization (either within a single <b>state</b> <b>machine</b> or between different concurrently active <b>state</b> <b>machines)</b> are hard to model as their realizations are dispersed throughout the <b>state</b> <b>machine</b> or even several <b>state</b> <b>machines.</b> We present High-Level Aspects (HiLA) for UML <b>state</b> <b>machines</b> to address this problem. The HiLA language facilitates modeling cross-cutting behaviors in one single place and separately from the base machines, and thus improves the modularity of the software design. It provides facilities for specifying multiple history-dependent and concurrent aspects that extend the behavior of base machines in a straightforward, mostly declarative style; it therefore allows the designer to build models {{at a high level}} of abstraction. Furthermore, HiLA provides aspects that constrain or modify the interactions between multiple independent <b>state</b> <b>machines.</b> ...|$|R
40|$|Classical and quantum {{parallelism}} {{are deeply}} different, {{although it is}} sometimes claimed that quantum Turing machines are nothing but special examples of classical probabilistic machines. We introduce the concepts of deterministic <b>state</b> <b>machine,</b> classical probabilistic <b>state</b> <b>machine</b> and quantum <b>state</b> <b>machine.</b> On this basis, we discuss the question: To what extent can quantum <b>state</b> <b>machines</b> be simulated by classical probabilistic <b>state</b> <b>machines?</b> Each <b>state</b> <b>machine</b> is devoted to a single task determined by its program. Real computers, however, behave differently, being able to solve different kinds of problems. This capacity can be modeled, in the quantum case, by the mathematical notion of abstract quantum computing machine, whose different programs determine different quantum <b>state</b> <b>machines.</b> The computations of abstract quantum computing machines can be linguistically described by the formulas of a particular form of quantum logic, termed quantum computational logic...|$|R
50|$|A <b>state</b> <b>machine</b> {{can also}} have a {{hierarchy}} {{in the sense that}} states can have sub <b>state</b> <b>machines.</b> Similar to the structure this can be extended to arbitrary depth.For details of the semantics of hierarchical <b>state</b> <b>machines</b> we refer to the original book.|$|R
40|$|In {{this paper}} we {{introduced}} {{the concept of}} interval neutrosophic finite <b>state</b> <b>machine,</b> interval neutrosophic finite switchboard <b>state</b> <b>machine</b> using the notion of interval neutrosophic set. We also introduced the concept of homomorphism and strong homomorphism of interval neutrosophic finite <b>state</b> <b>machine...</b>|$|R
40|$|Aspect-oriented {{modeling}} (AOM) is {{a relatively}} recent and very active field of research, whose application has, however, been limited in practice. AOM is assumed to yield several potential benefits such as enhanced modularization, easier evolution, increased reusability, and improved readability of models, as well as reduced modeling effort. However, credible, solid empirical evidence of such benefits is lacking. We evaluate the “readability” of <b>state</b> <b>machines</b> when modeling crosscutting behavior using AOM and more specifically AspectSM, a recently published UML profile. This profile extends the UML <b>state</b> <b>machine</b> notation with mechanisms to define aspects using <b>state</b> <b>machines.</b> Readability is indirectly measured through defect identification and fixing rates in <b>state</b> <b>machines,</b> and the scores obtained when answering a comprehension questionnaire about the system behavior. With AspectSM, crosscutting behavior is modeled using so-called “aspect state machines”. Their readability is {{compared with that of}} system <b>state</b> <b>machines</b> directly modeling crosscutting and standard behavior together. An initial controlled experiment and a much larger replication were conducted with trained graduate students, in two different institutions and countries, to achieve the above objective. We use two baselines of comparisons—standard UML <b>state</b> <b>machines</b> without hierarchical features (flat <b>state</b> <b>machines)</b> and standard <b>state</b> <b>machines</b> with hierarchical/concurrent features (hierarchical <b>state</b> <b>machines).</b> The results showed that defect identification and fixing rates are significantly better with AspectSM than with both flat and hierarchical <b>state</b> <b>machines.</b> However, in terms of comprehension scores and inspection effort, no significant difference was observed between any of the approaches. Results of the experiments suggest that one should use, when possible, aspect <b>state</b> <b>machines</b> along with hierarchical and/or concurrent features of UML <b>state</b> <b>machines</b> to model crosscutting behaviors...|$|R
40|$|Dynamic {{modeling}} of object-oriented software {{makes use of}} scenario diagrams, i. e. descriptions of particular uses of a system in terms of message flow between the objects belonging to the system. Such diagrams help the designer to specify the general behavior of objects as <b>state</b> <b>machines</b> or as collections of methods. Several techniques are discussed for building automated tool support for the dynamic modeling aspects of object-oriented software development. The discussed techniques include synthesis of <b>state</b> <b>machines</b> and method descriptions {{on the basis of}} scenario diagrams, constructing scenario diagrams with the support of existing <b>state</b> <b>machines,</b> visualizing the run-time behavior of an object system, extracting <b>state</b> <b>machines</b> of objects from running systems, consistency checking between scenario diagrams and <b>state</b> <b>machines,</b> automated simplification of <b>state</b> <b>machines</b> using OMT notation, and automated layout for <b>state</b> <b>machines.</b> 1 Introduction The basic problem of any software design [...] ...|$|R
25|$|The Unified Modeling Language has a {{notation}} {{for describing}} <b>state</b> <b>machines.</b> UML <b>state</b> <b>machines</b> overcome {{the limitations of}} traditional finite <b>state</b> <b>machines</b> while retaining their main benefits. UML <b>state</b> <b>machines</b> introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML <b>state</b> <b>machines</b> have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both {{the state of the}} system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.|$|R
50|$|The <b>state</b> <b>machine</b> {{actually}} {{controls the}} behavior of the organism. Since it is a feed forward <b>state</b> <b>machine,</b> the machine responds to future events predicted from past data.|$|R
50|$|For {{concurrent}} {{software and}} systems, Petri nets, process algebra, and finite <b>state</b> <b>machines</b> (which {{are based on}} automata theory - see also virtual finite <b>state</b> <b>machine</b> or event driven finite <b>state</b> <b>machine)</b> allow executable software specification {{and can be used}} to build up and validate application behavior.|$|R
