25|1039|Public
5000|$|In {{terms of}} <b>functionality,</b> <b>software</b> varies largely in which formats it can record {{and in what}} quality: ...|$|E
5000|$|Wiki {{software}} can include features {{that come with}} traditional content management systems, such as calendars, to-do lists, blogs and discussion forums. All of these can either be stored via versioned wiki pages, or simply be a separate piece of <b>functionality.</b> <b>Software</b> that supports blogs with wiki-style editing and versioning is sometimes known as [...] "bliki" [...] software.|$|E
50|$|The {{most common}} use of mockups in {{software}} development {{is to create}} user interfaces that show the end user what the software will look like without having to build the software or the underlying <b>functionality.</b> <b>Software</b> UI mockups can range from very simple hand drawn screen layouts, through realistic bitmaps, to semi functional user interfaces developed in a software development tool.|$|E
40|$|Abstract. A new {{university}} {{information system}} that provides electronic services for both university management and students {{was developed for}} iKnow project and implemented at Universities in Macedonia. It is an eStudent system enabling complete electronic functioning of a University, rendering paper documents obsolete. The system is web based and implements {{state of the art}} modular service oriented technologies. This paper presents the modules and <b>functionalities,</b> <b>software</b> and database architecture...|$|R
40|$|This {{document}} {{describes the}} implementation of the HOPE Aggregator Infrastructure in terms of:. Core <b>Functionalities.</b> <b>Software</b> Tools for Quality Control and Metadata Enrichment. HW & SW requirements After an introduction to the general characteristics of the HOPE implementation, the functionalities offered by this Release 2. 0 are presented. Then, the characteristics of the software tools available for Aggregator Administration and Data Curation are introduced. A further section reports the hardware and software configuration of the underlying system...|$|R
30|$|The {{method is}} {{suitable}} if a minimally invasive computational implementation is desired and it exploits existing <b>functionality</b> on <b>software</b> used to model hydrocarbon production systems.|$|R
40|$|Bachelor's {{thesis is}} bent on {{creation}} control software for spectral analyzer HP 89410 A. The first part offers overview {{capabilities of the}} analyzer and principle communication over the GPIB, second part serves to presentation to the problems graphical programming method and either as manual to control software with explanation of meaning individual entries. At last third part is introduced example of validation measure for check <b>functionality</b> <b>software...</b>|$|E
40|$|Bachelor’s {{thesis is}} bent on {{creation}} control software for multimeter and function generator. The {{first part of}} the thesis is focused on theoretical problems of individual parts of the whole measuring system and his parts. It show communication control unit with measuring instruments over the GPIB interface. Second part serves to presentation to problems graphical programming method and either as manual to control software for automated measuring system. At last third part are introduced examples of validation measure for check <b>functionality</b> <b>software...</b>|$|E
40|$|In {{light of}} {{unacceptable}} rates of software project failure agile development methodologies have achieved widespread industry prominence, {{aimed at reducing}} software project risks and improving the likelihood of project success. However, the highly collaborative processes embedded in agile methodologies may themselves introduce other risks. In particular, the fluid and diverse nature of agile team structures may mean that collaboration regarding {{what is to be}} delivered becomes more challenging. We have therefore developed a prototype tool intended to enable all stakeholders to have greater access to the features of the emerging system irrespective of their location, via remote feature management <b>functionality.</b> <b>Software</b> engineering experts have evaluated the initial prototype, verifying that it would enhance collaboration and is likely to assist teams in their handling of feature management...|$|E
5000|$|Behaviour {{diagrams}} {{are used}} to illustrate {{the behavior of a}} system, they are used extensively to describe the <b>functionality</b> of <b>software</b> systems. Some Behaviour diagrams are: ...|$|R
40|$|International audienceIn the {{proposed}} approach, smart sensors own {{the definition of}} the <b>software</b> <b>functionalities</b> but are no longer able to execute them locally. Thanks to the network, these <b>software</b> <b>functionalities</b> are sent to a smart sensor, to a smart actuator or to a common resource that has computation facilities...|$|R
5000|$|Some of {{the most}} common {{back-office}} <b>software</b> <b>functionality</b> options include: ...|$|R
40|$|Projects {{are failing}} {{more often than}} they are successful. After {{analyzing}} the courses behind, we found that many projects are missing their schedules, exceeding their budgets, delivering software products with poor quality {{and in many cases}} even poor <b>functionality.</b> <b>Software</b> development was misunderstood as only coding, whereas it is something before coding and continues even after deployment of software. In this paper we have mention the teaching methodologies to be made to SE education i. e, reducing the gap between research community and what is applied in industry. We have divided our paper mainly in two sections Course I: which will explain the concept of SE to be taught to students by faculty, Course II practical implementation of projects to be done by students under technical expert...|$|E
40|$|Abstract. The paper first {{introduces}} the basic concept of shortwave and ultra-short wave {{software defined radio}} (SDR) programs and the latest technical development in this area. Then we introduce {{the implementation of the}} shortwave and ultra-short wave SDR system and the workflow of each module. Based on a survey on the business markets and the technologies, we design a shortwave and ultra-short wave SDR system to meet the market requirement and technical standard. Its features include setup flexibility, scalability and operational simplicity. The design of <b>functionality,</b> <b>software,</b> hardware interface as well as parameters and targets is proposed accordingly. Finally, through engineering study and design, the proposed SDR system is expected to {{play a key role in}} emergency communications of urban areas to deal with some emergent events such as evacuation and sheltering...|$|E
40|$|Once {{supporting}} the electrical and mechanical <b>functionality,</b> <b>software</b> today became the main competitive advantage in products. However, in {{the companies that}} we study, {{the way in which}} software features are developed still reflects the traditional ‘requirements over the wall’ approach. As a consequence, individual departments prioritize what they believe is the most important and are unable to identify which features are regularly used – ‘flow’, there to be bought – ‘wow’, differentiating and that add value to customers, or which are regarded commodity. In this paper, and based on case study research in three large software-intensive companies, we (1) provide empirical evidence that companies do not distinguish between different types of features, which causes poor allocation of R&D efforts and suppresses innovation, and (2) develop a model in which we depict the activities for differentiating and working with different types of features and stakeholders...|$|E
5000|$|Package the <b>functionality</b> as a <b>software</b> library, {{rather than}} a service.|$|R
50|$|Network {{virtualization}} is {{categorized as}} either external virtualization, combining many networks {{or parts of}} networks into a virtual unit, or internal virtualization, providing network-like <b>functionality</b> to <b>software</b> containers on a single network server.|$|R
2500|$|Several MediaWiki {{extensions}} are [...] {{to extend}} the <b>functionality</b> of MediaWiki <b>software.</b>|$|R
40|$|Abstract: The {{first and}} most {{important}} step in solving any problem is understanding the problem well enough to create effective solutions. To this end, several software-related spacecraft accidents were studied to determine common systemic factors. Although the details in each accident were different, very similar factors related to flaws in the safety culture, the management and organization, and technical deficiencies were identified. These factors include complacency and discounting of software risk, diffusion of responsibility and authority, limited communication channels and poor information flow, inadequate system and software engineering (poor or missing specifications, unnecessary complexity and software <b>functionality,</b> <b>software</b> reuse without appropriate safety analysis, violation of basic safety engineering practices in the digital components), inadequate review activities, ineffective system safety engineering, flawed test and simulation environments, and inadequate human factors engineering. Each of these factors is discussed along with some recommendations on how to eliminate them in future projects. ...|$|E
40|$|Despite a large {{research}} effort, software distributed {{shared memory}} systems {{have not been}} widely used to run parallel applications across clusters of computers. The higher performance of hardware multiprocessors makes them the preferred platform for developing and executing applications. In addition, most applications are distributed only in binary format {{for a handful of}} popular hardware systems. Due to their limited <b>functionality,</b> <b>software</b> systems cannot directly execute the applications developed for hardware platforms. We have developed a system called Shasta that attempts to address the issues of efficiency and transparency that have hindered wider acceptance of software systems. Shasta is a distributed shared memory system that supports coherence at a fine granularity in software and can efficiently exploit small-scale SMP nodes by allowing processes on the same node to share data at hardware speeds. This paper focuses on our goal of tapping into large classes of commercially ava [...] ...|$|E
40|$|The {{first and}} most {{important}} step in solving any problem is understanding the problem well enough to create effective solutions. To this end, several software-related spacecraft accidents were studied to determine common systemic factors. Although the details in each accident were different, very similar factors related to flaws in the safety culture, the management and organization, and technical deficiencies were identified. These factors include complacency and discounting of software risk, diffusion of responsibility and authority, limited communication channels and poor information flow, inadequate system and software engineering (poor or missing specifications, unnecessary complexity and software <b>functionality,</b> <b>software</b> reuse without appropriate safety analysis, violation of basic safety engineering practices in the digital components), inadequate review activities, ineffective system safety engineering, flawed test and simulation environments, and inadequate human factors engineering. Each of these factors is discussed along with some recommendations on how to eliminate them in future projects...|$|E
5000|$|... all the <b>software</b> <b>functionality</b> of {{the larger}} XP 1024 with a smaller footprint.|$|R
50|$|Design {{characteristics}} {{allow for}} low cost by modularity and aiming to minimise electromechanical complexity by implementing most <b>functionality</b> in <b>software.</b> Additionally, {{the command and}} control software reuses over 75% of that developed for the PAAMS system.|$|R
5000|$|Define {{a set of}} {{routines}} able {{to stimulate}} as many <b>software</b> <b>functionalities</b> as possible; ...|$|R
40|$|We {{present an}} {{approach}} to the specification and implementation of provably safe software. It uses well-established tools and techniques that are usually employed to ensure correctness, rather than safety, of software. The approach comprises six steps, {{each of which is}} complemented by some proof obligations. For each step, the safety-related aspects are clearly elaborated. Thus, designers of safety-critical systems are given guidance that helps to avoid potentially dangerous gaps in the specification of the system's safety properties. 1 The General Setting The aim of this work is to support the development of provably safe software. Since a safety proof cannot be obtained by conventional software engineering techniques, we use formal methods to achieve this goal. Formal methods as they are used today mostly have the sole purpose of guaranteeing the correctness of software. This means, the software is to implement a certain <b>functionality.</b> <b>Software</b> safety, on the other hand, is not so m [...] ...|$|E
40|$|Apart from <b>functionality,</b> <b>software</b> {{system may}} have various {{nonfunctional}} requirements such as performance, security, reliability and schedulability. If we can predict {{how well the}} system will meet such requirements at an early phase of software development, we can significantly save the total development cost and time. Among non-functional requirements, performance is commonly required as the essential property of the system being developed. Therefore in the past, many analysis methods have been proposed but methods that can be practically performed in the design phase are rare. In this paper, we propose a simulationbased design-level performance analysis method based on aspectoriented programming. We separate performance models from design models, and then inject performance requirements into skeleton code generated from design models. Our method has the advantages that (1) code for the simulation is generated automatically or semi-automatically, and (2) it {{is relatively easy to}} modify design models or performance models independently when they are changed...|$|E
40|$|Abstract. The recent {{advances}} of humanoid robotics led to achievements {{in the development}} of human-like body parts and whole bodies, as well as of perceptual systems and schemes for behavior planning and learning. For this reason, a step further can be envisaged in the application of human-like robots as experimental tools in neuroscience, for carrying on experiments that may be difficult or impossible with human beings. This paper presents a human-like robotic manipulation platform for implementing neuro-physiological models of sensory-motor coordination in human grasping, with a particular attention to its sensory system. The proposed robotic system originates from requirements imposed by neurophysiological knowledge about the corresponding human system. Hence, it is composed of sensors and actuators replicating some level of anthropomorphism, in the physical structure and/or in the <b>functionality.</b> <b>Software</b> modules implement human-like basic mechanisms of perception and learning, on which more complex architectures are developed. The system is integrated so as to be as modular as possible and to be re-arranged for validating different hypotheses. 1...|$|E
40|$|The meta-environment is a {{flexible}} framework for language development, source code analysis and source code transformation. We highlight new features and demonstrate {{how the system}} supports key <b>functionalities</b> for <b>software</b> evolution: fact extraction, software analysis, visualization, and software transformatio...|$|R
50|$|Package {{diagrams}} can use packages containing {{use cases}} {{to illustrate the}} <b>functionality</b> of a <b>software</b> system.|$|R
5000|$|They {{specify the}} {{requirements}} and <b>functionalities</b> of the <b>software</b> of Catalan Name and Title Authority List.|$|R
40|$|An obfuscating {{transformation}} aims at confusing {{a program}} {{in order to make}} it more difficult to understand while preserving its <b>functionality.</b> <b>Software</b> protection and malware detection are two major applications of code obfuscation. Software developers use code obfuscation in order to defend their programs against attacks to the intellectual property, usually called malicious host attacks. In fact, by making the programs more difficult to understand it is possible to obstruct malicious reverse engineering – a typical attack to the intellectual property of programs. On the other side, malware writers usually obfuscate their malicious code in order to avoid detection. In this setting, the ability of code obfuscation to foil most of the existing detection techniques, such as misuse detection algorithms, relies in their purely syntactic nature that makes malware detection sensitive to slight modifications of programs syntax. In the software protection scenario, researchers try to develop sophisticated obfuscating techniques that are able to resist as many attacks as possible. In the malware detection scenario, on the other hand, it is important to design advanced detection algorithms i...|$|E
40|$|Every long-time running {{software}} system is {{sooner or later}} subject of a change. The most common reasons are different requests for a bug fixing or adding a new <b>functionality.</b> <b>Software</b> maintenance forms bigger part of software’s lifetime. Before applying a change, {{it is essential to}} correctly understand current state of affected system. Without all relevant information about both – system as whole and implementation details, a change can introduce new bugs or even break functionality of the system. In the paper we present contribution to program comprehension and following program change. Our method utilizes metalevel architectures to separate legacy application from evolution tool. The tool, placed in metalevel, uses aspect-oriented techniques to introduce a new code in the base level legacy application. This code manages casual connection between base level and metamodel, which is automatically created in metalevel. According to the base level program behavior, the metamodel is created and/or updated. Depending on the metamodel change, the base level program is extended with code which affects its functionality. Since the metamodel describes related implementation in higher level of abstraction, the method improves program comprehension and simplifies change...|$|E
40|$|Growing {{competition}} in the investment banking industry {{has given rise to}} increasing demand for high <b>functionality</b> <b>software</b> applications that can be developed {{in a short period of}} time. Yet delivering such applications creates a bottleneck in software development activities. This dilemma can be addressed when firms shift to development methods that emphasize software reusability. This article examines the productivity implications of object and repository-based integrated computer-aided software engineering (ICASE) software development in the context of a major investment bank 2 ̆ 7 s information systems strategy. The strategy emphasizes software reusability. Our empirical results, based on data from 20 projects that delivered software for the bank 2 ̆ 7 s New Trades Processing Architecture (NTPA), indicate an order of magnitude gain in software development productivity and the importance of reuse as a driver in realizing this result. In addition, results are presented on the extent of the learning that occurred over a two-year period after ICASE was introduced, and on the influence of the link between application characteristics and the ICASE tool set in achieving development performance. This work demonstrates the viability of the firm 2 ̆ 7 s IS strategy and offers new ideas for code reuse and software development productivity measurement that can be applied in development environments that emphasize reuse...|$|E
50|$|Forensic {{software}} engineering {{refers to the}} discipline of analyzing (and sometimes reconstructing) the <b>functionality</b> of <b>software</b> applications or services that have become defunct; are no longer accompanied by, or previously lacked, documentation; or for which the original engineers are no longer available.|$|R
50|$|Linux {{distributions}} {{which use}} the RPM Package Manager format for providing base <b>functionality</b> and <b>software</b> updates {{make use of}} MD5 and GPG to ensure content integrity. The hash values are packaged with the RPM file and verified when the package is installed.|$|R
5000|$|Linux {{distributions}} {{which use}} the Debian [...]deb package format for providing base <b>functionality</b> and <b>software</b> updates {{make use of}} GPG signatures to ensure content integrity. A signature is computed when the package is constructed and verified later when the package is installed.|$|R
