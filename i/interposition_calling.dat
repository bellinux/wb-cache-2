0|36|Public
40|$|Today’s {{programs}} run in hostile environments. An adversary {{attacking a}} running process may radically alter the program’s course of execution. Such attacks {{will be of}} little value to the adversary unless he can cause the program to affect the outside world by executing a system call. A fruitful line of research on system <b>call</b> <b>interposition</b> has investigated using security checks on system calls to harden computer systems. We propose a novel system <b>call</b> <b>interposition</b> system <b>called</b> Paladin. In Paladin system call accesscontrol decisions are made by policy handlers, i. e. reference monitor procedures, built into applications. This represents a fundamental perspective shift from previous system <b>call</b> <b>interposition</b> work. Paladin provides a mechanism with which developers harden their own software against attacks from a hostile execution environment. In contrast, previous system <b>call</b> <b>interposition</b> systems attempt to protect computers from untrusted application binaries. In such systems, polices are external to the application and written by third parties. ...|$|R
40|$|System <b>call</b> <b>interposition</b> is a {{powerful}} method for regulating and monitoring program behavior. A wide variety of security tools have been developed which use this technique. However, traditional system <b>call</b> <b>interposition</b> techniques are vulnerable to kernel attacks and have some limitations on effectiveness and transparency. In this paper, we propose a novel approach named VSyscall, which leverages virtualization technology to enable system <b>call</b> <b>interposition</b> outside the operating system. A system call correlating method is proposed to identify the coherent system calls belonging to the same process from the system call sequence. We have developed a prototype of VSyscall and implemented it in two mainstream virtual machine monitors, Qemu and KVM, respectively. We also evaluate the effectiveness and performance overhead of our approach by comprehensive experiments. The results show that VSyscall achieves effectiveness with a small overhead, and our experiments with six real-world applications indicate its practicality...|$|R
40|$|System <b>call</b> <b>interposition</b> {{allows the}} kernel {{security}} model to be extended. However, {{when combined with}} current operating systems, it is open to concurrency vulnerabilities leading to privilege escalation and audit bypass. We discuss the {{theory and practice of}} system call wrapper concurrency vulnerabilities, and demonstrate exploit techniques against GSWTK, Systrace, and CerbNG...|$|R
40|$|When an {{application}} reads private / sensitive information and subsequently communicates on an output channel {{such as a}} public file or a network connection, how can we ensure that the data written is free of private information? In this paper, we address this question in a practical setting {{through the use of}} a technique that we call “data sandboxing ”. Essentially, data sandboxing is implemented using the popular technique of system <b>call</b> <b>interposition</b> to mediate output channels used by a program. To distinguish between private and public data, the program is partitioned into two: one that contains all the instructions that handle sensitive data and the other containing the rest of the instructions. This partitioning is performed based on techniques from program slicing. When run together, these two programs collectively replace the original program. To address confidentiality, these programs are sandboxed with different system <b>call</b> <b>interposition</b> based policies. We discuss the design and implementation of a tool that enforces confidentiality policies on C programs using this technique. We also report our experiences in using our tool over several programs that handle confidential data. ...|$|R
40|$|In {{the age of}} coordinated malware {{distribution}} and zero-day exploits security becomes ever more important. This paper presents secuBT, a safe execution framework for the execution of untrusted binary code based on the fastBT dynamic binary translator. secuBT implements user-space virtualization using dynamic binary translation and adds a system <b>call</b> <b>interposition</b> framework to limit and guard the interoperability of binary code with the kernel. Fast binary translation is a key component to user-space virtualization. secuBT uses and extends fastBT, a generator for low-overhead, tablebased dynamic (just-in-time) binary translators. We discuss the most challenging sources of overhead and propose optimizations to further reduce these penalties. We argue for hardening techniques {{to ensure that the}} translated program cannot escape out of the user-space virtualization. An important feature of secuBT is that only translated code is executed. This ensures code validity and makes it possible to rewrite individual instructions. The system <b>call</b> <b>interposition</b> framework validates every system call and offers the choice to (i) allow it, (ii) abort the program, (iii) redirect to an user-space emulation. ...|$|R
2500|$|Successful nonviolent {{cross-border}} intervention projects {{include the}} Guatemala Accompaniment Project, Peace Brigades International and Christian Peacemaker Teams. Developed {{in the early}} 1980s, and originally inspired by the Gandhian Shanti Sena, the primary tools of these organisations have been nonviolent protective accompaniment, backed up by a global support network which can respond to threats, local and regional grassroots diplomatic and peacebuilding efforts, human rights observation and witnessing, and reporting. [...] In extreme cases, most of these groups are also prepared to do interpositioning: placing themselves between parties who are engaged or threatening to engage in outright attacks in one or both directions. [...] Individual and large group cases of <b>interpositioning,</b> when <b>called</b> for, have been remarkably effective in dampening conflict and saving lives.|$|R
40|$|Safe virtual {{execution}} (SVE) {{allows a}} host computer system {{to reduce the}} risks associated with running untrusted programs. SVE prevents untrusted programs from directly accessing system resources, thereby giving the host the ability to control how individual resources may be used. SVE is used in a variety of safety-conscious software systems, including the Java Virtual Machine (JVM), software fault isolation (SFI), system <b>call</b> <b>interposition</b> layers, and execution monitors. While SVE is the conceptual foundation for these systems, each uses a different implementation technology. The lack of a unifying framework for building SVE systems results in a variety of problems: many useful SVE systems are not portable and therefore are usable only on a limited number of platforms; code reuse among different SVE systems is often difficult or impossible; and building SVE systems from scratch can be both time consuming and error prone. To address these concerns, we have developed a portable, extensible framework for constructing SVE systems. Our framework, called Strata, is based on software dynamic translation (SDT), a technique for modifying binary programs as they execute. Strata is designed to be ported easily to new platforms and to date has been targeted to SPARC/Solaris, x 86 /Linux, and MIPS/IRIX. This portability ensures that SVE applications implemented in Strata are available {{to a wide variety of}} host systems. Strata also affords the opportunity for code reuse among different SVE applications by establishing a common implementation framework. Strata implements a basic safe virtual execution engine using SDT. The base functionality supplied by this engine is easily extended to implement specific SVE systems. In this paper we describe the organization of Strata and demonstrate its extension by building two SVE systems: system <b>call</b> <b>interposition</b> and stacksmashing prevention. To illustrate the use of the system <b>call</b> <b>interposition</b> extensions, the paper presents implementations of several useful security policies. 1...|$|R
40|$|This paper {{presents}} FOXP (computer FOrensic eXPerience), an {{open source}} project to support network Live Digital Forensics (LDF), where the network nodes run a Windows NT family Operating System (OS). In particular, the FOXP architecture {{is composed of}} a set of software sensors, once for every network node, that log node activities and then send these logs to a FOXP collector node; this collector node analyzes collected data and manages the sensors activities. Software sensors, implementing the technique <b>called</b> System <b>Call</b> <b>Interposition</b> for Win 32, intercepts all the kernel API (native API) invoked by the OS of the node. Thanks to the fine granularity of the logs, FOXP can intercept malicious activities. Centralized logs collected in the collector node, allow to detect coordinated-attacks on network nodes: attacks that would not be detectable with a single node analysis only. Note that the implemented System <b>Call</b> <b>Interposition</b> technique has allowed to intercept and redirect all of the 284 Windows XP system calls. The technique is exposed in detail and could be considered a contribution on its own. Finally, an overview of next steps to complete the FOXP project is provided...|$|R
40|$|Application sandboxes provide {{restricted}} execution {{environments that}} limit an application's access to sensitive OS resources. These systems are an increasingly popular method for limiting {{the impact of}} a compromise. While a variety of mechanisms for building these systems have been proposed, the most thoroughly implemented and studied are based on system <b>call</b> <b>interposition.</b> Current interpositionbased architectures offer a wide variety of properties that make them an attractive approach for building sandboxing systems. Unfortunately, these architectures also possess several critical properties that make their implementation error prone and limit their functionality. We presen...|$|R
5000|$|A property, in some {{object-oriented}} programming languages, {{is a special}} sort of class member, intermediate in functionality between a field (or data member) and a method. The syntax for reading and writing of properties is like for fields, but property reads and writes are (usually) translated to 'getter' and 'setter' method calls. The field-like syntax is easier {{to read and write}} than lots of method <b>calls,</b> yet the <b>interposition</b> of method <b>calls</b> [...] "under the hood" [...] allows for data validation, active updating (e.g., of GUI elements), or implementation of what may be called [...] " [...] fields".|$|R
5000|$|LSM was {{designed}} to provide {{the specific needs of}} everything needed to successfully implement a mandatory access control module, while imposing the fewest possible changes to the Linux kernel. LSM avoids the approach of system <b>call</b> <b>interposition</b> as used in Systrace because it does not scale to multiprocessor kernels and is subject to TOCTTOU (race) attacks. Instead, LSM inserts [...] "hooks" [...] (upcalls to the module) at every point in the kernel where a user-level system call is about to result in access to an important internal kernel object such as inodes and task control blocks.|$|R
30|$|A {{system for}} {{unscheduled}} system updates, called AutoPod, was presented by Potter et al. [17]. AutoPod {{is based on}} system <b>call</b> <b>interposition</b> and the chroot utility {{and is able to}} create file system namespaces, called pods. Every process in a pod can be offline-migrated to another physical machine by using a checkpoint mechanism. Unfortunately, AutoPod is bound to Debian Linux and cannot be used with other package managers. Furthermore, it also updates a system automatically, which could lead to problems in case of an incomplete update. In contrast to the presented solution, AutoPod is based on chroot, which is known for having several major security flaws in the past.|$|R
40|$|Abstract Execution of untrusted {{software}} can compromise a whole system. Tools for restricting access of software to system resources {{are essential for}} security maintenance. Operating systems should offer functionality for building tools which could run in user mode with no special privileges while providing full access control. Thus, they could {{be made available to}} any user in the system. In this paper we show ways of extending an operating system in order to provide such functionality. We present the changes introduced in the Linux kernel to offer the minimum functionality necessary for building such a tool. Using the new functionality we were able to code a program for controlling execution of untrusted software through system <b>call</b> <b>interposition...</b>|$|R
60|$|The {{temporary}} appointment by Parliament of the Supreme Council of India {{arose from}} an {{opinion that the}} Company, at that time at least, {{was not in a}} condition or not disposed to a proper exercise of the privileges which they held under their charter. It therefore behoved the Directors to be particularly attentive to their choice of Counsellors, on the expiration of the period during which their patronage had been suspended. The duties of the Supreme Council had been reputed of so arduous a nature as to require even a legislative <b>interposition.</b> They were <b>called</b> upon, by all possible care and impartiality, to justify Parliament at least as fully in the restoration of their privileges as the circumstances of the time had done in their suspension.|$|R
40|$|Operating system (OS) {{virtualization}} {{can provide}} {{a number of important}} benefits, including transparent migration of applications, server consolidation, online OS maintenance, and enhanced system security. However, the construction of such a system presents a myriad of challenges, even for the most cautious developer, that if overlooked may result in a weak, incomplete virtualization. We present a detailed discussion of key implementation issues in providing OS virtualization in a commodity OS, including system <b>call</b> <b>interposition,</b> virtualization state management, and race conditions. We discuss our experiences in implementing such functionality across two major versions of Linux entirely in a loadable kernel module without any kernel modification. We present experimental results on both uniprocessor and multiprocessor systems that demonstrate the ability of our approach to provide fine-grain virtualization with very low overhead...|$|R
40|$|Abstract. In this paper, {{we propose}} two {{new forms of}} Adaptive Programming. The first approach, AP-P, is an {{imperative}} approach that adds programming con-struct <b>called</b> <b>interposition</b> variables that can reduce boilerplate code in computa-tions over recursive data structures. Our current implementation of AP-P is called DemeterP and is provided as a standard Java annotation processor that generates AspectJ code. The second approach, AP-F, is a functional approach that param-eterizes a generic traversal with three sets of functions. These functions can be combined to modify traversal behavior to produce various functional transforma-tions and folds. Our current implementation of AP-F is called DemeterF and is provided as a Java library that relies on reflection. We describe the ideas behind the two approaches, discuss their implementations, {{and use them to}} solve some typical programming language related problems. ...|$|R
40|$|System <b>call</b> <b>interposition</b> is a {{powerful}} method for regulating and monitoring application behavior. In recent years, {{a wide variety of}} security tools have been developed that use this technique. This approach brings with it a host of pitfalls for the unwary implementer that if overlooked can allow his tool to be easily circumvented. To shed light on these problems, we present the lessons we learned in the course of several design and implementation cycles with our own system call interposition-based sandboxing tool. We first present some of the problems and pitfalls we encountered, including incorrectly replicating OS semantics, overlooking indirect paths to resources, race conditions, incorrectly subsetting a complex interface, and side effects of denying system calls. We then present some practical solutions to these problems, and provide general principles for avoiding the difficulties we encountered. ...|$|R
40|$|Markov-modulated Poisson {{processes}} (MMPPs) are stochastic {{models for}} fitting empirical traces for simulation, workload characterization and queueing analysis purposes. In this paper, we develop the first counting process fitting algorithm for the marked MMPP (M 3 PP), a generalization of the MMPP for modeling traces with events of multiple types. We initially explain how to fit two-state M 3 PPs to empirical traces of counts. We then propose a novel form of composition, <b>called</b> <b>interposition,</b> which enables the approximate superposition of several two-state M 3 PPs without incurring into state space explosion. Compared to exact superposition, {{where the state}} space grows exponentially {{in the number of}} composed processes, in interposition the state space grows linearly in the number of composed M 3 PPs. Experimental results indicate that the proposed interposition methodology provides accurate results against artificial and real-world traces, with a significantly smaller state space than superposed processes...|$|R
40|$|We propose an {{intrusion}} prevention {{system called}} WHIPS that controls, entirely in kernel mode, the invocation of the critical system calls for the Windows OS security. WHIPS is implemented as a kernel driver, also called kernel module, by using kernel structures of the Windows OS. It is integrated without requiring changes to either the kernel data structures or to the kernel algorithms. WHIPS is also transparent to the application processes that continue to work correctly without source code changes or recompilation. A working prototype has been implemented as a kernel extension and it is applicable to all the Windows NT family OS, e. g. Windows 2000 /XP/ 2003. The WHIPS first contribution is to apply the system <b>call</b> <b>interposition</b> technique to the Windows OS, which is not open source. It is not straightforward to apply this technique to Windows OS, also because Windows kernel structures are hidden from the developer, and furthermore, its kernel documentation is poor...|$|R
40|$|MBOX is a {{lightweight}} sandboxing mechanism for nonroot users in commodity OSes. MBOX’s sandbox usage model executes {{a program in}} the sandbox and prevents the program from modifying the host filesystem by layering the sandbox filesystem {{on top of the}} host filesystem. At the end of program execution, the user can examine changes in the sandbox filesystem and selectively commit them back to the host filesystem. MBOX implements this by interposing on system calls and provides a variety of useful applications: installing system packages as a non-root user, running unknown binaries safely without network accesses, checkpointing the host filesystem instantly, and setting up a virtual development environment without special tools. Our performance evaluation shows that MBOX imposes CPU overheads of 0. 1 – 45. 2 % for various workloads. In this paper, we present MBOX’s design, efficient techniques for interposing on system calls, our experience avoiding common system <b>call</b> <b>interposition</b> pitfalls, and MBOX’s performance evaluation. ...|$|R
40|$|Abstract—Inadvertent data {{disclosure}} by insiders is con-sidered {{as one of}} {{the biggest}} threats for corporate informa-tion security. Data loss prevention systems typically try to cope with this problem by monitoring access to confidential data and preventing their leakage or improper handling. Current solutions in this area, however, often provide limited means to enforce more complex security policies that for instance specify temporal or cardinal constraints on the execution of events. This paper presents UC 4 Win, a data loss prevention solution for Microsoft Windows operating systems that is based on the concept of data-driven usage control to allow such a fine-grained policy-based protection. UC 4 Win is capable of detecting and controlling data-loss related events at the level of individual function calls. This is done with function <b>call</b> <b>interposition</b> techniques to intercept application calls to the Windows API in combination with methods to track the flows of confidential data through the system. Keywords-data loss prevention; usage control; microsoft windows security; dynamic data flow tracking I...|$|R
40|$|Abstract. We propose an {{intrusion}} prevention {{system called}} WHIPS that controls, entirely in kernel mode, the invocation of the critical sys-tem calls for the Windows OS security. WHIPS is implemented as a kernel driver, also called kernel module, by using kernel structures of the Windows OS. It is integrated without requiring changes to either the kernel data structures or to the kernel algorithms. WHIPS is also transparent to the application processes that continue to work correctly without source code changes or recompilation. A working prototype has been implemented as a kernel extension and it is applicable to all the Windows NT family OS, e. g. Windows 2000 /XP/ 2003. The WHIPS first contribution is to apply the system <b>call</b> <b>interposition</b> technique to the Windows OS, which is not open source. It is not straightforward to apply this technique to Windows OS, also because Windows kernel structures are hidden from the developer, and furthermore, its kernel documenta-tion is poor. ...|$|R
40|$|Programmers {{and users}} of compute {{intensive}} scientific applications {{often do not}} want to (or even cannot) code load balancing and fault tolerance into their programs. The P / BEAM system [PL 95, PSLS 96] uses a global virtual name space to provide migration and rollback transparency in user space for distributed groups of processes on workstations. Applications always use the same virtual names for the operating system objects, independent of their current real location. The system calls are interposed and their parameters translated between the name spaces. Unlike other migration mechanisms, PBEAM does not require the applications to be written for a specific programming model or communication library. The first approach to execute applications in the virtual name space was to link the programs with a modified system library. Now, in this paper we describe design and implementation of a separate system <b>call</b> <b>interposition</b> process [Bol 97] that accesses the application via the debugging int [...] ...|$|R
40|$|Abstract. Programmers {{and users}} of compute {{intensive}} scientific applications {{often do not}} want to (or even cannot) code load balancing and fault tolerance into their programs. The P BEAM system [18] uses a global virtual name space to provide migration and rollback transparency in user space for distributed groups of processes on workstations. Applications always use the same virtual names for the operating system objects, independent of their current real location. The system calls are interposed and their parameters translated between the name spaces. Unlike other migration mechanisms, P BEAM does not require the applications to be written for a specific programming model or communication library. The first approach to execute applications in the virtual name space was to link the programs with a modified system library. Now, In this paper we describe design and implementation of a separate system <b>call</b> <b>interposition</b> process [3] that accesses the application via the debugging interface. The main advantage of this approach is that it can handle even unmodified (e. g. commercially bought) application programs. We compare measured performance figures with previous similar approaches [15, 20] and the modified system library. ...|$|R
40|$|During {{the last}} few years we have {{experienced}} a rise in malware that use so called drive-by web downloads to infect end-hosts. In response, several research efforts have proposed host-based mechanisms to prevent such attacks or to minimize their impact. These mechanisms sandbox the browser either through virtual machines (VMs) or via system <b>call</b> <b>interposition.</b> However, the effectiveness and usability of these techniques depend on the policies set to control either the browser’s system calls or the VM’s access to the host environment and the network. In this paper we present the first, as far as we know, interposition technique that dynamically modifies the policy ruleset to allow only system calls that originate from user requests while denying all other system calls. We do so by intercepting user GUI actions, parsing the contents of web pages downloaded by the user, and tracking the application state, safely, through stack tracing. Our evaluation results show that the proposed technique introduces limited overhead; 11. 8 % increase in latency and 13. 4 % decrease in throughput. Moreover, it generates no false positives and contains attacks against the browser itself as well as attacks on plugins and libraries used by the browser. ...|$|R
40|$|We {{present a}} {{consistency}} analysis approach {{to assist the}} Linux community in verifying the correctness of authorization hook placement in the Linux Security Modules (LSM) framework. The LSM framework consists {{of a set of}} authorization hooks inserted into the Linux kernel to enable additional authorizations to be performed (e. g., for mandatory access control). When compared to system <b>call</b> <b>interposition,</b> authorization within the kernel has both security and performance advantages, but it is more difficult to verify that placement of the LSM hooks ensures that all the kernel’s security-sensitive operations are authorized. Static analysis has been used previously to verified mediation (i. e., that some hook mediates access to a security-sensitive operation), but that work did not determine whether the necessary set of authorizations were checked. In this paper, we develop an approach to test the consistency of the relationships between security-sensitive operations and LSM hooks. The idea is that whenever a security-sensitive operation is performed as part of specifiable event, a particular set of LSM hooks must have mediated that operation. This work demonstrates that the number of events that impact consistency is manageable and that the notion of consistency is useful for verifying correctness. We describe our consistency approach for performing verification, the implementation of run-time tools that implement this approach, th...|$|R
40|$|Malware poses {{a serious}} threat to the Android ecosystem. Moreover, even benign {{applications}} can sometimes consti-tute security and privacy risks to their users, as they might contain vulnerabilities, or they might perform unwanted ac-tions. Previous research has shown that the current An-droid security model is not sufficient to protect against these threats, and several solutions have been proposed to enable the specification and enforcing of finer-grained security poli-cies. Unfortunately, many existing solutions suffer from sev-eral limitations: they require modifications to the Android framework, root access to the device, to create a modified version of an existing app that cannot be installed without enabling unsafe options, or they cannot completely sandbox native code components. In this work, we propose a novel approach that aims to sandbox arbitrary Android applications. Our solution, called Njas, works by executing an Android application within the context of another one, and it achieves sand-boxing by means of system <b>call</b> <b>interposition.</b> In this paper, we show that our solution overcomes major limitations that affect existing solutions. In fact, it does not require any modification to the framework, does not require root access to the device, and does not require the user to enable unsafe options. Moreover, the core sandboxing mechanism cannot be evaded by using native code components...|$|R
40|$|Grid {{computing}} promises {{gains in}} effective computational power, resource utilization, and resource accessibility, {{but in order}} to achieve these gains, organizations must deploy grid middleware that, in most cases, does not adhere to fundamental security principles. This paper introduces a new lightweight grid middleware called Mesh, which is based on the addition of a single sign-on capability to the built-in public key authentication mechanism of SSH using system <b>call</b> <b>interposition.</b> The initial Mesh implementation is compatible with approximately 90 % of the world’s SSH servers and any SSH client that supports public key authentication. Resources may be added to a Mesh-based grid {{in a matter of minutes}} using just five small files and two environment variable settings. Mesh adheres to fundamental security principles and was designed to be compatible with strong security mechanisms including two-factor authentication, SSH bastions, and restrictive firewalls. Mesh uses a remote command model, which is based on the syntax and commands already understood by users, thus requires no additional knowledge to utilize effectively. Several existing services have been integrated with Mesh to provide resource discovery and query, high performance file transfer, and job management. Categories and Subject Descriptors D. 4. 6 [Operating Systems]: Security and Privacy Protection–access controls, authentication; C. 2. 4 [Communication/Networking an...|$|R
40|$|We present runtime {{tools to}} assist the Linux {{community}} in verifying the correctness of the Linux Security Modules (LSM) framework. The LSM framework consists {{of a set of}} authorization hooks inserted into the Linux kernel to enable additional authorizations to be performed (e. g., for mandatory access control). When compared to system <b>call</b> <b>interposition,</b> authorization within the kernel has both security and performance advantages, but it is more difficult to verify that placement of the LSM hooks ensures that all the kernel’s security-sensitive operations are authorized. We have examined both static and runtime analysis techniques for this verification, and have found them to be complementary. Static analysis is more complex to implement and tends to generate more false positives, but coverage of all type-safe execution paths is possible. Runtime analysis lacks the code and input coverage of static analysis, but tends to be simpler to gather useful information. The major simplifying factor in our runtime verification approach is that we can leverage {{the fact that most of}} the LSM hooks are properly placed to identify misplaced hooks. Our runtime verification tools collect the current LSM authorizations and find inconsistencies in these authorizations. We describe our approach for performing runtime verification, the design of the tools that implement this approach, and the anomalous situations found in an LSM-patched Linux 2. 4. 16 kernel. ...|$|R
40|$|Several new {{approaches}} for detecting malicious attacks on computer systems and/or confining untrusted or malicious applications have emerged {{over the past}} several years. These techniques often rely on the fact that when a system is attacked from a remote location over a network, damage can ultimately be inflicted only via system calls made by processes running on the target system. This factor has lead to a surge of interest in developing infrastructures that enable secure interception and modification of system calls made by processes running on the target system. Most known approaches for solving this problem have relied on an in-kernel approach, where the interception mechanisms as well as the intrusion detection/confinement systems are implemented within the operating system kernel. We explore an alternative approach that uses mechanisms provided by most variants of the UNIX operating system to implement system <b>call</b> <b>interposition</b> at user level, where the system calls made by one process are monitored by another process. Some of the key problems that need to solved in developing such an approach are: providing adequate set of capabilities in the infrastructure, portability of the security enhancements and the infrastructure itself across different operating systems, and minimizing performance overheads associated with interception {{for a wide range of}} applications. We present a solution that satisfactorily addresses these issues, and can thus lead to a platform for rapid development and deployment of robust intrusion detectors, confinement systems and other application-specific security enhancements. ...|$|R
40|$|Many {{software}} applications extend their functionality by dynamically loading executable components into their allocated address space. Such components, exemplified by browser plugins and other software add-ons, not only enable reusability, but also promote programming simplicity, as they {{reside in the}} same address space as their host application, supporting easy sharing of complex data structures and pointers. However, such components are also often of unknown provenance and quality and may be riddled with accidental bugs or, in some cases, deliberately malicious code. Statistics show that such component failures account for {{a high percentage of}} software crashes and vulnerabilities. Enabling isolation of such fine-grained components is therefore necessary to increase the stability, security and resilience of computer programs. This thesis addresses this issue by showing how host applications can create isolation domains for individual components, while preserving the benefits of a single address space, via a new architecture for software isolation called LibVM. Towards this end, we define a specification which outlines the functional requirements for LibVM, identify the conditions under which these functional requirements can be met, define an abstract Application Programming Interface (API) that encompasses the general problem of isolating shared libraries, thus separating policy from mechanism, and prove its practicality with two concrete implementations based on hardware virtualization and system <b>call</b> <b>interpositioning,</b> respectively. The results demonstrate that hardware isolation minimises the difficulties encountered with software based approaches, while also reducing the size of the trusted computing base, thus increasing confidence in the solution’s correctness. This thesis concludes that, not only is it feasible to create such isolation domains for individual components, but that it should also be a fundamental operating system supported abstraction, which would lead to more stable and secure applications...|$|R
40|$|Software updates are an {{integral}} part of the software development and maintenance process, but unfortunately they present a high risk, as new releases often introduce new bugs and security vulnerabilities; as a consequence, many users refuse to upgrade their software, relying instead on outdated versions, which often leave them exposed to known software bugs and security vulnerabilities. In this thesis we propose a novel multi-version execution approach, a variant of N-version execution, for improving the software update process. Whenever a new program update becomes available, instead of upgrading the software to the newest version, we run the new version in parallel with the old one, and carefully synchronise their execution to create a more reliable multi-version application. We propose two different schemes for implementing the multi-version execution technique—via failure recovery and via transparent failover—and we describe two possible designs for implementing these schemes: Mx, focused on recovering from crashes caused by the faulty software updates; and Varan, focused on running a large number of versions in parallel with a minimal performance overhead. Mx uses static binary analysis, system <b>call</b> <b>interposition,</b> lightweight checkpointing and runtime state manipulation to implement a novel fault recovery mechanism, which enables the recovery of the crashing version using the code of the other, non-crashing version. We have shown how Mx can be applied successfully to recover from real crashes in several real applications. Varan combines selective binary rewriting with high-performance event streaming to significantly reduce performance overhead, without sacrificing the size of the trusted computing base, nor flexibility or ease of debugging. Our experimental evaluation has demonstrated that Varan can run C 10 k network servers with low performance overhead, and can be used in various scenarios such as transparent failover and live sanitisation. Open Acces...|$|R
40|$|It {{has become}} {{extremely}} difficult to distinguish a benign application from a malicious one {{as the number of}} untrusted applications on the Internet increases rapidly every year. In this project, we develop a lightweight application confinement mechanism for Linux systems in order to aid most users to increase their confidence in various applications that they stumble upon and use on a daily basis. Developed sandboxing facility monitors a targeted application’s activity and imposes restrictions on its access to operating system resources during its execution. Using a simple but expressive policy language, users are able to create security policies. During the course of the traced application’s execution, sandboxing facility makes execution decisions according to the security policy specified and terminates the traced application if necessary. In the case of an activity that is not covered by the policy, the facility asks for user input through an user interface with a simple human readable format of the activity and uses that user input to make execution decisions and to improve the security policy. Our ultimate goal is to create a facility such that even casual users with minimal technical knowledge can use the tool without getting overwhelmed by it. We base our tool on system <b>call</b> <b>interposition</b> which has been a popular research area over the past fifteen years. Developed sandboxing facility offers an user-friendly, easy to use user-interface. It monitors the given application and detects activities that might possibly be system intrusions. Moreover, the tool offers logging and auditing mechanisms for post-execution analysis. We present our evaluation of the tool in terms of performance and overhead it generates when confining applications. We conclude that developed system is successful in detecting abnormal application activity according to specified security policies. It has been obtained that the tool adds a significant overhead to the target applications. However, this overhead does not pose usability issues as our target domain is personal use cases with small applications...|$|R
40|$|Subject of {{this thesis}} are {{the design and}} {{implementation}} of an ad hoc Grid infrastructure. The vision of an ad hoc Grid further evolves conventional service-oriented Grid systems into a more robust, more flexible and more usable environment that is still standards compliant and interoperable with other Grid systems. A {{lot of work in}} current Grid middleware systems is focused on providing transparent access to high performance computing (HPC) resources (e. g. clusters) in virtual organizations spanning multiple institutions. The ad hoc Grid vision presented in this thesis exceeds this view in combining classical Grid components with more flexible components and usage models, allowing to form an environment combining dedicated HPC-resources with a large number of personal computers forming a "Desktop Grid". Three examples from medical research, media research and mechanical engineering are presented as application scenarios for a service-oriented ad hoc Grid infrastructure. These sample applications are also used to derive requirements for the runtime environment as well as development tools for such an ad hoc Grid environment. These requirements form the basis for the design and implementation of the Marburg ad hoc Grid Environment (MAGE) and the Grid Development Tools for Eclipse (GDT). MAGE is an implementation of a WSRF-compliant Grid middleware, that satisfies the criteria for an ad hoc Grid middleware presented in the introduction to this thesis. GDT extends the popular Eclipse integrated development environment by components that support application development both for traditional service-oriented Grid middleware systems as well as ad hoc Grid infrastructures such as MAGE. These development tools represent the first fully model driven approach to Grid service development integrated with infrastructure management components in service-oriented Grid computing. This thesis is concluded by a quantitative discussion of the performance overhead imposed by the presented extensions to a service-oriented Grid middleware as well as a discussion of the qualitative improvements gained by the overall solution. The conclusion of this thesis also gives an outlook on future developments and areas for further research. One of these qualitative improvements is "hot deployment" the ability to install and remove Grid services in a running node without interrupt to other active services on the same node. Hot deployment has been introduced as a novelty in service-oriented Grid systems {{as a result of the}} research conducted for this thesis. It extends service-oriented Grid computing with a new paradigm, making installation of individual application components a functional aspect of the application. This thesis further explores the idea of using peer-to-peer (P 2 P networking for Grid computing by combining a general purpose P 2 P framework with a standard compliant Grid middleware. In previous work the application of P 2 P systems has been limited to replica location and use of P 2 P index structures for discovery purposes. The work presented in this thesis also uses P 2 P networking to realize seamless communication accross network barriers. Even though the web service standards have been designed for the internet, the two-way communication requirement introduced by the WSRF-standards and particularly the notification pattern is not well supported by the web service standards. This defficiency can be answered by mechanisms that are part of such general purpose P 2 P communication frameworks. Existing security infrastructures for Grid systems focus on protection of data during transmission and access control to individual resources or the overall Grid environment. This thesis focuses on security issues within a single node of a dynamically changing service-oriented Grid environment. To counter the security threads arising from the new capabilities of an ad hoc Grid, a number of novel isolation solutions are presented. These solutions address security issues and isolation on a fine-grained level providing a range of applicable basic mechanisms for isolation, ranging from lightweight system <b>call</b> <b>interposition</b> to complete para-virtualization of the operating systems...|$|R

