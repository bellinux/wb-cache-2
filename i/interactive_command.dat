54|50|Public
25|$|Lisp {{languages}} {{are often used}} with an <b>interactive</b> <b>command</b> line, which may be combined with an integrated development environment (IDE). The user types in expressions at the command line, or directs the IDE to transmit them to the Lisp system. Lisp reads the entered expressions, evaluates them, and prints the result. For this reason, the Lisp command line is called a read–eval–print loop (REPL).|$|E
2500|$|In the 4DOS/4NT shell, the eset command {{provides}} an <b>interactive</b> <b>command</b> line to edit an existing alias: ...|$|E
5000|$|UTerm - An <b>interactive</b> <b>command</b> {{line and}} scriptable {{administration}} utility ...|$|E
5000|$|Empty — expect-like {{utility to}} run <b>interactive</b> <b>commands</b> in the UNIX shell-scripts ...|$|R
5000|$|Plugin {{architecture}} for developers, including rendering, <b>interactive</b> tools, <b>commands,</b> and Python scripts.|$|R
5000|$|It {{is common}} to run TSO in batch (as opposed to interactively): all the usual TSO line-mode <b>interactive</b> <b>commands</b> can be also {{executed}} via Job Control Language (JCL) by running any of the programs , , or [...] and supplying the line commands in a file pointed to by the [...] The primary difference between the three programs is their handling of return codes from the executed commands.|$|R
5000|$|In the 4DOS/4NT shell, the [...] command {{provides}} an <b>interactive</b> <b>command</b> line to edit an existing alias: ...|$|E
5000|$|<b>Interactive</b> <b>command</b> line sessions: After launch, {{a program}} may provide an {{operator}} with an independent means to enter commands {{in the form}} of text.|$|E
50|$|ListProc {{includes}} an <b>interactive</b> <b>command</b> protocol and interface for optional use by system managers, list owners, and list subscribers in performing almost all {{interactions with the}} list-management system.|$|E
40|$|This paper {{documents}} {{a collection}} of Lisp utilities which I have written while doing vision programming on a Symbolics Lisp machine. Many of these functions are useful both as <b>interactive</b> <b>commands</b> invoked from the Lisp Listener and as "building blocks" for constructing larger programs. Utilities documented here include functions for loading, storing, and displaying images, for creating synthetic images, for convolving and processing arrays, for making histograms, and for plotting data. MIT Artificial Intelligence Laborator...|$|R
50|$|The Conkeror browser can be {{customized}} in {{many ways}} using JavaScript as the scripting language, {{much in the way}} that Emacs uses Emacs Lisp. Customizations {{can be as simple as}} rebinding keys, but can be more involved; for instance, writing new <b>interactive</b> <b>commands.</b> By default, Conkeror looks for these customizations in ~/.conkerorrc. If ~/.conkerorrc/ is a directory instead of a file, then all the contained files will be read, which is a technique to enable modularization of bigger customizations.|$|R
40|$|This report {{describes}} a system comprised {{of a set}} of <b>interactive</b> <b>commands</b> and a data base which aids in the modeling of thermal power systems {{with the aid of a}} computer. This system, named TPSA (Thermal Power System Analyser), is implemented as a subsystem within the Multics interactive system, which runs on a Honeywell 6180 computer. TPSA deals with models and data bases. A TPSA model is a program capable of computing various output parameters of a thermal power system when given the values of necessary input variables. A TPSA data base is a collection of named variables which a model can access to obtain the value of a parameter or record a result. The <b>interactive</b> <b>commands</b> facilitate setting desired values of the input variables, executing the program, and displaying the selected output variables at the end of the program run. Some special commands, generally found useful in modeling work are also included. Procedure to modify the data base or to create a new data base is described. Some typical examples are included that provide a record of the interactive session with TPSA, illustrating model execution and use of the "probe" command for debugging the program...|$|R
5000|$|... yuma123 is netconf/YANG toolchain {{written in}} C providing: libyuma - API for {{development}} of applications supporting runtime compilation of YANG modules, netconfd - modular server, yangcli - <b>interactive</b> <b>command</b> line tool ...|$|E
50|$|DTSS {{implemented}} {{an early}} {{integrated development environment}} (IDE): an <b>interactive</b> <b>command</b> line interface. There {{was no need to}} log out. If users did not respond, they were logged out after a short delay.|$|E
50|$|OpenModelica Shell (OMShell) is an <b>interactive</b> <b>Command</b> Line Interface that parses and interprets {{commands}} and Modelica expressions for evaluation, simulation, plotting, etc. The session handler {{also contains}} simple history facilities, and completion of file names and certain identifiers in commands.|$|E
40|$|Qviz is a lightweight, modular,and {{easy to use}} {{parallel}} system for interactive analytical query processing and visual presentation of large datasets. Qviz allows queries of arbitrary complexity to be easily constructed using a specialized scripting language. Visual presentation of the results is also easily achieved via simple scripted and <b>interactive</b> <b>commands</b> to our query-specific visualization tools. This paper describes our initial experiences with the Qviz system for querying and visualizing scientific datasets, showing how Qviz {{has been used in}} two different applications: ocean modeling and linear accelerator simulations...|$|R
40|$|The {{invention}} {{is directed}} toward a method and apparatus for generating an animated sequence through the movement of three-dimensional graphical models. A plurality of pre-defined graphical models are stored and manipulated in response to <b>interactive</b> <b>commands</b> or {{by means of a}} pre-defined command file. The models may be combined as part of a hierarchical structure to represent physical systems without need to create a separate model which represents the combined system. System motion is simulated through the introduction of translation, rotation and scaling parameters upon a model within the system. The motion is then transmitted down through the system hierarchy of models in accordance with hierarchical definitions and joint movement limitations. The present invention also calls for a method of editing hierarchical structure in response to <b>interactive</b> <b>commands</b> or a command file such that a model may be included, deleted, copied or moved within multiple system model hierarchies. The present invention also calls for the definition of multiple viewpoints or cameras which may exist as part of a system hierarchy or as an independent camera. The simulated movement of the models and systems is graphically displayed on a monitor and a frame is recorded by means of a video controller. Multiple movement and hierarchy manipulations are then recorded as a sequence of frames which may be played back as an animation sequence on a video cassette recorder...|$|R
40|$|This {{research}} summary proposes {{my research}} on the LiteOS platform, a UNIX-like, multithreaded operating system for wireless sensor networks. My research focuses on two themes: system failure tolerance to provide reliability, and system visibility through <b>interactive</b> <b>commanding.</b> This research summary outlines my ongoing research efforts in these two directions, {{as well as a}} concise description of the LiteOS operating system. 1 Research Motivation My Ph. D. research proposal focuses on research in two directions, building reliable software for wireless sensor networks, and achieving system visibility through interactive operations. To facilitate these research directions, a UNIXlike operating system, called LiteOS, is implemented as th...|$|R
50|$|The Unix {{shell is}} both an <b>interactive</b> <b>command</b> {{language}} {{as well as a}} scripting programming language, and is used by the operating system as the facility to control (shell script) the execution of the system. Shells created for other operating systems often provide similar functionality.|$|E
50|$|Software {{is written}} in {{standard}} Fortran-77 and also has an <b>interactive</b> <b>command</b> language that allows the use of Fortran-77 mathematical and character expressions, macros, control flows and parallelization. Standard protocols are also written in this command language and can be modified by user without changing the source code.|$|E
5000|$|... gp is an easy-to-use <b>interactive</b> <b>command</b> line {{interface}} {{giving access}} to the PARI functions. It functions as a sophisticated programmable calculator which contains most of the control instructions of a standard language like C. GP {{is the name of}} gps scripting language which can be used to program gp.|$|E
5000|$|The Python <b>interactive</b> shell, (both <b>command</b> {{line and}} the {{included}} idle application).|$|R
2500|$|Making {{the command}} {{interpreter}} an ordinary user-level program, with additional commands provided as separate programs, was another Multics innovation popularized by Unix. The Unix shell {{used the same}} language for <b>interactive</b> <b>commands</b> as for scripting (shell scripts– there was no separate job control language like IBM's JCL). Since the shell and OS commands were [...] "just another program", the user could choose (or even write) his own shell. New commands could be added without changing the shell itself. Unix's innovative command-line syntax for creating modular chains of producer-consumer processes (pipelines) made a powerful programming paradigm (coroutines) widely available. Many later command-line interpreters {{have been inspired by}} the Unix shell.|$|R
40|$|There is a {{rich and}} {{expanding}} folklore con-cerning the consequences of inappropriate naming of computer commands. The problems are particu-la r ly acute for occasional users of interactive systems who may be unfamiliar with the jargon of computing. While "naming " has long been of interest to philosophers, linguists and psycholo-gists [2], there is l i t t le systematic research on the psychological processes involved in the under-standing and acquisition of the vocabularies of interactive computer systems. Since the names for <b>interactive</b> <b>commands</b> tend {{to be drawn from}} the wider vocabulary of natural language, occasional users are faced with the task of understanding, learning and remembering ne...|$|R
50|$|In CP/M, 86-DOS, MS-DOS, PC DOS, DR-DOS, {{and their}} various derivatives, the SUB {{character}} {{was also used}} to indicate {{the end of a}} character stream, and thereby used to terminate user input in an <b>interactive</b> <b>command</b> line window (and as such, often used to finish console input redirection, e.g. as instigated by COPY CON: TYPEDTXT.TXT).|$|E
5000|$|Although most users {{think of}} the shell as an <b>interactive</b> <b>command</b> interpreter, {{it is really a}} {{programming}} language in which each statement runs a command. Because it must satisfy both the interactive and programming aspects of command execution, it is a strange language, shaped as much by history as by design. Brian Kernighan & Rob Pike ...|$|E
5000|$|The word [...] (semi-colon) {{finishes}} the current definition {{and returns to}} interpretation state. It {{is an example of}} a word whose compilation semantics differ from the default. The interpretation semantics of [...] (semi-colon), most control flow words, and several other words are undefined in ANS Forth, meaning that they must only be used inside of definitions and not on the <b>interactive</b> <b>command</b> line.|$|E
5000|$|Making {{the command}} {{interpreter}} an ordinary user-level program, with additional commands provided as separate programs, was another Multics innovation popularized by Unix. The Unix shell {{used the same}} language for <b>interactive</b> <b>commands</b> as for scripting (shell scripts - there was no separate job control language like IBM's JCL). Since the shell and OS commands were [...] "just another program", the user could choose (or even write) his own shell. New commands could be added without changing the shell itself. Unix's innovative command-line syntax for creating modular chains of producer-consumer processes (pipelines) made a powerful programming paradigm (coroutines) widely available. Many later command-line interpreters {{have been inspired by}} the Unix shell.|$|R
50|$|It {{performs}} nonlinear DC and transient analysis, Fourier analysis, and AC analysis linearized at {{an operating}} point. It is fully <b>interactive</b> and <b>command</b> driven. It {{can also be}} run in batch mode or as a server. The output is produced as it simulates.|$|R
30|$|We {{acknowledge}} that disk latencies are usually {{higher than those}} of the network, as pointed out by others [1], and UNIX copes with them well. But {{that is not the case}} when wide-area links are involved. Under high latency, round trip times add up quickly leading to poor execution times. For example, in measurements from [1], reading data from a magnetic disk takes 20  ms and a round-trip from California to the Netherlands takes 150  ms. It is the addition of such round- trips what makes it unbearable to operate on files accessible from a WAN using <b>interactive</b> <b>commands.</b> Asynchronous RPCs and caches have been used to address the issue, but the problem still remains in many cases because the interface is not adequate.|$|R
50|$|Lisp {{languages}} {{are often used}} with an <b>interactive</b> <b>command</b> line, which may be combined with an integrated development environment (IDE). The user types in expressions at the command line, or directs the IDE to transmit them to the Lisp system. Lisp reads the entered expressions, evaluates them, and prints the result. For this reason, the Lisp command line is called a read-eval-print loop (REPL).|$|E
5000|$|... dig {{is useful}} for network {{troubleshooting}} and for educational purposes. dig can operate in <b>interactive</b> <b>command</b> line mode or in batch mode by reading requests from an operating system file. When a specific name server is not specified in the command invocation, it will use the operating systems default resolver, usually configured via the resolv.conf file. Without any arguments it queries the DNS root zone.|$|E
50|$|Developed by Stephen Bourne at Bell Labs, {{it was a}} {{replacement}} for the Thompson shell, whose executable file had the same name—sh. It was released in 1977 in the Version 7 Unix release distributed to colleges and universities. Although it is used as an <b>interactive</b> <b>command</b> interpreter, it was also intended as a scripting language and contains most of the features that are commonly considered to produce structured programs.|$|E
40|$|HFLCAL is {{a program}} for layout and {{optimization}} of heliostat fields of central receiver systems (CRS) based on annual performance calculation. Computation time for performance estimation is saved by using a simplified mathematical model for the concentrator optics: the reflected image of each heliostat is described by a circular normal distribution. This approximation is justified when the standard deviation of the statistical mirror error exceeds 1 mrad. The paper shows details about the mathematical model and its validation. The HFLCAL code has been continuously used and enhanced in numerous R&D projects. The current features of HFLCAL comprise (among others) automatic multi-aiming, secondary concentrator optics, tower reflector systems, various receiver models {{and the ability of}} least-cost optimization with various optimization algorithms. A graphical user interface has been added to the program that supports menu-driven <b>interactive</b> <b>commands</b> and depicts calculation results in a display window...|$|R
40|$|Abstract — Providing {{random access}} {{function}} in peer-to-peer on-demand video streaming is a challenging task, due {{to not only}} the asynchronous user interactivity but also the unpredictability of group dynamics. In this paper, we propose VMesh, a distributed peer-to-peer video-on-demand (VoD) streaming scheme which efficiently supports random seeking functionality. In VMesh, videos are divided into segments and stored in peers in a distributed manner. An overlay mesh is built upon peers to support jumping forward/backward, pause and restart during playback. Our scheme utilizes the large total storage capacity of peers to improve the segment supply so as to support <b>interactive</b> <b>commands</b> in a scalable manner. Through simulation, we show that our system outperforms a recent work, P 2 VoD. VMesh also has low segment missing rate under random member join/leave. In addition, the system achieves low joining and seeking latencies which are crucial requirements in an interactive VoD system. I...|$|R
40|$|Introduction Currently PVM is the {{standard}} for developing parallel applications in workstation environments. One of its goals {{is to use the}} computational power of idling workstations. In practice many users refrain from opening their machine to other users' PVM processes. This is due to their experience that such a process, which usually requires a lot of resources (CPU and memory), increases the response time for short <b>interactive</b> <b>commands,</b> i. e. reduces his own productivity. In the following, we describe an approach which enhances existing queuing systems with a support for parallel PVM applications and allows the migration of PVM processes to other machines. Hence, users who start to work interactively on their machine are no longer bothered by resource consuming PVM processes. 2 Load Leveling with Queuing Systems The interaction of the user with the queuing system is based on the notion of jobs. Formally, a job is the obligation of the que...|$|R
