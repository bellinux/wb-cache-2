23|156|Public
50|$|In {{the voting}} phase, {{similar to the}} {{two-phase}} commit, the coordinator requests that each node is ready to commit. If any node fails the coordinator will timeout {{while waiting for the}} failed node. If this happens the coordinator sends an abort message to every node. The same action will be undertaken if any of the nodes return a <b>failure</b> <b>message.</b>|$|E
5000|$|Some MTAs, upon encountering the {{temporary}} <b>failure</b> <b>message</b> from a greylisting server {{on the first}} attempt, will incorrectly send a warning message {{back to the original}} sender of the message. [...] The warning message is not a bounce message, but it is often formatted similarly to one and reads like one. This rarely seen practice that does not conform to the RFC's could cause the sender to believe that the message has not been delivered, when in fact the message will be delivered successfully at a later time.|$|E
5000|$|French BEA {{revealed}} {{that there were}} several technical defects on the plane, several of them were on the EPR system. On 21 July 2013, BEA noted that there was intermittent failures on the autothrottle {{that led to the}} replacement of the EPR transmitter on No.2 engine. On 19 October 2013, the No.1 engine EPR indicator was faulty (no display of values) and the display was replaced. On 2 March 2014, the autothrottle actuator was replaced. During the recommissioning process, the [...] "EPR LH" [...] <b>failure</b> <b>message</b> was displayed. The left-hand EPR transmitter was therefore also replaced. Additionally, on 27 June 2014, an engine surge resulted in a rejected take off, at about 80 knots. Due to this, No.1 engine, was replaced.|$|E
40|$|National audienceThis article {{presents}} {{a method of}} diagnosis of avionics equipment based on the temporal correlation of events. A failure is detected thanks to the execution of built-in tests organised in test trees. The method proposed is based on two parameters: the temporal data coming from the test tree execution and the propagation time of failures. The temporal correlation window between the <b>failure</b> <b>messages</b> is obtained thanks {{to the analysis of}} the ways of failure propagation. The identification of this time window allows determining the degree of correlation between the different <b>failure</b> <b>messages.</b> The goal is to distinguish between single failure occurrence with propagation phenomenon, and multiple occurrences of failure...|$|R
5000|$|... defines failure codes {{returned}} in the <b>Failure</b> packet <b>message</b> field ...|$|R
50|$|A Denial-of-Service attack (DoS) {{occurs when}} an {{attacker}} continually bombards a targeted AP (Access Point) or network with bogus requests, premature successful connection <b>messages,</b> <b>failure</b> <b>messages,</b> and/or other commands. These cause legitimate users {{to not be}} able to get on the network and may even cause the network to crash. These attacks rely on the abuse of protocols such as the Extensible Authentication Protocol (EAP).|$|R
5000|$|Prior to {{the advent}} of milter, an email filter was {{generally}} implemented as a program to which an MTA would hand the message once it has completely arrived, {{with most of the}} message's envelope information removed. That program could then analyze the header and body of the message and make a decision to accept the message (i.e. return a [...] "success" [...] status to the MTA) or reject it (i.e. return a [...] "failed" [...] status to the MTA). The MTA would then log a successful delivery or return a <b>failure</b> <b>message</b> to the sender as appropriate, and the filter would be responsible for effecting delivery of the message (to the intended inbox(es) as-is, or modified to remove unwanted content, or to specific folder(s), etc.).|$|E
30|$|The {{objective}} of ELFN [23] {{is to provide}} route failure information to the source to avoid unnecessary activation of congestion control. In [23], it is stated {{that one of the}} ways to inform a TCP sender about route failure is to use a 'host unreachable' ICMP (internet control message protocol) message for notification. However, in a case of route failure, the routing protocol will send a route <b>failure</b> <b>message</b> to the sender. The approach taken by ELFN is to piggy-back a route <b>failure</b> <b>message</b> for TCP on the routing protocol route <b>failure</b> <b>message.</b> The ELFN message contains the sender and receiver addresses and port numbers as well as the TCP segment's sequence number. To implement the ELFN scheme, the route <b>failure</b> <b>message</b> of dynamic source routing (DSR) [24] protocol was modified to piggy-back the route <b>failure</b> <b>message</b> for TCP.|$|E
30|$|Resolves a trap gate Tw to (α,[*]β). Medical Cloud Server {{received}} Tw, {{first by}} α positioning to the corresponding index vector, recorded as γ, using β decryption γ, make θ[*]=[*]γ[*]⊕[*]β. If the description {{does not contain}} the keyword to be queried, the medical cloud server feeds a <b>failure</b> <b>message</b> to a medical or patient person.|$|E
40|$|We {{consider}} scheduling distributable real-time threads with dependencies (e. g., due to synchroniza-tion) {{in mobile}} ad hoc networks, {{in the presence}} of node/link <b>failures,</b> <b>message</b> losses, and dynamic node joins and departures. We present a distributed real-time scheduling algorithm called RTG-DS. The algo-rithm uses a gossip-style protocol for discovering el-igible nodes, node/link <b>failures,</b> and <b>message</b> losses. In scheduling local thread sections, it exploits thread slacks to optimize the time available for gossiping. We prove that RTG-DS probabilistically bounds distributed blocking times and distributed deadlock detection and notification times. Thereby, it probabilistically satis-fies end-to-end thread time constraints. We also prove that RTG-DS probabilistically bounds failure-exception notification times for failed threads (so that their par-tially executed sections can be aborted). Our simula-tion results validate RTG-DS’s effectiveness. 1...|$|R
50|$|For objects, {{one could}} edit the description, the article {{to be used}} with it (i.e. 'a', 'an', 'some'), and an {{extended}} description shown upon closer examination. A magic object or magic room could be defined that would allow or prevent an object from being picked up or used unless inside a specific place. Like exits, success and <b>failure</b> <b>messages</b> could be defined for 'getting' or 'using' an object. An object's type could be set which allowed pre-programmed behavior.|$|R
40|$|Abstract—We {{present an}} optimistic crash {{recovery}} technique without any communication overhead during normal {{operations of the}} distributed system. Our technique does not append any information to the application messages, it does not suffer from the domino effect, and each processor rolls back at most once during recovery. We present three distributed rollback algorithms, their complexities, and correctness proofs. Their performances are measured through extensive simulations. Index Terms—Crash recovery, distributed algorithms, fail-stop <b>failures,</b> <b>message</b> complexity, optimistic message logging, time complexity. ...|$|R
3000|$|... [...]. If {{there are}} enough {{resources}} at the node, the RREP is forwarded to the next hop. At the same time, a soft reservation for bandwidth is set up at the node when RREP propagates back to the source node. On the other hand, if {{there are not enough}} resources at the node, a <b>failure</b> <b>message</b> is forwarded along the path towards the destination. Thus, the soft reservations of bandwidth along the route are explicitly taken apart when nodes receives the <b>failure</b> <b>message.</b> Finally, when the RREP arrives at the source node, enough end-to-end bandwidth has been reserved and the flow can start. Thus, admission control is completed only when RREP propagates back to the source node. Note that unlike in AODV, we require that only the destination node can generate an RREP and not the intermediate nodes. Hence, when the source node receives the RREP, it can ensure that enough resources are allocated end-to-end between the source and destination nodes. Moreover, due to the change of wireless channel condition or network topology, if any node along the established route(s) detects that QoS requirements can not be maintained, that node must send an QoS_Lost message as seen in AODV-QoS [34] to inform the source nodes about the unmaintainable flows. The corresponding source nodes have to reinitiate new flow requests.|$|E
30|$|The {{approach}} named ENIC is {{also based}} on ELFN to notify both the sender and the receiver about the route failure. However, it uses broadcast messages for all the related source/destination nodes. In ENIC, the intermediate nodes drop the packets on receiving the route <b>failure</b> <b>message,</b> which is the opposite strategy to that adopted in TCP-BuS which buffers the packets, while TCP-F diverts the traffic if another route is available. Therefore, there are three opinions {{on what to do}} with the packets on intermediate nodes in the event of route failure, which necessitates further evaluation of these approaches.|$|E
30|$|As {{receiving}} the EAP-response {{message from the}} MS, the AP first decrypts the *AT_Encr_Data(i) with K_encr(i) key to acquire the Counter_A(i) attribute. Then it, respectively, runs the HMAC authentication function and counter-synchronization function to verify the received AT_RES(i) and Counter_A(i) with the AT_XRES(i) and Counter_A(i) that are stored in its database. If both checks are positive, the AP sends an EAP success message to the MS. Otherwise, the AP immediately announces an authentication <b>failure</b> <b>message</b> to the RADIUS serve for requesting a new full authentication. Meanwhile, it also sends a client-error notification to the MS for terminating the FIL re-authentication exchanges and for initiating a new full authentication.|$|E
50|$|For exits, {{one could}} set {{multiple}} aliases (i.e. n|north|road) {{as well as}} extended descriptions. Player traversal of exits could be blocked or allowed if a magic object was defined on the exit. Success and <b>failure</b> <b>messages</b> for attempted traversal could be defined {{as well as the}} messages other players saw when a player entered or came out of an exit. Exits could be marked concealed and/or flagged as doors to require the player to attempt to open a door or search the room for concealed exits.|$|R
40|$|A publish/subscribe system {{dynamically}} {{routes and}} delivers events from sources to interested users, {{and is an}} extremely useful communication service {{when it is not}} clear in advance who needs what information. In this paper we discuss how a publish/subscribe system can be extended to operate in a mobile environment, where events can be generated by moving sensors or users, and subscribers can request delivery at handheld and/or mobile devices. We describe how the publish/subscribe system itself can be distributed across multiple (possibly mobile) computers to distribute load, and how the system can be replicated to cope with <b>failures,</b> <b>message</b> loss, and disconnections. 1...|$|R
40|$|We {{consider}} {{the problem of}} scheduling distributable real-time threads under run-time uncertainties including those on thread execution times, thread arrivals, node <b>failures,</b> and <b>message</b> losses. We present a distributed scheduling algorithm called ACUA that is designed under a partially synchronous model, allowing for probabilistically-described message delays. We show that ACUA satisfies thread time constraints {{in the presence of}} crash <b>failures</b> and <b>message</b> losses, is early-deciding, and has an efficient message and time complexity. The algorithm has also better “best-effort” real-time property than past thread scheduling algorithms. Categories and Subject Descriptors C. 3 [Special-purpose and application-based systems]: Real-time and embedded system...|$|R
40|$|Abstract: Due to the MAC (medium access control) {{protocol}}, {{routing protocol}} and TCP itself, the TCP flow is very unstable in the wireless Ad Hoc networks based on IEEE 802. 11. However, {{the main reasons}} that make the TCP flow unstable are the unfairness of MAC protocol and the false link <b>failure</b> <b>message</b> that causes the long route discovery procedure. Combining with the IEEE 802. 11 MAC protocol and DSR routing protocol, these causes are analyzed in detail and the enhanced algorithm to IEEE 802. 11 MAC protocol and DSR routing protocol is given in this paper. The simulational {{results show that the}} proposed algorithm can ultimately avoid the instability of TCP flow and increase its average throughput in the wireless Ad Hoc networks. Key words: wireless Ad Hoc network; MAC (medium access control) protocol; routing protocol; TCP flow...|$|E
40|$|In {{classical}} planning, the planner {{is given}} a concrete goal; it returns a plan for it or a <b>failure</b> <b>message.</b> In the latter case, the user can either quit or modify the goal. For many applications, {{it is more convenient}} to let the user provide a more elaborate specification consisting of constraints and preferences over possible goal states. Then, let the system discover a plan for the most desirable among the feasible goal states. To materialize such an approach we require a formalism for specifying preferences and constraints over goals and an algorithm for solving the resulting constrained optimization problem. In this work we motivate the need for planning with preferences and constraints, suggest a rich, yet intuitive formalism for representing goal preferences {{in the context of a}} deterministic action model, discuss some of its properties, propose an efficient algorithm for planning with preferences and constraints based on this formalism, and provide extensive experimental analysis in an interesting new domain of configuration planning...|$|E
40|$|Abstract — Radio-frequency {{identification}} (RFID) is {{a wireless}} technology that utilizes radio communication to identify objects {{with a unique}} electrical identity (EPC). The widespread deployment of RFID technologies may generate new threats to security and user privacy. The main goal {{of this paper is}} to design and implement a security system based on RFID and GSM technology which can be organized in banks, secured offices and homes. Implemented security system based on RFID and GSM technology containing security system using RFID and GSM which can activate, authenticate, and validate the user. The main advantage of using passive RFID and GSM is more secure than other systems. This system consists of Actel FPGA, RFID reader, GSM modem, dsPIC and LCD. In this system the RFID reader reads the id or passward number from passive tag and sends to the FPGA. FPGA checks the card is valid or not then sends data to the dsPIC, after that dsPIC microcontroller displays the success or <b>failure</b> <b>message</b> on LCD and sends the SMS to the authorized person mobile number,which was stored in dsPIC...|$|E
5000|$|There are no <b>failures</b> and all <b>messages</b> arrive {{intact and}} only once ...|$|R
40|$|Timing {{failures}} {{refer to}} {{a situation where the}} environment in which a system operates does not behave as expected regarding the timing assumptions, that is, the timing constraints are not met. In the immense body of work on the designing fault-tolerant systems, the type of failures that are usually considered are, process <b>failures,</b> link <b>failures,</b> <b>messages</b> loss and memory failures; and it is usually (implicitly) assumed that there are no timing failures. In this paper we investigate the ability to recover automatically from transient timing failures. We introduce and formally define the concept of algorithms that are resilient to timing failures, and demonstrate the importance of the new concept by presenting consensus and mutual exclusion algorithms, using atomic registers only, that are resilient to timing failures...|$|R
5000|$|In the {{condition}} of log-in <b>failure,</b> the error <b>message</b> shall not indicate which part of the credential is incorrect ...|$|R
30|$|A {{group of}} four {{approaches}} ELFN, ATCP, ECIA and ENIC does not use the route re-establishment mechanism like TCP-F and TCP-BuS. The ELFN mechanism is the first approach in this group. It modified the route <b>failure</b> <b>message</b> of DSR to piggy-back the route failure notification for TCP, while using the probe packet to detect route re-establishment. On route availability, ELFN comes out of standby mode into normal mode, restoring the retransmission timer and cwnd to their original states. It {{is possible that the}} original retransmission timer and cwnd may not be suitable for the new path {{as is the case with}} TCP-F. The authors state that for efficient performance of a network, it is better to restore the cwnd to its original state (the state before the route failure) rather than restore the cwnd to its initial size as in the slow start phase. Thus, both the TCP-F and the ELFN mechanisms fail to find out the actual size of the cwnd required on the new path. In ELFN, there is no mechanism to divert the traffic on intermediate nodes as in TCP-F.|$|E
40|$|The schemes {{proposed}} by S. Bose et al [Phys. Rev. Lett. 83, 5158 (1999) ] {{and others for}} long distance atomic teleportation using cavity decay, gives message state dependent fidelity on successful attempt and in case of <b>failure</b> <b>message</b> state destroys. We propose a different scheme for teleportation of an atomic state from one cavity to a distant cavity by reflecting optical-pulse modes of an entangled coherent state (ECS) from single atom-cavity systems and detecting whether light is on or off. Unit success with unit fidelity is obtained for large mean photon number (|α|^ 2). For small |α|^ 2, however, there is some probability of failure but message state does not destroy, and this allows us to achieve unit success in a few repeated attempts. Unlike previous schemes, our scheme also enjoys advantages of deterministic generation of ECS, robustness of ECS against de-coherence due to photon absorption, {{and it does not}} require many-stage cavity interactions and single photon detection ability. Comment: 12 Pages, 2 Figures and 1 Tabl...|$|E
40|$|Abstract. Fault {{tolerance}} {{is becoming}} a major concern in HPC sys-tems. The two traditional approaches for message passing applications, coordinated checkpointing and message logging, have severe scalability issues. Coordinated checkpointing protocols make all processes roll back after a <b>failure.</b> <b>Message</b> logging protocols log {{a huge amount of}} data and can induce an overhead on communication performance. Hierarchi-cal rollback-recovery protocols based on the combination of coordinated checkpointing and message logging are an alternative. These partial mes-sage logging protocols are based on process clustering: only messages between clusters are logged to limit the consequence of a failure to one cluster. These protocols would work efficiently only if one can find clus-ters of processes in the applications such that the ratio of logged messages is very low. We study the communication patterns of message passing HPC applications to show that partial message logging is suitable in most cases. We propose a partitioning algorithm to find suitable clusters of processes given the communication pattern of an application. Finally, we evaluate the efficiency of partial message logging using two state of the art protocols on a set of representative applications. ...|$|E
40|$|Abstract — In this paper, we {{concentrate}} on component adaptation in sensor-actuator networks. Component adaptation {{is the process}} of dynamically replacing components in an application in response to changes in the environment conditions. Since the normal operation of a sensor-actuator network is often hindered by faults (e. g., node <b>failures,</b> <b>message</b> losses, synchronization errors), {{it is important that the}} application adapts to the given conditions by dynamically composing suitable components. On the other hand, the applications are time-critical in nature and, hence, it is necessary to ensure that the network provides the required functionalities during adaptation. In this paper, we propose an approach for component adaptation in sensor-actuator networks by systematically using the distributed reset framework that provides assurance guarantees during adaptation. And, we perform a case study on a vibration control application...|$|R
40|$|In {{traditional}} fixed-wired networks, standard protocols like 2 -Phase-Commit {{are used}} to guarantee atomicity for distributed transactions. However, within mobile networks, a higher probability of failures including node <b>failures,</b> <b>message</b> loss, and even network partitioning makes {{the use of these}} standard protocols difficult or even impossible. To use traditional database applications within a mobile scenario, we need an atomic commit protocol that reduces the chance of infinite blocking. In this paper, we present an atomic commit protocol called multi coordinator protocol (MCP) that uses a combination of the traditional 2 -Phase-Commit, 3 -Phase-Commit, and consensus protocols for mobile environments. Simulation experiments comparing MCP with 2 PC show how MCP enhances stability for the coordination process by involving multiple coordinators, and that the additional time needed for the coordination among multiple coordinators is still reasonable...|$|R
40|$|Introduction A {{number of}} {{fundamental}} abstractions and supporting software mechanisms {{have been developed}} for simplifying the problems associated with programming highly dependable distributed systems. For example, transactions provide all or nothing execution despite failures, while ordered atomic multicast supports the replicated state machine approach to fault tolerance by ensuring that changes to the state machine are delivered atomically and in a consistent order despite failures. All of these provide a higher level virtual machine on which to build applications by abstracting away details such as the effect of <b>failures,</b> <b>message</b> reordering and losses, and unconstrained concurrent execution. Each is appropriate for different kinds of applications with different requirements. Many of the concrete realizations of these abstractions have been built as middleware services, i. e., software that is logically layered below the application and above the operating s...|$|R
3000|$|ELFN [32] is {{a simple}} {{approach}} designed by Holland and Vaidya. This approach {{is based on a}} real interaction between TCP and routing protocols. This interaction aims to provide link failure information to the TCP sender to allow TCP to distinguish packet losses that are caused by link failures from those that are caused by congestion. When a link failure occurs, an ELFN message, which is piggybacked on the route <b>failure</b> <b>message,</b> will be sent by the routing protocol to the TCP sender. The ELFN message is like a [...] "host unreachable" [...] Internet control message protocol (ICMP) message, which contains the sender receiver addresses and ports, as well as TCP packet's sequence number. The sender, upon receiving the ELFN message, responds by disabling its retransmission timers and enters a [...] "standby" [...] mode. During the standby period, the TCP sender uses a periodic probe message to determine whether the route has been restored. If the acknowledgment of the probe packet is received (implying that the route is re-established), the TCP sender resumes its retransmission timers and leaves the standby mode to continue the normal operations. In this way, TCP can avoid the slow-start phase and continues with a high rate.|$|E
40|$|Abstract The {{continuous}} {{progress in}} the performance of supercomputers has made possible the understanding of many fundamental problems in science. Simulation, the third scientific pillar, constantly demands more powerful machines to use algorithms that would otherwise be unviable. That will inevitably lead to the deployment of an exascale machine during the next decade. However, fault tolerance is a major challenge that has to be overcome to make such a machine usable. With an unprecedented number of parts, machines at extreme scale will have a small mean-time-between-failures. The popular checkpoint/restart mechanism used in today’s machines may not be effective at that scale. One promising way to revamp checkpoint/restart is to use message-logging techniques. By storing messages during execu-tion and replaying them in case of a <b>failure,</b> <b>message</b> logging is able to shorten recovery time and save a substantial amount of energy. The downside of message logging is that memory footprint may grow to unsustainable levels. This paper presents a technique that decreases the memory pressure in message-logging protocols by only storing the necessary messages in collective-communication operations. We introduce CAMEL, a protocol that has a low memory overhead for multicast and reduction operations. Our results show that CAMEL can reduce memory footprint in a molecular dynamics benchmark for more than 95 % on 16, 384 cores. Keywords fault tolerance · resilience · message logging · collective-communication operation...|$|E
40|$|Customer problem {{troubleshooting}} {{has been}} a critically important issue for both customers and system providers. This paper makes two major contributions to better understand this topic. First, it provides {{one of the first}} characteristic studies of customer problem troubleshooting using a large set (636, 108) of real world customer cases reported from 100, 000 commercially deployed storage systems in the last two years. We study the characteristics of customer problem troubleshooting from various dimensions as well as correlation among them. Our results show that while some failures are either benign, or resolved automatically, many others can take hours or days of manual diagnosis to fix. For modern storage systems, hardware failures and misconfigurations dominate customer cases, but software failures take longer time to resolve. Interestingly, a relatively significant percentage of cases are because customers lack sufficient knowledge about the system. We observe that customer problems with attached system logs are invariably resolved much faster than those without logs. Second, we evaluate the potential of using storage system logs to resolve these problems. Our analysis shows that a <b>failure</b> <b>message</b> alone is a poor indicator of root cause, and that combining failure messages with multiple log events can improve low-level root cause prediction by a factor of three. We then discuss the challenges in log analysis and possible solutions...|$|E
50|$|Notice {{that the}} new leader {{believes}} the old leader to have failed, and may also believe that other members have failed. Thus, the inquiry phase, and or the new propose phase, may also carry piggybacked <b>failure</b> <b>messages</b> for one or more members. This is a central requirement for the protocol, because it ensures that those members will subsequently be shunned: if further communication is received from a shunned member, the receiver will reject those messages. It follows that if any member executes the promise-list phase for an old leader L, no further propose or commit messages from L will be processed by that member. From this {{we can see that}} the promise-list collected by the new leader will be complete, containing all promised messages that could possibly have achieved a quorum in the current view. It may also contain some additional promised messages that have not yet achieved a quorum.|$|R
40|$|We {{identify}} new {{circumstances under}} which processes in faulty distributed systems must com-municate for one process to gain knowledge about another. Our main result says that, in systems with process crash <b>failures,</b> <b>message</b> loss, or asynchronous processes, if a proposition of a certain type about a process p does not hold, and later another process q knows that the proposition holds ~ {{then there was a}} message chain from p to q. Systems in which processes vote, bid, or transmit private values are often ones in which processes gain knowledge of propositions of the sort described in our result. One can use this result as a new tool in showing message lower bounds and impossibility results and in designing protocols. We demonstrate this by showing a new impossibility result for commitment problems: if a round-based commitment protocol is resilient to process failures and recovery and such that a message may be received only in the round in which it is sent, then the protocol may run forever. ...|$|R
40|$|Abstract. In this paper, we have {{proposed}} a simple and efficient approach for check pointing and recovery in cluster computing environment. The recovery scheme deals with both orphan and lost intra and inter cluster messages. This check pointing scheme ensures that after the system recovers from failures, all processes in different clusters can restart from their respective recent checkpoints; thus avoiding any domino effect. That is, the recent check points always form a consistent recovery line of the cluster federation. The main features of our work are: it uses selective message logging which enables the initiator process in each cluster to log the minimum number of messages, the recovery scheme is domino effect free and is executed simultaneously by all clusters in the cluster federation, it considers concurrent <b>failures,</b> <b>message</b> complexities in each cluster for both check pointing and recovery schemes are just O(n), where n {{is the number of}} processes in a cluster. These features make our algorithm superior to the existing works. ...|$|R
