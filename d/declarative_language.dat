774|1378|Public
25|$|Meld is a <b>declarative</b> <b>language,</b> a logic {{programming}} language originally designed for programming overlay networks. By using {{logic programming}}, the code for an ensemble of robots {{can be written}} from a global perspective, enabling the programmer {{to concentrate on the}} overall performance of the claytronics matrix rather than writing individual instructions for every one of the thousands to millions of catoms in the ensemble. This dramatically simplifies the thought process for programming the movement of a claytronics matrix.|$|E
2500|$|Desired State Configuration: <b>Declarative</b> <b>language</b> {{extensions}} {{and tools}} that enable the deployment {{and management of}} configuration data for systems using the DMTF management standards and WS-Management Protocol ...|$|E
2500|$|Darwish's early {{writings}} are in {{the classical}} Arabic style. He wrote monorhymed poems adhering to the metrics of traditional Arabic poetry. In the 1970s he began to stray from these precepts and adopted a [...] "free-verse" [...] technique that did not abide strictly by classical poetic norms. The quasi-Romantic diction of his early works {{gave way to a}} more personal, flexible language, and the slogans and <b>declarative</b> <b>language</b> that characterized his early poetry were replaced by indirect and ostensibly apolitical statements, although politics was never far away.|$|E
50|$|<b>Declarative</b> <b>languages</b> such as XSLT.|$|R
40|$|<b>Declarative</b> <b>languages</b> can be, {{and indeed}} are, {{widely used in}} education. Some areas are in fact {{completely}} dominated by <b>declarative</b> <b>languages,</b> such as formal methods in software engineering, and artificial intelligence. Other areas, such as operating systems rely less on specific declarative ideas. However as understanding of Computer Science increases, the formal basis for such subjects is growing, {{and with it the}} need to teach in a declarative fashion. We conclude the article with an extensive bibliography, from which we hope the interested reader can find support for teaching with <b>declarative</b> <b>languages</b> and ideas...|$|R
50|$|Other models include Hypertalk, Production Systems and <b>Declarative</b> <b>Languages.</b>|$|R
5000|$|XPath is a <b>declarative</b> <b>language</b> for {{navigating}} XML documents; ...|$|E
5000|$|Analytica, {{commercial}} Microsoft Windows <b>declarative</b> <b>language</b> from 1992 to 2015.|$|E
50|$|Because Alloy is a <b>declarative</b> <b>language</b> {{the meaning}} of a model is {{unaffected}} by the order of statements.|$|E
25|$|RQL, one of {{the first}} <b>declarative</b> <b>languages</b> for uniformly {{querying}} RDF schemas and resource descriptions, implemented in RDFSuite.|$|R
40|$|Program {{analysis}} and specialisation for <b>declarative</b> <b>languages</b> have been subjects of active research {{during the last}} 2 decades or so. Imperative languages could benet from the advances made in <b>declarative</b> <b>languages</b> but most research on {{analysis and}} specialisation is language-specic. Thus, it would be desirable to build connections between both worlds, enabling the transfer of results {{from one to the}} other. The semantics of an imperative programming language can be expressed as a program in a <b>declarative</b> constraint <b>language.</b> Not only does this render the semantics (as potentially) executable, but it opens up the possibility of applying to imperative languages the advances made in program analysis and transformation of <b>declarative</b> <b>languages.</b> This thesis presents results on analysis and specialisation of imperative programs through analysis and specialisation of constraint logic programs. The cornerstone of this connection is a constraint logic program capturing the structural operational semantics of the subject imperative language whose programs are to be specialise...|$|R
50|$|Common <b>declarative</b> <b>languages</b> {{include those}} of {{database}} query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.|$|R
5000|$|Enaml: Library for {{creating}} professional quality user interfaces combining a domain specific <b>declarative</b> <b>language</b> with a constraints based layout.|$|E
50|$|V-Play apps {{and games}} {{are written in}} JavaScript and QML, a <b>declarative</b> <b>language</b> that {{features}} property bindings, state machines or fluid animations of any property.|$|E
5000|$|... xupl is {{syntactically}} {{similar to}} SDL (Simple <b>Declarative</b> <b>Language)</b> but differs fundamentally in that xupl provides an exact but alternative representation of any XML document.|$|E
40|$|<b>Declarative</b> {{programming}} <b>languages</b> base on {{the idea}} that programs should be {{as close as possible to}} the problem specification and domain. Programs of these languages usually consist of directly formulated mathematical objects, i. e. relations and functions. Accordingly, <b>declarative</b> <b>languages</b> are distinguished into logic, functional, functional-logic, and constraint programming languages...|$|R
40|$|Abstract. <b>Declarative</b> {{programming}} <b>languages</b> {{advocate a}} programming style expressing {{the properties of}} problems and their solutions rather than how to compute individual solutions. Depending on the underlying formalism to express such properties, one can distinguish different classes of <b>declarative</b> <b>languages,</b> like functional, logic, or constraint programming languages. This paper surveys approaches to combine these different classes into a single programming language. ...|$|R
40|$|Computer {{scientists}} routinely design algorithms to efficiently {{solve problems}} found in nature. The resulting algorithms encapsulate the original problem {{as well as}} extra information about how to solve that problem; thus, nature’s original description that says {{what the problem is}} has been augmented with information about how to solve it. In this paper, we investigate the automation of this process by concentrating on <b>declarative</b> <b>languages,</b> arguing that certain classes of <b>declarative</b> <b>languages</b> encode more information about how to solve a problem than others, and demonstrating techniques for automatically translating between two languages separated in the what-to-how spectrum...|$|R
50|$|EMML is {{primarily}} a XML-based <b>declarative</b> <b>language,</b> but also provides ability to encode complex logic using embedded scripting engines. XPath is the expression language used in EMML.|$|E
5000|$|Desired State Configuration: <b>Declarative</b> <b>language</b> {{extensions}} {{and tools}} that enable the deployment {{and management of}} configuration data for systems using the DMTF management standards and WS-Management Protocol ...|$|E
5000|$|Cypher Query Language (Cypher) - a graph query <b>declarative</b> <b>language</b> for Neo4j {{that enables}} ad hoc and {{programmatic}} (SQL-like) {{access to the}} graph. Spec opened up as openCypher project.|$|E
40|$|The thesis investigates {{several aspects}} of the {{expressive}} power of <b>declarative</b> programming <b>languages.</b> There {{seems to be no}} widely accepted definition of expressive power of programming languages. In the literature expressiveness may mean power to describe algorithms, or to describe computations, or to check types, etc. Presenting a clearer idea of the expressiveness of programming languages {{is a part of the}} aim of the research. We concentrate on the expressive power of <b>declarative</b> <b>languages</b> because these languages are at the highest level of abstraction. People argue about relative expressiveness between <b>declarative</b> <b>languages.</b> Besides, there are two declarative paradigms: logic and functional programming. How can we define and compare expressive power of languages belonging to these two different paradigms ? In order to compare expressive power of logic and functional languages, several translation schemes from subsets of Prolog to Haskell are defined. During the translation we aim to [...] ...|$|R
30|$|Hypermedia {{documents}} define {{presentations of}} media objects (text, audio, video, images, etc.) spatially and temporally related. The creation of such documents is usually achieved by using <b>declarative</b> <b>languages,</b> among which structure-based XML languages, such as NCL [1], SMIL [15], SVG [17], etc.|$|R
50|$|A {{fifth-generation}} {{programming language}} (5GL) is {{a programming language}} based on solving using constraints given to the program, rather than using an algorithm written by a programmer. Most constraint-based and logic programming languages and some other <b>declarative</b> <b>languages</b> are fifth-generation languages.|$|R
5000|$|With {{the release}} of [...]NET 3.0, Microsoft {{released}} a second, parallel API for rendering GUIs: Windows Presentation Foundation (WPF) based on DirectX, together with a GUI <b>declarative</b> <b>language</b> called XAML.|$|E
50|$|The OOA is {{a hybrid}} {{architecture}} {{that relies on}} a special inter-agent communication language (ICL) - a logic-based <b>declarative</b> <b>language</b> which is good for expressing high-level, complex tasks and natural language expressions.|$|E
50|$|In computing, Puppet is an {{open-source}} {{software configuration}} management tool. It runs on many Unix-like systems {{as well as}} on Microsoft Windows, and includes its own <b>declarative</b> <b>language</b> to describe system configuration.|$|E
40|$|Abstract. We {{argue that}} there will be an {{increasing}} future need for the design and implementation of <b>declarative</b> <b>languages</b> that can aggregate trust evidence and therefore inform the decision making of IT systems at run-time. We first present requirements for such languages. Then we discuss an instance of such a language, Peal+, which extends an early pro-totype Peal that was researched by others in collaboration with us. Next, we formulate the intuitive semantics of Peal+, present a simple use case of it, and evaluate to what extent Peal+ meets our formulated require-ments. In this evaluation, particular attention is given to the usability aspects of <b>declarative</b> <b>languages</b> that mean to aggregate trust evidence. ...|$|R
40|$|The {{verification}} of network protocols is a challenging problem. Traditional model checking requires a trans-lation into an intermediate language and suffers from state explosion. Recent proposals [1, 2, 4] have aimed at mitigating these issues. In this poster 1, we propose {{a different and}} novel declarative framework to tackle this problem. The framework builds upon the recent real-ization that with simple extensions, database-style query languages (e. g., Datalog) {{can be used to}} specify and im-plement network protocols [3]. Contrary to imperative languages which describe how computation should be executed, <b>declarative</b> <b>languages</b> strive to specify what computation should be performed. As such, <b>declarative</b> <b>languages</b> have a clear correspondence to mathematical logic, and are well-suited for analysis. The large body o...|$|R
40|$|Abstract—We {{investigate}} {{the design of}} <b>declarative,</b> domain-specific <b>languages</b> for constructing interactive visualizations. By sep-arating specification from execution, <b>declarative</b> <b>languages</b> can simplify development, enable unobtrusive optimization, and sup-port retargeting across platforms. We describe {{the design of the}} Protovis specification language and its implementation within an object-oriented, statically-typed programming language (Java). We demonstrate how to support rich visualizations without requiring a toolkit-specific data model and extend Protovis to enable declarative specification of animated transitions. To support cross-platform deployment, we introduce rendering and event-handling infrastructures decoupled from the runtime platform, letting designers retarget visualization specifications (e. g., from desktop to mobile phone) with reduced effort. We also explore optimizations such as runtime compilation of visualization specifications, parallelized execution, and hardware-accelerated rendering. We present benchmark stud-ies measuring the performance gains provided by these optimizations and compare performance to existing Java-based visualization tools, demonstrating scalability improvements exceeding an order of magnitude. Index Terms—Information visualization, user interfaces, toolkits, domain specific <b>languages,</b> <b>declarative</b> <b>languages,</b> optimization. ...|$|R
5000|$|EMML is a <b>declarative</b> <b>language,</b> but {{provides}} programmatic scripting extensions {{for performing}} complex mashup logic. JavaScript, JRuby, Groovy, POJO, XQuery scripting environments are supported. Data flows seamlessly between EMML and scripting environments.|$|E
50|$|The {{original}} version of CycL was a frame language, but the modern version is not. Rather, it is a <b>declarative</b> <b>language</b> based on classical first-order logic, with extensions for modal operators and higher order quantification.|$|E
50|$|Parlog is a logic {{programming}} language designed for efficient utilization of parallel computer architectures. Its semantics {{is based on}} first order predicate logic. It expresses concurrency, interprocess communication, indeterminacy and synchronization within the <b>declarative</b> <b>language</b> framework.|$|E
40|$|Program specialisation, {{also called}} partial {{evaluation}} or partial deduction, is an automatic technique for program optimisation. The central {{idea is to}} specialise a given source program for a particular application domain. Program specialisation encompasses traditional compiler optimisation techniques, but uses more aggressive transformations, yielding both much greater speedups and more difficulty in controlling the transformation process. Because of their clear (and often simple) semantical foundations, <b>declarative</b> <b>languages</b> offer significant advantages {{for the design of}} semantics based program analysers, transformers and optimisers. This thesis exploits these advantages in the context of logic programming and develops advanced techniques for program specialisation, striving to produce tangible practical benefits within the larger objective of turning <b>declarative</b> <b>languages</b> and program specialisation into valuable tools for constructing reliable, maintainabl...|$|R
40|$|The goal of my {{research}} {{is to make it}} easier to write correct and efficient programs through advances in the design and implementation of <b>declarative</b> <b>languages.</b> <b>Declarative</b> <b>languages</b> provide programmers with such essential services as automatic thread scheduling and memory management. My research focuses on improving the effectiveness and flexibility of these services. <b>Declarative</b> <b>languages,</b> such as PML [FRRS 08] and Data-Parallel Haskell [CLP + 07], provide implicit and explicit threading mechanisms. An implicit thread is a linguistic construct that acts as a hint to the scheduler for where parallel evaluation may be profitable. Explicit threads provide a mechanism for concurrent programming and coarse-grain parallel programming. My thesis research presents the design of an effective system for a language that supports implicit threading and runs on a shared-memory multiprocessor. An effective system is scalable and robust. A system is scalable if performance improves in proportion to the number of processing elements. A system is robust when performance is consistently good under changing conditions, such as a change of input data set, number of processors, or hardware platform. Robust systems are predictable across programs generally, not just those tuned for a particular set of conditions. Research on thread scheduling provides evidence that no single scheduling policy is suitable for every applicatio...|$|R
40|$|This paper {{describes}} how Functional Programming {{was used in}} the Flagship System Software Kernel and how Formal Methods were used to design code to run on the parallel Flagship Machine. This method has generated about 20 k lines of code and has proved to be very effective and readily adopted by the team. 1 Introduction The Flagship project was an Alvey-sponsored project which aimed to produce a parallel machine that supported <b>declarative</b> <b>languages.</b> This paper describes the method by which the Flagship system software responsible for providing a multi-user, multi-process environment was developed. Since our software would be running on a parallel machine designed for <b>declarative</b> <b>languages,</b> the language chosen for the Flagship System Software was Hope +. We could therefore utilise the implicit parallelism in the language. We decided that we should use Formal Methods in our development for improved program correctness. This led us to investigate VDM 1. We set out to ensure that the im [...] ...|$|R
