1216|0|Public
5|$|The JMP Scripting Language (JSL) is an {{interpreted}} {{language for}} recreating analytic results and for automating or extending the functionality of JMP software. JSL {{was first introduced}} in JMP version 4 in 2000. JSL has a LISP-like syntax, structured {{as a series of}} expressions. All programming elements, including <b>if-then</b> statements and loops, are implemented as JSL functions. Data tables, display elements and analyses are represented by objects in JSL that are manipulated with named messages. Users may write JSL scripts to perform analyses and visualizations not available in the point-and-click interface or to automate a series of commands, such as weekly reports. SAS, R, and Matlab code can also be executed using JSL.|$|E
25|$|IT (bits 10–15 and 25–26) is the <b>if-then</b> state bits.|$|E
25|$|In general, {{a logical}} {{antecedent}} is a sufficient condition, and a logical consequent {{is a necessary}} condition(or the contingency) in a logical conditional. But logical conditionals accounting only for necessity and sufficiency do not always reflect every day <b>if-then</b> reasoning, {{and for this reason}} they are sometimes known as material conditionals. In contrast, indicative conditionals, sometimes known as non-material conditionals, attempt to describe <b>if-then</b> reasoning involving hypotheticals, fictions, or counterfactuals.|$|E
25|$|<b>If-then</b> {{arguments}} posit logical sequences {{that sometimes}} include objects of the mind. For example, a counterfactual argument proposes a hypothetical or subjunctive possibility which could or would be true, but {{might not be}} false. Conditional sequences involving subjunctives use intensional language, which is studied by modal logic, whereas classical logic studies the extensional language of necessary and sufficient conditions.|$|E
25|$|Truth {{tables for}} <b>if-then</b> {{statements}} identify four unique combinations of premises and conclusions: true premises and true conclusions; false premises and true conclusions; true premises and false conclusions; false premises and false conclusions. Strict conditionals assign a positive truth-value to every case except {{the case of}} a true premise and a false conclusion. This is sometimes regarded as counterintuitive, but makes more sense when false conditions are understood as objects of the mind.|$|E
2500|$|Concretely, in many {{languages}} one may write conditionals in two valid forms: the <b>if-then</b> form, and the if-then-else form – in effect, {{making the}} else clause optional: ...|$|E
2500|$|An {{example of}} a {{primitive}} recursive programming language is one that contains basic arithmetic operators (e.g. + and −, or ADD and SUBTRACT), conditionals and comparison (<b>IF-THEN,</b> EQUALS, LESS-THAN), and bounded loops, such as the basic for loop, {{where there is a}} known or calculable upper bound to all loops (FOR i FROM 1 to n, with neither i nor n modifiable by the loop body). No control structures of greater generality, such as while loops or <b>IF-THEN</b> plus GOTO, are admitted in a primitive recursive language. Douglas Hofstadter's BlooP in Gödel, Escher, Bach is one such. [...] Adding unbounded loops (WHILE, GOTO) makes the language partially recursive, or Turing-complete; Floop is such, as are almost all real-world computer languages.|$|E
2500|$|As {{discussed}} earlier, {{the processing}} stage {{is based on}} a collection of logic rules in the form of <b>IF-THEN</b> statements, where the IF part is called the [...] "antecedent" [...] and the THEN part is called the [...] "consequent". Typical fuzzy control systems have dozens of rules.|$|E
2500|$|Much of {{artificial}} intelligence had focused on high-level (symbolic) models that are processed by using algorithms, characterized for example by expert systems with knowledge embodied in <b>if-then</b> rules, until {{in the late}} 1980s research expanded to low-level (sub-symbolic) machine learning, characterized by knowledge embodied in the parameters of a cognitive model [...]|$|E
2500|$|In {{spite of}} the {{appearance}} there are several difficulties to give a rigorous logical interpretation of the <b>IF-THEN</b> rules. As an example, interpret a rule as [...] IF (temperature is [...] "cold") THEN (heater is [...] "high") by the first order formula Cold(x)→High(y) and assume that r is an input such that Cold(r) is false. Then the formula Cold(r)→High(t) is true for any t and therefore any t gives a correct control given r. A rigorous logical justification of fuzzy control is given in Hájek's book (see Chapter 7) where fuzzy control is represented as a theory of Hájek's basic logic. Also in Gerla 2005 [...] another logical approach to fuzzy control is proposed based on fuzzy logic programming.Indeed, denote by f the fuzzy function arising of an <b>IF-THEN</b> systems of rules. Then we can translate this system into a fuzzy program P containing a series of rules whose head is [...] "Good(x,y)". The interpretation of this predicate in the least fuzzy Herbrand model of P coincides with f. This gives further useful tools to fuzzy control.|$|E
2500|$|Thus, {{a subset}} of FOL can be both easier to use and more {{practical}} to implement. This was a driving motivation behind rule-based expert systems. <b>IF-THEN</b> rules provide {{a subset of}} FOL but a very useful one that is also very intuitive. [...] The history {{of most of the}} early AI knowledge representation formalisms; from databases to semantic nets to theorem provers and production systems can be viewed as various design decisions on whether to emphasize expressive power or computability and efficiency.|$|E
2500|$|Baldwin {{and colleagues}} have {{proposed}} that working models of attachment are composed of relational schemas. The fact that relational schemas contain information about the self and information about others {{is consistent with previous}} conceptions of working models. The unique contribution of relational schemas to working models is the information about the way interactions with attachments usually unfold. Relational schemas add the <b>if–then</b> statements about interactions to working models. To demonstrate that working models are organized as relational schemas, Baldwin and colleagues created a set of written scenarios that described interactions dealing with trust, dependency and closeness. For example, the scenarios for closeness included: ...|$|E
2500|$|For example, if {{a person}} {{regularly}} asks his or her partner for a hug or kiss, and the partner regularly responds with a hug or kiss, the person forms a relational schema representing the predictable interaction. The schema contains information about the self (e.g., [...] "I need lots of physical affection"). It also contains information about the partner (e.g., [...] "My partner is an affectionate person"). And it contains information {{about the way the}} interaction usually unfolds, which can be summarized by an <b>if–then</b> statement (e.g., [...] "If I ask my partner for a hug or kiss, then my partner will respond with a hug or kiss and comfort me"). Relational schemas help guide behavior in relationships by allowing people to anticipate and plan for partner responses.|$|E
2500|$|Structured programming, {{canonical}} structures: Per the Church–Turing thesis, any algorithm can be computed by a model {{known to}} be Turing complete, and per Minsky's demonstrations, Turing completeness requires only four instruction types—conditional GOTO, unconditional GOTO, assignment, HALT. Kemeny and Kurtz observe that, while [...] "undisciplined" [...] use of unconditional GOTOs and conditional <b>IF-THEN</b> GOTOs can result in [...] "spaghetti code", a programmer can write structured programs using only these instructions; {{on the other hand}} [...] "it is also possible, and not too hard, to write badly structured programs in a structured language". Tausworthe augments the three Böhm-Jacopini canonical structures: SEQUENCE, IF-THEN-ELSE, and WHILE-DO, with two more: DO-WHILE and CASE. An additional benefit of a structured program is that it lends itself to proofs of correctness using mathematical induction.|$|E
2500|$|Thumb-2 {{extends the}} Thumb {{instruction}} set with bit-field manipulation, table branches and conditional execution. At the same time, the ARM instruction set {{was extended to}} maintain equivalent functionality in both instruction sets. A new [...] "Unified Assembly Language" [...] (UAL) supports generation of either Thumb or ARM instructions from the same source code; versions of Thumb seen on ARMv7 processors are essentially as capable as ARM code (including the ability to write interrupt handlers). This requires a bit of care, and use of a new [...] "IT" [...] (<b>if-then)</b> instruction, which permits up to four successive instructions to execute based on a tested condition, or on its inverse. When compiling into ARM code, this is ignored, but when compiling into Thumb it generates an actual instruction. For example: ...|$|E
2500|$|Minsky {{describes}} a more congenial variation of Lambek's [...] "abacus" [...] model in his [...] "Very Simple Bases for Computability". Minsky's machine proceeds sequentially through its five (or six, {{depending on how}} one counts) instructions, unless either a conditional <b>IF–THEN</b> GOTO or an unconditional GOTO changes program flow out of sequence. Besides HALT, Minsky's machine includes three assignment (replacement, substitution) operations: ZERO (e.g. the contents of location replaced by 0: L ← 0), SUCCESSOR (e.g. L ← L+1), and DECREMENT (e.g. L ← L − 1). Rarely must a programmer write [...] "code" [...] with such a limited instruction set. But Minsky shows (as do Melzak and Lambek) that his machine is Turing complete with only four general types of instructions: conditional GOTO, unconditional GOTO, assignment/replacement/substitution, and HALT.|$|E
2500|$|The {{integration}} of Frames, rules, and object-oriented programming was significantly driven by commercial ventures such as KEE and Symbolics spun off from various research projects. At {{the same time}} as this was occurring, there was another strain of research which was less commercially focused and was driven by mathematical logic and automated theorem proving. [...] One of the most influential languages in this research was the KL-ONE language of the mid 80's. KL-ONE was a frame language that had a rigorous semantics, formal definitions for concepts such as an Is-A relation. KL-ONE and languages that were influenced by it such as Loom had an automated reasoning engine that was based on formal logic rather than on <b>IF-THEN</b> rules. This reasoner is called the classifier. A classifier can analyze a set of declarations and infer new assertions, for example, redefine a class to be a subclass or superclass of some other class that wasn't formally specified. In this way the classifier can function as an inference engine, deducing new facts from an existing knowledge base. The classifier can also provide consistency checking on a knowledge base (which in the case of KL-ONE languages is also referred to as an Ontology).|$|E
50|$|The {{material}} conditional {{does not}} always function in accordance with everyday <b>if-then</b> reasoning. Therefore there are drawbacks with using the material conditional to represent <b>if-then</b> statements.|$|E
5000|$|A {{classical}} <b>IF-THEN</b> statement uses binary logic, for instance: ...|$|E
5000|$|Smart Home Programming: <b>If-Then</b> Statements Make A Comeback- Science 2.0 ...|$|E
5000|$|With {{the help}} of <b>if-then</b> {{sentences}} we can specify conditional or hypothetical situations: ...|$|E
50|$|There {{are four}} {{constructs}} of subordination: relative sentences, <b>if-then</b> sentences, modality, and sentence subordination.|$|E
5000|$|<b>IF-THEN</b> rules map input or {{computed}} truth {{values to}} desired output truth values. Example: ...|$|E
5000|$|... vi) [...] "Den" [...] {{can also}} {{indicate}} a conditional (an <b>if-then</b> condition), implying an omitted [...] "if"/"when": ...|$|E
50|$|Conditional {{statements}} (<b>if-then</b> or if-then-else) {{in computer}} science, binary decisions about which piece of code to execute next.|$|E
50|$|In general, {{a logical}} {{antecedent}} is a sufficient condition, and a logical consequent {{is a necessary}} condition(or the contingency) in a logical conditional. But logical conditionals accounting only for necessity and sufficiency do not always reflect every day <b>if-then</b> reasoning, {{and for this reason}} they are sometimes known as material conditionals. In contrast, indicative conditionals, sometimes known as non-material conditionals, attempt to describe <b>if-then</b> reasoning involving hypotheticals, fictions, or counterfactuals.|$|E
5000|$|The {{following}} {{is an example of}} an argument using the law of detachment {{in the form of an}} <b>if-then</b> statement: ...|$|E
5000|$|Usually {{the rule}} base {{consists}} of several <b>IF-THEN</b> rules, linking input(s) and output(s).A simple rule of a fuzzy controller could be: ...|$|E
50|$|Typical {{reactive}} planning algorithm just evaluates <b>if-then</b> {{rules or}} computes {{the state of}} a connectionist network. However, some algorithms have special features.|$|E
5000|$|In English, {{examples}} are both—and, either—or, neither—nor, the—the ("the more the better"), so—that ("it ate so much food that it burst"), and <b>if—then.</b>|$|E
5000|$|Rules, {{that are}} either {{provided}} by subject experts or are extracted from numerical data, are expressed {{as a collection of}} <b>IF-THEN</b> statements, e.g., ...|$|E
5000|$|Statements in {{the form}} of an <b>if-then</b> (antecedent-consequent) {{sentence}} that describe the logical inferences that can be drawn from an assertion in a particular form ...|$|E
5000|$|This {{gives rise}} to an {{ambiguity}} in interpretation when there are nested statements, specifically whenever an <b>if-then</b> form appears as [...] in an if-then-else form: ...|$|E
50|$|The {{following}} code segment {{shows the}} IF-THEN-ELSIF construct. The ELSIF and ELSE parts are optional {{so it is}} possible to create simpler <b>IF-THEN</b> or, IF-THEN-ELSE constructs.|$|E
5000|$|Rules: {{statements}} {{in the form of}} an <b>if-then</b> (antecedent-consequent) sentence that describe the logical inferences that can be drawn from an assertion in a particular form ...|$|E
5000|$|Concretely, in many {{languages}} one may write conditionals in two valid forms: the <b>if-then</b> form, and the if-then-else form - in effect, {{making the}} else clause optional: ...|$|E
