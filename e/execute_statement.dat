2|184|Public
50|$|User-defined {{functions}} can {{be invoked}} from a query like built‑in {{functions such as}} OBJECT_ID, LEN, DATEDIFF, or can be executed through an <b>EXECUTE</b> <b>statement</b> like stored procedures.|$|E
40|$|In this article, {{we present}} four simple {{exercises}} that use non-determinism {{in the context}} of standard PASCAL-type programs. All four exercises are easy to grasp, and they all have short and nice solutions. Hence they might be appropriate for homework assignments and classroom exercises, and they might help students to digest the definition of a non-deterministic algorithm. Throughout, we will use an exclusive-or command (denoted OR) : If in a piece of code we write stmnt- 1 OR stmnt- 2 then the non-deterministic program will execute exactly one of the two statements stmnt- 1 and stmnt- 2. Furthermore, we use a command MAYBE(stmnt) which allows the non-deterministic program to either <b>execute</b> <b>statement</b> stmnt or not. Obviously, MAYBE(stmnt) is equivalent to stmnt OR do_nothing...|$|E
50|$|ModernPascal also {{supports}} Brief Pascal, {{so you can}} <b>execute</b> <b>statements</b> without all the formality.|$|R
25|$|Run-time evaluation: JavaScript {{includes}} an eval function that can <b>execute</b> <b>statements</b> provided as strings at run-time.|$|R
5000|$|...n: Display {{table of}} the line numbers of the n most {{frequently}} <b>executed</b> <b>statements</b> and their execution counts.|$|R
5000|$|The [...] {{operator}} {{is unnecessary}} in a function (although allowed); {{the value of}} the last <b>executed</b> <b>statement</b> or expression is normally the function's value.|$|R
5000|$|Multiple {{statements}} or multi queries must {{be executed}} with mysqli_multi_query (...) [...] The individual {{statements of the}} statement string are separated by semicolon. Then, all result sets returned by the <b>executed</b> <b>statements</b> must be fetched.|$|R
5000|$|Locks {{are held}} {{only during the}} {{currently}} <b>executing</b> <b>statement.</b> Note that if locks are released after a statement, the underlying data could be changed by another transaction before the current transaction commits, thus creating a violation.|$|R
50|$|A {{procedure}} call <b>executes</b> the <b>statements</b> of a procedure in a forward direction. A procedure uncall <b>executes</b> the <b>statements</b> of a procedure in the backward direction. There are no parameters to procedures, so all variable passing {{is done by}} side-effects on the global store.|$|R
5000|$|<b>Statements</b> can be <b>executed</b> {{with the}} mysqli_query (...) , mysqli_real_query (...) and mysqli_multi_query (...) {{function}}s. The mysqli_query (...) function {{is the most}} common, and combines the <b>executing</b> <b>statement</b> with a buffered fetch of its result set, if any, in one call. Calling mysqli_query (...) is identical to calling mysqli_real_query (...) followed by mysqli_store_result (...) [...]|$|R
40|$|A program fails. Under which {{circumstances}} {{does this}} failure occur? One single algorithm, the delta debugging algorithm, suffices to determine these failure-inducing circumstances. Delta debugging tests a program systematically and automatically to isolate failure-inducing circumstances {{such as the}} program input, changes to the program code, or <b>executed</b> <b>statements...</b>|$|R
5000|$|JDBC {{connections}} support {{creating and}} <b>executing</b> <b>statements.</b> These may be update {{statements such as}} SQL's CREATE, INSERT, UPDATE and DELETE, {{or they may be}} query statements such as SELECT. Additionally, stored procedures may be invoked through a JDBC connection. JDBC represents statements using one of the following classes: ...|$|R
50|$|NHibernate's {{configuration}} {{may affect}} when NHibernate <b>executes</b> SQL <b>statements.</b>|$|R
5000|$|An {{example of}} a {{database}} transaction:boolean autoCommitDefault = conn.getAutoCommit (...)try { conn.setAutoCommit(false); /* You <b>execute</b> <b>statements</b> against conn here transactionally */ conn.commit (...)} catch (Throwable e) { try { conn.rollback (...) } catch (Throwable e) { logger.warn("Could not rollback transaction",e); } throw e;} finally { try { conn.setAutoCommit(autoCommitDefault); } catch (Throwable e) { logger.warn("Could not restore AutoCommit setting",e); }} ...|$|R
5000|$|Execute: At a later time, the {{application}} supplies (or binds) {{values for the}} parameters, and the DBMS <b>executes</b> the <b>statement</b> (possibly returning a result). The application may <b>execute</b> the <b>statement</b> {{as many times as}} it wants with different values. In this example, it might supply 'Bread' for the first parameter and '1.00' for the second parameter.|$|R
5000|$|As {{compared}} to <b>executing</b> SQL <b>statements</b> directly, prepared statements offer two main advantages: ...|$|R
40|$|ABSTRACT Description: This paper {{explains}} how to conditionally <b>execute</b> <b>statements</b> in open code {{without having to}} wrap the code in a macro. This is accomplished by combining the macro function sysfunc with the data step function ifc. The result is that parameterized include programs gain the power of conditional processing — %if [...] . %then — for which macros are usually used...|$|R
5000|$|SQL editors allow {{users to}} edit and <b>execute</b> SQL <b>statements.</b> They may support the {{following}} features: ...|$|R
5000|$|Some {{languages}} do support locks syntactically. An {{example in}} C# follows:class Account { // {{this is a}} monitor of an account long val = 0; object thisLock = new object (...) public void deposit(const long x) { lock(thisLock) { // only one thread at a time may <b>execute</b> this <b>statement</b> val += x; } } public void withdraw(const long x) { lock(thisLock) { // only one thread at a time may <b>execute</b> this <b>statement</b> val -= x; } }} ...|$|R
5000|$|F1j → T F1j+1, {{implies that}} {{statement}} F1 in iteration [...] must be <b>executed</b> after <b>statement</b> F1 in iteration [...] This {{is also known}} as true dependency.|$|R
5000|$|CUBRID {{comes with}} a {{built-in}} command-line interface named csql {{that can be used}} to <b>execute</b> SQL <b>statements</b> on the CUBRID server.The tool can be used in one of two modes: ...|$|R
40|$|Abstract The {{semantics}} of a state-event {{statement is}} considered {{in a situation}} where one process changes the value of a variable, and another process <b>executes</b> a state-event <b>statement</b> – involving the same variable – at the same time-point. If the condition of the state-event statement is evaluated immediately, the shared variable may still have its old value. By means of an example model of a multi-section conveyor it is shown that immediate evaluation of state-event conditions is undesirable from a modelling point of view. The proposed semantics of the state-event statement is that the evaluation of the state-event condition is postponed until the other processes can no longer <b>execute</b> <b>statements</b> at the current time-point, and a new consistent state has been established. This semantics facilitates the development of correct models. The proposed semantics is analogous to the transition semantics in hybrid automata...|$|R
5000|$|The {{tasks in}} a {{parallel}} <b>statement</b> are <b>executed</b> by creating threads on the processor <b>executing</b> the <b>statement.</b> Tasks can be placed on different tiles by using a on prefix. In following example: ...|$|R
40|$|You just {{produced}} some graphs using the SGPLOT and SGPANEL procedures. Now {{you want to}} modify the structure of your graphs {{in order to make}} them more meaningful. You are looking for options that enable you to split the axis values across multiple lines, add a table under a graph, or create a template with which you can conditionally <b>execute</b> <b>statements</b> and dynamically assign variables. However, you cannot find any options within the procedure that enable you to put these final touches on your graphs. When all seems hopeless, ODS Graphics Template Language (GTL) comes to the rescue...|$|R
50|$|Conditional jumps {{should be}} used in the syntax:{{condition}}''''statement 1:statement 2When condition is true, <b>statement</b> 1 is <b>executed,</b> then <b>statement</b> 2 is <b>executed.</b> If condition is false, statement 1 is skipped and <b>statement</b> 2 is <b>executed.</b>|$|R
5000|$|Burlington's first project, appropriately, {{was his own}} London residence, Burlington House, {{where he}} {{dismissed}} his baroque architect James Gibbs {{when he returned from}} the continent in 1719 and employed the Scottish architect Colen Campbell, with the history-painter-turned-designer William Kent for the interiors. The courtyard front of Burlington House, prominently sited in Piccadilly, was the first major <b>executed</b> <b>statement</b> of neo-Palladianism.In the 1720s Burlington and Campbell parted, and Burlington was assisted in his projects by the young Henry Flitcroft, [...] "Burlington Harry"— who developed into a major architect of the second neopalladian generation— and Daniel Garrett— a straightforward palladian architect of the second rank— and some draughtsmen.|$|R
40|$|The {{semantics}} of a state-event {{statement is}} considered {{in a situation}} where one process changes the value of a variable, and another process <b>executes</b> a state-event <b>statement</b> [...] involving the same variable [...] at the same time-point. If the condition of the state-event statement is evaluated immediately, the shared variable may still have its old value. By means of an example model of a multi-section conveyor it is shown that immediate evaluation of state-event conditions is undesirable from a modelling point of view. The proposed semantics of the state-event statement is that the evaluation of the state-event condition is postponed until the other processes can no longer <b>execute</b> <b>statements</b> at the current time-point, and a new consistent state has been established. This semantics facilitates the development of correct models. The proposed semantics is analogous to the transition semantics in hybrid automata. Introduction Two main fields of research into hybrid systems are: formal analy [...] ...|$|R
40|$|Recently {{there has}} been {{significant}} interest in employing probabilistic techniques for fault localization. Using dynamic dependence information for multiple passing runs, learning techniques are used to construct a probabilistic graph model for a given program. Then, given a failing run, the probabilistic model is used to rank the <b>executed</b> <b>statements</b> according to the likelihood of them being faulty. In this paper we present a novel probabilistic approach in which universal probabilistic models are learned to characterize the behaviors of various instruction types used by all programs. The universal probabilistic model for an instruction type is in form of a probability distribution that represents how errors in the input (operand) values are propagated as errors in the output (result) of a given instruction type. Once these models have been constructed, {{they can be used}} in the analysis of any program as follows. Given a set of runs for any program, including at least one passing and one failing run, a Bayesian network called the Error Flow Graph (EFG) is then constructed from the dynamic dependence graphs of the program runs and the universal probabilistic models. Standard inference algorithms are employed to compute the probability of each <b>executed</b> <b>statement</b> being faulty. We also present optimizations to reduce the runtime cost of inference using the EFG. Our experiments demonstrate that our approach is highly effective in fault localization even when very few passing runs are available. It also performs well in the presence of multiple faults. D. 2. 5 [Software Engineer...|$|R
50|$|Construct a loop that <b>executes</b> this {{selection}} <b>statement</b> {{as long as}} L is not 0.|$|R
5000|$|The {{explicit}} {{result of}} a function or operator {{is the result of}} the last <b>statement</b> <b>executed</b> ...|$|R
40|$|This paper proposes and evaluates a {{mechanism}} for preserving and restoring the execution state of Java applications. A framework is developed, utilising the functionality provided in the Java Platform Debugging Architecture to locate the exact instruction of computation, {{at the time of}} program suspension. With the aid of bytecode modification, processing is resumed at the point of suspension, without repeating <b>executed</b> <b>statements.</b> This framework exhibits a low object code growth rate, between 4 % and 17 %, a substantial reduction in comparison to existing systems. Additionally, the execution overhead placed upon running applications is a minimal 7 %. This is in contrast to the cost of state capture and restoration, which incurs a substantial performanc...|$|R
40|$|Traditional {{dynamic program}} slicing {{techniques}} are code-centric, meaning dependences are introduced between <b>executed</b> <b>statement</b> instances, which {{gives rise to}} various problems such as space requirement is decided by execution length; dependence graphs are highly redundant so that inspecting them is labor intensive. In this paper, we propose a data-centric dynamic slicing technique, in which dependences are introduced between memory locations. Doing so, the space complexity is bounded by memory footprint instead of execution length. Moreover, presenting dependences between memory locations is often more desirable for human inspection during debugging as redundant dependences are suppressed. Our evaluation shows that the proposed technique supersedes traditional dynamic slicing techniques in terms of effectiveness and efficiency...|$|R
50|$|In version 9.5, in 2008, Opera {{introduced}} Dragonfly, a debugging tool {{similar to}} Firebug and developer tools {{found in other}} browsers, that allows debugging of the HTML DOM, JavaScript, CSS, and more. A user can set breakpoints and watches, alter scripts on-the-fly, <b>execute</b> <b>statements</b> in the current environment from a console, and audit page resources and local storage. Opera Dragonfly also allows debugging from a personal computer a webpage opened on a handheld or other device. Dragonfly is written using standard web technology and the Scope protocol, and source is available under the Apache License 2.0. Opera Dragonfly is compatible with Opera products using Presto 2.1 and later. The first stable version of Opera Dragonfly was released on 5 May 2011.|$|R
5000|$|UpdateCommand [...] - [...] <b>Executes</b> a JDBC <b>{{statement}}</b> {{that does}} not return a ResultSet, such as an update or DDL statement ...|$|R
5000|$|The {{while and}} until {{modifiers}} test the controlling expression before <b>executing</b> the <b>statement,</b> just like their loop counterparts. However, {{they are not}} considered actual loops, so the loop control keywords next, last and redo cannot be used with them. They have special semantics when combined with the do keyword: ...|$|R
40|$|Using {{traditional}} software profiling {{to optimize}} embedded software in an MPSoC design is not reliable. With multiple processors run-ning concurrently and programs interacting, traditional profiling on individual processors cannot capture useful execution information to assist software optimization. A new method to model parallel executions of interacting programs is needed. In this paper, we con-sider the software optimization problem for throughput-constrained MPSoC designs. We define the “longest delay path ” as {{a sequence of}} steps leading to a throughput constraint violation and propose an algorithm {{to build up the}} path dynamically during simulation. Using an industrial-strength MPEG- 2 decoder design in our case study and custom instructions for software optimization, we show that we can optimize the software efficiently in MPSoC designs using frequently <b>executed</b> <b>statement</b> information from the longest delay path...|$|R
