16|6|Public
2500|$|When Bash starts, it executes the {{commands}} {{in a variety}} of dot files. [...] Though similar to Bash shell script commands, which have execute permission enabled and an <b>interpreter</b> <b>directive</b> like #!/bin/bash, the initialization files used by Bash require neither.|$|E
2500|$|In UNIX {{scripting}} (typically for UNIX shell or Perl), [...] "!" [...] {{is usually}} used after a [...] "#" [...] {{in the first}} line of a script, the <b>interpreter</b> <b>directive,</b> to tell the OS what program to use to run the script. [...] The [...] "#!" [...] is usually called a [...] "hash-bang" [...] or shebang. A similar convention for PostScript files calls for the first line to begin with [...] "%!", called [...] "percent-bang".|$|E
5000|$|Shebang, {{the use of}} #! as an <b>interpreter</b> <b>directive</b> in scripts on Unix-like systems ...|$|E
50|$|Other {{systems or}} files may use some other magic number as the <b>interpreter</b> <b>directives.</b>|$|R
50|$|Kernel {{support for}} <b>interpreter</b> <b>directives</b> {{spread to other}} {{versions}} of Unix, and one modern implementation {{can be seen in}} the Linux kernel source in fs/binfmt_script.c.|$|R
5000|$|In later {{versions}} of Unix-like systems, this inconsistency was removed. Dennis Ritchie introduced kernel support for <b>interpreter</b> <b>directives</b> in January 1980, for Version 8 Unix, {{with the following}} description: ...|$|R
5000|$|TCC allows {{programs}} {{to be run}} automatically at compile time using a command-line switch. This allows {{programs to}} be run as a shell script under Unix-like systems which support the shebang <b>interpreter</b> <b>directive</b> syntax.|$|E
50|$|When Bash starts, it executes the {{commands}} {{in a variety}} of dot files. Though similar to Bash shell script commands, which have execute permission enabled and an <b>interpreter</b> <b>directive</b> like , the initialization files used by Bash require neither.|$|E
50|$|An <b>interpreter</b> <b>directive</b> is a {{computer}} language construct, that on some systems is better described as {{an aspect of the}} system's executable file format, that is used to control which interpreter parses and interprets the instructions in {{a computer}} program.|$|E
5000|$|In Ruby, <b>interpreter</b> <b>directives</b> are {{referred}} to as pragmas and are specified by top-of-file comments that follow a [...] notation. For example, [...] indicates that the file is encoded via the UTF-8 character encoding.|$|R
50|$|<b>Interpreter</b> <b>directives</b> allow {{scripts and}} data files {{to be used}} as commands, hiding the details of their {{implementation}} from users and other programs, by removing the need to prefix scripts with their interpreter on the command line.|$|R
50|$|Note that, even {{in systems}} with full kernel {{support for the}} #! magic number, some scripts lacking <b>interpreter</b> <b>directives</b> (although usually still {{requiring}} execute permission) are still runnable {{by virtue of the}} legacy script handling of the Bourne shell, still present in many of its modern descendants. Scripts are then interpreted by the user's default shell.|$|R
5000|$|The {{character}} [...] "%" [...] is used {{to introduce}} comments in PostScript programs. As a general convention, every PostScript program should start with the characters [...] "%!PS" [...] as an <b>interpreter</b> <b>directive</b> so that all devices will properly interpret it as PostScript.|$|E
50|$|Shell scripts often {{serve as}} an initial stage in {{software}} development, and are often subject to conversion later to a different underlying implementation, most commonly being converted to Perl, Python, or C. The <b>interpreter</b> <b>directive</b> allows the implementation detail to be fully hidden inside the script, rather than being exposed as a filename extension, and provides for seamless reimplementation in different languages with no impact on end users.|$|E
5000|$|In UNIX {{scripting}} (typically for UNIX shell or Perl), [...] "!" [...] {{is usually}} used after a [...] "#" [...] {{in the first}} line of a script, the <b>interpreter</b> <b>directive,</b> to tell the OS what program to use to run the script. The [...] "#!" [...] is usually called a [...] "hash-bang" [...] or shebang. A similar convention for PostScript files calls for the first line to begin with [...] "%!", called [...] "percent-bang".|$|E
50|$|When {{compared}} to the use of global association lists between file extensions and the interpreting applications, the <b>interpreter</b> <b>directive</b> method allows users to use interpreters not known at a global system level, and without administrator rights. It also allows specific selection of interpreter, without overloading the filename extension namespace (where one file extension refers to more than one file type), and allows the implementation language of a script to be changed without changing its invocation syntax by other programs.|$|E
50|$|An {{executable}} file starting with an <b>interpreter</b> <b>directive</b> is simply called a script, often prefaced {{with the name}} or general classification of the intended interpreter. The name shebang for the distinctive two characters {{may have come from}} an inexact contraction of SHArp bang or haSH bang, referring to the two typical Unix names for them. Another theory on the sh in shebang is that it is from the default shell sh, usually invoked with shebang. This usage was current by December 1989, and probably earlier.|$|E
50|$|This {{mechanism}} allows scripts {{to be used}} {{in virtually}} any context normal compiled programs can be, including as full system programs, and even as interpreters of other scripts. As a caveat, though, some early versions of kernel support limited the length of the <b>interpreter</b> <b>directive</b> to roughly 32 characters (just 16 in its first implementation), would fail to split the interpreter name from any parameters in the directive, or had other quirks. Additionally, some modern systems allow the entire mechanism to be constrained or disabled for security purposes (for example, set-user-id support has been disabled for scripts on many systems).|$|E
5000|$|The {{lack of an}} <b>interpreter</b> <b>directive,</b> but {{support for}} shell scripts, is {{apparent}} in the documentation from Version 7 Unix in 1979, which describes instead a facility of the Bourne shell where files with execute permission would be handled specially by the shell, which would (sometimes depending on initial characters in the script, such as [...] ":" [...] or [...] "#") spawn a subshell which would interpret and run the commands contained in the file. In this model, scripts would only behave as other commands if called from within a Bourne shell. An attempt to directly execute such a file via the operating system's own exec (...) system trap would fail, preventing scripts from behaving uniformly as normal system commands.|$|E
50|$|A {{key feature}} of shell scripts {{is that the}} {{invocation}} of their interpreters is handled as a core operating system feature. So rather than a user's shell only being able to execute scripts in that shell's language, or a script only having its <b>interpreter</b> <b>directive</b> handled correctly if it was run from a shell (both of which were limitations in the early Bourne shell's handling of scripts), shell scripts are set up and executed by the OS itself. A modern shell script is {{not just on the}} same footing as system commands, but rather many system commands are actually shell scripts (or more generally, scripts, since some of them are not interpreted by a shell, but instead by Perl, Python, or some other language). This extends to returning exit codes like other system utilities to indicate success or failure, and allows them to be called as components of larger programs regardless of how those larger tools are implemented.|$|E
50|$|On {{systems with}} {{interpreter}} directives, including virtually all versions of Unix, command name extensions have no special significance, and are by standard practice not used, since the primary method to set interpreters for scripts {{is to start}} them with a single line specifying the interpreter to use (which {{could be viewed as}} a degenerate resource fork). In these environments, including the extension in a command name unnecessarily exposes an implementation detail which puts all references to the commands from other programs at future risk if the implementation changes. For example, it would be perfectly normal for a shell scripts to be reimplemented in Python or Ruby, and later in C or C++, all of which would change the name of the command were extensions used. Without extensions, a program always has the same extension-less name, with only the <b>interpreter</b> <b>directive</b> and/or magic number changing, and references to the program from other programs remain valid.|$|E
50|$|The {{form of a}} shebang <b>{{interpreter}}</b> <b>directive</b> is as follows: #!interpreter optional-argin which interpreter is {{an absolute}} path to an executable program. The optional argument is a string representing a single argument. White space after #! is optional. In Linux, the file specified by interpreter can be executed if it has the execute right and contains code which the kernel can execute directly, {{if it has a}} wrapper defined for it via sysctl (such as for executing Microsoft EXE binaries using wine), or if it contains a shebang. On Linux and Minix, an interpreter can also be a script. A chain of shebangs and wrappers yields a directly executable file that gets the encountered scripts as parameters in reverse order. For example, if file /bin/A is an executable file in ELF format, file /bin/B contains the shebang #!/bin/A optparam, and file /bin/C contains the shebang #!/bin/B, then executing file /bin/C resolves to /bin/B /bin/C, which finally resolves to /bin/A optparam /bin/B /bin/C.|$|E

