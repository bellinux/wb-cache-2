287|827|Public
25|$|The {{pseudorandom}} function {{splits the}} input data {{in half and}} processes each one with a different <b>hashing</b> <b>algorithm</b> (MD5 and SHA-1), then XORs them together to create the MAC. This provides protection even if one of these algorithms {{is found to be}} vulnerable.|$|E
500|$|A random {{bipartite graph}} with n {{vertices}} {{on each side}} of its bipartition, and with cn edges chosen independently at random from each of the n2 possible pairs of vertices, is a pseudoforest with high probability whenever c is a constant strictly less than one. This fact {{plays a key role in}} the analysis of cuckoo hashing, a data structure for looking up key-value pairs by looking in one of two hash tables at locations determined from the key: one can form a graph, the [...] "cuckoo graph", whose vertices correspond to hash table locations and whose edges link the two locations at which one of the keys might be found, and the cuckoo <b>hashing</b> <b>algorithm</b> succeeds in finding locations for all of its keys if and only if the cuckoo graph is a pseudoforest.|$|E
5000|$|SHA-256 <b>hashing</b> <b>algorithm</b> as {{the default}} {{password}} <b>hashing</b> <b>algorithm</b> ...|$|E
5000|$|New {{features}} include: {{support for}} Secure <b>Hash</b> <b>Algorithm</b> 2.0 (SHA2) and all advanced <b>hash</b> <b>algorithms</b> that are supported in Windows 2008 R2; by default, weaker <b>hash</b> <b>algorithms</b> are disabled.|$|R
50|$|Secure <b>Hash</b> <b>Algorithm</b> - {{a widely}} used family of <b>hash</b> <b>algorithms</b> {{developed}} by NSA based on earlier designs by Ron Rivest.|$|R
40|$|Abstract: We study some technologys {{that people}} had {{developed}} to analyse and attack <b>hash</b> <b>algorithm.</b> We find a way that use data-depend function to resist differential attack. Then we design a <b>hash</b> <b>algorithm</b> that called Data-Depend Hash Algorit(DDHA). And DDHA is simple and strong under differential attack. Key Word: <b>Hash</b> <b>algorithm,</b> data-depend functio...|$|R
5000|$|Hashing {{is used in}} {{database}} {{systems as}} a method to protect sensitive data such as passwords; however it {{is also used to}} improve the efficiency of database referencing. Inputted data is manipulated by a <b>hashing</b> <b>algorithm.</b> The <b>hashing</b> <b>algorithm</b> converts the inputted data into a string of fixed length that can then be stored in a database. Hashing systems have two crucially important characteristics that will now be outlined. Firstly, hashes are [...] "unique and repeatable". As an example, running the word [...] "cat" [...] through the same <b>hashing</b> <b>algorithm</b> multiple times will always yield the same hash, however it is extremely difficult to find a word that will return the same hash that [...] "cat" [...] does. Secondly, hashing algorithms are not reversible. To relate this back to the example provided above, it would be nearly impossible to convert the output of the <b>hashing</b> <b>algorithm</b> back to the original input, which was [...] "cat". In the context of database encryption, hashing is often used in password systems. When a user first creates their password it is run through a <b>hashing</b> <b>algorithm</b> and saved as a hash. When the user logs back into the website, the password that they enter is run through the <b>hashing</b> <b>algorithm</b> and is then compared to the stored hash. Given the fact that hashes are unique, if both hashes match then it is said that the user inputted the correct password. One example of a popular hash function is SHA (Secure Hash Algorithm) 256.|$|E
50|$|Ethash is the <b>hashing</b> <b>algorithm</b> used {{natively}} for the proof-of-work {{function in}} Ethereum-based blockchain currencies.|$|E
5000|$|The Goldmont {{microarchitecture}} provides new instructions with hardware accelerated secure <b>hashing</b> <b>algorithm,</b> SHA1 and SHA256.|$|E
50|$|An easy {{example of}} MAC address anonymization {{would be to}} use a simple <b>hash</b> <b>algorithm.</b> Given an address of 11:22:33:44:55, the MD5 <b>hash</b> <b>algorithm</b> {{produces}} 8,093,140,232,281,458,246 (0x70509c29768f0646).|$|R
40|$|The National Institute of Standards and Technology (NIST) {{opened a}} public {{competition}} on November 2, 2007, {{to develop a}} new cryptographic <b>hash</b> <b>algorithm</b> – SHA- 3, which will augment the <b>hash</b> <b>algorithms</b> specified in the Federal Information Processing Standard (FIPS) 180 - 4, Secure Hash Standard (SHS). The competition was NIST’s response to advances in the cryptanalysis of <b>hash</b> <b>algorithms.</b> NIST received sixty-four submissions in October 2008, and selected fifty-one first-roun...|$|R
40|$|Abstract: Cryptographic <b>hash</b> <b>algorithms</b> are {{important}} building blocks in cryptographic protocols, providing authentication and assurance of integrity. While many different <b>hash</b> <b>algorithms</b> are available including MD 5, Tiger, and HAVAL, {{it is difficult}} to compare them since they do not necessarily use the same techniques to achieve their security goals. This work informally describes a framework in four parts which allows different <b>hash</b> <b>algorithms</b> to be compared based on their strengths and weaknesses. By breaking down cryptographic <b>hash</b> <b>algorithms</b> into their preprocessing, postprocessing, compression function, and internal structure components, weaknesses in existing algorithms can be mitigated and new algorithms can take advantage of strong individual components. ...|$|R
50|$|The Trusted Platform Module (TPM) as {{specified}} by the TCG provides many security functions including special registers (called Platform Configuration Registers - PCRs) which hold various measurements in a shielded location {{in a manner that}} prevents spoofing. Measurements consist of a cryptographic hash using a Secure <b>Hashing</b> <b>Algorithm</b> (SHA); the TPM v1.0 specification uses the SHA-1 <b>hashing</b> <b>algorithm.</b> More recent TPM versions (v2.0+) call for SHA-2.|$|E
5000|$|... an identificator of {{scheme that}} {{representing}} the <b>hashing</b> <b>algorithm</b> (such as 1 for MD5, 5 for SHA-256 etc.) ...|$|E
50|$|If all client {{libraries}} use {{the same}} <b>hashing</b> <b>algorithm</b> to determine servers, then clients can read each other's cached data.|$|E
50|$|There {{have been}} {{concerns}} with algorithm agility vis-à-vis attacks on hash functions used by SEND expressed in RFC 6273, as CGA currently uses the SHA-1 <b>hash</b> <b>algorithm</b> and PKIX certificates {{and does not}} provide support for alternative <b>hash</b> <b>algorithms.</b>|$|R
40|$|One-way <b>hash</b> <b>algorithms</b> are an {{indispensable}} tool in data security. Over {{the last decade}} or so a number of one-way <b>hash</b> <b>algorithms</b> have been designed and many of them have been used in numerous applications. Recent progress in cryptanalytic attacks on one-way <b>hash</b> <b>algorithms</b> by Wang and co-workers, however, has brought up the urgency of research into new and more secure algorithms. The goal of this paper is two-folded. On one hand we propose a simple technique to affix authentication tags to messages prior to being hashed by an iterative oneway <b>hash</b> <b>algorithm</b> with the aim of increasing the overall security of the algorithm against cryptanalytic attacks. One the other hand we advocate the importance of a system oriented approach towards the design and deployment of new families of one-way <b>hash</b> <b>algorithms</b> that support greater scalability and facilitate migration to newer member algorithms upon the compromise of deployed ones. We base our observations on a common sense premise that there is no specific one-way <b>hash</b> <b>algorithm</b> can remain secure forever and it will eventually be broken by a cryptanalytic attack faster than exhaustive research...|$|R
40|$|A {{cryptographic}} hash function {{has an important}} role in cryptography to achieve certain security goals such as authenticity, digital signatures, digital time stamping, and entity authentication. They are also strongly related to other important cryptographic tools such as block ciphers and pseudorandom functions. Due to the previous merits we present a proposal for a new secure <b>hash</b> <b>algorithm</b> based on the combination of some functions of SHA- 256 (Secure <b>Hash</b> <b>Algorithm</b> 256) -with its message expansion modification- and MD 5 (Message Digest 5) based on double-Davis-Mayer scheme to overcome the weakness existing in these functions. The proposal <b>hash</b> <b>algorithm</b> has been designed to satisfy the different levels of enhanced security and to resist the advanced hash attacks by increasing the complexity degree of the proposed <b>hash</b> <b>algorithm.</b> The security analysis of the proposed <b>hash</b> <b>algorithm</b> is compared to SHA 256 and gives more security and highly acceptable results as shown in our security results and discussions...|$|R
5000|$|The {{first step}} of {{algorithm}} is calculating the hashing based on the most frequent k characters. The <b>hashing</b> <b>algorithm</b> has below steps: ...|$|E
50|$|It is also {{possible}} to use a cryptographic hash function as a randomness extractor. However, not every <b>hashing</b> <b>algorithm</b> is suitable for this purpose.|$|E
50|$|Version 3 and 5 UUIDs are {{generated}} by hashing a namespace identifier and name. Version 3 uses MD5 as the <b>hashing</b> <b>algorithm,</b> and version 5 uses SHA1.|$|E
50|$|In {{general for}} any Merkle, {{to create a}} new branch or verify an {{existing}} branch, a <b>hash</b> <b>algorithm</b> is used on some combination of the local contents, such as a list of child hashes and other bytes. A few different <b>hash</b> <b>algorithms</b> are available in IPFS.|$|R
5000|$|... <b>hashing</b> <b>algorithms</b> MD5, RIPEMD-128/160, SHA-1, SHA-2 and Whirlpool; ...|$|R
50|$|In TLS 1.3, a {{cipher suite}} {{represents}} an AEAD encryption <b>algorithm</b> and a <b>hash</b> <b>algorithm</b> used in HKDF. For example, TLS_AES_128_GCM_SHA256 indicates AES_128_GCM {{is used to}} encrypt messages, and SHA256 is the underlying <b>hash</b> <b>algorithm</b> in HKDF. Non-AEAD encryption algorithms (such as AES_128_CBC) {{are not allowed to}} be used.|$|R
50|$|November 2014: OrangeFS 2.9.0 {{released}} adding {{support for}} distributed metadata for directory entries using an extensible <b>hashing</b> <b>algorithm</b> modeled after giga+, posix backward compatible capability base security supporting multiple modes.|$|E
50|$|Some {{password}} synchronization {{systems may}} copy password hashes from one system to another, where the <b>hashing</b> <b>algorithm</b> is the same. In general, {{this is not}} the case and access to a plaintext password is required.|$|E
50|$|Judy {{trees are}} usually faster than AVL trees, B-trees, hash tables and skip lists {{because they are}} highly {{optimized}} to maximize usage of the CPU cache. In addition, they require no tree balancing and no <b>hashing</b> <b>algorithm</b> is used.|$|E
40|$|It is {{well known}} that <b>Hash</b> <b>{{algorithm}}</b> works in one way, and it cannot be reversed. We can build a new algorithm by using Hill cipher technique. Since its invention in 1929, Hill cipher algorithm {{which is one of the}} most famous symmetric cryptosystems. Hill cipher requires the inverse of the key matrix for decryption. This inverse not always exists, so we can use non-invertible matrices to propose a model for our new <b>hash</b> <b>algorithm,</b> and we proof the four requirements that needed to design a practical one way <b>hash</b> <b>algorithm...</b>|$|R
5000|$|Secure <b>Hash</b> <b>Algorithm</b> 2 (SHA-256 and SHA-384) — {{message digest}} ...|$|R
5000|$|The SHA-1 <b>hash</b> <b>algorithm</b> uses 0123456789ABCDEFFEDCBA9876543210F0E1D2C3 as {{its initial}} hash value.|$|R
5000|$|Constructing a hash {{function}} with provable security {{is much more}} difficult than using a classical approach where we just hope that the complex mixing of bits in the <b>hashing</b> <b>algorithm</b> is strong enough to prevent adversary from finding collisions.|$|E
50|$|Connascence of {{algorithm}} is when multiple components must {{agree on a}} particular algorithm. Message authentication codes are {{an example of this}} form of connascence. Both sides of the exchange must implement exactly the same <b>hashing</b> <b>algorithm</b> or the authentication will fail.|$|E
50|$|The Verisys agent {{examines}} {{a number}} of properties and attributes of each file to ascertain whether any changes have been made. Rather than simply check basic object properties, Verisys performs a cryptographic <b>hashing</b> <b>algorithm</b> on the actual data contained within each file.|$|E
5000|$|FreeBSD {{implemented}} {{support for}} the NT LAN Manager <b>hash</b> <b>algorithm</b> to provide easier compatibility with NT accounts. [...] The NT-Hash algorithm {{is known to be}} weak, as it uses the deprecated md4 <b>hash</b> <b>algorithm</b> without any salting. FreeBSD used the [...] prefix for this. Its use is not recommended, as it is easily broken.|$|R
5000|$|Hash the document, d, to {{be signed}} (with a public <b>hash</b> <b>algorithm).</b>|$|R
30|$|The {{reminder}} of paper is organized as follows: Section II briefly explains reconfigurable hybrid CMOS/Nano technology. Section III illustrates the Secure <b>Hash</b> <b>Algorithm</b> very briefly. Section IV presents the performance {{results of the}} implementation of secure <b>hash</b> <b>algorithm</b> basic modules on hybrid CMOS/Nano platform. Finally, in the conclusion we briefly summarize {{the results of our}} discussions.|$|R
