0|948|Public
40|$|<b>Passive</b> <b>testing</b> {{has proved}} to be a {{powerful}} technique for protocol system fault detection by observing its input/output behaviors yet without interrupting its normal operations. Various techniques for <b>passive</b> <b>testing</b> on Extended Finite State Machine (EFSM) exist such as by invariants and by interval determination, which are not very costy in terms of complexity but that also don’t detect every errors. To im-prove the fault detection capabilities a backward checking method was proposed. It analyzes in a backward fashion the input/output trace from <b>passive</b> <b>testing</b> and its past. It effec-tively checks both the control and data portion of a protocol system and is able to detect every errors, but with a higher complexity. The purpose of the present paper is then to pro-pose possible parallel algorithms and architectures to im-prove the backward <b>passive</b> <b>testing</b> approach by narrowing down its maximal time complexity and transforming it into the rst real-time exhaustive <b>passive</b> <b>testing</b> approach. We present the backward algorithm and its parallel versions, study their complexity, and report results on various com-munication and routing protocols. 1...|$|R
40|$|In this paper, we {{employ the}} {{finite state machine}} (FSM) model for {{networks}} to investigate fault identification using <b>passive</b> <b>testing.</b> First, we introduce the concept of <b>passive</b> <b>testing.</b> Then, we introduce the FSM model with necessary assumptions and justification. We introduce the fault model and the fault detection algorithm using <b>passive</b> <b>testing.</b> Extending this result, we develop the theorems and algorithms for fault identification. An example is given illustrating our approach. Then, extensions to our approach are introduced to achieve better fault identification. We then illustrate our technique through a simulation of a practical X. 25 example. Finally future extensions and potential trends are discussed. ...|$|R
40|$|<b>Passive</b> <b>testing</b> is a {{complementary}} technique to active testing. For {{some types of}} systems, for example dynamic or adaptive distributed systems which are able to re-configure themselves at runtime in response to changes in their environments, exhaustive active testing before deployment is either theoretically impossible or practically not feasible. For such types of systems the additional application of the technique of <b>passive</b> <b>testing</b> is recommendable. However, a comprehensive theory and taxonomy of methods and techniques for model-based <b>passive</b> <b>testing</b> does –as far as we know– not yet exist and is from today’s perspective {{still very much a}} topic for future research in this domain. For this reason the presentation of the topic in this chapter is very much example-based such as to provide the reader with some first intuitions about what model-based <b>passive</b> <b>testing</b> is, what kinds of techniques could be used to implement it, and what could be some typical application scenarios for model-based <b>passive</b> <b>testing</b> in the domains of software systems, hardware systems, as well as embedded software+hardware systems. Note: Section 5 of our chapter, as well as several Figures and a number of Acknowledgments, which will appear in the above-mentioned book, are OMITTED in this pre-print version. [URL]...|$|R
40|$|Abstract—The {{paper is}} devoted to {{constructing}} a tester for checking student implementations of application-layer protocols. There are two testing modes for checking a protocol implementation: the active <b>testing</b> and the <b>passive</b> <b>testing.</b> We automate the testing process in both modes for checking student protocol implementations through Internet programming labs. Test set that contains test cases for detecting most frequent student faults, is derived for active testing of server protocol implementations. For <b>passive</b> <b>testing</b> of client protocol implementations, the paper uses the invariant approach. The approach is illustrated by a part of Dynamic Host Configuration Protocol (DHCP). The structure of the tester is also described. Index Terms—Active <b>testing,</b> computer applications, <b>passive</b> <b>testing,</b> protocols...|$|R
40|$|<b>Passive</b> <b>testing</b> is {{a process}} of {{detecting}} faults in a system under test by passively observing its input/output behaviors only without interrupting its normal operations, and proves to be a promising technique for network fault management. We study <b>passive</b> <b>testing</b> of data portions of network pro-tocols and present two algorithms, using an Event-driven Extended Finite State Machine model. Experimental results on the Internet routing protocol OSPF are reported. 1...|$|R
40|$|International audienceCommonly, {{two main}} classes of formal testing {{techniques}} {{are applied to}} check the conformance of protocols and software: active and <b>passive</b> <b>testing</b> (monitoring) techniques. Because of many industrial constraints such as the necessity to achieve implementation black box <b>testing,</b> <b>passive</b> <b>testing</b> techniques become highly relevant in several cases. Besides, most of the <b>passive</b> <b>testing</b> techniques only consider control portions of exchanged packets and ignores data parts. However, since systems become more complex, testing for data constraints and relations between packets is now essential. In this {{paper we propose a}} novel approach for defining data oriented invariants and show how they can be tested in a trace set by using logic programming. Experimental results on SIP protocol traces are provide...|$|R
40|$|In this paper, we {{employ the}} Communicating {{finite state machine}} (CFSM) model for {{networks}} to investigate fault identification using <b>passive</b> <b>testing.</b> First, we introduce the concept of <b>passive</b> <b>testing.</b> Then, we introduce the CFSM model and the observer model with necessary assumptions and justification. We introduce the fault model and the fault detection algorithm using <b>passive</b> <b>testing.</b> Extending our previous work, we develop the new approach for fault identification based on the CFSM model. A 2 -node model example is given to illustrate our approach. Then, we illustrate the effectiveness of our new technique through simulation of practical protocol examples, covering both the 2 -node and 3 -node models. Finally future extensions and potential trends are discussed. (Cross-referenced as UMIACS-TR- 2001 - 28...|$|R
40|$|<b>Passive</b> <b>testing</b> of {{a network}} protocol, the {{technique}} of detecting faults of the protocol implementation by monitoring its inputs and outputs when it is operating in a real communication network, has drawn attention lately {{because it does not}} interfere with the protocol development process. This paper proposes an extended finite state machine (EFSM) -based <b>passive</b> <b>testing</b> technique with good fault-detecting capability at a minimized on-line processing cost. Before testing, the proposed technique expands the given EFSM model to an expanded EFSM (XEFSM) model and derives its homing tree. During the testing we can find faults only by tracing that homing tree and the XEFSM with a given event sequence before and after the homing is accomplished respectively. In order {{to evaluate the effectiveness of}} the proposed technique we showed a simple example with the simple connection protocol (SCP) and also developed a <b>passive</b> <b>testing</b> system for the open shortest path first (OSPF) protocol. In the experiment with an OSPF implementation having intentional errors, the proposed technique showed a top-level fault detecting capability with less on-line processing. Therefore the proposed technique can be a good solution to real-time <b>passive</b> <b>testing</b> {{of a network}} protocol with rapid packet exchanges. Key words...|$|R
40|$|International audienceConformance {{testing of}} {{communicating}} protocols {{is a crucial}} step to the validation of systems. Formal approaches provide many keys to test efficiently these protocols. These approaches are divided in two main sets: active and <b>passive</b> <b>testing</b> techniques. While they both have their own advantages and drawbacks, <b>passive</b> <b>testing</b> techniques {{are the only ones}} that can be applied when the controllability of the system interfaces is unavailable or when the implementation under test cannot be stimulated in runtime. In this paper, we present a novel logic-based <b>passive</b> <b>testing</b> approach. We aim at formally specifying protocol properties in order to check them on real execution traces. Based on algorithms defined in a previous paper, a prototype is here developed and experienced. In order to evaluate and assess our technique, we present experiments through a set of IMS/SIP properties and long-size execution traces. We finally provide relevant verdicts and discussions...|$|R
40|$|Part 4 : Session 3 : TestingInternational audienceTesting {{is usually}} {{understood}} {{to involve the}} tester interacting with the studied system by supplying input and observing output. However, sometimes this active interaction is not possible and <b>testing</b> becomes more <b>passive.</b> In this setting, <b>passive</b> <b>testing</b> can {{be considered to be}} the process of checking that the observations made regarding the system satisfy certain required properties. In this paper we study a formal <b>passive</b> <b>testing</b> framework for systems where there is an asynchronous communications channel between the tester and the system. We consider a syntactic definition of a class of properties and provide a semantic representation, as automata, that take into account the different observations that we can expect due to the assumption of asynchrony. Our solution checks properties against traces in polynomial time, with a low need for storage. Therefore, our proposal is very suitable for real-time <b>passive</b> <b>testing...</b>|$|R
40|$|Abstract. <b>Passive</b> <b>testing</b> {{has proved}} to be a {{powerful}} technique for pro-tocol system fault detection by observing its input/output behaviors yet without interrupting its normal operations. To improve the fault detec-tion capabilities we propose a backward checking method that analyzes in a backward fashion the input/output trace from <b>passive</b> <b>testing</b> and its past. It eectively checks both the control and data portion of a protocol system, compliments the forward checking approaches, and detects more errors. We present our algorithm, study its termination and complexity, and report experiment results on the protocol SCP. ...|$|R
40|$|A novel test {{protocol}} is proposed for fuel {{cells that are}} in a nonfunctioning or passive state. Standard fuel-cell test methods are reviewed, along with the equivalent circuit models (ECMs) used to represent functioning or active fuel cells. Standard active tests focus on single cells, while the <b>passive</b> <b>test</b> is shown to be applicable to testing multiple cells. The <b>passive</b> <b>test</b> measures electrical characteristics of the fuel cell {{in the absence of}} electrochemical reactions. A simple ECM is developed to describe the cell behavior under the <b>passive</b> <b>test</b> conditions. Circuit model parameters of many series-connected cells can be acquired using the results of a single stack test. Proton exchange membrane fuel cells (PEMFCs) from three manufacturers were tested, ranging in system power from 12 - 500 W. Test results for each PEMFC exhibited similar behavior that is well predicted by the ECM. A strong similarity between a passive fuel cell and a double layer capacitor is discussed. © 2007 IEEE...|$|R
40|$|<b>Passive</b> <b>testing</b> is an {{alternative}} testing approach whose purpose is to passively analyze an implementation behaviour without disturbing it. Usually, <b>passive</b> <b>testing</b> methods extract traces by means of sniffer-based tools, running in the same environment as the implementation. Nevertheless, many implementation environments prevent from setting a sniffer-based tool for security or technical reasons. We propose a <b>passive</b> <b>testing</b> method based {{on the notion of}} proxy-tester which represents an intermediary between client applications and the implementation. We define a proxy-tester as a product between the specification and its canonical tester, which is able to receive the client traffic and to forward it to the implementation and vice versa. It also aims to analyze the implementation traces to detect faults. We define a non conformance relation between the implementation, its specification and the external environment from which is received the client traffic. We also provide some preliminary results on the Amazon E-commerce Web service and discuss about the proxy-tester benefits...|$|R
40|$|Anovel test {{protocol}} is proposed for fuel {{cells that are}} in a nonfunctioning or passive state. Standard fuel-cell test methods are reviewed, along with the equivalent circuit models (ECMs) used to represent functioning or active fuel cells. Standard active tests focus on single cells, while the <b>passive</b> <b>test</b> is shown to be applicable to testing multiple cells. The <b>passive</b> <b>test</b> measures electrical characteristics of the fuel cell {{in the absence of}} electrochemical reactions. A simple ECM is developed to describe the cell behavior under the <b>passive</b> <b>test</b> conditions. Circuit model parameters of many series-connected cells can be acquired using the results of a single stack test. Proton exchange membrane fuel cells (PEMFCs) from three manufacturers were tested, ranging in system power from 12 – 500 W. Test results for each PEMFC exhibited similar behavior that is well predicted by the ECM. A strong similarity between a passive fuel cell and a double layer capacitor is discussed...|$|R
40|$|Abstract — In {{recent years}} Web-based systems have become {{extremely}} popular and, nowadays, {{they are used}} in critical environments such as financial, medical, and military systems. As the use of Web applications for security-critical services has increased, the number and sophistication of attacks against these applications have grown as well. For this reason {{it is essential to}} be able to prove that the target Web-based system implements its designed security requirements avoiding known vulnerabilities in HTTP-based solutions. To reach this aim, we can rely on several testing techniques and mainly on security <b>passive</b> <b>testing</b> approach that is becoming increasingly important to security-relevant aspects into web based software systems. This article describes the application of the TestInv-P <b>passive</b> <b>testing</b> tool as part of the testing phase of TXT e-tourism Web application. TestInv-P is a <b>passive</b> <b>testing</b> tool that monitors communication traces of an application during run-time and verifies whether it satisfies certain securityrelated invariants derived from SHIELDS models. 1 Keywords-testing: passive testing; Web based application; security requirements; invariants; practical experience. I...|$|R
40|$|The service-oriented {{approach}} {{is becoming more}} and more popular to integrate highly heterogeneous systems. Web services are the natural evolution of conventional mid-dleware technologies to support Web-based and enterprise-level integration. Formal testing of such Web-based tech-nology is a key point to guarantee its reliability. In this paper, we choose a non-intrusive approach based on mon-itoring to propose a conformance <b>passive</b> <b>testing</b> method-ology to check that a composed Web service respects its functional requirements. This methodology is based on a set of formal invariants representing properties to be tested including data and time constraints. <b>Passive</b> <b>testing</b> of an industrial system (that uses a composition of Web services) is briefly presented to demonstrate the effectiveness of the proposed approach. ...|$|R
40|$|International audienceThe {{validation}} of systems and specifically the conformance testing of communicating protocols {{is a crucial}} step to their development. Many approaches {{have been developed for}} a while, among which, the formal ones have proved their efficiency to test these protocols. These approaches are divided in two main sets: active and <b>passive</b> <b>testing</b> techniques. While they both have their own advantages and drawbacks, <b>passive</b> <b>testing</b> techniques are the only ones that can be applied when the controllability of the system interfaces is unavailable or when the implementation under test cannot be stimulated in runtime. In this paper, we present a logic-based <b>passive</b> <b>testing</b> approach to test in a formal way the conformance and the protocol performance requirements provided by the protocol standard or experts. We aim at formally specifying time related protocol properties in order to check them on real execution traces. Based on a new algorithm, a prototype is here developed and experienced. In order to evaluate and assess our technique, we present experiments through a set of IMS/SIP properties (regarding the conformance and the protocol performance) and execution traces. We finally discuss the results by providing relevant verdict...|$|R
40|$|AbstractBackgroundHUTT test {{is used in}} {{evaluation}} of syncope. Isoprenaline and isosorbide dinitrate are used to increase {{the sensitivity of the}} test. These drugs act by different mechanisms. We aimed to compare the results of isoprenaline with isosorbide dinitrate. Methods and resultsWe studied 198 subjects referred for HUTT to our institute; those above the age of 35 years were not included in our study, because isoprenaline was not used commonly above this age; thus, only 90 subjects were analyzed. We found that isosorbide dinitrate resulted in more HUTT-positive results than isoprenaline by absolute risk difference of 26 %; relative risk for positive isoprenaline was 60 %, confidence interval 0. 38 – 0. 93, and P value of 0. 03. There was no difference in frequency of types of responses, i. e. Type 1, Type 2, and Type 3 between <b>passive</b> <b>testing,</b> isosorbide dinitrate, and isoprenaline, confidence interval 1. 53 – 2. 02, and P value 0. 71. Time to get positive response was highest for <b>passive</b> <b>testing</b> followed by ISO and ISDN; the mean was 16. 85 ± 7. 00 min, 9. 85 ± 5. 84 min, and 7. 00 ± 3. 35 min, respectively. Statistically, ISDN versus ISO time to get positive response was not significant; P value was 0. 074 and 95 % confidence interval was − 0. 28 to 5. 98. ConclusionsIsosorbide dinitrate yields more positive HUTT than isoprenaline. The frequencies of type of responses are not different between <b>passive</b> <b>testing,</b> isosorbide dinitrate, and isoprenaline. There is no difference in time taken for positive response between isosorbide dinitrate and isoprenaline. In comparison to isosorbide dinitrate and isoprenaline, <b>passive</b> <b>testing</b> showed longest time for positive response...|$|R
50|$|Conducted {{the first}} <b>passive</b> safety <b>testing.</b>|$|R
40|$|International audienceThis paper {{presents}} {{a new approach}} to perform <b>passive</b> <b>testing</b> based on the analysis of the control and data part of the system under <b>test.</b> <b>Passive</b> <b>testing</b> techniques are based on the observation and verification of properties on the behaviour of a system without interfering with its normal operation. Many <b>passive</b> <b>testing</b> techniques consider only the control part of the system and neglect data, or are confronted with an overwhelming amount of data values to process. In our approach, we consider control and data parts by integrating the concepts of symbolic execution and we improve trace analysis by introducing trace slicing techniques. Properties are described using Input-Output Symbolic Transition Systems (IOSTSs) and we illustrate in the paper how they can be tested on real execution traces optimizing the trace analysis. These properties can be designed to test the functional conformance of a protocol as well as security properties. In addition to the theoretical approach, we have developed a software tool that implements the algorithms presented in this paper. Finally, as a proof of concept of our approach and tool we have applied the techniques to a real-life case study: the SIP protocol. In particular, the proposed techniques are applied to a set of real execution traces extracted from an IMS/SIP architectur...|$|R
40|$|Part 3 : Monitoring and Fault LocalizationInternational audienceTesting {{is mainly}} {{known as the}} process of {{checking}} that a system possesses a set of desired properties and behavior. Its importance and impact are becoming crucial and strategic for the deployment and use of software and systems. Several techniques have been defined all along the protocol testing process whose formal techniques that allow validating multiple facets of a protocol implementation such as their reliability, scalability, security, and in particular its conformance to the standardized requirements. Among these testing techniques, the ones denoted as passive are currently often applied. Indeed, there are non intrusive and based on network observations. In this paper, we therefore intend to help and guide the protocol testers regarding their testing choices by considering the functional protocol properties to check, and the analysis of testing verdicts obtained by applying <b>passive</b> <b>testing</b> tools. We propose a compared analysis of the application of two efficient <b>passive</b> <b>testing</b> methodologies. The comparison is performed through {{the study of the}} Session Initiation Protocol. The results analysis demonstrates that depending on the properties to test, the way to model them, the way of testing (on-line/off-line), the available testing time ressources, tradeoffs are needed. Thus, this analysis aims at guiding the testers when tackling the <b>passive</b> <b>testing</b> of communication protocol...|$|R
40|$|Language {{acquisition}} {{has been}} a topic of discussion in several branches of psychology through the last decades. Prior to this, it was a topic reserved to the linguists, but Noam Chomsky changed this fact. At the same time B. F. Skinner revealed his thoughts on the topic. Article one gives a short description of the disagreement between the two and continues into {{an overview of the}} behavior analytic view of language acquisition. The fact that sounds can be established as conditioned reinforcers through a classical conditioning procedure will be briefly discussed. This will be compared to the view that a person’s verbal behavior conforms to the verbal behavior of the verbal community surrounding the person because of the phenomenon of parity. Parity as a form of automatic reinforcement will be discussed. Article two describes an experiment which is a replication of Ostvik, Eikeseth, and Klintwall (2012); Wright (2006) and Whitehurst, Ironsmidt, and Goldfein (1974). The objective was to see if the verbal behavior of the children conformed to that of the experimenter. Three girls aged three years and six months participated in the study. Several pictures were shown to the girls. The experimenter and the subject took turn in describing the pictures. The experimenter always used a grammatical <b>incorrect</b> <b>passive</b> construction to describe the pictures. This construction was defined in advance. The subject’s verbal behavior was recorded and scored into groups of grammatical forms. The forms were: The grammatical <b>incorrect</b> <b>passive</b> construction; a correct passive reversible construction; the age-appropriate active construction and other unspecified verbal behavior. The results indicated that modeling had an effect on the verbal behavior of the children, supposedly in combination with automatic reinforcement via parity. Master i læring i komplekse systeme...|$|R
40|$|Web {{services}} are {{emerging as the}} standard paradigm for program-to-program interactions on Internet. They are gaining more and more momentum {{and are expected to}} {{play a key role in}} Next Generation Networks. For these reasons, their management is becoming critical. Fault management is one of the most challenging areas of network and service management. It includes fault detection, isolation and repair. This paper proposes a Web service-based architecture for detecting faults in Web services. The architecture is rooted in <b>passive</b> <b>testing.</b> <b>Passive</b> <b>testing</b> consists of observing and analyzing messages the component under test exchanges with its environment. The passive testers of our architecture are designed as Web services. The components of the architecture are presented and the potential interfacing technologies are evaluated. This evaluation has led us to the selection of mobile agents...|$|R
40|$|Abstract—Choreography {{supports}} the specification, {{with a global}} perspective, of the interactions between roles played by peers in a collaboration. Choreography conformance testing aims at verifying whether a set of distributed peers collaborates wrt. a choreography. Such collaborations are usually achieved through information exchange, thus taking data into account during the testing process is necessary. We address this issue by using a non-intrusive <b>passive</b> <b>testing</b> approach based on functional properties. A property can express a critical (positive or negative) behaviour to be tested on an isolated peer (locally) or {{on a set of}} peers (globally). We support online verification of these kind of properties against local running traces of each peer in a distributed system where no global clock is needed. Our framework is fully tool supported. Keywords-choreography, conformance checking, <b>passive</b> <b>testing,</b> online verification, tools. I...|$|R
40|$|In this paper, we {{employ a}} variant of the {{communicating}} finite state machine (CFSM) model for networks to investigate fault detection and location using <b>passive</b> <b>testing.</b> First, we introduce the concept of <b>passive</b> <b>testing,</b> then we introduce the model with necessary assumptions and justification. Then, the model for the observer process is described and a 3 -node case is studied to show how fault location information can be deduced. Extending this result, we propose a multiple node-cut approach for a general network, applying our technique for fault detection and location. An abstraction of a node-cut shows how the 3 -node case can be used in the general case. We then illustrate our technique through a simulation of a practical X. 25 example. Finally future extensions and potential trends are discussed...|$|R
40|$|Swine were {{infected}} orally with pure cultures of Treponema hyodysenteriae, and the humoral antibody response {{was measured by}} a <b>passive</b> hemolysis <b>test</b> (<b>passive</b> hemagglutination <b>test</b> {{with the use of}} complement). Antibody to T. hyodysenteriae was detected as early as 1 week and later on at 4 months after exposure. However, peak serum titers were obtained after challenge at 4 weeks postinfection. The usefulness of the test as a potential diagnostic tool for antibody to T. hyodysenteriae is discussed...|$|R
50|$|Today, TAE {{connectors}} {{are common}} in Germany and other central European countries like Liechtenstein and Luxembourg. Modern TAE sockets also contain circuits referred to as passiver Prüfabschluss, meaning <b>passive</b> <b>test</b> termination. This provides a discernible condition to the telephone exchange indicating that the line is continuous to the TAE-connected device.|$|R
40|$|This paper {{presents}} a methodology to perform <b>passive</b> <b>testing</b> of timed systems. In <b>passive</b> <b>testing,</b> the tester does not {{interact with the}} implementation under test. On the contrary, execution traces are observed without interfering with the behaviour of the system. Invariants are used to represent the most relevant expected properties of the implementation under test. Intuitively, an invariant expresses the fact that each time the implementation under test performs a given sequence of actions, it must exhibit a behaviour in a lapse of time reflected in the invariant. There {{are two types of}} invariants: consequent and observational. The paper gives two algorithms to decide the correctness of proposed invariants with respect to a given specification and algorithms to check the correctness of a log, recorded from the implementation under test, with respect to an invariant. The soundness of this methodology is shown by relating it to an implementation relation. In addition to the theoretical framework, a tool called PASTE has been developed. This tool helps in the automation of the <b>passive</b> <b>testing</b> approach because it implements all the algorithms presented in this paper. PASTE takes advantage of mutation testing techniques in order to evaluate the goodness of an invariant according to its capability to detect errors in logs generated from mutants. An empirical study where PASTE was used to analyse a non-trivial system is also reported...|$|R
40|$|International audiencePerformance {{testing of}} {{communicating}} protocols is a {{qualitative and quantitative}} evaluation of a system, aiming to check whether the performance requirements have been satisfied under certain conditions. It raises an interesting issue: how to formalize the specified detailed performance requirements by taking consideration of data values of the messages. The <b>passive</b> <b>testing</b> techniques are approaches {{that can be applied}} when the controllability of the system interfaces is unavailable or when the implementation under test cannot be stimulated in runtime. In this paper, we present a novel logic-based <b>passive</b> <b>testing</b> approach in specifying time related protocol properties to be tested on real execution traces. Based on a new algorithm, a prototype is developed and experienced. In order to evaluate and assess our approach, we present experiments through a set of IMS/SIP properties and real execution traces. Finally, relevant verdicts and discussions are provide...|$|R
40|$|International audienceIn {{this paper}} we propose a <b>passive</b> {{conformance}} <b>testing</b> technique applied to a Mobile ad hoc network (MANET) routing protocol, OLSR, that is characterized by a dynamically changing topology and lack of centralized management. This makes it necessary to investigate new ways to test complex scenarios and configurations. The work here proposes a formal <b>passive</b> <b>testing</b> method to test the conformance and reliability of the protocol. The method developed has been performed on a real case study showing that the approach can be successful applied and that it allows reducing inconclusive verdicts often observed using other methods...|$|R
40|$|This work {{explores the}} query {{complexity}} of property testing for general piecewise functions {{on the real}} line, in the active and <b>passive</b> property <b>testing</b> settings. The results are proven under an abstract zero-measure crossings condition, which has as special cases piecewise constant functions and piecewise polynomial functions. We find that, in the active testing setting, the query complexity of testing general piecewise functions is independent {{of the number of}} pieces. We also identify the optimal dependence on the number of pieces in the query complexity of <b>passive</b> <b>testing</b> in the special case of piecewise constant functions...|$|R
40|$|A <b>passive</b> {{haemagglutination}} <b>test,</b> using sheep {{red blood}} cells sensitised with Salmonella typhi lipopolysaccharide, was compared with the Widal test for the serological diagnosis of typhoid fever in an endemic area. The results obtained on sera from 152 patients with bacteriologically confirmed typhoid and 183 patients {{who did not have}} typhoid were analysed in terms of sensitivity, specificity, simplicity, and rapidity of the respective <b>tests.</b> The <b>passive</b> haemagglutination <b>test</b> was found to be more sensitive (80 %) than the S typhi O antigen (71 %) but marginally less sensitive than the H antigen (82 %) of the Widal test. The false positive rate on control sera was 1. 2 % and 6. 6 %, respectively, for the Widal O and H antigens, and 1. 6 % for the <b>passive</b> haemagglutination <b>test.</b> Our findings indicate that the <b>passive</b> haemagglutination <b>test</b> is comparable with the Widal test for the serological diagnosis of typhoid fever in endemic areas, but is more simple, rapid, and economic. The <b>passive</b> haemagglutination <b>test</b> may be a useful alternative to the Widal test for the serological diagnosis of typhoid fever in busy microbiology laboratories in areas in which the disease is endemic...|$|R
40|$|Given a {{property}} of Boolean functions, {{what is the}} minimum number of queries required to determine with high probability if an input function satisfies this property? This is a fundamen-tal question in Property Testing, where traditionally the testing algorithm is allowed to pick its queries among the entire set of inputs. Balcan et al. have recently suggested to restrict the tester to take its queries from a smaller, typically random, subset of the inputs. This model is called active testing, in resemblance of active learning. Active testing gets more difficult as {{the size of the}} set we can query from decreases, and the extreme case is when it is exactly the number of queries we perform (so the algorithm actually has no choice). This is known as <b>passive</b> <b>testing,</b> or testing from random examples. In their paper, Balcan et al. have shown that active and <b>passive</b> <b>testing</b> of dictator functions is as hard as learning them, and requires Θ(logn) queries (unlike the classic model, in which it can be done in a constant number of queries). We extend this result to k-linear functions, proving that <b>passive</b> and active <b>testing</b> of them requires Θ(k logn) queries, assuming k is not too large...|$|R
40|$|A test oracle is a {{mechanism}} {{that is used}} during testing {{to determine whether a}} software component behaves correctly or not. The test oracle problem is widely acknowledged in the software testing literature and many methods for test oracle development have been proposed. Most of these methods use specifications or other resources to develop <b>test</b> oracles. A <b>passive</b> <b>test</b> oracle checks the behaviour of the component, but does not reproduce this behaviour. In this paper, we present a technique that develops <b>passive</b> <b>test</b> oracles for components using their APIs. This simple technique can be applied to any software component that is accessed through an API. In an initial experiment, we found that test oracles developed this way were more effective at finding faults with {{a relatively small number of}} test cases than test oracles developed from a formal specification and developed as a parallel implementation. 1...|$|R
40|$|In {{this paper}} we extend our {{previous}} work on <b>passive</b> <b>testing</b> of timed systems {{to establish a}} formal criterion to determine correctness of an implementation under test. In our framework, an invariant expresses {{the fact that if}} the implementation under test performs a given sequence of actions, then it must exhibit a behavior in a lapse of time reflected in the invariant. In a previous paper we gave an algorithm to establish the correctness of an invariant with respect to a specification. In this paper we continue the work by providing an algorithm to check the correctness of a log, recorded form the implementation under test, with respect to an invariant. We show the soundness of our method by relating it to an implementation relation. In addition to the theoretical framework we have developed a tool, called PASTE, that facilitates the automation of our <b>passive</b> <b>testing</b> approach...|$|R
40|$|In {{this paper}} we {{introduce}} a formal Methodology to perforin <b>passive</b> <b>testing,</b> based on invariants, for systems where {{the passing of}} time is represented in probabilistic terms by means of probability distributions functions. In our approach, invariants express the fact that each time the implementation under test performs a given sequence of actions, then it must exhibit a behavior according to the probability distribution functions reflected it? the invariant. We present algorithms to decide the correctness of the proposed invariants {{with respect to a}} given specification. Once we know that an invariant is correct, we check whether the execution traces observed from the implementation respect the invariant. In addition to the theoretical framework we have developed a tool., called PASTE, that helps in the automation of our <b>passive</b> <b>testing</b> approach. We have used the tool to obtain experimental results front the application of our methodology...|$|R
