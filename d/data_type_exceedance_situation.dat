0|10000|Public
50|$|A new <b>data</b> <b>type</b> can be added, {{possibly}} with default <b>data</b> <b>type</b> ID, {{as long as}} {{the default}} <b>data</b> <b>type</b> ID doesn’t conflict with one of the existing <b>data</b> <b>types.</b>|$|R
5000|$|ActionScript {{primarily}} {{consists of}} [...] "fundamental" [...] or [...] "simple" [...] <b>data</b> <b>types</b> {{which are used}} to create other <b>data</b> <b>types.</b> These <b>data</b> <b>types</b> {{are very similar to}} Java <b>data</b> <b>types.</b> Since ActionScript 3 was a complete rewrite of ActionScript 2, the <b>data</b> <b>types</b> and their inheritances have changed.|$|R
50|$|Data Type: The <b>Data</b> <b>Type</b> {{specifies}} how the payload of {{the message}} shall be interpreted with respect to its <b>data</b> <b>type</b> (i.e. floating-point <b>data</b> or number of bytes in case of integer data). The corresponding <b>data</b> <b>type</b> code is taken from the CANaerospace <b>data</b> <b>type</b> list which allows also user-defined <b>data</b> <b>type</b> definitions.|$|R
50|$|Two pins in OpenWire {{can connect}} and {{exchange}} data {{only if they}} support compatible <b>data</b> <b>types.</b> Each pin can support one or more <b>data</b> <b>types.</b> The <b>data</b> <b>types</b> are distinguished by GUID unique for each <b>data</b> <b>type.</b>|$|R
5000|$|Many {{implementations}} of YAML {{can support}} user-defined <b>data</b> <b>types</b> for object serialization. Local <b>data</b> <b>types</b> are not universal <b>data</b> <b>types</b> but are {{defined in the}} application using the YAML parser library. Local <b>data</b> <b>types</b> use a single exclamation mark (...) [...]|$|R
50|$|In some {{programming}} environments {{the term}} complex <b>data</b> <b>type</b> (in contrast to primitive <b>data</b> <b>types)</b> is {{a synonym for}} the composite <b>data</b> <b>type.</b>|$|R
5000|$|Care has to {{be taken}} for select <b>data</b> <b>types</b> based on defined <b>data</b> <b>types.</b> Here the name of the defined <b>data</b> <b>type</b> gets mapped too.|$|R
40|$|<b>Data</b> <b>types</b> are {{the core}} of many applications, and {{libraries}} offering implementations of <b>data</b> <b>types</b> should better be solid and well tested. Testing purely functional <b>data</b> <b>types</b> with QuickCheck provides a complete test method for <b>data</b> <b>types,</b> but establishing a complete test method for <b>data</b> <b>types</b> with side-effects is still an open issue. In this paper we show how we can use a stateful QuickCheck model to establish a complete test method for any <b>data</b> <b>type.</b> Considering side effects allows us {{to move from the}} purely functional world to the imperative world, as needed to face the testing of <b>data</b> <b>types</b> implementations in languages such as C. We therefore applied our method to some of the <b>data</b> <b>types</b> provided by the well-known GNOME Glib library...|$|R
50|$|In {{computer}} science, {{a composite}} <b>data</b> <b>type</b> or compound <b>data</b> <b>type</b> is any <b>data</b> <b>type</b> {{which can be}} constructed in a program using the programming language's primitive <b>data</b> <b>types</b> and other composite types. It is sometimes called a structure or aggregate <b>data</b> <b>type,</b> although the latter term may also refer to arrays, lists, etc. The act of constructing a composite type is known as composition.|$|R
50|$|The main way of {{defining}} <b>data</b> <b>types</b> in Agda is via inductive <b>data</b> <b>types</b> which {{are similar to}} algebraic <b>data</b> <b>types</b> in non-dependently typed programming languages.|$|R
40|$|Abstract: Various fuzzy {{data models}} such as fuzzy {{relational}} databases, fuzzy object-oriented databases, fuzzy objectrelational databases and fuzzy XML {{have been proposed}} in the literature in order to represent and process fuzzy information in databases and XML. But little {{work has been done}} in modeling fuzzy <b>data</b> <b>types.</b> Actually in the fuzzy data models, each fuzzy value is associated with a fuzzy <b>data</b> <b>type.</b> Explicit representations of fuzzy <b>data</b> <b>types</b> are the foundation of fuzzy data processing. To fill this gap, in this paper, we propose several fuzzy <b>data</b> <b>types,</b> including fuzzy simple <b>data</b> <b>types,</b> fuzzy collection <b>data</b> <b>types</b> and fuzzy defined <b>data</b> <b>types.</b> We further investigate how to declare the fuzzy <b>data</b> <b>types</b> in the fuzzy object-oriented database model and fuzzy XML Schema. The proposed fuzzy <b>data</b> <b>types</b> can meet the requirement of modeling fuzzy data in the fuzzy databases and fuzzy XML...|$|R
50|$|Although Excel {{nominally}} {{works with}} 8-byte numbers by default, VBA has {{a variety of}} <b>data</b> <b>types.</b> The Double <b>data</b> <b>type</b> is 8 bytes, the Integer <b>data</b> <b>type</b> is 2 bytes, and the general purpose 16 byte Variant <b>data</b> <b>type</b> can be converted to a 12 byte Decimal <b>data</b> <b>type</b> using the VBA conversion function CDec. Choice of variable types in a VBA calculation involves consideration of storage requirements, accuracy and speed.|$|R
50|$|In {{computer}} programming languages, a recursive <b>data</b> <b>type</b> (also {{known as a}} recursively-defined, inductively-defined or inductive <b>data</b> <b>type)</b> is a <b>data</b> <b>type</b> for values that may contain other values of the same <b>type.</b> <b>Data</b> of recursive <b>types</b> are usually viewed as directed graphs.|$|R
40|$|A program {{derivation}} {{is said to}} be polytypic if some of its {{parameters are}} <b>data</b> <b>types.</b> Polytypic program derivations necessitate a general, non-inductive definition of `data type'. Here we propose such a definition: a <b>data</b> <b>type</b> is a relator that has membership. It is shown how this definition implies various other properties that are shared by all <b>data</b> <b>types.</b> In particular, all <b>data</b> <b>types</b> have a unique strength, and all natural transformations between <b>data</b> <b>types</b> are strong. 1 Introduction What is a <b>data</b> <b>type?</b> It is easy to list a number of examples: pairs, lists, bags, finite sets, possibly infinite sets, function spaces... but such a list of examples hardly makes a definition. The obvious formalisation is a definition that builds up the class of <b>data</b> <b>types</b> inductively; such an inductive definition, however, leads to cumbersome proofs if we want to prove a property of all <b>data</b> <b>types.</b> Here we aim to give a non-inductive characterisation, defining a <b>data</b> <b>type</b> as a mathematical object [...] ...|$|R
50|$|Cg also {{features}} vector and matrix <b>data</b> <b>types</b> {{that are based}} on the basic <b>data</b> <b>types,</b> such as float3 and float4x4. Such <b>data</b> <b>types</b> are quite common when dealing with 3D graphics programming. Cg also has struct and array <b>data</b> <b>types,</b> which work in a similar way to their C equivalents.|$|R
30|$|Elements of the {{specific}} vector have the same <b>data</b> <b>types,</b> meaning that conversion of different <b>data</b> <b>types</b> to one <b>data</b> <b>type</b> for vectors should be done before employing the vector model.|$|R
50|$|Once {{declared}} deprecated, the <b>data</b> <b>type</b> will {{be maintained}} {{for at least}} two more years. After this period its default <b>data</b> <b>type</b> ID may be reused for an incompatible <b>data</b> <b>type.</b>|$|R
40|$|Data {{interoperability}} is {{an ongoing}} challenge for global open data initiatives. The machine-readable specification of <b>data</b> <b>types</b> for datasets will help address interoperability issues. <b>Data</b> <b>types</b> have typically been at the syntactical level such as integer, float and string, etc. in programming languages. The work {{presented in this paper}} is a model design for the semantic specification of <b>data</b> <b>types,</b> such as a topographic map. The work was conducted {{in the context of the}} Semantic Web. The model differentiates the semantic <b>data</b> <b>type</b> from the basic <b>data</b> <b>type.</b> The former are instances (e. g., topographic map) of a specific <b>data</b> <b>type</b> class that is defined in the developed model. The latter are classes (e. g., Image) of resource types in existing ontologies. A data resource is an instance of a basic <b>data</b> <b>type</b> and is tagged with one or more specific <b>data</b> <b>types.</b> The implementation of the model is given within an existing production data portal that enables one to register specific <b>data</b> <b>types</b> and use them to annotate data resources. Data users can obtain explicating assumptions or information inherent in a dataset through the specific <b>data</b> <b>types</b> of that dataset. The machine-readable information of specific <b>data</b> <b>types</b> also paves the way for further studies, such as dataset recommendation...|$|R
5000|$|There are {{additional}} [...] "complex" [...] <b>data</b> <b>types.</b> These are more processor and memory intensive and consist of many [...] "simple" [...] <b>data</b> <b>types.</b> For AS2, {{some of these}} <b>data</b> <b>types</b> are: ...|$|R
5000|$|A {{wide range}} of {{computational}} <b>data</b> <b>types,</b> program control <b>data</b> <b>types,</b> and forms of <b>data</b> structure (strong <b>typing).</b>|$|R
30|$|Another notable {{issue in}} {{exploring}} the AoaS layout {{is the use}} of build-in <b>data</b> <b>types.</b> CUDA has provided various build-in <b>data</b> <b>types.</b> The size requirement for alignment is automatically fulfilled. Compared to those user-defined <b>data</b> <b>types</b> in AoaS formant (see Fig.  3), we have found the counterparts of the build-in <b>data</b> <b>types</b> provided by CUDA do not achieve notable advantages. In addition, the user-defined AoaS <b>data</b> <b>types</b> are suggested to be used for the convenience in programming.|$|R
40|$|A program {{derivation}} {{is said to}} be polytypic if some of its {{parameters are}} <b>data</b> <b>types.</b> Polytypic program derivations necessitate a general non inductive definition of ‘data type’. Here we propose such a definition: a <b>data</b> <b>type</b> is a relator that has membership. It is shown how this definition implies various other properties that are shared by all <b>data</b> <b>types.</b> In particular, all <b>data</b> <b>types</b> have a unique strength, and all natural transformations between <b>data</b> <b>types</b> are strong...|$|R
5000|$|<b>Data</b> <b>types</b> are {{restricted}} to the following core data types: boolean, string, integer, real, date, timestamp, and arbitrary_id, {{or one of the}} following domain-specific data types: numeric, string, enumerated, and composite. Domain-specific numeric and string <b>data</b> <b>types</b> can represent subsets of the core <b>data</b> <b>types.</b> The domain-specific composite <b>data</b> <b>type</b> is to always be treated as a single unit within the domain. e.g., a MailingAddress composite <b>data</b> <b>type</b> could be declared, but city information couldn't be extracted from it.|$|R
5000|$|Null - The Null <b>data</b> <b>type</b> {{contains}} only one value, null. This is the default {{value for the}} String <b>data</b> <b>type</b> and all classes that define complex <b>data</b> <b>types,</b> including the Object class.|$|R
40|$|A {{theory of}} <b>data</b> <b>types</b> and a {{programming}} language based on category theory are presented. <b>Data</b> <b>types</b> {{play a crucial role}} in programming. They enable us to write programs easily and elegantly. Various programming languages have been developed, each of which may use different kinds of <b>data</b> <b>types.</b> Therefore, it becomes important to organize <b>data</b> <b>types</b> systematically so that we can understand the relationship between one <b>data</b> <b>type</b> and another and investigate future directions which lead us to discover exciting new <b>data</b> <b>types.</b> There have been several approaches to systematically organize data types: algebraic specification methods using algebras, domain theory using complete partially ordered sets and type theory using the connection between logics and <b>data</b> <b>types.</b> Here, we use category theory. Category theory has proved to be remarkably good at revealing the nature of mathematical objects, and we use it to understand the true nature of <b>data</b> <b>types</b> in programming...|$|R
40|$|Windowing Toolkit (AWT) that {{provides}} an abstract layer enabling {{the user to}} port Java applications easily from one window system to another 3. 2. 1 <b>Data</b> <b>Types</b> and Objects Everything in Java is an object; even the primitive <b>data</b> <b>types</b> can be encapsulated inside librarysupplied objects. Refer to Table 3 - 1 for primitive <b>data</b> <b>types</b> and definitions. Table 3 - 1. Primitive <b>data</b> <b>types</b> and definitions. <b>Data</b> <b>type</b> Definition Numeric Integer [...] 8 -bit byte, 16 -bit short, 32 -bit int, and 64 -bit long Real [...] 32 -bit float and 64 -bit double Boolean distinct <b>data</b> <b>type</b> [...] true or false Arrays real object with a runtime representation; can declare and allocate arrays of any type and can allocate arrays of arrays to obtain multidimensional arrays "The Java Language Environment: A White Paper" 23 20 The <b>data</b> <b>types</b> and sizes referenced in Table 3 - 2 are standard across all implementations of Java. Table 3 - 2. Sizes of <b>data</b> <b>types.</b> <b>Data</b> <b>Type</b> Size byte 8 -bit two's complement short 16 -bit two's [...] ...|$|R
40|$|Building on Wouter Swierstra’s <b>Data</b> <b>types</b> à la carte, {{we present}} a {{comprehensive}} Haskell library of compositional <b>data</b> <b>types</b> suitable for practical applications. In this framework, <b>data</b> <b>types</b> and functions on them can be defined in a modular fashion. We extend the existing work by implementing {{a wide array of}} recursion schemes including monadic computations. Above all, we generalise recursive <b>data</b> <b>types</b> to contexts, which allow us to characterise a special yet frequent kind of catamorphisms. The thus established notion of term homomorphisms allows for flexible reuse and enables shortcut fusion style deforestation which yields considerable speedups. We demonstrate our framework in the setting of compiler construction, and moreover, we compare compositional <b>data</b> <b>types</b> with generic programming techniques and show that both are comparable in run-time performance and expressivity while our approach allows for stricter types. We substantiate this conclusion by lifting compositional <b>data</b> <b>types</b> to mutually recursive <b>data</b> <b>types</b> and generalised algebraic <b>data</b> <b>types.</b> Lastly, we compare the run-time performance of our techniques with traditional implementations over algebraic <b>data</b> <b>types.</b> The results are surprisingly good...|$|R
50|$|In {{computer}} science, an opaque <b>data</b> <b>type</b> is a <b>data</b> <b>type</b> whose concrete <b>data</b> {{structure is}} not defined in an interface. This enforces information hiding, since its values {{can only be}} manipulated by calling subroutines that {{have access to the}} missing information. The concrete representation of the type is hidden from its users, and the visible implementation is incomplete. A <b>data</b> <b>type</b> whose representation is visible is called transparent. Opaque <b>data</b> <b>types</b> are frequently used to implement abstract <b>data</b> <b>types.</b>|$|R
25|$|Define a <b>data</b> <b>type,</b> and how {{values of}} that <b>data</b> <b>type</b> are combined.|$|R
5000|$|Additional <b>data</b> <b>types</b> and {{attributes}} {{corresponding to}} common PC <b>data</b> <b>types</b> (e.g. [...] , [...] ).|$|R
40|$|We {{propose to}} extend iUML-B class-diagrams to {{elaborate}} Abstract <b>Data</b> <b>Types</b> (ADTs) specified using Event-B theories. Classes {{are linked to}} <b>data</b> <b>types,</b> while attributes and associations correspond to operators of the <b>data</b> <b>types.</b> Axioms about the <b>data</b> <b>types</b> and operators are specified as constraints on the class. We illustrate our approach on a development of a control system in the railway domain...|$|R
2500|$|Boolean <b>data</b> <b>type</b> is a <b>data</b> <b>type,</b> {{having two}} values (usually denoted true and false) ...|$|R
5000|$|New <b>data</b> <b>type</b> {{declaration}} syntax, {{to specify}} the <b>data</b> <b>type</b> and other attributes of variables ...|$|R
5000|$|... {{introduced}} extended algebraic <b>data</b> <b>types</b> which combine GADTs {{together with}} the existential <b>data</b> <b>types</b> and type class constraints introduced by , [...] and [...]|$|R
5000|$|... the {{principle}} of <b>data</b> <b>type</b> completeness : All <b>data</b> <b>types</b> {{should have the same}} rights in the language. All <b>data</b> <b>types</b> should be allowed in general operations such as assignment or being passed as a parameter. (See first-class citizen.) ...|$|R
5000|$|New {{attributes}} {{for better}} support of object-oriented programming - the , , and [...] statement to introduce user-defined types, the [...] locator <b>data</b> <b>type,</b> the [...] <b>data</b> <b>type</b> itself, the [...] <b>data</b> <b>type,</b> and built-in functions for manipulating the new types.|$|R
