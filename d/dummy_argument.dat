11|12|Public
5000|$|If {{an actual}} {{argument}} is a pointer then, if the <b>dummy</b> <b>argument</b> {{is also a}} pointer, ...|$|E
5000|$|If the <b>dummy</b> <b>argument</b> {{is not a}} pointer, {{it becomes}} {{associated}} with {{the target of the}} actual argument: ...|$|E
5000|$|... is illegal. Also, {{a section}} with a vector {{subscript}} {{must not be}} supplied as an actual argument to an [...] or [...] <b>dummy</b> <b>argument.</b> Arrays of arrays are not allowed: ...|$|E
50|$|It allows full checks at compile {{time between}} actual and <b>dummy</b> <b>arguments.</b>|$|R
5000|$|Allocatable {{components}} of derived types, allocatable <b>dummy</b> <b>arguments,</b> and allocatable function results ...|$|R
5000|$|Σ1 = { true, false, nil, cons(.,.) } is our ranked alphabet, arities {{indicated}} by <b>dummy</b> <b>arguments</b> (i.e. the symbol cons has arity 2), ...|$|R
50|$|Examples {{of where}} a {{variable}} might only be referenced once is as a <b>dummy</b> <b>argument</b> in a function call, or when its address {{is assigned to}} another variable which subsequently accesses its allocated storage.|$|E
5000|$|... the {{corresponding}} <b>dummy</b> <b>argument</b> specification defines only {{the type and}} rank of the array, not its shape. This information {{has to be made}} available by an explicit interface, often using an interface block (see Interface blocks). Thus we write just ...|$|E
5000|$|The {{notation}} [...] denotes {{a function}} which takes one argument and returns it unchanged, printing the single character x {{as a side}} effect when it is invoked. [...] represents the version of the identity function that has no such side effect; it is used here as a <b>dummy</b> <b>argument.</b> The program [...] applies the -printing function to a <b>dummy</b> <b>argument</b> of , returning [...] and printing the letter [...] as a side effect. Similarly, [...] first applies [...] to , printing the letter [...] and returning this result of [...] is then applied to [...] {{as in the previous}} example. The function [...] is syntactic sugar for the function that prints a newline character.|$|E
5000|$|The <b>dummy</b> <b>arguments</b> {{cannot be}} used in {{specification}} expressions (see above) except asarguments to certain intrinsic functions ( [...] , , , and the numeric inquiry ones, (see below).|$|R
50|$|Diagonal, {{together}} with addition of <b>dummy</b> <b>arguments</b> and rearrangement of arguments, {{can build a}} relation asserting the equality of any two of its arguments; thus repeated variables can be handled.|$|R
50|$|Elemental {{procedures}} are specified with scalar <b>dummy</b> <b>arguments</b> {{that may be}} called witharray actual arguments. In {{the case of a}} function, the shape of the result is the shape of the arrayarguments.|$|R
5000|$|An {{important}} {{supplement to}} Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally {{known as the}} Allocatable TR. This specification defined enhanced use of [...] arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers. Such uses include [...] arrays as derived type components, in procedure <b>dummy</b> <b>argument</b> lists, and as function return values. ( [...] arrays are preferable to -based arrays because [...] arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage. In addition, elements of allocatable arrays are contiguous, and aliasing {{is not an issue}} for optimization of array references, allowing compilers to generate faster code than in the case of pointers.) ...|$|E
3000|$|... where Ω is a <b>dummy</b> <b>argument</b> {{representing}} the spatial position (φ and λ), and K represents the intermediary integration kernel (averaged Poisson’s kernel).|$|E
40|$|Handling the {{procedure}} interface in an HPF compiler is complex {{due to the}} many possible combinations of Fortran 90 /HPF properties of an actual array argument and its associated <b>dummy</b> <b>argument.</b> This paper describes an algorithm that reduces this complexity by mapping all the combinations of properties to a small set of canonical Internal Representations. These internal representations {{as well as the}} necessary run-time descriptors are also described. The algorithm has been implemented in the commercial HPF compiler produced by the Prepare project. ...|$|E
40|$|SUPERMAP {{computer}} {{program designed to}} produce map of all components and attributes of FORTRAN program. Maps usage of all variables and all COMMONs used in FORTRAN program. Maps alignment of subprograms CALLed with the <b>arguments</b> and <b>dummy</b> <b>arguments</b> of the CALLed subprogram. Tallies externals called by each module. Written in FORTRAN 77...|$|R
40|$|The aim of {{this paper}} is to {{summarize}} the new features in the draft Fortran 2000 standard (J 3 2002). We take as our starting point Fortran 95 plus the two official extensions (Cohen 2001, Reid 2001) that have been published as Type 2 Technical Reports. These provide features for 1. Allocatable <b>dummy</b> <b>arguments</b> and type components, and 2. Support for the five exceptions of the IEEE Floating Point Standard (IEEE 1989) and for other features of this Standard...|$|R
50|$|The default calling {{convention}} for programs {{written in the}} PL/I language passes all arguments by reference, although other conventions may optionally be specified. The arguments are handled differently for different compilers and platforms, but typically the argument addresses are passed via an argument list in memory. A final, hidden, address may be passed pointing to an area to contain the return value. Because of {{the wide variety of}} data types supported by PL/I a data descriptor may also be passed to define, for example, the lengths of character or bit strings, the dimension and bounds of arrays (dope vectors), or the layout and contents of a data structure. <b>Dummy</b> <b>arguments</b> are created for arguments which are constants or which do not agree with the type of argument the called procedure expects.|$|R
40|$|Handling the {{procedure}} interface in an HPF compiler is complex {{due to the}} many possible combinations of Fortran 90 /HPF properties of an actual array argument and its associated <b>dummy</b> <b>argument.</b> This paper describes an algorithm that reduces this complexity by mapping all the combinations of properties to a small set of canonical Internal Representations. These internal representations {{as well as the}} necessary run-time decsriptors are also described. The algorithm has been implemented in the commercial HPF compiler produced by the Prepare project. 1 Introduction In the recently completed Prepare project [9] a commercial HPF 2. 0 compiler ([6], [7]) has been implemented. Most current HPF compilers first generate C or fortran code as intermediate representation which is than translated by a conventional compiler to code for the target processor. This facilitates the retargeting of the compiler to another processor, but hampers code quality due to the limitations of C and fortran. In contr [...] ...|$|E
40|$|The focal {{object of}} study in this {{bachelor}} thesis is the Islamic Corporate Social Responsibility, the financing instruments of its complying companies and whether financial markets value it or not. As an introduction, one discusses the main concepts around Islamic morality including an appraisal {{to the idea of}} justice and its differences between Islam and the western approach. Then, a review of the Shari’ah (the Islamic law that governs social and economical relations) is done to further understand the Islamic approach to Corporate Social Responsibility. The principles of Riba prohibition, risk sharing, real asset backing, wealth accounting, speculative behaviour veto and asymmetric-information-ban are debated. After that, one argues the technical insights between the concept of Riba (interest) and its prohibition in the Islamic economic transactions. Subsequently, there is a thorough description of the external financing tools included in the Shari’ah, their main goals and the dissimilarities with their vanilla counterparts. Thus, it can be stated that there is a mainstream counterpart for every Islamic financing instrument. Nonetheless, there are risk structure significant disparities. The efficient market hypothesis (EMH) acknowledges that any difference in the risk of a financial product shall be discounted through the required profitability rate. Consequently, our main hypothesis outlines that Islamic Corporate Social Responsibility should not affect value creation in the financial markets. In order to test our hypothesis, an Ordinary Least Squares (OLS) model is proposed including the monthly average return of an equity stock as the dependent variable. We set as independent variables the standard deviation of the monthly average return and a <b>dummy</b> <b>argument</b> applying for the Shari’ah compliance. The sample includes the S&P 500 index and S&P 500 Shari’ah index time series from January 2012 to December 2014. After running 36 OLS regressions, it can be observed that none of the 36 Shari’ah compliance coefficients is statistically significant. Thus we cannot reject our null hypothesis. As a main conclusion, it can be stated that Islamic Corporate Social Responsibility shall not create value in financial markets...|$|E
5000|$|These axioms license adding <b>dummy</b> <b>arguments,</b> and rearranging {{the order}} of arguments, in {{relations}} of any arity. The peculiar form of Association is designed exactly {{to make it possible}} to bring any term in a list of arguments to the front (with the help of Converses). We represent the argument list [...] as [...] (it is a pair with the first argument as its first projection and the [...] "tail" [...] of the argument list as the second projection). The idea is to apply Assoc1 until the argument to be brought to the front is second, then apply Conv1 or Conv2 as appropriate to bring the second argument to the front, then apply Assoc2 until the effects of the original applications of Assoc1 (which are now behind the moved argument) are corrected.|$|R
40|$|The aim of {{this paper}} is to {{summarize}} the new features in the draft Fortran 2000 standard (J 3 2002). We take as our starting point Fortran 95 plus the two official extensions (Cohen 2001, Reid 2001) that have been published as Type 2 Technical Reports. These provide features for 1. Allocatable <b>dummy</b> <b>arguments</b> and type components, and 2. Support for the five exceptions of the IEEE Floating Point Standard (IEEE 1989) and for other features of this Standard. There is a firm commitment to include the features of these TRs in Fortran 2000, apart from changes that follow from errors and omissions found during implementation. Therefore, these features are not open to comment and are not described here. For an informal description, see chapters 12 and 13 of Metcalf and Reid (1999). Fortran 2000 is a major extension of Fortran 95. This contrasts with Fortran 95, which was a minor extension of Fortran 90. Beside the two TR items, the major changes concern object orientation and interfacing with C. Allocatable arrays are very important for optimization – after all, good execution speed is Fortran’s forte. Exception handling is needed to write robust code. Object orientation provides a...|$|R
50|$|The {{floating}} point arithmetic modules were both multi-stage processors which were driven by explicit instructions. In the two-stage adder an assembler instruction such as FADD DX,DY would load values from data pads DX and DY into stage one of the adder. A subsequent FADD instruction {{would be required to}} present the result at the adder's output. This second FADD could be a <b>dummy</b> with no <b>arguments,</b> or it could be the next calculation in a sequence. In this fashion a stream of FADD operations could be performed in a pipeline, with a new result in every instruction cycle though every addition requires two cycles.|$|R

