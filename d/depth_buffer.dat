107|89|Public
500|$|Although Wipeout 2048 and Wipeout HD have {{a shared}} shader program {{and did not}} require {{retooling}} for the Vita's architecture, Roberts said that a [...] "great deal" [...] of time and attention was spent fine-tuning the game's shader effects for the Vita's GPU. Lovegrove thought that the method of working on a PlayStation 3 and its handheld counterpart was identical (a sentiment generally shared by the team), and Roberts said that the systems' similarities helped the team [...] "get moving quickly". Roberts added that the game's lighting system was identical to that of Wipeout HD; both games' ships shared image-based lighting, with blended diffuse and specular highlights effects and the vertex-based lighting system used for weaponry. According to Roberts, {{the main difference between}} the games was PlayStation Vita's utilisation of the effects via the GPU; PlayStation 3 relied on SPUs. The team decided to use anti-aliased colour buffers for real-time shadow rendering, instead of depth buffers. This gave the game greater transparency effects, since the memory cost of anti-aliasing was 8 bits per pixel; therefore, 4x MSAA (multisample anti-aliasing) buffers contained the same amount of memory as a 32-bit <b>depth</b> <b>buffer.</b> Another feature which Roberts considered an improvement was tone mapping (partly due to Vita's superior support of buffer formats), which gave Wipeout 2048 better exposure control and bloom effects.|$|E
5000|$|<b>Depth</b> <b>buffer,</b> Stencil buffer, for {{different}} parts of image information ...|$|E
50|$|A {{stencil buffer}} is an extra buffer, in {{addition}} to the color buffer and <b>depth</b> <b>buffer</b> (z-buffering) found on modern graphics hardware. The buffer is per pixel, and works on integer values, usually with a depth of one byte per pixel. The <b>depth</b> <b>buffer</b> and stencil buffer often share the same area in the RAM of the graphics hardware.|$|E
5000|$|... 800 million trilinear mip-mapped, textured, 16-bit texel, <b>depth</b> <b>buffered</b> pixels {{per second}} ...|$|R
5000|$|... 750 million trilinear mip-mapped, textured, 16-bit texel, {{four by four}} {{sub-sample}} anti-aliased, <b>depth</b> <b>buffered</b> pixels {{per second}} ...|$|R
5000|$|... // enable {{color and}} <b>depth</b> <b>buffers.</b> glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); glDepthMask(GL_TRUE); // no more modifying of stencil buffer on stencil and depth pass. glStencilMask(0x00); // {{can also be}} {{achieved}} by glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); // stencil test: only pass stencil test at stencilValue == 1 (Assuming depth test would pass.) [...] // and write actual content to <b>depth</b> and color <b>buffer</b> only at stencil shape locations. glStencilFunc(GL_EQUAL, 1, 0xFF); [...] draw_actual_content (...) ...|$|R
5000|$|Attach the <b>depth</b> <b>buffer</b> (either as a RenderBuffer or a texture) to the FBO.|$|E
5000|$|Is more {{flexible}} {{because all of}} <b>depth</b> <b>buffer,</b> stencil buffer, etc. can be acquired.|$|E
5000|$|Approaching {{the distant}} plane to {{restrict}} scene such as far clip plane, thus increasing {{the accuracy of}} the <b>depth</b> <b>buffer,</b> or reducing the distance at which objects are visible in a scene. Increasing the number of bits allocated to the <b>depth</b> <b>buffer,</b> which is possible at the expense of memory for the stencil buffer. Staying away polygons, which could be inconsistent with the requirements elaborated scene.|$|E
5000|$|... 3. Stencil Function passes/Depth Function passes: [...] If say func is GL_ALWAYS, the stencil {{test will}} always pass. If depth test also passes. Both Color/Depth buffer are {{modified}}. Stencil buffer is modified as per glStencilOp zpass. If say, glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP) then Stencil values are not changed, only Color and <b>Depth</b> <b>buffers</b> are modified.|$|R
50|$|Processing of 3D {{graphics}} is computationally expensive, {{especially in}} real-time games, and poses multiple limits. Levels {{have to be}} processed at tremendous speeds, {{making it difficult to}} render vast skyscapes in real time. Additionally, realtime graphics generally have <b>depth</b> <b>buffers</b> with limited bit-depth, which puts a limit on the amount of details that can be rendered at a distance.|$|R
30|$|The {{trend for}} soil buffer pH among {{treatments}} {{was similar to}} pH (Table  5). At 0 – 7.5  cm, buffer pH was greater in FSTW–B/P and STW-F than the other treatments. At 7.5 – 15  cm, buffer pH was greater in STW-F than STCW and FSTCW. At other <b>depths,</b> <b>buffer</b> pH was not different among treatments and averaged 7.44, 7.59, 7.69, and 7.72 at 15 – 30, 30 – 60, 60 – 90, and 90 – 120  cm, respectively. Buffer pH was lower under continuous wheat than wheat-fallow at 0 – 7.5 and 7.5 – 15  cm and lower than wheat–barley/pea at 0 – 7.5  cm. Buffer pH was 1.07 – 1.41 units greater at 0 – 7.5  cm and 0.21 – 0.85 units greater at 7.5 – 15.0  cm than pH. At other <b>depths,</b> <b>buffer</b> pH was either similar to or less than pH.|$|R
50|$|Depth pass {{testing is}} also known as z-pass testing, as the <b>depth</b> <b>buffer</b> is often {{referred}} to as the z-buffer.|$|E
5000|$|Pixel Shader: Determines {{the final}} pixel colour {{to be written}} to the render target and can also {{calculate}} a depth value to be written to the <b>depth</b> <b>buffer.</b>|$|E
50|$|Typically Stencil buffer is {{initialized}} {{by setting}} <b>depth</b> <b>buffer</b> and color buffer masks to false. and then setting appropriate ref value to stencil buffer by failing the stencil test every time.|$|E
5000|$|... // disable {{color and}} <b>depth</b> <b>buffers</b> glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE); glDepthMask(GL_FALSE); glStencilFunc(GL_NEVER, 1, 0xFF); // never pass stencil test glStencilOp(GL_REPLACE, GL_KEEP, GL_KEEP); // replace stencil buffer values to ref=1 glStencilMask(0xFF); // stencil buffer free to write glClear(GL_STENCIL_BUFFER_BIT); // first clear stencil buffer by writing default stencil value (0) {{to all of}} stencil buffer. draw_stencil_shape (...) // at stencil shape pixel {{locations}} in stencil buffer replace stencil buffer values to ref = 1 ...|$|R
40|$|We {{present a}} novel 3 D object {{retrieval}} method that relies upon a hybrid descriptor which {{is composed of}} 2 D features based on <b>depth</b> <b>buffers</b> and 3 D features based on spherical harmonics. To compensate for rotation, two alignment methods, namely CPCA and NPCA, are used while compactness is supported via scalar feature quantization {{to a set of}} values that is further compressed using Huffman coding. The superior performance of the proposed retrieval methodology is demonstrated through an extensive comparison against state-of-the-art methods on standard datasets...|$|R
40|$|An {{efficient}} algorithm for the voxelization of solid objects represented by bound-ary surfaces of arbitrary topology is presented. The algorithm {{is based on}} the use of <b>depth</b> <b>buffers,</b> and is suitable for polygonal meshes and parametric surfaces. The presented method unifies and extends our previous approaches under a sin-gle general algorithm; three practical variants are then given that implement it on different generations of graphics hardware in order to achieve high performance. The implementations for older hardware impose certain limitations on the depth complexity of the object. ...|$|R
5000|$|Stencil buffer {{typically}} {{share the}} same memory space with a <b>depth</b> <b>buffer</b> ( [...] Eng. <b>Depth</b> <b>Buffer,</b> the Z-buffer), and typically the ratio is 24 bits in depth + 8 bits for stencil buffer or, heretofore often used, 15 bits for the depth + 1 bit for stencil buffer. Is also present in variant 4 + 24, where 28 of the 32 bits is used, and 4 ignored. Stencil and depth buffers {{are part of the}} frame buffer ( [...] Eng. Frame Buffer), coupled to the buffer for the color (Color Buffer). The first chip available to a wider market, which supported one bit stencil buffer, was 3Dlab's Permedia II.|$|E
5000|$|Another {{implementation}} {{includes the}} field of visualization during the modeling technique solids Constructive Solid Geometry (CSG), wherein stencil buffer, together with the <b>depth</b> <b>buffer,</b> it can successfully {{solve the problems of}} the Boolean operations of the SOLiD [...]|$|E
5000|$|Stencil buffer {{implementation}} of spatial drawing shadows is any {{shadow of a}} geometric body that its volume includes part of the scene that is in it. If {{any part of the}} scene belongs to this volume, light is not illuminated given, otherwise it is. This problem is compounded by {{the increase in the number}} of lights, but does not address the number of areas on which the shadows fall. There are several solutions to the problem, but we followed the following algorithm: 1. Draw a scene without light 2. Lock the <b>depth</b> <b>buffer</b> and color buffer, so that the two can not make changes For each light 1. Using in-depth information about the scene (<b>depth</b> <b>buffer)</b> to fill the stencil buffer only on parts of the scene where volume shadow does not exist or are not visible from the existing buildings. 2. Unlock buffer for color, and adjust the function of the <b>depth</b> <b>buffer</b> to allow amendments only where the depth value equal to an existing 3. Draw the scene illuminated only by this light, but only for part of the scene passing stencil test ...|$|E
50|$|For example, in 2D cases, scene graphs {{typically}} render {{themselves by}} {{starting at the}} tree's root node and then recursively draw the child nodes. The tree's leaves represent the most foreground objects. Since drawing proceeds from back to front with closer objects simply overwriting farther ones, the process is known as employing the Painter's algorithm. In 3D systems, which often employ <b>depth</b> <b>buffers,</b> it is more efficient to draw the closest objects first, since farther objects often need only be depth-tested instead of actually rendered, because they are occluded by nearer objects.|$|R
40|$|International audienceWe {{present a}} novel 3 D object {{retrieval}} method that relies upon a hybrid descriptor which {{is composed of}} 2 D features based on <b>depth</b> <b>buffers</b> and 3 D features based on spherical harmonics. To compensate for rotation, two alignment methods, namely CPCA and NPCA, are used while compactness is supported via scalar feature quantization {{to a set of}} values that is further compressed using Huffman coding. The superior performance of the proposed retrieval methodology is demonstrated through an extensive comparison against state-of-the-art methods on standard dataset...|$|R
25|$|Direct3D 10.1 is an {{incremental}} update of Direct3D 10.0 which shipped with, and required, Windows Vista Service Pack 1. This release mainly sets {{a few more}} image quality standards for graphics vendors, while giving developers more control over image quality. It also adds support for cube map arrays, separate blend modes per-MRT, coverage mask export from a pixel shader, ability to run pixel shader per sample, access to multi-sampled <b>depth</b> <b>buffers</b> and requires that the video card supports Shader Model 4.1 or higher and 32-bit floating-point operations. Direct3D 10.1 still fully supports Direct3D 10 hardware, {{but in order to}} utilize all of the new features, updated hardware is required.|$|R
50|$|To {{take better}} {{advantage}} of available memory performance, the GeForce 3 has a memory subsystem dubbed Lightspeed Memory Architecture (LMA). This {{is composed of}} several mechanisms that reduce overdraw, conserve memory bandwidth by compressing the z-buffer (<b>depth</b> <b>buffer)</b> and better manage interaction with the DRAM.|$|E
50|$|From this rendering, the <b>depth</b> <b>buffer</b> is {{extracted}} and saved. Because only the depth information is relevant, {{it is common}} to avoid updating the color buffers and disable all lighting and texture calculations for this rendering, in order to save drawing time. This depth map is often stored as a texture in graphics memory.|$|E
50|$|In the {{simplest}} case, the stencil buffer {{is used to}} limit the area of rendering (stenciling). More advanced usage of the stencil buffer makes use of the strong connection between the <b>depth</b> <b>buffer</b> and the stencil buffer in the rendering pipeline. For example, stencil values can be automatically increased/decreased for every pixel that fails or passes the depth test.|$|E
5000|$|The RDP is {{programmed}} {{by the use}} {{of display}} lists. A display list contains a series of commands, each of variable size, which give instructions to the RDP and control its operating state. The RDP is capable of rendering shaded, textured, and <b>depth</b> <b>buffered</b> geometry to an arbitrary frame buffer in main memory. The RDP contains 4 KB of on-chip TMEM (texture memory) in which the RDP can reference up to eight textures (so-called [...] "tiles") at any given time. The size of the available texture memory may be reduced further if using texture lookup tables (TLUT), since the high 2 KB will be used to store the lookup tables.|$|R
40|$|Abstract—Recently, optical {{packet switch}} architectures, {{composed}} of {{devices such as}} optical switches, fiber delay lines, and passive couplers, have been proposed to overcome the electromagnetic interference (EMI), pinout and interconnection problems that would be encountered in future large electronic switch cores. However, attaining the <b>buffer</b> size (<b>buffer</b> <b>depth)</b> in optical packet switches required in practice is a major problem; in this paper, a new solution is presented. An architectural concept is discussed and justified mathematically that relies on cascading many small switches to form a bigger switch with a larger <b>buffer</b> <b>depth.</b> The number of cascaded switches {{is proportional to the}} logarithm of the <b>buffer</b> <b>depth,</b> providing an economical and feasible hardware solution. Packet loss performance, control and buffer dimensioning are considered. The optical performance is also modeled, demonstrating the feasibility of <b>buffer</b> <b>depths</b> of several thousand, as required for bursty traffic. Index Terms—Buffer memories, communication switching, optical fiber communication, optical fiber delay lines, modeling, packet switching, photonic switching systems. I...|$|R
40|$|Abstract — We apply recent {{results in}} {{queueing}} theory {{to propose a}} methodology for bounding the <b>buffer</b> <b>depth</b> and packet delay in high radix interconnection networks. While most work in interconnection networks {{has been focused on}} the throughput and average latency in such systems, few studies have been done providing statistical guarantees for <b>buffer</b> <b>depth</b> and packet delays. These parameters are key in the design and performance of a network. We present a methodology for calculating such bounds for a practical high radix network and through extensive simulations show its effectiveness for both bursty and non-bursty injection traffic. Our results suggest that modest speedups and <b>buffer</b> <b>depths</b> enable reliable networks without flow control to be constructed...|$|R
5000|$|Due to {{the lack}} of {{precision}} <b>depth</b> <b>buffer,</b> coplanar polygons that are short-range, or overlapping, are portrayed as two buildings with a multitude of irregular cross-section. These sections can vary depending on the camera position and other parameters, and it is rapidly changing. This is called the fight-depth ( [...] Eng. With the fighting). Solutions that can give certain results are: ...|$|E
50|$|The {{algorithm}} is implemented as a pixel shader, analyzing the scene <b>depth</b> <b>buffer</b> which {{is stored in}} a texture. For every pixel on the screen, the pixel shader samples the depth values around the current pixel and tries to compute the amount of occlusion {{from each of the}} sampled points. In its simplest implementation, the occlusion factor depends only on the depth difference between sampled point and current point.|$|E
50|$|Volumetric {{lighting}} requires two {{components: a}} light space shadow map, and a <b>depth</b> <b>buffer.</b> Starting at the near clip {{plane of the}} camera, the whole scene is traced and sampling values are accumulated into the input buffer. For each sample, it is determined if the sample is lit by the source of light being processed using the shadow map as a comparison. Only lit samples will affect final pixel color.|$|E
50|$|The Silicon Graphics Indigo Elan option Graphics systems {{consist of}} four GE7 Geometry Engines {{capable of a}} {{combined}} 128 MFLOPS and one RE3 Raster Engine. Together, {{they are capable of}} rendering 180K Z-buffered, lit, Gouraud-shaded triangles per second. The framebuffer has 56 bits per pixel, causing 12-bits per pixel (dithered RGB 4/4/4) to be used for a double-buffered, <b>depth</b> <b>buffered,</b> RGB layout. When double-buffering isn't required, it is possible to run in full 24-bit color. Similarly, when Z-buffering is not required, a double-buffered 24-bit RGB framebuffer configuration is possible. The Elan Graphics system also implemented hardware stencil buffering by allocating 4 bits from the Z-buffer to produce a combined 20-bit Z, 4-bit stencil buffer.|$|R
40|$|International audienceIn this paper, {{we present}} an {{overview}} of the 3 D object retrieval method that we employed in our participation to the Generic Models track of SHREC 2008 organized by the AIM@SHAPE network of excellence. The proposed methodology is detailed in [2]. Our method is based on a hybrid scheme where 2 D features as well as 3 D features are extracted from a 3 D model which has been previously normalized for rotation using two alternative alignment techniques. The alignment methods that are used are CPCA and NPCA. The 2 D features are Fourier coefﬁcients extracted from a set of <b>depth</b> <b>buffers</b> and the 3 D features are spherical harmonic coefﬁ- cients extracted from a spherical function-based representation of a 3 D model...|$|R
50|$|Configuration {{of these}} {{surfaces}} is done through a pixel format selection process where different compatible layers of rendering information are combined {{to form a}} framebuffer. Examples of such layers are color buffers, transparency buffers (alpha), stencil <b>buffers,</b> and <b>depth</b> <b>buffers.</b> The CGL function CGLChoosePixelFormat is used to perform this buffer compatibility check. CGLChoosePixelFormat will, based on input parameters and their scoring policy, choose a pixel format that represents a compatible buffer configuration that {{is supported by the}} underlying renderer that will be used to process graphics commands. Renderers may be either hardware based, such that they correspond to graphics cards installed in the system or they may be software based, where the main CPU of the system handles all of the graphics command processing and final rasterization work.|$|R
