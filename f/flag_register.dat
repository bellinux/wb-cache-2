26|94|Public
50|$|In CPUs with flag registers, {{an earlier}} {{instruction}} sets {{a condition in}} the <b>flag</b> <b>register.</b> The earlier instruction may be arithmetic, or a logic instruction. It is often close to the branch, though not necessarily the instruction immediately before the branch. The stored condition is then used in a branch such as jump if overflow-flag set. This temporary information is often stored in a <b>flag</b> <b>register</b> but may also be located elsewhere. A <b>flag</b> <b>register</b> design is simple in slower, simple computers. In fast computers a <b>flag</b> <b>register</b> can place a bottleneck on speed, because instructions that could otherwise operate in parallel (in several execution units) need to set the flag bits in a particular sequence.|$|E
5000|$|The 8086 has no {{instruction}} to directly set or reset the trap flag. These operations are done by pushing the <b>flag</b> <b>register</b> on the stack, changing the trap flag bit {{to what the}} programmer wants it to be, and then popping the <b>flag</b> <b>register</b> back off the stack.The instructions to set the trap flag are: ...|$|E
5000|$|There {{are also}} {{machines}} (or particular instructions) where the condition may be checked by the jump instruction itself, such as [...] In simple computer designs, comparison branches execute more arithmetic and can use {{more power than}} <b>flag</b> <b>register</b> branches. In fast computer designs comparison branches can run faster than <b>flag</b> <b>register</b> branches, because comparison branches can access the registers with more parallelism, using the same CPU mechanisms as a calculation.|$|E
5000|$|The Flag Institute note, in the flag's {{entry on}} the UK <b>Flags</b> <b>Register</b> that: ...|$|R
40|$|The Mailbox Problem was {{described}} and solved by Aguilera, Gafni, and Lamport in their 2010 DC paper with an algorithm that uses two <b>flag</b> <b>registers</b> that carry 14 values each. An interesting problem that they ask {{is whether there}} is a mailbox algorithm with smaller flag values. We give a positive answer by describing a mailbox algorithm with 6 and 4 values in the two <b>flag</b> <b>registers...</b>|$|R
50|$|In {{gold with}} a lion, {{with the right}} paw {{clutching}} a silver and red <b>flag.</b> <b>Registered</b> in the Hessian State Archives in 1962.|$|R
50|$|The Hong Kong Ship Register {{is now the}} world’s {{fourth largest}} ship register, and the world’s largest {{national}} <b>flag</b> <b>register.</b>|$|E
50|$|In some {{instruction}} sets {{such as the}} MIPS architecture, {{a dedicated}} <b>flag</b> <b>register</b> is not used; jump instructions instead check a register for zero.|$|E
5000|$|PUSHF Push flags {{on stack}} MOV BP,SP Copy SP to BP {{for use as}} index OR WORD PTRBP+0,0100H Set TF flag POPF Restore <b>flag</b> <b>Register</b> ...|$|E
5000|$|... #Caption: The [...] "Vryheidsvlag" [...] (Freedom <b>Flag),</b> <b>registered</b> in 1995 {{with the}} South African Bureau of Heraldry as {{the flag of}} the Afrikaner Volksfront.|$|R
50|$|In 2014 The Friends of Bedfordshire Society began a {{successful}} campaign {{to have a}} slightly updated version of the council's <b>flag</b> <b>registered</b> with the <b>Flag</b> Institute.|$|R
50|$|The flag of Huntingdonshire is {{the county}} flag for the English County of Huntingdon. It was {{enrolled}} on the UK <b>Flags</b> <b>Register</b> by the <b>Flag</b> Institute on 25 June 2009.|$|R
50|$|A status register, <b>flag</b> <b>register,</b> or {{condition}} code register {{is a collection}} of status flag bits for a processor. An example is the FLAGS register of the x86 architecture or flags in a program status word (PSW) register.|$|E
50|$|Serial data {{transfers}} {{are provided}} by a serial to parallel/parallel to serial shift register, with bit transfers synchronized with the Ø2 clock. Application versatility is further increased by various control registers, including an interrupt <b>flag</b> <b>register,</b> an interrupt enable register and two Function Control Registers.|$|E
5000|$|The flags {{register}} {{can also}} be directly accessed. The low 8 bits of the <b>flag</b> <b>register</b> can be loaded into [...] using the [...] instruction. The entire flags register {{can also be}} moved {{on and off the}} stack using the instructions , , [...] (including [...] ) and [...]|$|E
50|$|The Flag of Derbyshire is {{the flag}} of the English county of Derbyshire. Introduced unofficially in 2006, the flag has {{subsequently}} been <b>registered</b> at the <b>Flag</b> Institute and added to their UK <b>Flags</b> <b>Register.</b>|$|R
5000|$|Ships must be {{registered}} in the ship register of the country whose flag it is flying. <b>Flag</b> <b>registers</b> in many countries are open to ships with foreign owners. Normally, each flag state has only one ship register, but several countries {{have more than one}} register: ...|$|R
50|$|The POPF, POPFD, and POPFQ {{instructions}} {{read from}} the stack, the first 16, 32, and 64 bits of the <b>flags</b> <b>register,</b> respectively. POPFD was introduced with the i386 architecture and POPFQ with the x64 architecture. In 64-bit mode, PUSHF/POPF and PUSHFQ/POPFQ are available but not PUSHFD/POPFD.|$|R
50|$|Some CPU architectures, {{such as the}} MIPS and Alpha, do not use a {{dedicated}} <b>flag</b> <b>register.</b> Others do not implicitly set and/or read flags. Such machines either do not pass implicit status information between instructions at all, or they pass it in an explicitly selected general purpose register.|$|E
5000|$|In the x86 architecture, {{a family}} of {{conditional}} move instructions ( [...] and [...] ) {{were added to the}} architecture by the Intel Pentium Pro (1995) processor. The [...] instructions copied the contents of the source register to the destination register depending on a predicate supplied by the value of the <b>flag</b> <b>register.</b>|$|E
50|$|There {{was both}} a user mode and a {{supervisor}} mode, selected by bit 14 in the <b>flag</b> <b>register.</b> In supervisor mode, the stack registers point to the system stack and all privileged instructions are available. In user mode, the stack registers point to the normal stack and all privileged instructions will generate a fault.|$|E
5000|$|... #Caption: <b>Flag</b> of <b>Registered</b> Cossacks of the Russian Federation ...|$|R
5000|$|... 8086 has a 16-bit <b>flags</b> <b>register.</b> Nine {{of these}} {{condition}} code flags are active, and indicate {{the current state}} of the processor: Carry flag (CF), Parity flag (PF), Auxiliary carry flag (AF), Zero flag (ZF), Sign flag (SF), Trap flag (TF), Interrupt flag (IF), Direction flag (DF), and Overflow flag (OF).|$|R
50|$|The {{parity flag}} is usually used in {{conditional}} jumps, where e.g. the JP instruction jumps to the given target when the parity flag is {{set and the}} JNP instruction jumps {{if it is not}} set. The flag may be also read directly with instructions such as PUSHF, which pushes the <b>flags</b> <b>register</b> on the stack.|$|R
50|$|The 8086 {{has eight}} {{more or less}} general 16-bit {{registers}} (including the stack pointer but excluding the instruction pointer, <b>flag</b> <b>register</b> and segment registers). Four of them, AX, BX, CX, DX, can also be accessed as twice as many 8-bit registers (see figure) while the other four, BP, SI, DI, SP, are 16-bit only.|$|E
50|$|In a {{computer}} processor the negative flag or sign flag {{is a single}} bit in a system status (<b>flag)</b> <b>register</b> used to indicate whether {{the result of the}} last mathematical operation resulted in a value whose most significant bit was set. In a two's complement interpretation of the result, the negative flag is set if the result was negative.|$|E
50|$|When {{generating}} a software interrupt, the processor calls {{one of the}} 256 functions pointed to by the interrupt address table, which {{is located in the}} first 1024 bytes of memory while in real mode (See Interrupt vector). It is therefore entirely possible to use a far-call instruction to start the interrupt-function manually after pushing the <b>flag</b> <b>register.</b>|$|E
5000|$|SHARC {{instructions}} {{may contain}} a 32-bit immediate operand. Instructions without this operand are generally {{able to perform}} two or more operations simultaneously. Many instructions are conditional, and may be preceded with [...] "if condition [...] " [...] in the assembly language. There {{are a number of}} condition choices, similar to the choices provided by the x86 <b>flags</b> <b>register.</b>|$|R
5000|$|Applications in IMS use set the [...] "transaction supported" [...] <b>flag</b> on <b>register</b> API ...|$|R
50|$|The {{instructions}} LD A,R and LD A,I {{affect the}} Z80 <b>flags</b> <b>register,</b> unlike {{all the other}} LD (load) instructions. The Sign (bit 7) and Zero (bit 6) flags are set {{according to the data}} loaded from the Refresh or Interrupt source registers. For both instructions, the Parity/Overflow flag (bit 2) is set according to {{the current state of the}} IFF2 flip-flop.|$|R
50|$|The zero flag is {{a single}} bit flag that is a central feature on most {{conventional}} CPU architectures (including x86, ARM, PDP-11, 68000, 6502, and numerous others). It is often stored in a dedicated register, typically called status register or <b>flag</b> <b>register,</b> along with other flags. The zero flag is typically abbreviated Z or ZF or similar in most documentation and assembly languages.|$|E
50|$|FCMOV is a {{floating}} point conditional move opcode of the Intel x86 architecture, first introduced in Pentium Pro processors. It copies {{the contents of}} one of the floating point stack register, depending on the contents of EFLAGS integer <b>flag</b> <b>register,</b> to the ST(0) (top of stack) register. There are 8 variants of the instruction selected by the condition codes that need be set for the instruction to perform the move.|$|E
5000|$|A two-byte {{instruction}} specialized {{for program}} looping {{is new to}} the Z80. DJNZ (Decrement Jump if Non-Zero) takes a signed 8-bit displacement as an immediate operand. The B register is decremented. If the result is nonzero then program execution jumps relative to {{the address of the}} PC plus the displacement. The flags remain unaltered. To perform an equivalent loop on an 8080 would require separate decrement and jump (to a two-byte absolute address) instructions, and the <b>flag</b> <b>register</b> would be altered.|$|E
50|$|In the x86 architecture, {{interrupts}} {{are handled}} through the Interrupt Dispatch Table (IDT). When a device triggers an interrupt, the interrupt flag (IF) in the <b>flags</b> <b>register</b> is {{set and the}} processor's hardware looks for an interrupt handler in the table entry corresponding to the interrupt number, or IRQ. Interrupt handlers usually save the state of all or some registers before handling it and restore the registers when done.|$|R
5000|$|The HP-67/97 series {{featured}} a program memory of 224 eight-bit words. The two extra bits per word {{compared to the}} HP-65's six allowed the designers to store any program instruction in a single memory cell ("fully merged keycodes") even if it required multiple keystrokes to enter (see image). Programs could include 20 labels, subroutines (3 levels deep), four <b>flag</b> <b>registers,</b> 8 comparison functions, and extended index and loop control functions.|$|R
5000|$|NAR 1 {{processor}} has a 5-bit {{address bus}} (32 bytes of addressable memory) and 8-bit data bus. Machine instructions were single-byte with three most significant bits specifying the opcode and 5 least significant bits the parameter - memory address. A single 8-bit accumulator register was available {{and there were}} no <b>flags</b> or <b>flag</b> <b>registers.</b> Only absolute addressing mode was available and all others were achieved by self-modifying code.|$|R
