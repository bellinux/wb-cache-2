139|1630|Public
5|$|This, {{and similar}} issues {{pertaining}} to the wording inhibiting the use of decltype in the declaration of a <b>derived</b> <b>class</b> and in a destructor call, were addressed by David Vandevoorde, and voted into the working paper in March 2010.|$|E
25|$|Ordinarily, when a {{function}} in a <b>derived</b> <b>class</b> overrides {{a function}} in a base class, the function to call {{is determined by the}} type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called dynamic dispatch. Virtual member functions or methods allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using virtual function tables. If the object type is known, this may be bypassed by prepending a fully qualified class name before the function call, but in general calls to virtual functions are resolved at run time.|$|E
2500|$|... Specifies that {{a method}} or {{property}} declaration can be overridden by a <b>derived</b> <b>class.</b>|$|E
5000|$|In this example, the [...] {{statement}} declares a new virtual function, {{but it also}} prevents <b>derived</b> <b>classes</b> from overriding it. It {{also has}} the effect of preventing <b>derived</b> <b>classes</b> from using that particular function name and parameter combination.|$|R
40|$|In the {{definition}} of <b>derived</b> <b>classes</b> in OODBs, the problem of integration of <b>derived</b> <b>classes</b> in object schemas {{is one of the}} main issues that has to be resolved. <b>Derived</b> <b>classes</b> are defined during the lifetime of the database to be included in some external schema or in the conceptual schema. Different solutions to this problem have been previously proposed; some of them involve the extension of the object-orientation paradigm to include new kinds of relationships. In this paper, a new solution according to the ANSI/SPARC framework is put forward. <b>Derived</b> <b>classes</b> are integrated in two phases: first, in the data dictionary using the derivation relationship; then, in the conceptual schema or external schemas using the inheritance relationship. The derivation relationship only appears in the data dictionary, therefore, in this solution the objectorientation paradigm is not extended. ...|$|R
40|$|According to the ANSI/SPARC architecture, {{external}} schemas {{are derived}} from the database conceptual schema. In object-oriented databases (OODBs), an external schema may include classes defined in the conceptual schema just as it may also contain <b>derived</b> <b>classes</b> which are directly or indirectly defined {{on the basis of}} conceptual schema classes. In the definition of <b>derived</b> <b>classes</b> in OODBs three main issues have to be resolved, namely: the integration of <b>derived</b> <b>classes</b> with other classes in an object schema; the definition of classes with new objects; and the transmission of modifications between the objects in <b>derived</b> <b>classes</b> and those of the classes from which they are defined. A solution to the first issue was proposed in [18] and [19]. In this paper, the two remaining issues are further studied and new conceptual level solutions are put forward. Our proposals are informally illustrated through some examples. ...|$|R
2500|$|A member {{function}} {{can also}} be made [...] "pure virtual" [...] by appending it with = 0 after the closing parenthesis and before the semicolon. A class containing a pure virtual function is called an abstract class. Objects cannot be created from an abstract class; they can only be derived from. Any <b>derived</b> <b>class</b> inherits the virtual function as pure and must provide a non-pure definition of it (and all other pure virtual functions) before objects of the <b>derived</b> <b>class</b> can be created. A program that attempts to create an object of a class with a pure virtual member function or inherited pure virtual member function is ill-formed.|$|E
2500|$|In {{addition}} to standard member functions, operator overloads and destructors can be virtual. As {{a rule of}} thumb, if any function in the class is virtual, the destructor should be as well. As the type of an object at its creation is known at compile time, constructors, and by extension copy constructors, cannot be virtual. Nonetheless a situation may arise where a copy of an object needs to be created when a pointer to a derived object is passed as a pointer to a base object. In such a case, a common solution {{is to create a}} clone (...) (or similar) virtual function that creates and returns a copy of the <b>derived</b> <b>class</b> when called.|$|E
2500|$|The first <b>derived</b> <b>class</b> was the two-ship St. Louis-class, {{which were}} {{modified}} Brooklyns using new boiler design, redesigned armor, and secondary armament placed into four twin mount turrets (two turrets per side). This class would lead onto the Cleveland-class light cruiser (less a fifth triple 6-inch turret), of which two were upgraded as the [...] The other predecessor was the , {{built on a}} modified Brooklyn-class hull, with a heavy cruiser armament featuring three rather than five triple turrets, but each turret containing larger 8-inch guns, and increased armor. The Wichita was succeeded by the Baltimore-class, including the [...] subclass, and the upgraded [...] As the Baltimore-class began building {{about a year after}} the Cleveland-class, later developments and improvements were transferred to the Baltimore-class hull.|$|E
5000|$|... vs [...] - for declaring {{methods that}} may not be {{overridden}} by <b>derived</b> <b>classes</b> ...|$|R
5000|$|... vs [...] - {{declares}} {{a method}} as {{being able to}} be overridden in <b>derived</b> <b>classes</b> ...|$|R
5000|$|The fragile {{base class}} {{problem is a}} {{fundamental}} architectural problem of object-oriented programming systems where base classes (superclasses) are considered [...] "fragile" [...] because seemingly safe modifications to a base class, when inherited by the <b>derived</b> <b>classes,</b> may cause the <b>derived</b> <b>classes</b> to malfunction. The programmer cannot determine whether a base class change is safe simply by examining in isolation the methods of the base class.|$|R
2500|$|Multiple {{inheritance}} is a C++ feature {{not found}} in most other languages, allowing a class {{to be derived from}} more than one base class; this allows for more elaborate inheritance relationships. For example, a [...] "Flying Cat" [...] class can inherit from both [...] "Cat" [...] and [...] "Flying Mammal". Some other languages, such as C# or Java, accomplish something similar (although more limited) by allowing inheritance of multiple interfaces while restricting the number of base classes to one (interfaces, unlike classes, provide only declarations of member functions, no implementation or member data). An interface as in C# and Java can be defined in C++ as a class containing only pure virtual functions, often known as an abstract base class or [...] "ABC". The member functions of such an abstract base class are normally explicitly defined in the <b>derived</b> <b>class,</b> not inherited implicitly. C++ virtual inheritance exhibits an ambiguity resolution feature called dominance.|$|E
50|$|Failing {{to include}} the using results in an int {{argument}} passed to f in the <b>derived</b> <b>class</b> being converted to a double and matching the function in the <b>derived</b> <b>class,</b> {{rather than in the}} base class; including using results in an overload in the <b>derived</b> <b>class</b> and thus matching the function in the base class.|$|E
50|$|In {{object-oriented}} programming, when a <b>derived</b> <b>class</b> inherits from a base class, {{an object}} of the <b>derived</b> <b>class</b> may be referred to via a pointer or reference of the base class type instead of the <b>derived</b> <b>class</b> type. If there are base class methods overridden by the <b>derived</b> <b>class,</b> the method actually called by such a reference or pointer can be bound either 'early' (by the compiler), according to the declared type of the pointer or reference, or 'late' (i.e., by the runtime system of the language), according to the actual type of the object referred to.|$|E
5000|$|Inheritance - An {{existing}} class {{may be used}} to <b>derive</b> a new <b>class.</b> <b>Derived</b> <b>classes</b> {{inherit the}} data and methods of the superclass. However, they can overwrite existing methods, and also add new ones.|$|R
50|$|This {{feature is}} most useful for {{multiple}} inheritance, {{as it makes}} the virtual base a common subobject for the <b>deriving</b> <b>class</b> and all <b>classes</b> that are <b>derived</b> from it. This {{can be used to}} avoid the diamond problem by clarifying ambiguity over which ancestor class to use, as {{from the perspective of the}} <b>deriving</b> <b>class</b> (C in the example above) the virtual base (X) acts as though it were the direct base class of C, not a <b>class</b> <b>derived</b> indirectly through its base (A).|$|R
5000|$|... vs [...] - {{prevents}} a {{class from}} being directly instantiated, and forces consumers to create object references to only <b>derived</b> <b>classes</b> ...|$|R
5000|$|Multilevel inheritance: where a {{subclass}} is {{inherited from}} another subclass. It {{is not uncommon}} that a class is derived from another <b>derived</b> <b>class</b> {{as shown in the}} figure [...] "Multilevel inheritance". The class A serves as a base class for the <b>derived</b> <b>class</b> B, which in turn serves as a base class for the <b>derived</b> <b>class</b> C. The class B is known as intermediate base class because it provides a link for the inheritance between A and C. The chain ABC is known as inheritance path.|$|E
5000|$|Evaluation {{expressions}} for <b>derived</b> <b>class</b> members (attributes and links) ...|$|E
5000|$|A <b>derived</b> <b>class</b> with {{multilevel}} inheritance is declared as follows: ...|$|E
5000|$|... class File { // Parent {{class for}} the {{elements}} (ArchivedFile, SplitFile and ExtractedFile)public: // This function accepts {{an object of}} any <b>class</b> <b>derived</b> from AbstractDispatcher and must be implemented in all <b>derived</b> <b>classes</b> virtual void accept(AbstractDispatcher &dispatcher) = 0;}; ...|$|R
2500|$|Initially, Stroustrup's [...] "C with Classes" [...] added {{features}} to the C compiler, Cpre, including <b>classes,</b> <b>derived</b> <b>classes,</b> strong typing, inlining and default arguments.|$|R
50|$|In {{object-oriented}} programming languages, objects {{can also be}} downcast : a reference of a base class is cast to one of its <b>derived</b> <b>classes.</b>|$|R
50|$|One common {{drawback}} {{of using}} composition instead of inheritance is that methods being provided by individual components {{may have to}} be implemented in the derived type, even if they are only forwarding methods. In contrast, inheritance does not require all of the base class's methods to be re-implemented within the <b>derived</b> <b>class.</b> Rather, the <b>derived</b> <b>class</b> only needs to implement (override) the methods having different behavior than the base class methods. This can require significantly less programming effort if the base class contains many methods providing default behavior and only a few of them need to be overridden within the <b>derived</b> <b>class.</b>|$|E
50|$|When using polymorphism, one {{sometimes}} {{needs to}} create copies of objects by the base class pointer. A commonly used idiom {{for this is}} adding a virtual clone function that is defined in every <b>derived</b> <b>class.</b> The CRTP {{can be used to}} avoid having to duplicate that function or other similar functions in every <b>derived</b> <b>class.</b>|$|E
5000|$|... {{is used to}} {{explicitly}} call a {{base class}} constructor from a <b>derived</b> <b>class</b> constructor.|$|E
50|$|In {{class-based}} programming, downcasting or type refinement is the act {{of casting}} a reference of a base class to one of its <b>derived</b> <b>classes.</b>|$|R
5000|$|Initially, Stroustrup's [...] "C with Classes" [...] added {{features}} to the C compiler, Cpre, including <b>classes,</b> <b>derived</b> <b>classes,</b> strong typing, inlining and default arguments.|$|R
40|$|The closure {{property}} {{is essential to}} enhance the power of database languages. In the deductive object-oriented database (DOOD) context, this property implies that the rule-derived objects {{as well as the}} rule-derived classes (i. e. the classes populated by the derived objects) be established with full OO (objectoriented) features. This paper provides the methods of specifying the OO features of <b>derived</b> <b>classes</b> (i. e. the populations of <b>derived</b> <b>classes</b> and the <b>class</b> hierarchies including <b>derived</b> <b>classes)</b> by their population rules. The work is based on a deductive language, called ERCLog, for an object and relationship data model. The principles can be applied to other DOOD languages which distinguish the notions of schema and instance of databases. Keywords Deductive database, object orientation, logic-based language, objectrelationship data model. 2 1. Introduction There has been a large amount of research on deductive object-oriented databases (DOOD) {{in the last few years}} [...] ...|$|R
5000|$|... Specifies that {{a method}} or {{property}} declaration can be overridden by a <b>derived</b> <b>class.</b>|$|E
50|$|There are {{two main}} {{potential}} traps in Java's object initialization. First, variable initializers are expressions that can contain method calls. Since methods can reference any variable defined in the class, the method called in a variable initializer can reference a variable that is defined below the variable being initialized. Since initialization order corresponds to textual order of variable definitions, such a variable would not be initialized to the value prescribed by its initializer and would contain the default value.Another potential trap is when a method that is overridden in the <b>derived</b> <b>class</b> is called in the base class constructor, {{which can lead to}} behavior the programmer would not expect when an object of the <b>derived</b> <b>class</b> is created. According to the initialization order, the body of the base class constructor is executed before variable initializers are evaluated and before the body of the <b>derived</b> <b>class</b> constructor is executed. The overridden method called from the base class constructor can, however, reference variables defined in the <b>derived</b> <b>class,</b> but these are not yet initialized to the values specified by their initializers or set in the <b>derived</b> <b>class</b> constructor. The latter issue applies to C# as well, but in a less critical form since in C# methods are not overridable by default.|$|E
5000|$|Converting a pointer of a {{base class}} to a pointer of a nonvirtual <b>derived</b> <b>class,</b> ...|$|E
5000|$|C++11 {{also adds}} {{the ability to}} prevent inheriting from classes or simply {{preventing}} overriding methods in <b>derived</b> <b>classes.</b> This is done with the special identifier [...] For example: ...|$|R
40|$|Our {{goal is to}} {{investigate}} specification-based approaches to testing OO components. That is, given a class C and its specification, how do we test C {{to see if it}} meets its specification ? Two important requirements that we impose on the testing approach are that it must not require access to the source code of the class under test; and that it should enable us to deal incrementally with <b>derived</b> <b>classes,</b> including <b>derived</b> <b>classes</b> that exploit polymorphism to extend the behavior of the base class. In this paper, we report on our work towards developing such a testing approach. 1...|$|R
5000|$|... string status = string.Empty;public string Status{ get { return status; } // {{anyone can}} get {{value of this}} property, {{protected}} set { status = value; } // but only <b>derived</b> <b>classes</b> can change it} ...|$|R
