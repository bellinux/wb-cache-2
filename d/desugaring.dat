22|17|Public
40|$|Syntactic {{language}} extensions {{can introduce}} new facilities into {{a programming language}} while requiring little implementation effort and modest changes to the compiler. It is typical to desugar language extensions in a distinguished compiler phase after parsing or type checking, not affecting any of the later compiler phases. If <b>desugaring</b> happens before type checking, the <b>desugaring</b> cannot depend on typing information and type errors are reported {{in terms of the}} generated code. If <b>desugaring</b> happens after type checking, the code generated by the <b>desugaring</b> is not type checked and may introduce vulnerabilities. Both options are undesirable. We propose a system for syntactic extensibility where <b>desugaring</b> happens after type checking and desugarings are guaranteed to only generate well-typed code. A major novelty of our work is that desugarings operate on typing derivations instead of plain syntax trees. This provides desugarings access to typing information and forms the basis for the soundness guarantee we provide, namely that a <b>desugaring</b> generates a valid typing derivation. We have implemented our system for syntactic extensibility in a language-independent fashion and instantiated it for a substantial subset of Java, including generics and inheritance. We provide a sound Java extension for Scala-like for-comprehensions. Programming Language...|$|E
40|$|JML, {{which stands}} for ”Java Modeling Language”, is a {{behavioral}} interface specification language designed to specify Java classes and interfaces. JML uses syntactic sugar to make specifications easier to read and write. In this paper, we reveal that the current JML <b>desugaring</b> of signals clauses has a somewhat counterintuitive meaning. A new semantics is proposed that is more intuitive. Special attention {{is given to the}} <b>desugaring</b> of signals clauses that are spread over different behavior blocks connected by the keywords also or and. The described <b>desugaring</b> ensures behavioral subtyping. The consequences of the new semantics are worked out...|$|E
40|$|JML, {{which stands}} for "Java Modeling Language, 2 ̆ 72 ̆ 7 is a {{behavioral}} interface specification language (BISL) designed to specify Java modules. JML features {{a great deal of}} syntactic sugar that is designed to make method specifications more expressive. This paper presents a <b>desugaring</b> process that boils down all of the syntactic sugars in JML method specifications into a much simpler form. This <b>desugaring</b> will help one understand the meaning of these sugars, for example for use in program verification. It may also help manipulation of JML method specifications by tools...|$|E
5000|$|A rule to <b>desugar</b> a do-while {{statement}} in Java: <b>desugar</b> : While(e, stm) -> If(e, DoWhile(stm, e)) ...|$|R
40|$|The {{adsorption}} {{behavior and}} {{mechanism for the}} uptake of fluoride ions by untreated and <b>desugared</b> reed residues (roots, stems and leaves) were studied through adsorption experiments, elemental analysis, infrared spectroscopy and surface area analysis. The {{results showed that the}} adsorption capacity of untreated and <b>desugared</b> reeds followed the order: <b>desugared</b> roots 2136 mg/kg > <b>desugared</b> leaves 1825 mg/kg > <b>desugared</b> stems 1551 mg/kg > untreated roots 191 mg/kg > untreated stems 175 mg/kg > untreated leaves 150 mg/kg, so adsorption capacity of <b>desugared</b> reeds was larger than that of the untreated reeds. The adsorption kinetic of fluoride ions followed a pseudo-first-order model. A Langmuir model could be used to fit the isothermal adsorption process which was a spontaneous endothermic reaction involving mainly physical adsorption. The ΔG for the uptake of fluoride by the <b>desugared</b> reeds was more negative, so the degree of spontaneity was higher than {{for the use of the}} untreated reeds. After samples were <b>desugared,</b> the specific surface area and aromaticity of the reed increased, while the polarity and hydrophilicity decreased, which explained the adsorption amount of <b>desugared</b> reed was higher than that of the untreated. This study enriches techniques and methods of removing fluoride ions from water...|$|R
5000|$|The same rule, using {{concrete}} syntax: <b>desugar</b> : |while (e) stm; | -> |if (e) do stm while(e); | ...|$|R
40|$|We propose an {{extension}} to list comprehensions {{that makes it}} easy to express the kind of queries one would write in SQL using ORDER BY, GROUP BY, and LIMIT. Our extension adds expressive power to comprehensions, and generalises the SQL constructs that inspired it. It is easy to implement, using simple <b>desugaring</b> rules...|$|E
40|$|The {{extensive}} use of lists in functional programming languages exacts a cost penalty for important operations such as array construction. In addition, because lists are linear data structures, {{it is difficult to}} generate and traverse them efficiently in parallel given a purely-functional environment. Three common methods of traversal [...] -left and right fold, and reduction [...] -can be described in terms of map and reduce operations yielding higher-order functions; these higher-order functions can be represented entirely at compile time. This thesis examines this representation of list traversal, describes its implementation in the <b>desugaring</b> phase of the compiler for pH (an implicitly-parallel, mostly-functional dialect of the language Haskell). This approach to <b>desugaring</b> gives rise to a set of rules for compiling list comprehensions efficiently, and to a pair of functions unfold and synthesize which can be immediately eliminated if the lists they generate are traversed by folding or reduc [...] ...|$|E
40|$|JML, {{which stands}} for "Java Modeling Language," is a {{behavioral}} interface specification language (BISL) designed to specify Java modules. JML features {{a great deal of}} syntactic sugar that is designed to make specifications more expressive. This paper presents a <b>desugaring</b> process that boils down all of the syntactic sugars in JML into a much simpler form. This <b>desugaring</b> will help one manipulate JML specifications in tools, understand the meaning of these sugars, and it also allows the use of JML specifications in verification. 1 Introduction JML [5], {{which stands for}} "Java Modeling Language," is a behavioral interface specification language (BISL) [7] designed to specify Java [1, 3] modules. JML features a great deal of syntactic sugar that is designed to make specifications more expressive [4]. Syntactic sugars are additions to a language that make it easier for humans to use. Syntactic sugar gives the user an easier to use notation that can be easily translated, i. e., desuga [...] ...|$|E
40|$|To {{elucidate}} the adsorption {{property and the}} mechanism of plant residues to reduce oxytetracycline (OTC), the adsorption of OTC onto raw willow roots (WR-R), stems (WS-R), leaves (WL-R), and adsorption onto <b>desugared</b> willow roots (WR-D), stems (WS-D), and leaves (WL-D) were investigated. The structural characterization was analyzed by scanning electron microscopy, Fourier-transform infrared spectra, and an elemental analyzer. OTC adsorption onto the different tissues of willow residues was compared and correlated with their structures. The adsorption kinetics of OTC onto willow residues was found to follow the pseudo-first-order model. The isothermal adsorption process of OTC onto the different tissues of willow residues followed the Langmuir and Freundlich model and the process was also a spontaneous endothermic reaction, which was mainly physical adsorption. After the willow residues were <b>desugared,</b> the polarity decreased and the aromaticity increased, which explained why the adsorption amounts of the <b>desugared</b> willow residues were {{higher than those of}} the unmodified residues. These observations suggest that the raw and modified willow residues have great potential as adsorbents to remove organic pollutants...|$|R
25|$|So-called n+k {{patterns}} (definitions of {{the form}} fact (n+1) = (n+1) * fact n) were no longer allowed. This syntactic sugar had misleading semantics, in which the code looked like it used the (+) operator, but in fact <b>desugared</b> to code using (-) and (>=).|$|R
40|$|The {{effect of}} a concentrated, depotassified beet vinasse (<b>desugared</b> beet molasses) on both {{germination}} (in vitro and in soil) and seedling development (in soil) of ryegrass Lolium multiflorum has been studied. Germination and root elongation of the ryegrass in vitro were more negatively affected by vinasse (concentration of 0 · 15 and 0 · 5...|$|R
40|$|We reduce JavaScript to a core {{calculus}} structured as a small-step operational semantics. We present several {{peculiarities of}} the language and show that our calculus models them. We explicate the <b>desugaring</b> process that turns JavaScript programs into ones in the core. We demonstrate faithfulness to JavaScript using real-world test suites. Finally, we illustrate utility by defining a security property, implementing it as a type system on the core, and extending it to the full language. Comment: European Conference on Object-Oriented Programming (ECOOP) 201...|$|E
40|$|This study {{examined}} the influence of applied tech- nologies namely <b>desugaring,</b> grinding, and bleaching on the compositions (cellulose, hemicelluloses, lignins, and pectins), physicochemical properties (water-holding capacity (WHC), swelling capacity (SWC), oil-holding capacity (OHC)) and the colour of dietary fibre (DF) during the production of fibre concentrates from unusual cooked apple and pear pomaces. Thermogravimetric analysis (TGA) and optical microscopy were also performed to monitor process-induced modifica- tion. All the processing conditions affected the compositions and physicochemical properties of DF. The bleaching treat- ment induced the greatest changes on DF producing yellow cellulose-rich fibre concentrates with improved WHC from 3. 2 to 10. 0 g/g and improved SWC from 4. 0 to 8. 8 ml/g. Otherwise, reduction of the particle size influenced hydration properties and colours of DF. WHC and SWC tended to increase with the particle size whereas smaller granulometric size increased the lightness of fibres. <b>Desugaring</b> increased the DF content in both pomaces by 1. 2 -fold with slight modifica- tion of apple insoluble dietary fibre ratio. Fibre concentrates had improved WHC and SWC up to 1. 4 -fold. All processes had no significant effect (p < 0. 05) on OHC of DF except with ultrafine apple fibre concentrates. Results showed that pro- cessing had overall positive effects on DF contents and hy- dration properties of pomaces from cooked fruits. Bleached fibre concentrates from apple pomace had the highest WHC (10. 0 g/g) whereas that of pear had the highest fibre content (89. 9 %). Fibres from cooked fruit pomaces may therefore be used as textural ingredients or functional foods. Peer reviewe...|$|E
40|$|Effects of Heating Process on the Enzymatic Digestibility of Meats. II. The Digestibility of Edible Liver. Y. AYANO and S. OTSUKA, Faculty of Horticulture, Chiba University, Matsudo, Japan. Tech. Bull. Fac. Hort. Chiba Univ., No. 16 : 41 〜 47, 1968. The {{effects of}} heating process on the {{digestibility}} of the boiled liver (pig), {{and the effects}} of removal of fat or reducing sugar from the liver on the improvement of digestibility, were investigated through peptic digestion method in vitro. The method of the removal of fat or redusing sugar from the liver was as follows. Defatting liver was prepared by using ethyl ether from the freeze-dried liver. <b>Desugaring</b> liver was prepared by using glucose-oxidase enzyme, and the amount of reducing sugar (as glucose) removed from raw liver was 59. 3 %. 0 The digestibility of both raw and boiled livers, at 100 °or 120 ℃ for 1 hr., was increased according as prolonged digestion. However, the relative rates of the digestibility of them were lowered in proportion to the elevated degree of heating temperature, during all the period of digestion. The digestibility of them (incubated at 37 ℃ for 24 hrs.), were 89. 1 0 n raw liver, 84. 4 139682564 n 100 ℃ boiled liver, and 77. 6 139497728 n 120 ℃ autoclaved liver. By removal of fat or sugar from liver, the digestibility was improved. The degree of the digestibility in the case of defatting liver was 3 〜 4 - 1229081253 gher than that of control, in all the heating process at 60 °, 100 °and 120 ℃ for 1 hr [...] The degree of the digestibility in the case of <b>desugaring</b> liver was also about 2 0 gher compared to control in same condition. From the point of composition of nitrogen components in peptic hydrolysates of the livers, it was recognized that defatting or <b>desugaring</b> liver was hydrolyzed to small molecules in comparision with that of control, in all the heating process. Especially, this phenomenon was observed in the case of livers autoclaved at 120 ℃. The presence of fat or reducing sugar in the liver was considered as a factor that inhibits the食用レバー(豚) を水煮した場合, 加熱が蛋白質の消化にどのように影響するか, また脱脂ならびに脱糖処理をして水煮した場合, 消化性がどのように向上するかについて, ペプシンによる人工消化試験を行なった. 1. 消化過程中における消化率の変化は, 生のもの, 加熱したもの(100 ℃および 120 ℃で 1 時間) 両者とも時間の経過にともない上昇した. しかし加熱温度が高いものほど消化率は低かった. 37 ℃で 24 時間消化後の消化率は生のもの 89. 1 %, 100 ℃で加熱したもの 84. 4 %, 120 ℃で加熱したもの 77. 6 %であった. 2. 脱脂(凍結乾燥レバーをエチルエーテルで処理) ならびに脱糖(生レバーをglucose-oxidaseで処理した後, 凍結乾燥, 脱糖率 59. 3 %) 処理により消化率は向上した. 脱脂したものの消化率は無処理のものより各加熱段階(60 ℃, 100 ℃および 120 ℃で 1 時間) とも約 3 〜 4 %高くなった. 脱糖したものも約 2 %高くなった. 消化生成物中の窒素成分の組成の点からみても, 脱脂ならびに脱糖処理を行なったものは無処理のものより小分子のものに分解されていることが認められた. 特に 120 ℃に加熱したものではその傾向が顕著にあらわれた. 3. レバーの消化を阻害する因子として蛋白質の加熱変性以外に, 脂肪や還元糖の存在が考えられ, これらは加熱温度が高い場合に著しく影響することが分った...|$|E
50|$|The CAL {{compiler}} takes CAL source, as text or as {{a source}} model (Java object model). This is processed by the early compiler stages to <b>desugar</b> and analyse the source. The intermediate form, plus metadata from analysis, is processed {{by a number of}} optimisers, optionally including a full rewrite optimiser capable of function fusion, deforestation and other major optimisations that preserve semantics but improve a program operationally.|$|R
40|$|Beet vinasse (<b>desugared,</b> beet molasses) was co-composted {{with each}} of three {{following}} solid agricultural residues: grape marc, olive press cake and the cotton gin trash. The composts were used to fertilize corn. A treatment of mineral fertilizer was used for comparison. Compost had no {{detrimental effects on the}} growth parameters and nutritional status of corn. compost treatments produced yields (weight of grain) that were higher than those obtained for mineral fertilizers. Peer Reviewe...|$|R
5000|$|GHC's front end—incorporating the lexer, parser and typechecker—is {{designed}} to preserve {{as much information}} about the source language as possible until after type inference is complete, toward the goal of providing clear error messages to users. After type checking, the Haskell code is <b>desugared</b> into a typed intermediate language known as [...] "Core" [...] (based on System F, extended with [...] and [...] expressions). Recently, Core was extended to support generalized algebraic datatypes in its type system, and is now based on an extension to System F known as System FC.|$|R
40|$|It {{is quite}} natural {{to define a}} {{software}} language {{as an extension of}} a base language. A compiler builder usually prefers to work on a representation in the base language, while programmers prefer to program in the extended language. As we define a language extension, we want to ensure that <b>desugaring</b> it into the base language is provably sound. We present a lightweight approach to verifying soundness by embedding the base language and its extensions in Haskell. The embedding uses the final tagless style, encoding each language as a type class. As a result, combination and enhancement of language extensions are expressed in a natural way. Soundness of the language extension corresponds to well-typedness of the Haskell terms, so no extra tool but the compiler is needed...|$|E
40|$|Abstract. We {{present the}} design of a {{compiler}} for a functional logic programming language and discuss the compiler’s implementation. The source program is abstracted by a constructor based graph rewriting system obtained from a functional logic program after syntax <b>desugaring,</b> lambda lifting and similar transformations provided by a compiler’s front-end. This system is non-deterministic and requires a specialized normalization strategy. The target program consists of 3 procedures that execute graph replacements originating from either rewrite or pull-tab steps. These procedures are deterministic and easy to encode in an ordinary programming language. We describe the generation of the 3 procedures, discuss the correctness of our approach, highlight some key elements of an implementation, and benchmark the performance of a proof-of-concept. Our compilation scheme is elegant and simple enough to be presented in one page. ...|$|E
40|$|We {{present a}} {{compiler}} for the functional language HDC, which aims at {{the generation of}} efficient code from high-level programs. HDC, which is syntactically {{a subset of the}} widely used language Haskell, facilitates the clean integration of skeletons with a predefined efficient parallel implementation into a functional program. Skeletons are higher-order functions which represent program schemata that can be specialized by providing customizing functions as parameters. The only restriction on customizing functions is their type. Skeletons can be composed of skeletons again. With HDC, we focus on the divide-and-conquer paradigm, which has a high potential for an efficient parallelization. We describe the most important phases of the compiler: <b>desugaring,</b> elimination of higher-order functions, generation of an optimized directed acyclic graph and code generation, with a focus on the integration of skeletons. The effect of the transformations on the target code is demonstrated on the examp [...] ...|$|E
50|$|Many road {{authorities}} in North America use <b>desugared</b> beet molasses as de-icing or anti-icing products in winter control operations. The molasses {{can be used}} directly, combined with liquid chlorides and applied to road surfaces, or used to treat the salt spread on roads. Molasses can be more advantageous than road salt alone because it reduces corrosion and lowers the freezing point of the salt-brine mix, so the de-icers remain effective at lower temperatures. The addition of the liquid to rock salt has the additional benefits that it reduces the bounce and scatter of the rock salt, keeping it where it is needed, and reduces the activation time of the salt to begin the melting process.|$|R
40|$|The IOA {{language}} provides notations {{for defining}} both primitive and composite I/O automata. This note describes, both formally and with examples, the constraints on these definitions, thecomposability {{requirements for the}} components of a composite automaton, and the transformationof a composite automaton into an equivalent primitive automaton. Section 2 introduces four examples used throughout this note to illustrate new definitions andoperations. Section 3 treats IOA programs for primitive I/O automata: it introduces notationsfor describing the syntactic structures that appear in these programs, and it lists syntactic andsemantic conditions that these programs must satisfy to represent valid primitive I/O automata. Section 4 describes how to reformulate primitive IOA programs into an equivalent but more regular(desugared) form that is used in later definitions in this note. Section 5 treats IOA programsfor composite I/O automata: it introduces notations for describing the syntactic structures thatappear in these programs, describes resortings induced by them, and lists syntactic and semanticconditions that these programs must satisfy to represent valid composite I/O automata. Section 6 describes the translation of the name spaces of component automata into a unified name spacefor the composite automaton. Section 7 shows how to expand an IOA program for a compositeautomaton into an equivalent IOA program for a primitive automaton. The expansion is generatedby combining syntactic structures of the <b>desugared</b> programs for the component automata afterapplying appropriate replacements of sorts and variables. Section 8 details the expansion of thecomposite automaton introduced in Section 2 using the <b>desugared</b> forms developed throughoutSections 4 Â 6 and the techniques described in Section 7. Finally, Section 9 gives a precise definitionof the resortings and substitutions used to replace sorts and variables...|$|R
40|$|We propose type {{systems that}} abstractly {{interpret}} small-step rather than big-step operational semantics. We treat an expression or evaluation context as a structure in a linear logic with hypothetical reasoning. Evaluation order {{is not only}} regulated by familiar focusing rules in the operational semantics, but also expressed by structural rules in the type system, so the types track control flow more closely. Binding and evaluation contexts are related, but the latter are linear. We use these ideas to build a type system for delimited continuations. It lets control operators change the answer type or act beyond the nearest dynamically-enclosing delimiter, yet needs no extra fields in judgments and arrow types to record answer types. The typing derivation of a directstyle program <b>desugars</b> it into continuation-passing style...|$|R
40|$|Many {{programming}} languages can {{be studied}} by <b>desugaring</b> them into an intermediate language, namely, the simply-typed - calculus. In this manner Landin and Tennent discovered a "correspondence" between the semantics of definition bindings and parameter bindings such that the semantics of free identifiers becomes independent of their mode of definition. In this paper we consider programming languages with modules and we desugar modules into records. A categorical model for the simply-typed - calculus with records is then freely generated. The record construction becomes a tensor product, the lambda abstraction construction becomes a function space, and if the language satisfies the correspondence principle, then the categorical exponentiation diagram commutes. A converse result is also proved. The framework for defining the model is of interest because it defines a hierarchy of call-by-value -calculi, of which call-by-name is the weakest form of call-by-value calculus. Applications to c [...] ...|$|E
40|$|Abstract Syntax Trees (ASTs) are {{commonly}} used to represent an input/output program in compilers and language processing tools. Many of the tasks of these tools consist in generating and rewriting ASTs. Such an approach can become tedious and hard to maintain for complex operations, namely program transformation, optimization, instrumentation, etc. On the other hand, concrete syntax provides a natural and simpler representation of programs, {{but it is not}} usually available as a direct feature of the aforementioned tools. We propose a simple technique to implement AST generation and rewriting in general purpose languages using concrete syntax. Our approach relies on extensions made in the scanner and the parser and the use of objects Syntax Trees (TWEASTs). A compiler for a simple language (Tiger) written in C ++ serves as an example, featuring transformations in concrete syntax: syntactic <b>desugaring,</b> optimization, code instrumentation such as boundschecking, etc. Extensions of this technique to provide a fullfledged concrete-syntax rewriting framework are presented as well...|$|E
40|$|Abstract. We reduce JavaScript to a core {{calculus}} structured as a small-step operational semantics. We present several {{peculiarities of}} the language and show that our calculus models them. We explicate the <b>desugaring</b> process that turns JavaScript programs into ones in the core. We demonstrate faithfulness to JavaScript using real-world test suites. Finally, we illustrate utility by defining a security property, implementing it as a type system on the core, and extending it to the full language. 1 The Need for Another JavaScript Semantics The growing use of JavaScript has created whole new technical and business models of program construction and deployment. JavaScript is a feature-rich language with many quirks, and these quirks are often exploited by security and privacy attacks. This {{is especially true in}} cases where JavaScript has a familiar syntax but an unconventional semantics. Due to its popularity and shortcomings, companies and researchers have tried to tame JavaScript via program analyses [4, 9, 10, 13], sub-language [5, 7, 17], an...|$|E
40|$|The goal of {{my thesis}} {{project is to}} create a {{framework}} for encoding and reasoning about functional languages in the Isabelle theorem prover. The framework will encode languages using deep embeddings, with higher-order abstract syntax. The motivating test case is the GHC-Core language—an explicitly-typed, <b>desugared</b> variant of Haskell which is used as an intermediate language by the Glasgow Haskell Compiler (GHC). My thesis statement consists of two parts: First, that the methodology that I present here is a good general way to formalize languages in a theorem prover. In particular, the framework should scale well enough to handle languages at least as complex as GHC-Core. Second, that using a deep embedding with higher-order abstract syntax facilitates doing proofs about object programs. A successful implementation of the framework should provide a level of proof automation comparable to that provided by other libraries (such as Isabelle/HOLCF domain theory). ...|$|R
40|$|Functionality of {{software}} systems has exploded {{in part because}} of advances in programming-language support for packaging reusable functionality as libraries. Developers benefit from the uniformity that comes of exposing many interfaces in the same language, as opposed to stringing together hodgepodges of command-line tools. Domain-specific languages may be viewed as an evolution of the power of reusable interfaces, when those interfaces become so flexible as to deserve to be called programming languages. However, common approaches to domain-specific languages give up many of the hard-won advantages of library-building in a rich common language, and even the traditional approach poses significant challenges in learning new APIs. We suggest that instead of continuing to develop new domain-specific languages, our community should embrace library-based ecosystems within very expressive languages that mix programming and theorem proving. Our prototype framework Fiat, a library for the Coq proof assistant, turns languages into easily comprehensible libraries via the key idea of modularizing functionality and performance away from each other, the former via macros that <b>desugar</b> into higher-order logic and the latter via optimization scripts that derive efficient code from logical programs...|$|R
40|$|One hundred seventy five steers (902 lb initial body weight) {{were used}} in a {{finishing}} study {{to determine the effect}} of betaine, provided either as feed-grade betaine (Betafin-S 6, Finnsugar Bioproducts) or as concentrated separator by-product (CSB; <b>desugared</b> beet molasses), on animal performance and carcass characteristics. Steers were fed a finishing diet based on steam-flaked and dry-rolled corn. Treatments included 10. 5 or 21 g/steer daily supplemental feed-grade betaine or 250 g (15. 5 betaine) or 500 g (31 g betaine) of CSB per steer daily. Dry matter intakes increased (linear, P< 0. 1) for steers supplemented with feed- grade betaine. Average daily gains and feed efficiencies were not affected by treatments. Dressing percent and twelfth rib back fat increased (P< 0. 1) for steers that received feed-grade betaine. Rib-eye area decreased (P< 0. 1) when steers were supplemented with either feed-grade betaine or CSB. Yield grades were significantly higher (linear, P< 0. 1) for cattle receiving supplemental CSB or feed-grade betaine (quadratic, P<. 05). Hot carcass weights, KPH, marbling scores, and percentage of carcasses grading USDA Choice were not affected by supplemental betaine. In this study, betaine supplementation did not markedly alter growth performance, but carcass fatness tended to increase for both supplements...|$|R
40|$|Unparsing, as {{implemented}} by scala. tools. unparse, makes explicit the <b>desugaring,</b> code expansion (“adding synthetics”), and type inference that the scalac compiler routinely performs. A close relative of unparsing, pretty-printing, usually results in less detailed output, as for example inferred types {{are not made}} explicit (that’s the terminology we follow in this write-up). A tool that already shows detailed types is Scaladoc [1], moreover taking into account any type instantiations and type refinements that might be in effect (unlike Javadoc, where “if method C:m returns type T, subclasses of C will always [be displayed with that] parent signature, even if they instantiate T to a concrete type such as Integer ”) We {{take a look at}} the “type unparsing ” capabilities of Scaladoc. First, by using Scaladoc as a library from within a compiler plugin (our unparser). After that, we duplicate that functionality without running Scaladoc at all. In spite of its focus, this write-up might also be of interest to those interested in the internal workings of API documentation tools in general (e. g., see also Collaborative Scaladoc...|$|E
40|$|The MultiJava Compiler (MJC) is an {{extension}} to the Java programming language that adds open classes and symmetric multiple dispatch. The Java Modeling Language (JML) is a Behavioral Interface Specification Language (BISL) {{that can be used}} to specify both simple DBC and full behavioral interface specifications. The JML toolset is based on MJC and contains tools such as the JML (type) checker and the JML Runtime Assertion Checker (RAC). JMLb, is a new version of JML that supports arbitrary precision integers and safe-arithmetic. In this thesis we present the implementation of (bytecode level) support for safe-math integral arithmetic in MJC as well as a performance evaluation of this new version of MJC, in comparison with other Java compilers. Another main enhancement presented in this thesis is the implementation of a non-null statistics gathering tool in the JML checker. An overview of the <b>desugaring</b> process for various kinds of JML method specifications is given. In addition, rules for judging non-null usage are described by presenting examples of different scenarios...|$|E
40|$|Recent {{work has}} {{proposed}} a promising approach to improving scalability of program synthesis by allowing the user to supply a syntactic template that constrains the space of potential programs. Unfortunately, creating templates often requires nontrivial effort from the user, which impedes the usability of the synthesizer. We present {{a solution to this}} problem in the context of recursive transformations on algebraic data-types. Our approach relies on polymorphic synthesis constructs: a small but powerful extension to the language of syntactic templates, which makes it possible to define a program space in a concise and highly reusable manner, {{while at the same time}} retains the scalability benefits of conventional templates. This approach enables end-users to reuse predefined templates from a library for a wide variety of problems with little effort. The paper also describes a novel optimization that further improves the performance and scalability of the system. We evaluated the approach on a set of benchmarks that most notably includes <b>desugaring</b> functions for lambda calculus, which force the synthesizer to discover Church encodings for pairs and boolean operations...|$|E
40|$|As JavaScript {{gets more}} popular in web programming, {{a demand for}} better {{analysis}} of JavaScript programs becomes higher. How-ever, many dynamic features of JavaScript make its analysis, es-pecially static analysis, particularly difficult. One of the main dy-namic features of JavaScript is the with statement, which invali-dates lexical scoping by introducing a new scope at run time. To simplify the problem, many researchers leave the with statement out of their consideration and major web service companies force their web application developers to use sub-languages of JavaScript which {{do not include the}} with statement. While deprecating a po-tentially dangerous feature might be the easiest solution, it could be too restrictive for application development. To decide whether to include the with statement, we should better understand the actual usage patterns of the with statement. In this paper, we present the usage patterns of the with state-ment in real-world JavaScript applications currently used in the 98 most popular web sites. We investigate whether we can rewrite the with statements in each pattern to other statements not using with. We show that we can rewrite all the static occurrences of the with statement which does not have any dynamic code generating functions. Even though the rewriting process is not applicable to any dynamically instrumented with statements either, our result is still promising. Because all the static approaches that disallow the with statement also disallow dynamic code instrumentation, such static approaches can allow the with statement using our rewriting process: JavaScript developers use the with statement in their ap-plications and the rewriting process <b>desugars</b> it away. Automating the rewriting process is under progress and we believe that it will make static analysis of JavaScript programs more feasible while imposing less restriction...|$|R
40|$|AbstractThe Orc {{calculus}} is a simple, yet powerful {{theory of}} concurrent computations with great versatility and practical applicability {{to a very}} wide range of applications, {{as it has been}} amply demonstrated by the Orc language, which extends the Orc calculus with powerful programming constructs that can be <b>desugared</b> into the underlying formal calculus. This means that for: (i) theoretical, (ii) program verification, and (iii) language implementation reasons, the formal semantics of Orc is of great importance. Furthermore, having a semantics of Orc that is executable is essential to provide: (i) a formally-defined interpreter against which language implementations can be validated, and (ii) a (semi-) automatic way of generating a wide range of semantics-based program verification tools, including model checkers and theorem provers. This work proposes a formal executable semantics for Orc in rewriting logic, to support formal verification of Orc programs and to make possible semantics-based correct-by-construction Orc implementations. While being a very simple calculus, Orc has a quite subtle semantics, so that fully capturing all its semantic aspects is highly nontrivial. The two main sources of subtlety are: (i) its real-time semantics, and (ii) the priority of internal computations within an Orc expression over external computations that process responses from external sites. In this paper, we show a simple and elegant way of handling these two sources of subtlety in rewriting logic using an order-sorted type system supporting subtypes and subtype polymorphism, and “tick” rewrite rules for capturing time. Moreover, our rewriting semantics incorporates useful semantic equivalences between Orc programs as equations and equational attributes, making the semantics both more abstract and more efficient. The semantics of Orc is given in two different styles: (i) an SOS style, which is directly based on the original SOS of Orc, whose correctness follows immediately by construction, and (ii) a reduction semantics, which is much more efficiently executable and analyzable, as shown through several experiments, and whose correctness is proved using a strong bisimulation theorem. The paper also presents MOrc, a simulator and model checking tool based on the rewriting semantics of Orc and Real-Time Maude. MOrc facilitates formal verification of Orc programs, and allows for user-defined state predicates and LTL formulas, with no need for any prior knowledge of Maude or its rewriting logic foundations...|$|R
40|$|ABSTRACT The {{distribution}} of enterococci in various {{dried egg white}} products was surveyed, and some behaviors of enterococci, detected from the dried egg whites, in the manufacturing process of dried egg white were studied. From some of dried egg white samples, enterococci including Streptococcus faecalis, S. faecalis var. liquefaciens, and S. faecium were identified, but S. durans was not detected. These three spp. of enterococcus did not grow in yolk-free egg white, but grew well in egg white containing small quantities of egg yolk. These enterococci hardly decreased by the pasteurization in various conditions including Cunningham and Lineweaver's method. In the <b>desugaring</b> process by glucose oxidase method these enterococci perished, but in yeast or bacteria fermentation of yolk-free egg white, the counts of these enterococci hardly changed. Small counts of presumable enterococci perished in the spontaneous fermentation of yolk-free egg white, but increased rapidly in the fermentation of the egg white containing 0. 15 % yolk. These enterococci decreased considerably by spray drying egg white, but hardly changed by pan drying. In the heat treatments of dried powder at 57 ° C. and of dried crystal at 50 ° C, many days were needed {{for the destruction of}} these enterococci...|$|E
