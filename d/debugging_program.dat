39|1163|Public
50|$|A model-specific {{register}} (MSR) is any {{of various}} control registers in the x86 instruction set used for <b>debugging,</b> <b>program</b> execution tracing, computer performance monitoring, and toggling certain CPU features.|$|E
50|$|Numerical {{machine code}} (i.e., not {{assembly}} code) may {{be regarded as}} the lowest-level representation of a compiled or assembled computer program or as a primitive and hardware-dependent programming language. While it is possible to write programs directly in numerical machine code, it is tedious and error prone to manage individual bits and calculate numerical addresses and constants manually. For this reason, programs are almost never written directly in machine code in modern contexts. Three exceptions are: for low level <b>debugging,</b> <b>program</b> patching, and assembly language disassembly (which would be called for in the absence of assembly source code, when only the machine language object code is available).|$|E
40|$|Program paths—sequences of {{executed}} basic blocks—have {{proven to}} be an effective way to capture a program’s elusive dynamic behavior. This paper shows how paths and path spectra compactly and precisely record many aspects of programs’ execution-time control flow behavior and explores applications of these paths in computer architecture, compilers, <b>debugging,</b> <b>program</b> testing, and software maintenance...|$|E
5000|$|DBX is also {{available}} on IBM z/OS systems, in the UNIX System Services component. DBX for z/OS can <b>debug</b> <b>programs</b> written in C and C++, and can also perform machine level debugging. As of z/OS V1R5, DBX is able to <b>debug</b> <b>programs</b> using the DWARF debug format. z/OS V1R6 added support for <b>debugging</b> 64-bit <b>programs.</b>|$|R
50|$|To {{compile a}} program using {{multiple}} threads with the Microsoft C/C++ Compiler, you must specify the /MT switch (or /MTd, for <b>debug</b> <b>programs).</b>|$|R
5000|$|The {{availability}} of compilers, assemblers, and a Symbolic Debugging System (SDS) that allow users to <b>debug</b> <b>programs</b> written in high-level languages such as FORTRAN, Pascal, PL/I, ... {{as well as}} in assembly language.|$|R
40|$|Program slicing is {{a program}} {{transformation}} that is useful in program <b>debugging,</b> <b>program</b> maintenance, and other applications that involve understanding program behavior. Given a program point p {{and a set of}} variables V, the goal of slicing is to create a projection of the program (by eliminating some statements), such that the projection and the original program compute the same values for all variables in V at point p. This pape...|$|E
40|$|This {{viewgraph}} presentation {{provides information}} on {{the technical aspects of}} debugging computer code that has been automatically converted for use in a parallel computing system. Shared memory parallelization and distributed memory parallelization entail separate and distinct challenges for a <b>debugging</b> <b>program.</b> A prototype system has been developed which integrates various tools for the debugging of automatically parallelized programs including the CAPTools Database which provides variable definition information across subroutines as well as array distribution information...|$|E
40|$|Information {{about which}} {{statements}} in a concurrent program may happen in parallel (MHP) {{has a number}} of important applications. It can be used in program optimization, <b>debugging,</b> <b>program</b> understanding tools, improving the accuracy of data flow approaches (e. g. [8, 12, 16]), and detecting synchronization anomalies, such as data races. For example, in optimization, if it is known that two threads of control will never attempt to enter a critical region of code at the same time...|$|E
50|$|The FX-603P {{featured}} a two line dot matrix display with 16 characters each as main display. An additional 4 digits 7-segment display used {{to display the}} program step when entering or <b>debugging</b> <b>programs</b> and 20 status indicators.|$|R
50|$|Programs {{designed}} to require concurrency {{are more difficult}} to <b>debug.</b> <b>Programs</b> {{designed to}} require concurrency will have performance issues when the number of required threads exceeds the number of hardware threads because time slicing artifacts can hit hard.|$|R
50|$|The GNU MIX Development Kit (GNU MDK) {{is a free}} {{software}} package for developing, running and <b>debugging</b> <b>programs</b> written in MIXAL, an assembly-like language for programming a hypothetical computer called MIX. GNU MDK {{is part of the}} GNU Project.|$|R
40|$|In "An Interrupt Based Organization for Management Information Systems" (1), {{the author}} of that paper proposes {{a new form of}} interrupt, a Boolean {{expression}} of variables in the program, as a natural extension from the present interrupt structure. His paper describes a software implementation; this note shows how his system could easily be implemented in hardware, with a corresponding decrease in system overhead. Keywords and Phrases: Interrupts, Interrupt scheduling, supervisors, monitors, <b>debugging,</b> <b>program</b> checkout, parallel processing, associative memories, microprogramming...|$|E
40|$|Regular approximations {{of logic}} {{programs}} {{have a variety}} of uses, including static analysis for <b>debugging,</b> <b>program</b> specialisation, and machine learning. An algorithm for computing a regular approximation of a normal program is given, and some applications are discussed. The analysis of a “magic set ” style of transformation of a program P can be used to derive more precise approximations than can be obtained from P itself. The approximation algorithm given here can also be applied to Prolog programs. 2...|$|E
40|$|Fault {{localization}} is {{an expensive}} technique in software <b>debugging.</b> <b>Program</b> dependence graphs are used for testing, debugging and maintenance applications in software engineering. Program dependence graphs (PDG) are used to build a probabilistic graphical model of program behavior. In this paper we proposed a model based fault localization technique using probabilistic program dependence (PPDG). This work presents algorithm for constructing PPDGs and PPDGs based fault localization. Our experimental result shows that proposed PPDG based fault localization method performs better than existing testing based fault localization (TBFL) method for DotNet programs. Our results also indicate that the probabilistic approach is efficient for fault localization...|$|E
50|$|Depending {{upon the}} system, {{low-level}} formatting was generally done by an operating system utility. IBM compatible PCs used the BIOS, which is invoked using the MS-DOS <b>debug</b> <b>program,</b> to transfer control to a routine hidden at different addresses in different BIOSes.|$|R
50|$|The FX-601P series {{featured}} {{a single line}} dot matrix display with 11 characters as main display. An additional 3 digits 7-segment display used to display exponents as well as program steps when entering or <b>debugging</b> <b>programs.</b> There were 11 status indicators.|$|R
50|$|Daikon is a {{computer}} program that detects likely invariants of programs. An invariant is a condition that always holds true at certain points in the program. It is mainly used for <b>debugging</b> <b>programs</b> in late development, or checking modifications to existing code.|$|R
40|$|Debugging is {{commonly}} understood as finding and fixing {{the cause of}} a problem. But what does "cause" mean? How can we find causes? How can we prove that a cause is a cause [...] -or even "the" cause? This paper defines common terms in debugging, highlights the principal techniques, their capabilities and limitations. KEYWORDS: Automated <b>Debugging,</b> <b>Program</b> Analysis, Causality 1 How Failures Come to Be Software bugs are a pain. In the US alone, software bugs cause costs of nearly 60 billion US$ anually, with {{more than half of the}} cost borne by end users[RTI 02]. How can we get rid of bugs? Basically, there are two methods:...|$|E
40|$|Although {{software}} engineering is a well-documented area of computer science, courses in {{software engineering}} frequently {{do not give}} students enough practical experience with concepts such as software design, prototyping, programming, <b>debugging,</b> <b>program</b> understanding, software reuse, and so on. As a result, computer science graduates too often acquire a sound theoretical understanding of software engineering concepts, without practical experience using these concepts #a recurrent complaint from industry#. We believe that this problem {{is partly due to}} a lack of appropriate tools for software engineering education. In this paper we presentanoverview of the tools wehave developed for software engineering education and how they are successfully being used in the instruction of a software engineering course at the UniversityofToronto...|$|E
40|$|In {{the first}} part of my thesis, I was {{studying}} materials about using solar energy. Then I write search about all components that are necessary to be used in solar systems. After that I designed the structure of solar system used for heating the hot water for a family house about 4 persons. For this system I designed a regulator and one layer circuit board using Eagle layout editor 4. 12 r 2, which I assembled and tested. This followed creating and <b>debugging</b> <b>program</b> for microprocessor that controls the whole device. This functional regulator for solar collectors connected in a box together with the necessary electronic components is my final product of this project...|$|E
50|$|HBasic is an {{integrated}} development environment used to create, execute and <b>debug</b> <b>programs</b> with a Basic language. HBasic has object oriented features either in combination with precompiled C++ components (shared libraries) or class definitions (HBasic sourcecode). This also includes a version of inheritance.|$|R
50|$|When the DOS <b>DEBUG</b> <b>program</b> is in memory, Ontario.2048 will detect it and {{disinfect}} {{programs in}} memory {{to avoid being}} analysed. Ontario.2048 also features an extremely complex encryption system; a given sample of Ontario.2048 may only share two bytes in common with another.|$|R
5000|$|... is {{a system}} call tracer for Sun(tm) systems much like the Sun {{supplied}} program [...] [...] is a useful utility to sort of <b>debug</b> <b>programs</b> for which no source is available which unfortunately includes {{almost all of the}} Sun supplied system software.|$|R
40|$|Abstract. Beginning {{software}} engineering students often lack {{skills necessary to}} perform efficient programming work, such as comprehending or <b>debugging</b> <b>program</b> code. To facilitate {{the needs of students}} having different skill levels, teachers should be able to recognize the specific student groups. Bloom’s Taxonomy defines educational objectives for the development of students ’ cognitive skills. This paper presents a study of 254 undergraduate students of a basic programming course whose performance were measured on different levels of Bloom’s Taxonomy. The results of statistical cluster analysis suggest that the obtained student groups did not align with the Bloom’s Taxonomy: students performing poorly on lower levels can still perform well on higher taxonomy levels. Based on the results, this paper suggests six student groups the teacher should recognize when organizing basic programming courses. ...|$|E
40|$|Existing {{algorithmic}} debuggers for Haskell {{require a}} transformation of all modules in a program, even libraries that the user {{does not want to}} debug and which may use language features not supported by the debugger. This is a pity, because a promising ap- proach to debugging is therefore not applicable to many real-world programs. We use the cost centre stack from the Glasgow Haskell Compiler profiling environment together with runtime value observations as provided by the Haskell Object Observation Debugger (HOOD) to collect enough information for algorithmic <b>debugging.</b> <b>Program</b> annotations are in suspected modules only. With this technique algorithmic debugging is applicable to a much larger set of Haskell programs. This demonstrates that for functional languages in general a simple stack trace extension is useful to support tasks such as profiling and debugging...|$|E
40|$|Program slicing is a {{fundamental}} operation for manysoftware engineering tools. Currently,the most efficient algorithm for interprocedural slicing is one that uses a program representation called the system dependence graph. This paper defines a newalgorithm for slicing with system dependence graphs that is asymptotically faster than the previous one. Apreliminary experimental study indicates that the newalgorithm is also significantly faster in practice, providing roughly a 6 -fold speedup on examples of 348 to 757 lines. CR Categories and Subject Descriptors: D. 2. 2 [Software Engineering]: Tools and Techniques - programmer workbench; D. 2. 6 [SoftwareEngineering]: Programming Environments; D. 2. 7 [SoftwareEngineering]: Distribution and Maintenance - enhancement, restructuring;E. 1 [Data Structures] graphs General Terms: Algorithms, Performance Additional Key Words and Phrases: dynamic programming, dynamic transitive closure, flow-sensitive summary information, program <b>debugging,</b> <b>program</b> [...] ...|$|E
5000|$|Another {{technique}} for <b>debugging</b> <b>programs</b> remotely {{is to use}} a remote stub. In this case, the <b>program</b> to be <b>debugged</b> is linked with a few special-purpose subroutines that implement the GDB remote serial protocol. The file containing these subroutines is called a [...] "debugging stub".|$|R
50|$|Monitor can be {{used for}} reading and writing memory, modifying CPU registers, running code at {{specific}} addresses in memory, saving/loading memory to/from a plugin option, etc. This is very useful for <b>debugging</b> <b>programs</b> written in machine code in difference to programs written in the EPSON BASIC programming language.|$|R
50|$|A {{time-sharing}} system, TSS-8, {{was also}} available. TSS-8 allowed multiple users to log {{into the system}} via 110-baud terminals, and edit, compile and <b>debug</b> <b>programs.</b> Languages included a special version of BASIC, a FORTRAN subset similar to FORTRAN-1 (no user-written subroutines or functions), an ALGOL subset, FOCAL, and an assembler called PAL-D.|$|R
40|$|A {{practical}} {{procedure for}} computing a regular approximation of a logic program is given. Regular approximations {{are useful in}} a variety of tasks in <b>debugging,</b> <b>program</b> specialisation and compile-time optimisation. The algorithm shown here incorporates optimisations taken from deductive database fixpoint algorithms and efficient bottom-up abstract interpretation techniques. Frameworks for defining regular approximations have been put forward in the past, but the emphasis has usually been on theoretical aspects. Our results contribute mainly to the development of effective analysis tools that can be applied to large programs. Precision of the approximation can be greatly improved by applying query-answer transformations to a program and a goal, thus capturing some argument dependency information. A novel technique is to use transformations based on computation rules other than left-to-right to improve precision further. We give performance results for our procedure on a range of programs. ...|$|E
40|$|Algebraic {{specifications}} {{have been}} used successfully as a formal basis for software development. The contribution {{of this paper is}} to show that the origin and dynamic dependence relations that are implicitly defined by an algebraic specification can be used to define powerful language-specific tools. In particular, it is shown how tools for source-level debugging and dynamic program slicing can be derived from algebraic specifications of interpreters. 1991 Mathematics Subject Classification: 68 N 20 [Software]: Compilers and generators, 68 Q 55 [Theory of computing]: Semantics, 68 Q 65 [Theory of computing]: Abstract data types; algebraic specification. 1991 CR Categories: D. 2. 5 [Software engineering]: Testing and debugging, D. 2. 6 [Software engineering]: Programming environments, F. 3. 2 [Logics and meanings of programs]: Semantics of programming languages. Keywords & Phrases: <b>Debugging,</b> <b>program</b> slicing, dynamic slicing, interpreters, programming environments, origin tracking, dynamic depend [...] ...|$|E
40|$|Previous work in {{software}} visualization has demonstrated {{the advantages of}} presenting programs in a graphical manner in both program understanding and debugging. Among the class of program visualization systems are those which operate non-intrusively on program sources. One of the major challenges faced by users of such systems {{is the problem of}} filtering the enormous amount of run-time information present during the execution of a large system. In this thesis, I describe an evolution of the Software Landscape. The Software Landscape is a tool for browsing a software system's static structure using boxes together with arrow and containment relations. My Run-Time Landscape includes run-time information, utilizes the Landscape paradigm for the elision of unwanted details, and provides a tightly integrated environment for viewing program artifacts from different perspectives. This prototype is useful in <b>debugging,</b> <b>program</b> understanding, and profiling. ii Acknowledgements I am grateful [...] ...|$|E
50|$|Plato is the Integrated Development Environment {{supplied}} with FTN95. It can edit, compile and <b>debug</b> <b>programs</b> {{in a manner}} similar to the Visual Studio plug-ins. Although Plato specialises in Fortran it is not limited to it and can be tuned to work with any compiler. It is designed to stand-alone from FTN95.|$|R
40|$|The major {{challenge}} for present technology is to generate software more efficiently. Computers {{are being used}} in essentially all areas of human activities; even products that seemingly {{have nothing to do}} with computers contain a significant portion of computer related cost. More efficient software means three things: coding and <b>debugging</b> <b>programs</b> faster; generating program...|$|R
40|$|Program {{verification}} tools (such as model checkers and static analyzers) {{can find}} many errors in programs. These tools need formal specifications of correct program behavior, but writing a correct specification is difficult, just as writing a correct program is difficult. Thus, {{just as we}} need methods for <b>debugging</b> <b>programs,</b> we need methods for debugging specifications...|$|R
