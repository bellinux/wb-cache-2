1101|10000|Public
25|$|Scala, an {{object-oriented}} and <b>functional</b> <b>programming</b> <b>language,</b> has a Scala-to-JavaScript compiler.|$|E
25|$|The lambda {{calculus}} {{may be seen}} as an idealised version of a <b>functional</b> <b>programming</b> <b>language,</b> like Haskell or Standard ML.|$|E
25|$|This {{algorithm}} {{is often used}} to demonstrate the power of a lazy <b>functional</b> <b>programming</b> <b>language,</b> because (implicitly) concurrent efficient implementations, using a constant number of arithmetic operations per generated value, are easily constructed as described above. Similarly efficient strict functional or imperative sequential implementations are also possible whereas explicitly concurrent generative solutions might be non-trivial.|$|E
50|$|The table shows a {{comparison}} of <b>functional</b> <b>programming</b> <b>languages</b> which compares various features and designs of different <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
50|$|This {{style is}} common in <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
50|$|The map {{function}} {{originated in}} <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
25|$|Over the years, {{a number}} of tools for {{analyzing}} and understanding systems described using CSP have been produced. Early tool implementations {{used a variety of}} machine-readable syntaxes for CSP, making input files written for different tools incompatible. However, most CSP tools have now standardized on the machine-readable dialect of CSP devised by Bryan Scattergood, sometimes referred to as CSPM. The CSPM dialect of CSP possesses a formally defined operational semantics, which includes an embedded <b>functional</b> <b>programming</b> <b>language.</b>|$|E
25|$|Scheme is {{primarily}} a <b>functional</b> <b>programming</b> <b>language.</b> It shares many characteristics {{with other members of}} the Lisp programming language family. Scheme's very simple syntax is based on s-expressions, parenthesized lists in which a prefix operator is followed by its arguments. Scheme programs thus consist of sequences of nested lists. Lists are also the main data structure in Scheme, leading to a close equivalence between source code and data formats (homoiconicity). Scheme programs can easily create and evaluate pieces of Scheme code dynamically.|$|E
500|$|The [...] "sharp" [...] suffix {{has been}} used by a number of other [...]NET {{languages}} that are variants of existing languages, including J# (a [...]NET language also designed by Microsoft that is derived from Java 1.1), A# (from Ada), and the <b>functional</b> <b>programming</b> <b>language</b> F#. The original implementation of Eiffel for [...]NET was called Eiffel#, a name retired since the full Eiffel language is now supported. The suffix has also been used for libraries, such as Gtk# (a [...]NET wrapper for GTK+ and other GNOME libraries) and Cocoa# (a wrapper for Cocoa).|$|E
40|$|The -calculus [1] adds {{explicit}} substitutions to the-calculus so as {{to provide}} a theoretical framework within which the implementation of <b>functional</b> <b>programming</b> <b>languages</b> can be studied. This paper generalises the-calculus to provide a linear calculus of explicit substitutions which analogously describes the implementation of linear <b>functional</b> <b>programming</b> <b>languages...</b>|$|R
50|$|Constraints {{have also}} been {{embedded}} into <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
50|$|Lazy {{evaluation}} {{is an essential}} feature of modern <b>functional</b> <b>programming</b> <b>languages</b> such as Haskell. Haskell {{is the latest in}} a series of languages based on lambda calculus and let expressions. These languages provide rich functionality through lazy evaluation, and a polymorphic type system using type inference. <b>Functional</b> <b>programming</b> <b>languages</b> also naturally support higher-order functions.|$|R
2500|$|Unlambda – An esoteric <b>functional</b> <b>programming</b> <b>language</b> {{based on}} combinatory logic ...|$|E
2500|$|Erlang ( [...] ) is a general-purpose, concurrent, <b>functional</b> <b>programming</b> <b>language,</b> {{as well as}} a garbage-collected runtime system.|$|E
2500|$|Haskell [...] is a standardized, {{general-purpose}} purely <b>functional</b> <b>programming</b> <b>language,</b> with non-strict semantics {{and strong}} static typing. It {{is named after}} logician Haskell Curry. The latest standard of Haskell is Haskell 2010. , a group {{is working on the}} next version, Haskell 2020.|$|E
50|$|Semantically these {{operators}} {{correspond to}} continuations, {{found in some}} <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
50|$|During {{the last}} few years many quantum <b>programming</b> <b>languages</b> based on the <b>functional</b> <b>programming</b> {{paradigm}} were proposed. <b>Functional</b> <b>programming</b> <b>languages</b> are well-suited for reasoning about programs.|$|R
50|$|<b>Functional</b> <b>programming</b> <b>languages</b> such as Scheme {{generally}} do not have goto, instead using continuations.|$|R
2500|$|Scheme is a <b>functional</b> <b>{{programming}}</b> <b>language</b> {{and one of}} the {{two main}} dialects of the programming language Lisp. [...] Unlike Common Lisp, the other main dialect, Scheme follows a minimalist design philosophy specifying a small standard core with powerful tools for language extension.|$|E
2500|$|In a {{standard}} Petri net, tokens are indistinguishable. [...] In a Coloured Petri net, every token has a value. [...] In popular tools for coloured Petri nets such as CPN Tools, {{the values of}} tokens are typed, and can be tested (using guard expressions) and manipulated with a <b>functional</b> <b>programming</b> <b>language.</b> A subsidiary of coloured Petri nets are the well-formed Petri nets, where the arc and guard expressions are restricted {{to make it easier}} to analyse the net.|$|E
5000|$|... potigol - A <b>functional</b> <b>programming</b> <b>language</b> in Portuguese for beginners.|$|E
50|$|In {{the context}} of <b>functional</b> <b>programming</b> <b>languages,</b> inline {{expansion}} is usually followed by the beta-reduction transformation.|$|R
5000|$|Attribute grammar, a {{formalism}} {{that can}} be used for aspect-oriented programming on top of <b>functional</b> <b>programming</b> <b>languages</b> ...|$|R
5000|$|<b>Functional</b> <b>programming</b> <b>languages</b> tend {{to rely on}} tail call {{optimization}} and higher-order functions {{instead of}} imperative looping constructs.|$|R
5000|$|Scala, an {{object-oriented}} and <b>functional</b> <b>programming</b> <b>language,</b> has a Scala-to-JavaScript compiler.|$|E
5000|$|Unlambda - An esoteric <b>functional</b> <b>programming</b> <b>language</b> {{based on}} combinatory logic ...|$|E
5000|$|Ur (programming language) - a <b>functional</b> <b>programming</b> <b>language</b> for web {{development}} ...|$|E
5000|$|Eugenio Moggi and Philip Wadler {{introduced}} {{the use of}} monads for structuring <b>programs</b> written in <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
5000|$|In 1978, ML built a {{polymorphic}} type {{system on}} top of Lisp, pioneering statically typed <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
40|$|The aim of {{this work}} is the {{development}} and application of a partial evaluation procedure for rewriting-based <b>functional</b> logic <b>programs.</b> <b>Functional</b> logic <b>programming</b> <b>languages</b> unite the two main declarative programming paradigms. The rewriting-based computational model extends traditional <b>functional</b> <b>programming</b> <b>languages</b> by incorporating logical features, including logical variables and built-in search, into its framework. This wor...|$|R
5000|$|Curry, a logic <b>functional</b> <b>{{programming}}</b> <b>language,</b> {{which allows}} programming concurrent systems http://www.informatik.uni-kiel.de/~curry/examples/#residuation.|$|E
5000|$|Lisp, {{implemented}} in 1958, {{was the first}} dynamically typed <b>functional</b> <b>programming</b> <b>language</b> ...|$|E
5000|$|CutEr is an {{open-source}} concolic {{testing tool}} for the Erlang <b>functional</b> <b>programming</b> <b>language.</b>|$|E
5000|$|Most <b>functional</b> <b>programming</b> <b>languages</b> have a {{primitive}} notion of product type. For instance, {{the product of}} type1, ..., typen is written type1...typen in ML and type1...typen in Haskell. In both these languages, tuples are written v1...vn and the components of a tuple are extracted by pattern-matching. Additionally, many <b>functional</b> <b>programming</b> <b>languages</b> provide more general algebraic data types, which extend both product and sum types. Product types are the dual of sum types.|$|R
30|$|With {{regard to}} the {{question}} whether <b>functional</b> <b>programming</b> <b>languages</b> are at all the right tool {{for the implementation of}} CMQ, we share the opinion stated in [29] that it is best to start with a <b>programming</b> <b>language</b> “whose computational fabric is by-default parallel” and that in the future “parallel programming will increasingly mean functional programming”. Notably, MapReduce and Hadoop are frameworks that are eventually based on the functions map and fold (aka reduce) of <b>functional</b> <b>programming</b> <b>languages.</b>|$|R
50|$|The lambda {{calculus}} influenced {{the design of}} the LISP <b>programming</b> <b>language</b> and <b>functional</b> <b>programming</b> <b>languages</b> in general. The Church encoding is named in his honor.|$|R
