10|107|Public
2500|$|The Bash command syntax is a superset of the Bourne shell command syntax. Bash can {{execute the}} vast {{majority}} of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc. [...] Bash command syntax includes ideas drawn from the Korn shell (ksh) and the C shell (csh) such as command line <b>editing,</b> <b>command</b> history, the directory stack, the $RANDOM and $PPID variables, and POSIX command substitution syntax $(…).|$|E
5000|$|No {{support for}} command line <b>editing</b> (<b>Command</b> {{retrieval}} and editing is handled at an abstraction level between user and shell.) ...|$|E
50|$|In computing, a {{line editor}} is a text editor {{in which each}} <b>editing</b> <b>command</b> applies {{to one or more}} {{complete}} lines of text designated by the user. Line editors predate screen-based text editors and originated in an era when a computer operator typically interacted with a teleprinter (essentially a printer with a keyboard), with no video display, and no ability to move a cursor interactively within a document. Line editors were also a feature of many home computers, avoiding the need for a more memory-intensive full-screen editor.|$|E
50|$|The <b>edit</b> <b>command</b> is a macro that expands to get -e.|$|R
5000|$|A wide {{selection}} of <b>editing</b> <b>commands,</b> including indenting and unindenting, paragraph reformatting and line joining.|$|R
50|$|TEX {{programs}} are {{a collection of}} TSS line <b>editing</b> <b>commands,</b> TSS session commands and TEX statements. TEX variables could be inserted into TSS commands and TSS line editor commands via the TEX variable substitution feature. TEX programs were primarily designed to extend the line editor system. Consequently, TEX had no concept of file input/output relying instead on applying line <b>edit</b> <b>commands</b> to the working file and saving as needed.|$|R
5000|$|EDT recognizes an {{additional}} usage for the Gold key, {{to enter a}} repeat count. For example, the keystrokes [...] enter a line of twenty equals signs. Repeat counts also apply to keypad editing commands, but if such a command itself requires the Gold key, the Gold key must be pressed again before the command key. For example, assuming a VT100 keypad, [...] perform the PASTE <b>editing</b> <b>command</b> (once), while [...] performs PASTE four times. For editing commands which are directional, such as moving the cursor, negative repeat counts {{may be used to}} indicate reverse direction.|$|E
5000|$|The Bash command syntax is a superset of the Bourne shell command syntax. Bash can {{execute the}} vast {{majority}} of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc. Bash command syntax includes ideas drawn from the Korn shell (ksh) and the C shell (csh) such as command line <b>editing,</b> <b>command</b> history, the directory stack, the [...] and [...] variables, and POSIX command substitution syntax [...]|$|E
50|$|In Overture, {{input of}} note {{data can be}} done by any of several methods: QWERTY {{keyboard}}, mouse, step entry MIDI keyboard recording, or real-time MIDI keyboard recording. Most notational symbols can be repositioned simply by dragging them with the mouse. Most other editing of notational symbols is performed by selecting the symbols using the mouse, and selecting the appropriate <b>editing</b> <b>command</b> from a menu or by clicking on a palette. MIDI data is edited in a special graphical view, where each note appears as a bar on a piano roll. Editing is done simply by adjusting the bars by dragging with the mouse.|$|E
40|$|In {{software}} system development, domain-specific visual notations are increasingly used and need a tool environment consisting of visual editors, simulators, model transformers, etc. Several Eclipse projects {{head for a}} meta technology to define domain-specific modeling languages. The Eclipse Modeling Framework (EMF) [4] {{can be used to}} define the underlying models of visual editors. A visual editor may be generated using the Graphical Modeling Framework (GMF) [3] which started recently as Eclipse technology subproject aiming at providing an infrastructure for generating visual editors in Eclipse. In essence, GMF forms a bridge between EMF and GEF [2], whereby a diagram definition is linked to a domain model which serves as input to the generation of a visual editor. GMF-generated editors offer basic <b>editing</b> <b>commands</b> to create, <b>edit,</b> move and delete single model elements (basic editing). Graph transformation-based editors (see e. g. Tiger [6]) show that the generation of editors with complex <b>editing</b> <b>commands</b> is also possible. Editing e. g. activity diagrams, there might be <b>editing</b> <b>commands</b> available which insert or delete a complete decision structure in one step. In this paper, we describe how meta model-based editor design and generation performed by GMF [3], can be extended by graph transformation concepts to define and generate complex <b>editing</b> <b>commands</b> to be used in GMF-generated visual editors...|$|R
50|$|PC DOS 6 {{does not}} include the <b>edit</b> <b>command.</b> Instead, it has the DOS E Editor. This was {{upgraded}} to support mouse and menus in version of 7.0.|$|R
40|$|Domain {{specific}} modeling {{languages are}} of increasing {{importance for the}} development of software and other systems. Meta tools are needed to support rapid development of domain-specific solutions. Usually, domainspecific modeling languages are defined by providing a meta model using the MOF/EMF approach. The language definition can be used to generate a corresponding editor using meta tools such as Eclipse GMF. The meta model defines all symbols and relations of the domain-specific model which can be used to provide an editor with basic <b>editing</b> <b>commands.</b> In addition, further language properties can be formulated by OCL constraints which form the input to a syntax checker. If the modeling language has not only simple syntax structures, syntax-directed editing would increase the convenience. Up to now, meta CASE tools being based on EMF do not provide support for the definition of complex <b>editing</b> <b>commands.</b> A natural way to define <b>editing</b> <b>commands</b> is the formulation by transformation rules, specifying the pre- and post-conditions of each command. The background for this approach is the grammar-based definition of visual modeling languages. While the transformation rules for simple commands can be generated automatically, complex commands are defined by the language designer. The formal basis for this kind of editor definition is given by graph transformation. A meta model-based editor specification extended by such rules shall be used to generate Eclipse plug-ins for domain-specific editing with complex <b>editing</b> <b>commands.</b> ...|$|R
5000|$|Some {{examples}} of variable usage: _ {{we can use}} quotes or other characters as delimiters {{as long as the}} string doesn't contain them a="hello" [...] _ here we use the / character as a delimiter (a common practice especially if the string has a [...] " [...] char) b=/world/ _ here we are concatenating strings together via the comma concatenation operator c=a,/ /,b _ the out statement will print [...] "hello world" [...] to the terminal without the quotes out:c _ here we use a TEX variable in a line <b>editing</b> <b>command</b> to find a line starting with [...] "hello world" [...] hello="hello world" [...] f:hello _ here we are replacing the [...] "hello" [...] string with the [...] "hello world" [...] string rs:a:c ...|$|E
5000|$|ARexx is a {{programming}} language that can communicate with other applications. Using ARexx, for example, one could request data from a database application {{and send it to}} a spreadsheet application. To support this facility, an application must be [...] "ARexx compatible" [...] by being able to receive commands from ARexx and execute them. A database program might have commands to search for, retrieve, and save data [...] - [...] the MicroFiche Filer database has an extensive ARexx command set. A text editor might have ARexx commands corresponding to its <b>editing</b> <b>command</b> set [...] - [...] the Textra editor supplied with JForth can be used to provide an integrated programming environment. The AmigaVision multimedia presentation program also has ARexx port built in and can control other programs using ARexx.|$|E
40|$|Composing {{text on the}} {{computer}} is usually heavily dependent on editing, such as moving text around, correcting spacing, and inserting punctuation characters. Dictation systems, based on automatic speech recognition, are not known for their efficiency as an editing tool—something that significantly reduces their potential for freeing the user from the keyboard. Speech recognition has almost invariably been tied to natural language, but we {{point out that this}} approach is inherently disadvantageous in important ways. Instead, given the evidence that humans routinely become experts at sequencing signs not related to natural language, we propose that <b>editing</b> <b>command</b> languages should rely on symbolizations {{similar to that of the}} keyboard. We introduce ShortTalk, an editing language whose command sequences are primitive symbol combinations that are not confusable with dictation. We argue that ShortTalk by construction may solve common editing situations much more efficiently than by use of keyboard and mouse. Our experimental results for ShortTalk indicate that an average information rate of about 16 bps for editing commands is achievable. Thus, editing by speech may be more efficient than by non-verbal means. 1...|$|E
5000|$|Using the {{scripting}} language, {{filters are}} prepared with <b>editing</b> <b>commands</b> to match and replace {{text in the}} downloaded page. Specific pages can be targeted for filtering by matching the page's URL with a specified pattern.|$|R
50|$|Emacs {{also has}} a {{built-in}} tutorial. Emacs displays instructions for performing simple <b>editing</b> <b>commands</b> and invoking the tutorial when it is launched with no file to edit. The tutorial is by Stuart Cracraft and Richard Stallman.|$|R
50|$|TEX {{programs}} were primarily designed {{to extend the}} line editor system. Consequently, TEX had no concept of file input/output relying instead on making changes to the working file via line <b>edit</b> <b>commands</b> and saving as needed.|$|R
40|$|Operations {{that create}} {{additive}} or subtractive volume features, such as bosses or slots, simplify the {{computer aided design}} of mechanical parts. Surface features,whether extracted automatically or selected interactively, group functionally related boundary elements, and thus provide an expedient interface between CAD systems and analysis or manufacturing applications. Despite much progress in CAD, design remains an iterative process and involves error-prone modifications of previous solutions. Features should in principle offer a high level vocabulary for characterizing errors and for specifyinghow they should be corrected. This paper points out the semantic ambiguities of simplistic feature-based commands for editing models. It recommends procedural models for editing volume features, and corrective volumes for editing surface features. It shows how space decomposition techniques and CSG expressionsbased on active zones {{reduce the cost of}} executing an <b>editing</b> <b>command.</b> Error detection may be automated by supporting intentional features, which correspond to the desired characteristics of the model, and by endowing them with domain dependent validity criteria expressed in terms of associated geometric elements. The paper demonstrates that validity may be tested by simply interrogating a mixed-dimensional geometric structure which is used to represent not only the model, but also the interactions between the geometric elements associated with intentional features...|$|E
5000|$|Special <b>editing</b> <b>{{commands}},</b> such as {{commands to}} jump to the beginning {{or the end of}} a function while editing a programming file or commands to validate documents or insert closing tags while working with markup languages such as XML.|$|R
5000|$|XEmacs {{text-editing}} features {{commands to}} manipulate words and paragraphs (deleting them, moving them, moving through them, and so forth), syntax highlighting for making source code easier to read, and [...] "keyboard macros" [...] for performing arbitrary batches of <b>editing</b> <b>commands</b> {{defined by the}} user.|$|R
5000|$|Edlin {{is a line}} editor, and {{the only}} text editor {{provided}} with early versions of MS-DOS. Although superseded in MS-DOS 5.0 and later by the full-screen <b>edit</b> <b>command,</b> and by Notepad in Microsoft Windows, {{it continues to be}} included in the 32-bit versions of current Microsoft operating systems.|$|R
50|$|However, <b>edit</b> <b>commands</b> {{represent}} the equation differently and keyboard direction commands reflect this. Analogous to a filesystem hierarchy of files and folders within folders, each equation is {{represented as a}} Tree structure. Each equation in Ket is a tree of operations and functions (tree branches) and variables and values (tree leaves).|$|R
50|$|CRT-based editing terminals, {{which can}} work compatibly {{with a variety}} of {{phototypesetting}} machines, were a major technical innovation in this regard. Keyboarding the original text on a CRT screen, with easy-to-use <b>editing</b> <b>commands,</b> is faster than keyboarding on a Linotype machine. Storing the text magnetically for easy retrieval and subsequent editing also saves time.|$|R
5000|$|Protext was {{designed}} for speed and flexibility [...] and features the usual word processing features, such as a spell checker, thesaurus, auto-correction and good printer support. While later releases supported use of a mouse, the fastest editing with Protext would be using the keyboard, with all commonly used <b>editing</b> <b>commands</b> available with control key combinations.|$|R
30|$|In {{the next}} section we state the problem {{addressed}} in this work. Section  3 presents the I/O framework discussed in this paper. Section  4 provides a brief introduction to Clive and to its Go dialect as used in the examples that follow. Section  5 describes the Go I/O framework used in Clive. Section  6 provides examples of file processing commands using it. Sections  7, 8, and 9 introduce other examples for file <b>editing</b> <b>commands,</b> commands using non-linear pipelines, and user interfaces. Sections  10 and 11 describe the implementation and discuss some drawbacks and lessons learned. Sections  12 and 13 provide quantitative evaluation results and discuss related and further work.|$|R
50|$|Word {{processors}} typically {{require the}} use of special function keys to access <b>editing</b> <b>commands</b> as opposed to text entry. This proved to be a challenge on the TRS-80 Model I and Model III computers, as their keyboards had no non-typewriter modifier keys—not even a Control key. Instead, Tandy drafted the '@' key to access features such as margin control and load/save.|$|R
5000|$|The early screen {{modes of}} Emacs, for example, were {{directly}} inspired by WAITS' [...] "E" [...] editor -- {{one of a}} family of editors that were the first to do real-time editing, in which the <b>editing</b> <b>commands</b> were invisible and where one typed text at the point of insertion/overwriting. The modern style of multi-region windowing is said to have originated there.|$|R
3000|$|In editors such as Sam [10] {{a command}} {{language}} is provided {{to let the}} user write <b>editing</b> <b>commands.</b> In Clive, the ix editor does not include a command language, but uses plain system commands. This can be done because the I/O framework discussed in this paper permits data to have structure (although the system simply forwards messages without interpreting them, like UNIX would do.) [...]...|$|R
30|$|Document {{formatting}} {{systems like}} roff [23] use pipelines with different commands to process and filter document streams. They {{are similar in}} spirit to the approach used in Clive for processing I/O streams (at least for <b>editing</b> <b>commands).</b> Of course, roff like tools rely on conventions {{to be able to}} cooperate in a pipe-line more than they rely on the mechanisms provided by the underlying system, and they are specific-purpose tools.|$|R
50|$|A {{frequent}} {{application of}} quantization {{in this context}} lies within MIDI application software or hardware. MIDI sequencers typically include quantization in their manifest of <b>edit</b> <b>commands.</b> In this case, the dimensions of this timing grid are set beforehand. When one instructs the music application to quantize a certain group of MIDI notes in a song, the program moves each note to the closest point on the timing grid.|$|R
30|$|In {{the context}} of digital TV systems, we can {{intuitively}} see the influence of incremental validation in the conventional process of authoring, {{but this is not}} the only situation where such validation can offer performance gains. The fact that set-top boxes (device that executes interactive applications) are environments with limited computing resources raises the need for validation techniques that avoid redundant checks in such a limited hardware. A particular case of this need is the validation of applications created within the set-top box in TV viewers’ households (Social TV) [7], since this validation must be done without affecting performance. On the other hand, systems such as ISDB-Tb [4] allow broadcasters to send <b>editing</b> <b>commands</b> to applications while they are being displayed, allowing what is known as live editing of content [8]. Before applying such edits, first it is necessary to validate them in order to make sure that the <b>editing</b> <b>commands</b> will result in consistent, accurate and coherent documents. From the above discussion, we can notice that the need for incremental validation mechanisms is present in various circumstances.|$|R
40|$|The MTS Manual is {{a series}} of volumes that {{describe}} in detail the facilities provided by the Michigan Terminal System. The MTS file editor is used for editing MTS files. <b>Edit</b> <b>commands</b> perform the <b>editing</b> functions on the edit file. These functions fall into three general categories: (1) changing the contents of the file, (2) searching the file for a character string or set of character strings, and (3) setting global editor options and modifiers. ...|$|R
40|$|The Local Editing Protocol {{allows a}} local {{programmable}} terminal {{to execute the}} most common <b>editing</b> <b>commands</b> on behalf of an extensible text editor on a remote system, thus greatly improving speed of response without reducing flexibility. The Line Saving Protocol allows the local system to save text which is not displayed, and display it again later when it is needed, {{under the control of}} the remote editor. Both protocols are substantially system and editor independent...|$|R
50|$|Emacs is {{primarily}} a text editor and is designed for manipulating pieces of text, although {{it is capable of}} formatting and printing documents like a word processor by interfacing with external programs such as LaTeX, Ghostscript or a web browser. Emacs provides commands to manipulate and differentially display semantic units of text such as words, sentences, paragraphs and source code constructs such as functions. It also features keyboard macros for performing user-defined batches of <b>editing</b> <b>commands.</b>|$|R
40|$|Pegasus is a {{prototype}} drawing system for rapid geometric design. Using Pegasus, a user can construct precise geometric diagrams easily without struggling with complicated <b>editing</b> <b>commands.</b> Two novel interaction techniques are introduced: interactive beautification and predictive drawing. Interactive beautification receives the user's free stroke input and beautifies it by considering possible geometric constraints among segments by generating multiple candidates to prevent recognition errors. Predictive drawing predicts the user's next drawing operation {{based on the}} spatial relationship among existing segments on the screen...|$|R
