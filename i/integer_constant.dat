113|183|Public
25|$|A {{null pointer}} is a pointer in a {{computer}} program that does not point to any object or function. In C, the <b>integer</b> <b>constant</b> 0 is converted into the null pointer at compile time when it appears in a pointer context, and so 0 is a standard way {{to refer to the}} null pointer in code. However, the internal representation of the null pointer may be any bit pattern (possibly different values for different data types).|$|E
5000|$|As {{above in}} {{conjunction}} with a single [...] or comparison with an <b>integer</b> <b>constant</b> ...|$|E
5000|$|Let C be a pseudo-disks-set with n objects. The {{following}} local search algorithm finds a disjoint set of size {{at least}} [...] in time , for every <b>integer</b> <b>constant</b> : ...|$|E
5000|$|A residue {{numeral system}} {{is defined by}} a set of N <b>integer</b> <b>constants,</b> ...|$|R
5000|$|Here , [...] and [...] are <b>integer</b> <b>constants</b> and 4 and 8 are {{the lengths}} of the [...] "value" [...] fields, respectively.|$|R
5000|$|The header file also defines macros that {{expand to}} <b>integer</b> <b>constants</b> that {{represent}} the error codes. The C standard library only requires three to be defined: ...|$|R
50|$|There {{are only}} two {{integral}} constant types, integer and long. Other integral types appearing in the high-level language, such as boolean, byte, and short must be represented as an <b>integer</b> <b>constant.</b>|$|E
50|$|In Joy, {{everything}} is a function that takes a stack as an argument and returns a stack as a result. For instance, the numeral '5' does not represent an <b>integer</b> <b>constant,</b> but instead a short program that pushes the number 5 onto the stack.|$|E
5000|$|The {{generating}} {{function of a}} language L is a rational function if L is regular. [...] Hence for any regular language [...] there exist an <b>integer</b> <b>constant</b> , complex constants [...] and complex polynomials such that for every [...] the number [...] of words of length [...] in [...] is.|$|E
50|$|For cubes with unmarked centre cubies the {{following}} positive <b>integer</b> <b>constants</b> (represented by P, Q, R and S) apply. These constants {{are in agreement}} with figures frequently quoted for the size 3 and size 4 cubes.|$|R
5000|$|... are <b>integer</b> <b>constants</b> that {{specify the}} {{generator}}. If c = 0, the generator {{is often called}} a multiplicative congruential generator (MCG), or Lehmer RNG. If c ≠ 0, the method is called a mixed congruential generator.|$|R
50|$|These <b>integer</b> <b>constants</b> may be {{expressed}} as sums over Bernoulli numbers, as given in (Vepstas, 2006) below. A fast algorithm for {{the calculation of}} Riemann's zeta function for any integer argument is given by E. A. Karatsuba.|$|R
50|$|Within {{a single}} switch statement, the <b>integer</b> <b>constant</b> {{associated}} with each case label must be unique. There {{may or may not}} be a default statement. There is no restriction on the order of the labels within a switch. The requirement that case labels values evaluate to integer constants gives the compiler more room for optimizations.|$|E
5000|$|Insn. Stack Stack Description before after [...] adi i1 i2 i1+i2 add two {{integers}} adr r1 r2 r1+r2 add two reals dvi i1 i2 i1/i2 integer division inn i1 s1 b1 set membership; b1 = whether i1 is {{a member}} of s1 ldci i1 i1 load <b>integer</b> <b>constant</b> mov a1 a2 move not b1 ~b1 boolean negation ...|$|E
50|$|Some early {{programming}} languages did not originally have enumerated types. If {{a programmer}} wanted a variable, for example myColor, {{to have a}} value of red, the variable red would be declared and assigned some arbitrary value, usually an <b>integer</b> <b>constant.</b> The variable red would then be assigned to myColor. Other techniques assigned arbitrary values to strings containing {{the names of the}} enumerators.|$|E
5000|$|... where a and b {{are some}} <b>integer</b> <b>constants</b> and x is the index number of each prime {{factor in the}} factorization, sorted from lowest to highest. For the purpose of {{determining}} Zeisel numbers, [...] The first few Zeisel numbers are ...|$|R
40|$|Action Language Verifier (ALV) is an {{infinite}} state model checker which specializes on systems specified with linear arithmetic constraints on integer variables. An Action Language specification consists of integer, boolean and enumerated variables, param-eterized <b>integer</b> <b>constants</b> {{and a set}} of modules and actions which are composed us...|$|R
40|$|We {{prove that}} the Fourier {{matrices}} for the imprimitive complex reflection groups introduced by Malle define fusion algebras with not necessarily positive but <b>integer</b> structure <b>constants.</b> Hence they define Z-algebras. As a result, we obtain that all known Fourier matrices belonging to spetses define algebras with <b>integer</b> structure <b>constants.</b> Comment: 14 page...|$|R
5000|$|For {{each type}} [...] and each non-negative <b>integer</b> <b>constant</b> , {{there is an}} array type denoted arrays of differing lengths are thus of {{different}} types. Dynamic arrays are available as [...] "slices", denoted [...] for some type [...] These have a length and a capacity specifying when new memory needs to be allocated to expand the array. Several slices may share their underlying memory.|$|E
50|$|Delphi {{uses the}} Pascal-based {{programming}} language called Object Pascal introduced by Borland, and compiles Delphi source code into native x86 code. It includes VCL, support for COM independent interfaces with reference counted class implementations, {{and support for}} many third-party components. Interface implementations can be delegated to fields or properties of classes. Message handlers are implemented by tagging a method of a class with the <b>integer</b> <b>constant</b> of the message to handle.|$|E
50|$|A {{null pointer}} is a pointer in a {{computer}} program that does not point to any object or function. In C, the <b>integer</b> <b>constant</b> 0 is converted into the null pointer at compile time when it appears in a pointer context, and so 0 is a standard way {{to refer to the}} null pointer in code. However, the internal representation of the null pointer may be any bit pattern (possibly different values for different data types).|$|E
30|$|In Fig.  4, {{note that}} TAL {{selectors}} {{can be used}} in defining constraints, which makes the language more versatile. Usually, constraints are defined as logical sentences that result from comparing two expressions (possibly nested between parentheses), which can contain <b>integer</b> <b>constants,</b> cardinality of component and interface types, or the result of a selector clause.|$|R
40|$|We {{present and}} compare various algorithms, {{including}} a new one, allowing to perform multiplications by <b>integer</b> <b>constants</b> using elementary operations. Such algorithms are useful, as they occur in several problems, such as the Toom-Cook-like algorithms to multiply large multiple-precision integers, the approximate computation of consecutive values of a polynomial, and the generation of integer multiplications by compilers...|$|R
50|$|As for {{domains of}} reals, functors {{can be used}} with domains of integers. In this case, a term can be an {{expression}} over <b>integers,</b> a <b>constant,</b> or the application of a functor over other terms. A variable can take an arbitrary term as a value, if its domain has not been specified to be a set of <b>integers</b> or <b>constants.</b>|$|R
50|$|The grammar's {{terminal}} {{symbols are}} the multi-character symbols or 'tokens' {{found in the}} input stream by a lexical scanner. Here these include = + * and int for any <b>integer</b> <b>constant,</b> and id for any identifier name. The grammar doesn't care what the int values or id spellings are, nor does it care about blanks or line breaks. The grammar uses these terminal symbols but does not define them. They are always at the bottom bushy end of the parse tree.|$|E
50|$|The grammar's {{terminal}} {{symbols are}} the multi-character symbols or 'tokens' {{found in the}} input stream by a lexical scanner. Here these include + * and int for any <b>integer</b> <b>constant,</b> and id for any identifier name, and eof for end of input file. The grammar doesn't care what the int values or id spellings are, nor does it care about blanks or line breaks. The grammar uses these terminal symbols but does not define them. They are always leaf nodes (at the bottom bushy end) of the parse tree.|$|E
5000|$|Two {{types of}} labels {{can be put}} in a switch statement. A case label {{consists}} of the keyword , followed by an expression that evaluates to <b>integer</b> <b>constant.</b> A default label consists of the keyword [...] Case labels are used to associate an integer value with a statement in the code. When a switch statement is reached, program execution continues with the statement after the case label with value that matches the value in the parentheses of the switch. If there is no such case label, but there is a default label, program execution continues with the statement after the default label. If there is no default label, program execution continues after the switch.|$|E
40|$|AbstractWe {{prove that}} the Fourier {{matrices}} for the imprimitive complex reflection groups introduced by Malle in [Gunter Malle, Unipotente Grade imprimitiver komplexer Spiegelungsgruppen, J. Algebra 177 (3) (1995) 768 – 826] define fusion algebras with not necessarily positive but <b>integer</b> structure <b>constants.</b> Hence they define Z-algebras. As a result, we obtain that all known Fourier matrices belonging to spetses define algebras with <b>integer</b> structure <b>constants...</b>|$|R
5000|$|Here, [...] is {{the kind}} type parameter; {{it can also be}} an {{explicit}} default <b>integer</b> literal <b>constant,</b> like ...|$|R
40|$|Abstract: We {{present and}} compare various algorithms, {{including}} a new one, allowing to perform multiplications by <b>integer</b> <b>constants</b> using elementary operations. Such algorithms are useful, as they occur in several problems, such as the Toom-Cook-like algorithms to multiply large multiple-precision integers, the approximate computation of consecutive values of a polynomial, and the generation of integer multiplications by compilers. Key-words: integer multiplication, addition chains Unité de recherche INRIA Lorrain...|$|R
50|$|Floating-point {{constants}} may {{be written}} in decimal notation, e.g. 1.23. Decimal scientific notation may be used by adding e or E followed by a decimal exponent, also known as E notation, e.g. 1.23e2 (which has the value 1.23 × 102 = 123.0). Either a decimal point or an exponent is required (otherwise, the number is parsed as an <b>integer</b> <b>constant).</b> Hexadecimal floating-point constants follow similar rules, except {{that they must be}} prefixed by 0x and use p or P to specify a binary exponent, e.g. 0xAp-2 (which has the value 2.5, since Ah × 2−2 = 10 × 2−2 = 10 ÷ 4). Both, decimal and hexadecimal floating-point constants may be suffixed by f or F to indicate a constant of type float, by l (letter l) or L to indicate type long double, or left unsuffixed for a double constant.|$|E
5000|$|Integer {{constants}} may be {{specified in}} source code in several ways. Numeric values {{can be specified}} as decimal (example: 1022), octal with zero (0) as a prefix (01776), or hexadecimal with 0x (zero x) as a prefix (0x3FE). A character in single quotes (example: 'R'), called a [...] "character constant," [...] represents the value of that character in the execution character set, with type int. Except for character constants, the type of an <b>integer</b> <b>constant</b> {{is determined by the}} width required to represent the specified value, but is always at least as wide as int. This can be overridden by appending an explicit length and/or signedness modifier; for example, 12lu has type unsigned long. There are no negative integer constants, but the same effect can often be obtained by using a unary negation operator [...] "-".|$|E
5000|$|For {{a typical}} {{instruction}} like [...] "Add," [...] the computer takes both operands from the topmost (most recent) {{values of the}} stack. The computer replaces those two values by the sum, calculated by the computer when it performs the [...] "Add" [...] instruction. The instruction's operands are 'popped' off the stack, and its result(s) are then 'pushed' back onto the stack, {{ready for the next}} instruction. Most stack instructions have only an opcode commanding an operation, with no additional fields to identify a constant, register or memory cell. The stack easily holds more than two inputs or more than one result, so a richer set of operations can be computed. <b>Integer</b> <b>constant</b> operands are often pushed by separate Load Immediate instructions. Memory is often accessed by separate Load or Store instructions containing a memory address or calculating the address from values in the stack.|$|E
5000|$|In mathematics, an {{algebraic}} expression {{is an expression}} built up from <b>integer</b> <b>constants,</b> variables, and the algebraic operations (addition, subtraction, multiplication, division and exponentiation by an exponent that is a rational number). For example, [...] is an {{algebraic expression}}. Since taking the square root {{is the same as}} raising to the power ,is also an algebraic expression. By contrast, transcendental numbers like π and e are not algebraic.|$|R
40|$|Exact array {{dataflow}} {{analysis can}} be achieved in the general case if the only control structures are do-loops and structural ifs, and if loop counter bounds and array subscripts are affine expressions of englobing loop counters and possibly some <b>integer</b> <b>constants.</b> In this paper, we begin the study of dataflow analysis of dynamic control programs, where arbitrary ifs and whiles are allowed. In the general case, this dataflow analysis can only be fuzzy...|$|R
40|$|We {{study the}} problem of {{minimizing}} the supremum norm, on {{a segment of the}} real line or on a compact set in the plane, by polynomials with integer coefficients. The extremal polynomials are naturally called integer Chebyshev polynomials. Their factors, zero distribution and asymptotics are the main subjects of this paper. In particular, we show that the integer Chebyshev polynomials for any infinite subset of the real line must have infinitely many distinct factors, which answers a question of Borwein and Erdélyi. Furthermore, it is proved that the accumulation set for their zeros must be of positive capacity in this case. We also find the first nontrivial examples of explicit <b>integer</b> Chebyshev <b>constants</b> for certain classes of lemniscates. Since it is rarely possible to obtain an exact value of <b>integer</b> Chebyshev <b>constant,</b> good estimates are of special importance. Introducing the methods of weighted potential theory, we generalize and improve the Hilbert-Fekete upper bound for <b>integer</b> Chebyshev <b>constant.</b> These methods also give bounds for the multiplicities of factors of integer Chebyshev polynomials, and lower bounds for <b>integer</b> Chebyshev <b>constant.</b> Moreover, all the mentioned bounds can be found numerically, by using various extremal point techniques, such as weighted Leja points algorithm. Applying our results in the classical case of the segment [0, 1], we improve the known bounds for the <b>integer</b> Chebyshev <b>constant</b> and the multiplicities of factors of the integer Chebyshev polynomials. Comment: 35 pages, 1 figur...|$|R
