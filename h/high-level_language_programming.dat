10|10000|Public
40|$|Abstract — While the {{computational}} {{power of}} Field Programmable Gate Arrays (FPGA) makes them attractive as code accelerators, {{the lack of}} <b>high-level</b> <b>language</b> <b>programming</b> tools is a major obstacle to their wider use. Graphics Processing Units (GPUs), on the other hand, have benefitted from advanced and widely used high-level programming tools. This paper evaluates the performance, throughput and energy of both FPGAs and GPUs on image processing codes using <b>high-level</b> <b>language</b> <b>programming</b> tools for both. I...|$|E
40|$|Many {{science and}} {{engineering}} students at university receive some elementary <b>high-level</b> <b>language</b> <b>programming</b> training {{at an early stage}} in their studies. However, few of them get any experience in using other techniques that are in common use in industrial software development and which are generally referred to as software engineering. This paper describes the aims, the content and the results of presenting an intensive two-week software engineering course prepared in industry and given to third-year students in the Department of Applied Physics at the University of Strathclyde...|$|E
40|$|IBM Thomas J. Watson Research Center. It {{consists}} of a running hardware prototype, a control program, and an optimizing compiler. The basic concepts underlying the system are discussed, as are the performance characteristics of the prototype. In particular, three principles are examined: (1) system orientation towards the pervasive use of <b>high-level</b> <b>language</b> <b>programming</b> and a sophisticated compiler, (2) a primitive instruction set which can be completely hard-wired, and (3) storage hierarchy and I 10 organization to enable the CPU to execute an instruction at almost every cycle...|$|E
5000|$|A source-to-source {{compiler}} {{is a type}} of compiler {{that takes}} a <b>high-level</b> <b>language</b> as its input and outputs a <b>high-level</b> <b>language.</b> For example, an automatic parallelizing compiler will frequently take in a <b>high-level</b> <b>language</b> <b>program</b> as an input and then transform the code and annotate it with parallel code annotations (e.g. OpenMP) or language constructs (e.g. Fortran's [...] statements).|$|R
40|$|Program {{refinement}} usually translates {{an abstract}} specification to a <b>high-level</b> <b>language</b> <b>program.</b> However, this {{process can be}} taken further by refining a <b>high-level</b> <b>language</b> `specification' to an assembler code `implementation'. It is shown how {{this can be done}} in the familiar refinement calculus framework. Several derived refinement rules for modelling program compilation are presented...|$|R
50|$|IBM {{operating}} systems descended from OS/360 and DOS/360, including z/OS and z/VSE, implement system calls through {{a library of}} assembly language macros. This reflects their origin {{at a time when}} <b>programming</b> in assembly <b>language</b> was more common than <b>high-level</b> <b>language</b> usage. IBM system calls are therefore not directly executable by <b>high-level</b> <b>language</b> <b>programs,</b> but require a callable assembly language wrapper subroutine.|$|R
40|$|Abstract:- The {{trend in}} {{programmable}} architectures for {{digital signal processing}} (DSP) is to move towards <b>high-level</b> <b>language</b> <b>programming,</b> which sets high requirements for compilers to efficiently exploit the instruction level parallelism in modern processors. In this paper, efficiency of transport triggered architectures (TTA) in DSP applications is discussed. The efficiency of a high-level compiler on a TTA is compared to commercial very long instruction word DSP architecture. The effect of different coding styles in high-level language code is evaluated with a DSP benchmark, fast Fourier transform. Key-Words:- transport triggered architecture, customizable processor architecture, digital signal processing, fast fourier transform, coding style, performance evaluation...|$|E
40|$|The {{trend in}} {{programmable}} architectures for {{digital signal processing}} is to move towards <b>high-level</b> <b>language</b> <b>programming</b> and customizable architectures. Several design methodologies have been proposed for designing application-specific instruction-set processors (ASIP) where the hardware resources are tailored {{according to the requirements}} of the application. This paper describes the design of an ASIP for a 32 -point discrete cosine transform using the tools from the MOVE framework, which is a semi-automatic design methodology for designing processors that utilize the paradigm of transport triggered architecture. Estimations of the designed processor are obtained on program execution, code size, timing and area. I...|$|E
40|$|This paper {{presents}} a pipeline synthesis and optimization technique for <b>high-level</b> <b>language</b> <b>programming</b> of reconfigurable Custom Computing Machines. The circuit synthesis generates hardware accelerators from a sequential program which exploit the reconfigurable hardware's parallelism. Program loops are transformed to structural hardware specifications. The optimization algorithm uses integer linear programming to balance and pipeline the circuit's registers. This global optimization determines the minimal amount of flip-flops necessary for an optimal pipeline throughput. It also considers the irregular flip-flop distribution on FPGAs. Standard interface circuitry and a runtime system provide {{the connection between}} the accelerator unit and its host computer. An integrated compiler invokes the synthesis and produces a program which downloads, calls and controls its hardware accelerators automatically. 1 Introduction Reconfigurable Custom Computing Machines (CCMs) have proven useful for [...] ...|$|E
40|$|Course Contents To learn {{computer}} architecture concepts and mechanisms {{related to the}} design of modern processors, memories, and I/O devices and to explain how these concepts and mechanisms interact To understand how a <b>high-level</b> <b>language</b> <b>program</b> is actually executed on a processor, and how architecture could influence progra...|$|R
40|$|This paper {{presents}} {{a case study}} in verified <b>program</b> compilation from <b>high-level</b> <b>language</b> <b>programs</b> to assembler code using the Cogito formal development system. A form of window-inference based on the Z schema is used to perform the compilation. Data-refinement is used to change the representation of integer variables to assembler word locations...|$|R
50|$|<b>High-level</b> <b>language</b> <b>{{programs}}</b> require OCL to be activated. OCL {{is used to}} load programs {{into the}} system's memory and start them (a process called execution) and assign resources such as disk files, printers, message members, memory, and disk space to those programs. Other abilities, such as displaying text on the screen, pause messages, and so forth, make OCL more powerful.|$|R
40|$|Abstract – The {{increasing}} use of programmable processors as IP {{blocks in}} embedded system design creates a need for C/C++ compilers capable of generating efficient machine code. Many of today’s compilers for embedded processors suffer from insufficient code quality in terms of code size and performance. This violates the tight chip area and realtime constraints often imposed on embedded systems. The reason is that embedded processors typically show architectural features which are not well handled by classical compiler technology. This paper provides a survey of methods and techniques dedicated to efficient code generation for embedded processors. Emphasis is put on DSP and multimedia processors, for which better compiler technology is definitely required. In addition, some frontend aspects and recent trends in research and industry are briefly covered. The goal of these recent efforts in embedded code generation is to facilitate the step from assembly to <b>high-level</b> <b>language</b> <b>programming</b> of embedded systems, so as to provide higher productivity, dependability, and portability of embedded software 1. ...|$|E
40|$|Although {{hardware}} description languages (HDL) {{are becoming}} more and more necessary to automated design systems, their application is complicated due to the difficulty in translating the HDL description into an implementable format, nonfamiliarity of hardware designers with <b>high-level</b> <b>language</b> <b>programming,</b> nonuniform design methodologies and the time and costs involved in transfering HDL design software. Digital design language (DDL) suffers from all of the above problems and in addition can only by synthesized on a complete system and not on its subparts, making it unsuitable for synthesis using standard modules or prefabricated chips such as those required in LSI or VLSI circuits. The present paper presents a method by which the DDL translator can be made to generate modular equations that will allow the system to be synthesized as an interconnection of lower-level modules. The method involves the introduction of a new language construct called a Module which provides for the separate translation of all equations bounded by it...|$|E
40|$|Only {{recently}} have methodical tools adequate to design real-time systems been formally introduced in design methodologies. Naturally, they were present fromthe beginning, {{but due to}} the large diversity of embedded systemsć areas of deployment, specially dedicated formalisms have been developed and used. <b>High-level</b> <b>language</b> <b>programming</b> and integration of modeling formalisms into design methods eased {{the development of more}} complex real-time applications. With the emerging object-oriented programming languages and design methods, their integration into larger information systems has become more transparent. It was the UML methodology, however, which eventually merged also the design methods and concepts of real-time systems into a consistent whole. It took a large consortium and a long process to persuade industry of the benefits the new integral methodology can offer. On the other hand, there are some trade-offs, and there are some features not completely covered, yet. Here, a different, more straightforward approach to program and design (embedded) real-time systems is presented. Since it emerged from the real-time community, it includes most features relevant there. Independent of the UML profile for schedulability, performance and time specification, a profile was devised for use in PEARL-oriented UML design. The strengths of the mentioned language and design methods for QoS-oriented design of (embedded) real-time systems are emphasised throughout this article...|$|E
40|$|AbstractProgram {{compilation}} can be formally {{defined as}} a sequence of equivalence-preserving transformations, or refinements, from <b>high-level</b> <b>language</b> <b>programs</b> to assembler code. Recent models also incorporate timing properties, but the resulting formalisms are intimidatingly complex. Here we {{take advantage of a}} new, simple model of real-time refinement, based on predicate transformer semantics, to present a straightforward compilation formalism that incorporates real-time constraints...|$|R
50|$|Tools such as <b>high-level</b> <b>programming</b> <b>languages,</b> {{object-oriented}} <b>programming</b> <b>languages,</b> {{and techniques}} such as programming in the large, code refactoring and test-driven development, exist {{to make it easier}} to maintain large, complicated programs.|$|R
50|$|The first <b>high-level</b> <b>programming</b> <b>languages,</b> or third-generation <b>programming</b> <b>languages</b> (3GL), {{were written}} in the 1950s. An early <b>high-level</b> <b>programming</b> <b>language</b> to be {{designed}} for a computer was Plankalkül, developed for the German Z3 by Konrad Zuse between 1943 and 1945. However, it was not implemented until 1998 and 2000.|$|R
40|$|International Telemetering Conference Proceedings / October 30 -November 02, 1989 / Town & Country Hotel & Convention Center, San Diego, CaliforniaThe {{difficulty}} of incorporating custom real-time processing into a conventional telemetry system frustrates many design engineers. Custom algorithms such as data compression/conversion, software decommutation, signal processing or sensitive defense related algorithms, are often executed on expensive and time-consuming mainframe computers during post-processing. The cost to implement such algorithms on real-time hardware is greater, because programming for such hardware is usually done in assembly language or microcode, resulting in: * The need for specially trained software specialists * Long and often unpredictable development time * Poor maintainability * Non-portability to new applications or hardware. This paper presents {{an alternative to}} host-based, post-processing telemetry systems. The Loral System 500 offers an easy to use, <b>high-level</b> <b>language</b> <b>programming</b> environment that couples real-time performance with fast development time, portability and easy maintenance. Targeted to Weltek's XL-Serles 32 and 64 bit floating point processors, delivering 20 MFLOPS peak performance, the environment transparently integrates the C programming environment with a parallel date-flow telemetry processing architecture. Supporting automatic human interface generation, symbolic high-level debugging and a complete floating point math library the System 500 programming environment extends to parallel execution transparently. It handles process scheduling, memory management and data conversion automatically. Configured to run under UNIX, the system's development environment is powerful and portable. The platform can be migrated to PC's and other hosts, facilitating eventual integration {{with an array of}} standard off-the-shelf tools...|$|E
40|$|The {{purpose of}} this {{research}} was to investigate the generation of machine code from <b>high-level</b> <b>programming</b> <b>language.</b> The following steps were undertaken: 1) Choose a <b>high-level</b> <b>programming</b> <b>language</b> as the source language and a computer as the target computer. 2) Examine all stages during the compiling of a <b>high-level</b> <b>programming</b> <b>language</b> and all data sets involved in the compilation. 3) Discover the mechanism for generating machine code and the mechanism to generate more efficient machine code from the language. 3) Construct an algorithm for generating machine code for the target computer. The results suggest that compiler is best implemented in a <b>high-level</b> <b>programming</b> <b>language,</b> and that SCANNER and PARSER should be independent of target representations, if possible...|$|R
50|$|Very <b>high-level</b> <b>programming</b> <b>languages</b> {{are usually}} domain-{{specific}} languages, {{limited to a}} very specific application, purpose, or type of task, and they are often scripting languages (especially extension languages), controlling a specific environment. For this reason, very <b>high-level</b> <b>programming</b> <b>languages</b> are {{often referred to as}} goal-oriented <b>programming</b> <b>languages.</b>|$|R
40|$|<b>High-level</b> <b>language</b> <b>program</b> {{compilation}} {{strategies can}} be proven correct by modelling {{the process as}} a series of refinement steps from source code to a machine-level description. We show how this can be done for programs containing recursively-defined procedures in the well-established predicate transformer semantics for refinement. To do so the formalism is extended with an abstraction of the way stack frames are created at run time for procedure parameters and variables...|$|R
5000|$|All display formats have {{exactly one}} coded S specification, which {{describes}} {{the size of}} the format, the keys which may be used, the lines to be cleared, special functions such as sounding the Alarm (the [...] "raspberry" [...] sound is the only sound a S/3X terminal can be programmed to make), and most importantly the name of the format which must be referenced by the HLL (<b>High-Level</b> <b>Language)</b> <b>program.</b>|$|R
40|$|We {{show how}} {{compilation}} of <b>high-level</b> <b>language</b> <b>programs</b> to assembler code can be formally {{represented in the}} refinement calculus. New operators are introduced to widen the modelling language to encompass assembler code. A compilation strategy is then embodied {{as a set of}} derived refinement rules. 1 Introduction The idea of modelling program compilation as a formal development procedure has surfaced many times in the literature, but has presented a significant challenge. This has resulted in complex models, often using new, unfamiliar formalisms. Our goal is to develop a model of program compilation within the alreadyfamiliar refinement calculus. Normally the refinement calculus translates an abstract requirements specification into a <b>programming</b> <b>language</b> implementation, using guarded command language augmented with specification statements as the underlying modelling notation. In the context of compilation, however, our `specification' is a <b>high-level</b> <b>language</b> (HLL) <b>program,</b> an [...] ...|$|R
5000|$|... "When {{the field}} of {{compiling}} {{began in the late}} 50s, its focus was limited to the translation of <b>high-level</b> <b>language</b> <b>programs</b> into machine code ... The compiler field is increasingly intertwined with other disciplines including computer architecture, <b>programming</b> <b>languages,</b> formal methods, software engineering, and computer security." [...] The [...] "Compiler Research: The Next 50 Years" [...] article noted the importance of object oriented languages and Java. Security and parallel computing were cited among the future research targets.|$|R
50|$|The 2900 {{architecture}} {{supports a}} hardware-based call stack, providing an efficient vehicle for executing <b>high-level</b> <b>language</b> <b>programs,</b> especially those allowing recursive function calls. This was a forward-looking decision at the time, {{since it was}} expected that the dominant <b>programming</b> <b>languages</b> would initially be COBOL and FORTRAN. The architecture provides built-in mechanisms for making procedure calls using the stack, and special purpose registers for addressing the top of the stack and the base of the current stack frame.|$|R
40|$|Abstract. <b>High-level</b> <b>language</b> <b>program</b> {{compilation}} {{strategies can}} be proven correct by modelling {{the process as}} a series of refinement steps from source code to a machine-level description. We show how this can be done for programs containing recursively-defined procedures in the well-established predicate transformer semantics for refinement. To do so the formalism is extended with an abstraction of the way stack frames are created at run time for procedure parameters and variables...|$|R
40|$|This {{document}} {{describes a}} proposed approach to compiling <b>high-level</b> <b>language</b> <b>programs</b> to the Rapid configurable architecture. Since the general version of Rapid very broad, this approach should {{be applicable to}} a wide range of coarse-grained configurable architectures. The compiler is comprised of a standard compiler front-end and a backend scheduler based on a simultaneous place and route formulation of the problem. This will allow the many constraints of a configurable architecture to be solved simultaneously...|$|R
40|$|Quartz is {{a formal}} {{software}} development method for concurrent real-time systems, currently being devised by the Software Verification Research Centre. It {{is a program}} refinement theory that supports systematic production of verified real-time code from a formal specification. Its model encompasses {{a broad range of}} development steps from abstract requirements specification, through <b>high-level</b> <b>language</b> <b>programs,</b> down to executable assembler code with verified timing behaviour. This article illustrates the method via a detailed case study...|$|R
50|$|Early {{operating}} system and systems software {{were written in}} assembly language. In the 60s and early 70s, <b>high-level</b> <b>languages</b> for system <b>programming</b> was still controversial due to resource limitations. Still several research and industry efforts began the shift toward <b>high-level</b> systems <b>programming</b> <b>languages,</b> for example, BCPL, Bliss, B, and C.|$|R
5000|$|Hardware {{designed}} to exclusively support <b>high-level</b> <b>programming</b> <b>languages</b> ...|$|R
5000|$|<b>High-level</b> <b>programming</b> <b>languages</b> usually include {{specific}} constructs to: ...|$|R
5000|$|Cg, a <b>high-level</b> shading <b>language</b> for <b>programming</b> vertex and pixel shaders ...|$|R
50|$|The *Lisp (aka StarLisp) <b>programming</b> <b>language</b> was {{conceived}} of in 1985 by Cliff Lasser and Steve Omohundro (employees of the Thinking Machines Corporation) {{as a way}} of providing an efficient yet <b>high-level</b> <b>language</b> for <b>programming</b> the nascent Connection Machine.|$|R
5000|$|Autocode - one of {{the first}} <b>high-level</b> <b>programming</b> <b>languages</b> (1961) ...|$|R
5000|$|Not eXactly C: (NXC), an {{open-source}} C-like <b>high-level</b> <b>programming</b> <b>language,</b> ...|$|R
