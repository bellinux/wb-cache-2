1964|541|Public
5|$|Age of Mythology: The Titans lets players use an AI <b>debugger</b> when {{creating}} custom scenarios; {{players can}} change the settings of computer players and make them act according to certain patterns. More basic changes to the AI had previously been available in the series' first two games.|$|E
5|$|In May 2008, it was {{revealed}} that a Debian developer discovered that the OpenSSL package distributed with Debian and derivatives such as Ubuntu, made a variety of security keys vulnerable to a random number generator attack, since only 32,767 different keys were generated. The security weakness was caused by changes made in 2006 by another Debian developer in response to memory <b>debugger</b> warnings. The complete resolution procedure was cumbersome because patching the security hole was not enough; it involved regenerating all affected keys and certificates.|$|E
5|$|Like {{the other}} BSD kernels (and those of most modern {{operating}} systems), DragonFly employs a built-in kernel <b>debugger</b> {{to help the}} developers find kernel bugs. Furthermore, , a debug kernel, which makes bug reports more useful for tracking down kernel-related problems, is installed by default, {{at the expense of}} a relatively small quantity of disk space. When a new kernel is installed, the backup copy of the previous kernel and its modules are stripped of their debugging symbols to further minimize disk space usage.|$|E
50|$|DDT {{is closely}} related to ODT. Both names were used for several {{different}} <b>debuggers,</b> but generally <b>debuggers</b> with the ODT name had more limited capabilities than DDT <b>debuggers.</b>|$|R
5000|$|Some <b>debuggers</b> {{include a}} feature called [...] "reverse debugging", {{also known as}} [...] "historical debugging" [...] or [...] "backwards debugging". These <b>debuggers</b> make it {{possible}} to step a program's execution backwards in time. Various <b>debuggers</b> include this feature. Microsoft Visual Studio (2010 Ultimate edition, 2012 Ultimate, 2013 Ultimate, and 2015 Enterprise edition) offers IntelliTrace reverse debugging for C#, Visual Basic [...]NET, and some other languages, but not C++. Reverse <b>debuggers</b> also exist for C, C++, Java, Python, Perl, and other languages. Some are open source; some are proprietary commercial software. Some reverse <b>debuggers</b> slow down the target by orders of magnitude, but the best reverse <b>debuggers</b> cause a slowdown of 2× or less. Reverse debugging is very useful for certain types of problems, but is still not commonly used yet.|$|R
40|$|We propose two {{declarative}} <b>debuggers</b> {{of missing}} answers {{with respect to}} C- and S-semantics. The <b>debuggers</b> are proved correct for every logic program. Moreover, they are complete and terminating {{with respect to a}} large class of programs, namely acceptable logic programs. The <b>debuggers</b> enhance existing proposals, which suffer from a problem due to the implementation of negation as failure. The proposed solution exploits decision procedures for C- and S-semantics introduced in [9]...|$|R
5|$|Python {{has been}} {{successfully}} embedded in many software products as a scripting language, including in finite element method software such as Abaqus, 3D parametric modeler like FreeCAD, 3D animation packages such as 3ds Max, Blender, Cinema 4D, Lightwave, Houdini, Maya, modo, MotionBuilder, Softimage, the visual effects compositor Nuke, 2D imaging programs like GIMP, Inkscape, Scribus and Paint Shop Pro, and musical notation programs like scorewriter and capella. GNU <b>Debugger</b> uses Python as a pretty printer to show complex structures such as C++ containers. Esri promotes Python as {{the best choice for}} writing scripts in ArcGIS. It has also been used in several video games, and has been adopted as first of the three available programming languages in Google App Engine, the other two being Java and Go. Python is also used in algorithmic trading and quantitative finance. Python can also be implemented in APIs of online brokerages that run on other languages by using wrappers.|$|E
25|$|Remote {{debugging}} is {{the process}} of debugging a program running on a system different from the <b>debugger.</b> To start remote debugging, a <b>debugger</b> connects to a remote system over a network. The <b>debugger</b> can then control the execution of the program on the remote system and retrieve information about its state.|$|E
25|$|In {{comparison}} to Internet Explorer, Firefox {{has a more}} comprehensive set of developer tools, which include a <b>debugger</b> as well. Old versions of Firefox without these tools used a Firefox addon called Firebug, or the older Venkman <b>debugger.</b> Also, WebKit's Web Inspector includes a JavaScript <b>debugger,</b> which is used in Safari. A modified version called Blink DevTools is used in Google Chrome. Node.js has Node Inspector, an interactive <b>debugger</b> that integrates with the Blink DevTools, available in Google Chrome. Opera includes a set of tools called Dragonfly.|$|E
40|$|Predictions from {{simulations}} with inherent uncertainty {{have entered}} the mainstream of public policy decisionmaking practices. Unfortunately, methods for gaining insight into unexpected simulation outcomes have not kept pace. Subject matter experts (SMEs) need to understand if the unexpected outcomes reflect a fault in the simulation or new knowledge. Recent work has adapted statistical <b>debuggers,</b> used in software engineering, to automatically identify simulation faults via extensive profiling of executions. The adapted <b>debuggers</b> {{have been shown to}} be effective, but have only been applied to simulations with large test suites and known faults. Here we employ these <b>debuggers</b> in a different manner. We investigate how they facilitate a SME exploring an unexpected outcome that reflects new knowledge. We also evaluate the <b>debuggers</b> in the face of smaller test suites and sparse execution profiling. These novel applications and evaluations show that these <b>debuggers</b> are more effective and robust than previously realized. ...|$|R
50|$|Debuggers: Debugger#List of <b>debuggers.</b> See also Debugging.|$|R
50|$|Software <b>debuggers</b> {{that run}} on a second computer.|$|R
25|$|Visual Studio {{includes}} a <b>debugger</b> that works {{both as a}} source-level <b>debugger</b> and as a machine-level <b>debugger.</b> It works with both managed code as well as native code {{and can be used}} for debugging applications written in any language supported by Visual Studio. In addition, it can also attach to running processes and monitor and debug those processes. If source code for the running process is available, it displays the code as it is being run. If source code is not available, it can show the disassembly. The Visual Studio <b>debugger</b> can also create memory dumps as well as load them later for debugging. Multi-threaded programs are also supported. The <b>debugger</b> can be configured to be launched when an application running outside the Visual Studio environment crashes.|$|E
25|$|Within JavaScript, {{access to}} a <b>debugger</b> becomes {{invaluable}} when developing large, non-trivial programs. Because there can be implementation differences between the various browsers (particularly within the DOM), {{it is useful to}} have {{access to a}} <b>debugger</b> for each of the browsers that a Web application targets.|$|E
25|$|Visual Studio {{includes}} a code editor supporting IntelliSense (the code completion component) {{as well as}} code refactoring. The integrated <b>debugger</b> works both as a source-level <b>debugger</b> and a machine-level <b>debugger.</b> Other built-in tools include a code profiler, forms designer for building GUI applications, web designer, class designer, and database schema designer. It accepts plug-ins that enhance the functionality at almost every level—including adding support for source control systems (like Subversion) and adding new toolsets like editors and visual designers for domain-specific languages or toolsets for {{other aspects of the}} software development lifecycle (like the Team Foundation Server client: Team Explorer).|$|E
5000|$|Compatible with GNU/gcc tool {{chain and}} popular {{third-party}} <b>debuggers</b> ...|$|R
5000|$|Earlier Mainframe <b>debuggers</b> include (in date {{of release}} order): ...|$|R
5000|$|From the Silent <b>Debuggers</b> Game Manual, NEC Technologies - 1991 ...|$|R
25|$|Stallman was {{responsible}} for contributing many necessary tools, including a text editor (Emacs), compiler (GCC), <b>debugger</b> (GNU <b>Debugger),</b> and a build automator (GNU make). The notable omission was a kernel. In 1990, members of the GNU project began using Carnegie Mellon's Mach microkernel in a project called GNU Hurd, which has yet to achieve the maturity level required for full POSIX compliance.|$|E
25|$|The Lisp REPL {{typically}} {{also provides}} input editing, an input history, error handling and an interface to the <b>debugger.</b>|$|E
25|$|Enhanced debugging: The <b>debugger</b> now {{supports}} debugging workflows, remote script {{execution and}} preserving debugging sessions across PowerShell session reconnections.|$|E
5000|$|... 64-bit {{releases}} do {{not support}} Spectrum Digital XDS510USB JTAG <b>debuggers.</b>|$|R
40|$|This paper {{presents}} a taxonomy of parallel and distributed <b>debuggers</b> based on execution replay. Programming of distributed and parallel systems {{is a complex}} task. Amongst the many factors contributing to this complexity, the nondeterminacy of these systems is an important one. Execution replay is a technique developed to facilitate the debugging of nondeterministic programs. Execution replay has very broad applications and not every algorithm is applicable in every situation. This taxonomy provides a precise classification of replay <b>debuggers</b> using nine criteria. From this classification, {{it is easier to}} determine a <b>debugger's</b> scope of application, outline its strengths and weaknesses and compare it with others. This taxonomy is illustrated and validated using a collection of existing replay <b>debuggers.</b> Keywords: debugging, nondeterminism, execution replay 1 Introduction It is well known that programming of distributed and parallel applications is a complex task. Furthermore, very few [...] ...|$|R
40|$|Transactional Memory (TM) has {{received}} a lot of attention as a programming API for concurrent programs on emerging multicore architectures. If the transactional programming model is to realize its promise of simplifying the problem of writing correct and scalable concurrent programs, <b>debuggers</b> will have to change. In this paper, we introduce tm db, an open-source library to provide <b>debuggers</b> with a general debugging support for transactional programs. The library helps <b>debuggers</b> provide programmers with generic transactional debugging features, independent of the particular TM’s runtime internals. In addition, it provides TM designers with a well defined interface for transactional debugging support...|$|R
25|$|Often systems {{programs}} cannot be {{run in a}} <b>debugger.</b> Running the program in a simulated environment can sometimes be used to reduce this problem.|$|E
25|$|The <b>debugger</b> allows setting {{breakpoints}} (which allow execution to {{be stopped}} temporarily at a certain position) and watches (which monitor the values of variables as the execution progresses). Breakpoints can be conditional, meaning they get triggered when the condition is met. Code can be stepped over, i.e., run one line (of source code) at a time. It can either step into functions to debug inside it, or step over it, i.e., {{the execution of the}} function body isn't available for manual inspection. The <b>debugger</b> supports Edit and Continue, i.e., it allows code to be edited as it is being debugged. When debugging, if the mouse pointer hovers over any variable, its current value is displayed in a tooltip ("data tooltips"), where it can also be modified if desired. During coding, the Visual Studio <b>debugger</b> lets certain functions be invoked manually from the Immediate tool window. The parameters to the method are supplied at the Immediate window.|$|E
25|$|AMD {{develops}} the AMD CodeXL tool suite {{which includes a}} GPU <b>debugger,</b> a GPU profiler, a CPU profiler and an OpenCL static kernel analyzer. CodeXL is freely available at AMD developer tools website.|$|E
50|$|Typically, <b>debuggers</b> offer a query processor, {{a symbol}} resolver, an {{expression}} interpreter, and a debug support interface at its top level. <b>Debuggers</b> also offer more sophisticated {{functions such as}} running a program step by step (single-stepping or program animation), stopping (breaking) (pausing the program to examine the current state) at some event or specified instruction {{by means of a}} breakpoint, and tracking the values of variables. Some <b>debuggers</b> have the ability to modify program state while it is running. It may also be possible to continue execution at a different location in the program to bypass a crash or logical error.|$|R
2500|$|... http://koti.mbnet.fi/~atjs/mc6809/ [...] Collection of 6809 instructions, emulators, tools, <b>debuggers,</b> dis{{assemblers}} and assemblers ...|$|R
50|$|This {{offers the}} {{functions}} for <b>debuggers</b> {{to be used}} in development tools.|$|R
25|$|Microsoft allows {{developers}} to temporarily or locally disable the signing requirement on systems they control (by hitting F8 during boot) or by signing the drivers with self-issued certificates or by running a kernel <b>debugger.</b>|$|E
25|$|OpenBSD {{includes}} {{a number of}} third-party software components, many with OpenBSD-specific patches; examples include the X.Org Server, GNU Compiler Collection (which acts as the default compiler), Perl, NSD, Unbound, Ncurses, GNU Binutils, GNU <b>Debugger</b> and Awk.|$|E
25|$|More typically, {{the first}} step in {{locating}} a bug is to reproduce it reliably. Once the bug is reproducible, the programmer may use a <b>debugger</b> or other tool while reproducing the error to find {{the point at which the}} program went astray.|$|E
5000|$|<b>Debuggers</b> {{for some}} {{programming}} languages used on System/360 and later IBM mainframes ...|$|R
50|$|The {{ability to}} detect non-fatal errors is a major {{distinction}} between Purify and similar programs from the usual <b>debuggers.</b> By contrast, <b>debuggers</b> generally only allow the programmer to quickly find the sources of fatal errors, such as a program crash due to dereferencing a null pointer, but do not help to detect the non-fatal memory errors. <b>Debuggers</b> are useful for other things that Purify is not intended for, such as for stepping through the code line by line or examining the program's memory by hand at a particular moment of execution. In other words, these tools can complement {{each other for a}} skilled developer.|$|R
25|$|Script <b>debuggers</b> are {{integrated}} within Internet Explorer, Firefox, Safari, Google Chrome, Opera and Node.js.|$|R
