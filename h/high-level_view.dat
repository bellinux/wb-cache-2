216|110|Public
2500|$|The Santa Teresa tram route {{rises from}} {{downtown}} Rio de Janeiro and follows a circuit of Santa Teresa hill, offering a <b>high-level</b> <b>view</b> of the city. It passes over the [...] high Carioca Aqueduct, a former aqueduct {{constructed in the}} 18th century and [...] electric trams used to run beneath it. Except for the aqueduct, the route is shared by motor vehicles.|$|E
2500|$|Cocoa's {{design is}} a fairly, but not {{absolutely}} strict application of MVC principles. Under OpenStep, {{most of the}} classes provided were either <b>high-level</b> <b>View</b> classes (in AppKit) or {{one of a number}} of relatively low-level model classes like NSString. Compared to similar MVC systems, OpenStep lacked a strong model layer. No stock class represented a [...] "document," [...] for instance. During the transition to Cocoa, the model layer was expanded greatly, introducing a number of pre-rolled classes to provide functionality common to desktop applications.|$|E
2500|$|Ugaki, Matome; Chihaya, Masataka (trans.). Fading Victory: The Diary of Admiral Matome Ugaki, 1941–45. Pittsburgh: University of Pittsburgh Press, 1991[...] Provides a <b>high-level</b> <b>view</b> of the {{war from}} the Japanese side, from the diaries of Yamamoto's Chief of Staff, Admiral Matome Ugaki. Provides {{evidence}} of {{the intentions of the}} imperial military establishment to seize Hawaii and to operate against Britain's Royal Navy in the Indian Ocean. Translated by Masataka Chihaya, this edition contains extensive clarifying notes from the U.S. editors derived from U.S. military histories.|$|E
50|$|In 1891 he {{produced}} <b>high-level</b> <b>views</b> of major London thoroughfares for Herbert Fry's London: Illustrated by Twenty Bird's Eye Views of the Principal Streets engraved by George William Ruffle (1838-1901).|$|R
5000|$|<b>High-level</b> (business) <b>view</b> of {{monitored}} resources through user-defined visual console {{screens and}} dashboards ...|$|R
40|$|Software {{clustering}} algorithms {{are used}} to create <b>high-level</b> <b>views</b> of a system's structure using source code-level artifacts. Software clustering is an active area of research that has produced many clustering algorithms. However, we have seen very little work that investigates how {{the results of these}} algorithms can be evaluated objectively {{in the absence of a}} benchmark decomposition, or without the active participation of the original designers of the system...|$|R
5000|$|<b>High-level</b> <b>view</b> {{of logical}} {{architecture}} {{of information technology}} systems ...|$|E
5000|$|TOE Security Specifications - a <b>high-level</b> <b>view</b> {{of how the}} {{developer}} intends to satisfy each SFR.|$|E
5000|$|Access Dashboard {{offers a}} <b>high-level</b> <b>view</b> of the business, {{presenting}} {{key performance indicators}} (KPIs) through graphical charts and graphs.|$|E
40|$|Software reverse {{engineering}} {{is a crucial}} task to reconstruct <b>high-level</b> <b>views</b> of a software system—with the purpose of understanding and/or maintaining it—when the only reliable source of information is the source code, or even the system binaries. This paper discusses key {{reverse engineering}} concepts through a UML conceptual model. Specifically, the model is composed {{of a set of}} UML class diagrams describing relationships existing among reverse engineering processes, tools, artifacts, and stakeholders. ...|$|R
40|$|The {{operational}} {{behavior of}} constraint programs {{is not easy}} to understand. We propose an approach where <b>high-level</b> <b>views</b> of executions are built on top of low-level tracers. We describe an analysis module which can analyze on the fly execution traces. Application programmers or end-users can easily program trace analysis tools without knowing any implementation details about the solver or the tracer. Most of the trace filtering can be done without storing or even generating any trace information...|$|R
5000|$|Shortly {{after leaving}} Queen Street station in Glasgow, and beyond Queen Street Tunnel, the line diverges {{from the main}} trunk route to Edinburgh & Perth at Cowlairs and follows a northwesterly course through the suburbs of Maryhill and Kelvindale. Between [...] and Dumbarton, the route is shared with the North Clyde Line to Helensburgh before {{branching}} northward at Craigendoran Junction towards , the section where the West Highland Line itself is generally accepted to begin. It gives <b>high-level</b> <b>views</b> of the Gareloch and Loch Long before emerging alongside the northwesterly shores of Loch Lomond, then climbs Glen Falloch to Crianlarich.|$|R
5000|$|It {{provides}} a <b>high-level</b> <b>view</b> of the foundational ontologies {{with only the}} most general concepts common to all implemented foundational ontologies.|$|E
5000|$|Fuzzy {{front-end}} (FFE) is the set {{of activities}} employed before the formal and well defined requirements specification is completed. Requirements are a <b>high-level</b> <b>view</b> of what the product should do to meet the perceived market or business need.|$|E
50|$|The logical flow {{can be used}} to give <b>high-level</b> <b>view</b> of how {{different}} screens in the user interface relate to each other to support a task. Flow can reveal for example number of required steps to perform certain task.|$|E
40|$|Architecture-based {{reasoning}} about {{reliability and}} fault tolerance is gaining increasing importance as component-based software architectures become more widespread. Architectural description languages (ADLs) {{are used to}} specify <b>high-level</b> <b>views</b> of software design. ADLs usually involve a static, structural view of a system together with a dynamic, state-transition-style semantics, facilitating specification and analysis of distributed and event-based systems. The aim is a compositional syntax and semantics: overall component behavior is {{understood in terms of}} subcomponent behavior. ADLs have been successful in understanding architecture functionality. However, it remains to be investigated how to equip an ADL with a compositional semantics for specification and analysis of extra-functional properties such as reliability and fault-tolerance...|$|R
40|$|The {{availability}} of large collections of linked data {{that can be}} accessed through public services and search endpoints requires methods and techniques for reducing the data complexity and providing <b>high-level</b> <b>views</b> of data contents defined according to users specific needs. To this end, a crucial step {{is the definition of}} data classification methods and techniques for the thematic aggregation of linked data. In this paper, we propose matching and clustering techniques specifically conceived for linked data classification, by focusing on the high level of heterogeneity of data descriptions {{in terms of the number}} and kind of their descriptive features. Categories and Subject Descriptors Information systems [Information retrieval]: tasks and goals—Clustering and classificatio...|$|R
40|$|AbstractSNOMED {{is one of}} {{the leading}} health care terminologies being used worldwide. As such, quality {{assurance}} is an important part of its maintenance cycle. Methodologies for auditing SNOMED based on structural aspects of its organization are presented. In particular, automated techniques for partitioning SNOMED into smaller groups of concepts based primarily on relationships patterns are defined. Two abstraction networks, the area taxonomy and p-area taxonomy, are derived from the partitions. The <b>high-level</b> <b>views</b> afforded by these abstraction networks form the basis for systematic auditing. The networks tend to highlight errors that manifest themselves as irregularities at the abstract level. They also support group-based auditing, where sets of purportedly similar concepts are focused on for review. The auditing methodologies are demonstrated on one of SNOMED’s top-level hierarchies. Errors discovered during the auditing process are reported...|$|R
5000|$|The Santa Teresa tram route {{rises from}} {{downtown}} Rio de Janeiro and follows a circuit of Santa Teresa hill, offering a <b>high-level</b> <b>view</b> of the city. It passes over the 45 m high Carioca Aqueduct, a former aqueduct {{constructed in the}} 18th century and [...] electric trams used to run beneath it. Except for the aqueduct, the route is shared by motor vehicles.|$|E
50|$|The Technological Architecture {{model is}} used to give an {{overview}} of the technical functions, and infrastructure needed to provide the service. For example, the way information is stored, or content is generated and broadcast. Although will be a <b>high-level</b> <b>view</b> of the technological architecture, it can be passed to technical developers who add more detail at a later stage of the development the ICT service.|$|E
50|$|CPOF is {{also used}} as a live-data {{alternative}} to PowerPoint briefings. During a CPOF briefing, commanders can drill into any data element in a <b>high-level</b> <b>view</b> to see details on demand, and view outliers or other elements of interest in different visual contexts without switching applications. Annotations and editing-gestures made during briefings {{become part of the}} shared repository. The commander's topsight is based on ground-truth at the moment of the briefing; the commander can then communicate intent on live data.|$|E
40|$|The GlycoViewer ([URL] is {{a web-based}} tool that can visualize, {{summarize}} and compare sets of glycan structures. Its input {{is a group}} of glycan structures; these can be entered as a list in IUPAC format or via a sugar structure builder. Its output is a detailed graphic, which summarizes all salient features of the glycans according to the shapes of the core structures, the nature and length of any chains, and the types of terminal epitopes. The tool can summarize up to hundreds of structures in a single figure. This allows unique, <b>high-level</b> <b>views</b> to be generated of glycans from one protein, from a cell, a tissue or a whole organism. Use of the tool is illustrated in the analysis of normal and disease-associated glycans from the human glycoproteome. 4 page(s...|$|R
40|$|As {{the size}} of {{software}} systems continues to grow, understanding the structure of these systems gets harder. This coupled with associated problems such as of lack of current documentation, and the limited or nonexistent availability of the original designers of the system, adds further di#culty to the job of software professionals {{trying to understand the}} structure of large and complex systems. The application of clustering techniques and tools to software systems helps software designers, developers, and maintenance programmers by recovering <b>high-level</b> <b>views</b> of system designs. In this paper we survey clustering approaches that have been developed by software engineering researchers. We also examine classical clustering techniques that have been applied in mathematics, science, and engineering, and investigate how these techniques have been adapted to work in the software domain. We conclude with a discussion of open research challenges related to software clustering...|$|R
40|$|Abstract. We {{present an}} {{approach}} {{for development of}} Grid resource management tools, where we put into practice internationally established <b>high-level</b> <b>views</b> of future Grid architectures. The approach addresses fundamental Grid challenges and strives towards a future vision of the Grid where capabilities are made available as independent and dynamically assembled utilities, enabling run-time changes in the structure, behavior, and location of software. The presentation is made in terms of design heuristics, design patterns, and quality attributes, and is centered around the key concepts of co-existence, composability, adoptability, adaptability, changeability, and interoperability. The practical realization of the approach is illustrated by five case studies (recently developed Grid tools) high-lighting the most distinct aspects of these key concepts for each tool. The approach contributes to a healthy Grid ecosystem that promotes a natural selection of “surviving ” components through competition, innovation, evolution, and diversity. In conclusion, this environment facilitates the use and composition of components on a per-component basis. ...|$|R
5000|$|Cocoa's {{design is}} a strict {{application}} of MVC principles. Under OpenStep, {{most of the}} classes provided were either <b>high-level</b> <b>View</b> classes (in AppKit) or {{one of a number}} of relatively low-level model classes like NSString. Compared to similar MVC systems, OpenStep lacked a strong model layer. No stock class represented a [...] "document," [...] for instance. During the transition to Cocoa, the model layer was expanded greatly, introducing a number of pre-rolled classes to provide functionality common to desktop applications.|$|E
50|$|Event {{processing}} involves {{altering the}} existing server software {{in an organization}} to emit events (these are just small messages) whenever a notable event occurs. Event-processing software (such as this software) can monitor these events and look out for certain patterns of interest. This is useful {{for the prevention of}} Credit card fraud or for giving executives a <b>high-level</b> <b>view</b> of what's going on in their company (e.g. when share price drops {{for an extended period of}} time). For a more detailed description see complex event processing.|$|E
50|$|The role {{of present}} AIS {{would need to}} {{transform}} to an information management service, changing duties, responsibilities and scope to satisfy these new requirements and to cope with and manage the provision of information. The definition of a future <b>high-level</b> <b>view</b> as to the shape, nature and content of a strategy for the evolution from traditional product-centric AIS to the enlarged scope of data-centric aeronautical information management (AIM) began and ICAO took the lead {{at the global level}} with regard to the transition from AIS to AIM.|$|E
40|$|Part 8 : Run-Time (Re) {{configuration}} and InspectionInternational audienceContemporary middleware offers powerful abstractions {{to construct}} distributed software systems. However, when inspecting the software at run-time, these abstractions {{are no longer}} visible. While inspection, monitoring and management are increasingly important in our always-online world, they are often only possible {{in terms of the}} lower-level abstraction of the underlying platform. Due to the complexity of current programming languages and middleware, this low-level information is too complex to handle or understand. This paper presents a run-time inspection system based on dynamic model transformation capabilities that extends run-time entities with higher-level abstract views, in order to enable inspection in terms of the original and most relevant abstractions. Our solution is lightweight in terms of performance overhead and agile {{in the sense that it}} can selectively (and on-demand) generate these <b>high-level</b> <b>views.</b> Our prototype implementation has been applied to inspect distributed applications using RMI. In this case study, we inspect the distributed RMI system using our integrated overview over the collection of distributed objects that interact using remote method invocation...|$|R
40|$|Many of the {{existing}} approaches to reverse architect-ing –the reverse engineering of the architecture of software systems – are based on software exploration tools which pro-vide interactive ways of exploring the system. These tools start with <b>high-level</b> <b>views</b> {{of the system and}} refine them with drill-down techniques applied on the high-level enti-ties such as modules and packages, leaving aside valuable information contained in the dependencies between them. In this article we argue that the visualization of inter-module relations bears great potential for support-ing the understanding of large evolving software systems. We present two concrete examples of such visualiza-tions. The first, The Semantic Dependency Matrix is a technique for displaying details about a dependency be-tween two modules which groups together classes with similar behavior. The second, The Edge Evolution Film-strip presents the evolution of an inter-module relation through multiple versions of the system. Based on our ex-perience with the Edge Evolution Film Strip, we propose a pattern language for inter-module relationships. We ex-emplify both the visualizations and the pattern language with examples from two large open source software sys-tems. 1...|$|R
40|$|Query-based code browsers can be {{customized}} {{to render}} {{many different types}} of views on-demand. In contrast to single-purpose browsers offered by modern IDEs such as Eclipse (e. g. Call Hierarchy), they release developers from mentally inducting the integral information from several views generated for specific purposes. However, customizing query-based tools, and communicating with their interfaces demands database expertise and understanding of the query language syntax. This puts a burden on maintainers by forcing them to encode their required views using complex queries. In this dissertation we investigate a query engine designed for software structural analysis which (1) provides a visual query interface over the high-level textual query language to eliminate the need for understanding the query language syntax, (2) incorporates the knowledge of programming language constructs into the factbase, query language, and the views, and (3) integrates the query-based and specific-purpose views already provided through the IDE. We are confident that this approach will be beneficial to maintainers during comprehension by allowing to abstract source code to <b>high-level</b> <b>views</b> and to speed up the rummage of the source code...|$|R
5000|$|Ugaki, Matome; Chihaya, Masataka (trans.). Fading Victory: The Diary of Admiral Matome Ugaki, 1941-45. Pittsburgh: University of Pittsburgh Press, 1991[...] Provides a <b>high-level</b> <b>view</b> of the {{war from}} the Japanese side, from the diaries of Yamamoto's Chief of Staff, Admiral Matome Ugaki. Provides {{evidence}} of {{the intentions of the}} imperial military establishment to seize Hawaii and to operate against Britain's Royal Navy in the Indian Ocean. Translated by Masataka Chihaya, this edition contains extensive clarifying notes from the U.S. editors derived from U.S. military histories.|$|E
5000|$|Geisler {{is known}} first and {{foremost}} as a classical Christian apologist. Between 1970 and 1990 he participated in dozens of public debates and gained {{a reputation as a}} defender of theism, biblical miracles, the resurrection of Jesus, and the reliability of the Bible. The first attempt to publish an outline of his apologetic method showed up in an appendix of his 1990 book When Skeptics Ask. The appendix is titled [...] "Reasoning to Christianity from Ground Zero" [...] and in it we see a <b>high-level</b> <b>view</b> of the holistic system of classical apologetics he had been developing over the years. The first outline contained fourteen points of argument: ...|$|E
40|$|This paper {{presents}} a graph matching {{model for the}} software architecture recovery problem. Because of their expressiveness, the graphs {{have been widely used}} for representing both the software system and its <b>high-level</b> <b>view,</b> known as the conceptual architecture. Modeling the recovery process as graph matching is an attempt to identify a sub-optimal transformation from a pattern graph, representing the <b>high-level</b> <b>view</b> of the system, onto a subgraph of the software system graph. A successful match yields a restructured system that conforms with the given graph pattern. A failed match indicates the points where the system violates specific constraints. The pattern graph generation and the incrementality of the recovery process are the important issues to be addressed. The approach is evaluated through case studies using a prototype toolkit that implements the proposed interactive recovery environment. ...|$|E
40|$|Software {{architecture}} {{recovery is}} a bottom-up process that aims at building <b>high-level</b> <b>views</b> {{that support the}} understanding of existing software applications. Many approaches have been proposed to support architecture recovery using various techniques. However, very few approaches are driven by the architectural styles {{that were used to}} build the systems under analysis. In this paper, we address the problem of recovering layered views of existing software systems. We re-examine the layered style to extract a set of fundamental principles which encompass a set of constraints that a layered system must conform to at design time and during its evolution. These constraints are used to guide the recovery process of layered architectures. In particular, we translate the problem of recovering the layered architecture into a quadratic assignment problem (QAP) based on these constraints, and we solve the QAP using a heuristic search algorithm. In this paper, we introduce the QAP formulation of the layering recovery and we present and discuss the results of the experimentation with the approach on four open source software systems...|$|R
40|$|Contemporary {{middleware}} offers powerful abstractions {{to construct}} distributed software systems. However, when inspecting the software at run-time, these abstractions {{are no longer}} visible. While inspection, monitoring and management are increasingly important in our always-online world, they are often only possible {{in terms of the}} lower-level abstraction of the underlying platform. Due to the complexity of current programming languages and middleware, this low-level information is too complex to handle or understand. This paper presents a run-time inspection system based on dynamic model transformation capabilities that extends run-time entities with higher-level abstract views, in order to enable inspection in terms of the original and most relevant abstractions. Our solution is lightweight in terms of performance overhead and agile {{in the sense that it}} can selectively (and on-demand) generate these <b>high-level</b> <b>views.</b> Our prototype implementation has been applied to inspect distributed applications using RMI. In this case study, we inspect the distributed RMI system using our integrated overview over the collection of distributed objects that interact using remote method invocationstatus: publishe...|$|R
40|$|The {{maintenance}} or reengineering of an object-oriented system includes its reverse engineering. In {{other words}} its internal structure and behavior {{needs to be}} understood. Many researchers have proposed different techniques to support the reverse engineering effort. The two predominant approaches to reverse engineering are: • static analysis of source code • dynamic analysis of behavior of a system at execution time. Both techniques have strengths and short comings. The static analysis of an object-oriented software system face difficulties such as polymorphism {{and it may be}} difficult to correlate parts with system functionality. Dynamic analysis approaches generally do not achieve full coverage of a software system. Moreover, due to the volume of data captured during dynamic analysis of a system, it is difficult to infer <b>high-level</b> <b>views.</b> In this thesis we address this issue of software maintenance and reengineering and propose a novel visualization technique which combines static analysis of source code with dynamic information extracted by exercising features of a system. We refer to these as dynamic feature-traces. This technique support...|$|R
