63|252|Public
25|$|Typically, {{computer}} programs {{are stored in}} non-volatile memory until requested {{either directly or indirectly}} to be executed by the computer user. Upon such a request, the program is loaded into random-access memory, by a computer program called an operating system, where it can be accessed directly by the central processor. The central processor then executes ("runs") the program, instruction by instruction, until termination. A program in execution is called a process. Termination is either by normal self-termination or by error– software or <b>hardware</b> <b>error.</b>|$|E
5000|$|Windows <b>Hardware</b> <b>Error</b> Architecture (WHEA) is an {{operating}} system <b>hardware</b> <b>error</b> handling mechanism introduced with Windows Vista and Windows Server 2008 {{as a successor}} to Machine Check Architecture (MCA) on previous versions of Windows. [...] The architecture consists of several software components that interact with the hardware and firmware of a given platform to handle and notify regarding <b>hardware</b> <b>error</b> conditions. [...] Collectively, these components provide: a generic means of discovering errors, a common error report format for those errors, a way of preserving error records, and an error event model based up on Event Tracing for Windows (ETW).|$|E
5000|$|If a <b>hardware</b> <b>error</b> causes {{its state}} {{to change in}} an {{unexpected}} way.|$|E
50|$|ACPI Platform Error Interface (APEI) is a {{specification}} {{for reporting}} of <b>hardware</b> <b>errors,</b> e.g. from the chipset, {{to the operating}} system.|$|R
50|$|In computing, Machine Check Architecture (MCA) is an Intel {{mechanism}} {{in which the}} CPU reports <b>hardware</b> <b>errors</b> to the operating system.|$|R
50|$|An NMI {{is often}} used when {{response}} time is critical or when an interrupt should never be disabled during normal system operation. Such uses include reporting non-recoverable <b>hardware</b> <b>errors,</b> system debugging and profiling, and handling of special cases like system resets.|$|R
5000|$|A microprogrammed 16-bit central {{processor}} with floating point <b>hardware,</b> <b>error</b> detection and system integrity checking features.|$|E
50|$|A machine-check {{exception}} (MCE) {{is a type}} {{of computer}} <b>hardware</b> <b>error</b> that occurs when a computer's central processing unit detects a hardware problem.|$|E
5000|$|When Apple {{introduced}} the iMac in 1998, {{it was a}} radical departure from other Macs of the time. The iMac began the production of New World Macs, as they are called; New World Macs, such as the iMac, Power Macintosh G3 (Blue & White), Power Mac G4 (PCI Graphics), PowerBook G3 (bronze keyboard), and PowerBook G3 (FireWire), load the Mac OS ROM from the hard drive. In the event of an error, but not a fatal <b>hardware</b> <b>error,</b> they display the same screen as seen when holding [...] at startup but with the error message instead of the [...] "0 >" [...] prompt. In the event of a fatal <b>hardware</b> <b>error,</b> they give these beeps: ...|$|E
5000|$|In computing, a non-maskable {{interrupt}} (NMI) is a hardware interrupt that standard interrupt-masking techniques {{in the system}} cannot ignore. It typically occurs to signal attention for non-recoverable <b>hardware</b> <b>errors.</b> (Some NMIs may be masked, but only by using proprietary methods specific to the particular NMI.) ...|$|R
40|$|This paper {{introduces}} SymPLFIED, a program-level framework {{which allows}} specification of arbitrary error detectors and the verification of their efficacy against <b>hardware</b> <b>errors.</b> SymPLFIED comprehensively enu-merates all transient <b>hardware</b> <b>errors</b> in registers, memory and computation (expressed symbolically as value errors) that potentially evade detection and cause program failure. The framework uses symbolic execu-tion to abstract {{the state of}} erroneous values in the pro-gram and model checking to comprehensively find all errors that evade detection. We demonstrate the use of SymPLFIED on a widely deployed aircraft collision avoidance application, tcas. Our {{results show that the}} SymPLFIED framework can be used to uncover hard-to-detect corner cases caused by transient errors in programs that may not be exposed by random fault-injection based validation. ...|$|R
50|$|Error {{detection}} and recovery is emphasized, with error-correcting code (ECC) on L2 and L3 caches and buffers, and extensive parity checking elsewhere; in all over 20,000 error checkers on the chip. Processor state is buffered {{in a way}} that allows precise core retry for almost all <b>hardware</b> <b>errors.</b>|$|R
50|$|The {{design as}} {{described}} in Stewart's 1973 paper is pretty much thatwhich was implemented in the first commercial version exceptthe facility to supply address bits from the processing elements wasremoved. This change greatly simplified <b>hardware</b> <b>error</b> detection. Anotable extra facility was carry propagation to simplifyvector mode addition.|$|E
50|$|In {{the event}} of a <b>hardware</b> <b>error,</b> the vmkernel can 'catch' a Machine Check Exception. This results in an error message {{displayed}} on a purple diagnostic screen. This is colloquially known as a purple diagnostic screen, or purple screen of death (PSOD, cf. Blue Screen of Death (BSOD)).|$|E
50|$|WHEA allows {{third-party}} software {{to interact with}} the operating system and react to certain hardware events. For example, when a new CPU is added to a running system—a Windows Server feature known as Dynamic Hardware Partitioning—the <b>hardware</b> <b>error</b> component stack is notified when a new processor is installed.|$|E
40|$|Abstract. It is {{expected}} that commodity hardware is becoming less re-liable because of the continuously decreasing feature sizes of integrated circuits. Nevertheless, more and more commodity <b>hardware</b> with insuf-ficient <b>error</b> detection is used in critical applications. One possible solu-tion is to detect <b>hardware</b> <b>errors</b> in software using arithmetic AN-codes. These codes detect <b>hardware</b> <b>errors</b> independent of the actual failure modes of the underlying hardware. However, measurements have shown that AN-codes still exhibit large rates of undetected silent data corrup-tions (SDC). These high rates of undetected SDCs are caused by the insufficient protection of control and data flow through AN-codes. In contrast, ANB- and ANBD-codes promise much higher error detection rates because they also detect errors in control and data flow. We present our encoding compiler that automatically applies either an AN-, ANB-or ANBD-code to an application. Our error injections show that AN-, ANB-, and ANBD-codes successfully detect errors and more important that indeed ANB- and ANBD-codes reduce the SDC rate more effec-tively than AN-codes. The difference between ANBD- and ANB-codes is also visible but less pronounced. ...|$|R
30|$|In this section, we {{describe}} how a Paxos member recovers from a failure. It {{is clear that}} the failure is a common phenomenon in distributed systems, e.g., power failure, administrator mistakes, software or <b>hardware</b> <b>errors</b> and so on. Therefore, we need to adopt recovery mechanism to ensure the correctness and consistency of the database.|$|R
30|$|Results are not {{presented}} for a 16 -node {{trial of the}} hardware program. During our testing, {{it was not possible}} to find 16 nodes of the HHPC that were all capable of running the hardware program at once. This was due to <b>hardware</b> <b>errors</b> on some nodes, and inconsistent system software installations on others.|$|R
50|$|DEC {{distributed}} {{their own}} PDP-11 version of V7, called V7M (for modified). V7M, developed by DEC's original Unix Engineering Group (UEG), contained many enhancements to the kernel for the PDP-11 line of computers including significantly improved <b>hardware</b> <b>error</b> recovery and many additional device drivers. UEG {{evolved into the}} group that later developed Ultrix.|$|E
5000|$|Modern {{versions}} of Microsoft Windows handle machine check exceptions through the Windows <b>Hardware</b> <b>Error</b> Architecture. When WHEA detects a machine check exception, it displays the error in a Blue Screen of Death, {{with the following}} parameters (which vary, but the first parameter is always 0x0 for a machine check exception): [...] *** STOP: 0x00000124 (0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000) ...|$|E
5000|$|In PL/1, {{even though}} a program itself may not be {{predominantly}} event-driven, certain abnormal events such as a <b>hardware</b> <b>error,</b> overflow or [...] "program checks" [...] may occur that possibly prevent further processing. Exception handlers may be provided by [...] "ON statements" [...] in (unseen) callers to provide housekeeping routines to clean up afterwards before termination, or to perform recovery operations {{and return to the}} interrupted procedure.|$|E
40|$|Rights to {{individual}} papers {{remain with the}} author or the author's employer. Permission is granted for noncommercial reproduction of the work for educational or research purposes. This copyright notice must {{be included in the}} reproduced paper. USENIX acknowledges all trademarks herein. and will continue to be, the most probable cause of loss of availability. While such failures are clearly common-place, especially in desktop environments, the probabil-ity of certain <b>hardware</b> <b>errors</b> is increasing. <b>Hardware</b> <b>errors</b> can be classified as hard errors and transient (soft) errors. Hard errors are those that require replacement (or otherwise relinquished use) of the com-ponent. They are typically caused by physical damage to a component, e. g. by damage to connectors. Transient errors are those that result in an invalid state that can be corrected, for example, by overwriting a corrupt mem-ory location. Ziegler et al. [21, 22] have shown that fac...|$|R
40|$|Abstract—The {{frequency}} of <b>hardware</b> <b>errors</b> is increasing due to shrinking feature sizes, {{higher levels of}} integration, and increasing design complexity. Intermittent errors are those that occur non-deterministically at the same location. It {{has been shown that}} intermittent <b>hardware</b> <b>errors</b> contribute to about 39 % of the total hardware failures. Intermittent faults have characteristics that are different than transient and permanent errors, which makes it challenging to devise efficient recovery techniques for them. In this paper, we evaluate the impact of different intermittent error recovery scenarios on the processor performance. To achieve this, we model a system that consists of a fault-tolerant multicore processor subject to intermittent faults. Our fault models are based on insights from related work at the physical level. We find that the {{frequency of}} the intermittent error and the relative importance of the error location {{play an important role in}} choosing the recovery action that maximizes the processor’s performance. Index Terms—Intermittent hardware faults, recovery, stochas-tic activity network, fault model, transistor wearout. I...|$|R
5000|$|... #Caption: The three {{red lights}} on the Ring of Light {{indicate}} that a General <b>Hardware</b> Failure <b>error</b> occurred.|$|R
50|$|The Macintosh II was {{followed}} by a series of related models including the Macintosh IIx and Macintosh IIfx, all of which used the Motorola 68030 processor. It was possible to upgrade a Macintosh II to a Macintosh IIx or IIfx with a motherboard swap. The Macintosh II was the first Macintosh to have the Chimes of Death accompany the Sad Mac logo whenever a serious <b>hardware</b> <b>error</b> occurred.|$|E
50|$|In early IBM-compatible {{personal}} computers, an IRQ {{conflict is}} a once common <b>hardware</b> <b>error,</b> received when two devices {{were trying to}} use the same interrupt request (or IRQ) to signal an interrupt to the Programmable Interrupt Controller (PIC). The PIC expects interrupt requests from only one device per line, thus more than one device sending IRQ signals along the same line will generally cause an IRQ conflict that can freeze a computer.|$|E
50|$|A Machine Check interruptionPoOps {{occurs to}} report unusual {{conditions}} {{associated with the}} channel or CPU that cannot be reported by another class of interruption. The most important class of conditions causing a Machine Check is a <b>hardware</b> <b>error</b> such as a parity error found in registers or storage, but some models may use it to report less serious conditions. Both the interruption code and the data stored in the scanout area at '80'x (128 decimal) are model dependent.|$|E
40|$|A {{method for}} {{improving}} the fault-tolerance of cache coherent multiprocessors is proposed. By dynamically verifying coherence operations in <b>hardware,</b> <b>errors</b> caused by manufacturing faults, soft errors, and design mistakes can be detected. Analogous to the DIVA concept for singleprocessor systems, a simple version of the protocol functions as a checker for the aggressive implementation. An example implementation is shown, and the overhead is estimated for a small SMP system...|$|R
50|$|Rapid context {{switching}} was {{a design}} objective. The register file {{is divided into}} four sections. The three commonly used interrupt levels and the background level have distinct sets of registers. Therefore, entry into most interrupt levels does not require saving the registers of the interrupted program. The infrequently used level which processed program and <b>hardware</b> <b>errors</b> shares registers with the next highest level and thus has to save and restore registers.|$|R
40|$|Proposed is {{a method}} for {{improving}} the fault tolerance of cache coherent multiprocessors. By dynamically verifying coherence operations in <b>hardware,</b> <b>errors</b> caused by manufacturing faults, soft errors, and design mistakes can be detected. Analogous to the DIVA concept for single-processor systems, a simple version of the protocol functions as a checker for the aggressive implementation. An example implementation is shown, and the overhead is estimated for a small SMP system. This is work in progress, and detailed simulation results are not yet available...|$|R
50|$|A {{watchdog}} timer is an electronic timer that detects abnormal operation of other components and initiates corrective action to restore normal operation. It especially ensures that microcontroller controlled devices do not completely fail if a software error or momentary <b>hardware</b> <b>error</b> occurs. Watchdog timers are typically based on either a monostable timer or digital counter. The timer circuit may be integrated on the microcontroller chip or be implemented as an external circuit. Watchdog timers can significantly improve {{the reliability of}} a microcontroller in an electromagnetically-influenced environment.|$|E
50|$|Typically, {{computer}} programs {{are stored in}} non-volatile memory until requested {{either directly or indirectly}} to be executed by the computer user. Upon such a request, the program is loaded into random-access memory, by a computer program called an operating system, where it can be accessed directly by the central processor. The central processor then executes ("runs") the program, instruction by instruction, until termination. A program in execution is called a process. Termination is either by normal self-termination or by error - software or <b>hardware</b> <b>error.</b>|$|E
5000|$|A C2 {{error is}} a read error of a compact disc. C2 errors can {{to a degree}} be {{recovered}} by the <b>hardware</b> <b>error</b> detection and correction scheme. A CD drive can have extraction errors when the data on the disc is not readable due to scratches or smudges. The drive can compensate by supplying a [...] "best guess" [...] of what the missing data was, then supplying the missing data. C2 error correction is an analysis over many interleaved frames, an improvement over C1 error correction, which analyzed just one frame, resulting in more accurate data correction. C2 error correction codes are also used by the Digital Audio Tape (DAT) format.|$|E
40|$|It {{is widely}} {{understood}} that most downtime is {{accounted for by}} programming errors and administration time. However, recent work has indicated an increasing cause of downtime may stem from transient <b>hardware</b> <b>errors</b> caused by external factors, such as cosmic rays. Moving to denser semiconductor technologies at lower voltages will cause an increase in transient errors. We investigate the trends in transient errors and the susceptibility of operating systems and applications to them, and we introduce ideas regarding software transient error recoverability...|$|R
50|$|Route {{flapping}} {{is caused}} by pathological conditions (<b>hardware</b> <b>errors,</b> software errors, configuration errors, intermittent errors in communications links, unreliable connections, etc.) within the network which cause certain reachability information to be repeatedly advertised and withdrawn. In a network where a link-state routing protocol is run, route flapping will force frequent recalculation of the topology by all participating routers. In networks with distance-vector routing protocols flapping routes can trigger routing updates with every state change. In both cases, they prevent the network from converging.|$|R
50|$|In practice, beta {{encoders}} {{have attempted}} to exploit the redundancy provided by the non-uniqueness of the expansion in base beta to produce more robust results. An early beta encoder, the Golden ratio encoder used the golden ratio base for its value of beta, but was susceptible to <b>hardware</b> <b>errors.</b> Although integrator leaks in hardware elements make some beta encoders imprecise, specific algorithms {{can be used to}} provide exponentially accurate approximations for the value of beta, despite the imprecise results provided by some circuit components.|$|R
