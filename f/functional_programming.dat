4077|2615|Public
5|$|Python {{features}} a dynamic type system and automatic memory management and supports multiple programming paradigms, including object-oriented, imperative, <b>functional</b> <b>programming,</b> and procedural styles. It {{has a large}} and comprehensive standard library.|$|E
5|$|Python is a multi-paradigm {{programming}} language: {{object-oriented programming}} and structured programming are fully supported, and many language features support <b>functional</b> <b>programming</b> and aspect-oriented programming (including by metaprogramming and metaobjects (magic methods)). Many other paradigms are supported via extensions, including design by contract and logic programming.|$|E
5|$|In 2005, Audrey Tang {{created the}} Pugs project, an {{implementation}} of Perl 6 in Haskell. This acted as, {{and continues to}} act as, a test platform for the Perl 6 language (separate from {{the development of the}} actual implementation)allowing the language designers to explore. The Pugs project spawned an active Perl/Haskell cross-language community centered around the freenode #perl6 IRC channel. Many <b>functional</b> <b>programming</b> influences were absorbed by the Perl 6 design team.|$|E
50|$|<b>Functional</b> <b>programs</b> do {{not have}} {{assignment}} statements, that is, {{the value of a}} variable in a <b>functional</b> <b>program</b> never changes once defined. This eliminates any chances of side effects because any variable can be replaced with its actual value at any point of execution. So, <b>functional</b> <b>programs</b> are referentially transparent.|$|R
40|$|This paper {{formally}} {{presents a}} model of tracing for <b>functional</b> <b>programs</b> based on a small-step operational semantics. The model records the computation of a <b>functional</b> <b>program</b> in a graph which can be utilised for various purposes such as algorithmic debugging. The main contribution {{of this paper is}} to prove the correctness of algorithmic debugging for <b>functional</b> <b>programs</b> based on the model. Although algorithmic debugging for <b>functional</b> <b>programs</b> is implemented in several tracers such as Hat, the correctness has not been formally proved before. The difficulty of the proof is to find a suitable induction principle and a more general induction hypothesis. ...|$|R
40|$|AbstractFinitely typed <b>functional</b> <b>programs</b> are {{naturally}} classified by their levels. This syntactic classification of <b>functional</b> <b>programs</b> {{corresponds to a}} semantical classification: the higher the level of <b>functional</b> <b>programs,</b> the more functions they can compute. We call FL the language of finitely typed <b>functional</b> <b>programs.</b> The halting problem on finite interpretations is elementary recursive for every FL program, i. e. for every FL program P there is an elementary recursive procedure to decide for every finite interpretation I whether P halts on I. The well-known programming language ML is essentially FL, augmented with the polymorphic let-in constructor. We show that ML computes the same class of functions as FL. As a consequence...|$|R
25|$|Scala, an {{object-oriented}} and <b>functional</b> <b>programming</b> language, has a Scala-to-JavaScript compiler.|$|E
25|$|For some {{alternate}} {{conceptions of}} what constitutes an algorithm see <b>functional</b> <b>programming</b> and logic programming.|$|E
25|$|GHC is {{also often}} a testbed for {{advanced}} <b>functional</b> <b>programming</b> features and optimizations in other programming languages.|$|E
40|$|We {{present a}} survey of control-flow {{analysis}} of <b>functional</b> <b>programs,</b> {{which has been the}} subject of extensive investigation throughout the past 30 years. Analyses of the control flow of <b>functional</b> <b>programs</b> have been formulated in multiple settings and have led to many different approximations, starting with the seminal works of Jones, Shivers, and Sestoft. In this paper, we survey control-flow analysis of <b>functional</b> <b>programs</b> by structuring the multitude of formulations and approximations and comparing them...|$|R
50|$|If we {{can turn}} {{students}} into teachers that create <b>functional</b> <b>programs</b> and run themon computers, we can reinforce this content and show students how writing downmathematics and how writing down <b>functional</b> <b>programs</b> creates lively animated scenesand even computer games.|$|R
40|$|This paper {{deals with}} {{automated}} termination analysis for partial <b>functional</b> <b>programs,</b> i. e. for <b>functional</b> <b>programs</b> {{which do not}} terminate for each input. We present a method to determine their domains (resp. non-trivial subsets of their domains) automatically. More precisely, for each <b>functional</b> <b>program</b> a termination predicate algorithm is synthesized, which only returns true for inputs where the program is terminating. To ease subsequent reasoning about the generated termination predicates we also present a procedure for their simplification...|$|R
25|$|The lambda {{calculus}} {{may be seen}} as an idealised version of a <b>functional</b> <b>programming</b> language, like Haskell or Standard ML.|$|E
25|$|Arrows in <b>functional</b> <b>programming</b> â€” whereas monads generalize {{the results}} of a {{computation}} to effects, arrows further generalize the inputs similarly.|$|E
25|$|The Department {{is engaged}} in {{research}} across Computer and Information Sciences, spanning Artificial Intelligence, Software Engineering, Information Retrieval, Mobile and Ubiquitous Interaction, <b>Functional</b> <b>Programming,</b> Dataflow Systems, Database Indexing and Information Science.|$|E
40|$|To {{prove the}} {{termination}} of a <b>functional</b> <b>program</b> {{there has to be}} a well-founded ordering such that the arguments in each recursive call are smaller than the corresponding inputs. In this paper we present a procedure for automated termination proofs of <b>functional</b> <b>programs.</b> In contrast to previously presented methods a suited well-founded ordering does not have to be fixed in advance by the user, but can be synthesized automatically. For that purpose we use approaches developed in the area of term rewriting systems for the automated generation of suited well-founded term orderings. But unfortunately term orderings cannot be directly used for termination proofs of <b>functional</b> <b>programs</b> which call other algorithms in the arguments of their recursive calls. The reason is that while for {{the termination of}} term rewriting systems orderings between terms are needed, for <b>functional</b> <b>programs</b> we need orderings between objects of algebraic data types. Our method solves this problem and enables term orderings to be used for termination proofs of <b>functional</b> <b>programs...</b>|$|R
40|$|This paper {{describes}} a fully automatic technique for verifying properties of higher-order <b>functional</b> <b>programs.</b> <b>Functional</b> <b>programs</b> are modelled with term rewriting systems and tree automata {{are used to}} model reachable program states. From a tree automaton representing the initial state, {{it is possible to}} define a completion algorithm on tree automata for approximating the output set of the program to verify. We define a subclass of higher-order <b>functional</b> <b>programs</b> for which the completion is guaranteed to terminate. Furthermore, since precision of the completion is fixed by a set of equations, we also propose an algorithm to automatically generate sets of equations by iterative refinement. We present some experiments showing that the resulting verification technique is complementary and extends several state-of-the-art model-checking approaches for higher-order <b>functional</b> <b>programs...</b>|$|R
40|$|We {{identify}} {{a class of}} PROLOG programs {{that can be used}} as the specification of the <b>functional</b> <b>programs.</b> Using the mode information, the functions needed to construct the <b>functional</b> <b>program</b> are identified. The function definitions may then be derived from the clauses in PROLOG specification. Rules have been given for constructing a FP-like definition for the function representing the user query. The methodology makes an extensive use of the algebra of <b>functional</b> <b>programs</b> to simplify and consolidate these representations. The methodology has been illustrated using an example...|$|R
25|$|Following {{the release}} of Miranda by Research Software Ltd, in 1985, {{interest}} in lazy functional languages grew. By 1987, {{more than a dozen}} non-strict, purely <b>functional</b> <b>programming</b> languages existed. Miranda was the most widely used, but it was proprietary software. At the conference on <b>Functional</b> <b>Programming</b> Languages and Computer Architecture (FPCA '87) in Portland, Oregon, there was a strong consensus that a committee be formed to define an open standard for such languages. The committee's purpose was to consolidate existing functional languages into a common one to serve as a basis for future research in functional-language design.|$|E
25|$|Mutual {{recursion}} is {{very common}} in the <b>functional</b> <b>programming</b> style, and is often used for programs written in LISP, Scheme, ML, and similar languages. In languages such as Prolog, mutual recursion is almost unavoidable.|$|E
25|$|When P is a {{predicate}} {{that for}} all X, P(X,Y) unifies Y with a single unique value, maplist(P, Xs, Ys) is equivalent to applying the map function in <b>functional</b> <b>programming</b> as Ys = map(Function, Xs).|$|E
40|$|AbstractThis paper {{deals with}} {{automated}} termination analysis of partial <b>functional</b> <b>programs,</b> that is, of <b>functional</b> <b>programs</b> {{which do not}} terminate for some input. We present a method to determine their domains (respectively non-trivial subsets of their domains) automatically. More precisely, for each <b>functional</b> <b>program</b> a termination predicate algorithm is synthesized that only returns true for inputs where the program is terminating. To ease subsequent reasoning about the generated termination predicates we also present a procedure for their simplification. Finally, we show that our method {{can also be used}} for automated termination analysis of imperative programs...|$|R
40|$|The {{deforestation}} of a <b>functional</b> <b>program</b> is {{a transformation}} which {{gets rid of}} intermediate data structures constructions that appear when two functions are composed. The descriptional composition, initially introduced by Ganzinger and Giegerich, is a deforestation method dedicated to the composition of two attribute grammars. This article presents a new functional deforestation technique, called symbolic composition, based on the descriptional composition mechanism, but extending it. An automatic translation from a <b>functional</b> <b>program</b> into an equivalent attribute grammar allows symbolic composition to be applied, and then {{the result can be}} translated back into a <b>functional</b> <b>program</b> (for instance, using the Jonhsson's transformation). This yields to a source to source <b>functional</b> <b>program</b> transformation. The resulting deforestation method provides a better deforestation than other existing functional techniques. Symbolic composition, completely dedicated to the declarative and descripti [...] ...|$|R
40|$|Thi s {{research}} aims to {{evaluated the}} religions teachers performance at Aliya Madrasa after attending training <b>functional</b> <b>programs</b> which managed by Balai Diklat Keagamaan on province of West Nusa Tenggara. This research {{important to do}} to seeing the change of religion teacher performance on Aliya Madrasa whether increase or decrease after attending training <b>functional</b> <b>program.</b> By using analysis of context, input, process, product (CIPP) this study had 4 findings, there are: (1) In pedagogic competency, personality, social and professional, the performances of religion teachers in Aliya Madrasa after attending training <b>functional</b> <b>programs</b> were include into fairly category. However in competition achivement the religion teacher is under expectation. (2) Performance of the religion teacher in Aliya Madrasa after attendingÂ Â  training <b>functional</b> <b>programs</b> give positive impact on students achievement. 3) The facilities of school like management, regulation and commitment of principal of Aliya Madrasa give positive impact to teacher performance, whereas support facilities in Aliya Madrasa is not support the increasing of religion teacher performance. (4) The Religion teachers performance after participated training <b>functional</b> <b>programs</b> gave positive impact to other teachers. </p...|$|R
25|$|In <b>functional</b> <b>programming</b> languages, such as Haskell and Scheme, loops can be {{expressed}} by using recursion or fixed point iteration rather than explicit looping constructs. Tail recursion is a special case of recursion which can be easily transformed to iteration.|$|E
25|$|Functors {{sometimes}} {{appear in}} <b>functional</b> <b>programming.</b> For instance, the programming language Haskell has a class Functor where fmap is a polytypic function used to map functions (morphisms on Hask, {{the category of}} Haskell types) between existing types to functions between some new types.|$|E
25|$|These {{concepts}} {{are discussed in}} a more precise way in <b>functional</b> <b>programming</b> and its foundational disciplines, lambda calculus and combinatory logic. Terminology varies between languages; some computer languages such as C define parameter and argument as given here, while Eiffel uses an alternative convention.|$|E
40|$|The {{correlation}} between test coverage and test effectiveness {{is important to}} justify the use of coverage in practice. Existing results on imperative programs mostly show that test coverage predicates effectiveness. However, since <b>functional</b> <b>programs</b> are usually structurally different from imperative ones, {{it is unclear whether}} the same result may be derived and coverage {{can be used as a}} prediction of effectiveness on <b>functional</b> <b>programs.</b> In this paper we report the first empirical study on the {{correlation between}} test coverage and test effectiveness on <b>functional</b> <b>programs.</b> We consider four types of coverage: as input coverages, statement coverage and expression coverage, and as oracle coverages, count of assertions and checked coverage. We also consider two types of effectiveness: raw effectiveness and normalized effectiveness. Our results are twofold. (1) In general the findings on imperative programs still hold on <b>functional</b> <b>programs,</b> warranting the use of coverage in practice. (2) On specific coverage criteria, the results may be unexpected or different from the imperative ones, calling for further studies on <b>functional</b> <b>programs...</b>|$|R
40|$|In {{this chapter}} we examine {{ways in which}} <b>{{functional}}</b> <b>programs</b> can be proved correct. For {{a number of reasons}} this is easier for functional than for impera-tive programs. In the simplest cases <b>functional</b> <b>programs</b> are equations, so the language documents itself, as it were. Beyond this we often have a higher-leve...|$|R
40|$|Two {{mappings}} from attribute grammars to lazy <b>functional</b> <b>programs</b> are defined. One {{of these}} mappings is an efficient implementation of attribute grammars. The other mapping yields inefficient programs. It is shown how some transformations of <b>functional</b> <b>programs</b> {{may be better}} understood by viewing the programs as inefficient implementations of attribute grammars...|$|R
25|$|Over the years, Perl 6 has {{undergone}} several alterations in its direction. The introduction of concepts from Python and Ruby were early influences, {{but as the}} Pugs interpreter {{was written in the}} Haskell programming language, many <b>functional</b> <b>programming</b> influences were absorbed by the Perl 6 design team.|$|E
25|$|Lambda {{calculus}} has {{applications in}} many different areas in mathematics, philosophy, linguistics, and computer science. Lambda calculus has {{played an important role}} in the development of the theory of programming languages. <b>Functional</b> <b>programming</b> languages implement the lambda calculus. Lambda calculus also is a current research topic in Category theory.|$|E
25|$|Whether a term is {{normalising}} or not, and {{how much}} work {{needs to be done}} in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in <b>functional</b> <b>programming</b> languages between eager evaluation and lazy evaluation.|$|E
40|$|We {{consider}} particular <b>functional</b> <b>programs</b> {{in which}} {{on the one}} hand the recursion is restricted to syntax-directed recursion {{and on the other hand}} simultaneous recursion and nesting of function calls in parameter positions of other functions is allowed. For such <b>programs</b> called syntax-directed <b>functional</b> <b>programs,</b> we formalize a compiler-based implementation of the callby -name computation strategy. The machine involved in this implementation, called syntaxdirected runtime-stack machine, is minimal in the sense that it computes exactly the class sdFun of functions which are expressible by syntax-directed <b>functional</b> <b>programs.</b> We verify this minimality property by showing a one-to-one correspondence between the implementation presented in this paper, and an interpreter-based implementation of syntax-directed <b>functional</b> <b>programs</b> on checking-tree nested-stack transducers. It is known from the literature that such transducers characterize in a formal sense the class sdFun. The work of thi [...] ...|$|R
5000|$|... #Subtitle level 3: On the VeriFun {{verification}} {{system for}} <b>functional</b> <b>programs</b> ...|$|R
40|$|Abstract. We {{introduce}} a new partial inversion technique for first-order <b>functional</b> <b>programs.</b> Our technique is simple, fully automatic, and (when it succeeds) returns a program that belongs to the same class of the original program, namely the class of inductively sequential programs (i. e., typical <b>functional</b> <b>programs).</b> Therefore, it forms an appropriate basis for developing a practically applicable transformation. ...|$|R
