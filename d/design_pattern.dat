2092|6470|Public
5|$|The {{specialized}} hardware of graphics processing units (GPU) {{is designed}} to accelerate rendering of 3-Dgraphics applications such as video games and can significantly outperform CPUs for some types of calculations. GPUs {{are one of the}} most powerful and rapidly growing computing platforms, and many scientists and researchers are pursuing general-purpose computing on graphics processing units (GPGPU). However, GPU hardware is difficult to use for non-graphics tasks and usually requires significant algorithm restructuring and an advanced understanding of the underlying architecture. Such customization is challenging, more so to researchers with limited software development resources. Folding@home uses the open source OpenMM library, which uses a bridge <b>design</b> <b>pattern</b> with two application programming interface (API) levels to interface molecular simulation software to an underlying hardware architecture. With the addition of hardware optimizations, OpenMM-based GPU simulations need no significant modification but achieve performance nearly equal to hand-tuned GPU code, and greatly outperform CPU implementations.|$|E
25|$|MonoCross, a {{cross-platform}} model–view–controller <b>design</b> <b>pattern</b> {{where the}} Model and Controller are shared across platforms and the Views are unique for each platform for an optimized User Interface. The framework requires Xamarin.iOS and Xamarin.Android.|$|E
25|$|The {{notes were}} {{commissioned}} by the then Central Bank of Ireland, in five denominations. The Central Bank held a limited competition in 1991 and invited nine Irish artists having decided on the theme itself previous to invitation. The designs of Robert Ballagh were chosen, and his designs were used in all the denominations to follow a unified <b>design</b> <b>pattern.</b>|$|E
40|$|The rapid {{evolution}} of <b>Design</b> <b>Patterns</b> has hampered the benefits gained from using <b>Design</b> <b>Patterns.</b> The {{increase in the}} number of <b>Design</b> <b>Patterns</b> makes a common vocabulary unmanageable and the tracing problem obscures the documentation that should be en-hanced by using <b>Design</b> <b>Patterns.</b> We present an analysis of the <b>Design</b> <b>Patterns</b> that will strongly reduce the number of Fundamen-tal <b>Design</b> <b>Patterns</b> and show how strong language abstractions can solve the tracing problem and thereby enhance the documentation. ...|$|R
40|$|The {{catalogue}} of <b>design</b> <b>patterns</b> from [Gamm 94] contains about twenty <b>design</b> <b>patterns</b> and their mutual relationships. In this paper, we organize these relationships into different categories and revise the <b>design</b> <b>patterns</b> and their relationships. We are then able {{to arrange the}} <b>design</b> <b>patterns</b> in different layers. The results simplify {{the understanding of the}} overall structure of the catalogue, thereby making it easier to classify other <b>design</b> <b>patterns,</b> and to apply these <b>design</b> <b>patterns</b> to software development...|$|R
40|$|Abstract. <b>Design</b> <b>patterns</b> are {{reusable}} proven {{solutions to}} frequently occurring design problems. To encourage software engineers to use <b>design</b> <b>patterns</b> effectively and correctly throughout the development process, <b>design</b> <b>patterns</b> should be classified and represented formally. In this paper, we apply Object Process Methodology (OPM) for representing and classifying <b>design</b> <b>patterns.</b> OPM enables concurrent {{representation of the}} structural and behavioral aspects of <b>design</b> <b>patterns</b> in a single and coherent view. Comparing OPM and UML models of seven popular <b>design</b> <b>patterns,</b> {{we found that the}} OPM models are more compact, comprehensible and expressive than their UML counterparts. Furthermore, the OPM models induce a straightforward classification of these <b>design</b> <b>patterns</b> into four groups: creational, structural composition, wrapper, and interaction <b>design</b> <b>patterns.</b> ...|$|R
25|$|In {{some regions}} of the country milk is offered along with {{crystallized}} sugar, rice pudding (kheer in local parlance). A special feature is of offering a lotus flower which is placed in a silver bowl. In front of this bowl, a rangoli (coloured <b>design</b> <b>pattern)</b> of snake is created on the floor with a brush made of wood or clay or silver or gold with sandalwood or turmeric paste as the paint. The <b>design</b> <b>pattern</b> will resemble a five hooded snake. Devotees then offer worship to this image on the floor. In villages, the anthills where the snakes are thought to reside, are searched. Incense is offered to the anthill as prayer along with milk (a myth of folk lore to feed milk to the snakes) to ensnare snakes {{to come out of the}} anthill. After this, milk is poured into the hole in the anthill as a libation to the snake god.|$|E
25|$|M101 {{has five}} {{prominent}} companion galaxies: NGC 5204, NGC 5474, NGC 5477, NGC 5585, and Holmberg IV. As stated above, the gravitational interaction between M101 and its satellites may have triggered {{the formation of}} the grand <b>design</b> <b>pattern</b> in M101. M101 has also probably distorted the companion galaxy NGC 5474. M101 and its companion galaxies comprise most or possibly all of the M101 Group.|$|E
500|$|The Iowa-class battleships were a {{class of}} six fast battleships ordered by the United States Navy in 1939 and 1940 to escort the Fast Carrier Task Forces that would operate in the Pacific Theater of World War II. Four were completed; two more were laid down but {{canceled}} in 1945 at war's end, and both hulls were scrapped in 1958. Like other third-generation American battleships, the Iowas followed the <b>design</b> <b>pattern</b> {{set forth in the}} preceding [...] and [...] battleships, which emphasized speed in addition to secondary and anti-aircraft batteries. Based on wartime experience, they were to serve as fast escorts for s.|$|E
40|$|<b>Design</b> <b>patterns</b> are {{of major}} {{interest}} to increase software quality and abstraction level. However, <b>design</b> <b>patterns</b> are di#- cult to choose, to apply, and to recover. We propose {{a set of}} tools to use <b>design</b> <b>patterns</b> in a round-trip fashion. We define a meta-model to describe <b>design</b> <b>patterns.</b> This meta-model is specifically oriented towards <b>design</b> <b>patterns</b> instantiation and detection. We develop a source-to-source transformation engine to modify the source code to comply with <b>design</b> <b>patterns</b> descriptions. Meanwhile, we use an explanationbased constraint solver to detect <b>design</b> <b>patterns</b> in source code from their descriptions. With these tools, we hope to o#er a mean to apply and to recover <b>design</b> <b>patterns</b> without overhead for the developers...|$|R
30|$|For the {{appropriate}} design of ArchReco we have introduced {{a number of}} ontologies for modelling the <b>Design</b> <b>Patterns</b> and the contextual elements in a uniformed way. A few years ago, {{the most commonly used}} <b>designed</b> <b>patterns</b> were the GoF <b>Design</b> <b>Patterns</b> (Gamma et al. 1995), which are still the fundamental <b>Design</b> <b>Patterns</b> that software engineers use. Over the last few years, <b>Design</b> <b>Patterns</b> became a common practice for several companies and individual engineers developed new <b>Design</b> <b>Patterns</b> and categorized them according to the domain the patterns are applied to. For example, repositories such as the yahoo ([URL] repository of <b>Design</b> <b>Patterns</b> for the UI/UX domain contain a number of patterns that can be applied in web based interfaces. Additionally, there are specific <b>Design</b> <b>Patterns</b> related to Data collection, Web Services, Mobile development and several other domain specific <b>Design</b> <b>Patterns.</b>|$|R
5000|$|Efforts {{have also}} been made to codify <b>design</b> <b>patterns</b> in {{particular}} domains, including use of existing <b>design</b> <b>patterns</b> as well as domain specific <b>design</b> <b>patterns.</b> Examples include user interface <b>design</b> <b>patterns,</b> information visualization, secure design, [...] "secure usability", Web design [...] and business model design.|$|R
2500|$|In {{functional}} programming, a monad is a <b>design</b> <b>pattern</b> {{that defines}} how functions, actions, inputs, and outputs {{can be used}} together to build generic types, [...] with the following organization: ...|$|E
2500|$|A <b>design</b> <b>pattern</b> is {{a general}} {{reusable}} solution to a commonly occurring problem in software design. [...] In Prolog, design patterns go under various names: skeletons and techniques, cliches, program schemata, and logic description schemata. [...] An alternative to design patterns is higher order programming.|$|E
2500|$|Some {{programming}} styles discourage mutual recursion, {{claiming that}} it can be confusing to distinguish the conditions which will return an answer from the conditions that would allow the code to run forever without producing an answer. Peter Norvig points to a <b>design</b> <b>pattern</b> which discourages the use entirely, stating: ...|$|E
40|$|Finding {{hypermedia}} <b>design</b> <b>patterns</b> {{is becoming}} a new trend in hypermedia design. However, as in other domains, especially in software engineering and objectoriented design, too much increase without control in proposing hypermedia <b>design</b> <b>patterns</b> is going against the purpose of <b>design</b> <b>patterns</b> that is to provide easily reusable solutions to identified problems. The {{reason is that the}} metaknowledge about hypermedia <b>design</b> <b>patterns</b> is not yet well organized. Since hypermedia engineering is by nature a multidimensional space, hypermedia <b>design</b> <b>patterns</b> may take their meaning according to several dimensions. Thereby this position paper proposes some directions for organizing the space of hypermedia <b>design</b> <b>patterns</b> and analyzing their use, thus promoting their effective use during design and possibly identifying not yet known <b>design</b> <b>patterns.</b> Our aim is to provide a basis of discussion for hypermedia <b>design</b> <b>patterns</b> description and use. KEY WORDS: <b>Design</b> <b>Patterns,</b> Pattern Language, Hyperme [...] ...|$|R
40|$|<b>Design</b> <b>patterns</b> {{are very}} useful in {{software}} engineering. We {{would like to}} automate {{as much as possible}} the use of <b>design</b> <b>patterns.</b> Thus, we need to formalize <b>design</b> <b>patterns.</b> We can formalize <b>design</b> <b>patterns</b> according to several distinct aspects: Intent, static structure, dynamic structure… Your work consists in: • Detailing the need to formalize <b>design</b> <b>patterns.</b> • Detailing the aspects according to which we can formalize <b>design</b> <b>patterns.</b> • Analyzing, for each possible aspect, previous researches, what we can do, and the limitations of the approaches. (End of the 30 hours theory.) • Representing and validating different <b>design</b> <b>patterns</b> according to different aspects, using the previously surveyed formalisms. (End of the 15 hours practice. ...|$|R
40|$|Abstract: Detection of {{instances}} of <b>design</b> <b>patterns</b> {{is useful for}} the software maintenance. This paper proposes a new framework for the automated detection {{of instances}} of <b>design</b> <b>patterns.</b> The framework uses a reengineering tool to analyze C++ source codes. Prolog is used to induce instances of <b>design</b> <b>patterns,</b> the elemental <b>design</b> <b>patterns</b> are also used as a intermediate results for the final target (<b>design</b> <b>patterns).</b> Two-phrased query makes the discovery process more efficient. ...|$|R
2500|$|Most ESB {{implementations}} {{contain a}} facility called [...] "mediation". For example, mediation flows {{are part of}} the WebSphere enterprise service bus intercept. Mule also supports mediation flows. Mediation flows modify messages that are passed between existing services and clients that use those services. A mediation flow mediates or intervenes to provide functions, such as message logging, data transformation, and routing, typically the functions can be implemented using the Interception <b>Design</b> <b>Pattern.</b>|$|E
2500|$|Pull parsing {{treats the}} {{document}} {{as a series}} of items read in sequence using the iterator <b>design</b> <b>pattern.</b> This allows for writing of recursive descent parsers in which the structure of the code performing the parsing mirrors the structure of the XML being parsed, and intermediate parsed results can be used and accessed as local variables within the methods performing the parsing, or passed down (as method parameters) into lower-level methods, or returned (as method return values) to higher-level methods. Examples of pull parsers include StAX in the Java programming language, XMLPullParser in Smalltalk, XMLReader in PHP, ElementTree.iterparse in Python, System.Xml.XmlReader in the [...]NET Framework, and the DOM traversal API (NodeIterator and TreeWalker).|$|E
5000|$|Proxy <b>design</b> <b>pattern</b> is {{also known}} as {{surrogate}} <b>design</b> <b>pattern.</b>|$|E
40|$|This work {{investigates the}} syntactical {{mechanisms}} used in <b>design</b> <b>patterns.</b> A taxonomy of patterns is presented, and a data set of <b>design</b> <b>patterns</b> is selected from this taxonomy. We argue that composition is the syntactical mechanism most used in <b>design</b> <b>patterns.</b> Several critera to classify and implement composition in our data set of <b>design</b> <b>patterns</b> are suggested. We postulate that {{the knowledge of}} <b>design</b> <b>patterns</b> should be incorporated into object-oriented languages using the analyzed syntactical mechanisms...|$|R
40|$|We {{present an}} {{empirical}} {{study of the}} impact of <b>design</b> <b>patterns</b> on quality attributes in the context of software maintenance and evolution. Our first hypothesis verifies software engineering lore: <b>design</b> <b>patterns</b> impact software quality positively. We show that, contrary to popular beliefs, <b>design</b> <b>patterns</b> in practice impact negatively several quality attributes, thus providing concrete evidence against common lore. We then study <b>design</b> <b>patterns</b> and object-oriented best practices by formulating a second hypothesis on the impact of these principles on quality. We show that results for some <b>design</b> <b>patterns</b> cannot be explained and conclude on the need for further studies on the relation between <b>design</b> <b>patterns</b> and object-oriented best practices. Thus, we bring further evidence that <b>design</b> <b>patterns</b> should be used with caution during development becaus...|$|R
30|$|Server Side Requirement shape - Used to {{describe}} features that {{will run the}} server. Recommended <b>Design</b> <b>patterns</b> are related <b>design</b> <b>patterns</b> used to implement functions in the server plane as e.g. GoF <b>Design</b> <b>patterns.</b>|$|R
50|$|In {{software}} engineering, a distributed <b>design</b> <b>pattern</b> is a <b>design</b> <b>pattern</b> {{focused on}} distributed computing problems.|$|E
50|$|The {{following}} documentation {{categories for}} the private class data <b>design</b> <b>pattern</b> follows the <b>design</b> <b>pattern</b> documentation style precedent set by the Gang of Four.|$|E
5000|$|Use When: [...] "Context of use" [...] is a {{critical}} component of the <b>design</b> <b>pattern.</b> This element helps people understand situations when the <b>design</b> <b>pattern</b> applies (and when it does not.) ...|$|E
40|$|<b>Design</b> <b>patterns</b> are problem-solution pairs {{that provide}} proven {{solutions}} for commonly occurring design problems. They {{are used to}} increase maintainability, reusability, comprehensibility and code quality. However, some studies have indicated relationship between <b>design</b> <b>patterns</b> and defects that doubts the claimed benefits of <b>design</b> <b>patterns.</b> In this paper we present an empirical study to evaluate the error proneness of <b>design</b> <b>patterns.</b> We extract the <b>design</b> <b>patterns</b> from open source software and map these patterns to post-release defects. Information on defects is extracted from version control repositories and bug databases. We have applied Mann-Whitney test to find the <b>design</b> <b>patterns</b> that are more error-prone than others...|$|R
40|$|<b>Design</b> <b>patterns</b> shall {{support the}} reuse of a {{software}} architecture in different application domains {{as well as}} the flexible reuse of components. In this paper, we propose <b>design</b> <b>patterns</b> for meta-search engines. We also introduce <b>design</b> <b>patterns</b> for common components of meta-search engines e. g. query interface generator, information extraction, result merger and result ranker. Presented <b>design</b> <b>patterns</b> for meta-search engines and their components are reusable, extendable and flexible. These <b>design</b> <b>patterns</b> accelerate the development process in meta-search domain and other related domains. Moreover, it promises higher quality of developed solutions. These <b>design</b> <b>patterns</b> also provide developers with a shared vocabulary for easy communication...|$|R
40|$|<b>Design</b> <b>patterns</b> offer {{numerous}} {{advantages for}} software development, but can often introduce inefficiency into the finished program. Program specialization can eliminate such overheads, but {{is most effective}} on large applications when targeted by the user to specific bottlenecks. To this end, we propose to consider program specialization and <b>design</b> <b>patterns</b> as complementary concepts. On the one hand, program specialization of objectoriented languages can optimize programs written using <b>design</b> <b>patterns.</b> On the other hand, <b>design</b> <b>patterns</b> provide information about the program structure that can guide specialization. Concretely, we propose specialization patterns, which encapsulate {{knowledge of how to}} apply program specialization to optimize uses of <b>design</b> <b>patterns.</b> We demonstrate the applicability of program specialization to uses of <b>design</b> <b>patterns,</b> by characterizing specialization opportunities for different kinds of <b>design</b> <b>patterns.</b> We document our approach using automatically obtai [...] ...|$|R
50|$|In {{computer}} programming, the adapter <b>design</b> <b>pattern</b> (often {{referred to}} as the wrapper pattern or simply a wrapper) is a <b>design</b> <b>pattern</b> for adapting one interface of a class into another interface that a client expects.|$|E
50|$|An {{important}} {{concept for}} objects is the <b>design</b> <b>pattern.</b> A <b>design</b> <b>pattern</b> provides a reusable template {{to address a}} common problem. The following object descriptions are examples {{of some of the}} most common design patterns for objects.|$|E
50|$|In {{computer}} science, {{a software}} <b>design</b> <b>pattern,</b> {{in the sense}} of a template, is a general solution to a problem in programming. A <b>design</b> <b>pattern</b> provides a reusable architectural outline that may speed the development of many computer programs.|$|E
30|$|Over {{the last}} few years, {{research}} papers related to the <b>Design</b> <b>Patterns</b> and their applications to real life software tools were significantly increased. <b>Design</b> <b>Patterns</b> are examined from many different perspectives such as the recovery of <b>Design</b> <b>Patterns</b> from existing software tools (Rasool and Streitferdt 2011), Formalization and Reasoning <b>Design</b> <b>Patterns</b> (Bayley and Zhu 2008; Hou and Hoover 2006), or generate <b>Design</b> <b>Patterns</b> repositories other than the well-known GoF patterns (Gamma et al. 1995) like for example the yahoo <b>design</b> <b>patterns</b> repository [URL] It {{is worth noting that}} in publications related to the recommendation algorithms for <b>Design</b> <b>Patterns</b> (Gomes et al. 2002; Guéhéneuc and Mustapha 2007; Weiss and Birukou 2007) we have not found applied recommendation algorithms that were used in software tools. It is also worth noting that there is not reported work where context was used as part of the recommendation mechanisms for the computation of recommendations for <b>Design</b> <b>Patterns.</b>|$|R
40|$|This thesis {{gives an}} {{overview}} and discusses how some chosen <b>design</b> <b>patterns</b> fit the Android environment, and it point out what dependencies the <b>design</b> <b>patterns</b> {{have on the}} Android system. There {{does not seem to}} be any related work of <b>design</b> <b>patterns</b> as applied to Android, so the research is novel and is done as an empirical experiment. The evaluation is therefore done in a subjective perspective where the author’s observations are presented. The research looks at how the chosen <b>design</b> <b>patterns</b> function when applied to Android, and it tries to adjust the <b>design</b> <b>patterns</b> to fit the Android system, if needed. The chosen <b>design</b> <b>patterns</b> are also put up against some criteria to evaluate them on a common ground. The result shows that most of the chosen <b>design</b> <b>patterns</b> are implementable in Android with some limitations, where it is dependency on the Android system that limit some <b>design</b> <b>patterns</b> from being fully implementable...|$|R
5000|$|<b>Design</b> <b>Patterns,</b> {{the book}} which {{gave rise to}} the study of <b>design</b> <b>patterns</b> in {{computer}} science ...|$|R
