1|13|Public
5000|$|Paramodulation is {{a related}} {{technique}} for reasoning on sets of clauses where the predicate symbol is equality. It generates all [...] "equal" [...] versions of clauses, except reflexive identities. The paramodulation operation takes a positive from clause, which must contain an <b>equality</b> <b>literal.</b> It then searches an into clause with a subterm that unifies with {{one side of}} the equality. The subterm is then replaced by {{the other side of the}} equality. The general aim of paramodulation is to reduce the system to atoms, reducing the size of the terms when substituting.|$|E
40|$|Abstract. We {{prove the}} {{completeness}} {{of the regular}} strategy of derivations for superposition-based calculi. The regular strategy was pioneered by Kanger in (Kan 63), who proposed that all equality inferences take place before all other steps in the proof. We show that the strategy is complete with the redundancy notions of tautology elimination and subsumption. The implication of our result is the completeness of non-standard selection functions by which in clauses that contain both <b>equality</b> and relational <b>literals,</b> only the <b>equality</b> <b>literals</b> (and all of them) are selected...|$|R
40|$|Abstract—The extensional {{theory of}} arrays {{is one of}} the most {{important}} ones for applications of SAT Modulo Theories (SMT) to hardware and software verification. Here we present a new T-solver for arrays in the context of the DPLL(T) approach to SMT. The main characteristics of our solver are: (i) no translation of writes into reads is needed, (ii) there is no axiom instantiation, and (iii) the T-solver interacts with the Boolean engine by asking to split on <b>equality</b> <b>literals</b> between indices. As far as we know, this is the first accurate description of an array solver integrated in a state-of-the-art SMT solver and, unlike most state-of-the-art solvers, it is not based on a lazy instantiation of the array axioms. Moreover, it is very competitive in practice, specially on problems that require heavy reasoning on array literals. I...|$|R
5000|$|... "We {{believe in}} the {{strength}} {{and the rule of}} the people; in government of the People, by the People and for the People. <b>Equality</b> is the <b>literal</b> meaning of the word Isocracy" ...|$|R
40|$|We {{present an}} {{approach}} to propagation based solving, Boolean equi-propagation, where constraints are modelled as propagators of information about <b>equalities</b> between Boolean <b>literals.</b> Propagation based solving applies this information {{as a form of}} partial evaluation resulting in optimized SAT encodings. We demonstrate for a variety of benchmarks that our approach results in smaller CNF encodings and leads to speed-ups in solving times...|$|R
40|$|The Altrurian Romances（ 1968 ）of William Dean Howells {{consists}} of three utopias: A Traveller from Altruria(1894), "The Letters of an Altrurian Traveller" (1893 - 94), and Through the Eye of the Needle (1907). The Altrurian traveller, Aristides Homos, visits the United States in 1892 and stays there {{for about a year}} and a half, visiting a New Hampshire mountain resort hotel, New York City and Chicago. These romances record Homos's criticisms of the social, political, and economic conditions of the industrial, capitalistic and "plutocratic" America. The Commonwealth of Altruria has attained the Utopian dream of brotherly <b>equality</b> through <b>literal</b> applications of the principles of "liberty, equality, and fraternity. " Howells uses Homos as his spokesman in such a way that Homos's account of his country implies every insulting criticism of America. By letting the Altrurian Homos and his American wife describe the conditions of Altruria where complete social, political, and economic equality has been attained, Howells effectively draws the people's attention to his call for social justice through return to the ideals of the Declaration of Independence and the Constitution，especially through the strict observance of the principles of "liberty, equality, and fraternity. ...|$|R
40|$|We {{present a}} {{modification}} to the paramodulation inference system, where semantic <b>equality</b> and non-equality <b>literals</b> are stored as local simplifiers with each clause. The local simplifiers are created when new clauses are generated and inherited by {{the descendants of}} that clause. Then the local simplifiers {{can be used to}} perform demodulation and unit simplification, if certain conditions are satisfied. This reduces the search space of the theorem proving procedure and the length of the proofs obtained. In fact, we show that for ground SLD resolution with any selection rule, any set of clauses has a polynomial length proof. Without this technique, proofs may be exponential. We show that this process is sound, complete, and compatible with deletion rules (e. g., demodulation, subsumption, unit simplification, and tautology deletion), which {{do not have to be}} modified to preserve completeness. We also show the relationship between this technique and model elimination...|$|R
40|$|We {{present an}} {{approach}} to propagation-based SAT encoding of combinatorial problems, Boolean equi-propagation, where constraints are modeled as Boolean functions which propagate information about <b>equalities</b> between Boolean <b>literals.</b> This information is then applied to simplify the CNF encoding of the constraints. A key factor is that considering only a small fragment of a constraint model at one time enables us to apply stronger, and even complete, reasoning to detect equivalent literals in that fragment. Once detected, equivalences apply to simplify the entire constraint model and facilitate further reasoning on other fragments. Equi-propagation in combination with partial evaluation and constraint simplification provide {{the foundation for a}} powerful approach to SAT-based finite domain constraint solving. We introduce a tool called BEE (Ben-Gurion Equi-propagation Encoder) based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of CNF encodings and subsequent speed-ups in SAT solving times. 1...|$|R
40|$|Abstract. BEE is a {{compiler}} which facilitates solving finite domain con-straints by encoding them to CNF {{and applying}} an underlying SAT solver. In BEE constraints are modeled as Boolean functions which prop-agate information about <b>equalities</b> between Boolean <b>literals.</b> This infor-mation is then applied {{to simplify the}} CNF encoding of the constraints. We term this process equi-propagation. A key factor is that considering only a small fragment of a constraint model at one time enables to ap-ply stronger, and even complete reasoning to detect equivalent literals in that fragment. Once detected, equivalences propagate to simplify the entire constraint model and facilitate further reasoning on other frag-ments. BEE is described in several recent papers: [20], [19] and [21]. In this paper, after a quick review of BEE, we elaborate on two undocu-mented details of the implementation: the hybrid encoding of cardinality constraints and complete equi-propagation. We then describe on-going work aimed to extend BEE to consider binary representation of numbers. ...|$|R
40|$|Article dans revue scientifique avec comité de lecture. We {{present a}} {{modification}} to the paramodulation inference system, where semantic <b>equality</b> and non-equality <b>literals</b> are stored as local simplifiers with each clause. The local simplifiers are created when new clauses are generated and inherited by {{the descendants of}} that clause. Then the local simplifiers {{can be used to}} perform demodulation and unit simplification, if certain conditions are satisfied. This reduces the search space of the theorem proving procedure and the length of the proofs obtained. In fact, we show that for ground SLD resolution with any selection rule, any set of clauses has a polynomial length proof. Without this technique, proofs may be exponential. We show that this process is sound, complete, and compatible with deletion rules (e. g., demodulation, subsumption, unit simplification, and tautology deletion), which {{do not have to be}} modified to preserve completeness. We also show the relationship between this technique and model elimination...|$|R
5000|$|In {{artificial}} intelligence, a fluent is {{a condition}} that can change over time. In logical approaches to reasoning about actions, fluents can be represented in first-order logic by predicates having an argument that depends on time. For example, the condition &ldquo;the box {{is on the table}}&rdquo;, if it can change over time, cannot be represented by a third argument is necessary to the predicate [...] to specify the time: [...] means that the box is on the table at time [...] This representation of fluents is modified in the situation calculus by using the sequence of the past actions in place of the current time. A fluent can also be represented by a function, dropping the time argument. For example, that the box is on the table can be represented by , where [...] is a function and not a predicate. In first order logic, converting predicates to functions is called reification; for this reason, fluents represented by functions are said to be reified. When using reified fluents, a separate predicate is necessary to tell when a fluent is actually true or not. For example, [...] means that the box is actually on the table at time , where the predicate [...] is the one that tells when fluents are true. This representation of fluents is used in the event calculus, in the fluent calculus, and in the features and fluents logics. Some fluents can be represented as functions in a different way. For example, the position of a box can be represented by a function [...] whose value is the object the box is standing on at time [...] Conditions that can be represented in this way are called functional fluents. Statements about the values of such functions can be given in first order logic with <b>equality</b> using <b>literals</b> such as [...] Some fluents are represented this way in the situation calculus.|$|R

