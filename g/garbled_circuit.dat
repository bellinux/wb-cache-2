103|93|Public
50|$|<b>Garbled</b> <b>circuit</b> is a {{cryptographic}} protocol {{that enables}} two-party secure computation {{in which two}} mistrusting parties can jointly evaluate a function over their private inputs without {{the presence of a}} trusted third party. Andrew Yao of Stanford University first proposed the protocol in 1986 to solve his famous Millionaires' Problem. The protocol is also known as Yao's protocol, Yao's <b>garbled</b> <b>circuit</b> protocol or simply the GC protocol in the cryptography literature. In the <b>garbled</b> <b>circuit</b> protocol, the function has to be described as a Boolean circuit.|$|E
5000|$|Alice {{sends the}} <b>garbled</b> <b>circuit</b> to Bob {{along with her}} {{encrypted}} input.|$|E
50|$|Here {{we study}} the one {{presented}} by Yao himself using the <b>garbled</b> <b>circuit</b> protocol.|$|E
40|$|In this paper, {{we propose}} a novel {{way to provide}} a fully {{homomorphic}} encryption service, namely by using <b>garbled</b> <b>circuits.</b> From a high level perspective, <b>garbled</b> <b>circuits</b> and fully homomorphic encryption, both aim at implementing complex computation on ciphertexts. We define a new cryptographic primitive named reusable garbled gate, which comes from the area of <b>garbled</b> <b>circuits,</b> then based on this new primitive we show {{that it is very}} easy to construct a fully homomorphic encryption. However, the instantiation of reusable garbled gates is rather difficult, in fact, we can only instantiate this new primitive based on indistinguishable obfuscation. Furthermore, reusable garbled gates can be a core component for constructing the reusable <b>garbled</b> <b>circuits,</b> which can reduce the communication complexity of them from O(n) to O(1). We believe that reusable garbled gates promise a new way to provide fully homomorphic encryption and reusable <b>garbled</b> <b>circuits</b> service fast. Peer ReviewedPostprint (author's final draft...|$|R
40|$|<b>Garbled</b> <b>circuits</b> play a {{key role}} in secure computation. Unlike {{previous}} work, which focused mainly on efficiency and automation aspects of secure computation, in this paper we focus on software modularity and scalability, considering very large circuits. Our main contribution is a virtual machine that dynamically loads hardware descriptions into memory and destructs them as soon as they are done computing. Our software also introduces a new technique for parallel evaluation of <b>garbled</b> <b>circuits.</b> The software is designed in a completely modular fashion, allowing developers to integrate <b>garbled</b> <b>circuits</b> through an API (Abstract Programming Interface), without having to modify the base code. We measure the performance of this architecture on several circuits with hundreds of millions of gates. To the best of our knowledge, these are the largest scalable secure computations done to date. ...|$|R
40|$|Secure multiparty {{computation}} {{allows for}} a set of users to evaluate a particular function over their inputs without revealing the information they possess to each other. Theoretically, this can be achieved using fully homomorphic encryption systems, but so far they remain in the realm of computational impracticability. An alternative is to consider secure function evaluation using homomorphic public-key cryptosystems or <b>Garbled</b> <b>Circuits,</b> the latter being a popular trend in recent times due to important breakthroughs. We propose a technique for computing the logsum operation using <b>Garbled</b> <b>Circuits.</b> This technique relies on replacing the logsum operation with an equivalent piecewise linear approximation, taking advantage of recent advances in efficient methods for both designing and implementing <b>Garbled</b> <b>Circuits.</b> We elaborate on how all the required blocks should be assembled in order to obtain small errors regarding the original logsum operation and very fast execution times...|$|R
50|$|Gennaro et al. {{defined a}} verifiable {{computation}} scheme for any function F using Yao’s <b>Garbled</b> <b>Circuit</b> {{combined with a}} fully homomorphic encryption system.|$|E
50|$|If one is {{considering}} malicious adversaries, further mechanisms to ensure correct behaviour {{of both parties}} need to be provided. By construction {{it is easy to}} show security for the sender, as all the receiver can do is to evaluate a <b>garbled</b> <b>circuit</b> that would fail to reach the circuit-output wires if he deviated from the instructions. The situation is very different on the sender's side. For example, he may send an incorrect <b>garbled</b> <b>circuit</b> that computes a function revealing the receiver's input. This would mean that privacy no longer holds, but since the circuit is garbled the receiver {{would not be able to}} detect this.|$|E
5000|$|In the <b>garbled</b> <b>circuit</b> protocol, we {{make use}} of {{oblivious}} transfer. In the oblivious transfer, a string is transferred between a sender and a receiver in the following way: a sender has two strings [...] and [...] The receiver chooses [...] and the sender sends [...] with the oblivious transfer protocol such that ...|$|E
40|$|<b>Garbled</b> <b>circuits</b> offer a {{powerful}} primitive for computation on a user’s personal data while keeping that data private. Despite recent improvements, constructing and evaluating circuits of any useful size remains expensive on the limited hardware resources of a smartphone, the primary computational device available to most users around the world. In this work, we {{develop a new}} technique for securely outsourcing the generation of <b>garbled</b> <b>circuits</b> to a Cloud provider. By outsourcing the circuit generation, {{we are able to}} eliminate the most costly operations from the mobile device, including oblivious transfers. After proving the security of our techniques in the malicious model, we experimentally demonstrate that our new protocol, built on this role reversal, decreases execution time by 98 % and reduces network costs by as much as 92 % compared to previous outsourcing protocols. In so doing, we demonstrate that the use of <b>garbled</b> <b>circuits</b> on mobile devices can be made nearly as practical as it is becoming for server-class machines. ...|$|R
40|$|Abstract. Secure {{function}} evaluation (SFE) on mobile devices, such as smartphones, creates compelling {{new applications}} such as privacypreserving bartering. Generating custom <b>garbled</b> <b>circuits</b> on smartphones, however, is infeasible {{for all but the}} most trivial problems due to the high memory overhead incurred. In this paper, we develop a new methodology of generating <b>garbled</b> <b>circuits</b> that is memory-efficient. Using the standard SFDL language for describing secure functions as input, we design a new pseudo-assembly language (PAL) and a template-driven compiler that generates circuits which can be evaluated with Fairplay. We deploy this compiler for Android devices and demonstrate that a large new set of circuits can now be generated on smartphones, with memory overhead for the set intersection problem reduced by 95. 6 % for the 2 -set case. We develop a password vault application to show how runtime generation of circuits can be used in practice. We also show that our circuit generation techniques can be used in conjunction with other SFE optimizations. These results demonstrate the feasibility of generating <b>garbled</b> <b>circuits</b> on mobile devices while maintaining high-level function specification. ...|$|R
40|$|Abstract. In secure two-party {{computation}} protocols, the cut-and-choose {{paradigm is}} used to prevent the malicious party who constructs the <b>garbled</b> <b>circuits</b> from cheating. In previous realization of the cut-and-choose technique on the <b>garbled</b> <b>circuits,</b> the delivery of the random keys is divided into multiple stages. Thus, the round complexity is high and the consistency of cut-and-choose challenge should be proved. In this paper, we introduce a new primitive called cut-and-choose bilateral oblivious transfer, which transfers all necessary keys of <b>garbled</b> <b>circuits</b> in one process. Specifically, in our oblivious transfer protocol, the sender inputs two pairs (x 0, x 1), (y 0, y 1) and a bit τ; the receiver inputs two bits σ and j. After the protocol execution, the receiver obtains xτ, yσ for j = 1, and x 0, x 1, y 0, y 1 for j = 0. By the introduction of this new primitive, the round complexity of secure two-party computation protocol can be decreased; the cut-and-choose challenge j {{is no need to}} be opened anymore, therefore the consistency proof of j is omitted. In addition, the primitive is of independent interest and could be useful in many cut-and-choose scenarios...|$|R
5000|$|Yao's <b>garbled</b> <b>circuit</b> {{protocol}} for two-party computation [...] only provided security against passive adversaries. 2PC protocols that are secure against active adversaries were proposed by Lindell and Pinkas, Ishai, Prabhakaran and Sahai [...] and Nielsen and Orlandi.Another solution for this problem, that explicitly works with committed input was proposed by Jarecki and Shmatikov.|$|E
50|$|Free XOR {{optimization}} implies {{an important}} point {{that the amount of}} data transfer (communication) and number of encryption and decryption (computation) of the <b>garbled</b> <b>circuit</b> protocol relies only on the number of AND gates in the Boolean circuit not the XOR gates. Thus, between two Boolean circuits representing the same function, the one with the smaller number of AND gates is preferred.|$|E
50|$|Lindell {{has worked}} on various aspects of secure computation, with his main {{contributions}} focusing on {{the examination of the}} Yao <b>garbled</b> <b>circuit</b> construction. His most cited work is a joint paper with Benny Pinkas onprivacy preserving data mining in which the use of secure computation was proposed for performing data mining algorithms; in particular the ID3 algorithm. More recent work has focused on the first proof of security for the basic Yao protocol, on the design of two-party protocols which are secure against active adversaries, and the introduction of the concept of covert adversarial models.|$|E
40|$|We {{construct}} the first schemes that allow a client to privately outsource arbitrary program executions {{to a remote}} server while ensuring that: (I) the client’s work is small and essentially independent {{of the complexity of}} the computation being outsourced, and (II) the server’s work is only proportional to the run-time of the computation on a random access machine (RAM), rather than its potentially much larger circuit size. Furthermore, our solutions are non-interactive and have the structure of reusable garbled RAM programs, addressing an open question of Lu and Ostrovsky (Eurocrypt 2013). We also construct schemes for an augmented variant of the above scenario, where the client can initially outsource a large private and persistent database to the server, and later outsource arbitrary program executions with read/write access to this database. Our solutions are built from non-reusable garbled RAM in conjunction with new types of reusable <b>garbled</b> <b>circuits</b> that are more efficient than prior solutions but only satisfy weaker security. For the basic setting without a persistent database, we can instantiate the required type of reusable <b>garbled</b> <b>circuits</b> from indistinguishability obfuscation or from functional encryption for circuits as a black-box. For the more complex setting with a persistent database, we can instantiate the required type of reusable <b>garbled</b> <b>circuits</b> using stronger notions of obfuscation. It remains an open problem to instantiate these new types of reusable <b>garbled</b> <b>circuits</b> under weaker assumptions, possibly avoiding obfuscation altogether. We also give several extensions of our results and techniques to achieve: schemes with efficiency proportional to the input-specific RAM run-time, verifiable outsourced RAM compu-tation, functional encryption for RAMs, and a candidate obfuscator for RAMs. ...|$|R
40|$|Abstract We {{present a}} new {{protocol}} for maliciously secure two-party computation based on cut-and-choose of <b>garbled</b> <b>circuits</b> using the recent idea of “forge-and-loose”, which eliminates around a factor 3 of <b>garbled</b> <b>circuits</b> {{that needs to}} be constructed and evaluated. Our protocol introduces a new way to realize the “forge-and-loose” approach, which avoids an auxiliary secure two-party computation protocol, does not rely on any number theoretic assumptions and parallelizes well in a same instruction, multiple data (SIMD) framework. With this approach we prove our protocol universally composable-secure against a malicious adversary assuming access to oblivious transfer, commitment and coin-tossing functionalities in the random oracle model. Finally, we construct, and benchmark, a SIMD implementation of this protocol using a GPU as a massive SIMD device. The findings compare favorably with all previous implementations of maliciously secure, two-party com-putation. ...|$|R
40|$|<b>Garbled</b> <b>circuits,</b> {{introduced}} by Yao {{in the mid}} 80 s, allow computing a function f on an input x without leaking anything about f or x besides f(x). <b>Garbled</b> <b>circuits</b> found numerous applications, but every known construction suffers from one limitation: it offers no security if used on multiple inputs x. In this paper, we construct {{for the first time}} reusable <b>garbled</b> <b>circuits.</b> The key building block is a new succinct single-key functional encryption scheme. Functional encryption is an ambitious primitive: given an encryption Enc(x) of a value x, and a secret key sk_f for a function f, anyone can compute f(x) without learning any other information about x. We construct, for the first time, a succinct functional encryption scheme for any polynomial-time function f where succinctness means that the ciphertext size does not grow with the size of the circuit for f, but only with its depth. The security of our construction is based on the intractability of the Learning with Errors (LWE) problem and holds as long as an adversary has access to a single key sk_f (or even an a priori bounded number of keys for different functions). Building on our succinct single-key functional encryption scheme, we show several new applications in addition to reusable <b>garbled</b> <b>circuits,</b> such as a paradigm for general function obfuscation which we call token-based obfuscation, homomorphic encryption for a class of Turing machines where the evaluation runs in input-specific time rather than worst-case time, and a scheme for delegating computation which is publicly verifiable and maintains the privacy of the computation. Natural Sciences and Engineering Research Council of Canada (NSERC Discovery Grant) United States. Defense Advanced Research Projects Agency (DARPA award FA 8750 - 11 - 2 - 0225) United States. Defense Advanced Research Projects Agency (DARPA award N 66001 - 10 - 2 - 4089) National Science Foundation (U. S.) (NSF award CNS- 1053143) National Science Foundation (U. S.) (NSF award IIS- 1065219) Google (Firm...|$|R
50|$|The two party {{setting is}} {{particularly}} interesting, {{not only from}} an applications perspective but also because special techniques can be applied in the two party setting which do not apply in the multi-party case. Indeed, secure multi-party computation (in fact the restricted case of secure function evaluation, where only a single function is evaluated) was first presented in the two-party setting. The original work is often cited as being {{from one of the}} two papers of Yao; although the papers do not actually contain what is now known as Yao's <b>garbled</b> <b>circuit</b> protocol.|$|E
5000|$|Alice (garbler) encrypts the Boolean circuit in {{this step}} {{to obtain a}} <b>garbled</b> <b>circuit.</b> Alice assigns two {{randomly}} generated strings called labels to each wire in the circuit: one for Boolean semantic 0 and one for 1. (The label is k-bit long where k the security parameter and is usually set to 128.) Next, She goes to all the gates in the circuit and replace 0 and 1 in the truth tables with the corresponding labels. The table below shows the truth table for an AND gate with two inputs: [...] and output : ...|$|E
50|$|The {{function}} F {{should be}} {{represented as a}} Boolean circuit on which the key generation algorithm would be applied. The key generation algorithm runs Yao’s garbling procedure over this Boolean circuit to compute the public and secret keys. The public key (PK) is composed of all the ciphertexts that represent the <b>garbled</b> <b>circuit,</b> and the secret key (SK) is composed of all the random wire labels. The generated secret key is then used in the problem generation algorithm. This algorithm first generates {{a new pair of}} public and secret keys for the homomorphic encryption scheme, and then uses these keys with the homomorphic scheme to encrypt the correct input wires, represented as the secret key of the <b>garbled</b> <b>circuit.</b> The produced ciphertexts represent the public encoding of the input (σx) that is given to the worker, while the secret key (τx) is kept private by the client. After that, the worker applies the computation steps of the Yao’s protocol over the ciphertexts generated by the problem generation algorithm. This is done by recursively decrypting the gate ciphertexts until arriving to the final output wire values (σy). The homomorphic properties of the encryption scheme enable the worker to obtain an encryption of the correct output wire. Finally, the worker returns the ciphertexts of the output to the client who decrypts them to compute the actual output y = F(x) or ⊥.|$|E
3000|$|... 2), where n is {{the size}} of matrix and t is the {{threshold}} in Shamir’s secret sharing scheme. Based on Yao’s <b>Garbled</b> <b>Circuits</b> and fully homomorphic encryption scheme, verifiably non-interactive outsourced computation for any function was proposed in [13], however, client needs to do an expensive preprocessing stage, and his computation complexity is related {{to the size of the}} Boolean circuit representing function.|$|R
40|$|Abstract. Non-interactive verifiable {{outsourced}} computation {{enables a}} computationally weak client to outsource the computation of a function f on input x {{to a more}} powerful but untrusted server, who will return {{the result of the}} function evaluation as well as a proof that the computation is performed correctly. A basic requirement of a verifiable outsourced computation scheme is that the client should invest less time in prepar-ing the inputs and verifying the proof than computing the function by himself. One of the best solutions of such non-interactive schemes are based on Yao’s <b>garble</b> <b>circuit</b> and full homomorphic encryption, which leads to invest poly(T) running time in offline stage and poly(logT) time in online stage of the client, where T is the time complexity to compute f. In this paper, we’ll present a scheme which does not need to use <b>garble</b> <b>circuit,</b> but to use a very simple technique to confuse the function we are going to compute, and only invests poly(logT) running time in the offline stage...|$|R
40|$|Abstract. <b>Garbled</b> <b>circuits</b> is a {{cryptographic}} technique, {{which has}} been used among other things for the con-struction of two and three-party secure computation, private function evaluation and secure outsourcing. Garbling schemes is a primitive which formalizes the syntax and security properties of <b>garbled</b> <b>circuits.</b> We dene a gener-alization of garbling schemes called reactive garbling schemes. We consider functions and garbled functions taking multiple inputs and giving multiple outputs. Two garbled functions can be linked together: an encoded output of one garbled function can be transformed into an encoded input of the other garbled function without commu-nication between the parties. Reactive garbling schemes also allow partial evaluation of garbled functions even when {{only some of the}} encoded inputs are provided. It is possible to further evaluate the linked garbled functions when more garbled inputs become available. It is also possible to later garble more functions and link them to the ongoing garbled evaluation. We provide rigorous denitions for reactive garbling schemes. We dene a new notion of security for reactive garbling schemes called condentiality. We provide both simulation based and in-distinguishability based notions of security. We also show that the simulation based notion of security implies the indistinguishability based notion of security. We present an instantiation of reactive garbling schemes. We present an application of reactive garbling schemes to reactive two-party computation secure against a malicious adversary. We demonstrate how garbling schemes can be used to give abstract black-box descriptions and proof of several advanced applications of <b>garbled</b> <b>circuits</b> in the literature, including Minilego and Lindell’s forge-and-loose technique. ...|$|R
50|$|Yao {{explained}} how to garble a circuit (hide its structure) so that two parties, sender and receiver, can learn {{the output of}} the circuit and nothing else. At a high level, the sender prepares the <b>garbled</b> <b>circuit</b> and sends it to the receiver, who obliviously evaluates the circuit, learning the encodings corresponding to both his and the senders output. He then just sends back the senders encodings, allowing the sender to compute his part of the output. The sender sends the mapping from the receivers output encodings to bits to the receiver, allowing the receiver to obtain their output.|$|E
50|$|In more detail, the <b>garbled</b> <b>circuit</b> is {{computed}} as follows. The {{main ingredient}} is a double-keyed symmetric encryption scheme. Given a {{gate of the}} circuit, each possible value of its input wires (either 0 or 1) is encoded with a random number (label). The values resulting from {{the evaluation of the}} gate at each of the four possible pair of input bits are also replaced with random labels. The garbled truth table of the gate consists of encryptions of each output label using its inputs labels as keys. The position of these four encryptions in the truth table is randomized so no information on the gate is leaked.|$|E
50|$|One of {{the main}} issues when working with Yao-based {{protocols}} is that the function to be securely evaluated (which could be an arbitrary program) must be represented as a circuit, usually consisting of XOR and AND gates. Since most real-world programs contain loops and complex data structures, this is a highly non-trivial task. The Fairplay system was the first tool designed to tackle this problem. Fairplay comprises two main components. The first of these is a compiler enabling users to write programs in a simple high-level language, and output these programs in a Boolean circuit representation. The second component can then garble the circuit and execute a protocol to securely evaluate the <b>garbled</b> <b>circuit.</b> As well as two-party computation based on Yao's protocol, Fairplay can also carry out multi-party protocols. This is done using the BMR protocol, which extends Yao's passively secure protocol to the active case.|$|E
40|$|Secure two-party {{computation}} allows two untrusting {{parties to}} jointly compute an arbitrary function on their respective private inputs while revealing no information beyond the outcome. Existing cryptographic compilers can automatically generate secure computation protocols from high-level specifications, but are often {{limited in their}} use and efficiency of generated protocols as {{they are based on}} either <b>garbled</b> <b>circuits</b> or (additively) homomorphic encryption only. In this paper we present TASTY, a novel tool for automating, i. e., describing, generating, executing, benchmarking, and comparing, efficient secure two-party computation protocols. TASTY is a new compiler that can generate protocols based on homomorphic encryption and efficient <b>garbled</b> <b>circuits</b> as well as combinations of both, which often yields the most efficient protocols available today. The user provides a high-level description of the computations to be performed on encrypted data in a domain-specific language. This is automatically transformed into a protocol. TASTY provides most recent techniques and optimizations for practical secure two-party computation with low online latency. Moreover, it allows to efficiently evaluate circuits generated by the well-known Fairplay compiler. We use TASTY to compare protocols for secure multiplication based on homomorphic encryption with those based on <b>garbled</b> <b>circuits</b> and highly efficient Karatsuba multiplication. Further, we show how TASTY improves the online latency for securely evaluating the AES functionality by an order of magnitude compared to previous software implementations. TASTY allows to automatically generate efficient secure protocols for many privacy-preserving applications where we consider the use cases for private set intersection and face recognition protocols...|$|R
30|$|Homomorphic cryptosystems can be {{used for}} secure {{distance}} computation [12, 13], e.g., in the context of image retrieval [14], fingerprint matching [15], and face recognition [16]. Kolesnikov et al. [17] combines homomorphic encryption for computing distances with <b>Garbled</b> <b>circuits</b> for choosing the point having the minimum distance to the query point. We provide a detailed comparison between our approach and additive homomorphic cryptosystems in Section 4.|$|R
40|$|Abstract. Two of {{the major}} {{branches}} in secure multi-party computation research are secret shar-ing and <b>garbled</b> <b>circuits.</b> This work succeeds in combining these to enable seamlessly switching to the technique more efficient for the required functionality. As an example, we add garbled cir-cuits based IEEE 754 floating-point numbers to a secret sharing environment achieving very high efficiency and the first, to our knowledge, fully IEEE 754 compliant secure floating-point imple-mentation. ...|$|R
50|$|More recently, {{there has}} been a focus on highly {{parallel}} implementations based on garbled circuits, designed to be run on CPUs with many cores. Kreuter, et al. describe an implementation running on 512 cores of a powerful cluster computer. Using these resources they could evaluate the 4095-bit edit distance function, whose circuit comprises almost 6 billion gates. To accomplish this they developed a custom, better optimized circuit compiler than Fairplay and several new optimizations such as pipelining, whereby transmission of the <b>garbled</b> <b>circuit</b> across the network begins {{while the rest of the}} circuit is still being generated. The time to compute AES was reduced to 1.4 seconds per block in the active case, using a 512-node cluster machine, and 115 seconds using one node. shelat and Shen improve this, using commodity hardware, to 0.52 seconds per block. The same paper reports on a throughput of 21 blocks per second, but with a latency of 48 seconds per block.|$|E
40|$|Abstract. We describe, and implement, a maliciously secure {{protocol}} for two-party computation {{in a parallel}} computational model. The protocol is based on cut-and-choose of Yao’s <b>garbled</b> <b>circuit</b> and an efficient oblivious transfer extension. The implementation is done using CUDA and yields fast results in a financially feasible and practical setting by using a consumer grade CPU and GPU. Our protocol introduces a novel construction in order to verify consistency of the <b>garbled</b> <b>circuit</b> constructor’s input in a parallel and maliciously secure setting. ...|$|E
40|$|Yao’s <b>garbled</b> <b>circuit</b> {{construction}} transforms a {{boolean circuit}} C: { 0, 1 } n → { 0, 1 } m into a “garbled circuit ” Ĉ along with n pairs of k-bit keys, {{one for each}} input bit, such that Ĉ together with the n keys corresponding to an input x reveal C(x) and no additional information about x. The <b>garbled</b> <b>circuit</b> construction is a central tool for constant-round secure computation and has several other applications. Motivated by these applications, we suggest an efficient arithmetic variant of Yao’s original construction. Our construction transforms an arithmetic circuit C: Zn → Zm over integers from a bounded (but possibly exponential) range into a <b>garbled</b> <b>circuit</b> Ĉ along with n affine functions Li: Z → Zk such that Ĉ together with the n integer vectors Li(xi) reveal C(x) and no additional information about x. The security of our construction relies on the intractability of the learning with errors (LWE) problem. ...|$|E
40|$|We {{present a}} high-assurance {{software}} stack for secure function evaluation (SFE). Our stack {{consists of three}} components: i. a verified compiler (CircGen) that translates C programs into Boolean circuits; ii. a verified implementation of Yao’s SFE protocol based on <b>garbled</b> <b>circuits</b> and oblivious transfer; and iii. transparent application integration and communications via FRESCO, an open-source framework for secure multiparty computation (MPC). CircGen is a general purpose tool that builds on CompCert, a verified optimizing compiler for C. It {{can be used in}} arbitrary Boolean circuit-based cryptography deployments. The security of our SFE protocol implementation is formally verified using EasyCrypt, a tool-assisted framework for building high-confidence cryptographic proofs, and it leverages a new formalization of <b>garbled</b> <b>circuits</b> based on the framework of Bellare, Hoang, and Rogaway (CCS 2012). We conduct a practical evaluation of our approach, and conclude that it is competitive with state-of-the-art (unverified) approaches. Our work provides concrete evidence of the feasibility of building efficient, verified, implementations of higher-level cryptographic systems. All our development is publicly available...|$|R
40|$|We {{propose a}} new two-party {{computation}} protocol using Yao’s <b>garbled</b> <b>circuits,</b> which is {{secure in the}} case of malicious behavior. To illustrate the need for the new protocol, we first discuss security issues of three existing protocols for secure two-party computation using <b>garbled</b> <b>circuits,</b> {{in the case of}} malicious behavior. The first is a protocol by Pinkas (Eurocrypt 2003), and the other two are the committed-input scheme and the k-leaked model, both presented by Mohassel and Franklin (PKC 2006). We address security flaws in all schemes, which allow leaking of information on the private inputs. In the k-leaked model leaking of some information is permitted if a participant is cheating, but then the honest participant should be aware of it. We show {{that this is not the}} case. After discussing these security issues of the known schemes, we describe our new protocol. It is based on the protocol by Pinkas, and the correction of the flaw of the scheme by Pinkas makes our protocol not only more secure, but also more efficient. We provide a detailed informal security analysis of our new protocol...|$|R
40|$|International audienceWe {{present a}} high-assurance {{software}} stack for secure function evaluation (SFE). Our stack {{consists of three}} components: i. a verified compiler (CircGen) that translates C programs into Boolean circuits; ii. a verified implementation of Yao's SFE protocol based on <b>garbled</b> <b>circuits</b> and oblivious transfer; and iii. transparent application integration and communications via FRESCO, an open-source framework for secure multiparty computation (MPC). CircGen is a general purpose tool that builds on CompCert, a verified optimizing compiler for C. It {{can be used in}} arbitrary Boolean circuit-based cryptography deployments. The security of our SFE protocol implementation is formally verified using EasyCrypt, a tool-assisted framework for building high-confidence cryptographic proofs, and it leverages a new formalization of <b>garbled</b> <b>circuits</b> based on the framework of Bellare, Hoang, and Rogaway (CCS 2012). We conduct a practical evaluation of our approach, and conclude that it is competitive with state-of-the-art (unverified) approaches. Our work provides concrete evidence of the feasibility of building efficient, verified, implementations of higher-level cryptographic systems. All our development is publicly available...|$|R
