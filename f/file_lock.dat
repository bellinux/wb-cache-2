12|220|Public
6000|$|This {{morning it}} was {{revealed}} to him {{that it had been}} too easy to open the <b>file.</b> <b>Lock</b> it, that was the thing! Inspired, he rushed out and locked up his cigars, his cigarettes, and even his box of safety matches; and the key to the file drawer he hid in his desk. But the crusading passion of it made him so tobacco-hungry that he immediately recovered the key, walked with forbidding dignity to the file, took out a cigar and a match--"but only one match; if ole cigar goes out, it'll by golly have to stay out!" [...] Later, when the cigar did go out, he took one more match from the file, and when a buyer and a seller came in for a conference at eleven-thirty, naturally he had to offer them cigars. His conscience protested, [...] "Why, you're smoking with them!" [...] but he bullied it, [...] "Oh, shut up! I'm busy now. Of course by-and-by--" [...] There was no by-and-by, yet his belief that he had crushed the unclean habit made him feel noble and very happy. When he called up Paul Riesling he was, in his moral splendor, unusually eager.|$|E
5000|$|The SIGLOST {{signal is}} sent to a process when a <b>file</b> <b>lock</b> is lost.|$|E
50|$|With Windows File Protection active, {{replacing}} or deleting {{a system}} file {{that has no}} <b>file</b> <b>lock</b> to prevent it getting overwritten causes Windows immediately and silently to restore the original copy of the file. The original version of the file is restored from a cached folder which contains backup copies of these files. The Windows NT family uses the cached folder %WinDir%\System32\Dllcache. Windows Me caches its entire set of compressed cabinet setup files and stores them in the %Systemroot%\Options\Install folder.|$|E
50|$|Poor use of <b>file</b> <b>locks,</b> {{like any}} {{computer}} lock, {{can result in}} poor performance or in deadlocks. <b>File</b> <b>locking</b> may also refer to additional security applied by a computer user either by using Windows security, NTFS permissions or by installing a third party <b>file</b> <b>locking</b> software.|$|R
25|$|<b>File</b> <b>locking</b> for unmergeable <b>files</b> ("reserved checkouts").|$|R
5000|$|Provides {{complete}} UNIX/POSIX <b>file</b> semantics. (<b>File</b> <b>locking,</b> etc.) ...|$|R
40|$|The {{concurrency}} control lock (e. g. <b>file</b> <b>lock,</b> table lock) {{has long been}} used as a canonical example of a covert channel in a database system. Locking is a fundamental {{concurrency control}} technique used in many kinds of computer systems besides database systems. Locking is generally considered to be interfering and hence unsuitable for multilevel systems. In this paper we show how such locks can be used for concurrency control, without introducing covert channels. 1...|$|E
40|$|Abstract. Distributed file systems use <b>file</b> <b>lock</b> {{mechanism}} to ensure consistency when the shared data are accessed by multiple nodes. In this paper, using the feature of distributed systems {{that the same}} file would be accessed frequently and the advantage of high concurrency of range lock, the semi-preemptible range lock for pNFS is proposed. Clients locally cache the finer-grained locks for ranges of files they hold. Clients retain or cache range locks even without the file instances. When an access lock is cached, a client answers some requests without a server message, improving performance by exploiting locality. Simulation {{results indicate that the}} proposed locking mechanism can effectively increase concurrency and decrease the communication cost of pNFS...|$|E
40|$|Many {{large-scale}} production applications often have very long executions times and require periodic data checkpoints {{in order to}} save the state of the computation for program restart and/or tracing application progress. These write-only operations often dominate the overall application runtime, which makes them a good optimization target. Existing approaches for write-behind data buffering at the MPI I/O level have been proposed, but challenges still exist for addressing system-level I/O issues. We propose a twostage write-behind buffering scheme for handing checkpoint operations. The first-stage of buffering accumulates write data for better network utilization and the second-stage of buffering enables the alignment for the write requests to the file stripe boundaries. Aligned I/O requests avoid <b>file</b> <b>lock</b> contention that can seriously degrade I/O performance. We present our performance evaluation using BTIO benchmarks on both GPFS and Lustre file systems. With the twostage buffering, the performance of BTIO through MPI independent I/O is significantly improved and even surpasses that of collective I/O. 1...|$|E
5000|$|Document Management (including Version Control and <b>File</b> <b>Locking</b> mechanisms) ...|$|R
5000|$|A file may be [...] "open", [...] "not open", or [...] "waiting for open" [...] and [...] "not locked", [...] "locked for read", [...] "locked for modify", [...] "locked for destroy", [...] "waiting for read", [...] "waiting for modify", or [...] "waiting for destroy". A file's open {{status is}} {{independent}} of its lock status. <b>Locking</b> a <b>file</b> for modification also <b>locks</b> the <b>file</b> for reading and <b>locking</b> a <b>file</b> for destroying also <b>locks</b> the <b>file</b> for modification and reading. Any number of tasks can have a <b>file</b> <b>locked</b> for reading {{at any given time}}, but only one task can have a <b>file</b> <b>locked</b> for modification at any given time and then only if no task has the <b>file</b> <b>locked</b> for reading, or locked for destroying. Only one task can have a <b>file</b> <b>locked</b> for destroying at any given time, and then only if no task has the <b>file</b> open, <b>locked</b> for reading, or locked for modification.|$|R
5000|$|... 1986 - db_VISTA version 2 is released, {{adding a}} {{portable}} (<b>file</b> <b>locks</b> {{stored in a}} <b>lock</b> <b>file),</b> multi-user DBMS with transaction level database consistency.|$|R
40|$|The {{concurrency}} control lock (e. g. <b>file</b> <b>lock,</b> table lock) {{has long been}} used as a canonical example of a covert channel in a database system. Locking is a fundamental {{concurrency control}} technique used in many kinds of computer systems besides database systems. Locking is generally considered to be interfering and hence unsuitable for multilevel systems. In this paper we show how such locks can be used for concurrency control, without introducing covert channels. 1. Introduction A database system is a software system that provides a collection of predefined operations with three features: 1) efficient management of large amounts of persistent data (the database), 2) transaction management for transactions composed of those operations on the data (concurrency control, atomicity, and recovery from failure), and 3) a data model that provides a simple abstraction for understanding how the predefined operations and data interact. Our concern is with the second of these features, transactio [...] ...|$|E
40|$|While the I/O {{functions}} {{described in}} the MPI standard included shared file pointer support from the beginning, the performance and portability of these functions have been subpar at best. ROMIO [1], which provides the MPI-IO functionality for most MPI libraries, to this day uses a separate file to manage the shared file pointer. This file provides the shared location that holds the cur-rent value of the shared file pointer. Unfortunately, each access to the shared file pointer involves <b>file</b> <b>lock</b> management and updates to the file contents. Further-more, support for shared file pointers is not universally available because few file systems support native shared file pointers [5] and a few file systems do not support file locks [3]. Application developers rarely use shared file pointers, even though many ap-plications can benefit from this file I/O capability. These applications are typi-cally loosely coupled and rarely exhibit application-wide synchronization. Exam-ples include application tracing toolkits [8, 4] and many-task computing applica...|$|E
40|$|Part 8 : High Performance Computing and BigDataInternational audienceThe Unified Model (UM) {{is a model}} {{produced}} by the UK MetOffice for Numerical Weather Prediction (NWP) and climate simulation. It is used extensively by various university, government and other research organizations on the large supercomputer hosted at the National Computing Infrastructure (NCI). A 3 -year collaboration between NCI, the Australian Bureau of Meteorology and Fujitsu is underway to address performance and scalability issues in the UM on NCI’s supercomputer, Raijin. IO performance in the UM is the most dominant factor in its overall performance. The IO server approach employed is sophisticated and requires proper calibration to achieve acceptable performance. Global synchronization and <b>file</b> <b>lock</b> contention {{is a problem that}} can be remedied with simple MPI global collective calls. Complimentary IO strategies, such as MPI-IO and directed IO, are being investigated for implementation. The OpenMP implementation employed in the UM is investigated, and is found to have inefficiencies that are detrimental to the load balance of the model. Only loop-wise parallelism is employed. Due to the inherently imbalanced nature of the model, a task-wise approach could yield improved threading efficiency...|$|E
5000|$|... the byte-range {{advisory}} Network Lock Manager (NLM) protocol (added {{to support}} UNIX System V <b>file</b> <b>locking</b> APIs) ...|$|R
5000|$|... 1988 - db_VISTA version 3 is released, with a {{system-wide}} lock manager {{process that}} manages all <b>file</b> <b>locks.</b>|$|R
50|$|Ensuring {{consistency}} {{across multiple}} file system operations is difficult, if not impossible, without file system transactions. <b>File</b> <b>locking</b> {{can be used}} as a concurrency control mechanism for individual files, but it typically does not protect the directory structure or file metadata. For instance, <b>file</b> <b>locking</b> cannot prevent TOCTTOU race conditions on symbolic links.File locking also cannot automatically roll back a failed operation, such as a software upgrade; this requires atomicity.|$|R
40|$|Abstract—Massively {{parallel}} applications {{often require}} periodic data checkpointing for program restart and post-run data analysis. Although high performance computing systems provide massive parallelism and computing power {{to fulfill the}} crucial requirements of the scientific applications, the I/O tasks of high-end applications do not scale. Strict data consistency semantics adopted from traditional file systems are inadequate for homogeneous parallel computing platforms. For high performance parallel applications independent I/O is critical, particularly if checkpointing data are dynamically created or irregularly partitioned. In particular, parallel programs generating {{a large number of}} unrelated I/O accesses on large-scale systems often face serious I/O serializations introduced by lock contention and conflicts at file system layer. As these applications {{may not be able to}} utilize the I/O optimizations requiring process synchronization, they pose a great challenge for parallel I/O architecture and software designs. We propose an I/O mechanism to bridge the gap between scientific applications and parallel storage systems. A static file domain partitioning method is developed to align the I/O requests and produce a client-server mapping that minimizes the <b>file</b> <b>lock</b> acquisition costs and eliminates the lock contention. Our performance evaluations of production application I/O kernels demonstrate scalable performance and achieve high I/O bandwidths...|$|E
40|$|The paper {{contains}} {{preliminary results}} from an investigation comparing Linux and WindowsXP disk I/O using kernel-based software RAID on identical hardware. WindowsXP performance {{is shown to}} be substantially superior to Linux performance, for reasons not currently understood. One known problem with the Linux RAID driver is that in Linux 2. 4 file I/O is synchronous and file operations are serialized by a kernel <b>file</b> <b>lock.</b> Since the RAID driver is exposed to user-level applications via a file interface, this means that all accesses to the RAID are serialized. There {{are a number of}} possibilities to improve disk I/O performance: [1] Develop a user-level RAID layer built on aio and extend applications to allow asynchronous I/O. [2] Attempt to debug the Linux software RAID devices so its synchronous performance is comparable to WindowsXP. We develop a simple user-level RAID layer built on aio, and demonstrate its improved performance over the Linux sofware RAID impelementation, but its performance is still lower than that of the WindowsXP software RAID implementation. The alternative is to investigate various options for extending or improving the Linxu kernel, which {{is likely to be a}} riskier and more difficult task...|$|E
40|$|Client-side file caching {{has long}} been {{recognized}} as a file system enhancement {{to reduce the amount}} of data transfer between application processes and I/O servers. However, caching also introduces cache coherence problems when a file is simultaneously accessed by multiple processes. Existing coherence controls tend to treat the client processes independently and ignore the aggregate I/O access pattern. This causes a serious performance degradation for parallel I/O applications. In our earlier work, we proposed a caching system that enables cooperation among application processes in performing client-side file caching. The caching system has since been integrated into the MPI-IO library. In this paper we discuss our new implementation and present an extended performance evaluation on GPFS and Lustre parallel file systems. In addition to comparing our methods to traditional approaches, we examine the performance of MPI-IO caching under direct I/O mode to bypass the underlying file system cache. We also investigate the performance impact of two file domain partitioning methods to MPI collective I/O operations: one which creates a balanced workload and the other which aligns accesses to the file system stripe size. In our experiments, alignment results in better performance by reducing <b>file</b> <b>lock</b> contention. When the cache page size is set to a multiple of the stripe size, MPI-IO caching inherits the same advantage and produces significantly improved I/O bandwidth. 1...|$|E
50|$|<b>File</b> <b>locks</b> {{apply to}} the actual file, rather than the file name. This is {{important}} since Unix allows multiple names {{to refer to the}} same file. Together with non-mandatory locking, this leads to great flexibility in accessing files from multiple processes. On the other hand, the cooperative locking approach can lead to problems when a process writes to a file without obeying <b>file</b> <b>locks</b> set by other processes.|$|R
50|$|In computing, '''''' is {{a command}} for MS-DOS that allowed {{software}} to perform <b>file</b> <b>locks.</b> <b>Locking</b> <b>files</b> became necessary when MS-DOS began allowing files to be accessed simultaneously by multiple programs, either through multitasking or networking.|$|R
50|$|MP/M II 2.0 added {{file sharing}} {{capabilities}} in 1981, MP/M II 2.1 came with extended <b>file</b> <b>locking</b> in January 1982.|$|R
5000|$|IBM pioneered <b>file</b> <b>locking</b> in 1963 {{for use in}} {{mainframe}} computers using OS/360, {{where it}} was termed [...] "exclusive control".|$|R
40|$|In {{order for}} I/O systems to achieve high {{performance}} in a parallel environment, they must either sacrifice client-side file caching, or keep caching and deal with complex coherency issues. The most common technique for dealing with cache coherency in multi-client file caching environments uses <b>file</b> <b>locks</b> to bypass the client-side cache. Aside from effectively disabling cache usage, <b>file</b> <b>locking</b> is sometimes unavailable on larger systems. The high-level abstraction layer of MPI allows us to tackle cache coherency with additional information and coordination without using <b>file</b> <b>locks.</b> By approaching the cache coherency issue further up, the underlying I/O accesses can be modified {{in such a way}} as to ensure access to coherent data while satisfying the user’s I/O request. We can effectively exploit the benefits of a file system’s clientside cache while minimizing its management costs. ...|$|R
50|$|<b>File</b> <b>locking</b> is a {{mechanism}} that restricts {{access to a}} computer file by allowing only one user or process to access it in a specific time.|$|R
5000|$|Leases are {{commonly}} used in distributed systems for applications ranging from [...] DHCP address allocation to <b>file</b> <b>locking,</b> {{but they are not}} (by themselves) a complete solution: ...|$|R
50|$|With release 2011.19, mined {{added an}} {{interactive}} file chooser; backup files (optionally versioned), <b>file</b> <b>locking</b> and recovery <b>files</b> which are interoperable with other editors, and file change monitoring.|$|R
50|$|Cloudian HyperStore Connect for Files (HCF) is {{a global}} file access product with native support for SMB, NFS, and FTP. HCF {{includes}} multi-site <b>file</b> <b>locking,</b> data deduplication, and compression.|$|R
5000|$|Improper error-handling in an {{application}} program {{can lead to}} a scenario where a <b>file</b> is <b>locked</b> (either using [...] "share" [...] access or with byte-range <b>file</b> <b>locking)</b> and cannot be accessed by other applications. If so, the user may be able to restore file access by manually terminating the malfunctioning program. This is typically done through the Task Manager utility.|$|R
50|$|System V Release 2 was {{released}} in April, 1984. It added shell functions and the SVID. New kernel features included record and <b>file</b> <b>locking,</b> demand paging, and copy on write.|$|R
50|$|<b>File</b> <b>locking</b> is {{a common}} {{technique}} for preventing race conditions for a single file, {{but it does not}} extend to the file system namespace and other metadata, and cannot prevent TOCTTOU race conditions.|$|R
50|$|Another {{difference}} is that <b>file</b> <b>locks</b> are managed by the metadata broker, rather than the individual host clients. This results in the elimination {{of a number of}} problems which typically plague distributed file systems.|$|R
5000|$|As part of [...] "really shared files" [...] (stage three above), <b>file</b> <b>locking</b> was {{introduced}} to control simultaneous access to shared files between active MTS sessions (that is, between separate running tasks or processes). <b>File</b> <b>locking</b> does not limit or block access to files within a single MTS session (between command language subsystems or user programs running {{as part of the}} same MTS session).File locking in MTS is mandatory rather than advisory. <b>Files</b> are <b>locked</b> implicitly on first use of a particular type of access or explicitly using the $LOCK command or the <b>LOCK</b> subroutine. <b>Files</b> are unlocked implicitly when the last use of a file within a task is closed or explicitly using the $UNLOCK command or the UNLK subroutine. The $LOCKSTATUS command or LSFILE and LSTASK subroutines can be used to obtain a file’s or a task’s current lock status.|$|R
5000|$|Open file backup: Many backup {{software}} packages feature {{the ability to}} handle open files in backup operations. Some simply check for openness and try again later. <b>File</b> <b>locking</b> is useful for regulating access to open files.|$|R
