154|369|Public
5000|$|Integrated {{spelling}} and handwriting <b>instruction</b> <b>sequence</b> with reading instruction, {{so that they}} are mutually reinforcing ...|$|E
5000|$|The term branch can be {{used when}} {{referring}} to programs in high level languages as well as program written in machine code or assembly language. In high-level programming languages, branches usually {{take the form of}} conditional statements of various forms that encapsulate the <b>instruction</b> <b>sequence</b> that will be executed if the conditions are satisfied. Unconditional branch instructions such as GOTO are used to unconditionally [...] "jump" [...] to (begin execution of) a different <b>instruction</b> <b>sequence.</b>|$|E
5000|$|The dance {{follows the}} {{instructions}} {{given in the}} lyrics of the song, which may be prompted by a bandleader, a participant, or a recording. A sample <b>instruction</b> <b>sequence</b> would be: ...|$|E
40|$|<b>Instruction</b> <b>sequences</b> {{with direct}} and {{indirect}} jump instructions are as expressive as <b>instruction</b> <b>sequences</b> with direct jump instructions only. We show that, in the case where the number of instructions is not bounded, {{we are faced with}} increases of the maximal internal delays of <b>instruction</b> <b>sequences</b> on execution that are not bounded by a linear function if we strive for acceptable increases of the lengths of <b>instruction</b> <b>sequences</b> on elimination of indirect jump instructions. Comment: 10 pages, definition of maximal internal delay and theorem 1 are stated more precise; presentation improve...|$|R
40|$|<b>Instruction</b> <b>sequences</b> {{with direct}} and {{indirect}} jump instructions are as expressive as <b>instruction</b> <b>sequences</b> with direct jump instructions only. We show that, in the case where the number of instructions is not bounded, there exist <b>instruction</b> <b>sequences</b> of the former kind from which elimination of indirect jump instructions is possible without a super-linear increase of their maximal internal delay on execution only {{at the cost of}} a super-linear increase of their length...|$|R
40|$|This paper {{concerns}} <b>instruction</b> <b>sequences</b> {{that contain}} probabilistic instructions, i. e. instructions that are themselves probabilistic by nature. We propose {{several kinds of}} probabilistic instructions, provide an informal operational meaning for each of them, and discuss related work. On purpose, we refrain from providing an ad hoc formal meaning for the proposed kinds of instructions. We also discuss the approach of projection semantics, which was introduced in earlier work on <b>instruction</b> <b>sequences,</b> {{in the light of}} probabilistic <b>instruction</b> <b>sequences.</b> Comment: 15 pages, revised because arxiv: 1409. 6873 v 1 [cs. LO] has come ou...|$|R
50|$|A {{branch is}} an {{instruction}} {{in a computer}} program that can cause a computer to begin executing a different <b>instruction</b> <b>sequence</b> and thus deviate from its default behavior of executing instructions in order. Branch (or branching, branched) may also refer to the act of switching execution to a different <b>instruction</b> <b>sequence</b> {{as a result of}} executing a branch instruction. A branch instruction can be either an unconditional branch, which always results in branching, or a conditional branch, {{which may or may not}} cause branching, depending on some condition. Branch instructions are used to implement control flow in program loops and conditionals (i.e., executing a particular sequence of instructions only if certain conditions are satisfied).|$|E
50|$|The {{deterministic}} rendezvous {{problem is}} {{a variant of the}} rendezvous problem where the players, or robots, must find each other by following a deterministic sequence of instructions. Although each robot follows the same <b>instruction</b> <b>sequence,</b> a unique label assigned to each robot is used for symmetry breaking.|$|E
5000|$|Threaded code interpreters {{are similar}} to byte code interpreters but instead of bytes they use pointers. Each [...] "instruction" [...] {{is a word that}} points to a {{function}} or an <b>instruction</b> <b>sequence,</b> possibly followed by a parameter. The threaded code interpreter either loops fetching instructions and calling the functions they point to, or fetches the first instruction and jumps to it, and every <b>instruction</b> <b>sequence</b> ends with a fetch and jump to the next instruction. Unlike byte code there is no effective limit on the number of different instructions other than available memory and address space. The classic example of threaded code is the Forth code used in Open Firmware systems: the source language is compiled into [...] "F code" [...] (a bytecode), which is then interpreted by a virtual machine.|$|E
2500|$|Simple {{addressing}} modes with complex addressing performed by <b>instruction</b> <b>sequences</b> ...|$|R
40|$|We study {{several aspects}} of the {{behaviours}} produced by <b>instruction</b> <b>sequences</b> under execution {{in the setting of}} the algebraic theory of processes known as ACP. We use ACP to describe the behaviours produced by <b>instruction</b> <b>sequences</b> under execution and to describe two protocols implementing these behaviours in the case where the processing of instructions takes place remotely. We also show that all finite-state behaviours considered in ACP can be produced by <b>instruction</b> <b>sequences</b> under execution. Comment: 36 pages, consolidates material from arXiv: 0811. 0436 [cs. PL], arXiv: 0902. 2859 [cs. PL], and arXiv: 0905. 2257 [cs. PL]; abstract and introduction rewritten, examples and proofs adde...|$|R
40|$|Both J 2 BP and PANDA tools verify {{compiled}} Java programs. By now, {{these tools}} {{are not able}} to process some programs with specific JVM bytecode <b>instruction</b> <b>sequences</b> in the correct way. We described these <b>instruction</b> <b>sequences</b> and proposed their transformations. We developed the new application, called BytecodeTransformer, based on these propositions. This application transforms compiled Java programs and replaces the problematic <b>instruction</b> <b>sequences</b> with some others. Usage of BytecodeTransformer enlarges the set of programs that can be verified by both J 2 BP and PANDA. We also evaluated BytecodeTransformer on several Java programs, including own tests and well-known open-source programs. These tests demonstrated the correct functionality of BytecodeTransformer. Powered by TCPDF (www. tcpdf. org...|$|R
50|$|Instruction {{simulation}} {{provides the}} opportunity to detect errors BEFORE execution {{which means that the}} conditions are still exactly as they were and not destroyed by the error. A very good example from the IBM S/360 world is the following <b>instruction</b> <b>sequence</b> that can cause difficulties debugging without an instruction simulation monitor.|$|E
50|$|A {{branch out}} of the normal <b>instruction</b> <b>sequence</b> often {{involves}} a hazard. Unless the processor can give effect to the branch in a single time cycle, the pipeline will continue fetching instructions sequentially. Such instructions cannot {{be allowed to take}} effect because the programmer has diverted control {{to another part of the}} program.|$|E
50|$|Programming in {{assembly}} language requires the programmer {{to keep track}} of the representation of numbers. Where the processor does not support a required mathematical operation, the programmer must work out a suitable algorithm and <b>instruction</b> <b>sequence</b> to carry out the operation; on some microprocessors, even integer multiplication must be done in software.|$|E
25|$|Allowed memory corruptions {{outside of}} the range of {{permitted}} writing for a process by running common <b>instruction</b> <b>sequences.</b>|$|R
40|$|We present new {{techniques}} that allow a return-into-libc attack to be mounted on x 86 executables that calls no functions at all. Our attack combines {{a large number}} of short <b>instruction</b> <b>sequences</b> to build gadgets that allow arbitrary computation. We show how to discover such <b>instruction</b> <b>sequences</b> by means of static analysis. We make use, in an essential way, of the properties of the x 86 instruction set. ...|$|R
40|$|This study {{examines}} the enactment effect in early Alzheimer’s disease using a novel working memory task. Free recall of action-object <b>instruction</b> <b>sequences</b> {{was measured in}} individuals with Alzheimer’s disease (n= 14) and older adult controls (n= 15). <b>Instruction</b> <b>sequences</b> were read out loud by the experimenter (verbal-only task), or read by the experimenter and performed by the participants (subject-performed task). In both groups and for all sequence lengths, recall was superior in the subject-performed condition than the verbal-only condition. Individuals with Alzheimer’s disease showed a deficit in free recall of recently learned <b>instruction</b> <b>sequences</b> relative to older adult controls, yet both groups show a significant benefit from performing actions themselves at encoding. The subject-performed task shows promise {{as a tool to}} improve working memory in early Alzheimer’s disease...|$|R
5000|$|A {{particular}} [...] "stress test" [...] can verify {{only the}} functionality {{of the specific}} <b>instruction</b> <b>sequence</b> used {{in combination with the}} data and may not detect faults in those operations. For example, an arithmetic operation may produce the correct result but incorrect flags; if the flags are not checked, the error will go undetected.|$|E
50|$|HOTSPOTS was an {{instruction}} trace tool written {{to help identify}} performance problem areas in IBM's MFT operating system. Branch trace data was written to tape, then summarized. The report {{took the form of}} a listing similar to a storage dump, with program entry points and exit points identified, including frequency of use for each <b>instruction</b> <b>sequence.</b>|$|E
5000|$|Microcontrollers {{must provide}} {{real-time}} (predictable, {{though not necessarily}} fast) response to events in the embedded system they are controlling. When certain events occur, an interrupt system can signal the processor to suspend processing the current <b>instruction</b> <b>sequence</b> and to begin an interrupt service routine (ISR, or [...] "interrupt handler") which will perform any processing required based on {{the source of the}} interrupt, before returning to the original <b>instruction</b> <b>sequence.</b> Possible interrupt sources are device dependent, and often include events such as an internal timer overflow, completing an analog to digital conversion, a logic level change on an input such as from a button being pressed, and data received on a communication link. Where power consumption is important as in battery devices, interrupts may also wake a microcontroller from a low-power sleep state where the processor is halted until required to do something by a peripheral event.|$|E
40|$|Internet worms pose {{a serious}} threat to {{computer}} security. Traditional approaches using signatures to detect worms pose little danger to the zero day attacks. The focus of malware research is shifting from using signature patterns to identifying the malicious behavior displayed by the malwares. This paper presents a novel idea of extracting variable length <b>instruction</b> <b>sequences</b> that can identify worms from clean programs using data mining techniques. The analysis is facilitated by the program control flow information contained in the <b>instruction</b> <b>sequences.</b> Based upon general statistics gathered from these <b>instruction</b> <b>sequences</b> we formulated the problem as a binary classification problem and built tree based classifiers including decision tree, bagging and random forest. Our approach showed 95. 6 % detection rate on novel worms whose data was not used in the model building process...|$|R
40|$|We add {{probabilistic}} {{features to}} basic thread algebra and its extensions with thread-service interaction and strategic interleaving. Here, threads represent the behaviours produced by <b>instruction</b> <b>sequences</b> under execution and services represent the behaviours {{exhibited by the}} components of execution environments of <b>instruction</b> <b>sequences.</b> In a paper concerned with probabilistic <b>instruction</b> <b>sequences,</b> we proposed several kinds of probabilistic instructions and gave an informal explanation for each of them. The probabilistic features added to the extension of basic thread algebra with thread-service interaction {{make it possible to}} give a formal explanation in terms of non-probabilistic instructions and probabilistic services. The probabilistic features added to the extensions of basic thread algebra with strategic interleaving make it possible to cover strategies corresponding to probabilistic scheduling algorithms. Comment: 25 pages (arXiv admin note: text overlap with arXiv: 1408. 2955, arXiv: 1402. 4950); some simplifications made; substantially revise...|$|R
5000|$|The <b>instruction</b> <b>sequencing</b> side {{does not}} contain an adder, so {{relative}} branches and position independent code are not possible. All jump and call addresses are absolute.|$|R
5000|$|The {{deterministic}} rendezvous {{problem is}} {{a variant of the}} rendezvous problem where the players, or robots, must find each other by following a deterministic sequence of instructions. Although each robot follows the same <b>instruction</b> <b>sequence,</b> a unique label assigned to each robot is used for symmetry breaking. Typically, the robots act synchronously, though non-synchronous versions of the deterministic rendezvous problem exist.|$|E
5000|$|The first {{implementation}} of tracing is Dynamo, [...] "a software dynamic optimization {{system that is}} capable of transparently improving the performance of a native instruction stream as it executes on the processor". To do this, the native instruction stream is interpreted until a [...] "hot" [...] <b>instruction</b> <b>sequence</b> is found. For this sequence an optimized version is generated, cached and executed.|$|E
50|$|One small detail: {{if there}} is {{temporal}} locality in ROB entries (i.e., if instructions close together in the von Neumann <b>instruction</b> <b>sequence</b> write back close together in time, {{it may be possible}} to perform write combining on ROB entries and so have fewer ports than a separate ROB/PRF would). It is not clear if it makes a difference, since a PRF should be banked.|$|E
40|$|Abstract. Single-pass <b>instruction</b> <b>sequences</b> under {{execution}} are con-sidered {{to produce}} behaviours {{to be controlled}} by some execution envi-ronment. Threads as considered in thread algebra model such behaviours: upon each action performed by a thread, a reply from its execution en-vironment determines how the thread proceeds. Threads in turn can be looked upon as producing processes as considered in process algebra. We show that, by apposite choice of basic instructions, all processes that can only be in a ¯nite number of states can be produced by single-pass <b>instruction</b> <b>sequences...</b>|$|R
40|$|Single-pass <b>instruction</b> <b>sequences</b> under {{execution}} {{are considered}} to produce behaviours {{to be controlled by}} some execution environment. Threads as considered in thread algebra model such behaviours: upon each action performed by a thread, a reply from its execution environment determines how the thread proceeds. Threads in turn can be looked upon as producing processes as considered in process algebra. We show that, by apposite choice of basic instructions, all processes that can only be in a finite number of states can be produced by single-pass <b>instruction</b> <b>sequences.</b> Comment: 23 pages; acknowledgement corrected, reference update...|$|R
50|$|Ardoin, S. P., Martens, B. K., & Wolfe, L. A. (1999). Using high-probability <b>instruction</b> <b>sequences</b> with fading to {{increase}} student compliance during transitions. Journal of Applied Behavior Analysis, 32, 339-351.|$|R
5000|$|... "Each POWER7 {{processor}} core implements aggressive out-of-order (OoO) instructionexecution to drive high efficiency {{in the use}} of available execution paths. The POWER7processor has an <b>Instruction</b> <b>Sequence</b> Unit that is capable of dispatching up to sixinstructions per cycle to a set of queues. Up to eight instructions per cycle can be issued tothe Instruction Execution units. The POWER7 processor has a set of twelve execution unitsas above" ...|$|E
50|$|Once fetched, trace cache stores the {{instructions}} in their dynamic sequence. When these instructions are encountered again, trace cache allows the instruction fetch unit of a processor to fetch several basic blocks from it without {{having to worry about}} branches in the execution flow. Instructions will be stored in trace cache either after they have been decoded, or as they are retired. However, <b>instruction</b> <b>sequence</b> is speculative if they are stored just after decode stage.|$|E
5000|$|At reset, the W65C816S {{starts in}} [...] "emulation mode," [...] meaning it {{essentially}} behaves as a 65C02. Following reset, the W65C816S may be switched to [...] "native mode" [...] with a two <b>instruction</b> <b>sequence,</b> {{causing it to}} enable all enhanced features, yet still maintain a substantial degree of backward compatibility with most 65C02 software. However, unlike the PDIP40 version of the 65C02, which is a pin-compatible replacement for its NMOS ancestor, the PDIP40 W65C816S is not pin-compatible with any other 6502 family MPU.|$|E
40|$|With the {{increasing}} importance of Application Domain Specific Processor (ADSP) design, a significant {{challenge is to}} identify special-purpose operations for implementation as a customized instruction. While many methodologies have been proposed for this purpose, they all work for a single algorithm chosen from the target application domain. Such algorithm-specific approaches are not suitable for designing instruction sets applicable to a whole family of related algorithms. For an entire range of related algorithms, this paper develops a methodology for identifying compound operations, {{as a basis for}} designing “domain-specific” Instruction Set Architectures (ISAs) that can efficiently run most of the algorithms in a given domain. Our methodology combines three different static analysis techniques to identify <b>instruction</b> <b>sequences</b> common to several related algorithms: identification of (non-branching) <b>instruction</b> <b>sequences</b> that occur commonly across the algorithms; identification of <b>instruction</b> <b>sequences</b> nested within iterative constructs that are thus executed frequently; and identification of commonly-occurring <b>instruction</b> <b>sequences</b> that span basic blocks. Choosing different combinations of these results enables us to design domain-specific special operations with different desired characteristics, such as performance or suitability as a library function. To demonstrate our approach, case studies are carried out for a family of thirteen string matching algorithms. Finally, the validity of our static analysis results is confirmed through independent dynamic analysis experiments and performance improvement measurements...|$|R
50|$|Typically, superoptimizing is {{performed}} via exhaustive brute-force search {{in the space}} of valid <b>instruction</b> <b>sequences.</b> This is a costly method, and thus impractical for general-purpose compilers. Yet, it {{has been shown to be}} useful in optimizing performance-critical inner loops.|$|R
40|$|Topics covered are: Micro{{computer}}s, {{the basic}} of computer logic, register structure, clocked sequential logic, microcomputer structure, <b>instruction</b> <b>sequencing,</b> the arithmetic logic unit, addressing and general registers, instruction sets, input/output system, software and architectural features applicable {{to a wide}} variety of microcomputer...|$|R
