4|2829|Public
40|$|Artificial neural {{networks}} (ANN's) perform adaptive learning. This advantage {{can be used}} to solve knowledge acquisition bottle-neck in knowledge engineering by rule extraction from the ANN's. This paper proposes a rule extraction method combining both open-box (white-box) and black-box approaches to analyse a trained Multilayer Perceptron in order to extract <b>general</b> <b>production</b> <b>rules</b> accurately, abstractly and efficiently...|$|E
40|$|Abstract: 2 ̆ 2 PUPS {{learning}} mechanisms {{center around}} {{the representation of}} causal relationships between objects or events. These learning mechanisms involve (1) a set of principles for inducing causal relationships in absence of a domain theory; (2) a set of analogical mechanisms for extrapolating the causal analysis of one situation in order to predict or problem solve in another situation; and (3) compilation procedures for turning these extrapolations into <b>general</b> <b>production</b> <b>rules.</b> These learning mechanisms are illustrated {{with respect to a}} detailed example from the algebra tutor where they {{do a good job of}} reproducing the instructionless learning we observe of students. 2 ̆...|$|E
40|$|GR- 2 is {{a hybrid}} {{knowledge-based}} system {{consisting of a}} Multilayer Perceptron and a rule based system for hybrid knowledge representations and reasoning. Knowledge embedded in the trained Multilayer Perceptron (MLP) is extracted {{in the form of}} <b>general</b> (<b>production)</b> <b>rules</b> [...] a natural format of abstract knowledge representation. The rule extraction method integrates Black-box and Open-box techniques on the MLP, obtaining feature salient and statistical properties of the training pattern set. The extracted general rules are quantified and selected in a rule validation process. Multiple inference facilities such as categorical reasoning, probabilistic reasoning and exceptional reasoning are performed in GR- 2. Experiments have shown that GR 2 is a reliable and general model for Knowledge Engineering...|$|E
40|$|A {{general scheme}} {{to aid in}} the {{selection}} of therapies is described A topological sorting procedure within a <b>general</b> <b>production</b> <b>rule</b> representation is introduced The procedure is used to choose among competing therapies on the basis of precedence rules This approach has a degree of naturalness that lends itself to automatic explanation of the choices made A system has been implemented using this approach to develop an expert system for planning therapies for patients diagnosed as having ocular herpes simplex An abstracted example of the system s output on an actual case is given*...|$|R
40|$|Abstract. Intelligent Tutoring Systems are {{effective}} at improving learn-ing, but are costly to produce. In this paper, we review SimStudent, a {{system designed to}} aid authors in {{improving the quality of}} their tu-tors while simultaneously reducing authoring costs. This system works by inducing <b>general</b> <b>production</b> <b>rule</b> models from user demonstrations and feedback. We discuss results demonstrating that SimStudent learned models better fit student data than expert authored models and that it is efficient to use. In addition, we provide an example of how a simple al-gebra tutor would be constructed using this paradigm. Lastly, we review future directions for this work. ...|$|R
40|$|We {{describe}} a scheme for developing expert interpretive systems and transferring {{them to a}} microprocessor environment The scheme has been successfully implemented and tested by producing a program for interpreting results from a widely used medical laboratory instrument a scanning densitometer Specialists {{in the field of}} serum protein electrophoresis analysis provided the knowledge needed to build an interpretive model using EXPERT, a <b>general</b> <b>production</b> <b>rule</b> system for developing consultation models By constraining a few of the structures used in the general model it was possible to develop procedures for automatically translating the model to a specialized application program and then to a microprocessor assembly language program Thus, the model development can take place on a large machine, using established techniques for capturing and conveniently updating expert knowledge structures, while the final interpretive program can be targeted to a microprocessor depending on the application Our experience in carrying out the complete process illustrates many of the requirements involved in taking an expert system from its early development phase to actual implementation and use in a real world application...|$|R
40|$|GR 2 is {{a hybrid}} connectionist/knowledge-based system {{consisting}} of a Multi-layer Perceptron and a rule-based system for knowledge representation and reasoning. Knowledge embedded in a trained Multi-layer Perceptron is extracted {{in the form of}} <b>general</b> (<b>production)</b> <b>rules</b> [...] a natural format for abstract knowledge representation. The rule extraction method integrates black-box and white-box techniques on the MLP, obtaining feature salient and statistical properties of the training pattern set. This is achieved via a heuristic based on the static connections strengths from input to output. The extracted general rules are quantified and selected in a rule validation process. Multiple inference modalities such as categorical reasoning, probablistic reasoning and exceptional reasoning can be performed in GR 2. In addition, quantitative indications of a rule's validity within the domain and the importance of any antecedent within a rule can be calculated. Experiments are conducted in artificial (simple logic) domains and using data from emergency medicine. The predictive performance of the underlying neural networks is seen to be maintained whilst a valid set of rules is extracted. For the medical problem, favourable comparison is drawn with the C 4. 5 technique, an extension of the celebrated ID 3 algorithm. The methodology can be applied to any feedforward neural network via straightforward extensions to the basic ideas and avoids the need for specialised architectures found in some other methods...|$|E
40|$|Abstract. One {{aim of the}} Generalized Intelligent Framework for Tutoring (GIFT) is {{to reduce}} the time and cost of {{authoring}} Intelligent Tutoring Systems. Recent work with SimStudent offers a promising approach to the efficient au-thoring of expert models and misconception libraries. SimStudent works by in-ducing <b>general</b> <b>production</b> <b>rule</b> models from author demonstrations and feed-back. Importantly, the demonstration and feedback takes place directly in the tutor interface and requires no programming. Empirical results have shown that models induced by SimStudent fit student data better than models hand-authored by domain experts. Additionally, an analysis with the Goals, Opera-tors, Methods, and Selection rules (GOMS) model showed that authoring with SimStudent is more efficient than authoring with current approaches, namely Example-Tracing. This paper reviews those results and provides an example of constructing a simple algebra tutor with SimStudent. This work with SimStu-dent presents several concepts that may be useful in the design and develop-ment of GIFT: modularization to allow for tutor authoring by non-programmers, generation of likely student misconceptions as a byproduct of ex-pert-model creation, and methods for comparing and evaluating authoring tools...|$|R
50|$|A {{compiler}} parses {{input from}} {{a programming language}} to an internal representation by matching the incoming symbols to <b>production</b> <b>rules.</b> <b>Production</b> <b>rules</b> are commonly defined using Backus-Naur form. An LL parser {{is a type of}} parser that does top-down parsing by applying each <b>production</b> <b>rule</b> to the incoming symbols, working from the left-most symbol yielded on a <b>production</b> <b>rule</b> and then proceeding to the next <b>production</b> <b>rule</b> for each non-terminal symbol encountered. In this way the parsing starts on the Left of the result side (right side) of the <b>production</b> <b>rule</b> and evaluates non-terminals from the Left first and, thus, proceeds down the parse tree for each new non-terminal before continuing to the next symbol for a <b>production</b> <b>rule.</b>|$|R
5000|$|OMG <b>Production</b> <b>Rule</b> Representation (PRR): Represents <b>rules</b> for <b>production</b> <b>rule</b> {{systems that}} make up most BRMS' {{execution}} targets ...|$|R
5000|$|<b>Production</b> <b>Rule</b> Representation - {{comparable}} to the dialect of RIF called <b>Production</b> <b>Rule</b> Dialect, although targeting modeling not run-time interchange.|$|R
40|$|<b>Production</b> <b>rules</b> are <b>rules</b> used in <b>production</b> systems, {{sometimes}} called <b>production</b> <b>rule</b> engines. <b>Production</b> <b>rule</b> engines {{are commonly used}} to implement expert systems. This report describes an information model for the exchange of <b>production</b> <b>rules</b> and for description {{of the relationship of}} the rules to a data population. The report is a precursor to a standardization effort in the ISO 10303 suite of standards. The report {{takes the form of a}} standards document generally, but departs from that form in places to provide more userfriendly explanation. 1. 0 Scope This report provides guidance on two forms of data structure mapping: (1) mapping of <b>production</b> <b>rules</b> to EXPRESS-based data [1], and; (2) mapping of instances in an EXPRESS population to structures typically found in <b>production</b> <b>rule</b> systems. The EXPRESS information model which this report describes is provided in an appendix to this report. The information model provides: • information describing rules for their use with typical <b>production</b> <b>rule</b> softwar...|$|R
40|$|The {{purpose of}} this {{research}} is to analyze <b>production</b> <b>rules</b> with coupling modes in active databases and to exploit an assistant system for <b>rule</b> programming. Each <b>production</b> <b>rule</b> is a specification including an event, acondition, and an action. The action is automatically executed whenever the event occurs and the condition is satisfied. Coupling modes are useful to control execution order of transactions. For example, a transaction for consistency check should be executed after transactions for update. An active database, which is a database with <b>production</b> <b>rules,</b> can spontaneously update database states and check their consistency. <b>Production</b> <b>rules</b> provide a powerful mechanism for knowledge-bases. However it is very difficult in general to predict how a set of <b>production</b> <b>rules</b> will behave because of cascading rule triggers, concurrency, and so on. We are attempting to adopt a process algebra as a basic tool to analyze <b>production</b> <b>rules.</b> In order to describe and analyze concurrent and communicating systems, process algebras such as CCS, CSP, ACP, and π-calculus, are well known. However there are some difficulties to apply existing process algebras to analysis of <b>production</b> <b>rules</b> in growing process trees by process creation. In this paper we propose a process algebra named CCSPR (a Calculus of Communicating Systems with <b>Production</b> <b>Rules),</b> which is an extension of CCS. An advantage of CCSPR is to syntactically describe growing process trees. Therefore, <b>production</b> <b>rules</b> can be appropriately analyzed in CCSPR. After giving definitions and properties of CCSPR, we show an example of analysis of <b>production</b> <b>rules</b> in CCSPR. key words: active database, <b>production</b> <b>rule,</b> process algebra, process creation, process tree, multi-way communication. 1...|$|R
5000|$|The {{parameters}} {{can be used}} by {{the drawing}} functions, and also by the <b>production</b> <b>rules.</b> The <b>production</b> <b>rules</b> can use the parameters in two ways: first, in a conditional statement determining whether the rule will apply, and second, the <b>production</b> <b>rule</b> can modify the actual parameters. For example, look at: ...|$|R
40|$|We propose {{incorporating}} a <b>production</b> <b>rules</b> facility into a relational database system. Such a facility allows definition of database operations that are automatically executed whenever certain conditions are met. In {{keeping with the}} set-oriented approach of relational data manipulation languages, our <b>production</b> <b>rules</b> are also set-oriented [...] -they are triggered by sets of changes to the database and may perform sets of changes. The condition and action parts of our <b>production</b> <b>rules</b> may refer to {{the current state of}} the database as well as to the sets of changes triggering the rules. We define a syntax for <b>production</b> <b>rule</b> definition as an extension to SQL. A model of system behavior is used to give an exact semantics for <b>production</b> <b>rule</b> execution, taking into account externally-generated operations, selftriggering rules, and simultaneous triggering of multiple rules. 1 Introduction Recently, there has been considerable interest in integrating <b>production</b> <b>rules</b> systems and database manag [...] ...|$|R
40|$|Approved {{for public}} release, {{distribution}} is unlimitedA prototype <b>production</b> <b>rule</b> program, DECAIDS, {{for the support}} of decisions on computer resources was constructed using the Stanford University EMYCIN <b>production</b> <b>rule</b> system. The DECAIDS program demonstrates the use of a <b>production</b> <b>rule</b> system to support a relatively unstructured management problem. A discussion of knowledge based systems, predicate calculus and <b>production</b> <b>rules</b> is included. A tutorial section discusses the user information needed for development of a backward-chaining, goal seeking knowledge based system. [URL] United States Marine CorpsLieutenant Commander, United States Nav...|$|R
40|$|Researchers often {{complain}} that the behavior of database <b>production</b> <b>rules</b> is difficult to reason about and understand, {{due in part to}} the lack of formal declarative semantics. It has even been claimed that database <b>production</b> <b>rule</b> languages inherently cannot be given declarative semantics, in contrast to, e. g., deductive database rule languages. In this short paper we dispute this claim by giving a denotational semantics for the Starburst database <b>production</b> <b>rule</b> language. 1 Introduction <b>Production</b> <b>rules</b> in database systems allow specification of data manipulation operations that are executed automatically whenever certain events occur or conditions are met, e. g. [Han 89,MD 89, SJGP 90,WF 90]. A wide variety of semantics have been proposed for database <b>production</b> <b>rule</b> languages; see, e. g. [HW 93, Sel 89]. Most of these semantics are based to some extent on the recognize-act cycle of the OPS 5 <b>production</b> <b>rule</b> language [BFKM 85]. In all cases, the semantics are described informally or, at best [...] ...|$|R
50|$|The <b>Production</b> <b>Rule</b> Representation (PRR) is a {{proposed}} standard of the Object Management Group (OMG) {{to provide a}} vendor-neutral rule-model representation in UML for <b>production</b> <b>rules</b> as used in forward-chaining rule engines.|$|R
40|$|Abstract. We {{introduce}} a formal {{setting for a}} first-order <b>production</b> <b>rule</b> approach to descriptive learning and we consider searching for sets of <b>production</b> <b>rules</b> {{as opposed to a}} direct search for concepts. We sketch the Parrot algorithm which generates a basic set of <b>production</b> <b>rules</b> capable of producing a set of user-given concepts and present some preliminary ideas on how to enrich this set. ...|$|R
40|$|AbstractIn the {{knowledge}} engineering, the fuzzy conceptual graphs and the <b>production</b> <b>rule</b> are two important knowledge representation methods. Because the confidence information can’t {{be represented in}} the fuzzy conceptual graphs and the fuzzy knowledge can’t be represented in the <b>production</b> <b>rules,</b> the ability of their knowledge representation is grievous insufficiency. In this paper, the extended <b>production</b> <b>rule</b> which is a new knowledge representation method has been presented. In the extended <b>production</b> <b>rule,</b> the antecedent and consequent of a rule are represented by fuzzy conceptual graphs, and the sustaining relation between antecedent and consequent is the confidence. The rule combines the fuzzy knowledge with the confidence effectually. It not only retains the semantic plentifulness of facts and proposition, but also makes the reasoning results more effectively. According to the extended <b>production</b> <b>rule,</b> the uncertain reasoning algorithm based on fuzzy conceptual graphs is designed. By the experiment test and analysis, the reasoning effects of the extended <b>production</b> <b>rule</b> are more in reason. The researching results are applied in the designed of uncertain inference engine in fuzzy expert system...|$|R
40|$|This paper {{describes}} {{the implementation of}} a set-oriented database <b>production</b> <b>rule</b> language proposed in earlier papers. Our implementation uses the extensibility features of the Starburst database system, and rule execution is fully integrated into database query and transaction processing. 1 Introduction In database systems, a <b>production</b> <b>rules</b> facility allows definition of database operations that are executed automatically whenever certain events occur or conditions are met. <b>Production</b> <b>rules</b> in database systems can be used for enforcing integrity constraints, maintaining derived data, and building efficient knowledge-base and expert systems. In [WF 89,WF 90] we propose a syntax for specifying <b>production</b> <b>rules</b> in relational database systems and a semantics for rule execution. In keeping with the setoriented approach of relational data manipulation languages, our <b>production</b> <b>rules</b> are set-oriented [...] -they are triggered by sets of changes to the database and may perform sets of changes [...] . ...|$|R
5000|$|In formal {{language}} theory, a context-free grammar (CFG) {{is a certain}} type of formal grammar: a set of <b>production</b> <b>rules</b> that describe all possible strings in a given {{formal language}}. <b>Production</b> <b>rules</b> are simple replacements. For example, the rule ...|$|R
40|$|This paper {{discusses}} scattered context grammars (SCG) {{and considers}} {{the application of}} scattered context grammar <b>production</b> <b>rules.</b> We use function that represents single derivation step over the given sentential form. Moreover, we define this function in such a way, so that it represents the delayed execution of scattered context grammar <b>production</b> <b>rules</b> using the same principles as a lazy evaluation in functional programming. Finally, we prove equivalence of the usual and the delayed execution of SCG <b>production</b> <b>rules...</b>|$|R
50|$|Entering {{from the}} right {{are a series of}} left-moving {{structures}} of the type shown above, separated by varying amounts of horizontal space. Large numbers of these structures are combined with different spacings to represent 0s and 1s in the cyclic tag system's <b>production</b> <b>rules.</b> Because the tag system's <b>production</b> <b>rules</b> are known at the time of creation of the program, and infinitely repeating, the patterns of 0s and 1s at the initial condition can be represented by an infinitely repeating string. Each <b>production</b> <b>rule</b> is separated from the next by another structure known as a rule separator (or block separator), which moves towards the left {{at the same rate as}} the encoding of the <b>production</b> <b>rules.</b>|$|R
50|$|A grammar mainly {{consists}} {{of a set of}} rules for transforming strings. (If it only consisted of these rules, it would be a semi-Thue system.) To generate a string in the language, one begins with a string consisting of only a single start symbol. The <b>production</b> <b>rules</b> are then applied in any order, until a string that contains neither the start symbol nor designated nonterminal symbols is produced. A <b>production</b> <b>rule</b> is applied to a string by replacing one occurrence of the <b>production</b> <b>rule's</b> left-hand side in the string by that <b>production</b> <b>rule's</b> right-hand side (cf. the operation of the theoretical Turing machine). The language formed by the grammar {{consists of}} all distinct strings that can be generated in this manner. Any particular sequence of <b>production</b> <b>rules</b> on the start symbol yields a distinct string in the language. If there are essentially different ways of generating the same single string, the grammar is said to be ambiguous.|$|R
40|$|C 4. 5 is {{the most}} {{well-known}} inductive learning algorithm. It {{can be used to}} build decision trees as well as <b>production</b> <b>rules.</b> <b>Production</b> <b>rules</b> are a very common formalism for representing and using knowledge in many real-world domains. C 4. 5 generates <b>production</b> <b>rules</b> from raw trees. It has been shown that the set of <b>production</b> <b>rules</b> is usually both simpler and more accurate than the decision tree from which the ruleset was formed. This research shows that generating <b>production</b> <b>rules</b> from pruned trees usually results in significantly simpler rulesets than generating rules from raw trees. This reduction in complexity is achieved without reducing prediction accuracies. Furthermore, the new approach uses significantly less induction time than the latter. This paper uses experiments {{in a wide variety of}} natural domains to illustrate these points. It also shows that the new method scales up better than the old one in terms of ruleset size, the number of rules, and learning time when the tr [...] ...|$|R
25|$|A more {{complicated}} example {{is given by}} recursive descent parsers, which can be naturally implemented by having one function for each <b>production</b> <b>rule</b> of a grammar, which then mutually recurse; this will in general be multiple recursion, as <b>production</b> <b>rules</b> generally combine multiple parts. This can also be done without mutual recursion, for example by still having separate functions for each <b>production</b> <b>rule,</b> but having them called by a single controller function, or by putting all the grammar in a single function.|$|R
50|$|Unlike grammars {{controlled}} by prescribed sequences of <b>production</b> <b>rules,</b> which constrain {{the space of}} valid derivations but do not constrain the sorts of sentences that a <b>production</b> <b>rule</b> can apply to, grammars {{controlled by}} context conditions have no sequence constraints, but permit constraints of varying complexity on the sentences to which a <b>production</b> <b>rule</b> applies. Similar to grammars controlled by prescribed sequences, there are multiple different kinds of grammars controlled by context conditions: conditional grammars, semi-conditional grammars, random context grammars, and ordered grammars.|$|R
5000|$|R is {{a finite}} set of string-transforming <b>rules</b> (called <b>production</b> <b>rules),</b> each rule {{being of the}} {{following}} form: ...|$|R
25|$|Generate <b>production</b> <b>rules</b> for the sequences.|$|R
25|$|A {{probabilistic}} context free grammar {{consists of}} terminal and nonterminal variables. Each feature to be modeled has a <b>production</b> <b>rule</b> that is assigned a probability estimated from a training set of RNA structures. <b>Production</b> <b>rules</b> are recursively applied until only terminal residues are left.|$|R
40|$|Abstract—The gaining {{popularity}} of <b>production</b> <b>rule</b> systems {{had as a}} result the recent Rule Interchange Format (RIF) extensibility framework. This framework, developed by the W 3 C Consortium, is for modeling <b>production</b> <b>rules</b> in forward chaining rule engines. Our research, based on this RIF extensibility framework, sets the foundational work for a flexible new rule language to facilitate knowledge representation with syntax that incorporates features from both logic and functional programming. The benefits are grammatical freedom, absolute clarity and rigor. Formalizations of the new language and examples are provided. Keywords-computer languages; F-expressions; higher-order logic programming; <b>production</b> <b>rule</b> systems; rule dialects...|$|R
50|$|Here again, such {{strategies}} may vary from the simple—use {{the order in}} which <b>production</b> <b>rules</b> were written; assign weights or priorities to <b>production</b> <b>rules</b> and sort the conflict set accordingly—to the complex—sort the conflict set according to the times at which <b>production</b> <b>rules</b> were previously fired; or according to the extent of the modifications induced by their RHSs. Whichever conflict resolution strategy is implemented, the method is indeed crucial to the efficiency and correctness of the production system. Some systems simply fire all matching productions.|$|R
5000|$|In the {{transformation}} {{portion of the}} <b>production</b> <b>rule,</b> the parameters as well as entire modules can be affected. In the above example, the module b(x,y) {{is added to the}} string, with initial parameters (2,3). Also, the parameters of the already existing module are transformed. Under the above <b>production</b> <b>rule,</b> ...|$|R
40|$|<b>Production</b> <b>Rule</b> Sets (PRS) are {{a digital}} event-based model for CMOS circuits; stable <b>production</b> <b>rule</b> sets {{are those in}} which in every execution, every enabled rule remains enabled until it is executed. It has been conjectured that stable <b>production</b> <b>rule</b> sets are determinstic, meaning in {{particular}} that they cannot implement arbiters, and that the sequence of values sent on any channel is independent of the execution. In this paper, we prove these facts rigorously, directly from first principles. We also propose improvements to PRS testing tools based on the resulting theory...|$|R
5000|$|In this example, <b>production</b> <b>rules</b> {{are chosen}} for testing {{according}} to their order in this production list. For each rule, the input string is examined {{from left to right}} with a moving window to find a match with the LHS of the <b>production</b> <b>rule.</b> When a match is found, the matched substring in the input string is replaced with the RHS of the <b>production</b> <b>rule.</b> In this <b>production</b> system, x and y are variables [...] matching any character of the input string alphabet. Matching resumes with P1 once the replacement has been made.|$|R
