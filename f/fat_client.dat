42|26|Public
50|$|A <b>fat</b> <b>client,</b> {{also known}} as a rich client or thick client, is a client that {{performs}} the bulk of any data processing operations itself, and does not necessarily rely on the server. The personal computer is a common example of a <b>fat</b> <b>client,</b> because of its relatively large set of features and capabilities and its light reliance upon a server. For example, a computer running a CAD program (such as AutoCAD or CATIA) that ultimately shares the result of its work on a network is a <b>fat</b> <b>client.</b>|$|E
5000|$|... #Caption: A stylized {{illustration}} of a tower personal computer, {{a form of}} <b>fat</b> <b>client</b> ...|$|E
50|$|A hybrid {{client is}} a mixture of the above two client models. Similar to a <b>fat</b> <b>client,</b> it {{processes}} locally, but relies on the server for storing persistent data. This approach offers features from both the <b>fat</b> <b>client</b> (multimedia support, high performance) and the thin client (high manageability, flexibility). A device running an online version of the video game Diablo III is an example of hybrid client.|$|E
50|$|In one classification, client {{computers}} and devices are either <b>fat</b> <b>clients,</b> thin clients, or hybrid clients.|$|R
5000|$|Diskless Remote Boot in Linux: similar booting {{system to}} LTSP <b>fat</b> <b>clients</b> ...|$|R
5000|$|In process {{access to}} Ingres NET for <b>FAT</b> <b>clients</b> making {{distribution}} easier.|$|R
50|$|Administration is also {{typically}} {{done through}} browser-based interfaces, but some systems {{require the use}} of a <b>fat</b> <b>client.</b>|$|E
50|$|The DDM {{architecture}} {{was initially}} designed {{to support the}} <b>fat</b> <b>client</b> model of distributed applications; it also supports whole-file transfers.|$|E
5000|$|Casting : Mimie Mathy (Joséphine Delamarre), Olivia Brunaux (Véronique Maillard), Valérie Vogt (Corinne), Patrick Catalifo (Wadeck Maréchal), Laura Martel (Vanessa Maillard), Marie Coesens (Chloé Maillard), Vincent Grass (<b>Fat</b> <b>client),</b> Jean Dell (The officer), ...|$|E
50|$|Alternatively {{end users}} can use <b>fat</b> <b>clients</b> like Mozilla Thunderbird or Microsoft Outlook {{as well as}} mobile devices to connect to the backend.|$|R
50|$|Both {{thin client}} and {{diskless}} node architectures employ diskless clients which have advantages over <b>fat</b> <b>clients</b> (see above), but differ {{with regard to}} the location of processing.|$|R
50|$|Their creators {{claim that}} {{programs}} built with RCP are portable to many operating systems while being {{as rich as}} client-server applications which use so called <b>fat</b> <b>clients</b> or traditional clients.|$|R
50|$|Traditionally, ClearQuest has {{comprised}} a <b>fat</b> <b>client</b> and {{a number}} of databases existing on a backend RDBMS server to store all captured data. ClearQuest supports various backend databases including Oracle, SQL Server and IBM DB2.|$|E
5000|$|LTSP v5.x {{added support}} for a thin client type known as [...] "fat clients". With the advent of inexpensive, {{relatively}} powerful computer hardware, the idea to run applications locally on the thin client while offering the manageability of a thin client solution became a reality. In {{the case of a}} LTSP <b>fat</b> <b>client,</b> the root filesystem is not a rudimentary chroot but a full Linux installation as a chroot. The <b>fat</b> <b>client</b> uses LDM to authenticate to the LTSP server and mounts user home directories using SSH and FUSE. The local CPU and RAM is used on the fat clients, which provides a few benefits.|$|E
5000|$|A <b>fat</b> <b>client</b> {{refers to}} a device that has {{sufficient}} speed and size to run programs and is loaded locally with software needed for operation. It can stand alone. Some advantages {{of this type of}} system are: ...|$|E
40|$|Web {{applications}} {{are becoming increasingly}} popular for mobile wireless PDAs. However, web browsing on these systems can be quite slow. An alternative approach is handheld thin-client computing, in which the web browser and associated application logic run on a server, which then sends simple screen updates to the PDA for display. To assess the viability of this thin-client approach, we compare the web browsing performance of thin <b>clients</b> against <b>fat</b> <b>clients</b> that run the web browser locally on a PDA. Our results show that thin clients can provide better web browsing performance compared to <b>fat</b> <b>clients,</b> {{both in terms of}} speed and ability to correctly display web content. Surprisingly, thin clients are faster even when having to send more data over the network. We characterize and analyze different design choices in various thin-client systems and explain why these approaches can yield superior web browsing performance on mobile wireless PDAs...|$|R
50|$|Diskless nodes {{can be seen}} as a {{compromise}} between <b>fat</b> <b>clients</b> (such as ordinary personal computers) and centralized computing, using central storage for efficiency, but not requiring centralized processing, and making efficient use of the powerful processing power of even the slowest of contemporary CPUs, which would tend to sit idle for much of the time under the centralized computing model.|$|R
5000|$|The growing use of web-based user {{interfaces}} by applications, {{along with the}} proliferation of associated practices (e.g., web design), continuously decreased the need for traditional client-server applications. Consequently, traditional software vendor's investment in software based on <b>fat</b> <b>clients</b> has become a disadvantage (mandating ongoing support), opening the door for new software vendors offering a user experience perceived as more [...] "modern".|$|R
50|$|IMPAX 6 {{features}} {{both local}} and remote access.The client can connect to the PACS server from home or office locations. This is accomplished via thin and <b>fat</b> <b>client</b> technology. The latest version is Impax 6.5, which features a stethoscope login screen.|$|E
50|$|Variations in the {{distribution}} include <b>FAT</b> <b>client</b> (Requires Ingres NET for communication), Thin eClient (can be used without Ingres NET but needs to use the Application Server instead (DCOM)), and finally mClient for Mobile Windows Clients (HTTP services required to interface to the Application server).|$|E
50|$|Cloud {{computing}} architecture {{refers to}} the components and subcomponents required for cloud computing. These components typically consist of a front end platform (<b>fat</b> <b>client,</b> thin client, mobile device), back end platforms (servers, storage), a cloud based delivery, and a network (Internet, Intranet, Intercloud). Combined, these components make up cloud computing architecture.|$|E
40|$|Thin Clients {{have evolved}} from simple text based CRT dumb {{terminal}} devices in the 1960 s, into a sophisticated architecture encompassing hardware, software, networks and protocols. However despite this recent evolution the Thin Client model {{has yet to}} re-emerge as a relevant design in an IT industry where <b>Fat</b> <b>Clients</b> (desktops and laptops) thrive. This paper describes two case studies performed within the Dublin Institute of Technology School of Computing, focused {{on the issue of}} student acceptance of this technology. The first case study provides a dedicated single service Thin Client implementation, while the second case study adopts a process of coexistence with <b>Fat</b> <b>Clients</b> in addition to providing new services to users. This paper examines both approaches as strategies for the integration of Thin Client technology into a Higher Level Educational Institute and through our data analysis demonstrates that while co-existence improves acceptance there are clearly additional factors to be resolved...|$|R
40|$|Web {{applications}} {{are becoming increasingly}} popular for mobile wireless systems. However, wireless networks can have high packet loss rates, which can degrade web browsing performance on wireless systems. An alternative approach is wireless thin-client computing, in which the web browser runs on a remote thin server with a more reliable wired connection to the Internet. A mobile client then maintains {{a connection to the}} thin server to receive display updates over the lossy wireless network. To assess the viability of this thin-client approach, we compare the web browsing performance of thin <b>clients</b> against <b>fat</b> <b>clients</b> that run the web browser locally in lossy wireless networks. Our results show that thin clients can operate quite effectively over lossy networks. Compared to <b>fat</b> <b>clients</b> running web browsers locally, our results show surprisingly that thin clients can be faster and more resilient on web applications over lossy wireless LANs despite having to send more data over the network. We characterize and analyze different design choices in various thin-client systems and explain why these approaches can yield superior web browsing performance in lossy wireless networks...|$|R
50|$|As {{microcomputers}} {{decreased in}} price and increased in {{power from the}} 1980s to the late 1990s, many organizations transitioned computation from centralized servers, such as mainframes and minicomputers, to <b>fat</b> <b>clients.</b> This afforded greater, more individualized dominion over computer resources, but complicated information technology management. During the 2000s, web applications matured enough to rival application software developed for a specific microarchitecture. This maturation, more affordable mass storage, {{and the advent of}} service-oriented architecture were among the factors that gave rise to the cloud computing trend of the 2010s.|$|R
50|$|Greater network {{bandwidth}} (i.e. capacity) {{will also be}} used in a diskless model, compared to a <b>fat</b> <b>client</b> model. This {{does not necessarily mean that}} a higher capacity network infrastructure will need to be installed—it could simply mean that a higher proportion of the existing network capacity will be used.|$|E
50|$|A simple web-based {{tool for}} quick ad hoc displays. PI Vision {{is a thin}} client tool {{and can be used}} {{anywhere}} an Internet connection is available, as opposed to the other end-user tools that are considered <b>fat</b> <b>client</b> and require a local installation. Prior to March 2017, PI Vision was called PI Coresight.|$|E
50|$|A <b>fat</b> <b>client</b> still {{requires}} {{at least}} periodic {{connection to a}} network or central server, but is often characterised by the ability to perform many functions without that connection. In contrast, a thin client generally does as little processing as possible and relies on accessing the server each time input data needs to be processed or validated.|$|E
50|$|Large {{numbers of}} nodes making {{demands on the}} same server {{simultaneously}} can slow down everyone's experience. However, this can be mitigated by installing large amounts of RAM on the server (which speeds up read operations by improving caching performance), by adding more servers (which distributes the I/O workload), or by adding more disks to a RAID array (which distributes the physical I/O workload). In any case {{this is also a}} problem which can affect any client-server network to some extent, since, of course, <b>fat</b> <b>clients</b> also use servers to store user data.|$|R
40|$|Obese, overweight, or fat are terms {{many people}} use to {{describe}} themselves and others. The terms often reflect a prejudicial attitude toward fat people which causes much emotional pain and negatively affects body image and self-esteem. The current paradigm holds that all people {{can and should be}} 2 ̆ 2 slim 2 ̆ 2 and that fat is the result of gluttony and within the control of the individual. This dissertation explores the extent and effect of fat prejudice. It challenges the current paradigm discusses diagnostic problems, proposes a new DSM-IV personality disorder called Ego-Dystonic Body Image, and develops recommendations for psychologists working with <b>fat</b> <b>clients</b> or clients presenting with the desire for weight loss...|$|R
50|$|Organizations {{also use}} RUM to test website or {{application}} changes prior to deployment by monitoring for errors or slowdowns in the pre-deployment phase. They may also {{use it to}} test changes within the production environment, or to anticipate behavioural changes in a website or application. For example, a website may add an area where users could congregate before moving forward in a group (for example, test-takers that log into a website individually {{over a period of}} twenty minutes and that then simultaneously begin taking a test), this is called rendezvous in test environments. Changes to websites such as these can be tested with RUM. As technology shifts more and more to hybrid environments like cloud, <b>fat</b> <b>clients,</b> widgets, and apps, it becomes more and more important to monitor from within the client itself.|$|R
5000|$|A <b>fat</b> <b>client</b> (also called heavy, rich or thick client) is a {{computer}} (client) in client-server architecture or networks that typically provides rich functionality independent of the central server. Originally known as just a [...] "client" [...] or [...] "thick client" [...] the name is contrasted to thin client, which describes {{a computer}} heavily dependent on a server's applications.|$|E
50|$|Although {{this initial}} NC {{standard}} {{was intended to}} promote the diskless workstation model of computing, it did not preclude computers with additional features, {{such as the ability}} to operate either as a diskless workstation or a conventional <b>fat</b> <b>client.</b> Thus, an ordinary personal computer (PC) having all the required features, could technically be classified as a Network Computer; indeed, Sun noted that contemporary PCs did indeed meet the NC reference requirements.|$|E
5000|$|<b>Fat</b> <b>client</b> {{applications}} perform all application processing tasks on client systems, but data is centralized in {{a server}} {{so that it}} can be managed, {{so that it can}} be accessed by any authorized client application, so that all client applications work with up-to-date data, and so that only the records, stream sections, or database tables affected by an application are transmitted. Client application programs must be distributed to all clients that work with the centralized data.|$|E
50|$|The use {{of central}} disk storage also makes more {{efficient}} use of disk storage. This can cut storage costs, freeing up capital to invest in more reliable, modern storage technologies, such as RAID arrays which support redundant operation, and storage area networks which allow hot-adding of storage without any interruption. Further, it means that losses of disk drives to mechanical or electrical failure—which are statistically highly probable events over a timeframe of years, {{with a large number}} of disks involved—are often both less likely to happen (because there are typically fewer disk drives that can fail) and less likely to cause interruption (because they would likely be part of RAID arrays). This also means that the nodes themselves are less likely to have hardware failures than <b>fat</b> <b>clients.</b>|$|R
50|$|Cloud {{computing}} architectures {{consist of}} front-end platforms called clients or cloud clients. These <b>clients</b> are servers, <b>fat</b> (or thick) <b>clients,</b> thin clients, zero clients, tablets and mobile devices. These client platforms {{interact with the}} cloud data storage via an application (middleware), via a web browser, or through a virtual session.|$|R
40|$|User Experience {{has become}} a key success factor for today's {{software}} applications. As {{the only part of}} a software application a user has direct contact with, the user interface contributes to a large degree to the overall user experience. This applies especially to ambient intelligence (AmI) systems that are more user centered than traditional systems. Although a system's software architecture is considered {{as one of the most}} significant technical factors in ensuring project success, its influence on user experience is usually neglected in today's software development. Thereby, the connection between the user interface part of a system and the system's core functionality is of particular importance. A system's distribution architecture and in particular the used client type has a significant influence on the overall user experience. The central contribution of this thesis is the introduction of an application's client type as an explicit adaptation factor in software development in general and in user interface generation in particular to improve user experience. As AmI systems are characterized by openness, heterogeneity and run-time dynamics, their user interfaces have to be generated to provide always an adequate user experience for the frequently changing usage situation. Thus, the appropriate client type needs to be determined automatically during user interface generation. To support developers in the client type selection, we provide a comprehensive characterization of nowadays commonly used <b>client</b> types: <b>fat</b> <b>clients,</b> thin clients, smart clients, rich internet clients and ultra-thin clients. Furthermore, we propose a method that allows the selection of an adequate client type for the current usage situation. Based on a detailed quality model that allows the assessment of the influence of several client type characteristics on the overall user experience and a usage situation model that describes context factors affecting the client type selection, the method determines the recommended client type automatically using a weighting function. With a concrete implementation of our client type selection method, supporting a fully automatic user interface generation approach that we applied within the ambient assisted living (AAL) domain, we demonstrate the feasibility of our approach. Finally, we describe further tool-support for user interface developers using a semi-automatic UI generation approach as well as for developers using a traditional software development process. Ultimately, the client type selection should be considered explicitly for every application during development...|$|R
