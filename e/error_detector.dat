121|349|Public
5000|$|Clock signal {{generator}} to synchronize the pattern generator and the <b>error</b> <b>detector</b> ...|$|E
5000|$|<b>Error</b> <b>detector</b> {{connected}} to the DUT or test system, to count the errors generated by the DUT or test system ...|$|E
50|$|KZO (Small {{aircraft}} {{target acquisition}} / drone) FFG developed the mobile launch container for this UAV. An integrated power supply, and antenna, in the launch container can act completely independently of accompanying systems. The start is controlled via a CAN-bus system, which {{is equipped with}} an <b>error</b> <b>detector.</b>|$|E
40|$|Abstract — This paper {{presents}} {{a technique to}} derive and implement <b>error</b> <b>detectors</b> to protect an application from data <b>errors.</b> The <b>error</b> <b>detectors</b> are derived automatically using compiler-based static analysis from the backward program slice of critical variables in the program. Critical variables are defined as those that are highly sensitive to errors, and deriving <b>error</b> <b>detectors</b> for these variables provides high coverage for errors in any data value used in the program. The <b>error</b> <b>detectors</b> {{take the form of}} checking expressions and are optimized for each control flow path followed at runtime. The derived detectors are implemented using a combination of hardware and software...|$|R
40|$|This paper {{presents}} {{a technique to}} derive and implement <b>error</b> <b>detectors</b> to protect an application from data <b>errors.</b> The <b>error</b> <b>detectors</b> are derived automatically using compiler-based static analysis from the backward program slice of critical variables in the program. Critical variables are defined as those that are highly sensitive to errors, and deriving <b>error</b> <b>detectors</b> for these variables provides high coverage for errors in any data value used in the program. The <b>error</b> <b>detectors</b> {{take the form of}} checking expressions and are optimized for each control flow path followed at runtime. The derived detectors are implemented using a combination of hardware and software. Experiments show that the derived detectors incur low performance overheads while achieving high error-detection coverage. 1...|$|R
40|$|We {{present a}} method {{for the design of}} low {{complexity}} tim-ing <b>error</b> <b>detectors</b> in orthogonal space-time block coding (OS-TBC) receivers. A general expression for the S-curve of timing <b>error</b> <b>detectors</b> is derived. Based on this result, we obtain suffi-cient conditions for a difference of threshold crossings timing estimate that is robust to channel fading. A number of tim-ing <b>error</b> <b>detectors</b> for 3 - and 4 -transmit antenna codes are pre-sented. The performance is evaluated by examining their track-ing capabilities within a timing loop of an OSTBC receiver. Symbol-error-rate results are presented showing negligible loss due to timing synchronization. In addition, we study the per-formance {{as a function of the}} timing drift and show that the receiver is able to track up to the normalized timing drift band-width of 0. 001. ...|$|R
40|$|In {{this paper}} we propose a new timing <b>error</b> <b>detector</b> for timing {{tracking}} loops inside the Rake receiver in DS-CDMA. Based on a particle filter, this timing <b>error</b> <b>detector</b> jointly tracks the delays of each path of the frequency selective channels. The proposed scheme avoids the drawback of the classical early late gate detector which is not able to separate closely spaced paths. Simulation results show that the proposed detector outperforms the conventional early late gate detector in indoor scenarios. 1...|$|E
3000|$|..., {{but simply}} to assess its {{theoretical}} performance. In a practical receiver, an adaptive algorithm (similar to a timing <b>error</b> <b>detector</b> [40]) {{could be used}} to compute [...]...|$|E
40|$|This paper {{describes}} how a prototype, the agreement <b>error</b> <b>detector,</b> for agreement error detection was implemented and tested. The implementation {{is based on}} a study of Swedish noun phrases. The prototype was designed to look for agreement errors in the most frequent types of noun phrases in the study. Relaxation techniques were used for detecting the agreement errors. A comparison was made between two different ways of handling morphological ambiguity. In the first approach words were tagged with all word classes and morphological features that they could take before being analysed by the agreement <b>error</b> <b>detector.</b> In the second approach all words were not only tagged but also probabilstically disambiguated and had only one tag before being analysed by the agreement <b>error</b> <b>detector.</b> The results of the agreement error detection depend very much on the chosen tagging approach. With the first approach the correct detection of errors in a small error sample was about 70 percent. When using the programme on a larger unsee...|$|E
40|$|The {{effect of}} {{crosstalk}} errors is most significant in highperformance circuits, mandating at-speed testing for crosstalk defects. This paper describes a self-test methodology {{that we have}} developed to enable on-chip at-speed testing of crosstalk defects in System-on-Chip interconnects. The self-test methodology {{is based on the}} Maximal Aggressor Fault Model [13], that enables testing of the interconnect with a linear number of test patterns. To enable self-testing of the interconnects, we have designed efficient on-chip test generators and <b>error</b> <b>detectors</b> to be embedded in necessary cores; while the test generators generate test vectors for crosstalk faults, the <b>error</b> <b>detectors</b> analyze the transmission of the test sequences received from the interconnects, and detect any transmission errors. We have also designed test controllers to initiate and manage test transactions by activating the appropriate test generators and <b>error</b> <b>detectors,</b> and having <b>error</b> diagnosis capability. We have deve [...] ...|$|R
5000|$|Non-data-aided/"blind" [...] carrier {{recovery}} methods do {{not rely}} on any knowledge of the modulation symbols. They are typically used for simple carrier recovery schemes or as the initial method of coarse carrier frequency recovery. Closed-loop non-data-aided systems are frequently maximum likelihood frequency <b>error</b> <b>detectors.</b>|$|R
40|$|Modern {{computer}} scaling {{trends in}} pursuit of larger component counts and power efficiency have, unfortunately, lead to less reliable hardware and consequently soft errors escaping into application data ("silent data corruptions"). Techniques to enhance system resilience hinge {{on the availability of}} efficient <b>error</b> <b>detectors</b> that have high detection rates, low false positive rates, and lower computational overhead. Unfortunately, efficient detectors to detect faults during address generation (to index large arrays) have not been widely researched. We present a novel lightweight compiler-driven technique called PRESAGE for detecting bit-flips affecting structured address computations. A key insight underlying PRESAGE is that any address computation scheme that flows an already incurred error is better than a scheme that corrupts one particular array access but otherwise (falsely) appears to compute perfectly. Enabling the flow of errors allows one to situate detectors at loop exit points, and helps turn silent corruptions into easily detectable error situations. Our experiments using PolyBench benchmark suite indicate that PRESAGE-based <b>error</b> <b>detectors</b> have a high error-detection rate while incurring low overheads...|$|R
30|$|We {{propose a}} new timing <b>error</b> <b>detector</b> for timing {{tracking}} loops inside the Rake receiver in spread spectrum systems. Based on a particle filter, this timing <b>error</b> <b>detector</b> jointly tracks the delays of each {{path of the}} frequency-selective channels. Instead of using a conventional channel estimator, we have introduced a joint time delay and channel estimator with almost no additional computational complexity. The proposed scheme avoids the drawback of the classical early-late gate detector which {{is not able to}} separate closely spaced paths. Simulation results show that the proposed detectors outperform the conventional early-late gate detector in indoor scenarios.|$|E
30|$|The PLL {{algorithm}} aims {{to maximize}} the phase likelihood function, which is obtained when {{the output of the}} phase <b>error</b> <b>detector</b> is zero. A more complete description of the PLL algorithm can be found in [33].|$|E
3000|$|Serving as the <b>error</b> <b>detector</b> {{within a}} PLL, the input {{signal to the}} BE filter must already be frequency-shifted or error-compensated as shown in Figure  4. Re-examine Equation  12 and {{consider}} a non-trivial IPE, i.e., [...]...|$|E
40|$|International audienceReal-time {{software}} applications {{are in charge}} of maintaining a timely and predictable interaction with their environment, being it hardware devices, or other software entities. In this paper, we illustrate the use of early <b>error</b> <b>detectors</b> (that we previously described in [1]), generated from timed automata based specifications, in a recovery block-like design pattern. This design pattern is enhanced with our Early Error Detection service that allows triggering as soon as possible error recovery mechanism...|$|R
50|$|In {{a control}} system, a synchro {{will provide a}} voltage for {{conversion}} to torque through an amplifier and a servomotor. Control type synchros are used in applications that require large torques or high accuracy such as follow-up links and <b>error</b> <b>detectors</b> in servo, automatic control systems (such as an autopilot system). In simpler terms, a control synchro system is {{a system in which}} the transmitted signal controls a source of power which does the usable work.|$|R
40|$|Which {{components}} of a large software system are the most defect-prone? In a study on a large SAP Java system, we evaluated and compared a number of defect predictors, based on code features such as complexity metrics, static <b>error</b> <b>detectors,</b> change frequency, or component imports, thus replicating a number of earlier case studies in an industrial context. We found the overall predictive power to be lower than expected; still, the resulting regression models successfully predicted 50 – 60 % of the 20 % most defectprone components. 1...|$|R
40|$|A new {{approach}} to synchronization recovery for signals watermarked using the Dither Modulation data hiding scheme is presented. The strategy followed {{involves the use of}} a digital phase-locked loop to track the offsets applied by an attacker to the sampling grid of the watermarked signal. The main element in this synchronization loop is the timing <b>error</b> <b>detector</b> which is responsible for generating an error signal, used to update the estimates of the applied offsets. It is shown how a timing <b>error</b> <b>detector</b> which has been used in digital communications may be easily adapted to extract timing information from DM watermarked signals. The performance of the proposed synchronizer is evaluated using the probability of decoding error under different models for the sampling grid offsets. 1...|$|E
40|$|Abstract. This paper {{deals with}} {{simplification}} and im-provement of data timing synchronization algorithms. Timing error synchronizers {{are usually the}} most compli-cated subsystems in the demodulator, and limit the DSP technique used for the high-rate application. This article is focused on feedback timing estimators for PSK modulation schemes, and shows modifications of widely used algo-rithms, that are suitable for the DSP implementation, as well as reach better parameters of the detection process. The methods applied {{in the evaluation of}} a timing <b>error</b> <b>detector,</b> which is a crucial part of the synchronizer, are described in the last part. Keywords Additive white Gaussian noise, delay lock loop, digital signal processing, early-late detector, ML criterion, Mueller-Mueller detector, normalized timing error variance, phase shift keying, timing synchronization, timing <b>error</b> <b>detector,</b> raised-cosine pulse shaping, zero-crossing detector. 1...|$|E
40|$|This thesis {{presents}} a timing <b>error</b> <b>detector</b> (TED) {{used in the}} symbol timing synchronization subsystem for digital communications. The new timing <b>error</b> <b>detector</b> is designed to minimize the probability of symbol decision error, and it is called minimum symbol error rate TED (MSERTED). The new TED resembles the TED derived using the maximum likelihood (ML) criterion but gives rise to faster convergence relative to MLTED. The new TED requires shorter training sequences for symbol timing recovery. The TED operates on the outputs of the matched filter and estimates the timing offset. The S-curve {{is used as a}} tool for analyzing the behavior of the TEDs. The faster convergence of the new TED is shown in simulation results as compared to MLTED. The new TED works well for any two-dimensional constellation with arbitrarily shaped decision regions...|$|E
40|$|Abstract — The {{performance}} of an approximately MAI-free OFDM transceiver, called the repetitively coded multicarrier CDMA (RCMC-CDMA), is evaluated and compared with MC-CDMA in this work. In particular, its advantages on the MAI reduction capability {{and the low}} implementational complexity are presented. We first demonstrate that RCMC-CDMA has the performance comparable to MC-CDMA using a linear MUD (multiuser detection) MMSE (minimum mean squared <b>errors)</b> <b>detector,</b> while it outperforms MC-CDMA with a MUD decorrelating detector. Then, the complexity of RCMC-CDMA is shown to be {{lower than that of}} MUD-based MC-CDMA...|$|R
40|$|Abstract — Design and {{analysis}} of low complexity timing <b>error</b> <b>detectors</b> (TEDs) for quasi-orthogonal space-time block coding systems are presented. The detectors operate on data symbols and approximate decision variables, producing timing error mea-surement robust to channel fading. In addition to the estimator S-curve, we obtain the estimation error variance and TED SNR, with the analysis carried out under the assumptions of perfect data and channel knowledge at the receiver. Simulations are {{used to examine the}} effects of decision <b>errors</b> on the <b>detector</b> characteristics, and to evaluate the overall system performance, where the proposed TEDs are incorporated into the receiver timing loop. Receivers with perfect channel knowledge and pilot-based channel estimation are considered. Symbol error rate results show timing synchronization loss of less than 0. 5 dB for a receiver with perfect channel information. I...|$|R
3000|$|A minimum {{mean square}} <b>error</b> (MMSE) <b>detector</b> is {{commonly}} applied to mitigate interference. Because of the linear signal model in (32), MMSE detection is also available. Here, the M×(N [...]...|$|R
40|$|An {{alternative}} simple derivation for {{the well-known}} soft-in soft-out LMMSE (linear minimum mean square <b>error)</b> <b>detector</b> in a turbo system is presented. The derivation {{leads to a}} concise representation for the LMMSE detector {{in terms of the}} extrinsic means and extrinsic variances of the data symbols, and provides new perspectives for its implementation. © 2006 IEEE...|$|E
40|$|Free memory already freed – Using freed memory – Using uninitialized {{variables}} – Using undeclared memory – Read/Write to invalid bound – Memory leaks • Stacks – Array index {{out of bound}} – Function pointer corruption NanoCAD Lab Valgrind Overview: Tool Suite • Memcheck: memory <b>error</b> <b>detector</b> • Cachegrind: cache and branch-prediction profiler • Callgrind: call-graph generating cache profiler • Massif: heap profiler • Helgrind: thread <b>error</b> <b>detector</b> valgrind [valgrind-options] your-prog [your-prog-options] NanoCAD Lab Memcheck • Memcheck detects memory-management problems, and {{is aimed}} primarily at C and C++ programs. • All reads and writes of memory are checked, and calls to malloc/new/free/delete are intercepted. valgrind [...] tool=memcheck ls-l NanoCAD Lab Memcheck machinery • Uses “V bit ” for every bit of data to check validity • Uses “A bit ” for every byte of data in memory to detect accessibility • Set on malloc/new and reset on free/delet...|$|E
40|$|This {{paper is}} devoted to the {{proposal}} of a highly efficient symbol synchronization subsystem for Software Defined Radio. The proposed feedback phase-locked loop timing synchronizer is suitable for parallel implementation on an FPGA. The polyphase FIR filter simultaneously performs matched-filtering and arbitrary interpolation between acquired samples. Determination of the proper sampling instant is achieved by selecting a suitable polyphase filterbank using a derived index. This index is determined based on the output either the Zero-Crossing or Gardner Timing <b>Error</b> <b>Detector.</b> The paper will extensively focus on simulation of the proposed synchronization system. On the basis of this simulation, a complete, fully pipelined VHDL description model is created. This model is composed of a fully parallel polyphase filterbank based on distributed arithmetic, timing <b>error</b> <b>detector</b> and interpolation control block. Finally, RTL synthesis on an Altera Cyclone IV FPGA is presented and resource utilization in comparison with a conventional model is analyzed...|$|E
5000|$|... #Subtitle level 4: Sources of <b>error</b> in the <b>{{detector}}</b> or detector settings ...|$|R
40|$|The use of spectrally e cient {{continuous}} phase modulations for mobile communications {{may lead to}} a serious performance degradation of the classical frequency <b>error</b> <b>detectors</b> (FEDs) due to the presence of self-noise. This contribution presents a new statistically e cient frequency estimation algorithm for staggered modulations. The cancellation of the self-noise is accomplished by the use of the Conditional ML principle, well known in the context of array processing, {{as an alternative to the}} Unconditional ML, typically applied in the communications eld. The paper also provides a new Cramer Rao Bound (CRB) which is more accurate than the so-called Modi ed CRB (MCRB) extensively applied to synchronization problems. 1...|$|R
40|$|This thesis proposes {{adaptable}} {{error detection}} technique {{for improving the}} availability of embedded systems, and in particular Automated Teller Machines (ATMs). The principles associated with immune-inspired techniques are exploited for detecting unforseen errors during run-time, since traditional techniques for error detection are usually limited to the knowledge available during design-time. Furthermore, the adaptable <b>error</b> <b>detectors</b> {{can be used to}} predict system failure well before it happens in order to improve overall system availability and/or maintainability. This thesis introduces a framework for realising adaptable error detection (AED), and demonstrates the effectiveness of an artificial immune system (AIS) as a technique for its implementation. Using data obtained from ATMs, the effectiveness of the AIS technique is evaluated based on the efficacy at detecting the incipience of failures. From the early awareness of impending failures, appropriate actions, such as error recovery or operator warning, can be initiated to prevent the deviaton of system's operations from correct service delivery. Alternatively, the foreknowledge of an imminent failure may quicken system repair with the effect that the downtime of the system is reduced and the system's availability is enhanced. The outcome of the investigations showed that the implemented AED could detect the antecedents to failure. The effects of the continuous learning feature were demonstrated in terms of: (1) a continual update of <b>error</b> <b>detectors</b> depending on new run-time bheaviours, and (2) an improvement in the detection capability by anticipating potential failures. Based on these results, I concluded that the adaptable error detection technique proposed is a step towards enhancing the availability of ATMs. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
40|$|The {{conditional}} {{maximum likelihood}} (CML) principle, {{well known in}} the context of sensor array processing, is applied to the problem of timing recovery. A new self-noise free CML-based timing <b>error</b> <b>detector</b> is derived. Additionally, a new (conditional) Cramer-Rao bound (CRB) for timing estimation is obtained, which is more accurate than the extensively used modified CRB (MCRB). Peer ReviewedPostprint (published version...|$|E
40|$|A {{reference}} signal of RF frequency modulates a 0. 85 micrometer wavelength optical transmitter. The output of which {{passes through a}} first optical filter and a voltage-controller phase shifter. The output of the phase shifter is provided to the fiber optic transmission line. At {{the receiving end of}} the transmission line, the signal is demodulated and used to modulate a 1. 06 micrometer optical transmitter. The signal from the transmitter is provided to the fiber optic transmission line and passes through the voltage-controlled phase shifter to a phase <b>error</b> <b>detector.</b> The phase of the modulation of the 1. 06 micrometer wavelength signal is compared to the phase of the {{reference signal}} by the phase <b>error</b> <b>detector.</b> A phase control signal related to the phase difference is provided to the voltage controlled phase shifter which alters the phase of both optical signals until a predetermined phase relationship between modulation on the 1. 06 micrometer signal and the reference signal is obtained...|$|E
40|$|Proposed {{open-loop}} analog/digital signal-processing {{system would}} be Costas-loop <b>error</b> <b>detector</b> functioning in closed-loop manner overall. Detector estimates difference between frequency of input signal and internal reference oscillator. Estimate used to close frequency-control loop. Precise symbol timing not necessary. Performance better than systems that effect open-loop acquisition using integrators instead of low-pass filters in arms of Costas loops and in which performance varies with symbol timing...|$|E
40|$|This paper {{introduces}} SymPLFIED, a program-level framework {{which allows}} specification of arbitrary <b>error</b> <b>detectors</b> and the verification of their efficacy against hardware errors. SymPLFIED comprehensively enu-merates all transient hardware errors in registers, memory and computation (expressed symbolically as value errors) that potentially evade detection and cause program failure. The framework uses symbolic execu-tion to abstract {{the state of}} erroneous values in the pro-gram and model checking to comprehensively find all errors that evade detection. We demonstrate the use of SymPLFIED on a widely deployed aircraft collision avoidance application, tcas. Our {{results show that the}} SymPLFIED framework can be used to uncover hard-to-detect corner cases caused by transient errors in programs that may not be exposed by random fault-injection based validation. ...|$|R
40|$|Mutual clock {{synchronization}} over a wireless channel has been recently {{studied in the}} framework of pulse-coupled oscilla-tors using either models borrowed from mathematical biology or the model of coupled discrete-time Phase Locked Loops (PLLs). In this paper, we focus on the latter case and extend previous analyses by considering frequency-asynchronous clocks, second-order PLLs and by addressing the issues of propaga-tion delays, finite pulse resolution and half-duplex constraints. Moreover, we provide a steady-state and convergence analy-sis of the system under the ideal assumption of infinite-resolution time <b>error</b> <b>detectors,</b> exploiting some results from the litera-ture on consensus of multi-agents networks. Finally, numer-ical examples are discussed that corroborate the analysis and show the impact of system parameters such as transmit / re-ceive switching time and oversampling factor at the receiver...|$|R
40|$|We present ClearView, {{a system}} for {{automatically}} patching errors in deployed software. ClearView works on stripped Windows x 86 binaries without any need for source code, debugging information, or other external information, and without human intervention. ClearView (1) observes normal executions to learn invariants that characterize the application’s normal behavior, (2) uses <b>error</b> <b>detectors</b> to distinguish normal executions from erroneous executions, (3) identifies violations of learned invariants that occur during erroneous executions, (4) generates candidate repair patches that enforce selected invariants by changing the state or flow of control to make the invariant true, and (5) observes the continued execution of patched applications to select the most successful patch. ClearView is designed to correct errors in software with high availability requirements. Aspects of ClearView that make it particularl...|$|R
