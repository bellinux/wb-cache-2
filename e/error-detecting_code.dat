30|50|Public
50|$|Finally, {{some form}} of <b>error-detecting</b> <b>code</b> (perhaps {{as simple as a}} cyclic {{redundancy}} check) is applied to the packet, and the packet is transmitted.|$|E
5000|$|All frames not {{employing}} the Reed-Solomon code use a {{cyclic redundancy check}} (CRC) <b>error-detecting</b> <b>code,</b> which has an undetected frame-error rate of less than 1 in 32,000.|$|E
5000|$|The {{concept of}} the CRC as an <b>error-detecting</b> <b>code</b> gets {{complicated}} when an implementer or standards committee uses it to design a practical system. Here {{are some of the}} complications: ...|$|E
5000|$|Checksums and hash functions, {{combined}} with the input data, {{can be viewed as}} systematic <b>error-detecting</b> <b>codes.</b>|$|R
40|$|In this paper, we {{investigate}} the optimal nonadditive quantum <b>error-detecting</b> <b>codes</b> with distance two. The the numerical simulation shows that, with n being can be 5, 6, 7, 8, 10 and 12, such the n-qubit quantum <b>error-detecting</b> <b>codes</b> with maximal number of codewords can be found. Therein, except the n= 7 case, the n-vertex loop graphs help find the optimal quantum codes. Comment: 6 pages, 22 figure...|$|R
50|$|A {{number of}} simple <b>error-detecting</b> <b>codes</b> were used before Hamming codes, but none were as {{effective}} as Hamming codes in the same overhead of space.|$|R
5000|$|Even {{when the}} channel errors exceed the {{correction}} {{capability of the}} error-correcting code, the presence of errors is nearly always detected by the error-correcting code or by a separate <b>error-detecting</b> <b>code.</b>|$|E
50|$|A frame check {{sequence}} (FCS) refers to the extra <b>error-detecting</b> <b>code</b> added to a frame in a communications protocol. Frames are used to send upper-layer data and ultimately the application data from a source to a destination.|$|E
50|$|Designers {{can choose}} to accept that soft errors will occur, and design systems with {{appropriate}} error detection and correction to recover gracefully. Typically, a semiconductor memory design might use forward error correction, incorporating redundant data into each word to create an error correcting code. Alternatively, roll-back error correction can be used, detecting the soft error with an <b>error-detecting</b> <b>code</b> such as parity, and rewriting correct data from another source. This technique is often used for write-through cache memories.|$|E
50|$|Memory {{scrubbing}} does error-detection and {{correction of}} bit errors in computer RAM by using ECC memory, other {{copies of the}} data, or other <b>error-detecting</b> <b>codes.</b>|$|R
40|$|Error-correcting or <b>error-detecting</b> <b>codes</b> {{have been}} used in the {{computer}} industry to increase reliability, reduce service costs, and maintain data integrity. The single-byte error-correcting and double-byte <b>error-detecting</b> (SbEC-DbED) <b>codes</b> have been successfully used in computer memory subsystems. There are many methods to construct double-byte error-correcting (DBEC) codes. In the present paper we construct a class of double-byte error-correcting codes, which are more efficient than those known to be optimum, and a decoding procedure for our codes is also considered...|$|R
50|$|Irving Stoy Reed (November 12, 1923 - September 11, 2012) was a {{mathematician}} and engineer. He {{is best known}} for co-inventing a class of algebraic error-correcting and <b>error-detecting</b> <b>codes</b> known as Reed-Solomon codes in collaboration with Gustave Solomon. He also co-invented the Reed-Muller code.|$|R
50|$|A Cyclic Redundancy Check (CRC) is an <b>error-detecting</b> <b>code</b> {{commonly}} used in digital networks and storage devices to detect accidental changes to raw data. Blocks of data entering these systems get a short check value attached, based on the remainder of a polynomial division of their contents. On retrieval, the calculation is repeated and, in the event the check values do not match, corrective action can be taken against data corruption. CRCs {{can be used for}} error correction, see bitfilters.|$|E
5000|$|A dumb fuzzer {{does not}} require the input model and can thus be {{employed}} to fuzz a wider variety of programs. For instance, AFL is a dumb mutation-based fuzzer that modifies a seed file by flipping random bits, by substituting random bytes with [...] "interesting" [...] values, and by moving or deleting blocks of data. However, a dumb fuzzer might generate a lower proportion of valid inputs and stress the parser code rather than the main components of a program. The disadvantage of dumb fuzzers can be illustrated by means of the construction of a valid checksum for a cyclic redundancy check (CRC). A CRC is an <b>error-detecting</b> <b>code</b> that ensures that the integrity of the data contained in the input file is preserved during transmission. A checksum is computed over the input data and recorded in the file. When the program processes the received file and the recorded checksum does not match the re-computed checksum, then the file is rejected as invalid. Now, a fuzzer that is unaware of the CRC is unlikely to generate the correct checksum. However, there are attempts to identify and re-compute a potential checksum in the mutated input, once a dumb mutation-based fuzzer has modified the protected data.|$|E
5000|$|Since the {{interpreter}} lacked sufficient memory space to store error messages, Richard Merrill used a work-around. FOCAL reported {{the address of}} the <b>error-detecting</b> <b>code</b> as a pseudo floating-point number. For example, the division by zero error was detected by code at address 4333 so the error message was: ?28.73 @ 01.10 (where 01.10 referred to the line number). Code Meaning ?00.00 Manual start given from console. ?01.00 Interrupt from keyboard via CTRL/C. ?01.40 Illegal step or line number used. ?01.78 Group number is too large. ?01.96 Double periods found in a line number. ?01.:5 Line number is too large. ?01.;4 Group zero is an illegal line number. ?02.32 Nonexistent group referenced by 'DO'. ?02.52 Nonexistent line referenced by 'DO'. ?02.79 Storage was filled by push-down-list. ?03.05 Nonexistent line number used after 'GOTO' or 'IF'. ?03.28 Illegal command used. ?04.39 Left of [...] "=" [...] in error in 'FOR' or 'SET'. ?04.52 Excess right terminators encountered. ?04.60 Illegal terminator for 'FOR' command. ?04.:3 Missing argument in Display command. ?05.48 Bad argument to 'MODIFY' ?06.06 Illegal use of function number. ?06.54 Storage is filled by variables. ?07.22 Operator missing in expression or double 'E'. ?07.38 No operator used before parenthesis. ?07.:9 No argument given after function call. ?07.;6 Illegal function name or double operators. ?08.47 Parenthesis do not match. ?09.11 Bad argument to 'ERASE'. ?10.:5 Storage was filled by text. ?11.35 Input buffer has overflowed. ?20.34 Logarithm of zero requested. ?23.36 Literal number is too large. ?26.99 Exponent is too large or negative. ?28.73 Division by zero requested. ?30.05 Imaginary square root requested. ?31.<7 Illegal character, unavailable command, or unavailable function used.|$|E
40|$|For many years, on-line testing {{techniques}} {{have been developed}} for digital circuits using <b>error-detecting</b> <b>codes.</b> More recently, some approaches on concurrent error detection for analog and mixed-signal circuits have been proposed. The techniques based on partial hardware replication and on balance checking are broadly addressed in this paper. Other approaches are briefly discussed...|$|R
40|$|Several {{methods of}} {{constructing}} systematic t-error correcting/all unidirectional <b>error-detecting</b> <b>codes</b> are described. These codes {{can be constructed}} by adding a tail to a linear t-error correcting code, but other constructions presented are more of an ad hoc nature. These codes will often be found as suitably chosen subsets of nonsystematic tEC/AUED codes. Further bounds on the word length of systematic tEC/AUED codes are derived, and extensive tables are given...|$|R
40|$|A novel {{construction}} that {{differs from the}} traditional way of constructing systematic EC/AUED/(error-correcting/all unidirectional <b>error-detecting)</b> <b>codes</b> is presented. The usual method {{is to take a}} systematic t-error-correcting code and then append a tail so that the code can detect more than t errors when they are unidirectional. In the authors' construction, the t-error-correcting code is modified {{in such a way that}} the weight distribution of the original code is reduced. The authors then have to add a smaller tail. Frequently they have less redundancy than the best available systematic t-EC/AUED codes...|$|R
40|$|A {{technique}} {{by which}} the codewords of an error-correcting code are partitioned to obtain an <b>error-detecting</b> <b>code</b> with half the original length is described. It {{is intended to be}} used in a hybrid-ARQ system for achieving high throughput on HF channels. Performance evaluations of examples based on BCH and RS codes are also providedPeer ReviewedPostprint (published version...|$|E
30|$|Data {{inconsistency}} during {{data exchange}} between grid nodes and portal machine {{can lead to}} failure in executing the next job or make results unavailable. Data verification mechanisms can solve this problem. The “cksum” tool from Linux/Unix implements the cyclic redundancy check (CRC), an <b>error-detecting</b> <b>code</b> designed to detect accidental changes to raw computer data. It {{can be used to}} detect a corruption on destination and ask the sender to transmit it again.|$|E
40|$|Abstract—One of {{the most}} {{effective}} ways of attacking a cryptographic device is by deliberate fault injection during computation, which allows retrieving the secret key with a small number of attempts. Several attacks on symmetric and public-key cryptosystems have been described in the literature and some dedicated error-detection techniques have been proposed to foil them. The proposed techniques are ad hoc ones and exploit specific properties of the cryptographic algorithms. In this paper, we propose a general framework for error detection in symmetric ciphers based on an operation-centered approach. We first enumerate the arithmetic and logic operations included in the cipher and analyze the efficacy and hardware complexity of several error-detecting codes for each such operation. We then recommend an <b>error-detecting</b> <b>code</b> for the cipher as a whole based on the operations it employs. We also deal with the trade-off between the frequency of checking for errors and the error coverage. We demonstrate our framework on a representative group of 11 symmetric ciphers. Our conclusions are supported by both analytical proofs and extensive simulation experiments. Index Terms—Cryptography, symmetric cipher, <b>error-detecting</b> <b>code,</b> parity code, residue code, fault attacks, fault detection. ...|$|E
40|$|Absfmct- The basic {{theory of}} t-UEC (I-UED codes is developed. Methods for {{construction}} of such codes from symmetric error-correcting and asymmetric error-correcting codes are developed. Some bounds for t-EC (I-UED codes are improved. Encoding/decoding procedures for these codes are discussed. Index Terms- Asymmetric error, code construction multiple errorcorrecting and <b>error-detecting</b> <b>codes</b> symmetric error unidirectional error. I. INTRODUCTION AND STATEMENT OF RESULTS The importance and benefits of error control for computer andcommunication systems are well recognized. Error-correcting/detecting codes that are effective against both symmetric and unidirectional errors are useful in protection against transient, intermittent an...|$|R
40|$|This paper {{analyses}} some of {{the most}} common <b>error-detecting</b> <b>codes</b> used in self-checking circuits with respect to the errors induced by crosstalk faults (CFs). The electrical-level behavior of circuits in the presence of CFs has been analyzed by considering these faults as parametric. A logic-level model providing the probability of errors has been abstracted and applied to the case of functional unit outputs (buses). Finally, the probability of detectable and undetectable errors has been evaluated for the parity, two-rail, m-out-of-n, and Berger codes, thus providing some design hin...|$|R
40|$|We are currenly {{living the}} age of communications. Information {{revolution}} implies efficient and reliable means of communication. Most of the communication and information storage media are not error-free, while the requirements on the digital information often do not tolerate any errors in transmission or storage retrieval. To cope with this contrast, efficient errorcorrecting <b>codes</b> and <b>error-detecting</b> <b>codes</b> were developped {{in the second half}} of the last century. This paper summarizes our experience with implementing an error-correcting protocol for communiction of PC with LEGO RCX running Lejos (Java environment) over unreliable infrared link coupled with radio BlueTooth transmission...|$|R
40|$|We rigorously analyze Knill's Fibonacci {{scheme for}} {{fault-tolerant}} quantum computation, {{which is based}} on the recursive preparation of Bell states protected by a concatenated <b>error-detecting</b> <b>code.</b> We prove lower bounds on the threshold fault rate of 0. 67 × 10 ^− 3 for adversarial local stochastic noise, and 1. 25 × 10 ^− 3 for independent depolarizing noise. In contrast to other schemes with comparable proved accuracy thresholds, the Fibonacci scheme has a significantly reduced overhead cost because it uses postselection far more sparingly...|$|E
40|$|A {{scheme for}} linear optical {{implementation}} of fault-tolerant quantum computation is proposed, {{which is based}} on an <b>error-detecting</b> <b>code.</b> Each computational step is mediated by transfer of quantum information into an ancilla system embedding error-detection capability. Photons are assumed to be subjected to both photon loss and depolarization, and the threshold region of their strengths for scalable quantum computation is obtained, together with the amount of physical resources consumed. Compared to currently known results, the present scheme reduces the resource requirement, while yielding a comparable threshold region. Comment: 9 pages, 7 figure...|$|E
40|$|This paper {{presents}} a fault tolerant configuration for a multiple discrete control system. The distributed control nodes, such as programmable logic controllers, communicate over networks. The design methodology {{of an additional}} redundant controller using Galois field and an <b>error-detecting</b> <b>code</b> is proposed. The proposed method is implemented and tested on distributed controllers connected on a network. It is shown {{that the system is}} functional even if one of the controllers fails. From a reliability analysis, it is also shown that the proposed design method drastically improves the mean time to failure of the discrete control system...|$|E
40|$|Postselected quantum {{computation}} is distinguished from regular {{quantum computation}} by accepting the output only if measurement outcomes satisfy predetermined conditions. The output {{must be accepted}} with nonzero probability. Methods for implementing postselected quantum computation with noisy gates are proposed. These methods are based on <b>error-detecting</b> <b>codes.</b> Conditionally on detecting no errors, {{it is expected that}} the encoded computation can be made to be arbitrarily accurate. Although the probability of success of the encoded computation decreases dramatically with accuracy, it is possible to apply the proposed methods to the problem of preparing arbitrary stabilizer states in large error-correcting codes with local residual errors. Together with teleported error-correction, this may improve the error tolerance of non-postselected quantum computation. Comment: 17 page...|$|R
40|$|Classical linear <b>error-detecting</b> <b>codes</b> are not optimum {{for error}} {{detection}} in communication and computational channel or data compression when the error distributions of a channel are non-stationary or unknown {{since they do}} not minimize the worst case error masking probability. Functions with flat autocorrelations {{can be used to}} construct optimum codes for such channels. In this paper we present generalized properties as well as optimum constructions {{for a wide range of}} practical parameters for such codes. These robust codes minimize the worst case error masking probability. We show a range of exemplary applications for which the codes can be used. We demonstrate the possible applications of robust codes for memory devices, data verification, and “lazy ” channels. 1...|$|R
40|$|Hardware {{implementations}} of cryptographic algorithms {{are vulnerable}} to fault analysis attacks. Methods based on traditional fault-tolerant architectures are not suited for protection against these attacks. To detect these attacks we propose an architecture based on Robust nonlinear systematic <b>error-detecting</b> <b>codes.</b> These nonlinear codes are capable of providing uniform error detecting coverage independently of the error distributions. They make no assumptions about what faults or errors will be injected by an attacker. Architectures based on these Robust construction have fewer undetectable errors than linear codes with the same (n,k). We present the general properties and construction methods of these codes {{as well as their}} application for the protection of a cryptographic devices implementing the Advanced Encryption Standard...|$|R
40|$|We prove an {{accuracy}} threshold theorem for fault-tolerant quantum computation based on error detection and postselection. Our proof provides a rigorous {{foundation for the}} scheme suggested by Knill, in which preparation circuits for ancilla states are protected by a concatenated <b>error-detecting</b> <b>code</b> and the preparation is aborted if an error is detected. The proof applies to independent stochastic noise but (in contrast to proofs of the quantum accuracy threshold theorem based on concatenated error-correcting codes) not to strongly-correlated adversarial noise. Our rigorously established lower bound on the accuracy threshold, 1. 04 × 10 − 3, is well below Knill’s numerical estimates...|$|E
40|$|Orbital angular {{momentum}} of photons is an intriguing {{system for the}} storage and transmission of quantum information, but it is rapidly degraded by atmospheric turbulence. Understanding the noise processes that affect photons is essential if we desire to protect them. In this paper we use the infinitesimal propagation equation of Roux to derive a discrete Lindblad equation, and numerically study {{the form of the}} most relevant Lindblad operators. We find that the dominant Lindblad operators are those that shift the {{angular momentum}} by one unit. We explore possible schemes to protect quantum information across multiple photons by concatenating a standard quantum error-correcting code with an <b>error-detecting</b> <b>code</b> for orbital angular momentum. Comment: 14 pages, 10 figures. Minor revision...|$|E
40|$|The {{distillation}} {{of magic}} states is an often-cited technique for enabling universal quantum computing once the error probability {{for a special}} subset of gates has been made negligible by other means. We present a routine for magic-state distillation that reduces the required overhead {{for a range of}} parameters of practical interest. Each iteration of the routine uses a four-qubit <b>error-detecting</b> <b>code</b> to distill the + 1 eigenstate of the Hadamard gate at a cost of ten input states per two improved output states. Use of this routine in combination with the 15 -to- 1 distillation routine described by Bravyi and Kitaev allows for further improvements in overhead. Comment: 10 pages, 8 figures, 1 tabl...|$|E
5000|$|... 1968: Richard Hamming for {{his work}} on {{numerical}} methods, automatic <b>coding</b> systems, and <b>error-detecting</b> and error-correcting <b>codes.</b>|$|R
40|$|Automatic repeat request (ARQ) {{techniques}} with <b>error-detecting</b> <b>codes</b> {{are commonly}} used in communication systems. Of these, selective protocols, while the most efficient, have the notable drawback of requiring large buffers at the receiver side. A new selective ARQ protocol with a finite-length buffer is described in this paper. If N {{is the number of}} codewords transmittable in the round-trip delay, the described protocol requires a buffer having length equal to N + N-a, N-a {{greater than or equal to}} 2 being an integer. A lower bound on the throughput of the described ARQ protocol is derived. The proposed protocol achieves higher throughputs than similar schemes, giving comparable results to selective protocols with infinite-length buffers for high error rates in the communication channel...|$|R
40|$|In {{this paper}} we present an {{approach}} for combining on-line concurrent checking (CC) with off-line built-in self-test (BIST). We {{will show that}} a reduction of an aliasing probability can be obtained for manufacturing testing by monitoring the output of a concurrent checker and a reduction of a probability of not detecting an error in the computing mode {{can be obtained by}} a short periodic BIST. We will present a technique for optimal selection of <b>error-detecting</b> <b>codes</b> for combined on-line CC and off-line space-time compression of test responses for BIST and estimate probabilities of not detecting an error for the approach based on integrating CC and BIST. We also present a technique for on-line error-detection in space-time compressors of test responses for BIST...|$|R
