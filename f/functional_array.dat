48|224|Public
25|$|APEX, a {{research}} APL compiler, is available under the GNU Public License, per Snake Island Research Inc. APEX compiles flat APL (a subset of ISO N8485) into SAC, a <b>functional</b> <b>array</b> language with parallel semantics, and currently runs under Linux. APEX-generated code uses loop fusion and 'array contraction', special-case algorithms not generally available to interpreters (e.g., upgrade of permutation matrix/vector), {{to achieve a}} level of performance {{comparable to that of}} Fortran.|$|E
40|$|Abstract. With-loops are {{versatile}} array comprehensions {{used in the}} <b>functional</b> <b>array</b> language SaC {{to implement}} universally applicable array operations. We describe the fusion of with-loops as a novel optimization technique to improve the data locality of compiled code. Experiments based on selected benchmark programs show the significance of withloop fusion for achieving competitive runtime performance figures with high-level SaC programs. ...|$|E
40|$|We {{propose a}} two-layered {{approach}} for exploiting {{different forms of}} concurrency in complex systems: We specify computational components in our <b>functional</b> <b>array</b> language SaC, which exploits data parallel properties of array processing code. The declarative stream processing language S-Net is used to orchestrate the collaborative behaviour of these components in a streaming network. We illustrate our approach by a hybrid implementation of a sudoku puzzle solver as a representative for more complex search problems. ...|$|E
40|$|We show an {{approach}} {{based on a}} combination of site-directed mutagenesis, NIL and multivalent host-guest interactions for the realization of engineered ordered <b>functional</b> <b>arrays</b> of purified components of the photosynthetic system, the membrane-bound LH 2 complex. In addition to micrometer-scale patterned structures, we demonstrated the use of nanometer-scale hard NIL stamps to generate <b>functional</b> protein <b>arrays</b> approaching molecular dimensions...|$|R
40|$|A longstanding open {{question}} in algorithms and data structures {{is the time}} and space complexity of pure <b>functional</b> <b>arrays.</b> Imperative arrays provide update and lookup operations that require constant time in the RAM theoretical model, but it is conjectured that there does not exist a RAM algorithm that achieves the same complexity for <b>functional</b> <b>arrays,</b> unless restrictions are placed on the operations. The main result {{of this paper is}} an algorithm that does achieve optimal unit time and space complexity for update and lookup on <b>functional</b> <b>arrays.</b> This algorithm does not run on a RAM, but instead it exploits the massive parallelism inherent in digital circuits. The algorithm also provides unit time operations that support storage management, as well as sparse and extensible arrays. The main idea behind the algorithm is to replace a RAM memory by a tree circuit that is more powerful than the RAM yet has the same asymptotic complexity in time (gate delays) and size (number of components). The algorithm uses an array representation that allows elements to be shared between many arrays with only a small constant factor penalty in space and time. This system exemplifies circuit parallelism, which exploits very large numbers of transistors per chip in order to speed up key algorithms. Extensible Sparse <b>Functional</b> <b>Arrays</b> (ESFA) can be used with both functional and imperative programming languages. The system comprises a set of algorithms and a circuit specification, and it has been implemented on a GPGPU with good performance...|$|R
40|$|Introduction. The self-assembling microphase {{separation}} of diblock copolymers provides a simple, convenient route to well-defined <b>arrays</b> of <b>functional</b> nanostructures. This project overview describes recent techniques developed to transform diblock copolymer thin-films into robust nanoporous array templates, and with subsequent chemical modification, into <b>functional</b> <b>arrays</b> of nanowires, patterned surfaces, or integrated devices. Nanofabrication by dibloc...|$|R
40|$|Abstract. This paper compares a {{high-level}} {{implementation of the}} NAS benchmark FT in the <b>functional</b> <b>array</b> language SaC with traditional solutions based on Fortran- 77 and C. The impact of abstraction on expressiveness, readability, and maintainability of code {{as well as on}} clarity of underlying mathematical concepts is discussed. The associated impact on runtime performance is quantified both in a uniprocessor environment as well as in a multiprocessor environment based on automatic parallelization and on OpenMP. ...|$|E
40|$|This paper {{reports on}} the {{experiences}} made with the parallelization of a <b>functional</b> <b>array</b> language called SAC. The high-level approach together with a side-effect free semantics make it {{a good candidate for}} this purpose. In order to realize the project with limited man power, shared memory systems are selected as target architectures and the implementation based on PTHREADS. These choices allow reuse of large parts of the existing compiler infrastructure as it avoids explicit data decomposition...|$|E
40|$|Abstract The Haskell String type is {{notoriously}} inefficient. We {{introduce a new}} data type, ByteString, based on lazy lists of byte arrays, combining the speed benefits of strict arrays with lazy evaluation. Equational transformations based on term rewriting are used to deforest intermediate ByteStrings automatically. We describe novel fusion combinators with improved expressiveness and performance over previous <b>functional</b> <b>array</b> fusion strategies. A library for ByteStrings is implemented, providing a purely functional interface, which approaches the speed of low-level mutable arrays in C...|$|E
30|$|In the {{framework}} of multiplexing sensors and biosensors development, inkjet printing represents a low-cost, additive patterning technique suitable for the deposition of metal nanoparticles assembled in <b>functional</b> <b>arrayed</b> elements constituting efficient SERS substrates. By means of a servo-assisted piezoelectric printhead, fed with an engineered ink, microdroplets can be ejected on flexible/rigid substrates drawing complex structures with controlled geometry characterized by quite high spatial resolution [5].|$|R
5000|$|<b>Functional</b> protein <b>arrays</b> display {{folded and}} active {{proteins}} {{and are used}} for screening molecular interactions, studying protein pathways, identifying targets for post-translational modification, and analyzing enzymatic activities.|$|R
40|$|Abstract—It can {{be argued}} that some of the {{benefits}} of purely functional languages are counteracted by the lack of efficient and natural-to-use data structures for these languages. Imperative programming is based on manipulating data structures destructively, e. g., updating arrays in-place; however, doing so in a purely functional language violates the language’s very nature. In this paper, we present a type and effect system for an eager purely functional language that tracks array usage, i. e., read and write operations, and enables the efficient implementation of purely <b>functional</b> <b>arrays</b> with destructive update. I...|$|R
40|$|Original paper can {{be found}} at: [URL] Copyright International Society for Optical Engineering [Full text {{of this article is}} not {{available}} in the UHRA]In this paper the problem of high performance software engineering is addressed in the context of image processing regarding productivity and optimized exploitation of hardware resources. Therefore, we introduce the <b>functional</b> <b>array</b> processing language Single Assignment C (SaC), which relies on a hardware virtualization concept for automated, parallel machine code generation. An illustrative benchmarking example proves both utility and adequacy of SaC for image processing...|$|E
40|$|Abstract. Sac is a <b>functional</b> <b>array</b> {{processing}} language particularly {{designed with}} numerical applications in mind. In this field the runtime performance of programs critically {{depends on the}} efficient utilization of the memory hierarchy. Cache conflicts due to limited set associativity are one relevant source of inefficiency. This paper describes the realization of an optimization technique which aims at eliminating cache conflicts by adjusting the data layout of arrays to specific access patterns and cache configurations. Its effect on cache utilization and runtime performance is demonstrated by investigations on the PDE 1 benchmark. ...|$|E
40|$|Abstract. SaC is {{a purely}} <b>functional</b> <b>array</b> {{processing}} language for computationally intensive numerical applications. Its design aims at combining efficiency in program construction with efficiency in parallel program execution. We demonstrate the declarative, generic programming style of SaC {{by means of}} a small case study: 3 -dimensional complex fast-Fourier transforms. The impact of abstraction on expressiveness, readability, and maintainability of code as well as on clarity of underlying mathematical concepts is discussed and compared with other approaches. We quantify the associated impact on runtime performance both in uniprocessor and in multiprocessor environments. ...|$|E
40|$|Abstract. Deductive {{verification}} {{based on}} weakest-precondition calculus has proved effective at proving imperative programs, through a suitable encoding of memory as <b>functional</b> <b>arrays</b> (a. k. a. the Burstall-Bornat model). Unfortunately, this encoding of memory {{makes it impossible}} to support features like union and cast in C. We show that an interesting subset of those unions and casts can be encoded as structure subtyping, on which it is possible to extend the Burstall-Bornat encoding. We present an automatic translation from C to an intermediate language Jessie on which this extended interpretation is performed. ...|$|R
40|$|It can {{be argued}} that some of the {{benefits}} of purely functional languages are counteracted by the lack of efficient and natural-to-use data structures for these languages. Imperative programming is based on manipulating data structures destructively, e. g., updating arrays in-place; however, doing so in a purely functional language violates the language's very nature. In this paper, we present a type and effect system for an eager purely functional language that tracks array usage, i. e., read and write operations, and enables the efficient implementation of purely <b>functional</b> <b>arrays</b> with destructive update. © 2011 Polish Info Processing Soc...|$|R
40|$|Mutual {{exclusion}} {{is typically}} employed for multiprocess synchronization. However, Massalin and Pu [MP 91], and Greenwald and Cheriton [GC 96] have implemented complete operating systems using non-blocking synchronization instead of mutual exclusion. Although most operating systems are implemented using procedural languages, {{both of these}} systems have significant object-oriented characteristics. We show the interaction of non-blocking synchronization and object-oriented language design for operating systems, and present a proposal for an implementation of the Java programming language with non-blocking synchronization based on <b>functional</b> <b>arrays.</b> We present an experimental plan to run portions of a Java operating system under our system and show the benefits. ...|$|R
40|$|We {{address the}} {{challenge}} of parallelization development of industrial high-performance inspection systems comparing a conventional parallelization approach versus an auto-parallelized technique. Therefore, we introduce the <b>functional</b> <b>array</b> processing language Single Assignment C (SAC), which relies on a hardware virtualization concept for automated, parallel machine code generation for multi-core CPUs and GPUs. Additional software engineering aspects like programmability, productivity, understandability, maintainability, and resulting achieved gain in performance are discussed {{from the point of}} view of a developer. With several illustrative benchmarking examples from the field of image processing and machine learning, the relationship between runtime performance and efficiency of development is analyzed...|$|E
40|$|This conference poster {{reviews the}} Indium {{hybridization}} {{of the large}} format TES bolometer arrays. We are developing a key technology to enable {{the next generation of}} detectors. That is the Hybridization of Large Format Arrays using Indium bonded detector arrays containing 32 x 40 elements which conforms to the NIST multiplexer readout architecture of 1135 micron pitch. We have fabricated and hybridized mechanical models with the detector chips bonded after being fully back-etched. The mechanical support consists of 30 micron walls between elements Demonstrated electrical continuity for each element. The goal is to hybridize fully <b>functional</b> <b>array</b> of TES detectors to NIST readout...|$|E
40|$|Research {{supported}} by EU research grant FP 7 / 2007 / 215216 Apple-COREWe present a first evaluation of our novel approach for non-deferred reference {{counting on the}} Microgrid many-core architecture. Non-deferred reference counting is a fundamental building block of implicit heap management of <b>functional</b> <b>array</b> languages in general and Single Assignment C in particular. Existing lock-free approaches for multi-core and SMP settings do not scale well for large numbers of cores in emerging many-core platforms. We, instead, employ a dedicated core for reference counting and use asynchronous messaging to emit reference counting operations. This novel approach decouples computational workload from reference-counting overhead...|$|E
40|$|SISAL is {{a purely}} {{functional}} language which supports arrays. The difficulty with supporting purely <b>functional</b> <b>arrays</b> {{is that a}} prohibitive amount of copying can be necessary. SISAL uses a sophisticated compile-time analysis to alleviate some copying associated with array operations. This compile-time analysis is discussed and some problems with it are exposed. The alternative to curing copying, is to prevent it. To this end we propose a linear ADT, inspired by Wadler's monads work. Our linear ADT may be incorporated into Haskell and other functional languages. It allows efficient <b>functional</b> assignment on <b>arrays.</b> In addition it allows efficient divide and conquer style algorithms to be expressed using array partitioning and concatenation. The latter is particularly useful for expressing parallel array algorithms. 1 Introduction: the copying problem SISAL is an applicative language designed for scientific processing, and in particular it supports arrays. It is a pure language which does [...] ...|$|R
40|$|International audienceThis paper {{describes}} SMTCoq, a plug-in for {{the integration}} of external solvers into the Coq proof assistant. Based on a checker for generic first-order proof certificates fully implemented and proved correct in Coq, SMTCoq offers facilities to check answers from external SAT and SMT solvers and to increase Coq's automation using such solvers, all in a safe way. The current version supports proof certificates produced by the SAT solver ZChaff, for propositional logic, and the SMT solvers veriT and CVC 4, for the quantifier-free fragment of the combined theory of fixed-size bit vectors, <b>functional</b> <b>arrays</b> with extensionality, linear integer arithmetic, and uninterpreted function symbols...|$|R
40|$|This paper {{describes}} {{an approach to}} crystal engineering based on designing and analyzing hierarchical levels of crystal l ine architecture. The system under study consists of 1 : 1 co-crystals of melamines and barbituric acids that self-assemble into crystallographically infinite hydrogen-bonded tapes. The formation of structural elements can be rat ional ized and control led using famil iar molecular concepts such as steric repulsion. INTRODUCTION AND BACKGROUND Control l ing the packing of organic molecules in crystals presents a major design chal lenge for molecular engineering. l- 3 The ult imate goal of patterned, <b>functional</b> <b>arrays</b> of organic molecules is of potential ly great interest and rer,vard. Fundamental investigations of the physical-organic chemistry of the sol id stat...|$|R
40|$|We {{propose a}} method called {{user-defined}} constraints specifically for shape-generic multi-dimensional array programming. Our proposed technique allows programmers to make implicit constraints {{in the domain}} and codomain of functions explicit. This method can help compilers to generate more reliable code, improve performance through better optimization and improve software documentation. We propose and motivate a syntax extension for the <b>functional</b> <b>array</b> language SAC and describe steps to systematically transform source-level constraints into existing intermediate code representations. We discuss ways of statically resolving constraints through aggressive partial evaluation and propose some form of syntactic sugar that blurs the line between user-defined constraints and fullyfledged dependent types...|$|E
40|$|The Sparc T 3 - 4 server {{provides}} up to 512 concurrent hardware threads, {{a degree}} of concurrency that is unprecedented in a single server system. This paper reports on how the automatically parallelising compiler of the data-parallel <b>functional</b> <b>array</b> language SAC copes with up to 512 execution units. We investigate three different numerical kernels that are representative {{for a wide range}} of applications: matrix multiplication, convolution and 3 -dimensional FFT. We show both the high-level declarative coding style of SAC and the performance achieved on the T 3 - 4 server. Last not least, we draw conclusions for improving our compiler technology in the future...|$|E
40|$|We {{present a}} set of program transformations which are applied {{automatically}} to convert abstract functional specifications of numerical algorithms into efficient implementations tailored to the AMT DAP array processor. The transformations are based upon a formal algebra of a <b>functional</b> <b>array</b> form, which provides a functional model of the array operations supported by the DAP programming language. The transformations are shown to be complete. We present specifications and derivations of two example algorithms: an algorithm for computing eigensystems and an algorithm for solving systems of linear equations. For the former, we compare the execution performance of the implementation derived by transformation {{with the performance of}} an independent, manually constructed implementation; the efficiency of the derived implementation matches that of the manually constructed implementation...|$|E
50|$|To {{overcome}} the acceptance problems encountered by other <b>functional</b> or <b>array</b> based languages intended for numerical / array intensive applications, e.g. SISAL, NESL, Nial, APL, J, or K, particular regard {{is paid to}} ease {{the transition from a}} C / Fortran like programming environment to SAC.|$|R
40|$|We {{present an}} LTL model checker whose code has been {{completely}} verified using the Isabelle theorem prover. The checker consists of over 4000 lines of ML code. The code is produced using recent Isabelle technology called the Refinement Framework, which allows us to split its correctness proof into (1) the proof of an abstract version of the checker, consisting {{of a few hundred}} lines of “formalized pseudocode”, and (2) a structures are replaced by implementations of efficient structures like red-black trees and <b>functional</b> <b>arrays.</b> This leads to a checker that, while still slower than unverified checkers, can already be used as a trusted reference implementation against which advanced implementations can be tested. We report on the structure of the checker, the development process, and some experiments on standard benchmarks...|$|R
40|$|Abstract—Increased process {{variability}} {{presents a}} major challenge for future SRAM scaling. Fast and accurate validation of SRAM read stability and writeability margins is crucial for estimating yield in large SRAM arrays. Conventional SRAM read/write metrics are characterized through test structures {{that are able to}} provide limited hardware measurement data and cannot be used to investigate cell bit fails in <b>functional</b> SRAM <b>arrays.</b> This work presents a method for large-scale characterization of read stability and writeability in <b>functional</b> SRAM <b>arrays</b> using direct bit-line measurements. A test chip is implemented in a 45 nm CMOS process. Large-scale SRAM read/write metrics are measured and compared against conventional SRAM stability metrics. Results show excellent correlation to conventional SRAM read/write metrics as well as VMIN measurements near failure. Index Terms—CMOS, measurement, noise margins, SRAM, variability...|$|R
40|$|Abstract. Construction {{of complex}} array {{operations}} by composition of more basic ones allows for abstract and concise specifications of algorithms. Unfortunately, naïve compilation of such specifications leads to creation of many temporary arrays at runtime and, consequently, to poor performance characteristics. This paper elaborates {{on a new}} compiler optimization, named withloop-scalarization, which aims at eliminating temporary arrays {{in the context of}} nested array operations. It is based on with-loops, a versatile array comprehension construct used by the <b>functional</b> <b>array</b> language SaC both for specification as well as for internal representation of array operations. The impact of with-loop-scalarization on the runtime performance of compiled SaC code is demonstrated by several experiments involving support for arithmetic on arrays of complex numbers and the application kernel FT from the NAS benchmark suite. ...|$|E
40|$|In this {{position}} paper, we advocate <b>functional</b> <b>array</b> programming {{in conjunction with}} automatic verification to economically harness the power of modern multi-core processors. Array operations often apply scalar operations uniformly to large numbers of array elements. Thus, their execution can be shared between multiple processing units. Using mechanisms such as functional composition, concurrent programs can be conveniently assembled from these basic data-parallel program bricks. To verify array programs, we use a custom type system that takes array shapes into account. The type checker employs a theorem prover to verify constraints on linear expressions. The system rules out large classes of potential run-time errors. Therefore, a well-typed program can dispense with run-time checks. We may even perform extensive code reorganization that aims at eliminating both temporary arrays and synchronization barriers. ...|$|E
40|$|SaC is {{a purely}} <b>functional</b> <b>array</b> {{processing}} language designed with numerical applications in mind. It supports generic, high-level program specifications {{in the style}} of Apl. However, rather than providing a fixed set of built-in array operations, SaC provides means to specify such operations in the language itself in a way that still allows their application to arrays of any rank and size. This paper illustrates the major steps in compiling generic, rank- and shape-invariant SaC specifications into efficiently executable multithreaded code for parallel execution on shared memory multiprocessors. The effectiveness of the compilation techniques is demonstrated by means of a small case study on the PDE 1 benchmark, which implements 3 -dimensional red/black successive over-relaxation. Comparisons with Hpf and Zpl show that despite the genericity of code, SaC achieves highly competitive runtime performance characteristics. 1...|$|E
40|$|Abstract. Functional programs, by nature, {{operate on}} functional, or {{persistent}}, data structures. Therefore, persistent graphs are {{a prerequisite to}} express functional graph algorithms. In this paper we describe two implementations of persistent graphs and compare their running times on different graph problems. Both data structures essentially represent graphs as adjacency lists. The first uses the version tree implementation of <b>functional</b> <b>arrays</b> to make adjacency lists persistent. An array cache of the newest graph version together with a time stamping technique for speeding up deletions makes it asymptotically optimal for a class of graph algorithms that use graphs in a single-threaded way. The second approach uses balanced search trees to store adjacency lists. For both structures we also consider several variations, for example, ignoring edge labels or predecessor information. ...|$|R
50|$|Aminoshikimic acid is a {{synthetic}} crystalline carboxylic acid. It {{is characterized by}} multiple stereogenic centers and <b>functional</b> groups <b>arrayed</b> around a six-membered carbocyclic ring. Aminoshikimic acid is also an alternative to shikimic acid as a starting material for the synthesis of neuraminidase inhibitors such as the antiinfluenza agent oseltamivir (Tamiflu).|$|R
40|$|International audienceWe {{present an}} LTL model checker whose code has been {{completely}} verified using the Isabelle theorem prover. The checker consists of over 4000 lines of ML code. The code is produced using recent Isabelle technology called the Refinement Framework, which allows us to split its correctness proof into (1) the proof of an abstract version of the checker, consisting {{of a few hundred}} lines of “formalized pseudocode”, and (2) a verified refinement step in which mathematical sets and other abstract structures are replaced by implementations of efficient structures like red-black trees and <b>functional</b> <b>arrays.</b> This leads to a checker that, while still slower than unverified checkers, can already be used as a trusted reference implementation against which advanced implementations can be tested. We report on the structure of the checker, the development process, and some experiments on standard benchmarks...|$|R
