5|4|Public
40|$|This paper {{proposes to}} generalize {{the notion of}} {{constant}} expressions to include constant-expression functions and user-defined literals. In addition, some <b>floating-point</b> <b>constant</b> expressions are allowed. The goal is to improve support for generic programming, systems programming, and library building, and to increase C 99 compatibility. The proposal allows us to remove long-standing embarassments from some Standard Library components (notably) ...|$|E
40|$|Bjarne Stroustrup (www. stroustrup. com/Programming) Declarations • A {{declaration}} {{introduces a}} name into a scope. • A declaration also specifies a type for the named object. • Sometimes a declaration includes an initializer. • A name must be declared {{before it can}} be used in a C++ program. • Examples: – int a = 7; / / an int variable named ‘a ’ is declared – const double cd = 8. 7; / / a double-precision <b>floating-point</b> <b>constant</b> – double sqrt(double); / / a function taking a double argument and / / returning a double result – vector v; / / a vector variable of Tokens (variable...|$|E
40|$|This {{research}} {{introduces a}} one-bit signal processing structure called the phase amplitude control bit stream adder. The proposed method is a digital filter structure, which {{is capable of}} controlling amplitude and phase over a one-bit sine wave without the need of directly multiplying the one-bit stream with a <b>floating-point</b> <b>constant.</b> The method allows performing signal processing in the one-bit domain, thus maintaining high-resolution characteristics associated with one-bit signals. It has applications in precision variable oscillator control and in oscillator bank additive synthesis reconstruction models. The research also explores a method for one-bit oscillator bank synthesis, without using intermediate multi-bit stages directly applied to the signal...|$|E
50|$|<b>Floating-point</b> <b>constants</b> may {{be written}} in decimal notation, e.g. 1.23. Decimal {{scientific}} notation may be used by adding e or E followed by a decimal exponent, also known as E notation, e.g. 1.23e2 (which has the value 1.23 × 102 = 123.0). Either a decimal point or an exponent is required (otherwise, the number is parsed as an integer <b>constant).</b> Hexadecimal <b>floating-point</b> <b>constants</b> follow similar rules, except {{that they must be}} prefixed by 0x and use p or P to specify a binary exponent, e.g. 0xAp-2 (which has the value 2.5, since Ah × 2−2 = 10 × 2−2 = 10 ÷ 4). Both, decimal and hexadecimal <b>floating-point</b> <b>constants</b> may be suffixed by f or F to indicate a constant of type float, by l (letter l) or L to indicate type long double, or left unsuffixed for a double constant.|$|R
5000|$|Long double <b>constants</b> are <b>floating-point</b> <b>constants</b> suffixed with [...] "L" [...] or [...] "l" [...] (lower-case L), e.g., 0.333333333333333333L. Without a suffix, the {{evaluation}} depends on FLT_EVAL_METHOD.|$|R
40|$|Generic base standards, that is, ones {{defining}} these fundamental {{concepts of}} information technology, offer {{a way of}} improving standardization in IT by enabling greater commonality. This paper looks briefly at the fundamental base standards of terminology and character sets. It then considers in more depth two other generic base concepts: syntactic metalanguages (for example, Backus Naur Form) and numeric <b>floating-point</b> <b>constants.</b> Case studies illustrate typical unnecessary variations in existing standards and demonstrate that even the simplest ideas are treated in widely different ways. ...|$|R
40|$|International audienceComputing cores to be {{implemented}} on FPGAs may involve divisions by small integer constants in fixed or floating point. This article presents a family of architectures addressing this need. They are derived from a simple recurrence whose body can {{be implemented}} very efficiently as a look-up table that matches the hardware resources of the target FPGA. For instance, division of a 32 -bit integer by the constant 3 may be implemented by a combinatorial circuit of 48 LUT 6 on a Virtex- 5. Other options are studied, including iterative implementations, and architectures based on embedded memory blocks. This technique also computes the remainder. An efficient implementation of the correctly rounded division of a <b>floating-point</b> <b>constant</b> by such a small integer is also presented...|$|E
50|$|It {{can be used}} on classes, {{interfaces}} and non-abstract methods. When {{applied to}} a method, it causes all calculations inside the method to use strict floating-point math. When applied to a class, all calculations inside the class use strict <b>floating-point</b> math. Compile-time <b>constant</b> expressions must always use strict floating-point behavior.|$|R

