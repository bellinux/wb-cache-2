0|3222|Public
40|$|A <b>dynamic</b> <b>call</b> graph is the {{invocation}} relation {{that represents a}} specific set of runtime executions of a program. <b>Dynamic</b> <b>call</b> graph extraction is a typical application of dynamic analysis to aid compiler optimization, performance analysis, program understanding, etc. In this paper, we empirically compare the results of nine Java <b>dynamic</b> <b>call</b> graph extractors quantitatively and qualitatively. We investigate those differences among the <b>dynamic</b> <b>call</b> graph extracted by different tools mainly caused by different underlying Java program instrumentation techniques and other design decisions. A comparison between static <b>call</b> graph and <b>dynamic</b> <b>call</b> graph shows software engineering tools for program understanding place a different requirement on <b>dynamic</b> <b>call</b> graph from compilers or profilers whose main purpose is optimization or performance tuning. <b>Dynamic</b> <b>call</b> graphs require some complementary static information and an effective representation to aid program understanding. Choosing an appropriate instrumentation technique, integrating static and dynamic information, and providing flexible user manipulation for <b>dynamic</b> <b>call</b> graphs can better facilitate program understanding task. In this paper, we discuss the study and sketch the design considerations for an effective <b>dynamic</b> <b>call</b> graph tool to support program understanding. 1...|$|R
5000|$|<b>Dynamic</b> <b>call</b> {{tracking}} works {{similarly to}} Google Analytics but has additional software that allows websites to dynamically swap phone numbers presented to each user when the website loads. This {{is known as}} <b>dynamic</b> <b>call</b> tracking. In essence, providers {{for this type of}} service supply users with software that is placed on their website which controls what numbers are shown to users on the site. there are two main methods of <b>Dynamic</b> <b>Call</b> Tracking: ...|$|R
40|$|In {{the event}} of a major network outage such as a ber cable cut, a network can {{experience}} signi cant deterioration of network performance. To address such a situation, a network can be equipped with restoration capacity. We present here a mathematical model and design algorithm for determination of transmission network restoration capacity. We then present models for two restoration options { connection based restoration and load directed restoration (for restoration of bundle of circuits) { and consider their impact on a wide-area <b>dynamic</b> <b>call</b> routing teletrac network when the restoration capacity is limited (tight). Our network simulation of failure and restoration of a <b>dynamic</b> <b>call</b> routing teletrac network shows that the load directed approach generally performs better than the connection based approach. KEY WORDS:Wide-area networks, <b>dynamic</b> <b>call</b> routing teletrac networks, restoration capacity design, restoration rerouting, multi-commodity ow models, network restoration performance. 1...|$|R
5000|$|<b>Call</b> <b>distribution</b> {{based on}} various {{criteria}} {{associated with the}} call ...|$|R
50|$|Automatic <b>Call</b> <b>Distribution,</b> {{as well as}} Boss-Secretary-Function for {{automated}} forwarding of calls.|$|R
5000|$|Simultaneous <b>Call</b> <b>Distribution</b> - <b>Calls</b> are {{presented}} to all available extensions simultaneously ...|$|R
5000|$|Proportional <b>call</b> <b>distribution</b> (such {{as between}} {{two or more}} call centres or offices) ...|$|R
5000|$|Circular/Rotary <b>Call</b> <b>Distribution</b> - <b>Calls</b> are {{distributed}} in order, {{starting with the}} next in order ...|$|R
5000|$|Linear <b>Call</b> <b>Distribution</b> - <b>Calls</b> are {{distributed}} in order, {{starting at the}} beginning each time ...|$|R
5000|$|Uniform <b>Call</b> <b>Distribution</b> - <b>Calls</b> are {{distributed}} uniformly, {{starting with the}} person who has handled the fewest calls ...|$|R
40|$|We present {{first data}} on {{circadian}} long <b>call</b> <b>distribution</b> of wild orangutans in Northwest Borneo. Data were collected during {{two months in}} Batang Ai National Park. A total of 151 male long calls were heard, exhibiting a bimodal distribution pattern with peaks at 05 : 00 - 06 : 00 hours and 18 : 00 - 19 : 00 hours. An earlier study found pronounced differences between the calling rates of Bornean orangutans, which showed an almost unimodal <b>call</b> <b>distribution</b> with its peak at mid-morning, and those of Sumatran orangutans, which showed a bimodal <b>call</b> <b>distribution</b> with a distinct calling peak at predawn and a more moderate peak near dusk (MacKinnon 1974). Our findings from Batang Ai resemble more closely the pattern reported for Sumatra than those reported for other Bornean localities and, therefore, contradict earlier reports suggesting a Sumatra-Borneo dichotomy in orangutan <b>call</b> <b>distribution.</b> In addition, orangutans in Batang Ai were heard to regularly emit long calls throughout the night. This behaviour is unusual for a diurnal species...|$|R
50|$|VaxTele SIP SDK, allows to add many IP-PBX (Private Branch Exchange) related features: voice mail, call transfer, chat rooms, Interactive Voice Responses (IVR), multi user conference <b>call,</b> auto <b>call</b> <b>distribution,</b> <b>call</b> queues and stealth listening.|$|R
50|$|Call graphs can be dynamic or static. A <b>dynamic</b> <b>call</b> graph is {{a record}} of an {{execution}} of the program, for example as output by a profiler. Thus, a <b>dynamic</b> <b>call</b> graph can be exact, but only describes one run of the program. A static call graph is a call graph intended to represent every possible run of the program. The exact static call graph is an undecidable problem, so static call graph algorithms are generally overapproximations. That is, every call relationship that occurs is represented in the graph, and possibly also some call relationships that would never occur in actual runs of the program.|$|R
40|$|A {{new family}} of <b>distributions,</b> <b>called</b> the trans-normal <b>distribution</b> is introduced. Its basic {{properties}} are presented. A closely related family of <b>distributions</b> <b>called</b> tran-t <b>distribution</b> is also given {{along with its}} basic properties. Trans-normal regression is used as an illustration on the usefullness of the new distribution...|$|R
40|$|Many devirtualization {{techniques}} {{have been proposed}} to reduce the runtime overhead of <b>dynamic</b> method <b>calls</b> for various objectoriented languages, however, {{most of them are}} less effective or cannot be applied for Java in a straightforward manner. This is partly because Java is a statically-typed language and thus transforming a <b>dynamic</b> <b>call</b> to a static one does not make a tangible performance gain (owing to the low overhead of accessing the method table) unless it is inlined, and partly because the dynamic class loading feature of Java prohibits the whole program analysis and optimizations from being applied. We propose a new technique called direct devirtualization with the code patching mechanism. For a given <b>dynamic</b> <b>call</b> site, our compiler first determines whether the call can be devirtualized, by analyzing the current class hierarchy. When the call is devirtualizable and the target method is suitably sized, the compiler generates the inlined code of the method, together with the backup code of making the <b>dynamic</b> <b>call.</b> Only the inlined code is actually executed until our assumption about the devirtualization becomes invalidated, at which time the compiler performs code patching to make the backup code executed subsequently. Since the new technique prevents some code motions across the merge point between the inlined code and the backup code, we have furthermore implemented recently-known analysis techniques, such as type analysis and preexistence analysis, which allow the backup code to be completely eliminated. We made various experiments using 16 real programs to understand the effectiveness and characteristics of the devirtualization techniques in our Java Just-In-Time (JIT) compiler. In summary, we reduced the number of <b>dynamic</b> <b>calls</b> by ranging from 8. 9 % to 97. 3 % (the average of 40. 2 %), and we improved the execution performance by ranging from- 1 % to 133 % (with the geometric mean of 16 %) ...|$|R
5000|$|Weighted <b>Call</b> <b>Distribution</b> - <b>Calls</b> are {{distributed}} {{according to a}} configurable weighting, such as differing skill sets within customer service representatives ...|$|R
50|$|The {{software}} enables Voice over IP {{as part of}} a self-organising Peer-to-peer telephone network.It supports {{features like}} <b>call</b> forwarding, <b>call</b> <b>distribution,</b> <b>call</b> hold, presence information and (text) messages, supports encrypted calls and also enables NAT traversal to establish the peer-to-peer connections.|$|R
5000|$|Dynamic lookup is {{performed}} using three distinct mechanisms: COM IDispatch for COM objects, [...] DLR interface for objects implementing that interface, and reflection for all other objects. Any C# class can therefore intercept <b>dynamic</b> <b>calls</b> on its instances by implementing [...]|$|R
50|$|Pbxnsip {{software}} {{includes many}} features available in traditional PBX systems: voice mail, conference calling, {{interactive voice response}} (phone menus), and automatic <b>call</b> <b>distribution.</b>|$|R
50|$|In {{the theory}} of {{generalized}} functions, certain kinds of generalized functions <b>called</b> <b>distributions</b> can be realized as linear functionals on spaces of test functions.|$|R
5000|$|Distributed {{ray tracing}}, also <b>called</b> <b>distribution</b> ray tracing and {{stochastic}} ray tracing, is a refinement of ray tracing {{that allows for}} the rendering of [...] "soft" [...] phenomena.|$|R
40|$|Functions {{and their}} {{relations}} can affect numerous properties and metrics of a functional program. To identify {{and represent the}} functions and their calling connections, software analysers commonly apply semantic function analysis, which derives the static call graph of the program, based on its source code. Function calls however may be dynamic and complex, {{making it difficult to}} statically identify the callee. <b>Dynamic</b> <b>calls</b> are determined just at run-time, static analysis therefore cannot be expected to fully identify every call. Nevertheless, by utilising the results of a properly performed data-flow analysis as well as taking ambiguous references into account, numerous <b>dynamic</b> <b>calls</b> are discoverable and representable. We consider cases where the identifiers of the callee are statically determined, but they flow into the call expression from a different program point, and also, we manage to handle function calls whose identifiers are not fully identifiable at compile-time. By utilising the improved reference analysis, we extend the static call graph with various information about <b>dynamic</b> function <b>calls.</b> We investigate such a function call analysis in the programming language Erlang...|$|R
40|$|Abstract—Distributed {{nature of}} web service {{computing}} im-poses new challenges on software maintenance community for localizing different software features and maintaining proper {{quality of service}} as the services change over time. In this paper, we propose a new approach for identifying the implementation of web service features in a service oriented architecture (SOA) by mining <b>dynamic</b> <b>call</b> trees that are collected from distributed execution traces. The proposed approach addresses the com-plexities of SOA-based systems that arise from: features whose locations may change due to changing of input parameters; execution traces that are scattered throughout different service provider platforms; and trace files that contain interleaving of execution traces related to different concurrent service users. In this approach, we execute different groups of feature-specific scenarios and mine the resulting <b>dynamic</b> <b>call</b> trees to spot paths in the code of a service feature, which correspond to a specific user input and system state. This allows us {{to focus on a}} the implementation of a specific feature in a distributed SOA-based system for different maintenance tasks such as bug localization, structure evaluation, and performance analysis. We define a set of metrics to assess structural properties of a SOA-based system. The effectiveness and applicability of our approach is demonstrated through a case study consisting of two service-oriented banking systems. Keywords-SOA; Feature location; Dynamic analysis; Execu-tion tracing; Pattern mining; <b>Dynamic</b> <b>call</b> trees...|$|R
40|$|<b>Dynamic</b> method <b>call</b> {{is one of}} {{the major}} {{advantages}} gained by object-oriented languages. However, it entails severe performance penalties. Static program analysis is used to identify cases where dynamic dispatch can be replaced by static binding. This is done by computing the dynamic type of method invocation expressions. Whenever such an expression may only call one method, the <b>dynamic</b> <b>call</b> can be replaced by a static call. Unlike most approaches, we present a data ow analysis allowing the ow- and context-sensitive approximation of types of expressions. We start with a conservative approximation of the control ow graph constructed by means of standard techniques...|$|R
50|$|Bunch fanout {{pigtails}} {{are made}} of multi-core round bunch fiber optic cable, which is also <b>called</b> <b>distribution</b> fiber optic cable. It is generally installed in closet area like rack mount or wall mount splice boxes or patch panels.|$|R
50|$|Historically, call centres {{have been}} built on Private branch {{exchange}} (PBX) equipment that is owned, hosted, and maintained by the call centre operator themselves. The PBX can provide functions such as automatic <b>call</b> <b>distribution,</b> interactive voice response, and skills-based routing.|$|R
40|$|Abstract. In this paper, we {{describe}} a model-driven approach that aids the developer in parallelizing a software program. Information from a <b>dynamic</b> <b>call</b> tree, data dependencies and domain knowledge from the developer are combined {{in a model}} transformation process. This process leads to {{a model of the}} application where it becomes obvious which parts of the application can be executed in parallel. ...|$|R
30|$|A {{function}} F(t): (-∞,+∞)→[0, 1] is <b>called</b> a <b>distribution</b> function {{if it is}} nondecreasing, left-continuous and _t→-∞F(t)= 0. In addition, if F(0)= 0, then F is <b>called</b> {{a distance}} <b>distribution</b> function.|$|R
30|$|A {{function}} F:(-∞,+∞)→[0, 1] is <b>called</b> a <b>distribution</b> function {{if it is}} non-decreasing and left-continuous with _t→-∞F(t)= 0. If {{in addition}} F(0)= 0, then F is <b>called</b> a distance <b>distribution</b> function.|$|R
3000|$|..., (1.7) is the {{prototype}} of nonlinear <b>dynamic</b> equations <b>called</b> Emden-Fowler neutral delay sublinear dynamic equation: [...]...|$|R
50|$|High strain <b>dynamic</b> {{testing is}} <b>called</b> <b>dynamic</b> pile {{monitoring}} {{when it is}} applied during pile driving and dynamic load testing when it is applied following pile installation, regardless of the installation method.|$|R
30|$|A {{function}} F(t): (-∞,+∞)→[0, 1] is <b>called</b> a <b>distribution</b> function {{if it is}} non-decreasing and left-continuous with _t→-∞F(t)= 0. If {{in addition}} F(0)= 0, then F is <b>called</b> a distance <b>distribution</b> function.|$|R
50|$|Fantom's type {{system is}} simple by design. All {{variables}} are statically typed, {{as they are}} in C# and Java. Fantom rejects generic types due to their complexity, but it does have a set of built-in generic types: List, Map, and Func. Fantom can also take on the feel of a dynamically typed language through <b>dynamic</b> <b>calls</b> and automatic downcasting. Fantom has an easy to use reflection API and metaprogramming capabilities.|$|R
5000|$|In case {{of dynamic}} method and indexer calls, {{overload}} resolution happens at run-time {{according to the}} actual types of the values passed as arguments, but otherwise according to the usual C# overloading resolution rules. Furthermore, {{in cases where the}} receiver in a <b>dynamic</b> <b>call</b> is not itself dynamic, run-time overload resolution will only consider the methods that are exposed on the declared compile-time type of the receiver. For example: ...|$|R
50|$|The {{money in}} such {{accounts}} {{is to be}} used to pay for medical expenses. Withdrawals from the account often <b>called</b> <b>distributions,</b> if made for that reason, {{may or may not be}} subject to income tax. Withdrawals without adequate documentation of use for medical expenses are subject to penalties.|$|R
50|$|Through the 1980s {{attention}} {{turned from}} pure hardware to software development. The BNR Toronto lab introduced Meridian Mail in the 1980s, which {{went on to}} be a very successful product and forced the introduction of similar products from other telephony vendors. They later added automatic <b>call</b> <b>distribution</b> and other similar services.|$|R
