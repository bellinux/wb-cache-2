31|10000|Public
25|$|Both the PPE and SPE are RISC {{architectures}} with a fixed-width 32-bit instruction format. The PPE {{contains a}} 64-bit <b>general</b> <b>purpose</b> <b>register</b> set (GPR), a 64-bit floating point register set (FPR), and a 128-bit Altivec register set. The SPE contains 128-bit registers only. These {{can be used}} for scalar data types ranging from 8-bits to 64-bits in size or for SIMD computations on a variety of integer and floating point formats. System memory addresses for both the PPE and SPE are expressed as 64-bit values for a theoretic address range of 264 bytes (16 exabytes or 16,777,216 terabytes). In practice, not all of these bits are implemented in hardware. Local store addresses internal to the SPU (Synergistic Processor Unit) processor are expressed as a 32-bit word. In documentation relating to Cell a word is always taken to mean 32 bits, a doubleword means 64 bits, and a quadword means 128 bits.|$|E
5000|$|Up to 12 words {{relative}} to any <b>general</b> <b>purpose</b> <b>register</b> (read and write, word access only) ...|$|E
5000|$|Instructions {{that access}} memory all use a base register: SP, DP, CP, PC or any <b>general</b> <b>purpose</b> <b>register.</b> In a single 16-bit {{instruction}} a thread can access: ...|$|E
5000|$|<b>General</b> <b>purpose</b> <b>registers</b> were {{normally}} {{located in}} a non-addressable portion of 1 μs core storage termed [...] "bump storage". For added speed, the <b>general</b> <b>purpose</b> <b>registers</b> could be implemented in Solid Logic Technology (SLT) circuitry with an access time of [...]25 μs.|$|R
5000|$|An indexed 16-bit {{quantity}} {{using any}} two <b>general</b> <b>purpose</b> <b>registers</b> ...|$|R
5000|$|... thirty-two 32-bit or 64-bit <b>general</b> <b>purpose</b> <b>registers</b> (GPRs) for integer operations.|$|R
5000|$|For example, the MOS Technology 6502 {{has only}} one <b>general</b> <b>purpose</b> <b>register</b> (the accumulator). As a result, it used the zero page extensively. Many {{instructions}} are coded differently for zero page and non-zero page addresses: ...|$|E
5000|$|The Arithmetical and Logical Unit {{gate array}} (ALU, {{also known as}} the [...] "BUFALU"). Replaced four Am2901 {{bit-slice}} processors, and some additional registers like the data bus register the <b>general</b> <b>purpose</b> <b>register,</b> and the internal register block.|$|E
50|$|By contrast, for a {{standard}} procedure call, only an address (a few bits) {{needs to be}} passed for each argument and may even be passed in a <b>general</b> <b>purpose</b> <b>register</b> requiring zero additional storage and zero transfer time.|$|E
50|$|It {{provides}} 16 <b>general</b> <b>purpose</b> <b>registers,</b> a vector-base-register, global-base-register, and {{a procedure}} register.|$|R
5000|$|Saving and {{restoring}} program state for called functions (including <b>general</b> <b>purpose</b> <b>registers</b> and return address) ...|$|R
50|$|Description: {{writes the}} {{character}} currently in R0 from the GPR (<b>General</b> <b>Purpose</b> <b>Registers)</b> onto the console display.|$|R
50|$|Later {{computers}} generally {{had more}} than one <b>general</b> <b>purpose</b> <b>register</b> or RAM location which could be the source or destination or both for arithmetic—and so later computers need some other addressing mode to specify the source and destination of arithmetic.|$|E
50|$|Some CPU architectures, {{such as the}} MIPS and Alpha, do not use a {{dedicated}} flag register. Others do not implicitly set and/or read flags. Such machines either do not pass implicit status information between instructions at all, or they pass it in an explicitly selected <b>general</b> <b>purpose</b> <b>register.</b>|$|E
5000|$|On earlier {{computer}}s, a knob on {{the computer}} console may have enabled step-by-step execution mode to be selected and execution would then proceed by pressing a [...] "single step" [...] or [...] "single cycle" [...] button. Program status word / Memory or <b>general</b> <b>purpose</b> <b>register</b> read-out could then be accomplished by observing and noting the console lights.|$|E
5000|$|Fastpathed CALL and RET-Imm {{instructions}} (formerly microcoded) {{as well as}} MOVs from SIMD <b>registers</b> to <b>general</b> <b>purpose</b> <b>registers</b> ...|$|R
5000|$|Delayed exceptions, using a {{not a thing}} bit {{within the}} <b>general</b> <b>purpose</b> <b>registers,</b> allow {{speculative}} execution past possible exceptions.|$|R
5000|$|... 130nm {{implementation}} of EnCore processor in baseline configuration extended with barrel shifter, multiplier, {{and a full}} set of 32 <b>general</b> <b>purpose</b> <b>registers.</b>|$|R
50|$|Modern {{computer}} designs {{generally do}} not include dedicated index registers; instead they allow any <b>general</b> <b>purpose</b> <b>register</b> to contain an address, and allow a constant value and, on some machines, the contents of another register {{to be added to}} it as an offset to form the effective address. Early computers designed this way include the PDP-6 and the IBM System/360.|$|E
5000|$|Over the years, programmers {{have created}} many {{variations}} on that [...] "interpreter" [...] or [...] "small selector". The particular {{address in the}} list of addresses may be extracted using an index, <b>general</b> <b>purpose</b> <b>register</b> or pointer. The addresses may be direct or indirect, contiguous or non-contiguous (linked by pointers), relative or absolute, resolved at compile time or dynamically built. No one variation is [...] "best".|$|E
50|$|The {{effective}} {{virtual address}} {{of a word}} is 17 bits wide. Virtual addresses 0 thru 15 are reserved to reference the corresponding <b>general</b> <b>purpose</b> <b>register,</b> and are not mapped. Otherwise, in virtual memory mode the high-order eight bits of an address, called virtual page number, are used as an index to an array of 256 13-bit memory map registers. The thirteen bits from the map register plus the remaining nine bits of the virtual address form the address used to access real memory.|$|E
2500|$|All <b>general</b> <b>purpose</b> <b>registers</b> {{can be used}} {{equally as}} source/destination in all instructions, {{simplifying}} compiler design (floating point registers are often kept separate) ...|$|R
5000|$|The <b>general</b> <b>purpose</b> <b>{{register}}s,</b> {{the status}} register and some I/O registers are bit-addressable, with bit 0 being the least significant and bit 7 the most significant.|$|R
50|$|MAX {{instructions}} {{operate on}} 32- or 64-bit SIMD data types consisting of multiple 16-bit integers packed in <b>general</b> <b>purpose</b> <b>registers.</b> The available functionality includes additions, subtractions and shifts.|$|R
50|$|In the x86 {{processor}} line, {{a typical}} pre-486 CPU {{did not have}} an individual register file, as all <b>general</b> <b>purpose</b> <b>register</b> were directly work with its decoder, and the x87 push stack was located within the floating-point unit itself. Starting with Pentium, a typical Pentium-compatible x86 processor is integrated with one copy of the single-port architectural register file containing 8 architectural registers, 8 control registers, 8 debug registers, 8 condition code registers, 8 unnamed based register, one instruction pointer, one flag register and 6 segment registers in one file.|$|E
5000|$|IEFBR14 {{consisted}} initially of {{a single}} instruction a [...] "Branch to Register" [...] 14. The mnemonic used in the IBM Assembler was BR and hence the name: IEF BR 14. BR 14 is identically equivalent to BCR 15,14 (Branch Always mask = 15 = always [...] to the address contained in <b>general</b> <b>purpose</b> <b>register</b> 14). BR is a pseudo instruction for BCR 15. The system assembler accepts many cases of such pseudo-instructions, as logical equivalents to the canonical System/360 instructions. The canonical instance of BR 14 is BCR 15,14.|$|E
5000|$|Most current {{computer}} instruction sets {{are based on}} a <b>general</b> <b>purpose</b> <b>register</b> model. The processor and memory architecture of the classic HP 3000 were based on a stack machine model, like HP's well-known line of RPN calculators. It was said to be inspired by the famous stack-based Burroughs large systems. Rather than having a small number of registers, for example only an AX and BX register {{in the case of the}} HP 1000, operands would be pushed on the same stack used to store local variables and return addresses. So rather than ...|$|E
50|$|The LARC was a decimal {{mainframe}} computer with 48 bits per word. It used bi-quinary coded decimal arithmetic with four bits per digit, allowing 11-digit signed numbers. Instructions were 48 bits long, one per word. Every digit {{in the machine}} had one parity bit for error checking, meaning every word occupied 60 bits (48 bits for data with 12 bits for parity check). The basic configuration had 26 <b>general</b> <b>purpose</b> <b>registers</b> and could be expanded to 99 <b>general</b> <b>purpose</b> <b>registers.</b> The general-purpose registers had an access time of one microsecond.|$|R
5000|$|... 32 <b>general</b> <b>purpose</b> <b>registers</b> (R0 is {{typically}} set to zero by convention, however R0 {{is a standard}} register and other values may be assigned to it if so desired.) ...|$|R
5000|$|The <b>general</b> <b>purpose</b> <b>registers</b> are {{addressed}} by their numbers (0-31), although the full 5-bit number is not stored in instructions {{that can only}} operate on a subset of those registers.|$|R
50|$|An {{important}} unique software optimization enabled by {{the transport}} programming is called software bypassing. In case of software bypassing, the programmer bypasses the register file write back by moving data {{directly to the}} next functional unit's operand ports. When this optimization is applied aggressively, the original move that transports the result to the register file can be eliminated completely, thus reducing both the register file port pressure and freeing a <b>general</b> <b>purpose</b> <b>register</b> for other temporary variables. The reduced register pressure, in addition simplifying the required complexity of the RF hardware, can lead to significant CPU energy savings, an important benefit especially in mobile embedded systems.|$|E
50|$|The 82750PB pixel {{processor}} is {{packaged in}} a 132-pin PQFP running at 25 MHz. It contains 57 instruction set, eight entries 64 bit vector registers(same MM0~MM7 register naming that mapped on x87 stack, only different is i750 has dedicate register while the x86 mmx cpu did not included. However it is lacked of integer <b>general</b> <b>purpose</b> <b>register</b> makes it different than its x86 counterpart.), an 64-bit ALU, a 512×48-bit instruction RAM, a 512×16-bit data RAM, two internal 16-bit buses, a wide instruction word processor, a variable length sequence decoder, a pixel interpolator and an interface supporting a 4 GB linear address space. These features make it capable of text, 2D and 3D graphics, video compression, and real-time video decompression and video effects. It can support up to 30 frames per second.|$|E
50|$|Both the PPE and SPE are RISC {{architectures}} with a fixed-width 32-bit instruction format. The PPE {{contains a}} 64-bit <b>general</b> <b>purpose</b> <b>register</b> set (GPR), a 64-bit floating point register set (FPR), and a 128-bit Altivec register set. The SPE contains 128-bit registers only. These {{can be used}} for scalar data types ranging from 8-bits to 64-bits in size or for SIMD computations on a variety of integer and floating point formats. System memory addresses for both the PPE and SPE are expressed as 64-bit values for a theoretic address range of 264 bytes (16 exabytes or 16,777,216 terabytes). In practice, not all of these bits are implemented in hardware. Local store addresses internal to the SPU (Synergistic Processor Unit) processor are expressed as a 32-bit word. In documentation relating to Cell a word is always taken to mean 32 bits, a doubleword means 64 bits, and a quadword means 128 bits.|$|E
50|$|A {{subroutine}} typically requires standard housekeeping code - both at entry to, {{and exit}} from, the function (function prologue and epilogue - usually saving <b>general</b> <b>purpose</b> <b>registers</b> and return address as a minimum).|$|R
50|$|Most {{instructions}} are 16-bit {{while a few}} have 32-bit encoding. Instructions can use between zero and six operands. Most common arithmetic operations (such as ADD, SUB, MULT) are three-operand instructions based {{on a set of}} 12 <b>general</b> <b>purpose</b> <b>registers.</b>|$|R
50|$|People who are {{familiar}} with the PDP-11 or VAX usually feel comfortable with the 68000. With the exception of the split of <b>general</b> <b>purpose</b> <b>registers</b> into specialized data and address registers, the 68000 architecture is in many ways a 32-bit PDP-11.|$|R
