0|524|Public
5000|$|In PHP, {{the triple}} equals sign (...) denotes identity, meaning {{that not only}} do the two {{expressions}} evaluate to equal values, they are also of the same data type. For instance, the expression [...] is true, but [...] is not, because the number 0 is an integer value whereas <b>false</b> is a <b>Boolean</b> <b>value.</b>|$|R
50|$|In {{computer}} science, a Boolean {{expression is}} an expression in a programming language that produces a <b>Boolean</b> <b>value</b> when evaluated, i.e. one of true or <b>false.</b> A <b>Boolean</b> expression may be composed {{of a combination of}} the Boolean constants true or false, Boolean-typed variables, Boolean-valued operators, and Boolean-valued functions.|$|R
40|$|Making use of <b>Boolean</b> <b>valued</b> {{representation}} it is {{proved that}} Kaplansky–Hilbert lattices and injective Banach lattices may be produced {{from each other}} {{by means of the}} convexification procedure. The relationship between the Kantorovich’s heuristic principle and the <b>Boolean</b> <b>value</b> transfer principle is also discussed...|$|R
2500|$|Boolean {{function}}, {{a function}} that determines <b>Boolean</b> <b>values</b> or operators ...|$|R
5000|$|Majority function, the {{majority}} {{of a collection of}} <b>Boolean</b> <b>values</b> ...|$|R
40|$|AbstractFor each {{consistent}} universal {{first order}} theory T a <b>Boolean</b> <b>valued</b> model of T is constructed that satisfies an existential sentence if {{and only if}} it is provable from T. The resolution calculus is extended so that proofs from T yield representations of objects incompletely specified by T in a <b>Boolean</b> <b>valued</b> model...|$|R
50|$|The <b>Boolean</b> <b>valued</b> models {{constructed}} by forcing are built using a cumulative hierarchy.|$|R
5000|$|Axiom 1 {{expresses the}} idea that [...] and [...] are the only <b>boolean</b> <b>values.</b>|$|R
40|$|For any {{first order}} theory T we {{construct}} a <b>Boolean</b> <b>valued</b> model M, in which precisely the T [...] provable formulas hold, {{and in which}} every (<b>Boolean</b> <b>valued)</b> subset which is invariant under all automorphisms of M is definable by a first order formula. Our presentation is entirely selfcontained, and only requires familiarity with the most elementary properties of model theory...|$|R
2500|$|Boolean {{expression}}, {{an expression}} in {{a programming language}} that produces a <b>Boolean</b> <b>value</b> when evaluated ...|$|R
5000|$|Simplified Independence Proofs: <b>Boolean</b> <b>Valued</b> Models of Set Theory, by J. Barkley Rosser, Academic Press, 1969 ...|$|R
40|$|The term “Boolean valued {{analysis}} ” appeared {{within the}} realm of mathematical logic. It was Takeuti, a renowned expert in proof theory, who introduced the term. Takeuti defined <b>Boolean</b> <b>valued</b> analysis in [18, p. 1] as “an application of Scott–Solovay’s <b>Boolean</b> <b>valued</b> models of set theory to analysis. ” Vopěnka invented similar models at the same time. That is how the question of the title receive...|$|R
40|$|Recently <b>Boolean</b> <b>valued</b> {{analysis}} (i. e., analysis {{based on}} <b>Boolean</b> <b>valued</b> set theory) {{has been extensively}} studied by G. Takeuti [14 – 16]. The main {{purpose of this paper}} is to show, by using this technique, that any continuous geometry can be viewed as an irreducible continuous geometry in its center valued set theory. This makes the transition from irreducible continuous geometries to reducible ones automatic...|$|R
50|$|Here again B is a <b>boolean</b> <b>value</b> (0 or 1), and S is a {{sequence}} of statements.|$|R
50|$|Kutateladze S.S. What is <b>Boolean</b> <b>valued</b> analysis? Siberian Advances in Mathematics, 2007, Vol. 17, No. 2, 91-111.|$|R
5000|$|Conversion of <b>Boolean</b> <b>value</b> True to Integer {{may yield}} -1 or 1 {{depending}} on the conversion used ...|$|R
25|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is T in most Lisps, in Scheme it is #t.|$|R
2500|$|By convention, the {{following}} two definitions (known as Church booleans) are used for the <b>boolean</b> <b>values</b> TRUE and FALSE: ...|$|R
50|$|Bit (<b>boolean</b> <b>value),</b> {{bit field}} (group {{of up to}} 32 bits) and bit string (up to 4Gb in length).|$|R
5000|$|A boolean flag, truth bit or truth flag in {{computer}} science is a <b>Boolean</b> <b>value</b> represented as one bit ...|$|R
5000|$|By convention, the {{following}} two definitions (known as Church booleans) are used for the <b>boolean</b> <b>values</b> TRUE and FALSE: ...|$|R
5000|$|Where the {{constant}} representing the <b>boolean</b> <b>value</b> of true is [...] in most Lisps, in Scheme it is [...]|$|R
5000|$|The {{following}} two definitions for the <b>boolean</b> <b>values</b> [...] and [...] are used, extending {{the definition of}} Church booleans: ...|$|R
50|$|Kutateladze S.S. Leibnizian, Robinsonian, and <b>Boolean</b> <b>valued</b> monads, Journal of Applied and Industrial Mathematics, 2011, Vol. 5, No. 3, 365-373.|$|R
50|$|Interpretations used {{to study}} non-classical logic include topological models, <b>Boolean</b> <b>valued</b> models, and Kripke models. Modal logic is also studied using Kripke models.|$|R
2500|$|In {{the case}} of Boolean-valued forcing, the {{procedure}} is similar – one has {{to prove that the}} <b>Boolean</b> <b>value</b> of [...] is not [...]|$|R
5000|$|Acknowledging {{the weak}} low order bit, the authors {{go on to}} say:We suggest to use a sign test to extract a random <b>Boolean</b> <b>value</b> ...|$|R
5000|$|In {{the case}} of Boolean-valued forcing, the {{procedure}} is similar - one has {{to prove that the}} <b>Boolean</b> <b>value</b> of [...] is not [...]|$|R
40|$|In {{this paper}} we {{will present a}} definability theorem for first order logic This theorem {{is very easy to}} state and its proof only uses {{elementary}} tools To explain the theorem let us first observe that if M is a model of a theory T in a language L then clearly any definable subset S M ie a subset S fa j M j ag defined by some formula is invariant under all automorphisms of M The same is of course true for subsets of Mn defined by formulas with n free variables Our theorem states that if one allows <b>Boolean</b> <b>valued</b> models the converse holds More precisely for any theory T we will construct a <b>Boolean</b> <b>valued</b> model M in which precisely the Tprovable formulas hold and in which every <b>Boolean</b> <b>valued</b> subset which is invariant under all automorphisms of M is denable by a formula of L Our presentation is entirely selfcontained and only requires familiarity with the most elementary properties of model theory In particular we have added a first section in which we review the basic definitions concerning <b>Boolean</b> <b>valued</b> models. The <b>Boolean</b> algebra used {{in the construction of the}} model will be presented concretely as the algebra of closed and open subsets of a topological space X naturally associated with the theory T The construction of this space is closely related to the one in In fact one of the results in that paper could be interpreted as a definability theorem for innitary logic using topological rather than <b>Boolean</b> <b>valued</b> model...|$|R
50|$|DER is {{a subset}} of BER {{providing}} for exactly one way to encode an ASN.1 value. DER is intended for situations when a unique encoding is needed, such as in cryptography, and ensures that a data structure {{that needs to be}} digitally signed produces a unique serialized representation. DER can be considered a canonical form of BER. For example, in BER a <b>Boolean</b> <b>value</b> of true can be encoded as any of 255 non-zero byte values, while in DER there is one way to encode a <b>boolean</b> <b>value</b> of true.|$|R
5000|$|Standard C (since C99) {{provides}} a boolean type, called [...] By {{including the header}} [...] one can use the more intuitive name [...] and the constants [...] and [...] The language guarantees that any two true values will compare equal (which was impossible to achieve before {{the introduction of the}} type). <b>Boolean</b> <b>values</b> still behave as integers, can be stored in integer variables, and used anywhere integers would be valid, including in indexing, arithmetic, parsing, and formatting. This approach (<b>Boolean</b> <b>values</b> are just integers) has been retained in all later versions of C.|$|R
5000|$|Here, when [...] is a <b>Boolean</b> <b>value</b> {{then the}} section tag {{acts like a}}n if conditional, but when [...] is an array then it acts like a foreach loop.|$|R
25|$|Church Booleans are the Church {{encoding}} of the <b>Boolean</b> <b>values</b> true and <b>false.</b> Some programming languages {{use these}} as an implementation model for Boolean arithmetic; examples are Smalltalk and Pico.|$|R
50|$|A basis oracle {{takes as}} its input {{a set of}} matroid elements, and returns as output a <b>Boolean</b> <b>value,</b> true if the given set is a basis and false otherwise.|$|R
30|$|The {{agents in}} the model {{have a variety of}} {{attributes}} that can take on any double precision value as well as individualized lists, <b>Boolean</b> <b>values,</b> etc. As such, they are asymptotically incompressible.|$|R
5000|$|... evaluates to {{the list}} 2, 4,…10 by {{applying}} the predicate [...] to every element {{of the list of}} integers 1, 2,… 10 in that order and creating a new list of those elements for which the predicate returns the <b>boolean</b> <b>value</b> true, thereby giving a list containing only the even members of that list. Conversely, the code example filter (not [...] even) 1..10evaluates {{to the list}} 1, 3,…9 by collecting those elements of the list of integers 1, 2… 10 for which the predicate [...] returns the <b>boolean</b> <b>value</b> <b>false</b> (with [...] being the function composition operator).|$|R
