2|54|Public
5000|$|This {{addressing}} mode, {{which always}} fetches data from memory or stores data to memory and then sequentially falls through {{to execute the}} next instruction (the effective address points to data), {{should not be confused}} with [...] "PC-relative branch" [...] which does not fetch data from or store data to memory, but instead branches to some other instruction at the given offset (the effective address points to an <b>executable</b> <b>instruction).</b>|$|E
50|$|Most modern desktop and server CPUs have {{at least}} three {{independent}} caches: an instruction cache to speed up <b>executable</b> <b>instruction</b> fetch, a data cache to speed up data fetch and store, and a translation lookaside buffer (TLB) used to speed up virtual-to-physical address translation for both executable instructions and data. A single TLB could be provided for access to both instructions and data, or a separate Instruction TLB (ITLB) and data TLB (DTLB) can be provided. The data cache is usually organized as a hierarchy of more cache levels (L1, L2, etc.; see also multi-level caches below). However, the TLB cache {{is part of the}} memory management unit (MMU) and not directly related to the CPU caches.|$|E
5000|$|<b>Executable</b> <b>instructions</b> are {{contained}} within a system [...] "instruction object". Since instructions are bit-aligned a 16-bit bit displacement into the instruction object allows the object to contain up to 8192 bytes of instructions (65536 bits).|$|R
50|$|Genetix is {{a virtual}} machine created by Bernard Hodson {{containing}} only 34 <b>executable</b> <b>instructions.</b> It {{was inspired by the}} principles of Alan Turing and allows for an entire operating system, including a word processor and utilities, to run on 32 kilobytes.|$|R
40|$|For instruction-level pamllel machines, it is es-sential to extmct pamllelly <b>executable</b> <b>instructions</b> from a progmm by code {{scheduling}}. I n this pa-per, {{we propose}} a new code scheduling technique using on extension of PDG. This technique p a d-lelizes non-numerical progmms, producing better machine codes than these created by percolation scheduling. ...|$|R
5000|$|TCCBOOT, a hack where TCC {{loads and}} boots a Linux kernel from source in about 10 seconds. That is to say, it is a [...] "boot loader" [...] which reads Linux kernel source code from disk, writes <b>executable</b> <b>instructions</b> to memory, and begins running it. This did require {{changes to the}} Linux build process.|$|R
40|$|Program {{verification}} procedures are described {{and used to}} determine the correctness of a program written for an airborne computer. The basic method relies on the inductive assertion method of Floyd (1967), modified and extended for application to a machine-language situation. Correctness considerations in the flight director program include self-modification, system correctness, <b>executable</b> <b>instructions,</b> overflow, approximate calculations with fractional quantities, and fixed point scaling. An example proof of correctness, which proceeds by proving the correctness of a certain subroutine, is provided...|$|R
40|$|A {{benchmark}} is {{a standard}} by which something can be measured or judged. A database benchmark {{is defined as a}} standard set of <b>executable</b> <b>instructions</b> which are used to measure and compare the relative and quantitative performance of two or more database systems through the execution of controlled experiments. Benchmarking is therefore a process of evaluating different database software systems on the same or different hardware platforms. Each experiment is made up of two kinds of variables. One is the set of independent variables which will affect the performance of database systems and areComparing Object-Oriente...|$|R
40|$|Abstract: The paper {{analyses}} business {{rule based}} data analysis for decision support and automation possibilities using business rule transformations. A specific method {{has been proposed}} for business rule transformation to the <b>executable</b> <b>instructions</b> in data analysis software systems. The proposed method enables to take the business rules used for data analysis out of software system code and use them for automated decisions and decision support to allow immediate and adequate reaction to the business environment changes according to {{the internal and external}} influences such as changes in law, new competition etc...|$|R
5000|$|Shelia [...] {{is a high}} {{interaction}} client honeypot {{developed by}} Joan Robert Rocaspana at Vrije Universiteit Amsterdam. It integrates with an email reader and processes each email it receives (URLs & attachments). Depending {{on the type of}} URL or attachment received, it opens a different client application (e.g. browser, office application, etc.) It monitors whether <b>executable</b> <b>instructions</b> are executed in data area of memory (which would indicate a buffer overflow exploit has been triggered). With such an approach, SHELIA is not only able to detect exploits, but is able to actually ward off exploits from triggering.|$|R
5000|$|United States of America Patent: Methods, devices, {{and systems}} for establishing, setting-up, and {{maintaining}} a virtual computer infrastructure US20120297179 A1 [...] Patent Overview: A system and method of operating an electronic device may include loading an operating system, from a boot key, on the electronic device during turn-on of the electronic device. The operating system may be operated on the electronic device. The boot key may cause the electronic device to automatically communicate with a web-service located on a communications network to enable <b>executable</b> <b>instructions</b> from the web-service to be communicated to the electronic device for execution thereon.|$|R
5000|$|An RPG program once {{typically}} {{started off}} with File Specifications, listing all files being written to, read from or updated, followed by Data Definition Specifications containing program elements such as Data Structures and dimensional arrays, much like a [...] "Working-Storage" [...] section of a COBOL program or [...] "var" [...] statements in Pascal. This is followed by Calculation Specifications, which contain the <b>executable</b> <b>instructions.</b> Output Specifications can follow {{which can be used}} to determine the layout of other files or reports. Alternatively files, some data structures and reports can be defined externally, mostly eliminating the need to hand code input and output ("I/O") specifications.|$|R
40|$|Race {{condition}} is a timing sensitive problem. A {{significant source of}} timing variation comes from nondeterministic hardware interactions such as cache misses. While data race detectors and model checkers can check races, the enormous state space of complex software {{makes it difficult to}} identify all of the races and those residual implementation errors still remain a big challenge. In this paper, we propose deterministic real-time scheduling methods to address scheduling nondeterminism in uniprocessor systems. The main idea is to use timing insensitive deterministic events, e. g, an instruction counter, in conjunction with a real-time clock to schedule threads. By introducing the concept of Worst Case <b>Executable</b> <b>Instructions</b> (WCEI), we guarantee both determinism and real-time performance. Comment: RTAS 11 Work-In-Progres...|$|R
50|$|A CMS-2 {{source program}} is {{composed}} of two basic types of statement. Declarative statements provide basic control information to the compiler and define {{the structure of the}} data associated with a particular program. Dynamic statements cause the compiler to generate <b>executable</b> machine <b>instructions</b> (object code).|$|R
40|$|Hungary While {{using the}} direct issue mode, {{dependent}} instructions cause issue blockages and thus an issue bottleneck. Shelving {{is a technique}} to avoid this and to increase the sustained issue rate. It takes advantage of two concepts: (a) the decoupling of dependency checking from instruction issue and (b) significantly widening the instruction window that is scanned in each clock cycle for <b>executable</b> <b>instructions.</b> In this paper we identify and explore the design space of shelving. We first outline its main dimensions, then we present and discuss feasible design alternatives along three of its crucial dimensions. Finally, we point out which design choices {{have been made in}} important superscalar processors. For a concise graphical representation of the design space we make use of DS-trees...|$|R
5000|$|Another change {{preserves}} the [...] "separate address space" [...] {{nature of a}} Harvard machine, but provides special machine operations to access {{the contents of the}} instruction memory as data. Because data is not directly <b>executable</b> as <b>instructions,</b> such machines are not always viewed as [...] "modified" [...] Harvard architecture: ...|$|R
50|$|Hardware Security Modules contain {{one or more}} cryptoprocessors. These {{devices are}} high grade secure cryptoprocessors used with Enterprise servers. A {{hardware}} security module can have multiple levels of physical security with a single-chip cryptoprocessor as its most secure component. The cryptoprocessor does not reveal keys or <b>executable</b> <b>instructions</b> on a bus, except in encrypted form, and zeros keys by attempts at probing or scanning. The crypto chip(s) may also be potted in the hardware security module with other processors and memory chips that store and process encrypted data. Any attempt to remove the potting will cause the keys in the crypto chip to be zeroed. A hardware security module may also {{be part of a}} computer (for example an ATM) that operates inside a locked safe to deter theft, substitution, and tampering.|$|R
40|$|Designing {{languages}} and systems for many-core computers {{is in some}} respects just like designing for uniprocessors. The challenge is, on the one hand, to develop an efficient organization of data, hardware, and software to accomplish the desired computation and, on the other hand, to invent a notation that is expressive and can be translated automatically to <b>executable</b> <b>instructions.</b> With many-core computers, {{it is far from}} obvious how to organize computation to run efficiently, but it seems important to think about this aspect of the problem. If nothing else, we need to have some idea of what a running program will look like so that we can begin to imagine how we might express that program in a high-level language. It is also good to know what a near-optimal program looks like in order to evaluat...|$|R
5000|$|In computing, a code segment, {{also known}} as a text segment or simply as text, is a portion of an object file or the {{corresponding}} section of the program's virtual address space that contains <b>executable</b> <b>instructions.</b> The term [...] "segment" [...] comes from the memory segment, which is a historical approach to memory management that has been succeeded by paging. When a program is stored in an object file, the code segment is a part of this file; when the loader places a program into memory so that it may be executed, various memory regions are allocated (in particular, as pages), corresponding to both the segments in the object files and to segments only needed at run time. For example, the code segment of an object file is loaded into a corresponding code segment in memory.|$|R
40|$|Systems, {{methods and}} {{apparatus}} are provided through {{which in some}} embodiments an informal specification is translated without human intervention into a formal specification. In some embodiments the formal specification is a process-based specification. In some embodiments, the formal specification is translated into a high-level computer programming language which is further compiled into a set of <b>executable</b> computer <b>instructions...</b>|$|R
40|$|When {{users of}} source-level {{debugging}} and monitoring programs choose {{to inspect the}} state of the program at a certain line number, it is desirable that effects of logically prior source statements be in the picture presented to the user, and that effects of subsequent statements not be in it. However, as optimizations change, drop and reorder code fragments, concerted effort is required of the compiler and the debug information consumer to select appropriate inspection points, and to reconstruct coherent pictures for the user. We propose a robust method for the compiler to select and annotate meaningful, consistent inspection points, and debug information extensions to support multiple coherent pictures at a single program location. They enable debug information consumers to stop at inspection points that could not be represented otherwise, and to advance to the user-visible states of subsequent source lines, {{even in the absence of}} intervening <b>executable</b> <b>instructions.</b> ...|$|R
40|$|The {{invention}} {{relates to}} {{a method for}} monitoring user activity on a mobile device, comprising an input and an output unit, comprising the following steps preferably in the following order: detecting and / or logging user activity on said input unit, identifying a foreground running application, hashing of a user-interface-element management list of the foreground running application, and creating a screenshot comprising items displayed on said input unit. The invention also relates to a method for analyzing user activity at a server, comprising the following step: obtaining {{at least one of}} an information about detected and / or logged user activity, an information about a foreground running application, a hashed user-interface-element management list and a screenshot from a mobile device. Further, a computer program product is provided, comprising one or more computer readable media having computer <b>executable</b> <b>instructions</b> for performing the steps of {{at least one of the}} aforementioned methods...|$|R
40|$|Sticking on {{with the}} basic idea, any {{processing}} device has its own specialty of virtue. It’s the usage that makes the difference depending on the requirement in the application. The general purpose attribute of a Microcontroller is very significant, and shouldn't be overlooked. A general purpose Microcontroller {{is a very powerful}} tool that allows a designer to create a special purpose design. The design becomes partially hardware and partially software. This paper has a thing to propose about the running trend of most mobile embedded devices and sensor based applications rely on ARM Cortex processors, where its standards and performance throughputs are given in comparison with other products designed as parallel trend to ARM processors. It also focuses the way in which attention to interdependent detail in intelligent voltage management, cache controller design, conditionally <b>executable</b> <b>instructions,</b> and interrupt control hardware contribute to the ARM architecture’s high performance and low power operation...|$|R
40|$|Most current-generation Wireless Sensor Network (WSN) nodes are {{equipped}} with multiple sensors of various types, and therefore support for multi-tasking and multiple concurrent applications is becoming increasingly common. This trend has been fostering the design of WSNs allowing several concurrent users to deploy applications with dissimilar requirements. In this paper, we extend the advantages of a holistic programming scheme by designing a novel compiler-assisted scheduling approach (called REIS) able to identify and eliminate redundancies across applications. To achieve this useful high-level optimization, we model each user application as a linear sequence of <b>executable</b> <b>instructions.</b> We show how well-known string-matching algorithms such as the Longest Common Subsequence (LCS) and the Shortest Common Super-sequence (SCS) {{can be used to}} produce an optimal merged monolithic sequence of the deployed applications that takes into account embedded scheduling information. We show that our approach can help in achieving about 60 % average energy savings in processor usage compared to the normal execution of concurrent applications...|$|R
40|$|The {{architecture}} for {{a shared}} memory CPU is described. The CPU allows for parallelism {{down to the}} level of single instructions and is tolerant of memory latency. All <b>executable</b> <b>instructions</b> and memory accesses are time stamped. The TimeWarp algorithm is used for managing synchronisation. This algorithm is optimistic and requires that all computations can be rolled back. The basic functions required for implementing the control and memory system used by TimeWarp are described. The memory model presented to the programmer is a single linear address space modified by a single thread of comtrol. Thus, at the software level {{there is no need for}} explicit synchronising actions when accessing memory. The physical implementation, however, is multiple CPUs with their own caches and local memory with each CPU simultaneously executing multiple threads of control. 1. Introduction Computer designers currently face a very interesting set of challenges. The steady increase in the number of transistor [...] ...|$|R
5000|$|In {{a typical}} central {{processing}} unit (CPU), the PC is a digital counter (which is {{the origin of the}} term [...] "program counter") that may be one of many registers in the CPU hardware. The instruction cycle begins with a fetch, in which the CPU places the value of the PC on the address bus to send it to the memory. The memory responds by sending the contents of that memory location on the data bus. (This is the stored-program computer model, in which <b>executable</b> <b>instructions</b> are stored alongside ordinary data in memory, and handled identically by it). Following the fetch, the CPU proceeds to execution, taking some action based on the memory contents that it obtained. At some point in this cycle, the PC will be modified so that the next instruction executed is a different one (typically, incremented so that the next instruction is the one starting at the memory address immediately following the last memory location of the current instruction).|$|R
40|$|Gameblox is an online, {{graphical}} {{programming environment}} currently {{being developed by}} the MIT Scheller Teacher Education Program {{as a means of}} making game development more accessible to students with little to no programming background. Through direct manipulation, users can create complex games by simply dragging objects onto specified screens, and attaching blocks as <b>executable</b> <b>instructions.</b> Users can create, modify, and test their games, all in one environment. However, certain users, such as beginners or students, may find that a scoped editor with only a subset of Gameblox features would be easier to use and still fulfill their goals. This thesis outlines the design and implementation of a new tool within Gameblox called the Flexidor Builder, which will allow any user to selectively restrict the view of the full Gameblox editor to create custom Gameblox editors with only a subset of features. This restricted editor is called a flexidor. by Erica Du. Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2015. Cataloged from PDF version of thesis. Includes bibliographical references (page 75) ...|$|R
40|$|ARM®’s {{success to}} date has been largely due to its {{remarkable}} performance/power (MIPS/Watt) rating, and this will likely continue to be its most critical benchmark for future applications. This paper considers how attention to interdependent detail in cache controller design, conditionally <b>executable</b> <b>instructions,</b> intelligent voltage management, and interrupt control hardware contribute to the ARM architecture’s high performance and low power operation. Level 1 Cache Controller Design As CPU clock rates go higher and higher, Level 1 caches, which are implemented {{as part of the}} processor core, are a requirement when high performance, measured in terms of clocks per instruction (CPI) must be maintained, even when frequent access must be made to SDRAM or Flash memory external to the core. A cache, as illustrated in Figure 1 below, is a subsystem that includes two kinds of RAM and some logic that forms the cache controller. The cache is interposed between the CPU and slow system memory. The purpose of a cache is to make the slow memory system look like a fast memory system. The data RAM size is measured in bytes, but internally, it is organized as lines of memory. A lin...|$|R
50|$|W^X ("Write XOR Execute"; spoken as W xor X) is a {{security}} feature in operating systems and virtual machines. It is a memory protection policy whereby every page in a process's or kernel's address space may be either writable or executable, but not both. Without such protection, a program can write (as data) CPU instructions {{in an area}} of memory intended for data and then arrange to run (as <b>executable)</b> those <b>instructions.</b> This can be dangerous if the writer of the memory is malicious.|$|R
25|$|In 2011, Touretzky began {{hosting a}} mirror of the website of George Hotz, {{containing}} <b>executable</b> files and <b>instructions</b> facilitating the jailbreaking of the Sony PlayStation 3, after Sony filed lawsuits against Hotz and other hackers aiming to utilize the takedown provisions of the DMCA to remove the content from the Internet.|$|R
5000|$|This {{final stage}} of a typical {{compiler}} converts the intermediate representation of program into an <b>executable</b> set of <b>instructions</b> (often assembly). This last stage is the only stage in compilation that is machine dependent. There can also be optimization done {{at this stage of}} compilation that make the program more efficient ...|$|R
40|$|No. 94 / 11 (replaced by 94 / 16) The {{architecture}} for an optimistic, highly parallel, scalable, {{shared memory}} CPU - the WarpEngine - is described. The WarpEngine CPU allows for parallelism {{down to the}} level of single instructions and is tolerant of memory latency. Its design is based around time stamping <b>executable</b> <b>instructions</b> and all memory accesses. The TimeWarp algorithm [Jefferson 1985, 1989] is used for managing the time stamps and synchronisation. This algorithm is optimistic and requires that all computations can be rolled back. The basic functions required for implementing the control and memory system used by TimeWarp are described. The WarpEngine memory model presented to the programmer, is a single linear address space which is modified by a single thread of execution. Thus, at the software level {{there is no need for}} locks or other explicit synchronising actions when accessing the memory. The actual physical implementation, however, is multiple CPUs with their own caches and local memory with each CPU simultaneously executing multiple threads of control. Reads from memory are optimistic, that is, if there is a local copy of a memory location it is taken as the current value. However, sometimes there will be a write with an earlier time stamp in transit in the system. When it arrives it causes the original read and any dependent calculations to be re-executed...|$|R
40|$|This paper {{deals with}} the {{challenges}} related to self-management and evolution of massive knowledge collections. We can assume that a self-managed knowledge graph needs {{a kind of a}} hybrid of: an explicit declarative self-knowledge (as knowledge about own properties and capabilities) and an explicit procedural self-knowledge (as knowledge on how to utilize own properties and the capabilities for the self-management). We offer an extension to a traditional RDF model of describing knowledge graphs according to the Semantic Web standards so that it will also allow to a knowledge entity to autonomously perform or query from remote services different computational executions needed. We also introduce the concepts of executable knowledge and knowledge computing on the basis of adding an executable property to traditionally used (datatype and object) properties within the RDF model. The knowledge represented with such an extended model we call as an executable knowledge, or the one which contains explicit (<b>executable)</b> <b>instructions</b> on how to manage itself. The appropriate process of the executable knowledge (self-) management we call as a Knowledge Computing. Unlike the knowledge answering machines, where computations over knowledge are used just for addressing a user query, the knowledge computing in addition provides computations for various self-management purposes. The paper also presents some pilot (proof-of-concept) implementation of the executable knowledge as a plug-in to Protégé ontology development environment...|$|R
40|$|Using a gate level {{emulation}} of {{a typical}} avionics miniprocessor, fault injection experiments were performed to (1) determine the time to detect a fault by comparison monitoring, (2) forecast a program's ability to detect faults and (3) validate the fault detection coverage {{of a typical}} self test program. To estimate time to detect, six programs ranging in complexity from 6 to 147 instructions, were emulated. Each program was executed repetitively {{in the presence of}} a single stuck at fault at a gate node or device pin. Detection was assumed to occur whenever the computed outputs differed from the corresponding outputs of the same program executed in a nonfaulted processor. Histograms of faults detected versus number of repetitions to detection were tabulated. Using a simple model of fault detection, which was based in an analog with the selection of balls in an urn, distributions of time to detect were computed and compared with those obtained empirically. A self test program of 2, 000 <b>executable</b> <b>instructions</b> was designed expressly for the study. The only requirement imposed on the design was that it should achieve 95 % coverage. The program was executed {{in the presence of a}} single stuck-at fault at a gate node on device pin. The proportion of detected faults are tabulated. In all experiments faults were selected at random over gate nodes or device pins...|$|R
40|$|There {{has been}} a {{significant}} effort over the past decade in creating concurrency libraries for a number of sequential programming languages, particularly for object-oriented ones such as C++ [BLL 88], Eiffel [KB 93], and Smalltalk [YT 86]. While the goal is laudable, this discussion shows that obtaining concurrency solely through libraries is, in general, unattainable in both shared-memory and distributed environments. An informal proof shows that while it is possible to build a concurrency library and applications that use it, no guarantee of correctness can be given without an unrealistic requirement being placed on the library designer and user, even when the library features are used correctly in a well formed concurrent program. This unrealistic requirement is the need to examine the <b>executable</b> <b>instructions</b> after every compilation of the library or application for incorrectly generated code. Furthermore, if incorrect code is found, it may not be possible to fix the problem directly. The library or application may have to be restructured, possibly significantly, to produce a working program. Such a requirement is clearly beyond that of any reasonable, practical technique, tool, or programmer. In other words, if a concurrency library imposes such an inspection and repair requirement, the library feature cannot be safely implemented. Moreover, such requirements violate the abstraction and encapsulation of the concurrency library itself because of the need to examine the generated code. The proof is based on the observation that any linguistic feature that affects code generation cannot b...|$|R
50|$|Full {{backward}} compatibility {{is particularly important}} in computer instruction set architectures, {{one of the most}} successful being the x86 family of microprocessors. Their full {{backward compatibility}} spans back to the Intel 8080 processors produced in 1974 but not to its predecessor, the Intel 8008. The fully backward compatible processors can process the same binary <b>executable</b> software <b>instructions</b> as their predecessors, allowing the use of a newer processor without having to acquire new applications or operating systems. Similarly, the success of the Wi-Fi digital communication standard is attributed to its broad forward and backward compatibility; it became more popular than other standards that were not backward compatible.|$|R
