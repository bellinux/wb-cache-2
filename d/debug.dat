3521|9576|Public
5|$|Like {{the other}} BSD kernels (and those of most modern {{operating}} systems), DragonFly employs a built-in kernel debugger {{to help the}} developers find kernel bugs. Furthermore, , a <b>debug</b> kernel, which makes bug reports more useful for tracking down kernel-related problems, is installed by default, {{at the expense of}} a relatively small quantity of disk space. When a new kernel is installed, the backup copy of the previous kernel and its modules are stripped of their debugging symbols to further minimize disk space usage.|$|E
5|$|The FreeBSD Project {{is run by}} around 500 committers, or {{developers}} who have commit access to the master source code repositories and can develop, <b>debug</b> or enhance {{any part of the}} system. Most of the developers are volunteers and few developers are paid by some companies. There are several kinds of committers, including source committers (base operating system), doc committers (documentation and web site authors) and ports (third party application porting and infrastructure). Every two years the FreeBSD committers select a 9-member FreeBSD Core Team who are responsible for overall project direction, setting and enforcing project rules and approving new commiters, or the granting of SVN commit access. A number of responsibilities are officially assigned to other development teams by the FreeBSD Core Team, for example, responsibility for managing the ports collection is delegated to the Ports Management Team.|$|E
5|$|Unlike the old {{characters}} in the Pokémon franchise, Mew's development was not overseen by Ken Sugimori, but by Game Freak programmer Shigeki Morimoto. Morimoto programmed Mew into the game secretly, as a prank amongst the staff just prior to its release in Japan, intending {{it to be a}} Pokémon only Game Freak staff members would know about and be able to obtain. Mew was added {{at the very end of}} the development of Pokémon Red and Blue after the removal of <b>debug</b> features, freeing up just enough space to add the character despite being told not to alter the game any further at this point. Though not intended by the developers to be obtainable, due to a glitch, players were able to encounter it.|$|E
40|$|This study {{demonstrates}} that {{formal training in}} <b>debugging</b> helps students develop skills in diagnosing and removing defects from computer programs. To enhance <b>debugging</b> skills in an assembly language course, students completed <b>debugging</b> exercises, <b>debugging</b> logs, development logs, reflective memos, and collaborative assignments. The <b>debugging</b> exercises were optional, but the other activities were mandatory. Students who completed the <b>debugging</b> exercises spent 37 % of their time on <b>debugging</b> programming assignments, whereas {{students who did not}} complete the <b>debugging</b> exercises spent 47 % of their time <b>debugging.</b> Students also provided qualitative data for each activity, and they responded to summative evaluation surveys. Students agreed that formal <b>debugging</b> training enhanced their <b>debugging</b> skills. This paper also proposes a model of <b>debugging</b> abilities and habits based on students' comments in their <b>debugging</b> logs, development logs, reflective memos, and evaluation surveys. Students and instructors can use the model to diagnose students' current <b>debugging</b> skills and take actions to enhance their skills. National Science Foundation under Grant SES- 0138309; College of Engineering, University of Illinois at Urbana-Champaignunpublishednot peer reviewe...|$|R
50|$|The JTAGICE mkII <b>debugging</b> tool {{supports}} on-chip <b>debugging</b> (OCD) of AVRs with SPI, JTAG, PDI, and debugWIRE interfaces. The debugWire interface enables <b>debugging</b> {{using only}} one pin (the Reset pin), allowing <b>debugging</b> of applications running on low pin-count microcontrollers.|$|R
40|$|Software <b>Debugging</b> {{is still}} one of the most {{challenging}} and time consuming aspects of software development. Monitor-ing the software behavior and finding the causes of this be-havior are located at the center of <b>debugging</b> process. Al-though many tools and techniques have been proposed to support developers in this job, none of them could replace or improve the traditional <b>debugging</b> methods. This paper presents Query-Point <b>debugging</b> as a new <b>debugging</b> ap-proach and explains how it can facilitate <b>debugging</b> for de-velopers...|$|R
5|$|When he proves {{unable to}} defeat Data-Sora himself, Pete infects Data-Riku's code with bugs and forces him to fight, putting the datascape {{in danger of}} being totally corrupted. Seeing no alternative, Data-Sora chooses to <b>debug</b> Data-Riku from inside, an act which will cause the datascape to reset if he succeeds, wiping his memories. The {{debugging}} process also activates the bug responsible for the data's corruption, which takes the form of Sora's Heartless. Data-Sora destroys the bug while Mickey and the others are returned to their world by Data-Riku before the reset occurs. In a scene exclusive to HD 2.5 ReMix, after Maleficent and Pete take their leave, Maleficent speaks with Pete about the Book of Prophecies, an ancient artifact capable of transcribing events that have yet to take place and even conjuring them, including entire worlds; she resolves to find it, believing it may hold a connection with the datascape and the journal.|$|E
5|$|In January 2013, a {{privilege}} escalation exploit {{was discovered in}} the Windows kernel that can allow unsigned code to run under Windows RT; the exploit involved {{the use of a}} remote debugging tool (provided by Microsoft to <b>debug</b> WinRT apps on Windows RT devices) to execute code which changes the signing level stored in RAM to allow unsigned code to execute (by default, it is set to a level that only allows code signed by Microsoft to execute). Alongside his explanation of the exploit, the developer also included a personal appeal to Microsoft urging them to remove the restrictions on Windows RT devices, contending that their decision was not for technical reasons, and that the devices would be more valuable if this functionality were available. In a statement, a Microsoft spokesperson applauded the effort, indicating that the exploit does not pose a security threat because it requires administrative access to the device, advanced techniques, and would still require programs to be re-compiled for ARM. However, Microsoft has still indicated that the exploit would be patched in a future update.|$|E
5|$|The {{majority}} of the Megami Tensei series is developed by Atlus' R Department 1. Other developers {{have been involved with}} the series: these include Multimedia Intelligence Transfer (Last Bible series), Lancarse (Strange Journey), CAVE (Imagine) and Nex Entertainment (Nine), and Arc System Works (Persona 4 Arena). Most of the games up to 2003 were handled by Okada, but when he departed to form his own company Gaia, Kazuma Kaneko became the series' creative director. There are two main writers in the franchise: Shogo Isogai and Ryutaro Ito. Ito first worked on Megami Tensei II, joining the team after development to write the script, along with working with the script and being part of the <b>debug</b> team. Isogai's first work for the series was the script for Shin Megami Tensei II. The next entry If... was also written by Ito, and designed as a departure from the grand scale of previous games, instead being set within a cloistered school environment. His final work for the series was the first Devil Summoner. Isogai also worked on Shin Megami Tensei II and If..., and later worked on multiple Devil Summoner games, Nocturne and Strange Journey. The music for the first five main Megami Tensei titles was composed by Tsukasa Masuko. For Nocturne, Shoji Meguro, who had done work on earlier spin-off titles, was brought in. He later became well known for his work on the Persona titles.|$|E
40|$|Abstract—Message-based <b>debugging</b> {{facilities}} for Web or Grid Services {{are separated from}} an infrastructure of source level <b>debugging</b> and can work in a self-identifying and coexisting mode within a normal services container. In this paper, we discuss problems for services <b>debugging</b> and approaches we take. We present the operational model and context inspection of message-based <b>debugging</b> facilities. The facilities are able to trace service behaviors, dump <b>debugging</b> information, and manage states and behavioral breakpoints of <b>debugged</b> services. This model supports a mechanism of multi-user and multi-site service <b>debugging</b> without requiring programmers or developers to one by one duplicate full scenarios in multiple servers. Keywords-Debugging facilities, mutual limitation, coexistence, breakpoint, mapping space, behavior trace, context expression, System <b>Debugging</b> Service. I...|$|R
40|$|We {{conducted}} a study to demonstrate that formal training in <b>debugging</b> helps students develop skills in diagnosing and removing defects from computer programs. To accomplish that goal in an assembly language course, we designed multiple activities to enhance students' <b>debugging</b> skills. The activities included <b>debugging</b> exercises, <b>debugging</b> logs, development logs, reflective memos, and collaborative assignments. The <b>debugging</b> exercises were optional, but the other activities were mandatory. Students who also completed the <b>debugging</b> exercises spent 37 % of their time on <b>debugging</b> programming assignments, whereas {{students who did not}} complete the <b>debugging</b> exercises spent 47 % of their time <b>debugging.</b> We also collected qualitative data for each activity through summative evaluation surveys. Students agreed that formal <b>debugging</b> abilities and habits based on students' comments in their <b>debugging</b> logs, development logs, reflective memos, and evaluation surveys. Students and instructors could use the model to diagnose students' current <b>debugging</b> skills and take actions to enhance their skills. This poster was also presented at Proceedings of the Thirty-Third ASEE/IEEE Frontiers in Education Conference, Westminster, CO, 2003 and Proceedings of the Thirty-Fifth ACM Technical Symposium on Computer Science Education, Norfolk, VA, 2004. published or submitted for publicatio...|$|R
40|$|Although {{attribute}} grammars {{are commonly}} used for compiler construction, little investigation has been conducted on <b>debugging</b> attribute grammars. The paper proposes two types of systematic <b>debugging</b> methods, an algorithmic <b>debugging</b> and slice-based <b>debugging,</b> both tailored for attribute grammars. By means of query-based interaction with the developer, our <b>debugging</b> methods effectively narrow the potential bug space in the attribute grammar description and eventually identify the incorrect attribution rule. We have incorporated this technology in our visual <b>debugging</b> tool called Aki. Comment: In M. Ducasse (ed), proceedings of the Fourth International Workshop on Automated <b>Debugging</b> (AADEBUG 2000), August 2000, Munich. cs. SE/ 001003...|$|R
25|$|Enhanced <b>debug</b> {{features}} {{with the}} introduction of the Processor-based <b>debug</b> port (See Pentium Processor Debugging in the Developers Manual, Vol 1).|$|E
25|$|Xamarin Studio and Visual Studio 2010 {{integration}} {{to design}} the UI, remotely <b>debug,</b> and deploy.|$|E
25|$|Cosmos {{offers several}} options {{as to how}} to deploy the {{resulting}} OS and how to <b>debug</b> the output.|$|E
40|$|Abstract—Due to the {{increasing}} design size and complexity of modern Integrated Circuits (IC) and the decreasing time-to-market, <b>debugging</b> {{is one of the}} major bottlenecks in the IC development cycle. This paper presents a generalized approach to automate <b>debugging</b> which can be used in different scenarios from design <b>debugging</b> to post-silicon <b>debugging.</b> The approach is based on model-based diagnosis. Diagnostic traces are proposed as an enhancement reducing <b>debugging</b> time and increasing di-agnosis accuracy. The experimental results show the effectiveness of the approach in post-silicon <b>debugging.</b> I...|$|R
40|$|End-user programmers’ code (e. g., accountants’ {{spreadsheet}} formulas) {{is fraught}} with errors. To help mitigate this problem, end-user software engineering research is becoming established. However, most of this work has focused on feature usage, rather than <b>debugging</b> strategies. If a <b>debugging</b> tool were to support end-user programmers’ specific <b>debugging</b> strategy needs, what should it take into account and how? To consider the design of such tools, this work contributes a comprehensive overview of end-user <b>debugging</b> strategies at four strategy levels. An example empirical study in Microsoft Excel demonstrates that this view of <b>debugging</b> provides useful insights, and we argue {{that many of these}} insights generalize to other environments. Our results include end-user <b>debugging</b> tactics and the effective and ineffective moves employed to achieve them, ten end-user <b>debugging</b> strategems applied to a new environment, and how these strategems were used within three contexts: by strategy used, by sensemaking step, and by <b>debugging</b> phase. These findings coalesce into a comprehensive overview of end-user <b>debugging</b> strategies and detailed implications for the design of strategy-based end-user <b>debugging</b> tools...|$|R
40|$|Program <b>debugging</b> {{is a form}} of {{diagnosis}} that might be referred to as "routine. " As such, <b>debugging</b> has similar properties as diagnosis and yet can be solved in a more straight-forward manner than many diagnostic problems. Automating the <b>debugging</b> problem is of interest for several reasons. <b>Debugging</b> is a time-consuming process that tends to haunt many programmers from novices to experts. Yet the <b>debugging</b> problem is of a scope that is implementable unlike many other diagnostic problems which have shown to require massive and unmanageable amounts of knowledge. In this paper, automated <b>debugging</b> of syntax errors in Turbo Pascal programs is considered. The <b>debugging</b> process is compared to diagnosis. Inference types are discussed along with the knowledge of Pascal that is required to perform these inferences. Finally, two prototype automated <b>debugging</b> systems are introduced and demonstrated by an example. Introduction The process of program <b>debugging</b> is one of searching a program for the [...] ...|$|R
25|$|Kinect for Windows 1.5 SDK {{would include}} 'Kinect Studio' a new app that allows {{developers}} to record, playback, and <b>debug</b> clips of users interacting with applications.|$|E
25|$|Information on {{features}} in the distributions. Package numbers are only approximate (some distributions like Ubuntu tend to separate tools into different packages (usually stable release, development release, documentation and <b>debug).</b>|$|E
25|$|In 2014, Hewlett {{directed}} the supernatural horror-science fiction film <b>Debug</b> with Jason Momoa, who starred alongside Hewlett in Stargate Atlantis. Jeananne Goossen and Adrian Holmes played the lead {{roles in the}} film.|$|E
40|$|Parallel <b>debugging</b> faces {{challenges}} in both scalability and efficiency. A number of advanced {{methods have been}} invented to improve the efficiency of parallel <b>debugging.</b> As the scale of system increases, these methods highly rely on a scalable communication protocol {{in order to be}} utilized in large-scale distributed environments. This paper describes a <b>debugging</b> middleware that provides fundamental <b>debugging</b> functions supporting multiple communication protocols. Its pluggable architecture allows users to select proper communication protocols as plug-ins for <b>debugging</b> on different platforms. It aims to be utilized by various advanced <b>debugging</b> technologies across different computing platforms. The performance of this <b>debugging</b> middleware is examined on a Cray XE Supercomputer with 21, 760 CPU cores...|$|R
40|$|<b>Debugging</b> {{is still}} {{among the most}} common and costly of {{programming}} activities. One reason is that current <b>debugging</b> tools do not directly support the inquisitive nature of the activity. Interrogative <b>Debugging</b> is a new <b>debugging</b> paradigm in which programmers can ask why did and even why didn’t questions directly about their program’s runtime failures. The Whyline is a prototype Interrogative <b>Debugging</b> interface for the Alice programming environment that visualizes answers in terms of runtime events directly relevant to a programmer’s question. Comparisons of identical <b>debugging</b> scenarios from user tests with and without the Whyline showed that the Whyline reduced <b>debugging</b> time by nearly a factor of 8, and helped programmers complete 40 % more tasks...|$|R
40|$|To aid the {{development}} of spreadsheet <b>debugging</b> tools, a knowledge of end-users natural behaviour within the Excel environment would be advantageous. This paper details the design and application of a novel data acquisition tool, {{which can be used}} for the unobtrusive recording of end-users mouse, keyboard and Excel specific actions during the <b>debugging</b> of Excel spreadsheets. A <b>debugging</b> experiment was conducted using this data acquisition tool, and based on analysis of end-users performance and behaviour data, the authors developed a "spreadsheet cell coverage feedback" <b>debugging</b> tool. Results from the <b>debugging</b> experiment are presented in terms of enduser <b>debugging</b> performance and behaviour, and the outcomes of an evaluation experiment with the <b>debugging</b> tool are detailed. Comment: 12 Pages, 13 Figure...|$|R
25|$|Agostino Russo and Ecology2007 later {{redesigned}} and rewrote {{the current}} Windows front-end. Hampus Wessman contributed the new downloader and the translation scripts. Bean123 and Tinybit also helped to <b>debug</b> and fix bootloader issues. Lubi and LVPM were subsequently created by Geza Kovacs.|$|E
25|$|Optimization {{can reduce}} {{readability}} and add code {{that is used}} only to improve the performance. This may complicate programs or systems, making them harder to maintain and <b>debug.</b> As a result, optimization or performance tuning is often performed {{at the end of}} the development stage.|$|E
25|$|August 2011 – 50 alpha {{boards are}} manufactured. These boards were {{functionally}} {{identical to the}} planned ModelB, but they were physically larger to accommodate <b>debug</b> headers. Demonstrations of the board showed it running the LXDE desktop on Debian, Quake 3 at 1080p, and Full HD MPEG-4 video over HDMI.|$|E
50|$|A <b>debugging</b> {{data format}} {{is a means}} of storing {{information}} about a compiled computer program for use by high-level debuggers. Modern <b>debugging</b> data formats store enough information to allow source-level <b>debugging.</b>|$|R
50|$|The most {{important}} run-time <b>debugging</b> feature was {{the ability to}} change the code on the fly while <b>debugging.</b> This allowed for bugs to be fixed while <b>debugging</b> without the need to recompile.|$|R
5000|$|Until 1956 - <b>Debugging</b> Oriented [...] - [...] Until 1956 {{it was the}} <b>debugging</b> {{oriented}} period, when {{testing was}} often associated to debugging: there was no clear difference between testing and <b>debugging.</b>|$|R
25|$|A ROM {{image was}} leaked {{of an early}} alpha version of the game, which came from a source code archive dating to when the game was in early development. This version {{features}} a rudimentary multiplayer mode. Another ROM, compiled from a close to release source code, can also be found—this version is nearly complete and contains minor bugs, <b>debug</b> code, and unfinished features, however, it lacks the multiplayer mode found in the alpha version. These ROMs can be played using a SNES emulator and can be run on real hardware if burned to a cartridge with a Super FX chip. Additionally, a fan-made patch {{can be added to}} the near-final ROM, which fixes most of the bugs, removes the <b>debug</b> code and the unfinished features, and translates the game's dialog into English, although a version of this patch also exists without the language translation.|$|E
25|$|Microsoft Visual Studio {{includes}} native {{support for}} data programming with Microsoft SQL Server. It {{can be used}} to write and <b>debug</b> code to be executed by SQL CLR. It also includes a data designer that {{can be used to}} graphically create, view or edit database schemas. Queries can be created either visually or using code. SSMS 2008 onwards, provides intellisense for SQL queries as well.|$|E
25|$|In his online postings, Titor {{claimed to}} be an American soldier from 2036, based in Tampa, Florida. He was {{assigned}} to a governmental time-travel project, and sent back to 1975 to retrieve an IBM 5100 computer which he said was needed to <b>debug</b> various legacy computer programs in 2036; a possible reference to the UNIX year 2038 problem. The IBM 5100 runs the APL and BASIC programming languages.|$|E
40|$|One reason <b>debugging</b> is {{the most}} {{time-consuming}} part of software development is because developers struggle to map their questions about a program's behavior onto <b>debugging</b> tools' limited support for analyzing code. Interrogative <b>debugging</b> is a new <b>debugging</b> paradigm that allows developers to ask questions directly about their programs' output, helping them to more efficiently and accurately determine what parts of the system to understand. An interrogative <b>debugging</b> prototype called the Whyline is described, which {{has been shown to}} reduce <b>debugging</b> time by a factor of eight. Several extensions and generalizations to it are proposed, including plans for evaluating their effectiveness...|$|R
40|$|Abstract—Debugging {{is one of}} {{the major}} {{bottlenecks}} in the current VLSI design process as design size and complexity increase. Efficient automation of <b>debugging</b> procedures helps to reduce <b>debugging</b> time and to increase diagnosis accuracy. This work proposes an approach for automating the design <b>debugging</b> procedures by integrating SAT-based <b>debugging</b> with testbench-based verification. The diagnosis accuracy increases by iterating <b>debugging</b> and counterexample generation, i. e., the total number of fault candidates decreases. The experimental results show that our approach is as accurate as exact formal <b>debugging</b> in 71 % of the experiments. Keywords—automated debugging; testbench; diagnostic trace; I...|$|R
40|$|Over {{the past}} few years there has been a {{significant}} amount of interest in the area of <b>debugging</b> and repairing of OWL ontologies. The process of <b>debugging</b> an ontology is necessary {{in the same way that}} <b>debugging</b> programme code is necessary – that is, <b>debugging</b> takes place in order to eradicate faults. In terms o...|$|R
