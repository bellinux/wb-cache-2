4|10|Public
40|$|Several {{different}} approaches to define the formal operational semantics of statecharts have been proposed in the literature, including visual techniques based on graph transformation. These visual approaches either define a compiler seman-tics (translating a concrete statechart into a semantical domain) or they define an interpreter using complex control and helper structures. Existing visual semantics definitions {{make it difficult to}} apply the classical theory of graph transformations to analyze behavioral statechart properties due to the complex control structures. In this paper, we define an <b>interpreter</b> <b>semantics</b> for statecharts based on amalga-mated graph transformation where rule schemes are used to handle an arbitrary number of transitions in orthogonal states in parallel. We build on an extension of the existing theory of amalgamation from binary to multi-amalgamation including nested application conditions to control rule applications for automatic simulation. This is essential for the <b>interpreter</b> <b>semantics</b> of statecharts. The theory of amalga-mation allows us to show termination of the <b>interpreter</b> <b>semantics</b> of well-behaved statecharts, and especially for our running example, a producer-consumer system...|$|E
40|$|An {{animation}} is {{an abstraction}} of a required {{system and a}} proof basis for correct animations of Z has been identified in a publication by Breuer and Bowen. The potential of animation for explaining formal specifications is acknowledged and the proof criteria for correctness is abstract approximation, based {{on the notion of}} abstract interpretation. The example <b>interpreter</b> <b>semantics</b> is implemented in a lazy functional programming language...|$|E
40|$|Following {{the long}} term goal of {{designing}} and implementing a higher-order functor language we give here the interpreter and compiler semantics for a procedural and a functional core language in terms of denotational semantics. By <b>interpreter</b> <b>semantics</b> we mean the usual way of directly evaluating {{the meaning of a}} program. The compiler semantics transform the program into a simpler language without identifiers. The rules are generic in the basic types and presented in a way such that they can be implemented straight forwardly...|$|E
40|$|Abstract. We review how the {{dependence}} upon semantics {{has been taken}} into account in abstract interpretation based program analysis and next propose to design general purpose abstract <b>interpreters</b> taking <b>semantics</b> as a parameter, either that of the program to be analyzed or that of a programming language...|$|R
40|$|Abstract. In this paper, we give an {{operational}} and denotational se-mantics for a 3 APL meta-language, with which various 3 APL inter-preters can be programmed. We moreover prove equivalence {{of these two}} semantics. Furthermore, we relate this 3 APL meta-language to object-level 3 APL by providing a specific <b>interpreter,</b> the <b>semantics</b> of which {{will prove to be}} equivalent to object-level 3 APL. ...|$|R
40|$|AbstractIn this paper, we give an {{operational}} and denotational semantics for a meta-language of the 3 APL agent programming language. With this meta-language, various 3 APL interpreters can be programmed. We prove equivalence of the operational and denotational semantics. Furthermore, we give {{an operational}} semantics for object-level 3 APL. Using this semantics, we relate the 3 APL meta-language to object-level 3 APL {{by providing a}} specific <b>interpreter,</b> the <b>semantics</b> of which {{will prove to be}} equivalent to object-level 3 APL...|$|R
40|$|Scala's type system unifies ML modules, object-oriented, and {{functional}} programming. The Dependent Object Types (DOT) family of calculi {{has been proposed}} as a new foundation for Scala and similar languages. Unfortunately, {{it is not clear}} how DOT relates to any well-known type systems, and type soundness has only been established for very restricted subsets. In fact, important Scala features are known to break at least one key metatheoretic property such as environment narrowing or subtyping transitivity, which are usually required for a type soundness proof. First, and, perhaps surprisingly, we show how rich DOT calculi can still be proved sound. The key insight is that narrowing and subtyping transitivity only need to hold for runtime objects, but not for code that is never executed. Alas, the dominant method of proving type soundness, Wright and Felleisen's syntactic approach, is based on term rewriting, which does not a priori make a distinction between runtime and type assignment time. Second, we demonstrate how type soundness can be proved for advanced, polymorphic, type systems with respect to high-level, definitional interpreters, implemented in Coq. We present the first mechanized soundness proof in this style for System F<: and several extensions, including mutable references. Our proofs use only simple induction: another surprising result, as the combination of big-step semantics, mutable references, and polymorphism is commonly believed to require co-inductive proof techniques. Third, we show how DOT-like calculi emerge as generalizations of F<:, exposing a rich design space of calculi with path-dependent types which we collectively call System D. Armed with insights from the definitional <b>interpreter</b> <b>semantics,</b> we also show how equivalent small-step semantics and soundness proofs in Wright-Felleisen-style can be derived for these systems...|$|E
40|$|Over {{the last}} few years we have seen an {{increasing}} number of applications of Fuzzy Logic Controllers. These applications range from the development of auto-focus cameras, to the control of subway trains, cranes, automobile subsystems (automatic transmissions), domestic appliances, and various consumer electronic products. In summary, we consider a Fuzzy Logic Controller to be a high level language with its local <b>semantics,</b> <b>interpreter,</b> and compiler, which enables us to quickly synthesize non-linear controllers for dynamic systems...|$|R
40|$|Logic {{programming}} employs logic as a programming language. Thus a logic program {{consists of}} a set of clauses of a certain form most often a subset of the clauses of first order logic viewed as axioms. Computation in this paradigm is deduction from these axioms via some <b>interpreter.</b> Logic programming <b>semantics</b> is concerned with background theory for logic programming. It tries to provide models for logic programs to give them their intended meaning and to connect them with practically implementable interpreters...|$|R
40|$|This paper {{describes}} a completely automated method for generating efficient and competitive <b>interpreters</b> from formal <b>semantics</b> expressed in Rewriting Logic. The semantics are compiled into OCaml code, which then {{acts as the}} interpreter for the language being defined. This automatic translation is tested on the semantics of an imperative {{as well as a}} functional language, and these generated interpreters are then benchmarked across a number of programs. In all cases the compiled interpreter is faster than directly executing the definition in a Rewriting system with improvements of several orders of magnitude. unpublishednot peer reviewe...|$|R
40|$|Abstract: In {{order to}} design {{software}} that {{is intended to}} compute answers to queries that are in accordance with some logic programming semantics, one would like to offer up a formal specification of the software design {{which could be used}} profitably to construct the software, and one would {{want to be able to}} prove that the specification is in fact faithful to the semantics. This paper presents a constructive formal specification of semantic trees and truthvalue determinations using semantic trees for disjunctive logic programs with negation as failure. This specification methodology directly supports the design of top-down <b>interpreters</b> for well-founded <b>semantics...</b>|$|R
40|$|The vlisp {{project has}} {{produced}} a rigorously verified compiler from Scheme to byte codes, and a verified interpreter for the resulting byte codes. The official denotational semantics for Scheme provides the main criterion of correctness. The Wand-Clinger technique was used to prove correctness of the primary compiler step. Then a state machine operational semantics is proved {{to be faithful to}} the denotational semantics. The remainder of the implementation is verified by a succession of state machine refinement proofs. These include proofs that garbage collection is a sound implementation strategy, and that a particular garbage collection algorithm is correct. Keywords: Scheme, verified, compiler, <b>interpreter,</b> denotational <b>semantics,</b> operational semantics, refinement, garbage collection Table of Contents 1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 2 1. 1 Structure of the VLISP Implementation : : : : : : : : : : : : : : : : : : : : 3 1 [...] . ...|$|R
40|$|This {{document}} presents {{our main}} {{contributions to the}} field of compilation, and more generally to the quest of performance ofcomputing systems. It is structured by type of execution environment, from static compilation (execution of native code), to JIT compilation, and purelydynamic optimization. We also consider interpreters. In each chapter, we give a focus on the most relevant contributions. Chapter 2 describes our work about static compilation. It covers a long time frame (from PhD work 1995 [...] 1998 to recent work on real-timesystems and worst-case execution times at Inria in 2015) and various positions, both in academia and in the industry. My research on JIT compilers started in the mid- 2000 s at STMicroelectronics, and is still ongoing. Chapter 3 covers the results we obtained on various aspects of JIT compilers: split-compilation, interaction with real-time systems, and obfuscation. Chapter 4 reports on dynamic binary optimization, a research effort started more recently, in 2012. This considers the optimization of a native binary (without source code), while it runs. It incurs significant challenges but also opportunities. Interpreters represent an alternative way to execute code. Instead of native code generation, an interpreter executes an infinite loop thatcontinuously reads a instruction, decodes it and executes its <b>semantics.</b> <b>Interpreters</b> are much easier to develop than compilers,they are also much more portable, often requiring a simple recompilation. The price to pay is the reduced performance. Chapter 5 presents some of our work related to interpreters. All this research often required significant software infrastructures for validation, from early prototypes to robust quasi products, andfrom open-source to proprietary. We detail them in Chapter 6. The last chapter concludes and gives some perspectives...|$|R

