10000|10000|Public
5|$|Helicoverpa zea earns its {{nickname}} {{the corn}} earworm for its widely known destruction of cornfields. The corn earworm feeds on {{every part of}} corn, including the <b>kernels.</b> Severe feeding {{at the tip of}} <b>kernels</b> allows entry for diseases and mold growth. Larvae begin feeding on the <b>kernels</b> once they have reached third instar. Larvae penetrate 9 to 15cm into the ear, with deeper penetration occurring as the <b>kernels</b> harden. Larvae do not eat the hard <b>kernels,</b> but take bites out of many <b>kernels,</b> lowering the quality of the corn for processing.|$|E
5|$|While all Debian {{releases}} {{are derived}} from the GNU Operating System and use the GNU userland and the GNU C library (glibc), other <b>kernels</b> aside from the Linux kernel are also available, such as those based on BSD <b>kernels</b> and the GNU Hurd microkernel.|$|E
5|$|Adenhart's number 21 jersey was retired by the Cedar Rapids <b>Kernels,</b> the Angels' Class A affiliate, on June 20, 2010. The <b>Kernels,</b> the <b>Kernels</b> Foundation, and the Adenhart {{family also}} {{established}} the Nick Adenhart Memorial Scholarship, a yearly $1,000 scholarship. The Orem Owlz, for whom Adenhart briefly played in 2005, have worn special jerseys, which bear {{the likeness of}} a screen-printed picture of Adenhart, along with his number 34. The Little League Baseball field where Adenhart played in Halfway, Maryland, was rededicated as the Nicholas James Adenhart Memorial Field. The Hagerstown Suns, the Minor League Baseball affiliate in Hagerstown, Maryland, held a fundraiser for the Nick Adenhart Memorial Fund and added Adenhart to their Wall of Fame at Municipal Stadium. The city of Manhattan Beach, Wilhite's home town, erected the Pearson-Wilhite-Stewart-Adenhart Commemorative Wall at Marine Avenue Park honoring all four victims of the crash.|$|E
5000|$|K: <b>Kernel</b> KA: <b>Kernel</b> Access KC: <b>Kernel</b> Cache KCB: <b>Kernel</b> Cache Buffer KCBW: <b>Kernel</b> Cache Buffer Wait KCC: <b>Kernel</b> Cache Control file KCCB: <b>Kernel</b> Cache Control file Backup KCCCF: <b>Kernel</b> Cache Copy Flash {{recovery}} area KCCDC: <b>Kernel</b> cache Control file Copy KCP: <b>Kernel</b> Cache transPortable tablespace KCR: <b>Kernel</b> Cache Redo KCT: <b>Kernel</b> Cache insTance KD: <b>Kernel</b> Data KG: <b>Kernel</b> Generic KGL: <b>Kernel</b> Generic library cache KGLJ: <b>Kernel</b> Generic library cache Java KJ: <b>Kernel</b> Locking KK: <b>Kernel</b> Compilation KQ: <b>Kernel</b> Query KS: <b>Kernel</b> Service(s) KSB: <b>Kernel</b> Service Background KSM: <b>Kernel</b> Service Memory KSR: <b>Kernel</b> Service Reliable message KSU: <b>Kernel</b> Service User KSUSE: <b>Kernel</b> Service User SEssion KSUSECON: <b>Kernel</b> Service User SEssion CONnection KSUSEH: <b>Kernel</b> Service User SEssion History KT: <b>Kernel</b> Transaction(s) KTU: <b>Kernel</b> Transaction Undo KX: <b>Kernel</b> Execution KXS: <b>Kernel</b> eXecution Sql KZ: <b>Kernel</b> Security K2: <b>Kernel</b> Distributed Transactions ...|$|R
5000|$|... where [...] with a [...] <b>kernel</b> on {{the domain}} of -s , [...] is a <b>kernel</b> on the {{embedded}} distributions, and [...] is the RKHS determined by [...] Examples for [...] include the linear <b>kernel</b> , the Gaussian <b>kernel</b> , the exponential <b>kernel</b> , the Cauchy <b>kernel</b> , the generalized t-student <b>kernel</b> , or the inverse multiquadrics <b>kernel</b> [...]|$|R
30|$|The several {{frequently}} used <b>kernel</b> functions are linear <b>kernel,</b> polynomial <b>kernel,</b> RBF <b>kernel,</b> and Sigmoid <b>kernel.</b> The linear <b>kernel</b> is mainly used in linearly separable situation. The polynomial <b>kernel</b> can map low-dimension input space to high-dimension feature space. However, {{there are many}} parameters in polynomial <b>kernel.</b> When the order of polynomial is high, the element value of <b>kernel</b> matrix tends to be infinite or infinitesimal. The computational complexity will be too large to calculate. RBF <b>kernel</b> {{is a kind of}} <b>kernel</b> function with strong locality, and it can map a sample into a more higher dimension space. It is the most widely used <b>kernel.</b> Whether or not the amount of the samples are large or small, it has great performance. And comparing with polynomial <b>kernel,</b> the parameter of RBF <b>kernel</b> is fewer. Therefore, SVM uses RBF <b>kernel</b> preferential in the majority of cases. The non-positive semi-definiteness of Sigmoid <b>kernel</b> makes its application limited. So, SVM selects RBF <b>kernel</b> in this paper.|$|R
5|$|Nahor oil, pressed {{from the}} <b>kernels</b> of Mesua ferrea, {{is used in}} India as a lamp oil.|$|E
5|$|The rise of {{consumer}} GPUs {{has led to}} support for compute <b>kernels,</b> either in graphics APIs (referred to as compute shaders), in dedicated APIs (such as OpenCL), or in other language extensions.|$|E
5|$|The Egyptians {{are also}} {{thought to have}} come into {{knowledge}} about elements such as antimony, copper, crude arsenic, lead, opium, and mandrake (among others) which are mentioned in papyri. Egyptians are now {{thought to be the}} first to master distillation, and to manipulate the poison that can be retrieved from apricot <b>kernels.</b>|$|E
50|$|The 64-bit <b>kernel</b> {{does not}} support 32-bit <b>kernel</b> extensions, and the 32-bit <b>kernel</b> {{does not support}} 64-bit <b>kernel</b> extensions.|$|R
40|$|Abstract. Dynamic <b>kernel</b> {{memory has}} been a popular target of recent <b>kernel</b> malware due to the {{difficulty}} of determining the status of volatile dynamic <b>kernel</b> objects. Some existing approaches use <b>kernel</b> memory mapping to identify dynamic <b>kernel</b> objects and check <b>kernel</b> integrity. The snapshot-based memory maps generated by these approaches are based on the <b>kernel</b> memory which may have been manipulated by <b>kernel</b> malware. In addition, because the snapshot only reflects the memory status at a single time instance, its usage is limited in temporal <b>kernel</b> execution analysis. We introduce a new runtime <b>kernel</b> memory mapping scheme called allocation-driven mapping, which systematically identifies dynamic <b>kernel</b> objects, including their types and lifetimes. The scheme works by capturing <b>kernel</b> object allocation and deallocation events. Our system provides a number of unique benefits to <b>kernel</b> malware analysis: (1) an un-tampered view wherein the mapping of <b>kernel</b> data is unaffected by the manipulation of <b>kernel</b> memory and (2) a temporal view of <b>kernel</b> objects to be used in temporal analysis of <b>kernel</b> execution. We demonstrate the effectiveness of allocation-driven mapping in two usage scenarios. First, we build a hidden <b>kernel</b> object detector that uses an un-tampered view to detect the data hiding attacks of 10 <b>kernel</b> rootkits that directly manipulate <b>kernel</b> objects (DKOM). Second, we develop a temporal malware behavior monitor that tracks and visualizes malware behavior triggered by the manipulation of dynamic <b>kernel</b> objects. Allocation-driven mapping enables a reliable analysis of such behavior by guiding the inspection only to the events relevant to the attack...|$|R
3000|$|The common <b>kernel</b> {{functions}} include linear <b>kernel</b> function, polynomial <b>kernel</b> function, Gauss radial basis <b>kernel</b> {{function and}} sigmoid <b>kernel</b> function. What {{need to consider}} when selecting the <b>kernel</b> function are its ability to handle nonlinear {{and the number of}} undetermined parameters. In this paper, select Gauss radial basis <b>kernel</b> function, that is K([...] x_i,x_j) = [[...] - ([...] x_i - x_j)^ 2 / 2 σ^ 2].|$|R
5|$|A German Linux {{programmer}} from gpl-violations.org {{obtained a}} preliminary injunction against Fortinet's UK subsidiary in April 2005, due to {{allegations that the}} company was using encryption to hide its use of Linux <b>kernels</b> that are subject to a General Public License (GPL). The license's terms require disclosure of the source code. The following month Fortinet agreed to make its source code for GPL-licensed elements available upon request, modified its licensing terms and made other changes, ending the dispute.|$|E
5|$|Adenhart {{made his}} {{professional}} debut on June 25, 2005 with the Pioneer League's Orem Owlz, the Angels' Rookie League affiliate. In his lone appearance for the Owlz, he pitched six innings, allowed one unearned run, struck out seven, and earned the win. He {{spent the rest}} of the 2005 season with the Angels of the Arizona League that summer. In 13 games for the Angels, he had a 2–3 record, a 3.68 ERA, and 52 strikeouts. The following spring, at the age of 19, Adenhart was one of twelve pitchers who earned a non-roster invitation to the Angels' big league camp. As the 2006 season began, he was also considered the Angels' sixth best prospect and the 90th-best overall by Baseball America. Adenhart was assigned to the Cedar Rapids <b>Kernels,</b> the Angels' Low-A affiliate, after spring training. He pitched well for the <b>Kernels.</b> In 16 games, Adenhart had 10 wins, a 1.95 ERA, and 99 strikeouts in 106 innings pitched. His performance earned him a starting assignment in the 2006 All-Star Futures Game on June 21 and a promotion to the Rancho Cucamonga Quakes, the organization's High-A affiliate, soon after. He continued his efforts with the Quakes, winning five games and losing two in nine starts. Adenhart was a member of the United States Olympic Qualifying team in 2006, along with fellow Angels prospect Brandon Wood.|$|E
5|$|In 1934 he {{photographed the}} film Kentucky <b>Kernels,</b> {{starring}} the comedy team of Wheeler & Woolsey. More importantly, Edward {{got to work}} with his father, Henry Sr., on the final film of Henry's career. 1936 saw his tenure at RKO come to an end, {{when he decided to}} turn down a new contract and enter the freelance arena; he shot films at both RKO and Paramount during the remainder of the year. The year also saw Cronjager's selection to the Academy of Motion Picture Arts and Sciences (AMPAS) nominating rules committee for the cinematography Oscar.|$|E
5000|$|Most current Unix-like {{systems and}} Microsoft Windows support loadable <b>kernel</b> modules, {{although}} they might {{use a different}} name for them, such as <b>kernel</b> loadable module (kld) in FreeBSD, <b>kernel</b> extension (kext) in macOS, <b>kernel</b> extension module in AIX, kernel-mode driver in Windows NT [...] and downloadable <b>kernel</b> module (DKM) in VxWorks. They are also known as <b>kernel</b> loadable modules (or KLM), and simply as <b>kernel</b> modules (KMOD).|$|R
40|$|Owing to {{the effect}} of {{classified}} models was different in Protein-Protein Interaction (PPI) extraction, which was made by different single <b>kernel</b> functions, and only using single <b>kernel</b> function hardly trained the optimal classified model to extract PPI, this paper presents a strategy to find the optimal <b>kernel</b> function from a <b>kernel</b> function set. The strategy is that in the <b>kernel</b> function set which consists of different single <b>kernel</b> functions, endlessly finding the last two <b>kernel</b> functions on the performance in PPI extraction, using their optimal <b>kernel</b> function to replace them, until there is only one <b>kernel</b> function and it’s the final optimal <b>kernel</b> function. Finally, extracting PPI using the classified model made by this <b>kernel</b> function. This paper conducted the PPI extraction experiment on AIMed corpus, the experimental result shows that the optimal convex combination <b>kernel</b> function this paper presents can effectively improve the extraction performance than single <b>kernel</b> function, and it gets the best precision which reaches 65. 0 among the similar PPI extrac-tion systems...|$|R
40|$|Abstract—Convolution tree <b>kernel</b> {{has shown}} {{promising}} results in semantic role labeling (SRL). However, this <b>kernel</b> {{does not consider}} much linguistic knowledge in <b>kernel</b> design and only performs hard matching between subtrees. To overcome these constraints, this paper proposes a grammar-driven convolution tree <b>kernel</b> for SRL by introducing more linguistic knowledge. Compared with the standard convolution tree <b>kernel,</b> the proposed grammar-driven <b>kernel</b> has two advantages: 1) grammar-driven approximate substructure matching, and 2) grammar-driven approximate tree node matching. The two approximate matching mechanisms enable the proposed <b>kernel</b> to better explore linguistically motivated structured knowledge. Experiments on the CoNLL- 2005 SRL shared task and the PropBank I corpus show that the proposed <b>kernel</b> outperforms the standard convolution tree <b>kernel</b> significantly. Moreover, we present a composite <b>kernel</b> to integrate a feature-based polynomial <b>kernel</b> and the proposed grammar-driven convolution tree <b>kernel</b> for SRL. Experimental results show that our composite kernel-based method significantly outperforms the previously best-reported ones. Index Terms—Dynamic programming, grammar-driven convolution tree <b>kernel,</b> natural languages, semantic role labeling. I...|$|R
5|$|Like {{the other}} BSD <b>kernels</b> (and those of most modern {{operating}} systems), DragonFly employs a built-in kernel debugger {{to help the}} developers find kernel bugs. Furthermore, , a debug kernel, which makes bug reports more useful for tracking down kernel-related problems, is installed by default, {{at the expense of}} a relatively small quantity of disk space. When a new kernel is installed, the backup copy of the previous kernel and its modules are stripped of their debugging symbols to further minimize disk space usage.|$|E
5|$|The ReactOS and the Wine {{projects}} {{share the}} goal to run binary Windows software natively and can share therefore many dependencies and development. ReactOS uses {{portions of the}} Wine project {{so that it can}} benefit from Wine's progress in implementing the Win32 API. While Wine's NTDLL, USER32, KERNEL32, GDI32, and ADVAPI32 components cannot be used directly by ReactOS due to architectural differences, code snippets of them and other parts can be shared between both projects. The kernel is developed by ReactOS separately as Wine relies here on existing Unix-like <b>kernels.</b>|$|E
5|$|The {{technology}} {{of everyday life}} is not well recorded, but archaeological evidence shows it to have been {{similar to that in}} Ireland and Anglo-Saxon England. Recently evidence has been found of watermills in Pictland and kilns were used for drying <b>kernels</b> of wheat or barley, not otherwise easy in the changeable, temperate climate. Although constructed in earlier times, brochs, roundhouses and crannogs remained in use into and beyond the Pictish period.|$|E
40|$|Abstract—We {{introduce}} <b>kernel</b> entropy {{component analysis}} (<b>kernel</b> ECA) {{as a new}} method for data transformation and dimensionality reduction. <b>Kernel</b> ECA reveals structure relating to the Renyi entropy of the input space data set, estimated via a <b>kernel</b> matrix using Parzen windowing. This is achieved by projections onto a subset of entropy preserving <b>kernel</b> principal component analysis (<b>kernel</b> PCA) axes. This subset does not need, in general, to correspond to the top eigenvalues of the <b>kernel</b> matrix, {{in contrast to the}} dimensionality reduction using <b>kernel</b> PCA. We show that <b>kernel</b> ECA may produce strikingly different transformed data sets compared to <b>kernel</b> PCA, with a distinct angle-based structure. A new spectral clustering algorithm utilizing this structure is developed with positive results. Furthermore, <b>kernel</b> ECA is shown to be an useful alternative for pattern denoising...|$|R
5000|$|<b>Kernel</b> markers were {{a static}} <b>kernel</b> {{instrumentation}} support mechanism for Linux <b>kernel</b> source code, allowing special {{tools such as}} LTTng or SystemTap to trace information exposed by these probe points. <b>Kernel</b> markers were declared in the <b>kernel</b> code by one-liners of the form: ...|$|R
40|$|The <b>kernel</b> {{hardening}} {{function is}} necessary in terms of <b>kernel</b> stability to reduce the system error or panic due to the <b>kernel</b> code error that is made by program developer. But, the traditional <b>kernel</b> hardening method is difficult to implement and consuming high cost. The suggested <b>kernel</b> hardening function that makes high availability system by changing the panic() function of inside <b>kernel</b> code guarantees normal system operation by recovering the incorrect address of the <b>kernel</b> stack frame. We experimented the <b>kernel</b> hardening function at the network module of the Linux by forcing panic code and confirmed the proposed design mechanism of <b>kernel</b> hardening is working well by this experiment...|$|R
25|$|Modern Unix-derivatives are {{generally}} based on module-loading monolithic <b>kernels.</b> Examples {{of this are}} the Linux kernel in its many distributions {{as well as the}} Berkeley software distribution variant <b>kernels</b> such as FreeBSD, DragonflyBSD, OpenBSD, NetBSD,and macOS. Apart from these alternatives, amateur developers maintain an active operating system development community, populated by self-written hobby <b>kernels</b> which mostly end up sharing many features with Linux, FreeBSD, DragonflyBSD, OpenBSD or NetBSD <b>kernels</b> and/or being compatible with them.|$|E
25|$|Popcorn will pop when freshly harvested, but not well: {{its high}} {{moisture}} content leads to poor expansion and chewy pieces of popcorn. <b>Kernels</b> {{with a high}} moisture content are also susceptible to mold when stored. For these reasons, popcorn growers and distributors dry the <b>kernels</b> until they reach the moisture level at which they expand the most. This differs by variety and conditions, but is generally {{in the range of}} 14–15% moisture by weight. If the <b>kernels</b> are over-dried, the expansion rate will suffer and the percentage of <b>kernels</b> that pop at all will decline.|$|E
25|$|The nut <b>kernels</b> of all {{the species}} are edible, but the walnuts most {{commonly}} traded are from the J.regia, the only species which has a large nut and thin shell. J.nigra <b>kernels</b> are also produced commercially in the US.|$|E
40|$|A <b>kernel</b> {{adapted to}} the {{spectral}} dimension of hyper-spectral images is proposed in this paper. A distance based on a statistical cluster model is used to construct a radial <b>kernel.</b> This class specific <b>kernel</b> realizes a com-promise between a conventional Gaussian <b>kernel</b> and a Gaussian <b>kernel</b> on the first principal components of the considered class. An automatic gradient optimization is used to select the optimal hyperparameters. Experimen-tal results on a real hyperspectral image show the <b>kernel</b> is effective compared to the conventional Gaussian ker-nel. Furthermoren the proposed <b>kernel</b> is less sensitive to one hyperparameter compared to the Gaussian <b>kernel</b> applied on the first principal components of the data. Index Terms — Hyperspectral image, Mahalanobis <b>kernel,</b> probabilistic principal component analysis, sup-port vector machine, <b>kernel</b> methods. 1...|$|R
40|$|Following {{the very}} recent {{line of work}} on the ``{{generalized}} min-max'' (GMM) <b>kernel,</b> this study proposes the ``generalized intersection'' (GInt) <b>kernel</b> and the related ``normalized generalized min-max'' (NGMM) <b>kernel.</b> In computer vision, the (histogram) intersection <b>kernel</b> has been popular, and the GInt <b>kernel</b> generalizes it to data which can have both negative and positive entries. Through an extensive empirical classification study on 40 datasets from the UCI repository, {{we are able to}} show that this (tuning-free) GInt <b>kernel</b> performs fairly well. The empirical results also demonstrate that the NGMM <b>kernel</b> typically outperforms the GInt <b>kernel.</b> Interestingly, the NGMM <b>kernel</b> has another interpretation [...] - it is the ``asymmetrically transformed'' version of the GInt <b>kernel,</b> based on the idea of ``asymmetric hashing''. Just like the GMM <b>kernel,</b> the NGMM <b>kernel</b> can be efficiently linearized through (e. g.,) generalized consistent weighted sampling (GCWS), as empirically validated in our study. Owing to the discrete nature of hashed values, it also provides a scheme for approximate near neighbor search...|$|R
40|$|Support vector machine (SVM) {{is one of}} {{the popular}} machine {{learning}} techniques used in various text processing tasks including named entity recognition (NER). The performance of the SVM classifier largely depends on the appropriateness of the <b>kernel</b> function. In the last few years a number of task-specific <b>kernel</b> functions have been proposed and used in various text processing tasks, for example, string <b>kernel,</b> graph <b>kernel,</b> tree <b>kernel</b> and so on. So far very few efforts have been devoted to the development of NER task specific <b>kernel.</b> In the literature we found that the tree <b>kernel</b> has been used in NER task only for entity boundary detection or reannotation. The conventional tree <b>kernel</b> is unable to execute the complete NER task on its own. In this paper we have proposed a <b>kernel</b> function, motivated by the tree <b>kernel,</b> which is able to perform the complete NER task. To examine the effectiveness of the proposed <b>kernel,</b> we have applied the <b>kernel</b> function on the openly available JNLPBA 2004 data. Our <b>kernel</b> executes the complete NER task and achieves reasonable accuracy...|$|R
25|$|Most micro <b>kernels</b> use {{a message}} passing system {{of some sort}} to handle {{requests}} from one server to another. The message passing system generally operates on a port basis with the microkernel. As an example, if a request for more memory is sent, a port is opened with the microkernel and the request sent through. Once within the microkernel, the steps are similar to system calls. The rationale {{was that it would}} bring modularity in the system architecture, which would entail a cleaner system, easier to debug or dynamically modify, customizable to users' needs, and more performing. They are part of the operating systems like AIX, BeOS, Hurd, Mach, macOS, MINIX, QNX. Etc. Although micro <b>kernels</b> are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic <b>kernels.</b> Advocates of monolithic <b>kernels</b> also point out that the two-tiered structure of microkernel systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of <b>kernels</b> normally provide only the minimal services such as defining memory address spaces, Inter-process communication (IPC) and the process management. The other functions such as running the hardware processes are not handled directly by micro <b>kernels.</b> Proponents of micro <b>kernels</b> point out those monolithic <b>kernels</b> have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a microkernel, if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error.|$|E
25|$|Raw, yellow, sweet maize <b>kernels</b> are {{composed}} of 76% water, 19% carbohydrates, 3% protein, and 1% fat (table). In a 100-gram serving, maize <b>kernels</b> provide 86 calories and are a good source (10-19% of the Daily Value) of the B vitamins, thiamin, niacin, pantothenic acid (B5) and folate (right table for raw, uncooked <b>kernels,</b> USDA Nutrient Database). In moderate amounts, they also supply dietary fiber and the essential minerals, magnesium and phosphorus whereas other nutrients are in low amounts (table).|$|E
25|$|While {{monolithic}} <b>kernels</b> execute all {{of their}} code in the same address space (kernel space) microkernels try to run most of their services in user space, aiming to improve maintainability and modularity of the codebase. Most <b>kernels</b> do not fit exactly {{into one of these}} categories, but are rather found in between these two designs. These are called hybrid <b>kernels.</b> More exotic designs such as nanokernels and exokernels are available, but are seldom used for production systems. The Xen hypervisor, for example, is an exokernel.|$|E
5000|$|The <b>kernel</b> {{function}} [...] {{chosen for}} point set registration is typically symmetric and non-negative <b>kernel,</b> {{similar to the}} ones used in the Parzen window density estimation. The Gaussian <b>kernel</b> typically used for its simplicity, although other ones like the Epanechnikov <b>kernel</b> and the tricube <b>kernel</b> may be substituted. The <b>kernel</b> correlation of an entire point set [...] is defined as the sum of the <b>kernel</b> correlations of every point in the set to every other point in the set: ...|$|R
40|$|AbstractSoftware based Memory {{acquisition}} {{on modern}} systems typically requires {{the insertion of}} a <b>kernel</b> module into the running <b>kernel.</b> On Linux, <b>kernel</b> modules must be compiled against the exact version of <b>kernel</b> headers and the exact <b>kernel</b> configuration used to build the currently executing <b>kernel.</b> This makes Linux memory acquisition significantly more complex in practice, than on other platforms due {{to the number of}} variations of <b>kernel</b> versions and configurations, especially when responding to incidents. The Linux <b>kernel</b> maintains a checksum of <b>kernel</b> version and will generally refuse to load a module which was compiled against a different <b>kernel</b> version. Although there are some techniques to override this check, there is an inherent danger leading to an unstable <b>kernel</b> and possible <b>kernel</b> crashes. This paper presents a novel technique to safely load a pre-compiled <b>kernel</b> module for acquisition {{on a wide range of}} Linux <b>kernel</b> versions and configuration. Our technique injects a minimal acquisition module (parasite) into another valid <b>kernel</b> module (host) already found on the target system. The resulting combined module is then relinked in such a way as to grant code execution and control over vital data structures to the acquisition code, whilst the host module remains dormant during runtime...|$|R
40|$|Abstract. <b>Kernel</b> {{rootkits}} {{are considered}} one of the most dangerous forms of malware because they reside inside the <b>kernel</b> and can perform the most privileged operations on the compromised machine. Most existing <b>kernel</b> rootkit detection techniques attempt to detect the existence of <b>kernel</b> rootkits, but cannot do much about removing them, other than booting the victim machine from a clean operating system image and configuration. This paper describes the design, implementation and evaluation of a <b>kernel</b> rootkit identification system for the Windows platform called Limbo, which prevents <b>kernel</b> rootkits from entering the <b>kernel</b> by checking the legitimacy of every <b>kernel</b> driver before it is loaded into the operating system. Limbo determines whether a <b>kernel</b> driver is a <b>kernel</b> rootkit based on its binary contents and run-time behavior. To expose the execution behavior of a <b>kernel</b> driver under test, Limbo features a forced sampled execution approach to traverse the driver’s control flow graph. Through a comprehensive characterization study of current <b>kernel</b> rootkits, we derive a set of run-time features that can best distinguish between legitimate and malicious <b>kernel</b> drivers. Applying a Naive Bayes classification algorithm on this chosen feature set, the first Limbo prototype is able to achieve 96. 2 % accuracy for a test set of 754 <b>kernel</b> drivers, 311 of which are <b>kernel</b> rootkits...|$|R
