95|138|Public
5000|$|... a <b>declarative</b> <b>representation</b> {{language}} {{influenced by}} ideas from knowledge representation World Wide Web Consortium ...|$|E
5000|$|A closed source {{web service}} hosted by Google {{converts}} SWF to an intermediate representation serialized as JSON. This representation is in turn converted into SVG {{in the web}} browser via JavaScript, which is also used for animations. The Swiffy thesis (2012) explains its general approach in the following way: The choice of SVG for rendering leaves us with several options to animate the SVG content. At first sight, both CSS animation and SMIL, adhere to our design goal of using a <b>declarative</b> <b>representation</b> when possible. However, both technologies provide insufficient control over the animation when support for ActionScript scripting is required. For example, although the concept of keyframes exists in CSS animation, it {{does not provide a}} mechanism to synchronise the JavaScript code to those keyframes or to modify the timeline from JavaScript, which is a basic feature required for SWF compatibility. Another limiting factor is that animation in the SWF file itself is not defined in terms of high-level transitions, but defines the position of every object at specific keyframes. Mapping these definitions back onto CSS or SMIL transitions is not always possible. Finally, these standards are not widely available: The CSS animation specification is still in working draft state, while SMIL is not implemented in the Internet Explorer browser. We have therefore chosen to use JavaScript to animate SVG on the client. Although this imperative approach might be less efficient, the level of control it provides is required to match all SWF functionality.|$|E
40|$|This work {{shows that}} intercepting a {{low-level}} graphics library com-mand stream and reconstructing a <b>declarative</b> <b>representation</b> is prac-tical and useful, especially for exploring new rendering styles. We show {{not only how}} the basic mechanics of intercepting an OpenGL command stream lead to a non-invasive extension mechanism for graphics applications, but also how simply manipulating the stream severely limits the kinds of effects we can consider. We describe how our system efciently reconstructs a <b>declarative</b> <b>representation</b> of the geometry implicit in the graphics library command stream. We present a set of application extensions built with this frame-work, including several stylized renderers. Extensions built using our system are capable of changing the rendering style of applica-tions on the y at interactive rates...|$|E
40|$|In a {{rational}} programming language, a program specifes a situation encountered by an agent; evaluating the program amounts to computing what {{a rational}} agent would believe or {{do in the}} situation. Rational programming combines the advantages of <b>declarative</b> <b>representations</b> with features of programming languages suc...|$|R
40|$|The highly {{automated}} {{configuration of}} large scale computing fabrics increasingly exploits <b>declarative</b> <b>representations</b> of the fabric's intended state. We examine three languages for expressing these representations: LCFG, Pan and SmartFrog. We give examples of their use and examine which language properties {{are of particular}} relevance to the configuration of grid computing fabrics...|$|R
25|$|Logic {{programming}} {{in its present}} form {{can be traced back to}} debates in the late 1960s and early 1970s about <b>declarative</b> versus procedural <b>representations</b> of knowledge in Artificial Intelligence. Advocates of <b>declarative</b> <b>representations</b> were notably working at Stanford, associated with John McCarthy, Bertram Raphael and Cordell Green, and in Edinburgh, with John Alan Robinson (an academic visitor from Syracuse University), Pat Hayes, and Robert Kowalski. Advocates of procedural representations were mainly centered at MIT, under the leadership of Marvin Minsky and Seymour Papert.|$|R
40|$|This {{extended}} abstract {{presents a}} logic, called Lp, that {{is capable of}} representing and reasoning {{with a wide variety of}} both qualitative and quantitative statistical information. The advantage of this logical formalism is that it offers a <b>declarative</b> <b>representation</b> of statistical knowledge; knowledge represented in this manner can be used for a variety o...|$|E
40|$|DATR is a <b>declarative</b> <b>representation</b> {{language}} for lexical information and as such, in principle, neutral {{with respect to}} particular processing strategies. Previous DATR compiler/interpreter systems support only one access strategy that closely resembles the set of inference rules of the procedural semantics of DATR (Evans & Gazdar 1989 a). In this paper we present an alternative access strategy (reverse query strategy) for a non-trivial subset of DATR. Comment: PostScript, 7 page...|$|E
40|$|Abstract. Using ontologies in {{software}} applications is a challenging task {{due to the}} chasm between the logics-based world of ontologies and the object-oriented world of software applications. The logics-based repre-sentation emphasizes the meaning of concepts and properties, i. e., their semantics. The modeler in the object-oriented paradigm also {{takes into account the}} pragmatics, i. e., how the classes are used, by whom, and why. To enable a comprehensive use of logics-based representations in object-oriented software systems, a seamless integration of the two paradigms is needed. However, the pragmatic issues of using logic-based knowledge in object-oriented software applications has yet not been considered suffi-ciently. Rather, the pragmatic issues that arise in using an ontology, e. g., which classes to instantiate in which order, remains a task to be care-fully considered by the application developer. In this paper, we present a <b>declarative</b> <b>representation</b> for designing and applying programming ac-cess to ontologies. Based on this <b>declarative</b> <b>representation,</b> we have build OntoMDE, a model-driven engineering toolkit that we have applied to several example ontologies with different Characteristics. ...|$|E
40|$|In {{order to}} learn effectively, a reasoner must not only possess {{knowledge}} about the world {{and be able to}} improve that knowledge, but it also must introspectively reason about how it performs a given task and what particular pieces of knowledge it needs to improve its performance at the current task. Introspection requires <b>declarative</b> <b>representations</b> of meta-knowledge of the reasoning performed by the system during the performance task, of the system's knowledge, and of the organization of this knowledge. This chapter presents a taxonomy of possible reasoning failures that can occur during a performance task, <b>declarative</b> <b>representations</b> of these failures, and associations between failures and particular learning strategies. The theory is based on Meta-XPs, which are explanation structures that help the system identify failure types, formulate learning goals, and choose appropriate learning strategies in order to avoid similar mistakes in the future. The theory is implemented in a comput [...] ...|$|R
40|$|Search and <b>declarative</b> <b>representations</b> {{are two of}} {{the most}} {{important}} themes in AI research. Many problems in AI require search for their solution, and <b>declarative</b> <b>representations</b> of the knowledge required to solve these problems offer many advantages. In this paper we show how these two themes can be combined. In particular, we show how a general search engine can be designed that is based on the most familiar declarative representation: first order logic. The system can be used to solve both search problems and optimization problems, e. g., job-shop scheduling, as well as problems traditionally viewed as being planning problems, e. g., simple logistics planning. The system is based entirely on the idea of evaluating firstorder formulas against finite (or computable) models. We show that formula evaluation can be used to perform arbitrary computations, to expand an implicitly defined search space, to compute heuristics, and even provide sophisticated control over the search engine. The e [...] ...|$|R
40|$|Many {{knowledge}} representation tasks involve trees or similar structures as abstract datatypes. However, devising compact and efficient <b>declarative</b> <b>representations</b> of such properties is non-obvious {{and can be}} challenging indeed. In this paper, we take acyclicity properties into consideration and investi-gate logic-based approaches to encode them. We use answer set programming as the primary representation language but also consider mappings to related formalisms, such as propo-sitional logic, difference logic, and linear programming...|$|R
40|$|Abstract. We present gclc/Wingclc — a {{tool for}} {{visualizing}} geometrical (and not only geometrical) objects and notions, for teaching/studying mathematics, and for producing mathematical illustrations of high quality. gclc uses a language gc for <b>declarative</b> <b>representation</b> of figures and for storing mathematical contents of visual nature in textual form. In gclc, there is a build-in geometrical theorem prover which directly links visual and semantical geometrical information with deductive properties and machine–generated proofs. ...|$|E
40|$|This paper {{describes}} a computational approach to robust human-computer interaction. The approach relies on an explicit, <b>declarative</b> <b>representation</b> {{of the content}} {{and structure of the}} interaction that a computer system builds {{over the course of the}} interaction. In this paper, we will show how this representation allows the system to recognize and repair mis-understandings between the human and the computer. We demonstrate the utility of the representations by showing how they facilitate the repair process. 1...|$|E
40|$|The Remote Maintenance Monitoring System (RMMS) {{provides}} automated {{support for}} the maintenance and repair of ModComp computer systems used in the Launch Processing System (LPS) at Kennedy Space Center. RMMS supports manual and automated diagnosis of intermittent hardware failures, providing an efficient means for accessing and analyzing the data generated by catastrophic failure recovery procedures. This paper describes the design and functionality of the user interface for interactive analysis of memory dump data, relating it to the underlying <b>declarative</b> <b>representation</b> of memory dumps...|$|E
40|$|The {{problem of}} {{modeling}} human understanding and generation {{of a coherent}} dialog is investigated by simulating a conversation participant. The rule-based system currently under development attempts to capture the intuitive concept of "topic" using data structures consisting of <b>declarative</b> <b>representations</b> of the subjects under discussion linked to the utterances and rules that generated them. Scripts, goal trees, and a semantic network are brought to bear by general, domain-independent conversational rules to understand and generate coherent topic transitions and specific output utterances...|$|R
40|$|Abstract. Many {{knowledge}} representation tasks involve trees or similar struc-tures as abstract datatypes. However, devising compact and efficient <b>declarative</b> <b>representations</b> of such structural properties is non-obvious {{and can be}} challeng-ing indeed. In this paper, we take a number of acyclicity properties into consid-eration and investigate various logic-based approaches to encode them. We use answer set programming as the primary representation language but also consider mappings to related formalisms, such as propositional logic, difference logic, and linear programming. We study the compactness of encodings and the resulting computational performance on benchmarks involving acyclic or tree structures. ...|$|R
40|$|In this paper, {{we explore}} {{the use of}} Linear Logic {{programming}} for story generation. We use the language Celf to represent narrative knowledge, and its own querying mechanism to generate story instances, {{through a number of}} proof terms. Each proof term obtained is used, through a resource-flow analysis, to build a directed graph where nodes are narrative actions and edges represent inferred causality relationships. Such graphs represent narrative plots structured by narrative causality. This approach is a candidate technique for narrative generation which unifies <b>declarative</b> <b>representations</b> and generation via query and deduction mechanisms...|$|R
40|$|Mixed-initiative {{systems are}} a popular {{approach}} to building intelligent systems that can collaborate naturally and effectively with people. But true collaborative behavior requires an agent {{to possess a}} number of capabilities, including reasoning, communication, planning, execution, and learning. We describe an integrated approach to the design and implementation of a collaborative problem solving assistant based on a formal theory of joint activity and a <b>declarative</b> <b>representation</b> of tasks. This approach builds on prior work by us and by others on mixed-initiative dialogue and planning systems...|$|E
40|$|Abstract. We propose {{an access}} control model that generalizes Role-Based Access Control {{by making a}} {{distinction}} between what we call ascribed status and action status. The model {{is based upon the}} key notion of an event to enable changes in access control requirements to be performed autonomously. Our access control model is specified as a term rewriting system that permits <b>declarative</b> <b>representation</b> of access control requirements, proving of properties of access control policies defined in terms of our model, and fast prototyping of access control checking. ...|$|E
40|$|We {{formulate}} an algebra of binary temporal {{relations between}} events {{the number of}} occurrences of which isunknown, but which areknown to recur in time. Ontologically, we view the temporal domain of recurring events {{as a set of}} (convex) intervals of unknown cardinality. Thus, an explicit, <b>declarative</b> <b>representation</b> of time adequate to solve reasoning problems involving recurring events indicates a form of higher-order reasoning about relations between collections, or sequences of intervals. The relations de ned here are each formed out of convex interval relations by applyin...|$|E
5000|$|The {{necessity}} of accounting for brain localization {{pushed for a}} major revision of the theory. ACT-R 5.0 introduced the concept of modules, specialized sets of procedural and <b>declarative</b> <b>representations</b> that could be mapped to known brain systems. [...] In addition, the interaction between procedural and declarative knowledge was mediated by newly introduced buffers, specialized structures for holding temporarily active information (see the section above). Buffers were thought to reflect cortical activity, and a subsequent series of studies later confirmed that activations in cortical regions could be successfully related to computational operations over buffers.|$|R
40|$|The article {{investigates the}} {{relation}} between declarative and procedural working memory (WM; Oberauer, 2009). Two experiments test the assumption that representations in the two subsystems are selected for processing in analogous ways. Participants carried {{out a series of}} decisions on memorized lists of digits. For each decision, they had to select <b>declarative</b> and procedural <b>representations.</b> Regarding <b>declarative</b> <b>representations,</b> participants selected a memory set and a digit within this set as the input to each decision. With respect to the procedural representations, they selected a task set to be applied to the selected digit and a response within that task set. We independently manipulated the number of lists and the number of tasks to be switched among (one, two, or three; Experiment 1) and preparation time for a list switch (Experiment 2). For three effects commonly observed in task-switch studies, analogues in declarative WM were found: list-switch costs, mixing costs, and residual switch costs. List- and task-switch costs were underadditive, suggesting that <b>declarative</b> and procedural <b>representations</b> are selected separately and in parallel. The findings support the hypothesis of two analogous WM subsystems...|$|R
40|$|We {{investigate}} interference between <b>declarative</b> {{and procedural}} <b>representations</b> in working memory (WM). <b>Declarative</b> <b>representations</b> are objects of thought, whereas procedural representations provide the (cognitive) actions to work upon these objects. In eight dual-task experiments we varied {{the number of}} representations to be maintained in WM (memory load). In Experiments 1 – 4, we varied declarative and procedural load separately in the two tasks used. In Experiments 5 – 8, only declarative or procedural load was manipulated in both tasks employed. We measured how much performance in the currently relevant task was impaired by increasing the load in the currently irrelevant task. These cross-task load effects were larger for Experiment 5 – 8 compared to Experiment 1 – 4. Yet, in task-switch trials we also obtained cross-task load effects in Experiment 1 – 4. Our findings support the distinction of declarative and procedural WM as largely independent sub-systems or distinct representational spaces...|$|R
40|$|We present (ML) 2, {{a formal}} {{language}} for {{the representation of}} KADS models of expertise. (ML) 2 {{is a combination of}} first order predicate logic (for the <b>declarative</b> <b>representation</b> of domain knowledge), meta-logic (for the representation of how to use the domain knowledge) and dynamic logic (for the representation of control information). After a brief summary of KADS, we describe how each of the four KADS layers is represented in (ML) 2, and we compare our formalism to other formalisms that have been proposed for the formalisation of KADS models...|$|E
40|$|In {{this paper}} I {{will present a}} {{detailed}} ACT-R model of how the task-specific knowledge for a new, complex task is learned. The model is capable of acquiring its knowledge through experience, using a <b>declarative</b> <b>representation</b> that is gradually compiled into a procedural representation. The model exhibits several characteristics that concur with Fitts theory of skill learning, {{and can be used}} to show that individual differences in working memory capacity initially have a large impact on performance, but that this impact diminished after sufficient experience. Some preliminary experimental data support these findings...|$|E
40|$|Web service {{specifications}} {{can be quite}} complex, including various operations and message exchange patterns. In this work, we give a rule-based <b>declarative</b> <b>representation</b> of services, and in particular of WSDL operations, that enables the application of techniques for reasoning about actions and change, that are typical of agent systems. This {{makes it possible to}} reason on a rule-based specification of choreography roles and about the selection of possible role players on a goal-driven basis, and allows us to attack the problem of the joint achievement of individual goals for a set of services which animate a choreography...|$|E
40|$|Planning {{programs}} are loose, high-level, <b>declarative</b> <b>representations</b> {{of the behavior}} of agents acting in a domain and following a path of goals to achieve. Such {{programs are}} specified through transition systems that can include cycles and decisions to make at certain points. We investigate a new effective approach for solving the problem of realizing a planning program, i. e., informally, for finding and combining a collection of plans that guarantee the planning program executability. We focus on deterministic domains and propose a general algorithm that solves the problem exploiting a planning technique handling goal constraints and preferences. A preliminary experimental analysis indicates that our approach dramatically outperforms the existing method based on formal verification and synthesis techniques...|$|R
40|$|The {{compilation}} of RELFUN programs {{consists of two}} main stages, horizontal transformations and vertical translations. The horizontal transformer performs both source-to-source steps into a subset of RELFUN and source-to-intermediate steps into a RELFUN-like language. The vertical translator is also divided into two phases, the classifier and the code generator. The classifier produces a declarative clause language; the code generator optimizes target code for underlying WAM emulators. These parts can be used incrementally-individually, as a relational/functional compilation laboratory, or batch-composed, as a complete RELFUN compiler. All intermediate steps employ explicit <b>declarative</b> <b>representations,</b> which can be displayed via RELFUN's user interface. The compiler is implemented in a subset of COMMON LISP; one emulator runs in COMMON LISP, the other in ANSI C. 2 CONTENTS Contents...|$|R
40|$|IDP 3 is a knowledge-base system, {{offering}} a rich, <b>declarative</b> knowledge <b>representation</b> language, {{a range of}} inferences and built-in interaction with a procedural language. In this paper, we give {{an overview of the}} system and show how multiple inferences are combined to obtain state-of-the-art model generation. status: publishe...|$|R
40|$|Abstract-This paper {{explores the}} {{specification}} and semantics of multiagent problem-solving systems, {{focusing on the}} represen-tations that agents have of each other. It provides a <b>declarative</b> <b>representation</b> for such systems. Several procedural solutions to a well-known test-bed problem are considered, and the re-quirements they impose on different agents are identified. A study of these requirements yields a representational scheme based on temporal logic for specifying the acting, perceiving, communicating, and reasoning abilities of computational agents. A formal semantics is provided for this scheme. The resulting representation is highly declarative, and useful for describing systems of agents solving problems reactively...|$|E
40|$|Recently, Gelfond and Lifschitz {{presented}} a formal language for representing incomplete knowledge on actions and states, and a sound translation from this language to extended logic programming. We present an alternative translation to abductive logic programming with integrity constraints and prove the soundness and completeness. In addition, we show how an abductive procedure can be used, {{not only for}} explanation, but also for deduction and proving satisfiability under uncertainty. From a more general perspective, this work {{can be viewed as}} a -successful- experiment in the <b>declarative</b> <b>representation</b> of and automated reasoning on incomplete knowledge using abductive logic programming...|$|E
40|$|This {{paper is}} a {{critical}} evaluation of an approach to control in natural language processing systems which makes use of canonical structures {{as a way of}} collapsing multiple analyses in individual components. We give an overview here of how the Lucy natural language interface system currently realizes this control model and then evaluate what we take to be {{the strengths and weaknesses of}} such an approach. In particular, we conclude that the use of canonical structures can restrain combinatorial explosion in the search, but at the cost of breaking down the barriers between modules and of letting processing concerns infect the <b>declarative</b> <b>representation</b> of information...|$|E
40|$|We {{present an}} {{approach}} to knowledge compilation that transforms a function-free first-order Horn knowledge base to propositional logic. This form of compilation is important since the most efficient reasoning methods are defined for propositional logic, while knowledge is most conveniently expressed within a first-order language. To obtain compact propositional representations, we employ techniques from (ir) relevance reasoning as well as theory transformation via unfold/fold transformations. Application areas include diagnosis, planning, and vision. Preliminary experiments with a hypothetical reasoner indicate that our method may yield significant speedups. This paper is an improved and significantly extended version of Prendinger and Ishizuka [22]. 1 1 Introduction The need for knowledge base (KB) reformation derives from two facts about <b>declarative</b> <b>representations</b> of knowledge. First, representations are designed for variety of queries; hence, they will likely contain in [...] ...|$|R
40|$|Most game {{behavior}} is written using scripts instead of rules. Rules are <b>declarative</b> <b>representations</b> that, given {{variables in the}} game, encode relationships and facts about the game. From these facts one can reason about truth in the game world. Scripts are imperative representations: they provide a set of instructions {{that are used to}} process game variables and compute some conclusion. Scripting is more intuitive for game designers and developers to work with. It is easier to conceptualize and write a script that says: "go right, go left, turn around twice, go straight, then fire your gun [...] . " then it is to formulate a set of rules that could shape an entities movement to the same effect. While scripting allows developers to construct sophisticated behaviors, typically these behaviors are brittle outside of th...|$|R
40|$|Abstract. In this paper, {{we explore}} {{the use of}} Linear Logic {{programming}} for story generation. We use the language Celf to represent narrative knowledge, and its own querying mechanism to generate story instances, {{through a number of}} proof terms. Each proof term obtained is used, through a resource-flow analysis, to build a directed graph where nodes are narrative actions and edges represent inferred causality relationships. Such graphs represent narrative plots structured by narrative causality. Building on previous work evidencing the suitability of Linear Logic as a conceptual model of action and change for narratives, we explore the conditions under which these representations can be operationalized through Linear Logic Programming techniques. This approach is a candidate technique for narrative generation which unifies <b>declarative</b> <b>representations</b> and generation via query and deduction mechanisms...|$|R
