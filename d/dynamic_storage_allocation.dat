78|710|Public
25|$|In principle, the Life {{field is}} infinite, but {{computers}} have finite memory. This leads to problems when the active area encroaches {{on the border}} of the array. Programmers have used several strategies to address these problems. The simplest strategy is simply to assume that every cell outside the array is dead. This is easy to program, but leads to inaccurate results when the active area crosses the boundary. A more sophisticated trick is to consider the left and right edges of the field to be stitched together, and the top and bottom edges also, yielding a toroidal array. The result is that active areas that move across a field edge reappear at the opposite edge. Inaccuracy can still result if the pattern grows too large, but at least there are no pathological edge effects. Techniques of <b>dynamic</b> <b>storage</b> <b>allocation</b> may also be used, creating ever-larger arrays to hold growing patterns.|$|E
5000|$|The PL/I D compiler, using 16 {{kilobytes}} of memory, {{was developed}} by IBM Germany for the DOS/360 low end operating system. It implements {{a subset of the}} PL/I language requiring all strings and arrays to have fixed extents, thus simplifying the run-time environment. Reflecting the underlying operating system, it lacks <b>dynamic</b> <b>storage</b> <b>allocation</b> and the controlled storage class. [...] It was shipped within a year of PL/I F.|$|E
50|$|Unlike the {{database}} where global variable nodes must fit {{within a database}} block, local variable strings can grow to 1MB. The GT.M run-time provides <b>dynamic</b> <b>storage</b> <b>allocation</b> with garbage collection. The number of local variables {{and the number of}} nodes in local variables are limited only by storage available to the process. The default scope of a local variable is the lifetime of a process. Local variables created within routines using the New command have more limited scope.|$|E
40|$|In {{computer}} information systems, {{some programs}} are used {{more frequently than}} others producing skewed distributions of program usages. We investigate the claim that static views of program usage frequencies are insufficient when they are used for <b>storage</b> <b>allocation</b> decisions making it necessary to study {{the implications of the}} use of <b>dynamic</b> frequencies in <b>storage</b> <b>allocation.</b> The use of dynamic frequencies provides a natural extension to previously presented static cost model literature for hierarchical <b>storage</b> <b>allocation.</b> In our work, we present the value of incorporating dynamic usage frequencies into program usage cost models. Thus, an optimization-based cost modeling methodology using Simon's Model for <b>dynamic</b> hierarchical <b>storage</b> <b>allocation</b> is presented. To illustrate, a simple example of program <b>storage</b> <b>allocation</b> is presented in both static and dynamic form. Cost-saving comparisons are then discussed...|$|R
40|$|In this paper, {{we address}} the problem of <b>dynamic</b> <b>allocation</b> of <b>storage</b> {{bandwidth}} to application classes so as to meet their response time requirements. We present an approach based on reinforcement learning to address this problem. We argue that a simple learning-based approach may not be practical since it incurs significant memory and search space overheads. To address this issue, we use application-specific knowledge to design an efficient, practical learning-based technique for <b>dynamic</b> <b>storage</b> bandwidth <b>allocation.</b> Our approach can react to dynamically changing workloads, provide isolation to application classes and is stable under overload. We implement our techniques into the Linux kernel and evaluate it using prototype experimentation and trace-driven simulations. Our results show that (i) the use of learning enables the storage system to {{to reduce the number of}} QoS violations by a factor of 2. 1 and (ii) the implementation overheads of employing such techniques in operating system kernels is small...|$|R
40|$|Dynamic Spectrum Access systems exploit {{temporarily}} available spectrum (`white spaces') and {{can spread}} transmissions {{over a number}} of non-contiguous sub-channels. Such methods are highly beneficial in terms of spectrum utilization. However, excessive fragmentation degrades performance and hence off-sets the benefits. Thus, {{there is a need to}} study these processes so as to determine how to ensure acceptable levels of fragmentation. Hence, we present experimental and analytical results derived from a mathematical model. We model a system operating at capacity serving requests for bandwidth by assigning a collection of gaps (sub-channels) with no limitations on the fragment size. Our main theoretical result shows that even if fragments can be arbitrarily small, the system does not degrade with time. Namely, the average total number of fragments remains bounded. Within the very difficult class of dynamic fragmentation models (including models of storage fragmentation), this result appears to be the first of its kind. Extensive experimental results describe behavior, at times unexpected, of fragmentation under different algorithms. Our model also applies to <b>dynamic</b> linked-list <b>storage</b> <b>allocation,</b> and provides a novel analysis in that domain. We prove that, interestingly, the 50 % rule of the classical (non-fragmented) allocation model carries over to our model. Overall, the paper provides insights into the potential behavior of practical fragmentation algorithms...|$|R
5000|$|Uniquely, the {{object-oriented}} paradigm involves {{dynamic memory}} allocation from heap storage for both object creation and message passing. A 1994 benchmark - [...] "Memory Allocation Costs in Large C and C++ Programs" [...] conducted by Digital Equipment Corporation {{on a variety}} of software, using an instruction-level profiling tool, measured how many instructions were required per <b>dynamic</b> <b>storage</b> <b>allocation.</b> The results showed that the lowest absolute number of instructions executed averaged around 50 but others reached as high as 611. See also [...] "Heap:Pleasures and pains" [...] by Murali R. Krishnan that states [...] "Heap implementations tend to stay general for all platforms, and hence have heavy overhead". The 1996 IBM paper [...] "Scalability of <b>Dynamic</b> <b>Storage</b> <b>Allocation</b> Algorithms" [...] by Arun Iyengar of IBM [...] demonstrates various dynamic storage algorithms and their respective instruction counts. Even the recommended MFLF I algorithm (H.S. Stone, RC 9674) shows instruction counts in a range between 200 and 400. The above pseudocode example does not include a realistic estimate of this memory allocation pathlength or the memory prefix overheads involved and the subsequent associated garbage collection overheads. Suggesting strongly that heap allocation is a nontrivial task, one open-source software microallocator, by game developer John W. Ratcliff, consists of nearly 1,000 lines of code.|$|E
50|$|Coral 66 is a {{general-purpose}} {{programming language}} based on ALGOL 60, with some features from Coral 64, JOVIAL, and FORTRAN. It includes structured record types (as in Pascal) and supports the packing of data into limited storage (also as in Pascal). Like Edinburgh IMP it allows embedded assembler, and also offers good run-time checking and diagnostics. It is specifically intended for real-time and embedded applications and {{for use on}} computers with limited processing power, including those limited to fixed point arithmetic and those without support for <b>dynamic</b> <b>storage</b> <b>allocation.</b>|$|E
50|$|In principle, the Life {{field is}} infinite, but {{computers}} have finite memory. This leads to problems when the active area encroaches {{on the border}} of the array. Programmers have used several strategies to address these problems. The simplest strategy is simply to assume that every cell outside the array is dead. This is easy to program, but leads to inaccurate results when the active area crosses the boundary. A more sophisticated trick is to consider the left and right edges of the field to be stitched together, and the top and bottom edges also, yielding a toroidal array. The result is that active areas that move across a field edge reappear at the opposite edge. Inaccuracy can still result if the pattern grows too large, but at least there are no pathological edge effects. Techniques of <b>dynamic</b> <b>storage</b> <b>allocation</b> may also be used, creating ever-larger arrays to hold growing patterns.|$|E
40|$|This paper {{describes}} {{ways that}} <b>storage</b> <b>allocation</b> optimization, though “correct”, can convert a running program into one that fails. A general “safety condition” is proposed {{and applied to}} some existing and proposed <b>storage</b> <b>allocation</b> optimizations. These are shown to be unsafe or not general. Application of the safety condition yields several classes of <b>storage</b> <b>allocations</b> that may safely be optimized to stack allocations. For one useful class of allocations optimization is shown to be NP-complete. Safety considerations for <b>storage</b> <b>allocation</b> optimizations...|$|R
5000|$|Support for {{multiple}} volume groups for optimal <b>storage</b> <b>allocation</b> ...|$|R
40|$|An Inverted file is a {{commonly}} used index for both archival databases and free text where no updates are expected. Applications like information filtering and dynamic environments like the Internet require inverted files to be updated efficiently. Recently, extensible inverted files are proposed {{which can be}} used for fast online indexing. The effective <b>storage</b> <b>allocation</b> scheme for such inverted files uses the arrival rate to preallocate storage. In this article, this <b>storage</b> <b>allocation</b> scheme is improved by using information about both the arrival rates and their variability to predict the storage needed, as well as scaling the <b>storage</b> <b>allocation</b> by a logarithmic factor. The resultant, final storage utilization rate can be as high as 97 - 98 % after indexing about 1. 6 million documents. This compares favorably with the storage utilization rate of the original arrival rate <b>storage</b> <b>allocation</b> scheme. Our evaluation shows that the retrieval time for extensible inverted file on solid state disk is on average similar to the retrieval time for in-memory extensible inverted file. When file seek time is not an issue, our scalable <b>storage</b> <b>allocation</b> enables extensible inverted files to be used as the main index on disk. Our statistical <b>storage</b> <b>allocation</b> may be applicable to novel situations where the arrival of items follows a binomial, Poisson or normal distribution. Department of Computin...|$|R
40|$|<b>Dynamic</b> <b>storage</b> <b>allocation</b> is an {{important}} part of a large class of computer programs written in C and C��. High-performance algorithms for <b>dynamic</b> <b>storage</b> <b>allocation</b> have been, and will continue to be, of considerable interest. This paper presents detailed measurements of the cost of <b>dynamic</b> <b>storage</b> <b>allocation</b> in 11 diverse C and C� � programs using five very different <b>dynamic</b> <b>storage</b> <b>allocation</b> implementations, including a conservative garbage collection algorithm. Four of the allocator implementations measured are publicly available on the Internet. A number of the programs used in these measurements are also available on the Internet to facilitate further research in <b>dynamic</b> <b>storage</b> <b>allocation.</b> Finally, the data presented in this paper is an abbreviated version of more extensive statistics that are also publicly available on the Internet. key words: Garbage collection <b>Dynamic</b> <b>storage</b> <b>allocation</b> Performance evaluation Conservative collection Dynamic memory managemen...|$|E
40|$|AbstractWe use {{an on-line}} {{algorithm}} for coloring interval graphs {{to construct a}} polynomial time approximation algorithm WIC for <b>Dynamic</b> <b>Storage</b> <b>Allocation.</b> The performance ratio for WIC is at most six; the best previous upper bound on the performance ratio for a polynomial time approximation algorithm for <b>Dynamic</b> <b>Storage</b> <b>Allocation</b> had been 80...|$|E
40|$|<b>Dynamic</b> <b>storage</b> <b>allocation</b> is used {{heavily in}} many {{application}} areas including interpreters, simulators, optimizers, and translators. We describe research that can improve {{all aspects of the}} performance of <b>dynamic</b> <b>storage</b> <b>allocation</b> by predicting the lifetimes of short-lived objects when they are allocated. Using five significant, allocation-intensive C programs, we show that a great fraction of all bytes allocated are short-lived (? 90 % in all cases). Furthermore, we describe an algorithm for lifetime prediction that accurately predicts the lifetimes of 42 [...] 99 % of all objects allocated. We describe and simulate a storage allocator that takes advantage of lifetime prediction of short-lived objects and show that it can significantly improve a program's memory overhead and reference locality, and even, at times, improve CPU performance as well. 1 Introduction. <b>Dynamic</b> <b>storage</b> <b>allocation</b> (DSA) is used heavily in {{many application areas}} including interpreters, simulators, optimizers, and [...] ...|$|E
50|$|Norton Zone offered 5 GB {{of storage}} {{for free and}} larger <b>storage</b> <b>allocations</b> via subscription.|$|R
40|$|Nowadays {{automation}} is a {{trend of}} container terminals all over the world. Although not applied in current automated container terminals, <b>storage</b> <b>allocation</b> is indispensable in conventional container terminals, and promising for automated container terminals in future. This paper seeks into the <b>storage</b> <b>allocation</b> problem in automated container terminals and proposed a two level structure for the problem. A mixed integer programming model is built for the upper level, and a modified Particle Swarm Optimization (PSO) algorithm is applied to solve the model. The applicable conditions of the model is investigated by numerical experiments, so as {{the performance of the}} algorithm in different problem scales. It is left to future research the lower level of the problem and the potential benefit of <b>storage</b> <b>allocation</b> to automated container terminals...|$|R
5000|$|... {{infinite}} store : The programmer is {{not responsible}} for <b>storage</b> <b>allocation</b> and can create as many data objects as needed.|$|R
40|$|We {{examine the}} problem of {{counting}} interval graphs. We answer the question posed by Hanlon, of whether the formal power series generating function {{of the number of}} interval graphs on n vertices has a positive radius of convergence. We have found that it is zero. We have obtained a lower bound and an upper bound on the number of interval graphs on n vertices. We also study the application of interval graphs to the <b>dynamic</b> <b>storage</b> <b>allocation</b> problem. <b>Dynamic</b> <b>storage</b> <b>allocation</b> {{has been shown to be}} NP-complete by Stockmeyer. Coloring interval graphs on-line has applications to <b>dynamic</b> <b>storage</b> <b>allocation.</b> The most colors used by Kierstead 2 ̆ 7 s algorithm is 3 ω - 2, where ω is the size of the largest clique in the graph. We determine a lower bound on the colors used. One such lower bound is 2 ω - 1...|$|E
40|$|<b>Dynamic</b> <b>Storage</b> <b>Allocation</b> is {{the problem}} of packing given axis-aligned {{rectangles}} into a horizontal strip of minimum height by sliding the rectangles vertically but not horizontally. Where L = LOAD is the maximum sum of heights of rectangles that intersect any vertical line and OPT is the minimum height of the enclosing strip, it is obvious that OPT LOAD; previous work showed that OPT 3 LOAD. We continue the study of the relationship between OPT and LOAD, proving that OPT = L + O((hmax=L)) L, where hmax is the maximum job height. Conversely, we prove that for any > 0, there exists a c > 0 such that for all suf- ciently large integers hmax, there is a <b>Dynamic</b> <b>Storage</b> <b>Allocation</b> instance with maximum job height hmax, maximum load at most L, and OPT L + c(hmax=L) L, for in nitely many integers L. En route, we construct several new polynomial-time approximation algorithms for <b>Dynamic</b> <b>Storage</b> <b>Allocation...</b>|$|E
40|$|<b>Dynamic</b> <b>Storage</b> <b>Allocation</b> is {{a problem}} {{concerned}} with storing items that each have weight and time restrictions. Approximate algorithms have been constructed through online coloring of interval graphs. We present a general-ization that uses online coloring of tolerance graphs. We utilize online-with-representation algorithms on tolerance graphs, which are online algorithms in which the corresponding tolerance representation of a vertex is also presented. We find linear bounds for the online-with-representation chromatic number of various classes of tolerance graphs and apply these results to a generalization of <b>Dynamic</b> <b>Storage</b> <b>Allocation,</b> giving us a polynomial time approximation algorithm with linear performance ratio...|$|E
40|$|Practical and {{theoretical}} {{results have been}} found concerning the use of global <b>storage</b> <b>allocation</b> for the instances of applied occurrences of an attribute. The practical results focus on the necessary and sufficient conditions to decide at evaluator construction time whether an evaluator can allocate the instances of an applied occurrence {{to a number of}} global variables, stackes and queues. Checking these conditions takes polynomial time for a simple multi-visit evaluator and exponential time for an absolutely non-circular evaluator. The theoretical results are concerned with the data structures that are required for the global <b>storage</b> <b>allocation</b> of the instances of applied occurrences in simple multi-X evaluators, where X € {pass, sweep, visit}. For this purpose, the general class of basic linear data structures is introduced. This class of data structures {{can also be used to}} explore the theoretical possibilities and limitations of <b>storage</b> <b>allocation</b> techniques in domains other than attribute grammars...|$|R
5000|$|<b>Dynamic</b> <b>Storage</b> Technology, which {{provides}} Novell Shadow Volumes ...|$|R
40|$|<b>Storage</b> <b>allocation</b> affects {{important}} {{performance measures}} of distributed storage systems. Most previous {{studies on the}} <b>storage</b> <b>allocation</b> consider its effect separately either {{on the success of}} the data recovery or on the service rate (time) where it is assumed that no access failure happens in the system. In this paper, we go one step further and incorporate the access model and the success of data recovery into the service rate analysis. In particular, we focus on quasi-uniform <b>storage</b> <b>allocation</b> and provide a service rate analysis for both fixed-size and probabilistic access models at the nodes. Using this analysis, we then show that for the case of exponential waiting time distribution at individuals storage nodes, minimal spreading allocation results in the highest system service rate for both access models. This means that for a given storage budget, replication provides a better service rate than a coded storage solution. Comment: This paper has been accepted for presentation in IEEE ISIT 201...|$|R
40|$|<b>Dynamic</b> <b>storage</b> <b>allocation</b> has a {{significant}} impact on computer performance. A dynamic storage allocator manages space for objects whose lifetimes are not known by the system {{at the time of their}} creation. A good dynamic storage allocator should utilize storage efficiently and satisfy requests in as few instructions as possible. A dynamic storage allocator on a multiprocessor should have the ability to satisfy multiple requests concurrently. This paper examines parallel <b>dynamic</b> <b>storage</b> <b>allocation</b> algorithms and how performancescales with increasing numbers of processors. The highest throughputs and lowest instruction counts are achieved with multiple free list fit I. The best memory utilization is achieved using a best fit system...|$|E
40|$|We empirically {{compare the}} local ratio {{algorithm}} for the profit maximization {{version of the}} <b>dynamic</b> <b>storage</b> <b>allocation</b> problem against various greedy algorithms. Our main conclusion is that, at least on our input distributions, the local ratio algorithms performed worse on average than the more naive greedy algorithms...|$|E
40|$|We analyse {{a storage}} process with {{dynamical}} arrivals and departures. Under probabilistic assumptions, we study {{the behavior of}} the storage unit and give the main features of it: the maximal throughput and the occupied length of the unit. <b>dynamic</b> <b>storage</b> <b>allocation</b> mximal throughput measure valued Markov processes...|$|E
5000|$|<b>Dynamic</b> <b>Storage</b> Technology (DST) by Novell on OES Linux Platform ...|$|R
40|$|Estimating {{the fault}} rate {{function}} Paging activity {{can be a}} major factor in determining whether a software workload will run on a given computer system. A program’s paging behavior is difficult to predict because it depends not only on the workload processed by the program, but also on the level of storage contention of the processor. A program’s fault rate function relates <b>storage</b> <b>allocation</b> to the page fault rate experienced while processing a given workload. Thus, with the workload defined, the fault rate function can be used to see how the program’s <b>storage</b> <b>allocation</b> is affected by varying levels of storage contention, represente...|$|R
40|$|This paper {{presents}} virtual allocation, {{a scheme}} for flexible <b>storage</b> <b>allocation.</b> It separates <b>storage</b> <b>allocation</b> from the file system. It employs an allocate-on-write strategy, which lets applications {{fit into the}} actual usage of storage space {{without regard to the}} configured file system size. This improves flexibility by allowing storage space to be shared across different file systems. This paper presents the design of virtual allocation and an evaluation of it through benchmarks. To illustrate our approach, we implemented a prototype system on PCs running Linux. We present the results from the prototype implementation and its evaluation. ...|$|R
40|$|STRIP COVERING. If we {{replace the}} {{covering}} constraint by apacking constraint (rectangles may not overlap, {{and the goal}} is to minimize the highest point covered), then the problem becomesidentical to <b>DYNAMIC</b> <b>STORAGE</b> <b>ALLOCATION,</b> a well-studied scheduling problem, which is in turn a restricted case of the wellknown problem STRIP PACKING...|$|E
40|$|<b>Dynamic</b> <b>storage</b> <b>allocation</b> {{continues}} {{to play an important}} role in the performance and correctness of systems ranging from user productivity software to high-performance servers. While algorithms for <b>dynamic</b> <b>storage</b> <b>allocation</b> have been studied for decades, much of the literature is based on measuring the performance of benchmark programs unrepresentative of many important allocation-intensive workloads. Furthermore, to date no standard has emerged or been proposed for publishing and exchanging representative allocation workloads. In this paper, we describe a preliminary design of a trace format for such workloads and investigate its e#ectiveness at representing large allocation traces. Our proposal allows for a flexible encoding of information in the trace to achieve greater compression. We evaluate our preliminary design in two dimensions. First, we measure how e#ective these encodings are at reducing trace size. Second we consider how a meta-level specification language could be used [...] ...|$|E
40|$|Fortran (FORmula TRANslation) was {{introduced}} in 1957 and remains the language of choice for most scientific programming. The latest standard, Fortran 90, includes extensions that are familiar to users of C. Some {{of the most important}} features of Fortran 90 include recursive subroutines, <b>dynamic</b> <b>storage</b> <b>allocation</b> and pointers, user defined data structures, modules, and the ability t...|$|E
40|$|The yard truck {{scheduling}} and the <b>storage</b> <b>allocation</b> are two important decision problems affecting {{the efficiency of}} container terminal operations. This paper proposes a novel approach that integrates these two problems into a whole. The objective is to minimize the weighted sum of total delay of requests and the total travel time of yard trucks. Due to the intractability of the proposed problem, a hybrid insertion algorithm is designed for effective problem solutions. Computational experiments are conducted to examine the key factors {{of the problem and}} the performance of the proposed heuristic algorithm. Container terminal operations Yard truck scheduling <b>Storage</b> <b>allocation</b> Heuristic algorithm...|$|R
5000|$|Version 7 extends {{support for}} {{multiple}} volumes to permit <b>Dynamic</b> <b>Storage</b> Tiering. <b>Dynamic</b> <b>Storage</b> Tiering allows root users to move files among different volumes, allocate files to different volumes at file creation time based on policy, and independently recover volumes, without altering the namespace of the file system. Version 7 {{was introduced in}} VxFS 5.0.|$|R
40|$|AbstractThis paper {{proposes a}} new <b>storage</b> <b>allocation</b> rule based on target storage curves. Joint {{operating}} rules are also proposed {{to solve the}} operation problems of a multi-reservoir system with joint demands and water transfer-supply projects. The joint operating rules include a water diversion rule to {{determine the amount of}} diverted water in a period, a hedging rule based on an aggregated reservoir to determine the total release from the system, and a <b>storage</b> <b>allocation</b> rule to specify the release from each reservoir. A simulation-optimization model was established to optimize the key points of the water diversion curves, the hedging rule curves, and the target storage curves using the improved particle swarm optimization (IPSO) algorithm. The multi-reservoir water supply system located in Liaoning Province, China, including a water transfer-supply project, was employed as a case study to verify the effectiveness of the proposed join operating rules and target storage curves. The results indicate that the proposed operating rules are suitable for the complex system. The <b>storage</b> <b>allocation</b> rule based on target storage curves shows an improved performance with regard to system storage distribution...|$|R
