0|40|Public
5000|$|<b>Indirect</b> <b>{{register}}</b> access (address register, {{data register}} in mapped memory) ...|$|R
5000|$|... 1. <b>Indirect</b> <b>{{register}}</b> - register {{is used as}} {{a memory}} address to read or write: OPR *R R contains address ...|$|R
50|$|The auto increment/decrement feature was {{improved}} {{by removing the}} control bits and adding four new <b>indirect</b> <b>registers</b> per FSR. Depending on which <b>indirect</b> file <b>register</b> is being accessed {{it is possible to}} postdecrement, postincrement, or preincrement FSR; or form the effective address by adding W to FSR.|$|R
50|$|The two {{addressing}} modes <b>Indirect</b> <b>register,</b> and <b>Indirect</b> <b>register</b> with auto-increment are then fairly efficient, to perform 8-bit operations {{on the data}} in the accumulator. There are no other {{addressing modes}}, though. Thus, the direct addressing mode needs to be emulated using the four instructions mentioned earlier to load the address into a spare register; followed by an instruction to select that register as the index register; followed, finally, by the intended operation on the data variable that is pointed to by that address.|$|R
2500|$|<b>Register</b> <b>indirect</b> with index <b>register</b> & 8-bit signed offset e.g. 8(A0, D0) or 8(A0, A1) ...|$|R
5000|$|... #Subtitle level 2: The {{notion of}} <b>indirect</b> address <b>register</b> [...] "N" ...|$|R
5000|$|The <b>indirect</b> file <b>register</b> (...) {{becomes an}} alias for the operand pointed {{to by the}} FSR.|$|R
50|$|The machine {{instructions}} can {{be grouped}} into six categories: accumulator instructions, branch instructions, memory reference instructions, address register instructions, scratchpad register instruction, miscellaneous instructions (interrupt, input, output, <b>indirect</b> scratchpad <b>register,</b> load, and store).|$|R
50|$|The ST6's {{addressing}} modes {{are limited to}} immediate, 8-bit absolute memory address, and <b>register</b> <b>indirect</b> modes (X) and (Y).|$|R
5000|$|<b>Indirect</b> then <b>register</b> (IR): Obtain the {{indirect}} {{word from the}} address specified by Y, and perform the modification requested by the tag field of {{the indirect}} word. This may result in multiple levels of indirection. Perform the address modification specified by the instruction on the last indirect word encountered.|$|R
50|$|If the offset is zero, {{this becomes}} {{an example of}} <b>register</b> <b>indirect</b> addressing; the {{effective}} address is just the value in the base register.|$|R
50|$|The {{effective}} address for a <b>Register</b> <b>indirect</b> instruction is the {{address in the}} specified register. For example, (A7) to access the content of address register A7.|$|R
50|$|The Bellmac 32 has {{different}} types of addressing, such as linear, immediate 8, 16 or 32 bits, registration, <b>register</b> <b>indirect,</b> short shift, absolute and indirect displacement of 8, 16 or 32 bits.|$|R
40|$|This report {{examines}} how the compiler can more efficiently use {{a large number}} of processor registers. The placement of data items into registers, called register allocation, is known {{to be one of the}} most important compiler optimizations for high-speed computers because registers are the fastest storage devices in the computer system. However, register allocation has been limited in scope because of aliasing in the memory system. To break this limitation and allow more data to be placed into registers, new compiler and microarchitecture support is needed. We propose the modification of register access semantics to include an indirect access mode. We call this optimization the Smart Register File. The smart register file allows the relaxation of overly-conservative assumptions in the compiler by having the hardware provide support for aliased data items in processor registers. As a result, the compiler can allocate data from a larger pool of candidates than in a conventional system. An attendant advantage is that the smart register file reduces the number of load and store operations executed by the processor. The simple addition of an <b>indirect</b> <b>register</b> acces...|$|R
50|$|Users {{could develop}} {{software}} for the HP-29C/19C, such as a prime number generator. The calculators expanded the HP-25's program capabilities by adding subroutines, increment/decrement looping, relative branching and <b>indirect</b> addressing (via <b>register</b> 0 as index).|$|R
50|$|For most {{commands}} the A, B and C address sections {{were used to}} denote actual locations in memory. There were six modes of addressing. Two were rarely used. The remainder were: Direct, Direct Special <b>Register,</b> <b>Indirect</b> Addressing and Indexed.|$|R
50|$|Generally {{the first}} 7 to 9 bytes of the {{register}} file are special-purpose registers, {{and the remaining}} bytes are general purpose RAM. Pointers are implemented using a register pair: after writing {{an address to the}} FSR (file select <b>register),</b> the INDF (<b>indirect</b> f) <b>register</b> becomes an alias for the addressed register. If banked RAM is implemented, the bank number is selected by the high 3 bits of the FSR. This affects register numbers 16-31; registers 0-15 are global and not affected by the bank select bits.|$|R
5000|$|The son of Antun Stjepan Crnković, Tomislav Nikola Crnković (1810-1880) {{settled down}} on an estate {{near the town}} of Lokve. Today, there is still a number of Crnkovićs that live in the {{vicinity}} of Lokve near Delnice. There is also a Crnković cluster in the town of Đakovo. In the early 20th century, several Crnković moved to Canada and the United States. There are direct and <b>indirect</b> descendants <b>registered</b> under [...] "Czernkovich","Crnkovich" [...] or [...] "Cinkovich" [...] in United States {{and other parts of the}} world.|$|R
50|$|In {{addition}} to real mode, the Intel 80286 supports protected mode, expanding addressable physical memory to 16 MB and addressable virtual memory to 1 GB, and providing protected memory, which prevents programs from corrupting one another. This {{is done by}} using the segment registers only for storing an index into a descriptor table that is stored in memory. There are two such tables, the Global Descriptor Table (GDT) and the Local Descriptor Table (LDT), each holding up to 8192 segment descriptors, each segment giving access to 64 KB of memory. In the 80286, a segment descriptor provides a 24-bit base address, and this base address is added to a 16-bit offset to create an absolute address. The base address from the table fulfills the same role that the literal value of the segment register fulfills in real mode; the segment registers have been converted from direct <b>registers</b> to <b>indirect</b> <b>registers.</b> Each segment can be assigned one of four ring levels used for hardware-based computer security. Each segment descriptor also contains a segment limit field which specifies the maximum offset {{that may be used}} with the segment. Because offsets are 16 bits, segments are still limited to 64 KB each in 80286 protected mode.|$|R
5000|$|Addressing modes include Immediate (operand in instruction), Direct or [...] "Symbolic" [...] (operand {{address in}} instruction), Register (operand in {{workspace}} <b>register),</b> <b>Register</b> <b>Indirect</b> (operand address in workspace register) {{with or without}} auto-increment, Indexed (operand address in instruction indexed with workspace register content), and Program Counter Relative.|$|R
5000|$|... 16 kB {{dedicated}} video RAM (64 kB {{standard in}} C128DCR, C128/C128D can be upgraded to 64 kB), {{accessible to the}} CPU only in a doubly <b>indirect</b> method (address <b>register,</b> data register on VDC, which in turn are addressed through address register, data register in mapped memory) ...|$|R
50|$|Note: The above routine {{presumes that}} the CDP1802 {{microprocessor}} {{is in an}} initial reset state (or {{that it has been}} set as such prior to executing this code). Therefore, the program counter (PC) and the X <b>indirect</b> <b>register</b> 'pointer' are both set to 16-bit register R0. That is why you can output an immediate value, as in the example 'OUT 4,00', because PC and X are both pointing to R0. The PC is incremented after the opcode instruction byte is retrieved from memory, so it points to the next address when the OUT 4 is executed. Therefore, it outputs the value in memory pointed to by RX = R0, which is the next immediate byte. The OUT instruction also increments the X register, which is R0, which is also the PC, so it outputs the immediate value after the OUT and continues program execution at the next instruction address after the immediate value. This is why you see the routine set X (SEX) to register R6 and R0 as needed. Also note that, although the OUT opcode increments the RX register, to easily output a section of memory ('buffer'), INP does not. It stores the value at the address pointed to by RX and into the D 8-bit data byte accumulator, but RX is not modified.|$|R
50|$|Gather-scatter {{is a type}} {{of memory}} {{addressing}} that often arises when addressingvectors in sparse linear algebra operations. It is thevector-equivalent of <b>register</b> <b>indirect</b> addressing, with gather involving indexedreads and scatter indexed writes. Vector processors (and some SIMD units in CPUs) havehardware support for gather-scatter operations, providing instructions such asLoad Vector Indexed for gather and Store Vector Indexed for scatter.|$|R
50|$|Most machine {{language}} implementations and early assembly languages {{did not have}} special syntax for records, but the concept was available (and extensively used) {{through the use of}} index <b>registers,</b> <b>indirect</b> addressing, and self-modifying code. Some early computers, such as the IBM 1620, had hardware support for delimiting records and fields, and special instructions for copying such records.|$|R
50|$|Rabbit Semiconductor {{claims that}} the {{instruction}} set of Rabbit processors is optimized for C code. A similar claim is made by Atmel for their AVR processors. The two architectures actually have very similar addressing modes, such as literal, <b>register,</b> <b>indirect</b> and indirect plus displacement. Furthermore, both architectures have specialized 16-bit registers. The Rabbit has IX, IY and SP, whereas the AVR has X, Y and Z.|$|R
50|$|RAM and I/O space can be {{accessed}} only by copying to or from <b>registers.</b> <b>Indirect</b> access (including optional postincrement, predecrement or constant displacement) is possible through registers X, Y, and Z. All accesses to RAM takes two clock cycles. Moving between registers and I/O is one cycle. Moving eight or sixteen bit data between registers or constant to register is also one cycle. Reading program memory (LPM) takes three cycles.|$|R
50|$|Systems {{which have}} control {{subsystem}} {{as an integral}} part of the switching network itself were known as direct control switching systems. Systems in which the control subsytem is outside the switching network are known as Common control systems. Strowger exchanges are usually direct control systems, whereas crossbar, electronic exchanges including all stored program control systems are common control systems. Common control is also known as <b>indirect</b> control or <b>register</b> control.|$|R
50|$|The OR1200 CPU is an {{implementation}} of the 32-bit ORBIS32 instruction set architecture (ISA) and (optionally) ORFP32X ISA implementing IEEE-754 compliant single precision floating point support. The ISA has five instruction formats and supports two addressing modes: <b>register</b> <b>indirect</b> with displacement, and PC-relative. The implementation has a single-issue 5-stage pipeline and is capable of single cycle execution on most instructions. The CPU also contains a MAC unit {{in order to better}} support digital signal processing (DSP) applications.|$|R
50|$|In the x86 {{assembly}} language, the TEST instruction {{performs a}} bitwise AND on two operands. The flags SF, ZF, PF are modified while {{the result of}} the AND is discarded. The OF and CF flags are set to 0, while AF flag is undefined. There are 9 different opcodes for the TEST instruction depending on the type and size of the operands. It can compare 8-bit, 16-bit, 32-bit or 64-bit values. It can also compare registers, immediate values and <b>register</b> <b>indirect</b> values.|$|R
40|$|Original article can {{be found}} at: [URL] Copyright Elsevier B. V. DOI: 10. 1016 / 0165 - 6074 (93) 90060 -X [Full text {{of this article is}} not {{available}} in the UHRA]RISC processors employ simple addressing modes which allow memory addresses to be calculated in a single processor cycle. This paper demonstrates that VLIW and Superscalar processor performance can be improved by further simplifying the addressing modes. In particular, the distinctive ORed indexing addressing mechanism employed by the HARP VLIW processor boosts performance by 10 %. <b>Register</b> <b>indirect</b> addressing on its own yields a similar performance improvement...|$|R
50|$|There was no {{expansion}} of the register set but the registers and instructions were significantly orthogonalized {{in order to make}} them more general purpose and powerful. Many new 8-bit and 16-bit operations were added, and the HL, IX, and IY registers were upgraded from their rather limited possibilities as accumulators in the Z80 to more versatile accumulators. In addition to the register operands possible in the Z80, they could be used with immediate data, direct address, <b>register</b> <b>indirect,</b> or indexed operands, even program counter-relative. Eight-bit operations had even more possibilities, including stack pointer-relative addressing and a choice of 8-bit or 16-bits immediate offsets.|$|R
5000|$|This type of {{reference}} {{can be applied}} to all r-values including non-l-values as well as l-values. Some processors provide one or more instructions which take an immediate value, sometimes referred to as [...] "immediate" [...] for short. An immediate value is stored as part of the instruction which employs it, usually to load into, add to, or subtract from, a register. The other parts of the instruction are the opcode, and destination. The latter may be implicit. (A non-immediate value may reside in a register, or be stored elsewhere in memory, requiring the instruction to contain a direct or <b>indirect</b> address index <b>register</b> address to the value.) ...|$|R
40|$|This article reviews {{previous}} research regarding cost stickiness and performs an empirical analysis {{applied to a}} sample of farms. It recognizes that modelization of cost stickiness is a particular case of representation of cost variations as a function of output variations. It also discusses methodological issues and analyses cost stickiness for all registered farm costs and opportunity costs of family work. Costs exhibit a considerable level of rigidity. Even for variable costs, a decrease in activity involves a lower decrease in costs than the amounts involved when activity increases. While <b>registered</b> <b>indirect</b> costs slightly decrease when activity decreases, opportunity costs always increase. The study provides empirical evidence that cost stickiness is significantly reduced with better management decision practices. cost stickiness, cost behavior, farm management accounting...|$|R
40|$|In static binary translation, {{it can be}} used {{to detect}} {{previously}} undetected entry points into the code, such as through <b>register</b> <b>indirect</b> branches. If no entry point can be found,. in a static binary translation scheme, the program has to branch to an interpreter which will interpret the original program code which is still maintained as part of the address space, or. in a dynamic binary translation scheme, the program has to invoke the dynamic binary compiler to generate a translation of the code fragment in question and then continue execution at the newly translated code fragment. In currently available systems, such as Mimic [2], Accelerator [3], VEST [4], FX! 32 [5], and DAISY [6], checking for an existing translation and generating a branch address from the branch target address in the original (emulated) program is performed using software, commonly by a table lookup. The table format can either be a linear mapping table or a compressed table format such as hash tables. Bo...|$|R
40|$|The {{purpose of}} this paper is to give an {{overview}} of recent trends in child-bearing in neighboring Norway and Sweden. We use indexes produced by applying <b>indirect</b> standardization to <b>register</b> data of the two countries in order to describe and contrast the fertility developments over the last four decades. Our indexes enable us to decompose overall fertility trends into birth-order specific components and by combining the same kind of data from two countries, we get a very accurate picture of various cross-country differences in fertility levels. We demonstrate how Swedish fertility has fluctuated relatively strongly during the whole study period while Norwegian fertility has evolved more gradually, at least during the last two decades. A turnaround from decreasing to increasing levels of childbearing is evident in 1977 in both countries while a sudden shift to shorter birth intervals is specific to Sweden in the 1980 s and contributed to its more spectacular increase in fertility during that decade. (AUTHOR) ...|$|R
40|$|Abstract. The aim of {{the study}} was to verify {{etiological}} agents of CNS perinatal damages in children of early age and to study peculiarities of immune and cytokine statuses during pathogenetically grounded therapy. 618 children aged from 1 month till 3 years were examined. Changes of neurologic status were interrogated and complete standard paraclinical examination was carried out. Basic clinical groups were formed. Immunoassay program, which included verification of a causative agent and determination of indices of cellular and humoral immunities, was used to identify a causative agent and to determin infectious activity. Direct methods of investigation which reveal a causative agent and <b>indirect</b> methods which <b>register</b> specific immune response were used. Patients were divided into groups on the basis of etiological agent. The program of pharmacotherapy was based on findings, immune status and in particular immune mediators. This program included specific anti-infectious therapy and adequate immunorehabilitation. Data analysis was made for groups of patients who got symptomatic therapy in neurologic disease and who got immunocorrective and anti-infectious therapy in addition to standard treatment. Comparison of clinical characteristics showed considerable improvement of patients in the latter group, what correlated with laboratorial data. Normalization of principal indices of immune and cytokine statuses which ensure development of anti-infectious immunity resulted in persistent infectious remission, noticeable improvement of clinical state of the invalidity rate. </p...|$|R
