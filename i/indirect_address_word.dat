0|960|Public
50|$|Modified <b>Indirect</b> Data <b>Address</b> <b>Words</b> (MIDAWs) are {{a channel}} {{programming}} {{capability of the}} IBM System z9 processor. The MIDAW facility is an extension to the pre-existing <b>Indirect</b> Data <b>Address</b> <b>Word</b> (IDAW) channel programming capability, providing support for more efficient FICON channel programs.|$|R
5000|$|MIDAW. The Modified <b>Indirect</b> Data <b>Address</b> <b>Word</b> (MIDAW) {{facility}} {{offers an}} alternative facility for a channel {{program to be}} constructed. It is designed to improve performance for native FICON applications that use extended format datasets (including DB2 and VSAM) by helping to improve channel utilization, reduce channel overhead, and improve I/O response times.|$|R
40|$|A {{microprocessor}} system {{is provided with}} added memories to expand its address spaces beyond its <b>address</b> <b>word</b> length capacity by using <b>indirect</b> <b>addressing</b> instructions of a type having a detectable operations code and dedicating designated address spaces of memory {{to each of the}} added memories, one space to a memory. By decoding each operations code of instructions read from main memory into a decoder to identify <b>indirect</b> <b>addressing</b> instructions of the specified type, and then decoding the address that follows in a decoder to determine which added memory is associated therewith, the associated added memory is selectively enabled through a unit while the main memory is disabled to permit the instruction to be executed on the location to which the effective <b>address</b> of the <b>indirect</b> <b>address</b> instruction points, either before the <b>indirect</b> <b>address</b> is read from main memory or afterwards, depending on how the system is arranged by a switch...|$|R
50|$|The DEC PDP-10 {{computer}} with 18-bit <b>addresses</b> and 36-bit <b>words</b> allowed multi-level <b>indirect</b> <b>addressing</b> {{with the possibility}} of using an index register at each stage as well.|$|R
50|$|Multiple {{levels of}} <b>indirect</b> <b>addressing</b> were supported. <b>Indirect</b> <b>addresses</b> {{had the same}} format as instructions, and the address {{modification}} indicated by the tag field of the <b>indirect</b> <b>address</b> was performed at each level.|$|R
50|$|<b>Indirect</b> <b>addressing</b> or field {{selection}} was selected if the one-bit field (i/a) was set. Both <b>indirect</b> <b>addressing</b> and a base register could be {{selected in the}} <b>indirect</b> <b>address</b> in memory. Only a base register could be selected in the field selector in memory.|$|R
50|$|For address generation, indexing, if specified, is {{performed}} before indirection. The word at the effective <b>indirect</b> <b>address</b> is decoded {{as if it}} were an instruction (except that the instruction code is ignored), allowing an <b>indirect</b> <b>address</b> to also specify indirection or indexing. Multiple levels of <b>indirect</b> <b>addressing</b> are allowed.|$|R
5000|$|Unlike Fortran and ALGOL 60, APL (Address {{programming}} language) supported <b>indirect</b> <b>addressing</b> {{and addressing}} of higher ranks. <b>Indirect</b> <b>addressing</b> is a mechanism {{that appeared in}} other programming languages much later (1963-65 in PL/1).|$|R
50|$|In {{the least}} {{significant}} digit of 5-digit addresses it was set for <b>indirect</b> <b>addressing</b> (an option on the 1620 I, standard on the 1620 II). Multi-level indirection could be used (you could even put the machine in an infinite <b>indirect</b> <b>addressing</b> loop).|$|R
50|$|<b>Indirect</b> <b>addressing</b> may be {{used for}} code or data. It can make {{implementation}} of pointers, references, or handles much easier, and can also make it easier to call subroutines which are not otherwise addressable. <b>Indirect</b> <b>addressing</b> does carry a performance penalty due to the extra memory access involved.|$|R
2500|$|RAM and RASP: <b>indirect</b> <b>addressing</b> available, {{immediate}} operands typical ...|$|R
2500|$|He defines <b>indirect</b> <b>addressing</b> for {{his model}} (p.288) and {{provides}} {{two examples of}} its use (p.89); his [...] "proof" [...] (p.290-292) that his model is Turing equivalent is so sketchy that the reader cannot tell {{whether or not he}} intended the <b>indirect</b> <b>addressing</b> to be a requirement for the proof.|$|R
5000|$|Random access machine—RAM: {{counter machine}} with added <b>indirect</b> <b>addressing</b> {{capability}} ...|$|R
5000|$|He defines <b>indirect</b> <b>addressing</b> for {{his model}} (p. 288) and {{provides}} {{two examples of}} its use (p. 89); his [...] "proof" [...] (p. 290-292) that his model is Turing equivalent is so sketchy that the reader cannot tell {{whether or not he}} intended the <b>indirect</b> <b>addressing</b> to be a requirement for the proof.|$|R
5000|$|... #Subtitle level 2: The {{notion of}} <b>indirect</b> <b>address</b> {{register}} [...] "N" ...|$|R
2500|$|Counter machine: no <b>indirect</b> <b>addressing,</b> {{immediate}} operands {{possible in}} highly atomized models ...|$|R
50|$|The {{address space}} was 15 bits, {{limiting}} the 1130 to 32,768 16-bit words (65,536 bytes) of memory. The 1130 used magnetic-core memory, which the processor <b>addressed</b> on <b>word</b> boundaries, using direct, <b>indirect,</b> and indexed <b>addressing</b> modes.|$|R
5000|$|... #Subtitle level 3: Elgot-Robinson (1964) and {{the problem}} of the RASP without <b>indirect</b> <b>addressing</b> ...|$|R
5000|$|A maximum {{file size}} {{of just over}} one gigabyte, through a system of <b>indirect</b> <b>addressing</b> ...|$|R
5000|$|Eight data {{pointers}} {{instead of}} one for <b>indirect</b> <b>addressing</b> of program and external data memory ...|$|R
5000|$|... f (...) is the [...] "effective value" [...] {{function}} {{used for}} <b>indirect</b> <b>addressing</b> (see details below): ...|$|R
5000|$|... bit 17: I (sr. Indirektno) - {{multi-level}} memory <b>indirect</b> (note: the <b>address</b> {{is loaded}} from specified location and, should it also specify [...] "I" [...] flag the <b>indirect</b> <b>address</b> calculation continues) ...|$|R
5000|$|Melzak {{recognized}} a couple serious defects in his register/counter-machine model: (i) Without {{a form of}} <b>indirect</b> <b>addressing</b> {{he would not be}} able to [...] "easily" [...] show the model is Turing equivalent, (ii) The program and registers were in different [...] "spaces", so self-modifying programs would not be easy. When Melzak added <b>indirect</b> <b>addressing</b> to his model he created a random access machine model.|$|R
40|$|For {{simulation}} on a spherical surface, such {{as global}} numerical weather prediction, icosahedral grids {{are superior to}} their competitors in uniformity of grid mesh distance across the entire globe and lack of neighboring grid cells that share only a single vertex. Use of such a grid presents unique programming challenges related to iteration across grid cells and location of neighboring cells. Here we describe an icosahedral grid with a one-dimensional vector loop structure, table specified memory order, and an <b>indirect</b> <b>addressing</b> scheme that yields very compact code despite the complexities of this grid. This approach allows the same model code {{to be used for}} many grid structures. <b>Indirect</b> <b>addressing</b> also allows grid cells to be stored in any order, selectable at run time. This permits easy implementation of different memory layouts for cache block-ing, distributed-memory parallelism, and static load balancing. Since <b>indirect</b> <b>addressing</b> can adversely affect execution time we organize arrays to place a directly addressable index innermost. We also describe experiments designed to measure any performance penalties accrued from use of <b>indirect</b> <b>addressing...</b>|$|R
50|$|The FX-603P {{supported}} <b>indirect</b> <b>addressing</b> {{both for}} memory access and jumps and therefore programming model {{could be considered}} Turing complete.|$|R
5000|$|Pointer machine:Reference model (or RAMrefModel): {{augment the}} <b>indirect</b> <b>addressing</b> and the RefLib for it. Is used {{also on the}} Random access program machine.|$|R
50|$|If {{the word}} size {{is larger than}} the <b>address,</b> then the <b>word</b> {{referenced}} for memory-indirect addressing could itself have an indirect flag set to indicate another memory indirect cycle. This flag is referred to as an indirection bit, and the resulting pointer is a tagged pointer, the indirection bit tagging whether it is a direct pointer or an indirect pointer. Care is needed to ensure that a chain of <b>indirect</b> <b>addresses</b> does not refer to itself; if it does, one can get an infinite loop while trying to resolve an address.|$|R
50|$|Each {{instruction}} contained six bits of opcode, one bit specifying whether <b>indirect</b> <b>addressing</b> used, two bits of {{index register}} address and fifteen bits of address.|$|R
5000|$|Assign a code {{to specify}} direct {{addressing}} as d="0" [...] and <b>indirect</b> <b>addressing</b> as i="1". Then our machine {{can determine the}} source address as follows: ...|$|R
50|$|The {{standard}} assembler places {{constant values}} for arithmetic {{in the current}} page. Likewise, cross-page jumps and subroutine calls use an <b>indirect</b> <b>address</b> in the current page.|$|R
5000|$|Memory operands are {{specified}} by absolute address; the location is fixed at compile time. To provide <b>indirect</b> <b>addressing,</b> {{a pair of}} special function registers are provided: ...|$|R
5000|$|Register then {{indirect}} (RI): Perform {{the address}} modification as in Register modification, {{use the word}} at the effective <b>address</b> as an <b>indirect</b> <b>address</b> of the operand.|$|R
50|$|The Address {{programming}} language (Адресный язык программирования Адресна мова програмування) {{is one of}} the world's first high-level {{programming language}}s. It was created in 1955 by Ekaterina Yushchenko. In particular, the Address programming language made possible <b>indirect</b> <b>addressing</b> and addresses of the highest rank analogous to pointers.|$|R
40|$|In {{the first}} part of this paper, an {{improved}} slope-intercept like representation is proposed for implementation of Standard Hough Transform (SHT) on SIMD (Single-Instruction, Multiple-Data) architectures with no local <b>indirect</b> <b>addressing</b> support. The real-time implementation is realized with high accuracy on our Wireless Smart Camera (WiCa) platform. The processing time of this approach is independent of the number of edge points or the number of detected lines. In the second part, we focus on analyzing the differences between the SHT implementations on 1 -D SIMD architectures with and without local <b>indirect</b> <b>addressing.</b> Three aspects are compared: total operation number, memory access/ energy consumption, and memory area cost. When local <b>indirect</b> <b>addressing</b> is supported, the results show a considerable amount of reduction in total operations and energy consumption at the cost of extra chip area. The results also show that the focuses for further optimization of these two architectures are different...|$|R
50|$|Direct and <b>Indirect</b> <b>addressing</b> were {{applicable}} to both general purpose and index registers. They would probably {{work with other}} registers too {{but that would be}} bad practice.|$|R
5000|$|... {{dependence}} {{analysis is}} hard for code that uses <b>indirect</b> <b>addressing,</b> pointers, recursion, or indirect function calls because {{it is difficult to}} detect such dependencies at compile time; ...|$|R
