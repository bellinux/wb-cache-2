47|333|Public
5000|$|... {{too many}} frames with invalid <b>frame</b> <b>check</b> <b>sequence</b> (FCS) field have been {{received}} ...|$|E
5000|$|A packet {{detected}} as jabber by an upstream repeater {{and subsequently}} cut off has an invalid <b>frame</b> <b>check</b> <b>sequence</b> and is dropped.|$|E
5000|$|<b>Frame</b> <b>check</b> <b>sequence</b> : A four byte field used {{to store}} the {{calculation}} of a CRC for frame integrity verification by the receiver.|$|E
5000|$|Protection against errors, {{generally}} {{by means}} of generating and <b>checking</b> <b>frame</b> <b>check</b> <b>sequences</b> ...|$|R
30|$|The Superframe {{structure}} of IEEE 802.15. 6 MAC comprises of three main modules that are MAC header, MAC variable length and <b>frame</b> <b>check</b> <b>sequences</b> (FCS). The MAC header reserves 7 bytes, the variable length reserves 0 – 255 bytes and FCS reserves 2 bytes {{as depicted in}} Fig.  4. The MAC frame body is further categorized into three sub-headers that are (a) Data Freshness which occupies 1 byte to protect data from the reply attack, (b) Message Integrity Code (MIC) occupies 4 bytes to authenticate the frame and maintains the integrity <b>check</b> of a <b>frame,</b> and (c) Data Payload contains data with MIC headers in the frame. Moreover, IEEE 802.15. 6 MAC header is categorized into 4 sub-headers. First, the Frame Control occupies 4 bytes and uses to distinguish between control frame and data frame along with an acknowledgment. The second and third headers are the addresses of the receiver and sender sensors, respectively. Each sensor uses 1 byte to store the address. The BANC header is the final header which occupies 1 byte to store the address. The slot allocation {{to the nature of}} a patient’s data in both IEEE 802.15. 4 and IEEE 802.15. 6 MACs is the responsibility of a BANC. Therefore, the draft version of IEEE 802.15. 6 MAC defines three ways for transmitting the patient’s data [4, 15] which are discussed in the following subsections.|$|R
40|$|A general {{model for}} {{constructing}} minimal length <b>checking</b> <b>sequences</b> is proposed. The model {{is based on}} the characteristics of <b>checking</b> <b>sequences</b> and sets of state identification and verification sequences. Some existing methods are shown to be special cases of the proposed model. The minimality of the resulting <b>checking</b> <b>sequences</b> is discussed and heuristic algorithms for the construction of minimal length <b>checking</b> <b>sequences</b> given...|$|R
50|$|Because {{inserting}} the VLAN tag {{changes the}} frame, 802.1Q encapsulation forces a recalculation {{of the original}} <b>frame</b> <b>check</b> <b>sequence</b> field in the Ethernet trailer.|$|E
50|$|FCS - The <b>Frame</b> <b>Check</b> <b>Sequence</b> {{enables a}} high level of {{physical}} error control by allowing the integrity of the transmitted frame data to be checked.|$|E
50|$|Frames {{are divided}} into very {{specific}} and standardized sections. Each frame consists of a MAC header, payload, and <b>frame</b> <b>check</b> <b>sequence</b> (FCS). Some frames {{may not have a}} payload.|$|E
40|$|This study {{discusses}} {{the generation of}} the minimum length <b>checking</b> <b>sequences</b> for FSM-based protocol conformance testing. The discussion focuses on finding the minimal length of resulting <b>checking</b> <b>sequences</b> for an FSM under different conditions. Without interleaving state identification and transition verification sequences, four methods (D-method, W-method, Wp-method and UIOv-method) of generating minimum length test sequences for FSMs with reliable reset feature are reviewed and provided to construct <b>checking</b> <b>sequences.</b> These four methods are then improved to generate minimum length <b>checking</b> <b>sequences</b> for FSMs without reliable reset feature and provided to construct <b>checking</b> <b>sequences.</b> Moreover, the effects of interleaving the state identification and transition verification sequences {{on the length of}} the <b>checking</b> <b>sequences</b> are studied. An algorithm for interleaving the state identification and transition verification sequences generated by the above four methods with reliable reset feature is proposed. It is observed that the reduction in the length of <b>checking</b> <b>sequences</b> due to interleaving is significant. Finally, the two general models for constructing minimal length <b>checking</b> <b>sequences</b> using distinguishing sequences with interleaved state identification and transition verification sequences are proposed. The proof for the first model to find a minimum length <b>checking</b> <b>sequence</b> in polynomial time is provided. The sequences generated by using both models are proved to be <b>checking</b> <b>sequences.</b> Examples are provided as applications of all the proposed methods and models...|$|R
40|$|The {{problem of}} {{generating}} <b>checking</b> <b>sequences</b> for FSMs with distinguishing sequence has been attracting interest of researchers for several decades. In this paper, a solution is proposed for partial reduced FSMs with distinguishing sets, and either {{with or without}} reset feature. Sufficient conditions for a sequence to be a <b>checking</b> <b>sequence</b> for such FSMs are formulated. Based on these conditions, a method to generate <b>checking</b> <b>sequence</b> is elaborated. The results of an experimental comparison indicate that the proposed method produces shorter <b>checking</b> <b>sequences</b> than existing methods in most cases. The impact of using the reset feature {{on the length of}} <b>checking</b> <b>sequence</b> is also experimentally evaluated...|$|R
40|$|Given {{a finite}} state machine M, a <b>checking</b> <b>{{sequence}}</b> is an input sequence that is guaranteed {{to lead to a}} failure if the implementation under test is faulty and has no more states than M. There has been much interest in the automated generation of a short <b>checking</b> <b>sequence</b> from a {{finite state machine}}. However, such sequences can contain reset transitions whose use can adversely affect both the cost of applying the <b>checking</b> <b>sequence</b> and the effectiveness of the <b>checking</b> <b>sequence.</b> Thus, we sometimes want a <b>checking</b> <b>sequence</b> with a minimum number of reset transitions rather than a shortest <b>checking</b> <b>sequence.</b> This paper describes a new algorithm for generating a <b>checking</b> <b>sequence,</b> based on a distinguishing sequence, that minimises the number of reset transitions used. This work {{was supported in part by}} Leverhulme Trust grant number F/ 00275 /D, Testing State Based Systems, Natural Sciences and Engineering Research Council (NSERC) of Canada grant number RGPIN 976, and Engineering and Physical Sciences Research Council grant number GR/R 43150, Formal Methods and Testing (FORTEST) ...|$|R
5000|$|A <b>frame</b> <b>check</b> <b>sequence</b> (FCS) word, which [...] "provides a {{check for}} errors in the message" [...] and covers [...] "the FC, PA, DA, WC, INFO, and the FCS fields." ...|$|E
50|$|RA - Receiver Address {{indicating}} the MAC Address {{of the station}} that shall receive frame.TA - Transmitter Address {{indicating the}} MAC address of the station which has transmitted frame.FCS - <b>Frame</b> <b>Check</b> <b>Sequence.</b>|$|E
50|$|A <b>frame</b> <b>check</b> <b>sequence</b> (FCS) {{refers to}} the extra error-detecting code added to a frame in a {{communications}} protocol. Frames are used to send upper-layer data and ultimately the application data from a source to a destination.|$|E
40|$|A {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} based testing is introduced. Unlike previous methods, {{which are based on}} state recognition using a single state identification sequence, our approach makes use of multiple state identification sequences. Using multiple state identification sequences provides an opportunity to construct shorter <b>checking</b> <b>sequences,</b> choosing greedily the state identification sequence that best suits our goal at different points during the construction of the <b>checking</b> <b>sequence.</b> We present the results of an experimental study showing that our approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods...|$|R
40|$|Part 1 : Model Based TestingInternational audienceA {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} based testing is introduced. Unlike previous methods, {{which are based on}} state recognition using a single state identification sequence, our approach makes use of multiple state identification sequences. Using multiple state identification sequences provides an opportunity to construct shorter <b>checking</b> <b>sequences,</b> choosing greedily the state identification sequence that best suits our goal at different points during the construction of the <b>checking</b> <b>sequence.</b> We present the results of an experimental study showing that our approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods...|$|R
40|$|Abstract. There are {{two main}} {{shortcomings}} in the existing models for generating <b>checking</b> <b>sequences</b> based on distinguishing sequences. First, these models require a priori selection of state recognition sequences (called α-sequences) {{which may not be}} the best selection for yielding substantial reduction in the length of <b>checking</b> <b>sequences.</b> Second, they do not take advantage of overlapping to further reduce the length of <b>checking</b> <b>sequences.</b> This paper proposes an optimization model that tackles these shortcomings to reduce the lengths of <b>checking</b> <b>sequences</b> beyond what is achieved by the existing models by replacing the state recognition sequences with a set of basic sequences called α-elements and by making use of overlapping. ...|$|R
50|$|Error control {{protocols}} such as LAPM use {{frames of}} variable lengths, each {{beginning with a}} header and ending with a <b>frame</b> <b>check</b> <b>sequence</b> trailer (a cyclic redundancy check). Correctly received packets are acknowledged, and unacknowledged packets are automatically retransmitted (ARQ).|$|E
50|$|A remote collision, in CSMA/CD {{computer}} networks, is {{a collision}} {{that occurs when}} a frame having length less than minimum length and with an incorrect <b>frame</b> <b>check</b> <b>sequence,</b> is transmitted. This frame causes a collision at the remote end which will not be detected by the transmitter.|$|E
50|$|Note: Link-level {{functions}} {{provide an}} interface between the station high-level logic {{and the data}} link. Link-level functions include (a) transmit bit injection and receive bit extraction, (b) address and control field interpretation, (c) command response generation, transmission and interpretation, and (d) <b>frame</b> <b>check</b> <b>sequence</b> computation and interpretation.|$|E
40|$|A {{new method}} for {{constructing}} a <b>checking</b> <b>sequence</b> for {{finite state machine}} (FSM) based testing is introduced. It {{is based on a}} recently suggested method which uses quite a different approach than almost all the methods developed since the introduction of the <b>checking</b> <b>sequence</b> generation problem around half a century ago. Unlike its predecessor which aggressively tries to recognize the states by applying identification sequences, our approach relies on yet to be generated parts of the sequence for this. The method may terminate without producing a <b>checking</b> <b>sequence.</b> We also suggest a method to <b>check</b> if a <b>sequence</b> is a <b>checking</b> <b>sequence</b> for this purpose. If it turns out not be a <b>checking</b> a <b>sequence,</b> a post processing phase extends the sequence further. We present the results of an experimental study showing that our two phase approach produces shorter <b>checking</b> <b>sequences</b> than the previously published methods. This experimental study is performed on FSMs that are randomly generated by using a tool implemented within this work to support this and other FSM based testing studies...|$|R
40|$|Lower bounds on {{the lengths}} of <b>checking</b> <b>sequences</b> {{constructed}} for testing from Finite State Machine-based specifications are established. These bounds {{consider the case}} where a distinguishing sequence is used in forming state recognition and transition verification subsequences and identify the effects of overlapping among such subsequences. Empirical {{results show that the}} existing methods for construction of <b>checking</b> <b>sequences</b> provide <b>checking</b> <b>sequences</b> with lengths that are within acceptable distance to these lower bounds...|$|R
40|$|Methods for {{software}} testing based on Finite State Machines (FSMs) have been researched {{since the early}} 60 ’s. Many of these methods are about generating a <b>checking</b> <b>sequence</b> from a given FSM which is an input sequence that determines whether an implementation of the FSM is faulty or correct. In this paper, we consider one of these methods, which constructs a <b>checking</b> <b>sequence</b> by reducing the problem of generating a <b>checking</b> <b>sequence</b> to finding a Chinese rural postman tour on a graph induced by the FSM; we re-formulate the constraints used in this method {{as a set of}} Boolean formulas; and use a SAT solver to generate a <b>checking</b> <b>sequence</b> of minimal length...|$|R
50|$|The {{structure}} of a DPT Packet is quite {{similar to that of}} Ethernet. It contains a source and destination MAC address (both 48-bits long), a protocol type identifier (used for identifying the upper layer protocol contained in the payload), and an <b>frame</b> <b>check</b> <b>sequence</b> used to validate the data.|$|E
5000|$|In the {{computer}} networking, {{data to be}} transmitted is the payload, but is almost always encapsulated in some type of a [...] "frame" [...] composed of framing bits and a <b>frame</b> <b>check</b> <b>sequence.</b> [...] Examples are Ethernet frames, Point-to-Point Protocol (PPP) frames, Fibre Channel frames, and V.42 modem frames.|$|E
50|$|Two {{types of}} PDUs are {{available}} {{for use in the}} protocol: the Request PDU and the Respond PDU. Each support an application protocol that the specific implementation must define. A <b>frame</b> <b>check</b> <b>sequence</b> is responsible for error checking, which, due to the system's simplicity, must be done on the application layer.|$|E
40|$|Based on a {{distinguishing}} sequence for a Finite State Machine (FSM), {{an efficient}} <b>checking</b> <b>sequence</b> may be produced {{from the elements}} of a set of –sequences and a set ET of T–sequences, that both recognize the states, and elements of EC which represents the transitions in the FSM. An optimization algorithm may then be used to produce a reduced length <b>checking</b> <b>sequence</b> by connecting the elements of, ET, and EC using transitions taken from an acyclic set E ′′. It is known that only a subset E′C of EC is sufficient to form a <b>checking</b> <b>sequence.</b> This paper improves this result by reducing the number of elements in E′C that must be included in the generated <b>checking</b> <b>sequence...</b>|$|R
40|$|Context: Given a Finite State Machine (FSM), a <b>checking</b> <b>{{sequence}}</b> is a {{test sequence}} that determines whether the system under test is correct as long as certain standard assumptions hold. Many <b>checking</b> <b>sequence</b> generation methods use an adaptive distinguishing sequence (ADS), which is an experiment that distinguishes {{the states of the}} specification machine. Furthermore, {{it has been shown that}} the use of shorter ADSs yields shorter <b>checking</b> <b>sequences.</b> It is also known, on the other hand, that constructing a minimum cost ADS is an NP-hard problem and it is NP-hard to approximate. This motivates studying and investigating effective ADS construction methods. Objective: The main objective of this paper is to suggest new methods that can compute compact ADSs to be used in the construction of <b>checking</b> <b>sequences.</b> Method: We briefly present the existing ADS construction algorithms. We then propose generalizations of these approaches with a set of heuristics. We also conduct experiments to compare the size of the resultant ADSs and the length of the <b>checking</b> <b>sequences</b> constructed using these ADSs. Results: The results indicate that when the ADSs are constructed with the proposed methods, the length of the <b>checking</b> <b>sequences</b> may reduce up to 54...|$|R
40|$|Most of today’s {{wireless}} communication devices operate on unlicensed bands with uncoordinated spectrum access, with the consequence that RF interference and collisions are impairing the overall performance of wireless networks. In the classical design of network protocols, both packets in a collision are considered lost, such that channel access mechanisms {{attempt to avoid}} collisions proactively. However, with the current proliferation of wireless applications, e. g., WLANs, car-to-car networks, or the Internet of Things, this conservative approach is increasingly limiting the achievable network performance in practice. Instead of shunning interference, this thesis questions the notion of „harmful“ interference and argues that interference can, when generated in a controlled manner, be used to increase the performance and security of wireless systems. Using results from information theory and communications engineering, we identify the causes for reception or loss of packets and apply these insights to design system architectures that benefit from interference. Because the effect of signal propagation and channel fading, receiver design and implementation, and higher layer interactions on reception performance is complex and hard to reproduce by simulations, we design and implement an experimental platform for controlled interference generation to strengthen our theoretical findings with experimental results. Following this philosophy, we introduce and evaluate a system architecture that leverage interference. First, we identify the conditions for successful reception of concurrent transmissions in wireless networks. We focus on the inherent ability of angular modulation receivers to reject interference when the power difference of the colliding signals is sufficiently large, the so-called capture effect. Because signal power fades over distance, the capture effect enables two or more sender–receiver pairs to transmit concurrently if they are positioned appropriately, in turn boosting network performance. Second, we show how to increase the security of wireless networks with a centralized network access control system (called WiFire) that selectively interferes with packets that violate a local security policy, thus effectively protecting legitimate devices from receiving such packets. WiFire’s working principle is as follows: {{a small number of}} specialized infrastructure devices, the guardians, are distributed alongside a network and continuously monitor all packet transmissions in the proximity, demodulating them iteratively. This enables the guardians to access the packet’s content before the packet fully arrives at the receiver. Using this knowledge the guardians classify the packet according to a programmable security policy. If a packet is deemed malicious, e. g., because its header fields indicate an unknown client, one or more guardians emit a limited burst of interference targeting the end of the packet, with the objective to introduce bit errors into it. Established communication standards use <b>frame</b> <b>check</b> <b>sequences</b> to ensure that packets are received correctly; WiFire leverages this built-in behavior to prevent a receiver from processing a harmful packet at all. This paradigm of „over-the-air“ protection without requiring any prior modification of client devices enables novel security services such as the protection of devices that cannot defend themselves because their performance limitations prohibit the use of complex cryptographic protocols, or of devices that cannot be altered after deployment. This thesis makes several contributions. We introduce the first software-defined radio based experimental platform that is able to generate selective interference with the timing precision needed to evaluate the novel architectures developed in this thesis. It implements a real-time receiver for IEEE 802. 15. 4, giving it the ability to react to packets in a channel-aware way. Extending this system design and implementation, we introduce a security architecture that enables a remote protection of wireless clients, the wireless firewall. We augment our system with a rule checker (similar in design to Netfilter) to enable rule-based selective interference. We analyze the security properties of this architecture using physical layer modeling and validate our analysis with experiments in diverse environmental settings. Finally, we perform an analysis of concurrent transmissions. We introduce a new model that captures the physical properties correctly and show its validity with experiments, improving {{the state of the art}} in the design and analysis of cross-layer protocols for wireless networks...|$|R
50|$|When {{cut-through}} switching {{is used in}} Ethernet, {{because the}} <b>frame</b> <b>check</b> <b>sequence</b> appears {{at the end of}} the frame, the switch is not able to verify the integrity of an incoming packet before forwarding it. A cut-through switch will forward corrupted packets, whereas a store and forward switch will drop them.|$|E
5000|$|<b>Frame</b> <b>Check</b> <b>Sequence</b> (FCS) Field. Since one cannot {{completely}} {{ignore the}} bit error-rate of the medium, each switching node needs to implement error detection to avoid wasting bandwidth {{due to the}} transmission of erred frames. The error detection mechanism used in Frame Relay uses the cyclic redundancy check (CRC) as its basis.|$|E
5000|$|A {{composite}} FX.25 entity {{is called}} a [...] "frame," [...] distinguishing it from the AX.25 [...] "packet" [...] contained within. The FX.25 frame contains the following elements:- Preamble- Correlation Tag- AX.25 Packet- - AX.25 Packet Start- - AX.25 Packet Body- - AX.25 Packet <b>Frame</b> <b>Check</b> <b>Sequence</b> (FCS)- - AX.25 Packet End- Pad for bit-to-byte alignment- FEC Check Symbols- Postamble ...|$|E
40|$|Methods {{for testing}} from finite state machine-based {{specifications}} often require {{the existence of}} a preset distinguishing <b>sequence</b> for constructing <b>checking</b> <b>sequences.</b> It has been shown that an adaptive distinguishing sequence is sufficient for these methods. This result is significant because adaptive distinguishing sequences are strictly more common and up to exponentially shorter than preset ones. However, there has been no study on the actual effect of using adaptive distinguishing sequences on the length of <b>checking</b> <b>sequences.</b> This paper describes experiments that show that <b>checking</b> <b>sequences</b> constructed using adaptive distinguishing sequences are almost consistently shorter than those based on preset distinguishing sequences. This is investigated for three different <b>checking</b> <b>sequence</b> generation methods and the results obtained from an extensive experimental study are given...|$|R
40|$|Part 6 : Short ContributionsInternational audienceIn this paper, we {{investigate}} how a <b>checking</b> <b>sequence</b> {{can be generated}} from a Finite State Machine, {{with respect to a}} user-defined set of faults, modeled as a nondeterministic FSM, called Mutation Machine (MM). We propose an algorithm for generating a <b>checking</b> <b>sequence</b> in this scenario and demonstrate its correctness...|$|R
40|$|With {{advances}} {{in computer technology}} and software engineering, systems are constantly becoming larger and more complex. Straightforward testing methods are insufficient {{to cope with the}} complexity and maintaining quality of service demands the use of more structured testing methods. <b>Checking</b> <b>sequences</b> are testing mechanisms based on finite state behavior models that can offer guarantees about a system under test, under certain assumptions. However, their complexities are high, and to make their imple-mentation feasible methods of their construction need to be refined. We have studied several methods of <b>checking</b> <b>sequence</b> construction in the presence of distinguishing sequences, developed fully formed algorithms from loose specifications, then implemented and compared their performances. We have also proposed several improvements that will allow generation of shorter <b>checking</b> <b>sequences.</b> We are confident that these developments will be instrumental in making the use of <b>checking</b> <b>sequences</b> feasible in a larger scope. i...|$|R
