42|52|Public
2500|$|The slash {{is used as}} a <b>division</b> <b>operator</b> in most {{programming}} languages. The double slash is used by Rexx as a modulo operator, and Python (starting in version 2.2) uses {{a double}} slash for division which rounds any decimals down to the nearest integer. [...] In Perl 6 the double slash {{is used as a}} [...] "defined-or" [...] alternative to ||. A dot and slash [...] is used in MATLAB and GNU Octave to indicate an element-by-element division of matrices.|$|E
2500|$|For example, the {{following}} code defines a binary operator [...] as safe division that avoids dividing by zero, using the Maybe monad and its constructors [...] and [...] The monadic values x and y {{may have the}} form Nothing or Just i, where i is an integer. The integer values contained within x and y are extracted into the plain values a and b, which are processed by the plain <b>division</b> <b>operator</b> [...] "" [...] only when b is not zero.|$|E
50|$|The {{results of}} the using the <b>division</b> <b>operator</b> on i, j and k was as follows.|$|E
5000|$|For example, it {{requires}} the programmer to declare variables {{and it does not}} feature the infamous GOTO and GOSUB statements. Some aspects of the syntax are even inspired in non-BASIC languages, such as C/C++. Thanks to this, thinBASIC optionally allows use of implicit line continuation, simplified addition, subtraction, multiplication and <b>division</b> <b>operators,</b> shortened variable declaration and initialization: ...|$|R
5000|$|CJ E&M Smart Media <b>Division</b> - <b>operator</b> {{of various}} {{entertainment}} and media websites ...|$|R
40|$|International audienceThis two part paper proposes new and exact {{arithmetic}} {{operations for}} intervals and their extension to fuzzy and gradual ones. Indeed, {{it is well}} known that the practical use of interval and fuzzy arithmetic operators gives results more imprecise than necessary or in some cases, even incorrect. This problem is due to the overestimation effect induced by computing interval arithmetic operations. In this part, the Midpoint-Radius (MR) representation is considered to define new exact and optimistic subtraction and <b>division</b> <b>operators.</b> These operators are extended to fuzzy and gradual intervals in the Part II...|$|R
5000|$|... {{the first}} and second {{argument}} term of the <b>division</b> <b>operator</b> / is called dividend and divisor, respectively, ...|$|E
50|$|Note {{the use of}} {{the colon}} tile to {{represent}} the <b>division</b> <b>operator,</b> as opposed to the slash or obelus.|$|E
5000|$|... if the <b>division</b> <b>operator</b> {{is written}} as {{fraction}} bar, {{the top and}} bottom terms are called numerator and denominator, respectively.|$|E
50|$|In {{order to}} reflect normal usage, addition, subtraction, multiplication, and <b>division</b> <b>{{operator}}s</b> are usually left-associative while an exponentiation operator (if present) is right-associative; this {{applies to the}} up-arrow operator as well. Any assignment operators are also typically right-associative. To prevent cases where operands {{would be associated with}} two operators, or no operator at all, operators with the same precedence must have the same associativity.|$|R
40|$|This paper {{presents}} integer multiplication and <b>division</b> <b>operators</b> {{dedicated to}} Virtex-II FPGAs from Xilinx. Those operators {{are based on}} small 18 x 18 multiplier blocks available in the Virtex-II device family. Various trade-offs are explored (computation decomposition, radix, digit sets, [...] .) using specific VHDL generators. The obtained operators lead to speed improvements up to 18 % for multiplication and 40 % for division compared to standard solutions only based on CLBs...|$|R
40|$|This paper {{presents}} integer mu l ipl [...] k(ion and <b>division</b> <b>operators</b> {{dedicated to}} Virtex-II FPGAs from Xil# x. Those operators are basedonsmal l 1818 mu l ipl [...] 8 b cks avail# l e in the Virtex-II device fam il. Various trade-o#s are expl ored (computation decomposition, radix, digit sets [...] .) using specific VHDL generators. The obtained operatorsl ead to speed improvements up to 18 % for mul tiplp [...] #. k(and 40 % for division compared to standardsol tions onl y based on CLBs. ...|$|R
5000|$|Integers are {{automatically}} promoted to reals in expressions that involve the normal <b>division</b> <b>operator</b> (...) so that division of one integer by another produces the intuitively correct result. VB provides a specific integer divide operator (...) that does truncate.|$|E
5000|$|The {{relational}} division {{operation is}} {{a slightly more}} complex operation and essentially involves using the tuples of one relation (the dividend) to partition a second relation (the divisor). The relational <b>division</b> <b>operator</b> is effectively {{the opposite of the}} cartesian product operator (hence the name).|$|E
5000|$|Numeric {{classes for}} {{floating}} point types are also different. Haskell's classes Fractional, RealFrac, RealFloat and Floating are not defined. Haskell's class Real defines toRational while Frege's defines (/):class Real (Num r) => r where -- classname precedes context --- the <b>division</b> <b>operator</b> (/) :: r -> r -> r ...|$|E
40|$|International audienceRecently, gradual {{numbers have}} been {{introduced}} {{as a means of}} extending standard interval computation methods to fuzzy and gradual intervals. However, {{it is well known that}} the practical use of standard interval arithmetic operators, just as their fuzzy extension, gives results more imprecise than necessary. In this paper, we combine the concepts of gradual numbers and Kaucher arithmetic on extended intervals to define extended gradual interval arithmetic where subtraction and <b>division</b> <b>operators</b> are respectively the inverse operators of the addition and the multiplication. They are applied to a control problem based on the inversion of a linear model...|$|R
3000|$|... denote {{factorial}} component-wise vector multiplication and component-wise vector <b>division,</b> respectively. The <b>operator</b> [...]...|$|R
40|$|Fuzzy {{arithmetic}} is {{a powerful}} tool in many engineering problems such as decision making, control theory, fuzzy systems and approximate reasoning. However, {{it is well known}} that the practical use of standard fuzzy arithmetic operators gives results more imprecise than necessary or in some cases, even incorrect. This problem is due to the overestimation effect induced by computing fuzzy arithmetic operations. In this paper a modified implementation for fuzzy unimodal interval arithemtics is defined where new subtraction and <b>division</b> <b>operators</b> are proposed. These new operators are exactly the inverse of the addition and multiplication operators. The effectiveness of the proposed methodology is illustrated by simulation examples...|$|R
50|$|Most {{operators}} {{encountered in}} programming {{are of the}} binary form. For both programming and mathematics these can be the multiplication operator, the addition operator, the <b>division</b> <b>operator.</b> Logical predicates such as OR, XOR, AND, IMP are typically used as binary operators with two distinct operands. In CISC architectures, it's common to have two source operands (and store result in one of them).|$|E
50|$|The next {{order of}} {{operation}} {{according to the}} rules is division. However, there is no <b>division</b> <b>operator</b> sign (÷) in the expression, 16 − 6. So we {{move on to the next}} order of operation, i.e., addition. But there is no addition operator sign (+) in the expression 16 − 6. So we move on to the next and final order of operation, which is subtraction.|$|E
5000|$|To {{avoid this}} issue, a {{proposal}} {{was made to}} change {{the behavior of the}} Python <b>division</b> <b>operator.</b> In Python 2.2, a new operator [...] was introduced for floor division, both for integer and floating-point arguments. The [...] operator was changed so that the quotient of two integers returned a float, but for backwards compatibility, this behavior had to be explicitly requested until Python 3.0.|$|E
5000|$|Python 2.2 changes integer {{division}} to round towards negative infinity, e.g. [...] and [...] The floor <b>division</b> [...] <b>operator</b> is introduced. So , , [...] and [...] Adding [...] causes a module to use Python 3.0 rules for division (see next).|$|R
40|$|International audienceMaintaining the {{synchronization}} between {{receiver and}} transmitter {{in the presence}} of Doppler effect is considered as a major challenge for ultra-wideband (UWB) communication systems. Delay-Locked Loop (DLL) method is widely proposed to keep the satisfactory synchronization. In this paper, we modify the structure of DLL, using Internal Model Control (IMC). Unfortunately, primary simulation results confirm that the IMC-DLL has a high opportunity to lose tracking {{in the presence of}} Doppler effect. In order to solve this problem, we develop the IMC tracking structure by adding an adaptive filter block, which has a simple structure: one addition and one <b>division</b> <b>operators.</b> The simulation results confirm that the proposed IMC-DLL has better transient response, compared with the classical DLL...|$|R
40|$|Well known {{implementations}} for perspective correct {{rendering of}} planar polygons require a division per rendered pixel. Such a division {{is better to}} be avoided as it is an expensive operation in terms of silicon gates and clock cycles. In this paper we present a family of efficient midpoint algorithms {{that can be used to}} avoid <b>division</b> <b>operators.</b> These algorithms do not require more than a small number of additions per pixel. We show how these can be embedded in scan line algorithms and in algorithms that use mipmaps. Experiments with software implementations show that the division free algorithms are a factor of two faster, provided that the polygons are not too small. These algorithms are however most profitable when realised in hardware...|$|R
50|$|The {{following}} is the Berlekamp-Massey algorithm specialized for the binary finite field F2 (also written GF(2)). The field elements are '0' and '1'. The field operations '+' and '−' are identical and are {{equivalent to the}} 'exclusive or' operation, XOR. The multiplication operator '*' becomes the logical AND operation. The <b>division</b> <b>operator</b> reduces to the identity operation (i.e., field division is only defined for dividing by 1, and x/1 = x).|$|E
5000|$|More precisely, let [...] be the scalar <b>division</b> <b>operator</b> on Rn. A {{distribution}} S on Rn or Rn \ {0} is homogeneous {{of degree}} m provided thatfor all positive real t and all test functions &phi;. The additional factor of t&minus;n {{is needed to}} reproduce the usual notion of homogeneity for locally integrable functions, and comes about from the Jacobian change of variables. The number m can be real or complex.|$|E
50|$|Typically, a fuzzer is {{considered}} more effective if it achieves {{a higher degree}} of code coverage. The rationale is, if a fuzzer does not exercise certain structural elements in the program, then it is also not able to reveal bugs that are hiding in these elements. Some program elements are considered more critical than others. For instance, a <b>division</b> <b>operator</b> might cause a division by zero error, or a system call may crash the program.|$|E
40|$|International audienceWe {{combine the}} {{concepts}} of gradual numbers and Kaucher arithmetic on extended intervals to deﬁne extended gradual interval (EGI) arithmetic in which subtraction and <b>division</b> <b>operators</b> are the inverse operators of addition and multiplication, respectively. Use of the proposed EGI operators can lead to non-monotonic gradual intervals that are not fuzzy subsets and cannot be represented by fuzzy intervals. In this context and when fuzzy representation results are desired, an approximation strategy is proposed to determine the nearest fuzzy interval of the non-monotonic gradual interval obtained. This approximation is viewed as an interval regression problem according to an optimization procedure. The EGI operators are applied to the common fuzzy weighted average (FWA) leading to a gradual weighted average (GWA) ...|$|R
40|$|This paper {{describes}} {{the conversion of}} nested loop programs into single assignment forms. The nested loop programs may contain the integer operators: integer division, floor, ceil,and modulo, in expressions and the stride, or step size, of for loops may be greater than one. The programs may be parametrized but must have static control. The conversion is done completely automatical by the tool ######. The output of HiPars is a single assignment program (SAP) and a dependence graph (DG). The description of the dependence graph is based on linearly bounded lattices. We will show {{the relation between the}} integer <b>division</b> <b>operators</b> in the SAP and linearly bounded lattices in the corresponding DG. KEYWORDS. Nested loop programs, data dependencies, single assignment programs, linearly bounded lattices. ...|$|R
40|$|The {{structural}} {{scheme of}} operators studying process control and {{management in the}} training complex is proposed for observation. Structural scheme includes the <b>division</b> of <b>operators</b> upon the subgroups according {{to the level of}} demonstrated knowledge. Also in the article the example of such divisions criteria is presented. </p...|$|R
5000|$|The slash {{is used as}} a <b>division</b> <b>operator</b> in most {{programming}} languages. The double slash is used by Rexx as a modulo operator, and Python (starting in version 2.2) uses {{a double}} slash for division which rounds any decimals down to the nearest integer. In Perl 6 the double slash {{is used as a}} [...] "defined-or" [...] alternative to ||. A dot and slash [...] is used in MATLAB and GNU Octave to indicate an element-by-element division of matrices.|$|E
5000|$|For example, the {{following}} code defines a binary operator [...] as safe division that avoids dividing by zero, using the Maybe monad and its constructors [...] and [...] The monadic values x and y {{may have the}} form Nothing or Just i, where i is an integer. The integer values contained within x and y are extracted into the plain values a and b, which are processed by the plain <b>division</b> <b>operator</b> [...] "" [...] only when b is not zero.|$|E
5000|$|...- Defining a safe <b>division</b> <b>operator</b> [...] "//" [...] (a [...] "monadic function") {{using the}} Maybe monad -- The {{expression}} x // y {{is defined as}} thex // y = -- bind binary operator (>>=) of the Maybe monad x >>= (\a -> [...] -- which takes as parameters 'x' and an anonymous function y >>= (\b -> [...] -- which divides x by y. if b == 0 then Nothing else Just (a / b))) -- The result value has type Maybe (Number)-- Example usages ("pipelines")Nothing // Just 10 -- This expression returns Nothing (by definition of the bind operator (>>=) in the Maybe monad)Just 10 // Just 5 -- This expression returns Just 2 (by definition of the // operator)Just 10 // Just 0 -- This expression returns Nothing (by definition of the // operator)(Just 10 // Just 0) // Just 2 -- This expression, a pipeline of two composed [...] "//" [...] calls, returns Nothing ...|$|E
50|$|The {{multiplier}} was removed, {{making the}} arithmometer a simple adding machine, {{but thanks to}} its moving carriage used as an indexed accumulator, it still allowed for easy multiplication and <b>division</b> under <b>operator</b> control. It {{was introduced in the}} UK at The Great Exhibition of 1851 and true industrial production started in 1851.|$|R
5|$|Python 2.2 changes integer {{division}} to round towards negative infinity, e.g. 7/3 == 2 and -7/3 == -3. The floor <b>division</b> // <b>operator</b> is introduced. So 7//3 == 2, -7//3 == -3, 7.5//3 == 2.0 and -7.5//3 == -3.0. Adding from __future__ import division causes a module to use Python 3.0 rules for division (see next).|$|R
40|$|A {{simplified}} neutrosophic set {{is characterized}} by a truth-membership function, an indeterminacy-membership function, and a falsity-membership function, which is a subclass of the neutrosophic set and contains the concepts of an interval neutrosophic set and a single valued neutrosophic set. It is a powerful structure in expressing indeterminate and inconsistent information. However, there has only been one paper until now—to the best of my knowledge—on the subtraction and <b>division</b> <b>operators</b> in the basic operational laws of neutrosophic single-valued numbers defined in existing literature. Therefore, this paper proposes subtraction operation and division operation for simplified neutrosophic sets, including single valued neutrosophic sets and interval neutrosophic sets respectively, under some constrained conditions to form the integral theoretical framework of simplified neutrosophic sets. In addition, we give numerical examples to illustrate the defined operations. The subtraction and division operations are very important in many practical applications, such as decision making and image processing...|$|R
