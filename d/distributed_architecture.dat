1666|3863|Public
5|$|The combat data {{system was}} {{procured}} separately to the submarine design; 14 companies {{were identified as}} capable of providing what the RAN wanted, from which eight were approached in January 1983 with a separate request for tender. Five responded: a consortium led by Rockwell International of the United States, Plessey of the United Kingdom, Signaal of the Netherlands, Sintra Alcatel of France, and a collaboration between the German Krupp Atlas Elektronik and the British Ferranti. Each tender was required to offer a system with a <b>distributed</b> <b>architecture,</b> {{despite the absence of}} an accepted definition for 'distributed computing' at that time, and had to show the cost of programming the software in Ada, although they could offer additional cost breakdowns for other programming languages.|$|E
25|$|However, such an {{approach}} means that every library call requires {{a considerable amount of}} overhead. RPC calls are much more expensive than calling a shared library that has already been loaded on the same machine. This approach is commonly used in a <b>distributed</b> <b>architecture</b> that makes heavy use of such remote calls, notably client-server systems and application servers such as Enterprise JavaBeans.|$|E
25|$|On March 14, 2010, the plugin {{framework}} {{and the new}} library system called Alexandria were announced. Both were completely rewritten as a <b>distributed</b> <b>architecture</b> with a REST HTTP/XML API opposed to the old monolithic one, less customizable. These were released with a new Plex version called Plex/Nine on August 30, 2010. The advantages of the new library {{is the ability to}} scan and sort the media even if the websites adding additional metadata and content are down. If the user had a custom filename layout organization, he can write his own parser. Parsers work exactly like Plex plugins using the new plugin framework with XPath parsing and Unicode support. The old Plex/Eight used the old XBMC scrapers which used regex encoded in XML which is considered much harder to program.|$|E
50|$|M&S {{has made}} {{significant}} progress in enabling users to link critical resources through <b>distributed</b> <b>architectures.</b>|$|R
30|$|<b>Distributed</b> <b>architectures</b> {{typically}} use a Peer-to-Peer protocol [20] {{that enables}} nodes to communicate directly without a centralised controller.|$|R
40|$|This review {{provides}} a gentle introduction to one-way quantum computing in <b>distributed</b> <b>architectures.</b> One-way quantum computation shows significant promise as a computational model for distributed systems, particularly those architectures which rely on probabilistic entangling operations. We review the theoretical underpinnings of one-way quantum computation {{and discuss the}} practical issues related to exploiting the one-way model in <b>distributed</b> <b>architectures.</b> Comment: Revised in light of review comments made on quantal...|$|R
50|$|<b>Distributed</b> <b>architecture</b> {{is just as}} {{scalable}} as the centralised model, {{however it}} has bandwidth usage advantages and inherent system management features that are essential for managing a larger server network. Operators who plan to deploy a relatively large system should therefore consider implementing a <b>distributed</b> <b>architecture</b> model right from the start. <b>Distributed</b> <b>architecture</b> requires intelligent and sophisticated content distribution technologies to augment effective delivery of multimedia contents over service provider's network.|$|E
5000|$|The ‘EFx Factory’ {{implements}} the [...]NET <b>Distributed</b> <b>Architecture</b> for Service-Oriented {{applications and}} services.|$|E
5000|$|Embrane Heleos - Virtual {{appliances}} that leverage a <b>distributed</b> <b>architecture</b> and was {{pioneered by}} Dante Malagrinò and Marco Di Benedetto in 2009.|$|E
40|$|International audienceThis paper studies parallelization {{schemes for}} {{stochastic}} Vector Quantization algorithms {{in order to}} obtain time speed-ups using distributed resources. We show that the most intuitive parallelization scheme does not lead to better performances than the sequential algorithm. Another distributed scheme is therefore introduced which obtains the expected speed-ups. Then, it is improved to fit implementation on <b>distributed</b> <b>architectures</b> where communications are slow and inter-machines synchronization too costly. The schemes are tested with simulated <b>distributed</b> <b>architectures</b> and, for the last one, with Microsoft Windows Azure platform obtaining speed-ups up to $ 32 $ Virtual Machines...|$|R
40|$|From the {{security}} point of view, one challenge for today's <b>distributed</b> <b>architectures</b> {{is to support}} interoperation between applications relying on different possibly inconsistent security policies. This paper proposes a practical approach {{for dealing with the}} coexistence of different security policies in <b>distributed</b> <b>architectures.</b> We introduce a model for specifying security policies in terms of security domains and access control rules. Then, we identify the set of operators for combining the specifications of sub-policies and we address the validity of the resulting policy according to {{the security}} properties of the sub-policies...|$|R
40|$|This paper studies parallelization {{schemes for}} {{stochastic}} Vector Quantization algorithms {{in order to}} obtain time speed-ups using distributed resources. We show that the most intuitive parallelization scheme does not lead to better performances than the sequential algorithm. Another distributed scheme is therefore introduced which obtains the expected speed-ups. Then, it is improved to fit implementation on <b>distributed</b> <b>architectures</b> where communications are slow and inter-machines synchronization too costly. The schemes are tested with simulated <b>distributed</b> <b>architectures</b> and, for the last one, with Microsoft Windows Azure platform obtaining speed-ups up to 32 Virtual Machines...|$|R
50|$|Similar to a <b>distributed</b> <b>architecture,</b> any complex SCADA can {{be reduced}} to {{simplest}} components and connected through communication protocols. In the case of a networked design, the system may be spread across more than one LAN network called a process control network (PCN) and separated geographically. Several <b>distributed</b> <b>architecture</b> SCADAs running in parallel, with a single supervisor and historian, could be considered a network architecture. This allows for a more cost effective solution in very large scale systems.|$|E
5000|$|Devices {{can talk}} {{directly}} {{to each other}} without requiring a server. The <b>distributed</b> <b>architecture</b> ensures {{that there is no}} central point of failure.|$|E
50|$|A <b>distributed</b> <b>architecture</b> is made {{possible}} by doing all the processing, mixing, encoding and encryption on the clients, relieving the servers and increasing scalability.|$|E
40|$|Semi-joins is {{the most}} used {{technique}} to optimize the treatment of complex relational queries on <b>distributed</b> <b>architectures.</b> However the overcost related to semi-joins computation can be very high due to data skew and to {{the high cost of}} communication in <b>distributed</b> <b>architectures.</b> In this paper we present a parallel equi-semi-join algorithm for shared nothing machines. The performance of this algorithm is analyzed using the BSP cost model and is proved to have asymptotic optimal complexity and perfect load balancing even for highly skewed data. This guarantees unlimited scalability in all situations for this key algorithm...|$|R
50|$|The third {{call was}} part of the H2020 Work Programme 2017. It {{combined}} the CAPS programme with <b>Distributed</b> <b>Architectures</b> for Decentralised Data Governance (ICT 11 2017 and ICT 12 2016) programme.|$|R
40|$|Abstract. From the {{security}} point of view, one challenge for today's <b>distributed</b> <b>architectures</b> {{is to support}} interoperation between applications relying on di erent possibly inconsistent security policies. This paper proposes a practical solution {{for dealing with the}} coexistence of di erent security policies in <b>distributed</b> <b>architectures.</b> We introduce a model for specifying security policies in terms of security domains, access control and information ow rules. Then, we identify the set of operators for combining the speci cations of sub-policies and we address the validity of the resulting policy according to {{the security}} properties of the sub-policies. ...|$|R
5000|$|Peer-to-peer—A <b>distributed</b> <b>architecture</b> {{without the}} need for central coordination. Participants are both {{suppliers}} and consumers of resources (in contrast to the traditional client-server model).|$|E
5000|$|OpenGate {{implements}} a <b>distributed</b> <b>architecture</b> {{designed to}} provide tools and functions for the development and deployment of GSM/GPRS/UMTS based wireless solutions. This architecture presents several components: ...|$|E
5000|$|A Net-centric Enterprise Architecture {{is defined}} in lay terms as a: [...] "massively <b>distributed</b> <b>architecture</b> with {{components}} and/or services available across and throughout an enterprise's entire lines-of-business." ...|$|E
40|$|From the {{security}} point of view, one challenge for today's <b>distributed</b> <b>architectures</b> {{is to support}} interoperation between applications relying on different possibly inconsistent security policies. This paper proposes a practical solution {{for dealing with the}} coexistence of different security policies in <b>distributed</b> <b>architectures.</b> We introduce a model for specifying security policies in terms of security domains, access control and information flow rules. Then, we identify the set of operators for combining the specifications of sub-policies and we address the validity of the resulting policy according to {{the security}} properties of the sub-policies. 1 Introduction Object-based <b>distributed</b> computing <b>architectures</b> 1 like CORBA (Common Object Request Broker Architecture) defined by the Object Management Group (OMG) [24], and the Telecommunication Intelligent Network Architecture proposed by the TINA consortium [26] are promising approaches to support large open distributed systems. Go [...] ...|$|R
30|$|Transfer security: <b>Distributed</b> <b>architectures,</b> massive {{resource}} sharing and virtual machine (VM) instances synchronization imply more {{data in transit}} in the cloud, thus requiring VPN mechanisms for protecting the system against sniffing, spoofing, man-in-the-middle and side-channel attacks.|$|R
40|$|International audienceThis paper {{presents}} many typical {{problems that}} are encountered when executing large scale scientific applications over <b>distributed</b> <b>architectures.</b> The causes and effects of these problems are explained and a solution for some classes of scientific applications is also proposed. This solution is {{the combination of the}} asynchronous iteration model with JACEP 2 P-V 2 which is a fully decentralized and fault tolerant platform dedicated to executing parallel asynchronous applications over volatile <b>distributed</b> <b>architectures.</b> We explain in detail how our approach deals with each of these problems. Then we present two large scale numerical experiments that prove the efficiency and the robustness of our approach...|$|R
50|$|Open {{mainframe}} is a mainframe-class server {{built on}} industry standard components that {{is capable of}} hosting both IBM mainframe and <b>distributed</b> <b>architecture</b> platforms such as Windows Server and Linux.|$|E
5000|$|Initially {{the project}} was named DataGate, renamed to eGate in the late 1990s with a new <b>distributed</b> <b>architecture.</b> Monk, a LISP variant was used for {{translation}} of the messages.|$|E
50|$|In response, and {{to satisfy}} members' {{concerns}} about privacy, SWIFT began {{a process of}} improving its architecture by implementing a <b>distributed</b> <b>architecture</b> with a two-zone model for storing messages (see Operations centers).|$|E
50|$|PM2 is an {{open-source}} distributed multithreaded {{programming environment}} designed to support efficiently distributed programs {{with a highly}} irregular behavior (e.g. branch and bound search, computation on sparse matrices, etc.) on <b>distributed</b> <b>architectures.</b> It is <b>distributed</b> under the GPL.|$|R
40|$|The # {{programming}} model {{attempts to}} address the needs of the high performance computing community for new paradigms that reconcile efficiency, portability, abstraction and generality issues on parallel programming for high-end <b>distributed</b> <b>architectures.</b> This paper provides a semantics for the compositiona...|$|R
40|$|MuPAD is {{a general}} purpose {{computer}} algebra system with two programming concepts for parallel processing: micro-parallelism for shared-memory machines and macroparallelism for <b>distributed</b> <b>architectures.</b> This article describes language instructions for both concepts, {{the current state of}} implementation, together with some examples...|$|R
5000|$|In the Eighties and Nineties Harmon was {{a senior}} {{consultant}} and head of Cutter Consortium's <b>Distributed</b> <b>Architecture</b> practice. From 1985 to 2000 he wrote Cutter newsletters, including expert systems strategies, CASE strategies, and component development strategies.|$|E
50|$|In {{contrast}} to similar tools like Iperf or Netperf {{it features a}} <b>distributed</b> <b>architecture,</b> where throughput and othermetrics are measured between flowgrind server processes. The Flowgrind client hasthe purpose to schedule such measurements and collect the measurement data.|$|E
5000|$|Though {{used for}} {{multi-user}} portfolio management, Spider {{does not have}} a server. It manages portfolios using the same software that manages individual projects. It does this with a <b>distributed</b> <b>architecture,</b> through software features and organisational procedures. This includes: ...|$|E
40|$|Abstract—Genetic {{algorithms}} {{are attractive}} to solve many search-based software engineering problems because they allow the easy parallelization of computations, which improves scalability and reduces computation time. In this paper, we present our experience in applying different <b>distributed</b> <b>architectures</b> to parallelize a genetic algorithm used {{to solve the}} concept identification problem. We developed an approach to identify concepts in execution traces by finding cohesive and decoupled fragments of the traces. The approach relies on a genetic algorithm, on a textual analysis of source code using latent semantic indexing, and on trace compression techniques. The fitness function in our approach has a polynomial evaluation cost and is highly computationally intensive. A run of our approach on a trace of thousand methods may require several hours of computation on a standard PC. Consequently, we reduced computation time by parallelizing the genetic algorithm {{at the core of}} our approach over a standard TCP/IP network. We developed four <b>distributed</b> <b>architectures</b> and compared their performances: we observed a decrease of computation time up to 140 times. Although presented in the context of concept location, our findings could be applied to many other searchbased software engineering problems. Keywords-Concept location; dynamic analysis; information retrieval; <b>distributed</b> <b>architectures.</b> I...|$|R
40|$|Projet EURECAMuPAD is {{a general}} purpose {{computer}} algebra system with two programming concepts for parallel processing: micro-parallelism for shared-memory machines and macro-parallelism for <b>distributed</b> <b>architectures.</b> This article describes language instructions for both concepts, {{the current state of}} implementation, together with some examples...|$|R
40|$|There is no {{distinction}} in a <b>distributed</b> object <b>architectures</b> between clients and server machines. � Each distributable entity is {{an object that}} provides services to other objects and receives services from other objects. � Object communication is through a middleware system called an object request broker. � Objects describe their interface using an interface description language (IDL) � Similar to WSDL <b>Distributed</b> object <b>architecture</b> object state interface Advantages of <b>distributed</b> object <b>architecture</b> � It allows the system designer to delay decisions on wher...|$|R
