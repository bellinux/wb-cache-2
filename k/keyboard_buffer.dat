20|8|Public
5000|$|KEYBUF (FreeDOS only) : Specifies {{the address}} of the {{relocated}} <b>keyboard</b> <b>buffer.</b>|$|E
50|$|A <b>keyboard</b> <b>buffer</b> is {{a section}} of {{computer}} memory used to hold keystrokes before they are processed.|$|E
50|$|On some systems, by {{pressing}} too many keys at once, the <b>keyboard</b> <b>buffer</b> overflows and will emit a beep from the computer's internal speaker.|$|E
50|$|The use of <b>keyboard</b> <b>buffers</b> is {{sometimes}} {{known from the}} user experience side as typeahead.|$|R
50|$|<b>Keyboard</b> <b>buffers</b> {{have long}} been used in {{command-line}} processing. As a user enters a command, they see it echoed on their terminal and can edit it before it is processed by the computer.|$|R
5000|$|... {{interface}} {{to various}} hardware (mouse, <b>keyboard,</b> bitmap frame <b>buffer,</b> disk, printer, network interface) ...|$|R
50|$|In {{the early}} days of the IBM PC, John Socha wrote a column for the now defunct {{magazine}} Softalk, where he published such programs as ScrnSave, KbdBuffer (extending the <b>keyboard</b> <b>buffer),</b> and Whereis (finding files on a hard disk).|$|E
50|$|On {{some early}} home computers, to {{minimize}} the necessary hardware, a CPU interrupt checked the keyboard's switches for key presses multiple times each second, and recorded the key presses in a <b>keyboard</b> <b>buffer</b> for the operating system or application software to read.|$|E
50|$|In XOSL-OW these {{stability}} {{issues have}} been solved by an improved A20 Line Switching algorithm and flushing the <b>keyboard</b> <b>buffer</b> before the XOSL boot manager hands over control to either the Ranish Partition manager, the Smart Boot Manager or the Operating System Bootloader.|$|E
5000|$|... #Caption: A 24-byte <b>keyboard</b> {{circular}} <b>buffer.</b> When the {{write pointer}} {{is about to}} reach the read pointer - because the microprocessor is not responding, the buffer will stop recording keystrokes and - in some computers - a beep will be played.|$|R
50|$|Some people combine {{touch typing}} and hunt and peck {{by using a}} {{buffering}} method. In the buffer method, the typist looks at the source copy, mentally stores one or several sentences, then looks at the keyboard and types out the buffer of sentences. This eliminates frequent up and down motions with the head and is used in typing competitions in which the typist is not well versed in touch typing. Not normally used in day-to-day contact with <b>keyboards,</b> this <b>buffer</b> method is used only when {{time is of the}} essence.|$|R
40|$|One is a small, {{portable}} {{printing calculator}} {{and the other}} is a hand-held version without a printer. Both versions feature a "smart " magnetic card reader, and each can run the other's programs. by Peter 0. Dickinson and William E. Egbert TWO POWERFUL NEW fully programmable per sonal calculators {{in the tradition of the}} HP- 65 (the first fully programmable pocket-sized scientific calculator) 1 are the pocket-sized HP- 67, Fig. 1, and the HP- 97, Fig. 2, a briefcase-portable calculator that has a built-in thermal printer, a <b>buffered</b> <b>keyboard,</b> and a large easy-to-read display. Both new calculators can read and record programs on magnetic cards using their built-in firmware-controlled magnetic card reader/recorders...|$|R
50|$|A {{program called}} MENU, closely {{resembling}} the PC utility XTree, facilitates complex file management tasks and {{can serve as}} a replacement shell. Other utilities allow to change disk names, search disks for files, undelete them, install <b>keyboard</b> <b>buffer,</b> edit system files (CONFIG.SYS and AUTOEXEC.BAT) and so on. A port of ARC (SEA's archiver, very popular before ZIP has appeared) gives archiving facilities.|$|E
5000|$|In {{time-sharing}} systems, {{the location}} of the buffer depends on whether communications is full-duplex or half-duplex. In full-duplex systems, keystrokes are transmitted one by one. As the main computer receives each keystroke, it ordinarily appends the character which it represents {{to the end of the}} <b>keyboard</b> <b>buffer.</b> The exception is control characters, such as [...] "delete" [...] or [...] "backspace" [...] which correct typing mistakes by deleting the character at the end of the buffer.|$|E
5000|$|... — This reassigns the key F10 {{to send to}} the <b>keyboard</b> <b>buffer</b> {{the string}} [...] "DIR" [...] and ENTER, which in the DOS command line would display the {{contents}} of the current directory. (MS-DOS ANSI.SYS only) This was sometimes used for ANSI bombs. This is a private-use code (as indicated by the letter p), using a non-standard extension to include a string-valued parameter. Following the letter of the standard would consider the sequence to end at the letter D.|$|E
40|$|Rux's goal is {{to become}} a safe {{general-purpose}} microkernel. It tries to take advantage of Rust's memory model [...] ownership and lifetime. While the kernel will be small, unsafe code should be kept minimal. This makes updating functionalities of the kernel hassle-free. Rux uses a design that is similar to seL 4. While there won't be formal verification in the short term, it tries to address some design issues of seL 4, for example, capability allocation. This nitial release is a functional microkernel with support of x 86 _ 64. Features include: 	Capability-base kernel-object management 	Take advantage of Rust's ownership system for memory safety 	Memory management, scheduling, IPC and hardware primitives (timer, <b>keyboard</b> and VGA <b>buffer...</b>|$|R
40|$|Computer use is {{essential}} for tasks such as e-mail, banking and social networking and is important for communication and independence in persons with aphasia. However, most evaluations of dysgraphia have investigated handwriting exclusively. Buchwald and Rapp (2009) evaluated dysgraphia in handwriting and described dissociated distinctions between orthographic long-term memory (O-LTM) and working memory (WM). Greater word-level errors (e. g., semantic) and frequency effects were indicative of O-LTM impairment. Greater nonword-level errors and length effects indicated a WM-level impairment where the graphemic buffer was less able to maintain orthographic representation for correct order and letter production. Cameron, Cubelli, and Della Sala (2002) posit a common orthographic buffer for handwriting and typing where the orthographic buffer supports a single allographic system with subsystems for handwriting and typing. Thus, a buffer-level impairment should in principle affect writing and typing similarly. However, one additional consideration in keyboard use is {{the potential impact of}} divided attention (between keyboard and screen) and visual search. Alternatively, the availability of letters may potentially aid in letter activation and/or selection. To examine these questions, this study compares writing-by-hand (WBH) and typing on QWERTY and ABC <b>keyboards.</b> Lexical or <b>buffer</b> level impairments should result in similar accuracy across modalities. However, participants with buffer level impairments may show increased or decreased keyboard performance depending on how keyboard use interacts with impairments. Potential differential effects across keyboards could also potentially be seen, since the QWERTY keyboard could recruit procedural memory in previously proficient users like those included in this study, though the ABC keyboard could provide a strategy for letter search. Methods. Seven English speaking participants with chronic aphasia due to stroke participated. A cognitive neuropsychologist ruled out visual scanning/spatial deficits and neglect. All had within average performance on the Ruff 2 & 7 accuracy, suggesting good visual search abilities. Participants reported premorbid type-by-touch abilities and > 30 hours/week of computer use. The Western Aphasia Battery revealed aphasia quotients from 73. 3 to 91 (3 anomic aphasia (Participants 400, 402, 500), 2 conduction aphasia (Participants 401, 404), and 2 Broca’s aphasia (participants 501, 502)). Stimuli were drawn from the Johns Hopkins Dyslexia and Dysgraphia Batteries (Goodglass & Caramazza, 1986). Three word sets were matched on number of words (49) and letters (268), frequency and length (4 - 8 letters). Participants were presented with pre-recorded words over headphones and were given 30 seconds to write each word in each modality. Order of modality was counterbalanced across participants. Each response was scored for letter (accuracy and position), word accuracy and error type. Error classifications were lexical (semantic, real word, morphological, phonologically plausible) or nonlexical (letter error (e. g., substitution) and nonword) (Buchwald & Rapp, 2009). No participants exhibited allographic errors. Chi-squares were conducted on letter, word and error results with the significance level set at. 01 due to multiple comparisons. Results. No accuracy or error type differences were observed for 5 participants. Nonword errors predominated for these participants. P 400 exhibited higher letter accuracy on both keyboards compared to WBH, with significantly more nonlexical errors on both keyboards compared to WBH. P 402 showed a reversed accuracy trend with WBH > QWERTY > ABC. Error patterns for P 402 were predominantly nonlexical across conditions. Discussion. A lack of accuracy or error differences for 5 participants indicates a neutral effect of keyboard use despite an error pattern suggestive of buffer-level impairment. However, P 402 ’s stepwise WBH-QWERTY-ABC accuracy decline suggests an interaction between a buffer-level impairment and keyboard use. Higher accuracy on the QWERTY compared to ABC keyboard may indicate recruitment of procedural memory on the QWERTY keyboard. P 402 's below average performance on the Trails B may be suggestive of more impaired executive function difficulties as compared to the other participants who scored within the average range (except for P 404). P 400 ’s higher keyboard accuracy may suggest aided letter activation and/or selection not available in WBH despite producing more letter-level errors in both keyboards. These findings suggest that there is the potential for dissociation in performance across handwriting and keyboard modalities. Interestingly, no difference was observed between the keyboards, despite more familiarity with QWERTY keyboards in this group. Additional (planned) length and frequency analyses will aid in interpretation of data...|$|R
5000|$|Typeahead is {{a feature}} of {{computers}} and software (and some typewriters) that enables users to continue typing regardless of program or computer operation—the user may type in whatever speed is desired, and if the receiving software is busy {{at the time it}} will be called to handle this later. Often this means that keystrokes entered will not be displayed on the screen immediately. This programming technique for handling uses what is known as a <b>keyboard</b> <b>buffer.</b>|$|E
50|$|System request (often {{abbreviated}} SysRq or Sys Req) {{is a key}} {{on personal}} computer keyboards that has no standard use. Introduced by IBM with the PC/AT, {{it was intended to}} be available as a special key to directly invoke low-level operating system functions with no possibility of conflicting with any existing software. A special BIOS routine — software interrupt 0x15, subfunction 0x85 — was added to signal the OS when SysRq was pushed or released. Unlike most keys, when it is pressed nothing is stored in the <b>keyboard</b> <b>buffer.</b>|$|E
5000|$|One might plokta {{when the}} abort {{procedure}} {{for a program}} is not known, or when {{trying to figure out}} if the system is just sluggish or really hung. Plokta can also be used while trying to figure out any unknown key sequence for a particular operation. Someone going into [...] "plokta mode" [...] usually places both hands flat on the keyboard and mashes them down, hoping for some useful response. This will sometimes eventually result in beeping sounds from an unresponding computer as its <b>keyboard</b> <b>buffer</b> fills up.|$|E
5000|$|While both [...] and [...] {{combination}} {{are commonly}} implemented {{as a way}} of breaking the execution of a console application, they are also used for similar effect in integrated development environments. Although these two are often considered interchangeable, compilers and execution environments usually assign different signals to these. Additionally, in some kernels (e.g. miscellaneous DOS variants) [...] is detected only at the time OS tries reading from a <b>keyboard</b> <b>buffer</b> and only if it's the only key sequence in the buffer, while [...] is often translated instantly (e.g. by INT 1Bh under DOS). Because of this, [...] is usually a more effective choice under these operating systems; sensitivity for these two combinations can be enhanced by the [...] CONFIG.SYS statement.|$|E
50|$|Originally on IBM PCs, {{the user}} could {{hold down the}} Alt key and type a decimal number on the keypad. The system BIOS would place the {{corresponding}} code into the <b>keyboard</b> <b>buffer</b> so that, for software using the BIOS for character input, it would look (almost) as if the code had been entered by a single keystroke. Applications reading keystrokes from the BIOS would behave according to what action they associate with that code. Some would interpret the code as a command, but often it would {{be interpreted as a}} code to be placed on the screen at the location of the cursor, thus displaying the corresponding 8-bit character from the current code page. On the original IBM PC this was CP437, see that article for a list of the numbers accepted.|$|E
50|$|To improve performance, a {{trick was}} used by some DOS programmers, for example, to have one segment that has access to program data (such as from F800:0000 to F800:7FFF, {{pointing}} to the physical addresses 0x000F8000 - 0x000FFFFF) {{as well as the}} I/O data (such as the <b>keyboard</b> <b>buffer)</b> that was located in the first memory segment (with addresses F800:8000 to F800:FFFF pointing to the physical addresses 0x00000000 to 0x00007FFF).. The address wrap was also used by MS-DOS itself, to implement the CALL 5 entry point in the Program Segment Prefix; the CALL 5 handler was at physical address 0x000000C0 but for CP/M compatibility, its offset had to match the segment size (usually 0xFEF0). The only way to reconcile them was to choose a segment value that when added to 0xFEF0, resulted in a physical address of 0x001000C0, which would wrap around to 0x000000C0.|$|E
5000|$|The DFS also {{supports}} {{a means to}} start up disc software based on a key sequence. If the shift key is held while the machine is soft or hard reset, the DFS checks drive 0 for a disc containing a positive boot flag. The boot flag is either 0 (ignore), 1 (load file), 2 (run machine code file) or 3 ("execute" [...] script). If the boot flag is positive, a file called [...] is looked for and loaded into memory (1), loaded and executed as machine code (2) or fed into the <b>keyboard</b> <b>buffer</b> (3). Option 3 reads [...] "EXEC" [...] files, text macro files used as primitive shell scripts. These are not true shell scripts but simply a series of keys to be typed, like a recording to play back. Thus, they cannot loop or branch unless they input such code into the BASIC interpreter. As well as being used during a reset, they can be executed at any time with the operating system's [...] command. EXEC files are file system independent.|$|E
5000|$|In {{conjunction}} with the alternative DOS keyboard and console drivers FreeKEYB and K3PLUS, [...] also served {{as part of a}} copy & paste facility between applications. Compared to the standard keyboard driver KEYB these drivers offered a number of extensions including an extended keystroke buffer with key stacking facility, macro recorder and a second cursor called CopyCursor, which could be invoked on demand (by default on pressing [...] or the middle mouse button) and freely moved on the screen using the cursor keys or the mouse, even outside the area reachable by the standard cursor in the running application. Once invoked, pressing [...] (or the left mouse button) the characters under the CopyCursor could be stuffed, one after another, into the <b>keyboard</b> <b>buffer,</b> from where they would be read by the running application as emulated key (or Alt Numpad) input, thereby typically showing up at the location of the standard cursor. The CopyCursor would move to the next screen position after each [...] (or backwards with each [...] ). Normal keyboard input was still possible while the CopyCursor was enabled, and the user could switch between the two cursors by toggling the [...] hotkey again. Pressing [...] or [...] would exit the CopyCursor, so that, on its next invocation, it would show up at the position of the standard cursor again rather than at its previous location. If the screen contents was scrolled, the position of the CopyCursor would move accordingly until reaching the display limits. With [...] activated, keypresses would still reach the normal keystroke buffer, while CopyCursor input would be stacked up internally for later use in a second queue, dynamically maintained within the extended keystroke buffer. Thereby, it was possible to [...] "collect" [...] selected screen output from different programs and spool out the data much later while within yet another application by toggling [...] off again. It was also possible to use this as input into the macro recorder for later use as scrap macro. Since this {{was an integral part of}} these keyboard drivers, it was fully transparent to running software and therefore worked with virtually any DOS programs, including at the command prompt, temporary shelled programs and task switchers.|$|E
40|$|Meaningful {{human factors}} {{applications}} {{to the design}} of human-computer tasks require a quantitative data base that describes operator behavior as a function of various independent variables. Three classes of metrics (operator satisfaction ratings, work-sampling procedures, and embedded performance measurement) are described as important measures in evaluat-ing a human-computer interface used to enter and update personnel records. Polynomial regression procedures were used to generate functional relationships between each of these metrics and four independent variables representing system delay, display rate, keyboard echo rate, and <b>keyboard</b> <b>buffer</b> length. Each of the 22 separate dependent variables showed different functional relationships among the four systems variables, but overall system delay and keyboard echo rate were the major determiners of operator behavior. Additionally, the three classes of metrics were combined into three underlying interface dimensions relating to operator production, waiting, and planning activities...|$|E
40|$|Keyloggers are a {{prominent}} class of malware that harvests sensitive data by recording any typed in information. Key-logger implementations strive {{to hide their}} presence using rootkit-like techniques to evade detection by antivirus and other system protections. In this paper, we present a new approach for implementing a stealthy keylogger: we explore the possibility of leveraging the graphics card as an alterna-tive environment for hosting the operation of a keylogger. The key idea behind our approach is to monitor the system’s <b>keyboard</b> <b>buffer</b> directly from the GPU via DMA, without any hooks or modifications in the kernel’s code and data structures besides the page table. The evaluation of our pro-totype implementation shows that a GPU-based keylogger can effectively record all user keystrokes, store them in the memory space of the GPU, and even analyze the recorded data in-place, with negligible runtime overhead. 1...|$|E
40|$|In 2009, {{security}} researchers {{discovered a}} new, very powerful rootkit environment on x 86 platforms [1]. That environment {{is based on}} Intel's Active Management Technology (iAMT) [2], which is completely isolated from the host. One part of iAMT is implemented as an embedded my-controller in the platform's memory controller hub. That my-controller is called Manageability Engine (ME) and includes a processor (ARCtangent-A 4), read-only memory (ROM), {{static random access memory}} (SRAM) and direct memory access (DMA) engines. Furthermore, iAMT provides an isolated network channel (out-of-band (OOB) communication). To illustrate the power of the stealth enviroment, [1] called the iAMT environment in conjunction with rootkits "ring - 3 ", following the x 86 ring protection model. For our evaluation we implemented a prototype in form of a USB keyboard keystroke logger [3]. 1 Since we were unable to get an Intel developer board providing the "ring - 3 " environment, we had to use the exploit discovered by [1] to infiltrate our target platform. We monitor the <b>keyboard</b> <b>buffer</b> of the Linux based target platform via DMA. To find the physical address of the <b>keyboard</b> <b>buffer</b> we apply a search algorithm, that finds the USB product string and follows some pointers to the structure containing the buffer address. To exfiltrate captured keystrokes our prototype uses iAMT's OOB communication capabilities. [1] discussed countermeasures against "ring - 3 " rootkits, but they also provide approaches to defeat such countermeasures. Furthermore, it is doubtful if all the proposed countermeasures can be applied in practice. 2 The goal of our evaluation is to find a reliable detection mechanism for "ring - 3 " rootkits. We assume that we can provoke delays when accessing the same resources as our prototype. For example, our prototype has to scan the host memory to find certain data structures and it also has use the network interface card to send keystroke codes. Another possibility is to initiate various DMA transfers using multiple devices. Only one device can be the bus master at a certain point in time. The next step is to design an experimental set-up that allows the measurement of delays and finally derive a reliable detection mechanism for "ring - 3 " rootkits...|$|E

