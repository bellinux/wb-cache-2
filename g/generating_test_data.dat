85|10000|Public
50|$|However, Random Test Data Generation {{is usually}} {{used as a}} {{benchmark}} as it has the lowest acceptable rate of <b>generating</b> <b>test</b> <b>data.</b>|$|E
5000|$|A program usually {{consists}} of modules which then itself {{consists of}} functions. Two solutions {{have been proposed}} for <b>generating</b> <b>test</b> <b>data</b> for such functions: ...|$|E
50|$|The ASC-15 {{was first}} flown on SA-5, the first Saturn I Block II vehicle {{and the first}} to achieve orbit. It was a {{passenger}} on this mission, not guiding the vehicle but <b>generating</b> <b>test</b> <b>data</b> for later evaluation. The active guidance system on SA-5 was similar to that of earlier flights. The passenger system was the ASC-15 and the ST-124 inertial platform. Guidance was open loop; that is guidance commands were functions only of time. SA-5 also saw the introduction of the Instrument Unit.|$|E
50|$|Test <b>data</b> generator: <b>Generates</b> <b>test</b> <b>data</b> for {{the program}} to be tested.|$|R
40|$|Testing is an {{important}} activity in software development. Unfortunately till today testing is done manually {{by most of the}} industry due to high cost and complexity of automation. Automated testing can reduce the cost of software significantly. Automated Software Test Data Generation is an activity that in the course of software <b>testing</b> automatically <b>generates</b> <b>test</b> <b>data</b> for the software under test. Most of the automated <b>test</b> <b>data</b> generation uses constraint solver to <b>generate</b> <b>test</b> <b>data.</b> But it cannot <b>generate</b> <b>test</b> <b>data</b> when the constraints are not solvable. Although method can be found to <b>generate</b> <b>test</b> <b>data</b> even if the constraints are unsolvable, but it is poor in terms of code coverage. In this paper, we propose a <b>test</b> <b>data</b> generation method to improve test coverage and to avoid the unsolvable constraints problem. Our method is based on the individual constraints and same or dependent variable to create the path table which holds the information about the path traversed by various input <b>test</b> <b>data.</b> For <b>generating</b> unique <b>test</b> <b>data</b> for all the linearly independent feasible path we created equivalence class from the path table on the basis of path traversed by the various input <b>test</b> <b>data.</b> The input data is taken based on individual constraints or boundary value. Our results are compared with cyclomatic complexity and number of possible infeasible paths. The comparison shows the effectiveness of our method...|$|R
5000|$|Test vector {{generator}} {{is a program}} used to automatically <b>generate</b> <b>test</b> <b>data</b> for use in automated testing of software. This can <b>generate</b> many individual <b>test</b> vectors.|$|R
40|$|The {{application}} of genetic algorithms in automatically <b>generating</b> <b>test</b> <b>data</b> has aroused broad concerns and obtained delightful achievements in recent years. However, {{the efficiency of}} genetic algorithm-based test data generation for path testing needs to be further improved. In this paper, we establish a mathematical model of <b>generating</b> <b>test</b> <b>data</b> for multiple paths coverage. Then, a multipopulation genetic algorithm with individual sharing is presented to solve the established model. We not only analyzed {{the performance of the}} proposed method theoretically, but also applied it to various programs under test. The experimental results show that the proposed method can improve the efficiency of <b>generating</b> <b>test</b> <b>data</b> for many paths’ coverage significantly...|$|E
40|$|Copyright © 2014 X. Yao and D. Gong. This is an {{open access}} article {{distributed}} under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The application of genetic algorithms in automatically <b>generating</b> <b>test</b> <b>data</b> has aroused broad concerns and obtained delightful achievements in recent years. However, the efficiency of genetic algorithm-based test data generation for path testing needs to be further improved. In this paper, we establish a mathematical model of <b>generating</b> <b>test</b> <b>data</b> for multiple paths coverage. Then, a multipopulation genetic algorithm with individual sharing is presented to solve the established model. We not only analyzed {{the performance of the}} proposed method theoretically, but also applied it to various programs under test. The experimental results show that the proposed method can improve the efficiency of <b>generating</b> <b>test</b> <b>data</b> for many paths ’ coverage significantly. 1...|$|E
30|$|A method {{complementary}} to {{our approach}} {{is described by}} Harman et al. Testability transformation results in a transformed program {{to be used by}} a test-data generator to improve its ability of <b>generating</b> <b>test</b> <b>data</b> for the original program [22].|$|E
40|$|In {{software}} <b>testing</b> process, <b>test</b> <b>data</b> generation {{represents an}} important step for high quality software, even for mobile devices. As proposed in previous works, a potential source for random data generation {{is represented by the}} UI layout files that are used for almost all mobile platforms (Android, iOS, Windows Phone/Mobile). This paper continues the previous work and presents a <b>test</b> <b>data</b> generation system based on Android layout files. The <b>test</b> <b>data</b> generator uses DSL files as input and <b>generates</b> <b>test</b> <b>data</b> that conform to several <b>testing</b> principles. The <b>generated</b> <b>test</b> <b>data</b> could be stored in XML files or any format required by the testing frameworks...|$|R
40|$|The {{study of}} {{automatically}} <b>generate</b> <b>test</b> <b>data</b> based on evolutionary algorithm method {{focuses on the}} path coverage direction. The key problem is how to construct a suitable and has a good orientation of the fitness function to evaluate {{the quality of a}} <b>test</b> <b>data.</b> This paper introduces several evolution test methods, shows its advantages and problems it can effectively solve, and proposes an improved evolutionary <b>test</b> <b>data</b> generation method, which can <b>generate</b> better <b>test</b> <b>data...</b>|$|R
40|$|Abstract — As the {{complexity}} of software is increasing, <b>generating</b> an effective <b>test</b> <b>data</b> has become a necessity. This necessity has increased the demand for techniques that can <b>generate</b> <b>test</b> <b>data</b> effectively. This paper proposes a <b>test</b> <b>data</b> generation technique based on adequacy based testing criteria. Adequacy based testing criteria uses the concept of mutation analysis to check the adequacy of <b>test</b> <b>data.</b> In general, mutation analysis is applied after the <b>test</b> <b>data</b> is <b>generated.</b> But, in this work, we propose a technique that applies mutation analysis {{at the time of}} <b>test</b> <b>data</b> generation only, rather than applying it after the <b>test</b> <b>data</b> has been <b>generated.</b> This saves significant amount of time (required to <b>generate</b> adequate <b>test</b> cases) as compared to the latter case as the total time in the latter case is the sum of the time to <b>generate</b> <b>test</b> <b>data</b> and the time to apply mutation analysis to the <b>generated</b> <b>test</b> <b>data.</b> We also use genetic algorithms that explore the complete domain of the program to provide near-global optimum solution. In this paper, we first define and explain the proposed technique. Then we validate the proposed technique using ten real time programs. The proposed technique is compared with path testing technique (that use reliability based testing criteria) for these ten programs. The results show that the adequacy based proposed technique is better than the reliability based path testing technique and there is a significant reduce in number of <b>generated</b> <b>test</b> cases and time taken to <b>generate</b> <b>test</b> cases...|$|R
40|$|Abstract — Software {{testing is}} a labor {{intensive}} and takes very much effort in software development process. There are many aspects in software testing to assurance quality of software. Gray-box testing {{is a combination}} of white-box testing and blackbox testing. In gray-box testing, test data is generated from the specification which describes the behavior and data structure of the system. In this paper, a frame work for automatically <b>generating</b> <b>test</b> <b>data</b> from gray-box method is proposed. The proposed framework is pluggable; therefore it can be used in many test generation approaches. Artificial intelligent is contemplated in this research, especially genetic algorithm. UML state diagram is a specification for <b>generating</b> <b>test</b> <b>data</b> because it is similar to control flow graph. Anyway, the proposed framework still needs many further research and investigation. Index Terms — test data generation, gray-box testing, artificial intelligence, genetic algorithm I...|$|E
40|$|Abstract Dillencourt [7] gives a {{constructive}} proof for the realizability as a Delaunay triangulation of any triangulation {{of the interior}} of a simple polygon. A naive implementation of the construction will take O(n 2) time. I give a simple O(n) algorithm for this problem. An application of this algorithm is <b>generating</b> <b>test</b> <b>data</b> for algorithms that process convex polygons...|$|E
40|$|A {{number of}} {{research}} focus on test cases and their generation from dynamic models. In this {{paper we propose}} an approach for <b>generating</b> <b>test</b> <b>data</b> for these tests, that we derive from formal constraints expressed in a static model. This approach complements an overall quality development framework that we are currently developing in our reseach team and which is also introduced here...|$|E
40|$|A {{number of}} {{approaches}} {{have been proposed}} to automatically <b>generate</b> <b>test</b> <b>data</b> to traverse a given path in a program. In this paper, we present a program execution based approach to <b>generate</b> <b>test</b> <b>data</b> for a given path. The technique derives a desired input for a test path by iteratively refining an arbitrarily chosen input. A set of linear constraints on the increments to the input are derived to refine the input. We solve this constraint set using a Unified Numerical Approach (UNA) developed in this paper. Our technique can generate both integer and floating point inputs as well as handle arrays and loops. We determine a basis set of paths for a program and use our technique to <b>generate</b> <b>test</b> <b>data</b> for this set. We implemented and experimentally evaluated our technique. We present results of generating input for scientific programs. The experimental {{results show that the}} technique is effective in that it generates input for most of the paths in the basis sets and also efficiently detects [...] ...|$|R
50|$|Random <b>test</b> <b>data</b> {{generation}} {{is probably the}} simplest method for generation of <b>test</b> <b>data.</b> The advantage {{of this is that}} {{it can be used to}} generate input for any type of program. Thus to <b>generate</b> <b>test</b> <b>data</b> we can randomly generate a bit stream and let it the represent the data type needed. However, random <b>test</b> <b>data</b> generation does not <b>generate</b> quality <b>test</b> <b>data</b> as it does not perform well in terms of coverage. Since the data generated is based solely on probability it cannot accomplish high coverage as the chances of it finding semantically small faults is quite low.|$|R
40|$|Black-box and white-box testing are the {{two major}} {{techniques}} for unit testing. In black-box testing, no information about the internal structure of the program under testing is available. However, in white-box testing, a complete source code or the internal structure is available. Basis path testing is a white-box testing technique that uses a control flow graph (CFG) of a given program to generate a basis set of independent of paths for the CFG. Different techniques have been proposed to <b>generate</b> <b>test</b> <b>data</b> that cover all the paths of a basis set. In this thesis, we implemented an interactive tool that performs three tasks: - constructs a control flow graph of a given program based on the pseudocode and {{information provided by the}} user; - computes a basis set of independent paths of the control flow graph; - <b>generates</b> <b>test</b> <b>data</b> using genetic algorithms to exercise all basis paths. We evaluated the performance of different mutation operators for the genetic algorithm based on the percentage of basis paths covered by the <b>generated</b> <b>test</b> <b>data.</b> Experiments show that the use of two known mutation operators, input value and one-point crossover, provide the best path coverage for the programs tested...|$|R
40|$|Abstract—Efficiently <b>generating</b> <b>test</b> <b>data</b> {{is one of}} the key testing {{requirements}} of automated model-based test case generation. Keeping this in mind and driven by the needs of our industrial partners, we propose an improvement in heuristics that we previously defined to generate test data from OCL constraints using search algorithms. We evaluate our improved heuristics using two empirical studies with thre...|$|E
40|$|Abstract — The hidden {{states of}} objects create {{a barrier to}} {{designing}} and <b>generating</b> <b>test</b> <b>data</b> automatically. For example, the state of an object has to be established indirectly through a sequence of method invocations. For a non-trivial class, however, {{it is extremely difficult}} for a randomly-chosen sequence of method invocations to construct an object successfully, as each invocation has to satisfy the state invariants. Nonetheless, automated random testing can reduce the cost of testing dramatically and has strong potential for finding errors that are difficult to find in other ways because it eliminates the subjectiveness in constructing test data. We propose a new approach to <b>generating</b> <b>test</b> <b>data</b> automatically for Java classes annotated with JML specifications. The key idea underlying our approach is to construct an object incrementally in that each method call in the sequence is checked before the next call is chosen. We use JML’s runtime assertion checker to chec...|$|E
40|$|Path {{testing is}} one of the areas covered in {{structural}} testing. In this process, it is a key challenge to search for a set of test data in the whole search space to satisfy path coverage. Thus, finding an efficient method for <b>generating</b> <b>test</b> <b>data</b> automatically is a key issue in software testing. This paper proposed a method based on Negative Selection Algorithm (NSA) for <b>generating</b> <b>test</b> <b>data</b> to satisfy the path coverage criterion. The results show that NSA could reduce the number of test data generated and improve the coverage percentage, as well as enhance the efficiency of the test data generation process. To evaluate the performance of the method, results from the proposed method were compared with random testing and a previous work that used Genetic Algorithm and Ant Colony Optimization. The results demonstrate that NSA outperforms other methods in reducing the number of test data that cover all program paths even the difficult ones...|$|E
40|$|This {{dissertation}} {{addresses the}} problem of automated <b>test</b> <b>data</b> generation for commonly used coverage based criteria. A new program execution based approach to automated <b>test</b> <b>data</b> generation using iterative relaxation methods has been developed. In this approach, <b>test</b> <b>data</b> generation is initiated with an arbitrarily chosen input, which is iteratively refined using a relaxation technique to generate the desired input. New algorithms to <b>generate</b> <b>test</b> <b>data</b> for statement, branch, data flow and path coverage have been developed. They are general in their applicability as they can <b>generate</b> <b>test</b> <b>data</b> for programs with branch predicates that compute linear and nonlinear functions of input. They can detect linear infeasible paths and can handle programs using arrays, records, pointers and loops. A new code transformation method to handle <b>test</b> <b>data</b> generation for functions with pointer inputs has been developed. A new method called Unified Numerical Approach has also been developed to compute a real and an integer feasible solution {{of a set of}} linear constraints. It enables the <b>test</b> <b>data</b> generation algorithms developed in this dissertation to handle programs that have both integer and floating point inputs. The experimental evaluation reveals that these methods automatically <b>generated</b> <b>test</b> <b>data</b> that covers a large percentage of coverage elements. The average time taken to <b>generate</b> a <b>test</b> case was of the order of a few seconds. The experiments also revealed their power in detecting infeasible linear paths as well as in indicating potentially infeasible nonlinear paths. ...|$|R
40|$|Abstract. This paper {{proposes a}} genetic algorithm-based method to <b>generate</b> <b>test</b> cases. This method {{provides}} information for test case generation using state machine diagrams. Its feature is realizing automation through fewer <b>generated</b> <b>test</b> cases. In terms of automatic generation of <b>test</b> <b>data</b> based on path coverage, {{the goal is}} to build a function that can excellently assess the <b>generated</b> <b>test</b> <b>data</b> and guide the genetic algorithms to find the targeting parameter values...|$|R
30|$|Rodrigo Fraxino Araujo, Marcio Eduardo Delamaro and José Carlos Maldonado {{address the}} problem of testing {{critical}} embedded systems. They describe an experimental evaluation of the pairwise combinatorial approach as a technique to <b>generate</b> <b>test</b> <b>data</b> applied specifically to Simulink-like models, also introducing an associated computational tool.|$|R
40|$|International audienceThis {{extended}} abstract outlines a model-based {{approach for}} <b>generating</b> <b>test</b> <b>data</b> {{to assess the}} robustness of computer vision (CV) solutions {{with respect to a}} given task or application. The outlined approach enables the automatic generation of test data with a measurable coverage of optical situations both typical as well as critical for a given application. In addition, expected results are generated, all with almost no manual effort...|$|E
40|$|This paper {{discusses}} {{the evaluation of}} the electronic cash counterfeit threat scenarios using micro dynamic simulation. This modeling technique provides information needed for the quantification of economic risk exposure in conjunction with other analytical tools. It also allows {{the evaluation of the}} effectiveness of various on-chip risk management capabilities. And by <b>generating</b> <b>test</b> <b>data,</b> it allows the assessment of the effectiveness of the host system based counterfeit transaction detection models...|$|E
30|$|The code shows {{a single}} {{decision}} with one condition inside. In this concrete example it is valid {{to define the}} scope of decision coverage (or MCDC) as the single MATLAB/Simulink element. The generated source code for this element contains the whole decision, thus <b>generating</b> <b>test</b> <b>data</b> for decision coverage (or MCDC) based on the hidden control-flow of the Switch element results in a full decision coverage (or MCDC) at source code level.|$|E
25|$|RowGen is {{designed}} to <b>generate</b> <b>test</b> <b>data</b> in production table, file, and report formats for prototype database population, compliance, outsourcing, and application prototyping projects. RowGen's GUI parses data models to define table layouts and relationships so database test sets are structurally and referentially correct. RowGen can also transform and format <b>test</b> <b>data</b> during its generation.|$|R
40|$|Abstract – Test (input) data {{generation}} {{is important for}} the algorithms/software/hardware testing. The previous researches on <b>test</b> <b>data</b> generation motivate us to find some meaningful information of <b>generated</b> <b>test</b> <b>data.</b> In this paper, we differentiate the <b>test</b> (input) <b>data</b> space (i. e., problem instance space) from the output data space (i. e., solution space), by examining the <b>test</b> <b>data</b> <b>generated</b> in terms of optimality (one of the performance measures). We investigate the problem instance space of the 0 / 1 knapsack problem, by calculating some kind of cost-distance correlation; the correlation was quite different from those in well-known combinatorial optimization problems. Also, we improved a greedy algorithm of the 0 / 1 knapsack problem by <b>generated</b> <b>test</b> <b>data.</b> The improved algorithm showed superiority to the original one under 10, 000 random instances. This paper presents some promising values of the researches on the <b>test</b> <b>data</b> space and the <b>test</b> <b>data</b> generation for improving the tested module...|$|R
30|$|We {{can observe}} that the works do {{not deal with}} the mutation-based <b>test</b> <b>data</b> {{generation}} as a multi-objective problem. In addition to this, all {{of them do not}} address mutation and combinatorial testing at the same time. To satisfy both criteria can improve the quality of the <b>generated</b> <b>test</b> <b>data.</b> Moreover, our approach allows reducing costs.|$|R
40|$|Constraint-based {{testing is}} a novel way of <b>generating</b> <b>test</b> <b>data</b> to detect {{specific}} types of common programming faults. The conditions under which faults will be detected are encoded as mathematical systems of constraints in terms of program symbols. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraint systems and solves them to create test cases {{for use by the}} Mothra testing system. Experimental results from using Godzilla show that the technique can produce test data that is very close in terms of mutation-adequacy to test data that is produced manually, and at substantially reduced cost. Additionally, these experiments have suggested a new procedure for unit testing, where test cases are viewed as throw-away items rather than scarce resources. 1 INTRODUCTION This paper describes experimental results that are based on a new technique for <b>generating</b> <b>test</b> <b>data.</b> This technique, called constraint-based testing (CBT), uses the source code to automatically generate test data that attempts to satisfy the mutation-adequacy criteria. Elsewhere, we describe the technique [9, 12], and the details and algorithms of the implementation [29]; here we describe a set of experiments that measure CBT...|$|E
40|$|This paper {{presents}} an approach for <b>generating</b> <b>test</b> <b>data</b> for unit-level, and possibly integration-level, testing based on sampling over intervals of the input probability distribution, i. e., {{one that has}} been divided or layered according to criteria. Our approach is termed "spathic" as it selects random values felt to be most likely or least likely to occur from a segmented input probability distribution. Also, it allows the layers to be further segmented if additional test data is required later in the test cycle...|$|E
40|$|This work {{presents}} {{results on}} applying {{recent advances in}} automatic test generation for Java programs based on Design-by-ContractTM specifications on two real world ap-plications. It therefore extends an existing tool with both, already well-known approaches {{and the first time}} ever with a SMT solver. The results show that those fancy techniques do not matter since the most important challenge in this area is still <b>generating</b> <b>test</b> <b>data</b> that conform to their speci-fication- at least as soon as it comes to real world applica-tions...|$|E
40|$|Abstract: Many {{software}} testing techniques are targeted on <b>test</b> <b>data</b> generation. Only {{a few of}} them provide an automatic way to verify if software behaves correctly using <b>generated</b> <b>test</b> <b>data.</b> We propose to use software model as imprecise test oracle. UML modelling language extension OCL can be used as test oracle. Imprecise OCL constraints can be viewed as expressions which define expected results within some ranges of possible values. Imprecise OCL constraints can be viewed as expressions which define expected results within some ranges of possible values. When software is executed using <b>generated</b> <b>test</b> <b>data</b> the output is verified against imprecise OCL constraints. If output does not satisfy imprecise OCL constrains, unit under test definitely contains bugs. And if output satisfies imprecise OCL constraints the tester can assume that unit under test has no bugs. Key words: OCL, {{software testing}}, test oracle...|$|R
40|$|Software Testing is a {{approach}} where different {{errors and}} bugs {{in the software}} are identified. To test a software we need the <b>test</b> <b>data.</b> In this thesis, we have developed the approach to <b>generate</b> <b>test</b> <b>data</b> automatically from some initial random <b>test</b> <b>data</b> using Evolutionary Algorithms (EA) and test the software to detect the presence of errors, if any. We have taken two measures, they are path coverage and adequacy criterion to test the validation of our approach. In our first approach, we have used simple Genetic Algorithm (GA) to find the <b>test</b> <b>data.</b> We then used an memtic algorithm to curb the difficulties faced by using GA. We are using the instrumented program to find the paths. We then represent the program into a Control Flow Graph (CFG). We have used genetic algorithm to find the more optimal <b>test</b> <b>data</b> that covers all the feasible test paths from some initial random <b>test</b> <b>data</b> automatically. Path coverage based <b>testing</b> approach <b>generates</b> reliable <b>test</b> cases. A test case set is reliable if it's execution ensures that the program is correct on all its inputs. But, Adequacy requires that the test case set detect faults rather than show correctness. Hence, for adequacy based testing we uses the concept of mutation analysis. Here, we have taken the mutation score as our fitness function in the approach. We find out the mutation score from using mutation testing based tool called "MuJava". And then <b>generate</b> <b>test</b> <b>data</b> accordingly. We applied a more complex hybrid approach to <b>generate</b> <b>test</b> <b>data.</b> This algorithm is a hybrid version of genetic algorithm. It produces better results than the results generated by using GA. Also it curbs various problems faced by G...|$|R
40|$|Although {{it is well}} {{understood}} to be a generally undecidable problem, a number of {{attempts have been made}} over the years to develop systems to automatically <b>generate</b> <b>test</b> <b>data.</b> These approaches have ranged from early attempts at symbolic execution to more recent approaches based on, for example, dynamic data flow analysis or constraint satisfaction. Despite their variety (and varying degrees of success), all the systems developed have involved a detailed analysis of the program or system under test and have encountered problems (such as handling of procedure calls, efficiently finding solutions to systems of predicates and dealing with problems of scale) which have hindered their progress from research prototype to commercial tool. The approach described in this paper uses the ideas of Genetic Algorithms (GAs) to automatically develop a set of <b>test</b> <b>data</b> to achieve a level of coverage (branch coverage in this case). Using GAs neatly sidesteps many of the problems encountered by other systems in attempting to automatically <b>generate</b> <b>test</b> <b>data...</b>|$|R
