280|1649|Public
25|$|To {{test whether}} <b>input</b> <b>program</b> x halts on y, {{construct}} a program p that on input (x,y) reports true and diverges on all other inputs.|$|E
2500|$|There are {{programs}} (interpreters) that {{simulate the}} execution of whatever source code they are given. Such programs can demonstrate that a program does halt {{if this is the}} case: the interpreter itself will eventually halt its simulation, which shows that the original program halted. However, an interpreter will not halt if its <b>input</b> <b>program</b> does not halt, so this approach cannot solve the halting problem as stated; it does not successfully answer [...] "doesn't halt" [...] for programs that do not halt.|$|E
2500|$|Rice's theorem generalizes the theorem {{that the}} halting problem is unsolvable. It states that for any non-trivial property, {{there is no}} general {{decision}} procedure that, for all programs, decides whether the partial function implemented by the <b>input</b> <b>program</b> has that property. (A partial function is a function which may not always produce a result, and so is used to model programs, which can either produce results or fail to halt.) [...] For example, the property [...] "halt for the input 0" [...] is undecidable. Here, [...] "non-trivial" [...] means that the set of partial functions that satisfy the property is neither the empty set nor the set of all partial functions. For example, [...] "halts or fails to halt on input 0" [...] is clearly true of all partial functions, {{so it is a}} trivial property, and can be decided by an algorithm that simply reports [...] "true." [...] Also, note that this theorem holds only for properties of the partial function implemented by the program; Rice's Theorem does not apply to properties of the program itself. For example, [...] "halt on input 0 within 100 steps" [...] is not a property of the partial function that is implemented by the program—it is a property of the program implementing the partial function and is very much decidable.|$|E
40|$|The INDES {{computer}} <b>program,</b> a multistep <b>input</b> design <b>program</b> used {{as part of}} a {{data processing}} technique for rotorcraft systems identification, is described. Flight test inputs base on INDES improve the accuracy of parameter estimates. The <b>input</b> design algorithm, <b>program</b> <b>input,</b> and <b>program</b> output are presented...|$|R
50|$|ORBCOMM’s {{interchangeable}} OG2 (OG2-M and OG2-GPS) and OG-ISAT (IsatData Pro L-Band) satellite modems feature {{an identical}} footprint (smaller than a credit card), connectors, power <b>input,</b> <b>programming</b> environment, communication interface and protocols. ORBCOMM’s SkyWave IDP 200 Series packaged satellite modems operate over Inmarsat’s IsatData Pro network.|$|R
40|$|The work {{reported}} in this report evaluates the correctness, performance and usefulness of the four MetaFork translators (MetaFork to CilkPlus, CilkPlus to MetaFork, MetaFork to OpenMP, OpenMP to MetaFork). To this end, we run these translates on various <b>input</b> <b>programs</b> written either in CilkPlus or OpenMP, or both...|$|R
5000|$|The {{front end}} verifies syntax and {{semantics}} {{according to a}} specific source language. For statically typed languages it performs type checking by collecting type information. If the <b>input</b> <b>program</b> is syntactically incorrect or has a type error, it generates errors and warnings, highlighting them on the source code. Aspects of the front end include lexical analysis, syntax analysis, and semantic analysis. The front end transforms the <b>input</b> <b>program</b> into an intermediate representation or IR for further processing by the middle-end. This IR is usually {{a lower level of}} representation of the program with respect to the source code.|$|E
50|$|Solomonoff {{described}} a universal {{computer with a}} randomly generated <b>input</b> <b>program.</b> The program computes some possibly infinite output. The universal probability distribution is the probability distribution on all possible output strings with random input.|$|E
5000|$|If the <b>input</b> <b>program</b> [...] uses [...] registers, {{the output}} program [...] will need [...] registers, where [...] is a {{parameter}} of the construction. [...] uses [...] memory and its (worst-case) access overhead is [...]|$|E
50|$|AutoPar {{is a tool}} {{which can}} {{automatically}} insert OpenMP pragmas into input serial C/C++ codes. For <b>input</b> <b>programs</b> with existing OpenMP directives, the tool will double check the correctness when the right option is turned on. Compared to conventional tools, AutoPar can incorporate user knowledge (semantics) to discover more parallelization opportunities.|$|R
40|$|This paper {{describes}} LCLint, {{an efficient}} and flexible tool that accepts as <b>input</b> <b>programs</b> (written in ANSI C) and {{various levels of}} formal specification. Using this information, LCLint reports inconsistencies between a program and its specification. We also describe our experience using LCLint to help understand, document, and re-engineer legacy code...|$|R
40|$|This paper {{presents}} a static analysis that estimates uncaught exceptions in multithreaded Java programs. In Java, throwing exceptions across threads is deprecated {{because of the}} safety problem. Instead of restricting programmers' freedom, we extend Java language to support multithreaded exception handling and propose a tool to detect uncaught exceptions in the <b>input</b> <b>programs...</b>|$|R
50|$|Each rule {{consists}} optionally of tests, operators, {{and output}} productions. A rule matches {{some part of}} the <b>input</b> <b>program</b> source character stream returning success or failure. On success the input is advanced over matched characters. On failure the input is not advanced.|$|E
5000|$|In North America FM and TV translators {{were common}} before {{satellite}} broadcasting. With {{the introduction of}} satellite broadcasting (TVRO and RRO), some TV translator operators abandoned their stations or switched over to low power TV station (LPTV) licenses because of the higher broadcast quality provided by non-over-the-air <b>input</b> <b>program</b> streams.|$|E
5000|$|Method and {{apparatus}} for parsing {{source code}} using prefix analysis, #5,812,853, [...] "A technique for speeding up preliminary processing, such as macro preprocessing, in a compiler by remembering useful prefix strings of the <b>input</b> <b>program</b> in a tree-like data structure and keying those strings to remembered {{states of the}} compiler." ...|$|E
40|$|This paper {{presents}} {{an overview of}} a parallelizing compiler to automatically generate efficient code for large-scale parallel architectures from sequential <b>input</b> <b>programs.</b> This research focuses on loop-level parallelism in dense matrix computations. We illustrate the basic techniques the compiler uses by describing the entire compilation process for a simple example. Our compile...|$|R
40|$|We present {{experimental}} evidence that multiple compute-units, compiled from sequential high-level language <b>input</b> <b>programs,</b> can be merged into a reduced number of configurations for a reconfigurable fabric (such {{as a modern}} FPGA), thus significantly reducing the reconfiguration overhead. For cases requiring multiple configurations, both heuristical and exact algorithms to solve the configuration merging problem are described...|$|R
50|$|Often {{there is}} more than one way of {{choosing}} an enclosing chain of dots. When played with pens and paper, players are free to choose one however they like. Nevertheless, when game is played on a computer, to simplify user <b>input,</b> <b>programs</b> usually automatically surround minimum area. In some cases it can be tactically exploited to one's advantage.|$|R
5000|$|To produce exploit code from JIT, an {{idea from}} Dion Blazakis is used. The <b>input</b> <b>program,</b> usually JavaScript or ActionScript, {{typically}} contains numerous constant values {{that can be}} erroneously executed as code. For example, the XOR operation could be used:var a = (0x11223344^0x44332211^0x44332211^ ...);JIT then will transform bytecode to native x86 code like: ...|$|E
50|$|The auto-parallelization {{feature of}} the Intel C++ Compiler {{automatically}} translates serial portions of the <b>input</b> <b>program</b> into semantically equivalent multi-threaded code. Automatic parallelization determines the loops that are good work sharing candidates,performs the data-flow analysis to verify correct parallel execution, and partitions the data for threaded code generation as is needed inprogramming with OpenMP directives. The OpenMP and Auto-parallelization applications provide the performance gains from sharedmemory on multiprocessor systems.|$|E
50|$|The {{problem of}} {{precisely}} identifying semantic garbage {{can easily be}} shown to be partially decidable: a program that allocates an object X, runs an arbitrary <b>input</b> <b>program</b> P, and uses X if and only if P finishes would require a semantic garbage collector to solve the halting problem. Although conservative heuristic methods for semantic garbage detection remain an active research area, essentially all practical garbage collectors focus on syntactic garbage.|$|E
40|$|This report {{details the}} program {{developed}} to use th~e VAX 11 / 780 Operating System to assemble programs {{written for the}} Intel 8748 microcomputer. <b>Input</b> <b>programs</b> are written in Intel*MCS- 48 mnemonics and the output listing gives the instructions and * memory addresses in hexidecimal code. The-assembly language itself is written in MACROr, DD I'AN 1473 EorIoMo- IMNov S isOESOLETE Unclassifie...|$|R
40|$|AUTOCASK (AUTOmatic Generation of 3 -D CASK models) is a micro{{computer}}-based {{system of}} computer programs and databases {{developed at the}} Lawrence Livermore National Laboratory (LLNL) for the structural analysis of shipping casks for radioactive material. Model specification is performed on the microcomputer, and the analyses are performed on an engineering workstation or mainframe computer. AUTOCASK is based on 80386 / 80486 compatible microcomputers. The system is composed {{of a series of}} menus, <b>input</b> <b>programs,</b> display programs, a mesh generation program, and archive programs. All data is entered through fill-in-the-blank input screens that contain descriptive data requests...|$|R
40|$|In {{this paper}} {{we present a}} novel {{lightweight}} approach to validate compilers for synchronous languages. Instead of verifying a compiler for all <b>input</b> <b>programs</b> or providing a fixed suite of regression tests, we extend the compiler to generate a test-suite with high behavioral coverage and geared towards discovery of faults for every compiled artifact. We have implemented and evaluated our approach using a compiler from Lustre to C...|$|R
5000|$|He {{worked on}} {{numerous}} projects around the Whirlwind secret {{room of the}} Cape Cod System SAGE air defense system and at the Eglin Air Force Base ERA 1103. Around 1954 Ross wrote the first hand-drawn graphics <b>input</b> <b>program</b> to a computer. He stated it was [...] "One of the few programs that I ever wrote that worked the first time" [...] The Air Force was interested in continuing beyond MIT's Numerical Control Projects objective of standardizing the control of machine tools.|$|E
5000|$|There are {{programs}} (interpreters) that {{simulate the}} execution of whatever source code they are given. Such programs can demonstrate that a program does halt {{if this is the}} case: the interpreter itself will eventually halt its simulation, which shows that the original program halted. However, an interpreter will not halt if its <b>input</b> <b>program</b> does not halt, so this approach cannot solve the halting problem as stated; it does not successfully answer [...] "doesn't halt" [...] for programs that do not halt.|$|E
50|$|A Camlp4 {{preprocessor}} operates by loading {{a collection}} of compiled modules which define a parser {{as well as a}} pretty-printer: the parser converts an <b>input</b> <b>program</b> into an internal representation. This internal representation constitutes the abstract syntax tree (AST). It can be output in a binary form, e.g. it can be passed directly to one of the OCaml compilers, or it can be converted back into a clear text program. The notion of concrete syntax refers to the format in which the abstract syntax is represented.|$|E
40|$|This report {{contains}} a program and user instructions for plotting functions and line graphs on the IBM- 7371 or 7372 color plotter. <b>Program</b> <b>input</b> and operation are illustrated and explained. Examples that illustrate program capabilities are included. The program {{is written in}} IBM BASICA. The program eliminates the requirement for discrete coordinate inputs in order to plot functions. Continuous single valued functions are defined using the construction rules for standard BASIC expressions. These function definitions then become the <b>program</b> <b>inputs.</b> The <b>program</b> will also accept (X,Y) points and plot a line graph connecting the points[URL]...|$|R
40|$|This {{users manual}} for the solid rocket booster {{performance}} evaluation model (SRB-II) contains {{descriptions of the}} model, the program options, the required <b>program</b> <b>inputs,</b> the <b>program</b> output format and the program error messages. SRB-II is written in FORTRAN and is operational on both the IBM 370 / 155 and the MSFC UNIVAC 1108 computers...|$|R
40|$|We {{introduce}} DLV 2, a new Answer Set Programming (ASP) system. DLV 2 combines I-DLV, a fully-compliant ASP-Core- 2 grounder, {{with the}} well-assessed solver wasp. <b>Input</b> <b>programs</b> may be enriched by annotations and directives that customize heuristics {{of the system}} and extend its solving capabilities. An empirical analysis conducted on benchmarks from past ASP competitions shows that DLV 2 outperforms the old DLV system and is close to the state-of-the-art ASP system clingo...|$|R
50|$|LR parsers can {{generate}} somewhat helpful error messages {{for the first}} syntax error in a program, by simply enumerating all the terminal symbols that could have appeared next instead of the unexpected bad lookahead symbol. But this does not help the parser work out how to parse {{the remainder of the}} <b>input</b> <b>program</b> to look for further, independent errors. If the parser recovers badly from the first error, it is very likely to mis-parse everything else and produce a cascade of unhelpful spurious error messages.|$|E
50|$|Another {{possibility}} {{is to treat}} pruning as a dead code elimination problem. Then, a Φ function is live only if any use in the <b>input</b> <b>program</b> will be rewritten to it, or if {{it will be used}} as an argument in another Φ function. When entering SSA form, each use is rewritten to the nearest definition that dominates it. A Φ function will then be considered live {{as long as it is}} the nearest definition that dominates at least one use, or at least one argument of a live Φ.|$|E
5000|$|Pen {{computing}} {{has very}} deep historical roots.For example, the first patent for an electronic device used for handwriting, the telautograph, was granted in 1888.What {{is probably the}} first patent for a system that recognized handwritten characters by analyzing the handwriting motion was granted in 1915.Around 1954 Douglas T Ross, working on the Whirlwind computer at MIT, wrote the [...] "first hand-drawn graphics <b>input</b> <b>program</b> to a computer". The first publicly demonstrated system using a tablet and handwriting text recognition instead of a keyboard for working with a modern digital computer dates to 1956.|$|E
50|$|Interpretation: An {{interpreter}} {{takes as}} <b>input</b> a <b>program</b> in some language, and performs the actions written in that language on some machine.|$|R
50|$|A {{compiler}} {{is likely}} to perform many {{or all of the}} following operations: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of <b>input</b> <b>programs</b> to an intermediate representation, code optimization and code generation. Compilers implement these operations in phases that promote efficient design and correct transformations of source input to target output. Program faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementers invest significant effort to ensure compiler correctness.|$|R
40|$|Abstract. Comparing {{different}} {{software verification}} or bug-finding tools for C {{programs can be}} a difficult task. Problems arise from different kinds of properties that different tools can check, restrictions on the <b>input</b> <b>programs</b> accepted, lack of a standardized specification language for program properties, or different interpretations of the programming language semantics. In this discussion paper we describe problem areas and discuss possible solutions. The paper also reflects some lessons we have learned from participating with our tool LLBMC in the TACAS 201...|$|R
