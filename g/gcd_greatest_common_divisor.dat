16|2325|Public
40|$|This paper {{presents}} an algorithm and its implementation for computing the approximate <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of multivariate polynomials whose coefficients may be inexact. The method and the companion software {{appears to be}} the first practical package with such capabilities. The most significant features of the algorithm are its robustness and accuracy as demonstrated in the results of computational experiment. In addition, two variations of a squarefree factorization algorithm for multivariate polynomials are proposed as an application of the GCD algorithm...|$|E
40|$|Abstract. We {{introduce}} {{concepts of}} “recursive polynomial remainder sequence (PRS) ” and “recursive subresultant, ” and investigate their properties. In calculating PRS, if there exists the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of initial polynomials, we calculate “recursively ” with new PRS for the GCD and its derivative, until a constant is derived. We call such a PRS a recursive PRS. We define recursive subresultants to be determinants representing the coefficients in recursive PRS by coefficients of initial polynomials. Finally, we discuss usage of recursive subresultants in approximate algebraic computation, which motivates the present work. ...|$|E
40|$|Four new {{algorithms}} for multivariate polynomial <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> are given. The {{first is}} a simple improvement of PRS (polynomial remainder sequence) algorithms. The second is to calculate a Groebner basis with a certain term ordering. The third is to calculate subresultant by treating the coefficients as truncated power series. The fourth is to calculate PRS by treating the coefficients as truncated power series. The first and second algorithms are not important practically, but {{the third and fourth}} ones are quite efficient and seem to be useful practi-cally. 1...|$|E
30|$|Key generation: compute ϕ(N)=(p− 1)·(q− 1). Next, {{select a}} prime number {{as a public}} {{exponent}} e such that e∈[3,ϕ(N)) and gcd(e,ϕ(N))= 1, where <b>gcd</b> means the <b>greatest</b> <b>common</b> <b>divisor.</b> Also, compute the private exponent d such that e·d≡ 1. The public key is composed by (e,N) and the corresponding private key is composed by (d,N).|$|R
5000|$|As proved by Cate & Twigg (1977), {{the number}} of fixed points (cycles of length 1) of the {{permutation}} is precisely , where <b>gcd</b> is the <b>greatest</b> <b>common</b> <b>divisor.</b> For example, with N = M {{the number of}} fixed points is simply N (the diagonal of the matrix). If [...] and [...] are coprime, on the other hand, the only two fixed points are the upper-left and lower-right corners of the matrix.|$|R
5000|$|If {{the full}} {{factorization}} of n is known, say [...] where the [...] are distinct primes, then n {{is a perfect}} power {{if and only if}} [...] where <b>gcd</b> denotes the <b>greatest</b> <b>common</b> <b>divisor.</b> As an example, consider n = 296·360·724. Since gcd(96, 60, 24) = 12, n is a perfect 12th power (and a perfect 6th power, 4th power, cube and square, since 6, 4, 3 and 2 divide 12).|$|R
40|$|The book {{is divided}} into four major parts. Part I covers HDL {{constructs}} and synthesis of basic digital circuits. Part II {{provides an overview of}} embedded software development with the emphasis on low-level I/O access and drivers. Part III demonstrates the design and development of hardware and software for several complex I/O peripherals, including PS 2 keyboard and mouse, a graphic video controller, an audio codec, and an SD (secure digital) card. Part IV provides three case studies of the integration of hardware accelerators, including a custom <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> circuit, a Mandel...|$|E
40|$|We {{introduce}} {{concepts of}} "recursive polynomial remainder sequence (PRS) " and "recursive subresultant," and investigate their properties. In calculating PRS, if there exists the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of initial polynomials, we calculate "recursively" with new PRS for the GCD and its derivative, until a constant is derived. We call such a PRS a recursive PRS. We define recursive subresultants to be determinants representing the coefficients in recursive PRS by coefficients of initial polynomials. Finally, we discuss usage of recursive subresultants in approximate algebraic computation, which motivates the present work. Comment: 13 pages. Presented at CASC 2003 (Passau, Germany, September 20 - 26, 2003...|$|E
40|$|AbstractWe {{investigate}} {{a variant of}} the so-called “binary” algorithm for finding the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of two numbers which requires no comparisons. We show that when implemented with carry-save hardware, {{it can be used to}} find the modulo B inverse of an n-bit binary integer in a time proportional to n, using only registers of length proportional to n. Such a hardware implementation of this algorithm set up for finding inverses with respect to a 336 bit modulus B would have applications in the currently expanding field of secure data transmission and storage. In such an implementation, multiplication in linear time-both modulo B and ordinary—would come along as a by-product because multiplication can be achieved by a sequence of nine inversions, some additions and negations...|$|E
40|$|We {{address the}} {{following}} question in this paper: Given that the period of a discrete time periodic signal belongs to a set P = P_ 1, P_ 2,…,P_K, what is the minimum duration of the signal necessary to identify its period? It will be shown that the following number of samples is both necessary and sufficient: max P_i + P_j - gcd(P_i, P_j), where <b>gcd</b> is the <b>greatest</b> <b>common</b> <b>divisor,</b> and the maximization is over all pairs P_i, P_j ∈ P. Sufficiency is shown via a constructive proof, leading to a new period estimation algorithm...|$|R
40|$|Abstract. We give a {{self-contained}} {{proof that the}} nullity of the Bezoutian matrix associ-ated {{with a pair of}} polynomials f and g equals the number of their common zeros counting multiplicities. With two polynomials f and g and n = max{deg f,deg g} we associate an n × n matrix B, called the Bezoutian, and a 2 n × 2 n matrix R, called the resultant. Their defining relations are given by (6) and (5) below, respectively. In terms of the coefficients of f and g they are given by (8) and (4). In this note we give a simple and self-contained proof of the equalities (1) dimkerB = dimkerR = deg gcd(f, g), where <b>gcd</b> stands for <b>greatest</b> <b>common</b> <b>divisor.</b> H. Wimmer in [8] attributes this result to Jacobi who in 1836 showed that the singularity of what we call the Bezoutian implies the existence of a common factor of f and g. More contemporary proofs of (1) {{can be found in the}} recent books [3, Theorems 21. 10 and 21. 11] by H. Dym and [5, Theorem 8. 30] by P. Fuhrmann. In the Introduction to [3, Chapter 21] it is shown that dimkerB ≥ deg gcd(f, g) by using the defining formula for B, differentiation and chains of vectors. That equality prevails is then proved by using these chains and the so-called Barnett identity: B = Hfg(Cf), where Hf i...|$|R
40|$|Misalkan F adalah lapangan berhingga dengan q elemen dan dinotasikan dengan GF(q), a suatu elemen primitif dan i GF(q) dan suatu akar dan i x" — 1, maka = 1 dan a disebut akar satuan primitif ke n. Dengan demikian. 1 (x) = x"— 1 mempunyai akar satuan primitif ke — n. Misalkan / 3 suatu akar satuan primitf n. dari-. GF(e); [...] polinomial -minimal dari [...] . 13 - -atas-GF(q). adalah "	•	. "	• •	•	 [...] t-i dan dapat dinyatakan dalam bentuk : 1,(x) =fJ(x -	dimana t bilangan bulat positif terkecil sedemikian sehingga	= fl. Selanjutnya mfi(x) adalah suatu faktor dari x" — 1 atas, GF(q) Dengan meaggunakan tabel log Zech's (1 + = ce(i)), perluasan in/x) mudah dievaluasi. Metode lain untuk pemfaktoraq j(x) = xn — 1 atas GF(q) adalah dengan inenggunakan operasi — operasi PPT (pthnbagi persekutuan terbesar) antara. /(x) dan g(x) dengan derajat g(x) < [...] n 1 [...] dan memenuhi [g(x) ]' g(x) (mod f(x)). Selanjutnya W=FIPPT (f(x),g(i) -	• • •	• Let F is finite {{field with}} q {{elements}} and denoted by GF(q), a is a primitive element of GF(q) and a root of e - 1, then an= 1 and a {{is called a}} primitive nth root of unity. Hence f(x) = x" — 1 has primitive nth root of unity. Let f 3 is a • primitive nth root of unity of GF(e) •,- mithrrial polynomial of 13 over GF(4) [...] i: Ax) and can be written in the form : p(x) =fi(x 18 (/) where t is the smallest i. 0 positive integer such that fle =. Then ny(x) is i factor of x" — I over GF(q). Using the Zech's 14 table. (1 + a = a'ti)), expanding mix) is easy to evaluate. • Another method for factoring f(x) = x" — 1 over GF(q) is using appropriate <b>gcd</b> (the <b>great</b> <b>common</b> <b>divisor)</b> operations between. f(x) and g(x) where deg g(x) < n — 1 and satisfying [g(x) ] 1 g(x) (mod fix)). Then. f(x) = fl gcd (/(x), g(x) - 4 sEF ••	• This document is Undip Institutional Repository Collection. The author xii copyright owner(s) changing the content, translate the submission to any medium or form,. 	the purpose of presi " rP r c) 	 1 - 1 "t INIDIP-!R may keep more than one copy of this submission for purpose of secur httn'tinrHt'...|$|R
40|$|AbstractThree new {{algorithms}} for multivariate polynomial <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> are given. The {{first is}} to calculate a Gröbner basis with a certain term ordering. The second is to calculate the subresultant by treating the coefficients w. r. t. the main variable as truncated power series. The third is to calculate a PRS (polynomial remainder sequence) by treating the coefficients as truncated power series. The first algorithm is not important practically, but {{the second and third}} ones are efficient and seem to be useful practically. The third algorithm has been implemented naively and compared with the trial-division PRS algorithm and the EZGCD algorithm. Although {{it is too early to}} derive a definite conclusion, the PRS method with power series coefficients is very efficient for calculating low degree GCD of high degree non-sparse polynomials...|$|E
40|$|AbstractWe {{describe}} two algorithms of approximate <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> for polynomials with {{coefficients of}} floating-point numbers. One is for univariate polynomials {{and the other}} for multivariate polynomials. The algorithms are careful extensions of the conventional Euclidean algorithm, and they are applied to solving ill-conditioned algebraic equations. Ill-conditioned univariate algebraic equations have multiple or close roots, and we can ill-conditioned system of algebraic equations which have an approprimate common divisor. Conventional numeric root-finding methods such as Newton's method give no satisfactory result for such ill-conditioned systems. By using an approximate GCD algorithm for multivariate polynomials, the system is transformed into a well-conditioned problems by a combination of algebraic and numeric methods; we call such algorithms hybrid algorithms. This paper shows the importance and possible fruitfulness of the hybrid algorithm...|$|E
40|$|AbstractWe {{introduce}} {{concepts of}} “recursive polynomial remainder sequence (PRS) ” and “recursive subresultant,” along with investigation of their properties. A recursive PRS is defined as, if there exists the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of initial polynomials, {{a sequence of}} PRSs calculated “recursively” for the GCD and its derivative until a constant is derived, and recursive subresultants are defined by determinants representing the coefficients in recursive PRS as functions of coefficients of initial polynomials. We give three different constructions of subresultant matrices for recursive subresultants; while {{the first one is}} built-up just with previously defined matrices thus the size of the matrix increases fast as the recursion deepens, the last one reduces the size of the matrix drastically by the Gaussian elimination on the second one which has a “nested” expression, i. e. a Sylvester matrix whose elements are themselves determinants...|$|E
40|$|AbstractNehlig (Applications Affines Discrétes et Antialiassage, Ph. D. Thesis, Université Louis Pasteur, Strasbourg, November 1992. Theoret. Comput. Sci. 156 (1995) 1 – 38) {{introduced}} tilings {{generated by}} quasi-affine transformations (QAT). Let us {{remember that a}} quasi-affine transformation, or QAT, is a transformation of the discrete plane obtained by composing a rational affine transformation with the usual integer function. So it is defined by [g]:Z 2 →Z 2 (x,y) ↦x′=ax+by+eωy′=cx+dy+fωwhere a,b,c,d,e,f and ω are integers, ω> 0, and [] denotes the usual integer function. The reciprocal image of a point (i,j) by a QAT can contain no, one or several points; this reciprocal image is called paving or tile of index (i,j) and noted Pi,j. The pavings form a periodic tiling of the discrete plane. Nehlig defined the supertile which {{is a set of}} tiles containing all generic tiles: so the supertile tiles the discrete plane. He defined also the generic strip which {{is a part of the}} supertile sufficient to tile the discrete plane and proved that if ω=ad−bc then the paving of index (0, 0) tiles the plane. This study has been done assuming that gcd(a,b) =gcd(b,d) =gcd(c,d) =gcd(c,a) = 1 (where <b>gcd</b> denotes the <b>greatest</b> <b>common</b> <b>divisor).</b> The aim of this paper is to go on with this study in the general case. We will determine a set of indices I and two vectors u and v such that each paving of index (i,j) can be obtained by translating a paving of index belonging to I, the translation vector depending on (i,j), u and v. We then call paving-cluster the set of pavings of index belonging to I. When gcd(a,b) =gcd(b,d) =gcd(d,c) =gcd(c,a) = 1, the paving-cluster contains the same pavings as the generic strip defined by Nehlig. We also prove that the number of neighbours of a paving varies from four to eight; when ω=ad−bc a paving has 4 or 6 neighbours. This last result is a particular case of Beauquier and Nivat's theorem [1]...|$|R
5000|$|The {{content of}} a <b>greatest</b> <b>common</b> <b>divisor</b> of polynomials is the <b>greatest</b> <b>common</b> <b>divisor</b> (in [...] ) of their contents: ...|$|R
5000|$|Any two (or finitely many) {{elements}} of a UFD have a <b>greatest</b> <b>common</b> <b>divisor</b> and a least common multiple. Here, a <b>greatest</b> <b>common</b> <b>divisor</b> of a and b is an element d which divides both a and b, and such that every other <b>common</b> <b>divisor</b> of a and b divides d. All <b>greatest</b> <b>common</b> <b>divisors</b> of a and b are associated.|$|R
40|$|We {{introduce}} {{concepts of}} "recursive polynomial remainder sequence (PRS) " and "recursive subresultant," along with investigation of their properties. A recursive PRS is defined as, if there exists the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of initial polynomials, {{a sequence of}} PRSs calculated "recursively" for the GCD and its derivative until a constant is derived, and recursive subresultants are defined by determinants representing the coefficients in recursive PRS as functions of coefficients of initial polynomials. We give three different constructions of subresultant matrices for recursive subresultants; while {{the first one is}} built-up just with previously defined matrices thus the size of the matrix increases fast as the recursion deepens, the last one reduces the size of the matrix drastically by the Gaussian elimination on the second one which has a "nested" expression, i. e. a Sylvester matrix whose elements are themselves determinants. Comment: 30 pages. Preliminary versions of this paper have been presented at CASC 2003 (arXiv: 0806. 0478 [math. AC]) and CASC 2005 (arXiv: 0806. 0488 [math. AC]...|$|E
40|$|We {{introduce}} {{concepts of}} “recursive polynomial remainder sequence (PRS) ” and “recursive subresultant, ” along with investigation of their properties. A recursive PRS is defined as, if there exists the <b>GCD</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of initial polynomials, {{a sequence of}} PRSs calculated “recursively ” for the GCD and its derivative until a constant is derived, and recursive subresultants are defined by determinants representing the coefficients in recursive PRS as functions of coefficients of initial polynomials. We give three different constructions of subresultant matrices for recursive subresultants; while {{the first one is}} built-up just with previously defined matrices thus the size of the matrix increases fast as the recursion deepens, the last one reduces the size of the matrix drastically by the Gaussian elimination on the second one which has a “nested ” expression, i. e. a Sylvester matrix whose elements are themselves determinants. Key words: polynomial remainder sequence, subresultants, Gaussian elimination, Sylvester’s identity...|$|E
40|$|Abstract. Current {{automotive}} radar systems measure the distance, the relative velocity {{and the direction}} of objects in their environment. This information enables the car to sup-port the driver. The direction estimation capabilities of a sensor array de-pend on its beampattern. To find the array configuration lead-ing to the best angle estimation by a global optimization algo-rithm, {{a huge amount of}} beampatterns have to be calculated to detect their maxima. In this paper, a novel algorithm is proposed to find all maxima of an array’s beampattern fast and reliably, leading to accelerated array optimizations. The algorithm works for arrays having the sensors on a uniformly spaced grid. We use a general version of the <b>gcd</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> function in order to write the problem as a polynomial. We differentiate and root the polynomial to get the extrema of the beampattern. In addition, we show a method to reduce the computational burden even more by decreasing the order of the polynomial. ...|$|E
40|$|The {{problem of}} {{computing}} the <b>greatest</b> <b>common</b> <b>divisor</b> of two univariate polynomials in D[x], with D a field or an integral domain, {{is one of}} the cornerstones in Computer Algebra. When D is an integral domain we shall talk about a <b>greatest</b> <b>common</b> <b>divisor</b> as a polynomial in D[x] which is a <b>greatest</b> <b>common</b> <b>divisor</b> of th...|$|R
5000|$|As [...] the <b>greatest</b> <b>common</b> <b>divisor</b> is {{the same}} for [...] and [...] This shows that the <b>greatest</b> <b>common</b> <b>divisor</b> of the input [...] {{is the same}} as that of [...] This proves that [...] is the <b>greatest</b> <b>common</b> <b>divisor</b> of a and b. (Until this point, the proof is {{the same as that of}} the {{classical}} Euclidean algorithm.) ...|$|R
40|$|AbstractUsing {{floating}} point operations in computer graphics produces uncontrollable rounding errors that can induce dramatic mistakes, especially when topological decisions depend on numeric results. These numerical {{problems have been}} reported early [30, 31]. It is thus compulsory {{to take into account}} the discrete nature of computers in order to produce a robust computer science theory giving algorithms free of chaotic numerical perturbations. We describe some aspects of a discrete geometry, developed in our research centre [3, 10, 11, 19, 23, 24] based on the arithmetic properties of the integers and free of rounding error problems. The aim of this communication is to study tilings of the discrete plane by reciprocal images of a quasi-affine transformation (QAT) defined on Z 2 by x′ = [ax + by + eω], y′ = [cx + dy + fω], where all terms are integers, ω > 0, and the brackets denote usual integer part function. Studying these tilings is possible because of a fundamental one-to-one relationship between these reciprocal images and intersections of discrete lines [27]. The discrete line D of slope −ab, with lower bound m and thickness ω, is the set of integer points (x, y) such that: m ⩽ ax + by 0 = F(Xn− 1). This dynamical system induces a partitioning of Z 2 into attraction basins. Attraction basins can be split into trees attached on limit cycles. A great variety of situations occurs here at any level: the number of attraction basins as well as the number of points of limit cycles can be any strictly positive number. There can be zero or more trees attached to a limit cycle. We show that the leaves of these trees (i. e. the entry points of the dynamical system) can be seen as the union of n subgroups of Z 2 and define thus a regular pattern over Z 2. The main results in the second part of this paper concern tilings by reciprocal images. Let F be the QAT: x′ = [ax + byω], y′ = [cx + dyω]. let Pi,j = F− 1 (i,j), the reciprocal image of (i,j) by F. Pi,j is a tile in the tiling of Z 2. We prove that if ω = ¦ad−bc¦, then the tile P 0, 0, is a tiling pattern and can be replicated to tile Z 2. When there is no other constraint on ω than being strictly positive, there exists a supertile containing all the generic tiles of the reciprocal image tiling. This supertile is the set of all the points (x, y) such as S(F(x, y)) = (i,j), for any given(i,j) ϵ Z 2, with S(i,j) = ([(di − bj) δ], [(− ci + aj) δ]), and δ = ¦ad − bc¦. A supertile contains ω 2 points and no more that δ tiles. A second interesting set of reciprocal image tiles is the generic strip containing following tiles: {P 0,i¦i ϵ [0, δgcd(ω,δ) ]}. This set contains δgcd(ω,δ) distinct reciprocal images (with <b>gcd</b> denoting the <b>greatest</b> <b>common</b> <b>divisor)</b> and ω 2 gcd((ω,δ) points. Both the supertile and the generic strip are tools that aid in understanding the structure of tilings of the discrete plane by reciprocal images of QATs...|$|R
40|$|We here {{discuss the}} {{optimization}} of coefficients of lists of polynomials using evolutionary computation. The given polynomials have 5 variables, namely t, a 1, a 2, a 3, a 4, and integer coefficients. The {{goal is to}} find integer values i, with i 2 1, 2, 3, 4, substituting ai such that, after crossing out the <b>gcd</b> (<b>greatest</b> <b>common</b> <b>divisor)</b> of all coefficients of the polynomials, the resulting integers are minimized in absolute value. Evolution strategies, a special class of heuristic, evolutionary algorithms, are here used for solving this problem. In this paper we describe this approach in detail and analyze test results achieved for two benchmark problem instances; we also show a visual analysis of the fitness landscapes of these problem instancesThe authors thank Franz Winkler at the Research Institute for Symbolic Computation, Johannes Kepler University Linz, for his advice. R. Sendra is partially supported by the Spanish Ministerio de Economía y Competitividad under the project MTM 2011 - 25816 -C 02 - 01 {{and is a member}} of the Research Group ASYNACS (Ref. CCEE 2011 /R 34). The authors also thanks members of the Heuristic and Evolutionary Algorithms Laboratory as well as of the Bioinformatics Research Group, University of Applied Sciences Upper Austria, for their comments...|$|E
40|$|<b>GCD</b> (<b>Greatest</b> <b>Common</b> <b>Divisor)</b> & LCM (Least Common Multiple) is an {{elementary}} school lesson. Its about to search prime number from the compared numbers then the prime number is used to search GCD & LCM. The number which have been search before will be saved into txt file. It's used as a simple learning machine. Every time user input numbers that already saved in txt file, the program will automatically take the number and the prime number and then display it to user. This program use array to store the data that required to count GCD & LCM. Because array is special, it can store many data without limit and this program needs many data. This program has several function to solve the GCD & LCM. It use PHP and HTML to count the result and to create the web design. There are 4 steps in this program. First is search the prime factor, then sort it from smallest into biggest value to make user read the prime factor easier. If it already sorted then the program will count for GCD & LCM. Result of GCD & LCM will be informed as detailed as possible include the multiple process until it found the result...|$|E
40|$|In the {{multimedia}} applications messages like audio and videomessages are broadcasted through groups. To provide secrecy ofthose keys {{which are used}} in this communication, the methods likekey generation and the key distribution among these groupsshould {{be done in a}} secure way. The problems due to this aremutual authentication with the exchange of a session key. In mostof the Key Management schemes, different types of group usersobtain a new distributed multicast group key which is issued forencrypting and decrypting multimedia data for every sessionupdate. Among the various works on key distribution, The RSAmethod focuses on making the key generation operation speed andalso reduces the complexity. The main advantage of this algorithmis that only one message is generated per rekeying operation andonly one key is stored in each user’s memory. Key distribution isan important issue in multimedia networks. The Key Distributionalgorithm and at the same time, increases the number of keys to bestored by GC (Group Center) and group members. A new <b>GCD</b> (<b>Greatest</b> <b>Common</b> <b>Divisor)</b> and LCM based KeyDistribution Protocol which focuses on two dimensions is also usedto decrease the complexity by increasing the number ofmultiplication operations and for this the divide and conquerapproach for multiplication is used. The second dimension aims atreducing the amount of information stored in the Group Centerand group members while performing the update operation in thekey content...|$|E
5000|$|The {{extended}} Euclidean algorithm for the <b>greatest</b> <b>common</b> <b>divisor</b> of two integers [...] and [...] is certifying: it outputs three integers [...] (the divisor), , and , {{such that}} [...] This equation {{can only be}} true of multiples of the <b>greatest</b> <b>common</b> <b>divisor,</b> so testing that [...] is the <b>greatest</b> <b>common</b> <b>divisor</b> may be performed by checking that [...] divides both [...] and [...] and that this equation is correct.|$|R
5000|$|The second way to {{normalize}} the <b>greatest</b> <b>common</b> <b>divisor</b> {{in the case}} of polynomials with integers coefficients is to divide every output by the content of [...] to get a primitive <b>greatest</b> <b>common</b> <b>divisor.</b> If the input polynomials are coprime, this normalization provides also a <b>greatest</b> <b>common</b> <b>divisor</b> equal to 1. The drawback of this approach {{is that a lot of}} fractions should be computed and simplified during the computation.|$|R
50|$|A third {{difference}} is that, in the polynomial case, the <b>greatest</b> <b>common</b> <b>divisor</b> is defined {{only up to}} the multiplication by a non zero constant. There {{are several ways to}} define the <b>greatest</b> <b>common</b> <b>divisor</b> unambiguously.|$|R
40|$|In this work, the {{analysis}} of the computation of the <b>greatest</b> <b>common</b> <b>divisor</b> of univariate and bivariate polynomials is presented. The whole process is split into three stages. In the first stage, data preprocessing is explained and the resulting better numerical behavior is demonstrated. Next stage is concerned with the problem of the computation of the numerical rank of the Sylvester matrix, from which the degree of the <b>greatest</b> <b>common</b> <b>divisor</b> is obtained. The last stage is the actual algorithm for calculating the <b>greatest</b> <b>common</b> <b>divisor</b> of two polynomials. Furthermore, the underlying theory behind the computation of the <b>greatest</b> <b>common</b> <b>divisor</b> is explained and illustrated on many examples. ...|$|R
5|$|The Euclidean {{algorithm}} calculates the <b>greatest</b> <b>common</b> <b>divisor</b> (GCD) of two natural numbers a and b. The <b>greatest</b> <b>common</b> <b>divisor</b> g is {{the largest}} natural number that divides both a and b without leaving a remainder. Synonyms for the GCD include the <b>greatest</b> <b>common</b> factor (GCF), the highest common factor (HCF), the highest <b>common</b> <b>divisor</b> (HCD), and the <b>greatest</b> <b>common</b> measure (GCM). The <b>greatest</b> <b>common</b> <b>divisor</b> is often written as gcd(a,b) or, more simply, as (a,b), although the latter notation is also used for other mathematical concepts, such as two-dimensional vectors.|$|R
50|$|Any Euclidean domain is a PID; the {{algorithm}} {{used to calculate}} <b>greatest</b> <b>common</b> <b>divisors</b> {{may be used to}} find a generator of any ideal.More generally, any two principal ideals in a commutative ring have a <b>greatest</b> <b>common</b> <b>divisor</b> in the sense of ideal multiplication.In principal ideal domains, this allows us to calculate <b>greatest</b> <b>common</b> <b>divisors</b> of elements of the ring, up to multiplication by a unit; we define gcd(a,b) to be any generator of the ideal ⟨a,b⟩.|$|R
50|$|In algebra, the <b>greatest</b> <b>common</b> <b>divisor</b> (frequently {{abbreviated}} as GCD) of two polynomials is a polynomial, of {{the highest}} possible degree, that is a factor of both the two original polynomials. This concept {{is analogous to the}} <b>greatest</b> <b>common</b> <b>divisor</b> of two integers.|$|R
40|$|Chapter I {{begins with}} {{a brief history of}} the topic of <b>greatest</b> <b>common</b> subgraphs. Then we provide a summaiy of the work done on some {{variations}} of <b>greatest</b> <b>common</b> subgraphs. Finally, in this chapter we present results previously obtained on <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of graphs. In Chapter II the concepts of prime graphs, prime divisors of graphs, and primeconnected graphs are presented. We show the existence of prime trees of any odd size and the existence of prime-connected trees that are not prime having any odd composite size. Then the number of prime divisors in a graph is studied. Finally, we present several results involving the existence of graphs whose size satisfies some prescribed condition and which contains a specified number of prime divisors. Chapter III presents properties of <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of graphs. Then graphs with a prescribed number of <b>greatest</b> <b>common</b> <b>divisors</b> or least <b>common</b> multiples are studied. In Chapter IV we study the sizes of <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of specified graphs. We find the sizes of <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of stars and that of stripes. Then the size of <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of paths and complete graphs are investigated. In particular, the size of least common multiples of paths versus K 3 or K 4 are determined. Then we present the <b>greatest</b> <b>common</b> <b>divisor</b> index of a graph and we determine this parameter for several classes of graphs. iii In Chapter V <b>greatest</b> <b>common</b> <b>divisors</b> and least <b>common</b> multiples of digraphs are introduced. The existence of least common mutliples of two stars is established, and the size of a least common multiple is found for several pairs of stars. Finally, we present the concept of <b>greatest</b> <b>common</b> <b>divisor</b> index of a digraph and determine it for several classes of digraphs. ivMathematical SciencesPh. D. (Mathematical sciences...|$|R
5000|$|... #Subtitle level 2: <b>Greatest</b> <b>common</b> <b>divisor</b> and Euclidean {{algorithm}} ...|$|R
