22|61|Public
5000|$|<b>Key</b> <b>lookup</b> - {{the ability}} to quickly {{undertake}} a database lookup using a key (typically an address in a packet) to find a result, typically routing information.|$|E
5000|$|<b>Key</b> <b>lookup</b> in Tulip has a {{guaranteed}} stretch of 2 over optimal lookup {{with up to}} 2 lookup hops. If a source node [...] wants to access an object at another node [...] then, if both {{belong to the same}} color group node [...] directly communicates with node [...] in one hop or else if the nodes [...] and [...] are in different color groups, then, node [...] communicates with its closest neighbor [...] which is in the same color group as [...] and reaches [...] in 2-hops via the node [...]|$|E
5000|$|The central {{concept of}} a {{document}} store {{is the notion of}} a [...] "document". While each document-oriented database implementation differs on the details of this definition, in general, they all assume that documents encapsulate and encode data (or information) in some standard formats or encodings. Encodings in use include XML, YAML, and JSON as well as binary forms like BSON. Documents are addressed in the database via a unique key that represents that document. One of the other defining characteristics of a document-oriented database is that in addition to the <b>key</b> <b>lookup</b> performed by a key-value store, the database offers an API or query language that retrieves documents based on their contents.|$|E
40|$|Distributed Hash Tables (DHTs) {{have been}} used in Peer-to-Peer {{networks}} to provide <b>key</b> <b>lookups</b> in typically O(log n) hops whilst requiring maintenance of only small amounts of routing state. We extend ROME, a layer which runs on top of the Chord DHT to provide control over network size through monitoring of node workload and propose the use of processes to reorganise nodes and add or remove them from a pool of available machines. We show this can reduce further the hop counts in networks where available node capacity exceeds workload, without the need to modify any processes of the underlying Chord protocol...|$|R
50|$|P4 tables {{contain the}} state used to forward packets. Tables are {{composed}} of <b>lookup</b> <b>keys</b> and a corresponding set of actions and their parameters. A trivial example might be to store a set of destination MAC addresses as the <b>lookup</b> <b>keys,</b> and the corresponding action could set the output port on the device, and/or increment a counter. Tables and their associated actions are almost always chained together in sequence to realize the full packet forwarding logic, although in the abstract {{it is possible to}} build a single table that includes all the <b>lookup</b> <b>key</b> information and the full output action set.|$|R
5000|$|CMEA is {{described}} in [...] It is byte-oriented, with variable block size, typically 2 to 6 bytes. The key size is only 64 bits. Both of these are unusually small for a modern cipher. The algorithm consists of only 3 passes over the data: a non-linear left-to-right diffusion operation, an unkeyed linear mixing, and another non-linear diffusion that {{is in fact the}} inverse of the first. The non-linear operations use a <b>keyed</b> <b>lookup</b> table called the T-box, which uses an unkeyed lookup table called the CaveTable. The algorithm is self-inverse; re-encrypting the ciphertext with the same key is equivalent to decrypting it.|$|R
40|$|Wireless mesh {{networks}} are a promising {{area for the}} deployment of new wireless communication and network-ing technologies. In this paper, we {{address the problem of}} enabling effective peer-to-peer resource sharing in this type of networks. In particular, we consider the well-known Chord protocol for resource sharing in wired networks and the recently proposed MeshChord specialization for wire-less mesh networks, and compare their performance under various network settings for what concerns total generated traffic and load balancing. Both iterative and recursive <b>key</b> <b>lookup</b> implementation in Chord/MeshChord are consid-ered in our extensive performance evaluation. The results confirm superiority of MeshChord with respect to Chord, and show that recursive <b>key</b> <b>lookup</b> is to be preferred when considering communication overhead, while similar degree of load unbalancing is observed. However, recursive lookup implementation reduces the efficacy of MeshChord cross-layer design with respect to the original Chord algorithm. MeshChord has also the advantage of reducing load unbal-ancing with respect to Chord, although a moderate degree of load unbalancing is still observed, leaving room for fur-ther improvement of the MeshChord design. ...|$|E
40|$|Wireless mesh {{networks}} are a promising {{area for the}} deployment of new wireless communication and networking technologies. In this paper, we {{address the problem of}} enabling effective peer-to-peer resource sharing in this type ofnetworks. In particular, we consider the well-known Chord protocol for resource sharing in wired networks and the recently proposed MeshChord specialization for wireless mesh networks, and compare their performance under various network settings for what concerns total generated traffic and load balancing. Both iterative and recursive <b>key</b> <b>lookup</b> implementation in Chord/MeshChord are considered in our extensive performance evaluation. The results confirm superiority of MeshChord with respect to Chord, and show that recursive <b>key</b> <b>lookup</b> is to be preferred when considering communication overhead, while similar degree ofload unbalancing is observed. However, recursive lookup implementation reduces the efficacy of MeshChord crosslayer design with respect to the original Chord algorithm. MeshChord has also the advantage ofreducing load unbalancing with respect to Chord, although a moderate degree ofload unbalancing is still observed, leaving room for further improvement ofthe MeshChord design. ...|$|E
40|$|Abstract — This {{paper is}} {{motivated}} {{by a desire to}} create a user friendly, technically flexible approach to cryptography. This approach can create a flexible design pattern that is useable under a wide variety of circumstances from broadcast media to existing network protocols. This is accomplished by designing a new, key piece of infrastructure used for cryptography <b>key</b> <b>lookup.</b> Once the key is obtained the application/protocol developer is given the flexibility to meet their requirements...|$|E
40|$|AbstractDistributed Hash Table-based {{overlays}} {{are widely}} used to support efficient information routing and storage in structured peer- to-peer networks, {{but they are also}} subject to numerous attacks aimed at disrupting their correct functioning. In this paper we analyze the impact of the Eclipse attack on a Chord-based overlay in terms of number of <b>key</b> <b>lookups</b> intercepted by a collusion of malicious nodes. Moreover, we propose some modifications to the Chord routing protocol in order to mitigate its effects. Such countermeasures can operate in a distributed fashion or assume the presence of a centralized trusted entity and introduce a limited traffic overhead. The effectiveness of the proposed mitigation techniques has been shown through numerical results...|$|R
40|$|Due to {{the rapid}} {{development}} of the Web, applications based on the P 2 P paradigm gain more and more interest. Recently, such systems start to evolve to adopt standard database functionalities in terms of complex query processing support. This goes far beyond simple <b>key</b> <b>lookups,</b> as provided by standard DHT systems, which makes estimating the completeness of query answers a crucial challenge. In this paper, we discuss the semantics of completeness for complex queries in P 2 P database systems and propose methods based {{on the notion of}} routing graphs for estimating the number of expected query answers. Further, we discuss probabilistic guarantees for the estimated values and evaluate the proposed methods through an implemented system...|$|R
40|$|Distributed Hash Table-based {{overlays}} {{are widely}} used to support ecient information routing and storage in structured peerto- peer networks, {{but they are also}} subject to numerous attacks aimed at disrupting their correct functioning. In this paper we analyze the impact of the Eclipse attack on a Chord-based overlay in terms of number of <b>key</b> <b>lookups</b> intercepted by a collusion of malicious nodes. Moreover, we propose some modifications to the Chord routing protocol in order to mitigate its eects. Such countermeasures can operate in a distributed fashion or assume the presence of a centralized trusted entity and introduce a limited trac overhead. The eectiveness of the proposed mitigation techniques has been shown through numerical results...|$|R
40|$|Structured P 2 P {{systems in}} the form of {{distributed}} hash tables (DHT) are a promising approach for building massively distributed data management platforms. However, for many applications the supported <b>key</b> <b>lookup</b> queries are not sufficient. Instead, techniques for managing and querying (relational) structured data are required. In this paper, we argue that in order to cope with the dynamics in large-scale P 2 P systems such query techniques should be work in a best effort manner. We describe such operations (namely grouping/aggregation, similarity and nearest neighbor search) and discuss appropriate query evaluation strategies. 1...|$|E
40|$|We {{present the}} Internet Key Service (IKS), a {{distributed}} architecture for authenticated distribution of public keys, layered on Secure DNS (DNSSEC). Clients use DNSSEC to securely discover {{the identities of}} the relevant IKS servers, and send <b>key</b> <b>lookup</b> or management requests directly to these servers using a special-purpose protocol. Clients authenticate keys retrieved from IKS servers using key commitments published in DNSSEC. IKS derives its authentication authority from the authority DNS domains have over Internet names. The IKS architecture is loosely coupled with DNS to minimize overhead on DNS servers. We also present RIKS, a prototype IKS implementation. 1...|$|E
40|$|One of {{the goals}} for this master thesis was to {{implement}} a code generator for the static hybrid data structure. Both the generator and the generated code has proved to work but the throughput of the lookup function can be greatly improved. It is possible to enter any stride sequence to generate code, which allows for a future merge of the the code generator and Sundströms automated cross-breeding tool, Strider. Some measures needed for a faster lookup is to inline all functions concerned with query <b>key</b> <b>lookup</b> and try to avoid loops in the code. Validerat; 20101217 (root...|$|E
30|$|RQ 4 : JPA vs JPQL. To answer RQ 5, {{we compare}} the basic JPA find on primary <b>key</b> (read <b>lookup)</b> to a JPQL query on primary key. By {{comparing}} both, we can assess the extra overhead cost of JPQL query translation.|$|R
40|$|In this paper, an {{implementation}} of digital image encryption {{scheme based on}} one dimensional logistic map is proposed. The chaotic cryptography technique concentrates in general on the symmetric key cryptographic technique. In the proposed algorithm, a random <b>key</b> table <b>lookup</b> criterion was combined with a one-dimensional chaotic map were used for high degree 2 -stage security image encryption while maintaining acceptable overhead delay time. The proposed algorithm is based on image row shuffling and pixel-wise XOR encryption. To increase the security of row shuffling variable rotation and inversion were applied to each shuffled row, based on the difference between old and new row location. The experimental {{results showed that the}} proposed algorithm is effective and applicable. The combination of logistic map and <b>key</b> table <b>lookup</b> shows advantages of large random key space and high-level of security. The resulting cipher image is suitable for practical use in secure image storing and transmission...|$|R
40|$|This poster {{describes}} {{the design of}} a distributed system to resolve flat semantic-free identifiers. Because Distributed Hash Tables (DHTs, [10, 13]) in theory allow users of the DHT to perform fast lookups on flat identifiers, researchers have—too eagerly, we argue—proposed using them as a substrate for various resolution tasks. For example, researchers have argued for infrastructure-style DHTs in systems like CoDoNS [7] (here the <b>lookup</b> <b>key</b> is a hash of the DNS name, and the target of the resolution is an A-record), i 3 [12] (here, the <b>lookup</b> <b>key</b> is a flat identifier, one per well-known Internet service, and the target of the resolution is the actual IP address of the service), and SFR [14] (here, the <b>lookup</b> <b>key</b> is a flat identifier, one per Web link, and the target of the resolution is an (IP,port,path) triple). The purpose of this work is twofold...|$|R
40|$|Public key {{infrastructures}} (PKIs) {{enable users}} {{to look up}} and verify one another’s public keys based on identities. Current approaches to PKIs are vulnerable {{because they do not}} offer sufficiently strong guarantees of identity retention; that is, they do not effectively prevent one user from registering a public key under another’s already-registered identity. In this paper, we leverage the consistency guarantees provided by cryptocurrencies such as Bitcoin and Namecoin to build a PKI that ensures identity retention. Our system, called Certcoin, has no central authority and thus requires the use of secure distributed dictionary data structures to provide efficient support for <b>key</b> <b>lookup.</b> ...|$|E
40|$|Abstract—Due to its better scalability, Key-Value (KV) {{store has}} {{superseded}} traditional relational databases for many applications, such as data deduplication, on-line multi-player gaming, and Internet services like Amazon and Facebook. The KV store efficiently supports two operations (<b>key</b> <b>lookup</b> and KV pair insertion) through an index structure that maps keys to their associated values. The KV store is also {{commonly used to}} implement the chunk index in data deduplication, where a chunk ID (SHA 1 value computed based on the chunk’s content) is a key and its associative chunk metadata (e. g., physical storage location, stream ID) is the value. For a deduplication system, typically the number of chunks is too large to store the KV store solely in RAM. Thus, the KV store maintains a large (hash-table based) index structure in RAM to index all KV pairs stored on secondary storage. Hence, its available RAM space limits {{the maximum number of}} KV pairs that can be stored. Moving the index data structure from RAM to flash can possibly overcome the space limitation. In this paper, we propose efficient KV store on flash with a Bloom Filter based index structure called BloomStore. The unique features of the BloomStore include (1) no index structure is required to be stored in RAM so that a small RAM space can support a large number of KV pairs and (2) both index structure and KV pairs are stored compactly on flash memory to improve its performance. Compared with the state-of-the-art KV store designs, the BloomStore achieves a significantly better <b>key</b> <b>lookup</b> performance and roughly the same insertion performance with multiple times less RAM usage based on our experiments with deduplication workloads. I...|$|E
40|$|Wireless mesh {{networks}} are a promising area for thedeployment of new wireless communication and networkingtechnologies. In this paper, we address the problemof enabling effective peer-to-peer resource sharing in thistype ofnetworks. In particular, {{we consider the}} well-knownChord protocol for resource sharing in wired networks andthe recently proposed MeshChord specialization for wirelessmesh networks, and compare their performance undervarious network settings for what concerns total generatedtraffic and load balancing. Both iterative and recursive keylookup implementation in Chord/MeshChord are consideredin our extensive performance evaluation. The resultsconfirm superiority of MeshChord with respect to Chord,and show that recursive <b>key</b> <b>lookup</b> is to be preferred whenconsidering communication overhead, while similar degreeofload unbalancing is observed. However, recursive lookupimplementation reduces the efficacy of MeshChord crosslayerdesign {{with respect to the}} original Chord algorithm. MeshChord has also the advantage of reducing load unbalancingwith respect to Chord, although a moderate degreeof load unbalancing is still observed, leaving room for furtherimprovement ofthe MeshChord design...|$|E
40|$|Recently, Distributed Hash Tables (DHT) {{explicitly}} {{designed for}} the use in MANETs have been proposed. Thus, many DHT-based distributed network applications from {{the domain of the}} Internet can be expected to be efficiently ported to MANETs. While the exact <b>key</b> <b>lookups</b> provided by such DHTs might be sufficient for many applications, range queries are often a desirable feature in wireless ad hoc networks (e. g. in sensor networks). However, the implementation of range queries using DHTs is a non-trivial task. In this paper we present a straight-forward implementation of Distributed Segment Trees as proposed in [4] on top of MADPastry [3] to provide DHT-based range queries for MANETs. The main goal of this work is to gain a first insight into the question whether DHT-based approaches for range queries are feasible in MANETs. First experimental results indicate that DHTs can indeed enable efficient range queries in MANETs...|$|R
40|$|Distributed hash table-based {{overlays}} {{are widely}} used to support efficient information routing and storage in structured peer-to-peer networks, {{but they are also}} subject to numerous attacks aimed at disrupting their correct functioning. In this paper, we analyse the impact of the eclipse attack on a chord-based overlay in terms of number of <b>key</b> <b>lookups</b> intercepted by a collusion of malicious nodes. We propose a detection algorithm for the individuation of ongoing attacks to the chord overlay, relying on features that can be independently estimated by each network peer, which are given as input to a C 4. 5 -based binary classifier. Moreover, we propose some modifications to the chord routing protocol in order to mitigate the effects of such attacks. The countermeasures introduce a limited traffic overhead and can operate either in a distributed fashion or assuming the presence of a centralised trusted entity. Numerical results show the effectiveness of the proposed mitigation techniques...|$|R
40|$|NAND Flash {{has become}} the most popular stable storage medium for {{embedded}} systems. As on-board storage capacity increases, the need for efficient indexing techniques arises. Such techniques are very challenging to design due to a combination of NAND Flash constraints (for example the block-erase-before-pagerewrite constraint and limited number of erase cycles) and embedded system constraints (for example tiny RAM and resource consumption predictability). Previous work adapted traditional indexing methods to cope with Flash constraints by deferring index updates using a log and batching them to decrease the number of rewrite operations in Flash memory. However, these methods were not designed with embedded system constraints in mind and do not address them. In this paper, we propose a new alternative for indexing Flash-resident data that specifically addresses the embedded context. This approach, called PBFilter, organizes the index structure in a purely sequential way. <b>Key</b> <b>lookups</b> are sped up thanks to two principles called Summarization and Partitioning. We instantiate these principles with data structures and algorithms based on Bloom Filters and show the effectiveness of this approach through a comprehensive performance study. 1...|$|R
40|$|Abstract. Construction of overlay {{networks}} {{without any}} consideration of real network topologies causes inefficient routing in peer-to-peer net-works. This paper presents {{the design and}} evaluation of a proximity based peer-to-peer overlay network (P 3 ON). P 3 ON is composed of two-tier overlay rings. The high tier ring is a global overlay in which every node participates. Whereas, the low tier ring is a local overlay that consists of nodes in the same autonomous system (AS). Since the low tier ring consists of nearby nodes (in the same AS), the lookup latency can be sig-nificantly reduced if the first search within the low tier ring is successful. Also, to cope with skewness of load (of <b>key</b> <b>lookup)</b> distribution, P 3 ON effectively replicates the popular keys (and results) to neighbor nodes and neighbor ASs. Simulation results reveal that P 3 ON outperforms the existing ring-based P 2 P network in terms of lookup time and achieves relatively balanced load distribution...|$|E
40|$|We {{implemented}} a distributed, peer-to-peer file system in Java using the Chord protocol for efficient location of files stored across a network. Chord is a distributed <b>key</b> <b>lookup</b> technique that scales logarithmically {{with an increase}} in the number of storage nodes. Initially, we discovered problems with the Chord algorithms, and prototyped corrections to verify the changes. To implement the file sharing system, a Sockets-based messaging framework was implemented in Java, using command line interfaces and an FTP-like file push/pull semantics. The file system enables distributed peers to present a virtual single directory to users while sharing file load across different platforms. Using the application, we verified the claimed messaging performance of the basic Chord algorithm to be close to Mlog(N) behavior in an average case. The algorithms were modified to do locally-optimal balanced node joins, and experiments showed a 20 % improvement in load balancing fairness over the standard, unbalanced algorithms. We designed algorithm modifications to support concurrent joins and leaves of the Chord cloud using a variant on Raymond’s tree-based distributed mutual exclusion algorithm, and informall...|$|E
40|$|We define C 3, a model-based {{formalism}} that is {{one half}} of a framework for the modelling, specification and verification of cryptographic protocols. C 3 consists of a design language of distributed processes and an associated (SOS) notion of concurrent execution. The other half of our framework is a property-based formalism, i. e., a logic for the specification and verification of cryptographic protocols, called CPL. The two primary features of the co-design of C 3 and CPL are that reduction constraints of C 3 -processes are checkable via CPL-satisfaction, and that C 3 ’s notion of observational equivalence and CPL’s notion of propositional knowledge have a common definitional basis, namely structurally indistinguishable protocol histories. Moreover, this co-design permits separation of the concerns of protocol and property description, within the same framework. Other important features of C 3 are explicit notions of secure (out- of-band) communication and history-based <b>key</b> <b>lookup,</b> which together give a concrete foundation {{on which to base}} authentication and key establishment protocols.  Unpublished note accompanying a presentation at the Joint Workshop on Foundations of Computer Security and Automated Reasoning for Security Protocol Analysis, Seattle, August 15 - 16, 200...|$|E
40|$|Distributed {{hash tables}} (DHTs) are very {{efficient}} for querying based on <b>key</b> <b>lookups.</b> However, building huge term indexes, as required for IR-style keyword search, poses a scalability challenge for plain DHTs. Due {{to the large}} sizes of document term vocabularies, peers joining the network cause huge amounts of key inserts and, consequently, {{a large number of}} index maintenance messages. Thus, the key to exploiting DHTs for distributed information retrieval is to reduce index maintenance costs. Various approaches in this direction have been pursued, including the use of hybrid infrastructures, or changing the granularity of the inverted index to peer level. We show that indexing costs can be significantly reduced further by letting peers form groups in a self-organized fashion. Instead of each individual peer submitting index information separately, all peers of a group cooperate to publish the index updates to the DHT in batches. Our evaluation shows that this approach reduces index maintenance cost by an order of magnitude, while still keeping a complete and correct term index for query processing. 1...|$|R
5000|$|There {{are many}} {{practical}} examples of data whose valid values are restricted within a small range. A trivial hash function is a suitable choice when such data needs {{to act as}} a <b>lookup</b> <b>key.</b> Some examples include: ...|$|R
40|$|Peer-to-peer (P 2 P) systems {{research}} has gained considerable attention recently {{with the increasing}} popularity of file sharing applications. Since these applications are used for sharing huge amounts of data, {{it is very important}} to efficiently locate the data of interest in such systems. However, these systems usually do not provide efficient search techniques. Existing systems offer only keyword search functionality through a centralized index or by query flooding. In this paper, we propose a scheme based on reference vectors for sharing multi-dimensional data in P 2 P systems. This scheme effectively supports a larger set of query operations (such as k-NN queries and content-based similarity search) than current systems, which generally support only exact <b>key</b> <b>lookups</b> and keyword searches. The basic idea is to store multiple replicas of an object’s index at different peers based on the distances between the object’s feature vector and the reference vectors. Later, when a query is posed, the system identifies the peers that are likely to store the index information about relevant objects using reference vectors. Thus the system is able to return accurate results by contacting a small fraction of the participating peers...|$|R
40|$|This {{article is}} an {{editorial}} note submitted to CCR. It has NOT been peer reviewed. Authors {{take full responsibility}} for this article’s technical content. Comments can be posted through CCR Online. Peer-to-peer systems have seen a tremendous growth {{in the last few}} years and peer-to-peer traffic makes a major fraction of the total traffic seen in the Internet. The dominating application for peer-to-peer is file sharing. Some of the most popular peer-to-peer systems for file sharing have been Napster, FastTrack, BitTorrent, and eDonkey, each one counting a million or more users at their peak time. We got interested in kad, since it is the only DHT that has been part of very popular peer-to-peer system with several million simultaneous users. As we have been studying kad over the course of the last 18 months we have been both, fascinated and frightened by the possibilities kad offers. Mounting a Sybil attack is very easy in kad and allows to compromise the privacy of kad users, to compromise the correct operation of the <b>key</b> <b>lookup</b> and to mount DDOS with very little resources. In this paper, we will relate some of our findings and point out how kad can be used and misused. Categories and Subject Descriptor...|$|E
40|$|Grid {{computing}} is {{a service}} for sharing computer resources and data storage capacity over the internet. As resource requirements of recent applications increased greatly, grid systems have gained {{importance in the}} last decade. Resource discovery is the essential job in Grid computing which provides searching and identifying necessary resources for given processes. There are various Resource Discovery mechanisms in which Peer-to-Peer (P 2 P) technology witnessed a rapid development. Current Peer-to-Peer system is based on DHTs struggle with routing locality because of random node ID assignment. Locality awareness {{is one of the}} important properties of P 2 P Systems, which builds and operates their topology independently in the underlying network topology. Among structured P 2 P system Chord is well-known protocol due to its simplicity, dynamicity, scalability and flexibility in node join and departure. Due to the use of logical overlay network, Chord suffered from high routing latency and low efficiency in data lookup. In this paper, Geo-Chord is introduced, which is based on geographical location of nodes. Based on the Euclidian distance among nodes neighbors are identified and many Region-Rings are formed. Ring heads of Regions form the main Chord ring. Geo-Chord makes use of the physical network topology of the overlay network to demonstrate more efficient <b>key</b> <b>lookup.</b> Simulation results show that our proposed algorithm performs better in terms of average number of messages, hops and average communication time...|$|E
40|$|An {{important}} function in modern routers and switches is {{to perform a}} lookup for a key. Hash-based methods, and in particular cuckoo hash tables, are popular for such lookup operations, but for large structures stored in off-chip memory, such methods have the downside that they may require more than one off-chip memory access to perform the <b>key</b> <b>lookup.</b> Although the number of off-chip memory accesses can be reduced using on-chip approximate membership structures such as Bloom filters, some lookups may still require more than one off-chip memory access. This can be problematic for some hardware implementations, as having only a single off-chip memory access enables a predictable processing of lookups and avoids the need to queue pending requests. We provide a data structure for hash-based lookups based on cuckoo hashing that uses only one off-chip memory access per lookup, by utilizing an on-chip pre-filter to determine which of multiple locations holds a key. We make particular use of the flexibility to move elements within a cuckoo hash table to ensure the pre-filter always gives the correct response. While this requires a slightly more complex insertion procedure and some additional memory accesses during insertions, it is suitable for most packet processing applications where key lookups are much more frequent than insertions. An important feature of our approach is its simplicity. Our approach is based on simple logic {{that can be easily}} implemented in hardware, and hardware implementations would benefit most from the single off-chip memory access per lookup...|$|E
40|$|NAND Flash {{has become}} the most popular {{persistent}} data storage medium for mobile and embedded devices and is even being considered as a credible competitor for traditional disks. The hardware characteristics of NAND Flash (e. g. page granularity for read/write with a block-erase-before-rewrite constraint, limited number of erase cycles) preclude in-place updates. Previous works adapted traditional indexing methods to cope with these constraints mainly by deferring index updates thanks to a log and batching them to decrease the number of rewrite operations in Flash. These methods introduce a complex trade-off between read and write performance and neglect negative side-effects on the RAM consumption, Flash consumption and garbage collection cost. In this paper, we propose a new alternative for indexing Flash-resident data, designed from the outset to exploit the peculiarities of NAND Flash. This ap-proach, called PBFilter, organizes the index structure in a pure sequential way to avoid the side-effects mentioned above. <b>Key</b> <b>lookups</b> are sped up thanks to two principles called Summariza-tion and Partitioning. We instantiate these principles by data structures and algorithms based on Bloom Filters and show the effectiveness of this approach through a comprehensive perform-ance analysis. PBFilter can be instantiated with different Summarization and Partitioning algo-rithms opening up a new way to think about indexing Flash-resident data...|$|R
40|$|Searching in P 2 P {{networks}} {{is fundamental}} to all overlay networks. P 2 P networks based on Distributed Hash Tables (DHT) are optimized for single <b>key</b> <b>lookups,</b> whereas unstructured networks offer more complex queries {{at the cost of}} increased traffic and uncertain success rates. Our Distributed Tree Construction (DTC) approach enables structured P 2 P networks to perform prefix search, range queries, and multicast in an optimal way. It achieves this by creating a spanning tree over the peers in the search area, using only information available locally on each peer. Because DTC creates a spanning tree, it can query all the peers in the search area with a minimal number of messages. Furthermore, we show that the tree depth has the same upper bound as a regular DHT lookup which in turn guarantees fast and responsive runtime behavior. By placing objects with a region quadtree, we can perform a prefix search or a range query in a freely selectable area of the DHT. Our DTC algorithm is DHT-agnostic and works with most existing DHTs. We evaluate the performance of DTC over several DHTs by comparing the performance to existing application-level multicast solutions, we show that DTC sends 30 – 250 % fewer messages than common solutions. this research is funded by DFG 2 D. Bradler, J. Kangasharju, M. Mühlhäuse...|$|R
5|$|Along with {{quadratic}} probing {{and double}} hashing, linear probing {{is a form}} of open addressing. In these schemes, each cell of a hash table stores a single key–value pair. When the hash function causes a collision by mapping a new key to a cell of the hash table that is already occupied by another key, linear probing searches the table for the closest following free location and inserts the new <b>key</b> there. <b>Lookups</b> are performed in the same way, by searching the table sequentially starting at the position given by the hash function, until finding a cell with a matching key or an empty cell.|$|R
