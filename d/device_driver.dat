1077|1730|Public
5|$|Once an {{alternate}} boot partition has been created, the TPM module {{needs to be}} initialized (assuming that this feature is being used), after which the required disk encryption key protection mechanisms such as TPM, PIN or USB key are configured. The volume is then encrypted as a background task, something that may take {{a considerable amount of}} time with a large disk as every logical sector is read, encrypted and rewritten back to disk. The keys are only protected after the whole volume has been encrypted, when the volume is considered secure. BitLocker uses a low-level <b>device</b> <b>driver</b> to encrypt and decrypt all file operations, making interaction with the encrypted volume transparent to applications running on the platform.|$|E
25|$|Using a lower-level <b>device</b> <b>driver</b> (file drivers using disk drivers).|$|E
25|$|A {{connected}} storage device, {{such as a}} hard drive, is accessed {{through a}} <b>device</b> <b>driver.</b> The <b>device</b> <b>driver</b> understands the specific language of the drive {{and is able to}} translate that language into a standard language used by the operating system to access all disk drives. On UNIX, this is the language of block devices.|$|E
40|$|Writing Windows NT <b>device</b> <b>drivers</b> {{can be a}} {{daunting}} task. <b>Device</b> <b>drivers</b> must be fully re-entrant, must use only limited resources and must be created with special development environments. Executing <b>device</b> <b>drivers</b> in user-mode offers significant coding advantages. User-mode <b>device</b> <b>drivers</b> have access to all user-mode libraries and applications. They can be developed using standard development tools and debugged on a single machine. Using the Proxy Driver to retrieve I/O requests from the kernel, user-mode drivers can export full device services to the kernel and applications. User-mode <b>device</b> <b>drivers</b> offer enormous flexibility for emulating devices and experimenting with new file systems. Experimental results show that in many cases, the overhead of moving to user-mode for processing I/O can be masked by the inherent costs of accessing physical devices. 1. Introduction The creation of <b>device</b> <b>drivers</b> {{is one of the}} most difficult challenges facing Windows NT developers. <b>Device</b> <b>drivers</b> [...] ...|$|R
5000|$|... inspect service dependencies, {{discovering}} which {{services or}} <b>device</b> <b>drivers</b> {{depend on a}} given service or upon which services or <b>device</b> <b>drivers</b> a given service depends ...|$|R
50|$|The Linux kernel is a {{monolithic}} kernel, hence <b>device</b> <b>drivers</b> are kernel components. To ease {{the burden of}} companies maintaining their (proprietary) <b>device</b> <b>drivers</b> out-of-tree, stable APIs for the <b>device</b> <b>drivers</b> have been repeatedly requested. The Linux kernel developers have repeatedly denied guaranteeing stable in-kernel APIs for <b>device</b> <b>drivers.</b> Guaranteeing such would have faltered {{the development of the}} Linux kernel in the past and would still in the future and, {{due to the nature of}} free and open-source software, are not necessary. Ergo, by choice, the Linux kernel has no stable in-kernel API.|$|R
25|$|AMDGPU is AMD's {{open source}} <b>device</b> <b>driver</b> {{supporting}} the GCN architecture, available for Linux.|$|E
25|$|AMD Catalyst is a {{collection}} of proprietary <b>device</b> <b>driver</b> software available for Microsoft Windows and Linux.|$|E
25|$|Implementing {{certain parts}} in {{operating}} systems and networking requires systems programming, for example implementing paging (virtual memory) or a <b>device</b> <b>driver</b> for an operating system.|$|E
40|$|<b>Device</b> <b>drivers</b> {{have always}} been complex {{software}} that are written at the operating system level. They are knit {{with the rest of}} the operating system kernel and work by interacting with it. Writing <b>device</b> <b>drivers</b> is a cumbersome task because writing and debugging the kernel code is very difficult. It is thus desirable to have a mechanism for implementing user level <b>device</b> <b>drivers.</b> In thi...|$|R
40|$|<b>Device</b> <b>drivers</b> are {{the major}} cause of {{operating}} system failure. Prior research proposed frameworks to improve the reliability of <b>device</b> <b>drivers</b> by means of driver restart. While avoiding any instrumentation of the driver, this approach does not always allow graceful recovery. In this paper, we propose a framework for self-healing <b>device</b> <b>drivers</b> that lets the driver developer consider and implement the failure recovery of <b>device</b> <b>drivers.</b> For this purpose, our framework provides {{easy to use and}} light-weight persistent memory that preserves the state of the driver needed to successfully recover. We developped a prototype on top of the L 4 microkernel, and were able to achieve full recovery of crashed drivers as fast as 0. 2 ms for different <b>device</b> <b>drivers.</b> In all cases, recovery was totally transparent for the user. ...|$|R
5000|$|Kernel mode <b>device</b> <b>drivers</b> must be 64-bit versions; {{there is}} no way to run 32-bit kernel mode executables within the 64-bit {{operating}} system. User mode <b>device</b> <b>drivers</b> can be either 32-bit or 64-bit.|$|R
25|$|It {{should be}} noted that Kernel Patch Protection only defends against device drivers modifying the kernel. It does not offer any {{protection}} against one <b>device</b> <b>driver</b> patching another.|$|E
25|$|NAND devices {{also require}} bad block {{management}} by the <b>device</b> <b>driver</b> software, or by a separate controller chip. SDcards, for example, include controller circuitry to perform bad block management and wear leveling. When a logical block is accessed by high-level software, it is mapped to a physical block by the <b>device</b> <b>driver</b> or controller. A number of blocks on the flash chip may {{be set aside}} for storing mapping tables to deal with bad blocks, or the system may simply check each block at power-up to create a bad block map in RAM. The overall memory capacity gradually shrinks as more blocks are marked as bad.|$|E
25|$|Bad block {{management}} {{is a relatively}} new feature in NORchips. In older NOR devices not supporting bad block management, the software or <b>device</b> <b>driver</b> controlling the memory chip must correct for blocks that wear out, or the device will cease to work reliably.|$|E
5000|$|The Microsoft Windows [...]sys {{files and}} Linux [...]ko modules contain loadable <b>device</b> <b>drivers.</b> The {{advantage}} of loadable <b>device</b> <b>drivers</b> {{is that they}} can be loaded only when necessary and then unloaded, thus saving kernel memory.|$|R
50|$|TI-RTOS Drivers and Board Initialization: Target-specific <b>device</b> <b>drivers.</b> Drivers include Ethernet, GPIO, I²C, I²S, PWM, SPI, UART, USB, Watchdog timer, and Wi-Fi.|$|R
50|$|As {{with most}} optical disc-based copy {{protection}} systems (such as SafeDisc, StarForce, etc.), Tagès installs its own <b>device</b> <b>drivers</b> {{as a part}} of the copy protection system. The Tagès <b>device</b> <b>drivers</b> are installed on the first launch of any Tagès-protected application.|$|R
25|$|An {{additional}} firewall {{virtual machine}} {{is used to}} house the Linux-kernel-based firewall, so {{that even if the}} network domain is compromised due to a <b>device</b> <b>driver</b> bug, the firewall is still isolated and protected (as it is running in a separate Linux kernel in a separate VM).|$|E
25|$|Windows 95 {{was able}} to reduce the role of MS-DOS in Windows much further than had been done in Windows 3.1x and earlier. According to Microsoft {{developer}} Raymond Chen, MS-DOS served two purposes in Windows 95: as the boot loader, and as the 16-bit legacy <b>device</b> <b>driver</b> layer.|$|E
25|$|Under {{versions}} of Windows before Vista and {{versions of}} Linux before 2.6, all driver execution was co-operative, meaning {{that if a}} driver entered an infinite loop it would freeze the system. More recent revisions of these operating systems incorporate kernel preemption, where the kernel interrupts the driver to give it tasks, and then separates itself from the process until it receives a response from the <b>device</b> <b>driver,</b> or gives it more tasks to do.|$|E
50|$|Making {{decisions}} about which data elements are prioritized for NAND flash memory {{is at the}} core of SSHD technology. Products offered by various vendors may achieve this through device firmware, through <b>device</b> <b>drivers</b> or through software modules and <b>device</b> <b>drivers.</b>|$|R
40|$|Running <b>device</b> <b>drivers</b> as unprivileged user-level code, {{encapsulated}} {{into their}} own process, has often been proposed as a technique for increasing system robustness. However, in the past, systems based on user-level drivers have generally exhibited poor I/O performance. Consequently, user-level <b>device</b> <b>drivers</b> have never caught on to any significant degree. In this paper we demonstrate {{that it is possible}} to build systems which employ user-level <b>device</b> <b>drivers,</b> without significant performance degradation, even for high-bandwidth devices such as Gigabit Ethernet...|$|R
5000|$|Windows 95 was {{designed}} to be maximally compatible with existing MS-DOS and 16-bit Windows programs and <b>device</b> <b>drivers,</b> while offering a more stable and better performing system. The Windows 95 architecture is an evolution of Windows for Workgroups' 386 enhanced mode. The lowest level of the operating system consists {{of a large number of}} virtual <b>device</b> <b>drivers</b> (VxDs) running in 32-bit protected mode and one or more virtual DOS machines running in virtual 8086 mode. The virtual <b>device</b> <b>drivers</b> are responsible for handling physical devices (such as video and network cards), emulating virtual devices used by the virtual machines or providing various system services. The three most important virtual <b>device</b> <b>drivers</b> are: ...|$|R
25|$|ODBC {{is based}} on the <b>device</b> <b>driver</b> model, where the driver encapsulates the logic needed to convert a {{standard}} set of commands and functions into the specific calls required by the underlying system. For instance, a printer driver presents a standard set of printing commands, the API, to applications using the printing system. Calls made to those APIs are converted by the driver into the format used by the actual hardware, say PostScript or PCL.|$|E
25|$|Handles {{plug and}} play and {{supports}} device detection and installation at boot time. It also has the responsibility to stop and start devices on demand—this can happen when a bus (such as USB or IEEE 1394 FireWire) gains a new device and {{needs to have a}} <b>device</b> <b>driver</b> loaded to support it. Its bulk is actually implemented in user mode, in the Plug and Play Service, which handles the often complex tasks of installing the appropriate drivers, notifying services and applications of the arrival of new devices, and displaying GUI to the user.|$|E
25|$|Note, too, {{that some}} {{nominally}} bi-endian CPUs require motherboard help to fully switch endianness. For instance, the 32-bit desktop-oriented PowerPC processors in little-endian mode act as little-endian {{from the point}} of view of the executing programs, but they require the motherboard to perform a 64-bit swap across all 8 byte lanes to ensure that the little-endian view of things will apply to I/O devices. In the absence of this unusual motherboard hardware, <b>device</b> <b>driver</b> software must write to different addresses to undo the incomplete transformation and also must perform a normal byte swap.|$|E
40|$|This paper {{presents}} a new mechanism that enables applications to run correctly when <b>device</b> <b>drivers</b> fail. Because <b>device</b> <b>drivers</b> {{are the principal}} failing component in most systems, reducing driver-induced failures greatly improves overall reliability. Earlier work has shown that an operating system can survive driver failures [33], but the applications that depend on them cannot. Thus, while operating system reliability was greatly improved, application reliability generally was not. To remedy this situation, we introduce a new operating system mechanism called a shadow driver. A shadow <b>driver</b> monitors <b>device</b> <b>drivers</b> and transparently recovers from driver failures. Moreover, it assumes {{the role of the}} failed driver during recovery. In this way, applications using the failed driver, as well as the kernel itself, continue to function as expected. We implemented shadow drivers for the Linux operating system and tested them on over a dozen <b>device</b> <b>drivers.</b> Our results show that applications and the OS can indeed survive the failure of a variety of <b>device</b> <b>drivers.</b> Moreover, shadow drivers impose minimal performance overhead. Lastly, they can be introduced with only modest changes to the OS kernel and with no changes at all to existing <b>device</b> <b>drivers.</b> ...|$|R
2500|$|<b>Device</b> <b>drivers</b> in Windows 9x can be virtual <b>device</b> <b>drivers</b> or (starting with Windows 98) WDM drivers. VxDs {{usually have}} the {{filename}} extension [...]vxd or [...]386, whereas WDM compatible drivers usually use the extension [...]sys. The 32-bit VxD message server (msgsrv32) {{is a program}} that is able to load virtual <b>device</b> <b>drivers</b> (VxDs) at startup and then handle communication with the drivers. Additionally, the message server performs several background functions, including loading the Windows shell (such as Explorer.exe or Progman.exe).|$|R
50|$|All {{hardware}} developers provide <b>device</b> <b>drivers</b> {{for their}} products over a range of operating systems. But some developers of graphics hardware provide no free and open-source drivers for their hardware and they provide little or no technical documentation to support independent development of free and open-source <b>device</b> <b>drivers</b> {{for their products}}. The free and open-source <b>device</b> <b>drivers</b> available for hardware with support for independent driver development are generally of much higher quality in terms of completeness, stability, security performance than drivers for hardware that lack such support.|$|R
25|$|When a {{hardware}} device triggers an interrupt, the operating system's kernel decides {{how to deal}} with this event, generally by running some processing code. The amount of code being run depends on the priority of the interrupt (for example: a person usually responds to a smoke detector alarm before answering the phone). The processing of hardware interrupts is a task that is usually delegated to software called a <b>device</b> <b>driver,</b> which may be part of the operating system's kernel, part of another program, or both. Device drivers may then relay information to a running program by various means.|$|E
25|$|Each Net-Lib {{supported}} {{network protocol}} has a separate driver (not {{to be confused}} with a <b>device</b> <b>driver),</b> and has support for a session layer in its protocol stack. There are two general types of Net-Lib: the primary and the secondary. The primary Net-Lib consists of a Super Socket Net-Lib and the Shared Memory Net-Lib, while there are numerous secondary Net-Libs, including TCP/IP and named pipes network libraries (named pipes are a method of communicating with other processes via a system-persistent pipeline that is given an identity). The Microsoft OLE DB Provider for SQL Server (SQLOLEDB) communicates via primary Net-Libs.|$|E
25|$|When the kernel has an {{appropriate}} <b>device</b> <b>driver</b> in place, it can then access {{the contents of}} the disk drive in raw format, which may contain one or more file systems. A file system driver is used to translate the commands used to access each specific file system into a standard set of commands that the operating system can use to talk to all file systems. Programs can then deal with these file systems on the basis of filenames, and directories/folders, contained within a hierarchical structure. They can create, delete, open, and close files, as well as gather various information about them, including access permissions, size, free space, and creation and modification dates.|$|E
40|$|The Slam toolkit {{demonstrates}} that predicate abstraction enables automated verification of real world Windows <b>device</b> <b>drivers.</b> Our predicate abstraction-based tool DDVerify enables the automated verification of Linux <b>device</b> <b>drivers</b> and provides an accurate {{model of the}} relevant parts of the kernel. We report on benchmarks based on Linux <b>device</b> <b>drivers,</b> confirming the results that Slam established for the Windows world. Furthermore, we take predicate abstraction one step further and introduce a technique to verify concurrent software with shared memory. Categories and Subject Descriptors:D. 2. 4 [Software Engineering]...|$|R
5000|$|Ease of deployment. In general, {{the fewer}} {{privileges}} an application requires {{the easier it}} is to deploy within a larger environment. This usually results from the first two benefits, applications that install <b>device</b> <b>drivers</b> or require elevated security privileges typically have additional steps involved in their deployment. For example, on Windows a solution with no <b>device</b> <b>drivers</b> can be run directly with no installation, while <b>device</b> <b>drivers</b> must be installed separately using the Windows installer service in order to grant the driver elevated privileges.|$|R
50|$|System Configuration Program (SCP): {{configure}} <b>device</b> <b>drivers.</b>|$|R
