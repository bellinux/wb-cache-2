15|65|Public
2500|$|... {{variables}} are initialized by default to zero. They {{can be assigned}} or initialized to the named values defined by the <b>enumeration</b> <b>type.</b>|$|E
5000|$|Before C++11, {{the values}} of {{variables}} {{could be used in}} constant expressions only if the variables are declared const, have an initializer which is a constant expression, and are of integral or <b>enumeration</b> <b>type.</b> C++11 removes the restriction that the variables must be of integral or <b>enumeration</b> <b>type</b> if they are defined with the [...] keyword: ...|$|E
5000|$|... an <b>enumeration</b> <b>type</b> and a “flags” type, both {{corresponding}} to C’s [...] type, but differing {{in that the}} latter is only used for bit fields ( [...] and [...] ); ...|$|E
5000|$|Both C and Pascal include <b>enumeration</b> <b>types.</b> A Pascal example: ...|$|R
50|$|In C++03, {{enumerations}} are not type-safe. They {{are effectively}} integers, {{even when the}} <b>enumeration</b> <b>types</b> are distinct. This allows the comparison between two enum values of different <b>enumeration</b> <b>types.</b> The only safety that C++03 provides is that an integer or a value of one enum type does not convert implicitly to another enum type. Further, the underlying integral type is implementation-defined; code {{that depends on the}} size of the enumeration is thus non-portable. Lastly, enumeration values are scoped to the enclosing scope. Thus, it is not possible for two separate enumerations to have matching member names.|$|R
5000|$|C++ has <b>enumeration</b> <b>types</b> {{that are}} {{directly}} inherited from C's and work mostly like these, except that an enumeration {{is a real}} type in C++, giving added compile-time checking. Also (as with structs), the C++ [...] keyword is automatically combined with a typedef, so that instead of naming the type , simply name it [...] This can be simulated in C using a typedef: ...|$|R
5000|$|Enumeration data type: Enumeration {{values are}} simple strings such as red, green, and blue for an rgb-enumeration. In {{the case that}} an <b>enumeration</b> <b>type</b> is {{declared}} extensible it can be extended in other schemas.|$|E
5000|$|Select data type: Selects {{define a}} choice or an {{alternative}} between different options. Most commonly used are selects between different entity_types. More rare are selects that include defined types. In {{the case that}} an <b>enumeration</b> <b>type</b> is declared extensible, it can be extended in other schemas.|$|E
5000|$|C++11 {{provides}} a second, type-safe <b>enumeration</b> <b>type</b> {{that is not}} implicitly converted to an integer type. It allows io streaming to be defined for that type. Additionally the enumerations do not leak, {{so they have to}} be used with Enumeration [...] This is specified by the phrase [...] "enum class". For example: ...|$|E
50|$|Ada's type {{system is}} not based on a set of {{predefined}} primitive types but allows users to declare their own types. This declaration in turn {{is not based on}} the internal representation of the type but on describing the goal which should be achieved. This allows the compiler to determine a suitable memory size for the type, and to check for violations of the type definition at compile time and run time (i.e., range violations, buffer overruns, type consistency, etc.). Ada supports numerical types defined by a range, modulo types, aggregate types (records and arrays), and <b>enumeration</b> <b>types.</b> Access types define a reference to an instance of a specified type; untyped pointers are not permitted.Special types provided by the language are task types and protected types.|$|R
5000|$|Even more, {{one can use}} {{enumerations}} as indexes for arrays like Pascal, {{but there}} are attributes defined for enumerations Shuffle : constant array(Cardsuit) of Cardsuit := (Clubs => Cardsuit'Succ(Clubs), -- see attributes of enumerations 'First, 'Last, 'Succ, 'Pred Diamonds => Hearts, --an explicit value Hearts => Cardsuit'Last, --first <b>enumeration</b> value of <b>type</b> Cardsuit e.g., clubs Spades => Cardsuit'First --last <b>enumeration</b> value of <b>type</b> Cardsuit e.g., spades [...] ); ...|$|R
40|$|Free datatypes {{unify the}} {{concepts}} of <b>enumeration</b> <b>types,</b> disjoint unions and recursive types, and are used for defining new terms and operations on them. They correspond to the mathematical concept of term algebras and are a fundamental part of typed functional languages for representing dynamic data structures. But free datatypes are types and not algebras and this results in several drawbacks. The most important is the implicit binding of the constructors to identifiers without any explicit binding statement. We discuss these drawbacks and propose an explicit language construct for creating term algebras. This is a small extension for languages that already include constructs for building structures and signatures, and brings us all the advantages of free datatypes without their shortcomings. Several examples are presented in this formalism. ...|$|R
50|$|The Global JXDM, Version 3.0.3 Global Justice XML Data Dictionary (Global JXDD) {{types and}} {{properties}} are rendered as XML Schema types, elements, and attributes. Also included {{are the most}} current <b>enumeration</b> <b>type</b> schemas (code tables) and their proxy schemas. Version 3.0.3 is compatible with Versions 3.0.2 and 3.0. See the FAQ on compatibility for an explanation.|$|E
50|$|C# has {{implemented}} enumerations in {{a manner}} similar to C, that is as wrappers around the bit-flags implemented in primitive integral types (int, byte, short, etc.). This has performance benefits and improves interaction with C/C++ compiled code, but provides fewer features and can lead to bugs if low-level value types are directly cast to an <b>enumeration</b> <b>type,</b> as is allowed in the C# language. Therefore, it is seen as syntactic sugar. In contrast, Java implements enumerations as full featured collection of instances, requiring more memory and not aiding interaction with C/C++ code, but providing additional features in reflection and intrinsic behavior. The implementation in each language is described in the table below.|$|E
5000|$|Internally, each enum value {{contains}} an integer, {{corresponding to the}} order in which they are declared in the source code, starting from 0. The programmer cannot set a custom integer for an enum value directly, but one can define overloaded constructors that can then assign arbitrary values to self-defined members of the enum class. Defining getters allows then access to those self-defined members. The internal integer can be obtained from an enum value using the [...] method, and the list of enum values of an <b>enumeration</b> <b>type</b> can be obtained in order using the [...] method. It is generally discouraged for programmers to convert enums to integers and vice versa. Enumerated types are , using the internal integer; as a result, they can be sorted.|$|E
5000|$|In C++, booleans, characters, integer numbers, floating-point numbers, arrays, classes—including strings, lists, dictionaries, sets, stacks, queues—and <b>enumerations</b> are value <b>types,</b> while {{references}} and pointers are reference types.|$|R
40|$|This paper {{compares the}} tasks of type {{checking}} and type inference {{in the context of}} a simple many-sorted prescriptive type system. Type inference is an extension of type checking in the context of incomplete type declarations; while checking the well-typedness of some expressions, type inference also infers type declarations for undeclared symbols. The basis of our approach is a declarative representation of the concept of a well-typed expression by a formal denition in a logic theory. We show that type checking can be implemented as a deductive task with respect to this logical theory augmented with an exhaustive <b>enumeration</b> of <b>type</b> declarations. We show that type inference can be implemented as an abductive task with respect to the same logical theory augmented with a partial <b>enumeration</b> of <b>type</b> declarations and some axioms expressing general properties of the type system. 1 Introduction This paper studies two tasks {{in the context of a}} simple many-sorted prescriptive type system [...] ...|$|R
40|$|The {{introduction}} of Java 5. 0 came {{along with an}} extension of the language syntax. Several new language features as generic <b>types</b> and <b>enumeration</b> <b>types</b> were added to the language specification. These features cause downward-incompatibilities, code written in Java 5. 0 will not work on older versions of the Java runtime environment. For some active projects, however, {{it is not possible to}} upgrade to higher Java versions, since some code might not be supported on Java 5. 0. If one still wants to use components written in Java 5. 0, these must be downgraded. Up to now this has been accomplished mostly by transforming the byte code of these programs. In this thesis, we present a set of transformations which transform Java 5. 0 source code to Java 1. 4 compatible code. We successfully apply these transformations to two larger projects and compare our approach to the up to now common byte-code based tools...|$|R
40|$|We have {{generated}} better MQL, this time using enumerations wherever possible, so that queries that worked on versions 4 and 4 b still work on 2016, 2017 and c. We use a single <b>enumeration</b> <b>type</b> across all features, so that different features with equal values {{can be compared}} in queries. We have corrected many broken links in the documentation. This release happens on the celebration of "ETCBC ≥ 40 years"...|$|E
40|$|An {{important}} {{challenge in}} software reengineering is to encapsulate collections of related data that, {{due to the}} absence of appropriate constructs for encapsulation in legacy programming languages, may be distributed throughout the code. The encapsulation of such collections is a necessary step for reengineering a legacy system into an objectoriented design or implementation. Encapsulating a set of related symbolic constants into an <b>enumeration</b> <b>type</b> is an instance of this problem. We present a classification of how enumeration types are modeled using symbolic constants in real-world programs, a set of heuristics to identify candidate enumeration types, and an experimental evaluation of these heuristics...|$|E
40|$|A {{mathematical}} model is proposed for scheduling activities of periodic type. First a model is proposed for scheduling periodic events with particular time constraints. This problem, {{which could be}} considered the extension to periodic phenomena of ordinary scheduling with precedence constraints, is shown to be NP-complete. An algorithm for it of implicit <b>enumeration</b> <b>type</b> is designed based on network flow results, and its average complexity is discussed. Some extensions of the model are considered. The results of this first part serve as a basis in modelling periodic activities using resources. Several cases are considered. Finally some applications are presented for which the proposed model can be a useful tool...|$|E
40|$|While Java {{continues}} to gain popularity in both industry and academia, few Java programming environments enable {{the user to}} directly interact with the code. Professional environments require developers to use a command line interface to execute Java code. In contrast, our DrJava programming environment supports a read-eval-print-loop (REPL) incorporating a Java interpreter called DynamicJava [...] -enabling developers to execute arbitrary fragments of Java code on-the-fly. DynamicJava was developed at the University of Nice, but development ceased in 2002 with DynamicJava supporting Java 1. 3. In 2004, the Java language was extended in the Java 1. 5 (renamed 5. 0) release. To support Java 5. 0 in DrJava, we were confronted {{with the task of}} extending DynamicJava to support the new language features. This dissertation describes the new features in Java 5. 0 [...] -including generic types, autoboxing, variable arguments, static import, foreach, <b>enumeration</b> <b>types</b> and metadata [...] -and explains how we extended the existing DynamicJava code base to support them...|$|R
5000|$|The Programmer's Hierarchical Interactive Graphics System (PHIGS) {{was one of}} {{the first}} {{programmatic}} efforts at interactive visualization and provided an <b>enumeration</b> of the <b>types</b> of input humans provide. People can: ...|$|R
40|$|In {{this paper}} {{we look back}} to work done in the late 1980 s, and that looked at links between grammars, data types and {{recursion}} principles, and illustrating it with examples that include <b>enumerations</b> of <b>types</b> and developing a structure editor. The work is introduced by a historical foreword, and closes with an afterword that discusses some of the subsequent developments of these ideas...|$|R
40|$|Abstract. Evolutionary Testing (ET) {{has been}} shown to be very {{successful}} in testing real world applications [16]. However, it has been pointed out [11], that further research is necessary if flag variables appear in program expressions. The problems increase when ET is used to test state-based applications where the encoding of states hinders successful evolutionary tests. This is because the ET performance is reduced to a random test in case of the use of flag variables or variables that encode an <b>enumeration</b> <b>type.</b> The authors have developed an ET System to provide easy access to automatic testing. An extensive set of programs has been tested using this system [4], [16]. This system is extended for new areas of software testing and research has been carried out to improve its performance. This paper introduces a new approach for solving ET problems with flag conditions. The problematic constructs are explained with the help of code examples originally found in large real world applications. 1 Introduction to the Flag Proble...|$|E
40|$|Vita [...] Texas A&M UniversityThe {{discrimination}} problem {{consisting of}} classifying an nxl observation vector as coming {{from one of}} two multivariate normal distributions which differ both in their mean vectors and covariance matrices is considered. A search for the procedure which minimizes the expected cost of misclassification is conducted within the class of procedures based upon a certain combination of n independent univariate discriminations. An efficient search of this class of procedures is made by employing an algorithm of the implicit <b>enumeration</b> <b>type</b> used in integer programming. In the case of known population parameters, the independent discriminant functions and exact probabilities of misclassification are found. When the parameters are unknown, estimates are introduced for the coefficients of each univariate discriminant function and for the probabilities of misclassification. A jackknife procedure is introduced {{in order to improve}} the estimation process. The method is applied to the problem classifying a set of male twins as to whether they are monozygotic or dizygotic...|$|E
40|$|International audienceIn {{the past}} decade, {{the number of}} couples {{consulting}} an assisted reproductive techniques (ART) center for infertility has increased in most European countries. In France, sperm bacterial examination must be performed every 6  months in couples undergoing in vitro fertilization (IVF) cycles, according to 2010 French ART Guidelines. The {{aim of this study}} was to analyze the results from such samples at Nantes University Hospital and to assess their potential value for infertile couples undergoing ART cycles. Between 2003 and 2008, semen cultures performed were analyzed according to bacterial <b>enumeration,</b> <b>type</b> and number of bacterial species, and their antibiotic resistance profile. A total of 14, 119 semen cultures were performed, showing an annual increase of 45 % from the start to the end of the study. The proportion of positive semen cultures was stable throughout the study period (40 to 45 %). Many bacterial species were considered as contaminants (coagulase-negative staphylococci, alpha-hemolytic streptococci). For pathogen agents (in most cases, Enterobacteriaceae), the antibiotic resistance profile revealed mostly a susceptible phenotype. Finally, every positive bacterial result had direct consequences on the IVF cycle management, with subsequent reinforced advice on the hygiene procedure before sample collection and/or antibiotics prescription...|$|E
3000|$|The Energy ADE Core module, {{defining}} {{a number of}} abstract base classes and some generally used data <b>types,</b> <b>enumerations</b> and codelists, and extending the CityGML feature classes _AbstractBuilding and _CityObject with new properties; [...]...|$|R
50|$|This {{language}} feature {{was introduced}} in J2SE 5.0. Technically enumerations {{are a kind of}} class containing enum constants in its body. Each enum constant defines an instance of the enum <b>type.</b> <b>Enumeration</b> classes cannot be instantiated anywhere except in the enumeration class itself.|$|R
5000|$|In C#, {{structures}} ( [...] keyword)—including booleans, characters, integer numbers, floating-point {{numbers and}} fixed-point numbers, lists, dictionaries, sets, stacks, queues, optionals—and <b>enumerations</b> are value <b>types,</b> while classes ( [...] keyword)—including immutable strings, arrays, tuples, lists, dictionaries, sets, stacks, queues—, interfaces and pointers are reference types.|$|R
40|$|Some {{formulae}} {{are given}} for the <b>enumeration</b> of certain <b>types</b> of dissections of the convex (n+ 2) -gon by non-crossing diagonals. The classical Schroeder and Motzkin numbers are addressed using a cataloguing tool, the "reversive symbol". The elementary details are referred to three Web addresses. Comment: 2 page...|$|R
40|$|AbstractWe {{describe}} a combinatorial model which encompasses the <b>enumeration</b> of many <b>types</b> of ordered structures {{and determine the}} behavior of three random variables which record certain numerical parameters of such structures. Examples to which our results are applicable include chains in binomial posets, direct sum decompositions of finite vector spaces, binary words, and Fishburn's generalized weak orders...|$|R
40|$|For {{the exact}} <b>enumeration</b> of various <b>types</b> of {{constrained}} secondary structures, this pa-per presents some recursion formulas and derives some properties {{which are based}} on the recursion relation about S(n) given by Waterman in [7]. And a classification of secondary structure by complexity is discussed. Furthermore, we obtain some relations on RNA sec-ondary structures of a given order...|$|R
5000|$|You {{can also}} specify a step by low:high:step. Alternatively you can specify a <b>type</b> (<b>enumeration</b> or integer ranged type) to specify a loop over {{a range of}} values or a set to loop over all {{elements}} of the set or you can specify an array to loop over an array. You can also specify a pointer:next to walk through a list. For example, if defining: ...|$|R
40|$|We enumerate {{smooth and}} rationally smooth Schubert {{varieties}} {{in the classical}} finite types A, B, C, and D, extending Haiman's <b>enumeration</b> for <b>type</b> A. To do this enumeration, we introduce a notion of staircase diagrams on a graph. These combinatorial structures are collections of steps of irregular size, forming interconnected staircases over the given graph. Over a Dynkin-Coxeter graph, the set of "nearly-maximally labelled" staircase diagrams is in bijection with the set of Schubert varieties with a complete Billey-Postnikov (BP) decomposition. We can then use an earlier result of the authors showing that all finite-type rationally smooth Schubert varieties have a complete BP decomposition to finish the enumeration. Comment: 42 pages, 3 table...|$|R
40|$|AbstractComplex groups {{generated}} by involutory reflexions arise naturally {{in the modern}} theory of abstract regular polytopes. The paper investigates this relationship and explains how the enumeration of certain finite universal regular polytopes can be accomplished through the <b>enumeration</b> of certain <b>types</b> of finite complex reflexion groups. In particular, the paper enumerates all the finite groups and their diagrams which arise in this context, and describes the corresponding regular polytopes...|$|R
