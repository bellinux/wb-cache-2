1|888|Public
40|$|Allocates {{primary memory}} to {{processes}} Maps process address space to primary memory Minimizes access time using cost effective memory configuration ◮ Memory management approaches range from primitive bare-machine approach to sophisticated paging and segmentation strategies for implementing virtual memory. Relocating Executables ◮ Compile, Link, and Load phases. ◮ Source program, relocatable object modules, absolute program. ◮ <b>Dynamic</b> <b>address</b> <b>relocation</b> using relocation registers. ◮ Memory protection using limit registers. (violating the limit generates an hardware interrupt, often called segment violation, {{that results in}} a fatal execution error.) Building the address spac...|$|E
5000|$|Protection system {{instructions:}} reference {{the storage}} protection system, memory or <b>address</b> <b>relocation</b> system: ...|$|R
5000|$|... <b>address</b> <b>relocation</b> {{hardware}} on all S/370s {{except the}} original models 155 and 165 ...|$|R
50|$|Multi-system operationPoOps {{is a set}} of {{features}} to support multi-processor systems, e.g., Direct Control, direct <b>address</b> <b>relocation</b> (prefixing).|$|R
5000|$|By contrast, [...] "in 1972, the System/370 Advanced Function was {{released}} and had new <b>Address</b> <b>Relocation</b> Hardware and now supported four new operating systems (VM/370, DOS/VS, OS/VS1, OS/VS2)." ...|$|R
5000|$|IBM VM/370 Discontinuous Saved Segments (DCSS) were {{an early}} {{example of this}} {{technique}}, though not called rebasing. The technique is used extensively on Win32 platforms to avoid the overhead of <b>address</b> <b>relocation</b> of system DLLs by the loader.|$|R
40|$|In this paper, we {{show that}} the use of <b>dynamic</b> <b>addressing</b> can enable {{scalable}} routing in ad hoc networks. It is well known that the current ad hoc protocol suites do not scale to work efficiently in networks of more than a few hundred nodes. Most current ad hoc routing architectures use flat static addressing and thus, need to keep track of each node individually, creating a massive overhead problem as the network grows. Could <b>dynamic</b> <b>addressing</b> alleviate this problem? To begin to answer this question, we provide an initial design of a routing layer based on <b>dynamic</b> <b>addressing,</b> and evaluate its performance. Each node has a unique permanent identifier and a transient routing address, which indicates its location in the network at any given time. The main challenge is <b>dynamic</b> <b>address</b> allocation in the face of node mobility. We propose mechanisms to implement <b>dynamic</b> <b>addressing</b> efficiently. Our initial evaluation suggests that <b>dynamic</b> <b>addressing</b> is a promising approach for achieving scalable routing in meganode ad hoc networks...|$|R
40|$|Increasing the {{locality}} of {{a memory}} access profile {{is an interesting}} optimization problem, whose solution has implications on both performance and energy consumption of a processor-based system. High-locality memory access patterns are normally obtained through software-driven transformations, applied either at the source-code level or during compilation and machine-code generation. For some specific classes of systems, e. g., embedded systems, hardware-oriented, on-the-fly access pattern modification is also an option, as it trades generality in the applicability for better performance. This paper presents a class of algorithms for improving the locality of a given memory access profile through selective <b>address</b> <b>relocation</b> that require a very low-overhead custom hardware unit. Results obtained {{on a set of}} typical embedded applications show an average reduction in the complexity of the <b>address</b> <b>relocation</b> unit around 40 %, yet with the best achievable increase in memory access locality...|$|R
40|$|Abstract — In this paper, we {{show that}} the use of <b>dynamic</b> <b>addressing</b> can enable {{scalable}} routing in ad hoc networks. It is well known that the current ad hoc protocol suites do not scale to work efficiently in networks of more than a few hundred nodes. Most current ad hoc routing architectures use flat static addressing and thus, need to keep track of each node individually, creating a massive overhead problem as the network grows. Could <b>dynamic</b> <b>addressing</b> alleviate this problem? To begin to answer this question, we provide an initial design of a routing layer based on <b>dynamic</b> <b>addressing,</b> and evaluate its performance. Each node has a unique permanent identifier and a transient routing address, which indicates its location in the network at any given time. The main challenge is <b>dynamic</b> <b>address</b> allocation in the face of node mobility. We propose mechanisms to implement <b>dynamic</b> <b>addressing</b> efficiently. Our initial evaluation suggests that <b>dynamic</b> <b>addressing</b> is a promising approach for achieving scalable routing in meganode ad hoc networks. 1 I...|$|R
50|$|Several memory {{systems are}} {{supported}} in the specification. Physical-only is {{suited to the}} smallest embedded systems. Hardware <b>address</b> <b>relocation</b> using a single set of base-and-bound registers permits different code to run at the same <b>address.</b> Hardware <b>relocation</b> for two separate sets of base and bound registers permits processes with different RAM to share the same code, or permits a system to run code from read-only memory. These options are suitable for systems that keep all code and data in memory. Applications include intermediate-sized embedded systems, and fast supercomputers that operate from memory. There are also three UNIX-style virtual memory systems for memory cached in mass-storage systems.|$|R
5000|$|RFC 5061 Stream Control Transmission Protocol (SCTP) <b>Dynamic</b> <b>Address</b> Reconfiguration ...|$|R
5000|$|Optional MMU {{supporting}} both {{memory protection}} and <b>dynamic</b> <b>address</b> translation.|$|R
5000|$|A Self Configuring and Self Administrating Name System with <b>Dynamic</b> <b>Address</b> Assignment ...|$|R
40|$|Secure Routing {{is one of}} the {{important}} issues in wireless sensor networks. A number of approaches have been proposed for secure routing in wireless sensor networks, but {{there is a lack of}} sufficient support for quick &secure routing in large-scale sensor networks. We consider the <b>dynamic</b> <b>address</b> routing for wireless sensor networks. We consider two security algorithms namely RSA (Rivest, Shamir &Adleman), Elliptic Curve Cryptography (ECC) as an initial test for <b>dynamic</b> <b>address</b> routing protocol for wireless sensor networks. We consider five routing attacks such as Directory attack, Brutal attack, Wormhole attack, Sinkhole attack and Sybil attack against <b>dynamic</b> <b>address</b> routing in wireless sensor networks. In this paper, we propose a common key cryptographic security algorithm named Random Number Addressing Cryptography (RAC) for providing energy efficient secure <b>dynamic</b> <b>address</b> routing protocol for scalable wireless sensor networks. RAC security algorithm works energyefficiently and provides better security than RSA and ECC...|$|R
40|$|This paper {{proposes a}} {{protocol}} independent <b>Dynamic</b> <b>Addressing</b> scheme for Wireless Media Access Protocols, and discusses related systems and performance issues. <b>Dynamic</b> <b>Addressing</b> allows {{spatial and temporal}} reuse of MAC addresses, thereby reducing the address size {{by a factor of}} 8. This reduces the control overhead in a MACAW [2] style protocol by 30 % to 70 %, and produces an overall performance improvement of 5 % to 33 %. <b>Dynamic</b> <b>Addressing</b> also serves as an enabling technology for two important features in wireless media access protocols - security, and real-time support - as described in related papers. We are implementing the <b>Dynamic</b> <b>Addressing</b> scheme {{as a part of the}} LCMACA wireless media access protocol. 1 Introduction Recent years have witnessed the rapid development of mobile computing devices, such as PDAs, palmtops, and portable computers. A crucial technology that has enabled this development is wireless networking. In the very near future, wireless LANs connecting a variety [...] ...|$|R
5000|$|A <b>Dynamic</b> <b>Address</b> Translation {{mechanism}} {{that can be}} used to implement a virtual memory system ...|$|R
5000|$|An {{instruction}} {{set for the}} smallest [...] "embedded" [...] CPUs (set [...] "E") is reduced in other ways: Only 16 of the 32-bit integer registers are supported. Floating-point instructions should not be supported (the specification forbids it as uneconomical), so a floating-point software library must be used. The compressed set [...] "C" [...] is recommended. The privileged {{instruction set}} supports only machine mode, user mode and memory schemes that use base-and-bound <b>address</b> <b>relocation.</b>|$|R
5000|$|The use of Virtual {{memory and}} <b>Dynamic</b> <b>Address</b> Translation (DAT) on the IBM S/360-67 in 1967.|$|R
40|$|<b>Dynamic</b> <b>address</b> {{assignment}} {{is one of}} the most important features in wireless ad hoc networks if nodes should be enabled to join and to work in the network by automatically configuring all necessary settings. Different approaches have been developed throughout the last years to achieve this objective of <b>Dynamic</b> <b>Address</b> Autoconfiguration but research primarily focused on efficiency and correctness, less on security issues. Whereas Duplicate Address Detection has become reliable in commonplace scenarios, it is still relatively easy to suspend the whole network functionality in extraordinary situations within the boundaries of a <b>Dynamic</b> <b>Address</b> Configuration Protocol. In this paper, we therefore want to point out shortcomings and weaknesses in existing protocol solutions which <b>address</b> <b>dynamic</b> IP <b>address</b> assignment. We concentrate on a leader-based approach called ODACP and want to propose several solutions which improve the original protocol in such a way that it is safer against malicious host activities. Finally, we will demonstrate the improvements of our solution in a separate test scenario...|$|R
50|$|It {{included}} <b>Dynamic</b> <b>address</b> translation (DAT) hardware, a pre-requisite {{for the new}} {{virtual memory}} operating systems (OS/VS1, OS/VS2).|$|R
5000|$|The [...] "DAT Box" [...] (<b>Dynamic</b> <b>Address</b> Translation), {{announced}} as {{an addition to}} the S/370 series in 1972 ...|$|R
50|$|Stevenson, Herbert F. Keswick's Authentic Voice: Sixty-five <b>Dynamic</b> <b>Addresses</b> Delivered at the Keswick Convention 1875-1957. London: Marshall, Morgan & Scott, 1959.|$|R
40|$|With today’s rapidly {{improving}} link-layer technology, and {{the widespread}} adoption of wireless networking, {{the creation of}} large-scale ad hoc networks {{could be construed as}} all but inevitable. Current ad hoc protocol suites do not scale to work efficiently in networks of more than a few hundred nodes. We believe the main reason behind the lack of scalability is that current protocols use flat and static addressing. In this paper, we provide an initial design of a routing layer based on <b>dynamic</b> <b>addressing</b> by providing a separation between address and identity. Each node has a unique permanent identifier and a transient routing address, which indicates its location in the network at any given time. We propose mechanisms to implement <b>dynamic</b> <b>addressing</b> efficiently. Our initial design suggests that <b>dynamic</b> <b>addressing</b> is a promising approach and worth further examination...|$|R
50|$|Peripheral {{processor}} (PP or PPU) {{instructions are}} {{completely different from}} CPU instructions. Peripheral processor hardware is simpler; it has an 18-bit A (accumulator register, a 12-bit Program Address register, a 12-bit Q register (not programmer-visible), and a 22-bit R register (used to accomplish <b>address</b> <b>relocation</b> during central memory read and write instructions on Cyber 180 systems). No special job validation was required to assemble peripheral processor programs, but to be executed, such programs were required to installed into the operating system via special system editing commands.|$|R
5000|$|MIT {{input to}} S/360: IBM {{personnel}} {{with close ties}} to MIT became [...] "strong proponents of time-sharing" [...] and kept System/360 designers aware of work at MIT, including the purpose of the CTSS hardware enhancements. System/360 architects visited MIT and talked with Professor Corbató. Nevertheless, the IBM belief was now that [...] "time-sharing would never amount to anything and that what the world needed was faster batch processing." [...] When the System/360 was announced in 1964 without <b>address</b> <b>relocation,</b> MIT and other time-sharing advocates felt betrayed.|$|R
50|$|The {{invention}} of <b>dynamic</b> <b>address</b> translation (the function provided by an MMU) originally reduced {{the need for}} position-independent code because every process could have its own independent address space (range of addresses). However, multiple simultaneous jobs using the same code created a waste of physical memory. If two jobs run entirely identical programs, <b>dynamic</b> <b>address</b> translation provides a solution by allowing the system simply to map two different jobs' address 32K to the same bytes of real memory, containing the single copy of the program.|$|R
5000|$|It offered [...] "dynamic {{relocation}} of problem programs using the <b>dynamic</b> <b>address</b> translation facilities of the 2067 Processing Unit, permitting response, within seconds, to many simultaneous users" ...|$|R
25|$|Some {{references}} {{in a program}} or library module are stored in a relative or symbolic form which cannot be resolved until all code and libraries are assigned final static <b>addresses.</b> <b>Relocation</b> {{is the process of}} adjusting these references, and is done either by the linker or the loader. In general, relocation cannot be done to individual libraries themselves because the addresses in memory may vary depending on the program using them and other libraries they are combined with. Position-independent code avoids references to absolute addresses and therefore does not require relocation.|$|R
5000|$|... thereby {{permitting}} {{operations on}} up to 2^24-1 bytes (16 MB), vs. the 256-byte limits on the 360's MVC and CLC, but lacked a DAT (<b>Dynamic</b> <b>Address</b> Translation) box.|$|R
40|$|Abstract Online {{services}} {{often use}} IP addresses as client identifierswhen enforcing access-control decisions. The academic community has typically eschewed this approach, how-ever, {{due to the}} effect that NATs, proxies, and <b>dynamic</b> <b>addressing</b> have on a server's ability to identify individualclients. Yet, it is unclear to what extent these edge technolo-gies actually impact the utility of using IP addresses as client identifiers. This paper provides some insights intothis phenomenon. We do so by mapping out the size and extent of NATs and proxies, as well as characterizing thebehavior of <b>dynamic</b> <b>addressing...</b>|$|R
40|$|Abstract. The stream control {{transmission}} protocol (SCTP) {{is a new}} transport protocol, which provides multi-streaming and multi-homing features. Especially, recent SCTP extensions with <b>dynamic</b> <b>address</b> reconfiguration supports transport layer mobility. We address web agent framework supporting seamless transport layer mobility in the wired and wireless environment. Our proposed framework for mobile web agent deploys SCTP with <b>dynamic</b> <b>address</b> reconfiguration. Mean response time is an important performance measure of web agents. Our simulation results show that our SCTP based framework reduces the mean response time of a typical transmission control protocol (TCP) based framework remarkably. ...|$|R
5000|$|<b>Dynamic</b> <b>Address</b> Translation (DAT) {{with support}} for 24 or 32-bit virtual {{addresses}} using segment and page tables (up to 16 segments each containing up to 256 4096 byte pages) ...|$|R
40|$|Abstract [...] - In {{this paper}} we have {{analyzed}} the algorithms, {{in which we}} can analyze the dynamic generation of IP addresses. This concept is based on the application level server logs. The algorithm will take the input (either DNS or IPs) from log on server to produce the identification and signification of <b>dynamic</b> IP <b>addresses</b> for the user in university campus use <b>dynamic</b> IP <b>address.</b> <b>Dynamic</b> IP <b>address</b> may be counted in a fraction of total number of static IP address which can change in a certain time of span. On the basis of this concept we can study and research that how <b>dynamic</b> IP <b>address</b> can use in our university (SGVU) campus WI-FI network. By these results we can analyze the importance of <b>dynamic</b> IP <b>addresses</b> for resolving different types of internet attacks and IP conflicts. We expect the benefits of dynamic IP generation is to enhance the security level of the university WI-FI network and to protect ou...|$|R
30|$|In addition, {{in order}} to protect the digital evidence, from {{contamination}} and loss of continuity, Delport et al. proposed methods to isolate suspected cloud instances in cloud environments. The researchers discussed the benefits and challenges of several means of isolating crime scene (instance, under investigation) in the cloud, including relocating the instance manually or automatically, server farming, collecting evidence from a failover instance, <b>address</b> <b>relocation,</b> sandboxing instances, using man-in-the-middle analysis on cloud virtual machines, and following a “let’s hope for the best” approach, which involves imaging the relevant cloud nodes in a similar manner to traditional forensics [63].|$|R
50|$|Virtual Memory (VM) {{and demand}} paging support {{were added to}} UMMPS in November 1967, making MTS the first {{operating}} system to use the <b>Dynamic</b> <b>Address</b> Translation (DAT) features that {{were added to the}} IBM S/360-67.|$|R
5000|$|Distribution: Lock server and 64-bit object IDs support <b>dynamic</b> <b>addressing</b> space (with each {{federation}} {{capable of}} managing up to 65,535 individual databases and 10^24 bytes (one quadrillion gigabytes, or a yottabyte) of physical addressing space).|$|R
