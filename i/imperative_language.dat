538|1305|Public
500|$|Though {{primarily}} an <b>imperative</b> <b>language,</b> C# 2.0 offered limited support for functional programming through first-class functions and closures {{in the form}} of anonymous delegates. C# 3.0 expanded support for functional programming with the introduction of a lightweight syntax for lambda expressions, extension methods (an affordance for modules), and a list comprehension syntax {{in the form of}} a [...] "query comprehension" [...] language.|$|E
2500|$|A {{library is}} also a {{collection}} of implementations of behavior, written {{in terms of a}} language, that has a well-defined interface by which the behavior is invoked. For instance, people who want to write a higher level program can use a library to make system calls instead of implementing those system calls over and over again. In addition, the behavior is provided for reuse by multiple independent programs. [...] A program invokes the library-provided behavior via a mechanism of the language. [...] For example, in a simple <b>imperative</b> <b>language</b> such as C, the behavior in a library is invoked by using C's normal function-call. [...] What distinguishes the call as being to a library function, versus being to another function in the same program, is the way that the code is organized in the system.|$|E
5000|$|QVT-Operational is an <b>imperative</b> <b>language</b> {{designed}} for writing unidirectional transformations.|$|E
40|$|The {{semantics}} of <b>imperative</b> <b>languages</b> {{are often}} {{expressed in terms}} of a store-passing translation and an algebra for reasoning about stores. We axiomatize the semantics of several typical <b>imperative</b> <b>languages</b> via equational axioms by "inverting" the storepassing translation as well as the algebraic axioms for reasoning about the store. The inversion process is simple and systematic and results in theories that are similar to equational theories for <b>imperative</b> <b>languages</b> that have been derived in more complicated ways, and is likely to be applicable to languages other than those presented here. 1 A Semantic Toolkit for <b>Imperative</b> <b>Languages</b> The mathematical semantics of <b>imperative</b> <b>languages</b> conventionally regards the store as a primitive concept [16 :p. 203]. Using a "store-passing transformation", imperative operations are translated to explicit operations on a concrete representation of the store in an augmented lambda-calculus. The resulting store constructs typically have a simple sem [...] ...|$|R
50|$|Implementation {{techniques}} include <b>imperative</b> <b>languages</b> (object-oriented or procedural), functional languages, {{and logic}} languages.|$|R
25|$|One {{criticism}} of <b>imperative</b> <b>languages</b> is the {{side effect of}} an assignment statement on a class of variables called non-local variables.|$|R
5000|$|Introduced P′′, {{the first}} <b>imperative</b> <b>language</b> without GOTO to be proved Turing-complete.|$|E
50|$|For <b>imperative</b> <b>language</b> the {{overhead}} is {{to define the}} function, for functional language {{the overhead}} is to define the accumulator variable x.|$|E
50|$|Like most query languages, D4 has a Data Definition Language (DDL) and a Data Manipulation Language (DML). D4 {{also has}} an <b>Imperative</b> <b>Language</b> for {{procedural}} code.|$|E
50|$|State-full <b>imperative</b> <b>languages</b> such as ALGOL and Pascal {{essentially}} {{implement a}} let expression, to implement restricted scope of functions, in block structures.|$|R
50|$|Most {{computer}} programming languages support recursion by allowing a function to call itself within the program text. Some functional programming languages do not define any looping constructs but {{rely solely on}} recursion to repeatedly call code. Computability theory proves that these recursive-only languages are Turing complete; they are as computationally powerful as Turing complete <b>imperative</b> <b>languages,</b> meaning they can solve {{the same kinds of}} problems as <b>imperative</b> <b>languages</b> even without iterative control structures such as “while” and “for”.|$|R
50|$|<b>Imperative</b> <b>languages</b> such as Java {{provide a}} notion of {{imperative}} variables, which basically represent memory locations that can be written to and read from.|$|R
50|$|The {{scripting}} language is an <b>imperative</b> <b>language,</b> lacking most program flow control structures, but containing many features familiar to programmers, including variables, distinct datatypes, conditionals, and complex expressions.|$|E
50|$|In {{this section}} we compare how {{particular}} programming idioms are handled in a functional language with first-class functions (Haskell) {{compared to an}} <b>imperative</b> <b>language</b> where functions are second-class citizens (C).|$|E
50|$|Immutability of {{data can}} {{in many cases}} lead to {{execution}} efficiency by allowing the compiler to make assumptions that are unsafe in an <b>imperative</b> <b>language,</b> thus increasing opportunities for inline expansion.|$|E
40|$|Abstract: An <b>imperative</b> {{programming}} <b>language</b> {{is defined}} by closure of a free word-algebra of de/con-structors under two new operators (simultaneous safe recurrence and constructive diagonalization). By assigning ordinals to its programs a transfinite hierarchy of <b>imperative</b> <b>languages</b> is introduced which singles-out the feasible classes DTIMEF(n k) and the superexponential classes DTIMEF (k n) ...|$|R
40|$|Most commonly-used {{programming}} {{languages are}} imperative: they {{consist of a}} sequence of actions that alter {{the state of the}} world. State includes the values of program variables and also the program’s external environment (e. g. files the program reads or writes). High-level <b>imperative</b> <b>languages</b> mimic the style of the underlying Von Neumann machine architecture, where programs are sequences of instructions that modify the contents of registers and memory locations. This makes it relatively straightforward to compile <b>imperative</b> <b>languages</b> to efficient code: • High-level variables are mapped to machine locations. • High-level operations are mapped to (multiple) machine instructions. <b>Imperative</b> <b>languages</b> are also natural for writing reactive programs that interact with the state of the “real world. ” Examples: • Reading mouse clicks and modifying the contents of a display. • Controlling a set of relays in an external device...|$|R
50|$|In <b>imperative</b> {{programming}} <b>languages,</b> values can {{generally be}} accessed or changed at any time. In pure functional and logic languages, variables {{are bound to}} expressions and keep a single value during their entire lifetime due {{to the requirements of}} referential transparency. In <b>imperative</b> <b>languages,</b> the same behavior is exhibited by constants, which are typically contrasted with normal variables.|$|R
50|$|The <b>Imperative</b> <b>Language</b> in D4 {{is remarkably}} similar to Pascal in many respects. The largest {{distinction}} being that D4 also allows DDL and DML statements to be run in regular procedural code.|$|E
50|$|XC is an <b>imperative</b> <b>language,</b> {{based on}} the {{features}} for parallelism and communication in occam, and the syntax and sequential features of C. It provides primitive features that correspond to the various architectural resources provided, namely: channel ends, locks, ports and timers.|$|E
50|$|ISWIM is an <b>imperative</b> <b>language</b> with a {{functional}} core, {{consisting of a}} syntactic sugaring of lambda calculus to which are added mutable variables and assignment and a powerful control mechanism—the J operator. Being based on lambda calculus ISWIM has higher order functions and lexically scoped variables.|$|E
40|$|Course aims Programming {{languages}} communicate {{programs to}} a computer and every computing professional must know their history, purposes, styles and means of implementation. While use of an object-oriented programming language (i. e. Java) was used in first year courses, COSC 230 looks at the history and concepts of functional and logic-based programming styles, {{as well as at}} implementation techniques for <b>imperative</b> <b>languages.</b> Students will learn basic techniques for implementing <b>imperative</b> <b>languages</b> and how to employ and choose competently among a variety of programming tools, including functional and logic-based languages...|$|R
40|$|Architecture The Alma Abstract Architecture (AAA) is {{the virtual}} {{architecture}} {{used during the}} intermediate code generation phase of the Alma- 0 compiler. The AAA combines {{the features of the}} abstract machines for <b>imperative</b> <b>languages</b> and for logic programming languages. The compiler compiles the Alma- 0 programs into AAA programs. In a second phase the AAA instructions are translated into C statements. As the Alma- 0 language itself, the AAA aims to combine the best of both worlds; elements were taken from virtual machines used to compile <b>imperative</b> <b>languages</b> (in particular the RISC architecture described in Wirth [1996, pp. 55 [...] 59], and from the WAM machine used to compile a logical language (see Ait-Kaci [1991]). Still, the AAA resembles most the virtual machines used in the compilation of <b>imperative</b> <b>languages.</b> The additions made to provide for the extensions of the Alma- 0 language are [...] -the failure handling instructions ONFAIL, FAIL, 40 Δ Krzysztof R. Apt et al [...] -the log [...] ...|$|R
50|$|OptimJ {{combines}} concepts from object-oriented <b>imperative</b> <b>languages</b> with concepts from algebraic modeling languages for optimization problems. Here we {{will review}} the optimization concepts added to Java, starting with a concrete example.|$|R
50|$|Instead {{of logic}} programming, {{constraints}} can be mixed with functional programming, term rewriting, and imperative languages.Programming languages with built-in support for constraints include Oz (functional programming) and Kaleidoscope (imperative programming). Mostly, constraints are implemented in imperative languages via constraint solving toolkits, which are separate libraries for an existing <b>imperative</b> <b>language.</b>|$|E
5000|$|The {{factorial}} function {{provides a good}} example of how the fixed point combinator may be applied to functions of two variables. The result demonstrates simple recursion, as would be implemented in a single loop, in an <b>imperative</b> <b>language.</b> The definition of numbers used is explained in Church encoding. The fixed point function is, ...|$|E
50|$|XL {{features}} programmer-reconfigurable syntax and semantics. Compiler plug-ins {{can be used}} to add {{new features}} to the language. A base set of plug-ins implements a relatively standard <b>imperative</b> <b>language.</b> Programmers can write their own plug-ins to implement application-specific notations, such as symbolic differentiation, which can then be used as readily as built-in language features.|$|E
50|$|Wilhelm is {{co-author}} of the book Compiler Construction, which teaches not only compilers for <b>imperative</b> <b>languages,</b> but for object-oriented, functional and logical ones as well and stresses theoretical foundation. It is available in German and French, too.|$|R
50|$|The {{definition}} {{in terms}} of a representation was often done in <b>imperative</b> <b>languages</b> such as ALGOL and Pascal, while the definition {{in terms of}} a value space and behaviour was used in higher-level languages such as Simula and CLU.|$|R
50|$|Therefore, {{the rules}} for calculating ABC vector {{slightly}} differ based on the language. We define the ABC metric calculation rules for C, C++ and Java below. Based on these rules {{the rules for}} other <b>imperative</b> <b>languages</b> can be interpreted.|$|R
50|$|Applied to a {{function}} with one variable the Y combinator usually does not terminate. More interesting results are obtained {{by applying the}} Y combinator to functions {{of two or more}} variables. The second variable may be used as a counter, or index. The resulting function behaves like a while or a for loop in an <b>imperative</b> <b>language.</b>|$|E
5000|$|Though {{primarily}} an <b>imperative</b> <b>language,</b> C# 2.0 offered limited support for functional programming through first-class functions and closures {{in the form}} of anonymous delegates. C# 3.0 expanded support for functional programming with the introduction of a lightweight syntax for lambda expressions, extension methods (an affordance for modules), and a list comprehension syntax {{in the form of}} a [...] "query comprehension" [...] language.|$|E
50|$|Short-circuit {{operators}} are, in effect, {{control structures}} rather than simple arithmetic operators, {{as they are}} not strict. In <b>imperative</b> <b>language</b> terms (notably C and C++), where side effects are important, short-circuit operators introduce a sequence point - they completely evaluate the first argument, including any side effects, before (optionally) processing the second argument. ALGOL 68 used proceduring to achieve user defined short-circuit operators & procedures.|$|E
50|$|The Y {{combinator}} is an {{implementation of}} a fixed-point combinator in lambda calculus. Fixed-point combinators may also be easily defined in other functional and <b>imperative</b> <b>languages.</b> The implementation in lambda calculus is more difficult due to limitations in lambda calculus.|$|R
40|$|Polymorphic types, {{higher order}} functions, and partial {{application}} are common features in functional programming languages. They allow a compact formulation of algorithms and their integration into <b>imperative</b> <b>languages</b> will increase expressiveness. Current approaches to integrate functional features into <b>imperative</b> <b>languages</b> are either {{based on the}} definition of a new language, or implemented as a runtime mechanism. While the first variant needs a special compiler, the second is less efficient and may not support polymorphic types. In this paper we will present a method of how to integrate functional features into C++ without the need of runtime mechanisms, special preprocessors, or compilers. As a practical application of these features we will demonstrate how parallel environments can benefit from these features...|$|R
40|$|Traditional <b>imperative</b> <b>languages</b> (such as C) {{and modern}} {{object-oriented}} languages are plagued by uncontrolled resource aliasing problems. Add in concurrency {{and the problems}} compound exponentially. Improperly synchronised access to shared (i. e. aliased) resources leads to problems of race-hazard, deadlock, livelock and starvation...|$|R
