107|703|Public
5000|$|Performance analysis: After the {{simulation}} is finished and data is {{available as a}} time-stamped <b>event</b> <b>trace.</b> This data can then be statistically analysed with tools like R to draw conclusions.|$|E
5000|$|Common Modules with Internetworks: Applications (Traffic Generator): Voice, Video, FTP, Database, HTTP, Email, Peer-to-peer and Custom. Encryption: AES, DES. Virtual Network Stack, Simulation Kernel, Command Line Interface, Wireshark Interface, Metrics Engine with Packet Trace and <b>Event</b> <b>Trace,</b> Packet Animator ...|$|E
5000|$|The monitor verifies the {{received}} <b>event</b> <b>trace</b> {{and produces}} a verdict whether the specification is satisfied. Additionally the monitor sends {{feedback to the}} system to possiblly correct false behaviour. When using offline monitoring the system of cause cannot receive any feedback, as the verification is done at a later point in time.|$|E
40|$|This paper {{presents}} a pragmatic {{approach to the}} specification of functionality of object-oriented applications. The approach relies on <b>event</b> <b>traces,</b> which are used to depict the co-operation between objects. <b>Event</b> <b>traces</b> model the communication between the objects, whereas object models provide a static view of object structures. Together these two notations form the backbone of object modelling, {{and they can be}} used consistently throughout the development process. In the analysis phase, <b>event</b> <b>traces</b> provide a black-box view of the system that is to be implemented. <b>Event</b> <b>traces</b> are also used to illustrate how the end user communicates with the user interface. In the design phase <b>event</b> <b>traces</b> illustrate what architectural decisions have been made and how the design objects co-operate with each other. The implementation phase can also be supported by <b>event</b> <b>traces.</b> This paper explains how we use <b>event</b> <b>traces</b> in real software projects. Our approach combines ideas from various object-orient [...] ...|$|R
5000|$|WMI <b>event</b> <b>tracing</b> cannot, by itself, {{automatically}} {{generate the}} [...] {{part of the}} trace message. This is a limitation of all such technologies, not specific to WMI <b>event</b> <b>tracing.</b>|$|R
50|$|The Vista {{and later}} Resource Monitor heavily leverages the <b>Event</b> <b>Tracing</b> for Windows (ETW) {{facilities}} introduced in Windows 7;the counter setup (<b>event</b> <b>tracing</b> session) {{used by the}} Resource Monitor can provide logging as well.|$|R
50|$|The WMI {{extensions}} to WDM provide kernel-level instrumentation such as publishing information, configuring device settings, supplying event notification from device {{drivers and}} allowing administrators to set data security through a WMI provider {{known as the}} WDM provider. The extensions {{are part of the}} WDM architecture; however, they have broad utility and can be used with other types of drivers as well (such as SCSI and NDIS). The WMI Driver Extensions service monitors all drivers and <b>event</b> <b>trace</b> providers that are configured to publish WMI or <b>event</b> <b>trace</b> information. Instrumented hardware data is provided by way of drivers instrumented for WMI extensions for WDM. WMI extensions for WDM provide a set of Windows device driver interfaces for instrumenting data within the driver models native to Windows, so OEMs and IHVs can easily extend the instrumented data set and add value to a hardware/software solution. The WMI Driver Extensions, however, are not supported by Windows Vista and later operating systems.|$|E
50|$|The Lagos Marathon is a {{marathon}} held annually in :Lagos, Nigeria. The Lagos International Marathon {{was preceded by}} several recurring half marathons held in the city.The origins of the <b>event</b> <b>trace</b> back to 1983 when the first ever Lagos international marathon took place. Over 20,000 athletes competed in the February 6, 2016 event which was sponsored by Access Bank. The marathon course record is held by a Kenyan national, Abraham Kipton who completed the race in 2 hours, 16 minutes and 21 seconds. The fastest woman is the Ethiopian Halima Hussein Kayo, who ran a time of 2 hours, 38 minutes and 36 seconds.The Marathon course which spans {{a distance of about}} 42km, starts at National Stadium, Lagos, (where previous half marathons initially finished), continues along the Third Mainland Bridge and finishes at Eko Atlantic.|$|E
50|$|The Toronto Marathon, held {{annually}} in May, is a race from Mel Lastman Square, {{in the north}} end of Toronto, to Ontario Place. The race was initially called the Canadian International Marathon, and was first held in 1995 under its current organizer. The origins of the <b>event</b> <b>trace</b> back to 1977. In 2003, its name was changed to the Toronto Marathon. In 2008, it was again renamed for a new primary sponsor, GoodLife Fitness. It was held previously on the third Sunday in October, the first Sunday after Canadian Thanksgiving, for 16 consecutive years. Because of concerns that the Toronto Waterfront Marathon was being held three weeks prior lead to too many road closures, the Toronto Marathon is now run in May, beginning in 2011. The event was temporarily held mid-May in 2011, due to other events in the City of Toronto that year. The event is now held on the first Sunday in May, beginning in 2012.|$|E
40|$|Many {{performance}} monitoring tools are currently {{available to the}} super-computing community. The performance data gathered and analyzed by these tools fall under two categories: statistics and <b>event</b> <b>traces.</b> Statistical data is much more compact but lack the probative power <b>event</b> <b>traces</b> offer. <b>Event</b> <b>traces,</b> on the other hand, can easily fill up the entire file system during execution such that the instrumented execution have to be terminated. In this paper, we propose an innovative methodology for monitoring and trace representation that offers a middle ground. The user can trace-off trace data size vs. quality incrementally. Specifically, the user {{will be able to}} limit the amount of trace collected and, at the same time, carry out some of the analysis <b>event</b> <b>traces</b> offer for the entire execution. With the help of a few CFD examples, we illustrate the use of our technique in performance tuning. We also compare quantitatively, the quality of the traces we collected vs. <b>event</b> <b>traces...</b>|$|R
40|$|The two commonly-used {{performance}} data {{types in the}} super-computing community, statistics and <b>event</b> <b>traces,</b> are discussed and compared. Statistical data are much more compact but lack the probative power <b>event</b> <b>traces</b> offer. <b>Event</b> <b>traces,</b> on the other hand, are unbounded and can easily fill up the entire file system during program execution. In this paper, we propose an innovative methodology for {{performance data}} gathering and representation that offers a middle ground. Two basic ideas are employed: the use of averages to replace recording data for each instance and formulae to represent sequences associated with communication and control flow. The user can trade off tracing overhead, trace data size with data quality incrementally. In other words, the user {{will be able to}} limit the amount of trace data collected and, at the same time, carry out some of the analysis <b>event</b> <b>traces</b> offer using space-time views. With the help of a few simple examples, we illustrate the use of these techniqu [...] ...|$|R
5000|$|The [...] "St. Vitus Dance" [...] musical <b>event</b> <b>traces</b> the {{tradition}} of San Vito Tarantella.|$|R
40|$|AbstractHighly effcient {{encoding}} of <b>event</b> <b>trace</b> data is {{a quality}} feature of any <b>event</b> <b>trace</b> format. It not only enables measurements of long running applications but also reduces bias caused by intermediate memory buffer flushes. In this paper we present encoding techniques that will remarkably increase memory effciency without introducing overhead for the compression. We applied these techniques to the Open Trace Format 2, a state-of-the-art Open Source <b>event</b> <b>trace</b> data format and library {{used by the}} performance analysis tools Vampir, Scalasca, and Tau. In addition, we show that these encoding techniques are a basic step in achieving a complete in-memory <b>event</b> <b>trace</b> work flow...|$|E
40|$|Object-oriented methodologies {{are often}} used for {{developing}} highly reliable systems. In object-oriented methodologies, state transition diagrams and <b>event</b> <b>trace</b> diagrams are {{used to describe the}} system behavior. The state transition diagram describes the behavior of each object while the <b>event</b> <b>trace</b> diagrams describes inter-object behavior. <b>Event</b> <b>trace</b> diagrams may include the timing order of object's output events which are not important when considering the inter-object behavior model. This leads to a higher system complexity and increases the risk of errors. We propose the Event Dependency Graph(EDG) to describe inter-object essential behavior. Using EDG, we can characterize and specify communication and interaction among objects. In this paper, we characterize a certain communication model, called Statechart-type communication model(SCM), using EDG. We also compare two communication models, The SCM model and an Asynchronous communication model. 1. INTRODUCTION Object-oriented me [...] ...|$|E
3000|$|We shall {{first recall}} basic {{concepts}} {{related to the}} validation of event traces in various contexts. For the needs of this paper, an <b>event</b> <b>trace</b> [...]...|$|E
40|$|<b>Event</b> <b>tracing</b> is a {{powerful}} method for analyzing the performance behavior of parallel applications. Because <b>event</b> <b>traces</b> record the temporal and spatial relationships between individual runtime events, they allow application developers to analyze dependences of performance phenomena across concurrent control flows. However, {{in view of the}} large amounts of data generated on contemporary parallel machines, the depth and coverage of a purely manual analysis is often limited. Our approach automatically searches <b>event</b> <b>traces</b> for patterns of inefficient behavior, classifies detected instances by category, and quantifies the associated performance penalty. This enables developers to study the performance of their applications at a high level of abstraction, while requiring significantly less time and expertise than a manual analysis. Copyright (c) 2006 John Wiley & Sons, Ltd...|$|R
40|$|IOMMU <b>event</b> <b>tracing</b> feature enables {{reporting}} IOMMU {{events as}} they happen during boot-time and run-time. As an example, when a device is detached from host and {{assigned to a}} virtual machine, the device gets moved from host domain to vm domain. Enabling IOMMU <b>event</b> <b>tracing</b> will provide useful information about the devices that are using IOMMU as well as as the changes that occur in device assignments. In this talk, we will discuss the IOMMU <b>event</b> <b>tracing</b> feature and how to enable {{and use it to}} <b>trace</b> <b>events</b> during boot-time and run-time. The discussion will be focused on using the IOMMU tracing feature to get insight into what's happening on a system in virtualized environments as devices get assigned from host to virtual machines and vice versa. Linux kernel developers and users can learn about a feature that can aid during development, maintenance, and support of systems with IOMMU...|$|R
5000|$|Several {{kinds of}} <b>event</b> <b>tracing</b> are defined, mostly {{depending}} {{on a high}} speed auxiliary port to offload the voluminous data without negatively impacting program execution: ...|$|R
40|$|This paper {{suggests}} {{an approach to}} formal software system architecture specification based on behavior models. The behavior {{of the system is}} defined as a set of events (<b>event</b> <b>trace)</b> with two basic relations: precedence and inclusion. The structure of <b>event</b> <b>trace</b> is specified using event grammars and other constraints organized into schemas. The schema framework is amenable to stepwise architecture refinement up to executable design and implementation models, reuse, composition, visualization, and application of automated tools for consistency checks. ACM Category D. 2. 11 Software Architecture...|$|E
40|$|OOPSLA’ 09 /Onward conference, OOPSLA Companion, October 2009, pp. 1031 - 1038 This paper {{suggests}} {{an approach to}} formal software system architecture specification based on behavior models. The behavior {{of the system is}} defined as a set of events (<b>event</b> <b>trace)</b> with two basic relations: precedence and inclusion. The structure of <b>event</b> <b>trace</b> is specified using event grammars and other constraints organized into schemas. The schema framework is amenable to stepwise architecture refinement up to executable design and implementation models, reuse, composition, visualization, and application of automated tools for consistency checks...|$|E
40|$|Abstract. This paper {{describes}} a new meta-tool named EARL {{which consists of}} a new highlevel trace analysis language and its interpreter which allows to easily construct new trace analysis tools. Because of its programmability and flexibility, EARL {{can be used for}} a wide range of <b>event</b> <b>trace</b> analysis tasks. It is especially well-suited for automatic and for view on an <b>event</b> <b>trace</b> the EARL interpreter provides to the user, and give an overview about the EARL language. Finally, a set of EARL script examples are used to demonstrate the features of EARL. ...|$|E
40|$|Many {{performance}} monitoring tools are currently {{available to the}} super-computing community. The performance data gathered and analyzed by these tools fall under two categories: statistics and <b>event</b> <b>traces.</b> Statistical data is much more compact but lacks the probative power <b>event</b> <b>traces</b> offer. <b>Event</b> <b>traces,</b> on the other hand, can easily fill up the entire file system during execution such that the instrumented execution {{may have to be}} terminated half way through. In this paper, we propose an innovative methodology for performance data gathering and representation that offers a middle ground. The user can trade-off tracing overhead, trace data size vs. data quality incrementally. In other words, the user will be able to limit the amount of trace collected and, at the same time, carry out some of the analysis <b>event</b> <b>traces</b> offer using space-time views for the entire execution. Two basic ideas arc employed: the use of averages to replace recording data for each instance and formulae to represent sequences associated with communication and control flow. With the help of a few simple examples, we illustrate the use of these techniques in performance tuning and compare the quality of the traces we collected vs. <b>event</b> <b>traces.</b> We found that the trace files thus obtained are, in deed, small, bounded and predictable before program execution and that the quality of the space time views generated from these statistical data are excellent. Furthermore, experimental results showed that the formulae proposed were able to capture 100 % of all the sequences associated with 11 of the 15 applications tested. The performance of the formulae can be incrementally improved by allocating more memory at run-time to learn longer sequences...|$|R
2500|$|The traces model {{defines the}} meaning of a process {{expression}} as the set of sequences of <b>events</b> (<b>traces)</b> that the process can be observed to perform. For example, ...|$|R
40|$|International audienceThe {{off-line}} (or post-mortem) {{analysis of}} execution <b>event</b> <b>traces</b> {{is a popular}} approach to understand the performance of HPC applications that use the message passing paradigm. Combining this analysis with simulation {{makes it possible to}} " replay " the application execution to explore " what if? " scenarios, e. g., assessing application performance in a range of (hypothetical) execution environments. However, such off-line analysis faces scalability issues for acquiring, storing, or replaying large <b>event</b> <b>traces.</b> We first present two previously proposed and complementary frameworks for off-line replaying of MPI application <b>event</b> <b>traces,</b> each with its own objectives and limitations. We then describe how these frameworks can be combined so as to capitalize on their respective strengths while alleviating several of their limitations. We claim that the combined framework affords levels of scalability that are beyond that achievable by either one of the two individual frameworks. We evaluate this framework to illustrate the benefits of the proposed combination for a more scalable off-line analysis of MPI applications...|$|R
40|$|Abstract — This paper {{describes}} our Java Performance Monitoring Tool (JPMT), {{which is}} developed for {{detailed analysis of}} the behavior and performance of Java applications. JPMT represents internal execution behavior of Java applications by event traces, where each event represents the occurrence of some activity, such as thread creation, method invocation, and locking contention. JPMT supports event filtering during and after application execution. Each event is annotated by high-resolution performance attributes, e. g., duration of locking contention and CPU time usage by method invocations. JPMT is an open toolkit, its <b>event</b> <b>trace</b> API can be used to develop custom performance analysis applications. JPMT comes with an <b>event</b> <b>trace</b> visualizer and a command-line <b>event</b> <b>trace</b> query tool for shell scripting purposes. The instrumentation required for monitoring the application is added transparently to the user during run-time. Overhead is minimized by only instrumenting for events the user is interested in and by careful implementation of the instrumentation itself. Index Terms—Measurement, Software performance...|$|E
40|$|Abstract. This paper {{describes}} our Java Performance Monitoring Toolkit (JPMT), {{which is}} developed for {{detailed analysis of}} the behavior and performance of Java applications. JPMT represents internal execution behavior of Java applications by event traces, where each event represents the occurrence of some activity, such as thread creation, method invocation, and locking contention. JPMT supports event filtering during and after application execution. Each event is annotated by high-resolution performance attributes, e. g., duration of locking contention and CPU time usage by method invocations. JPMT is an open toolkit, its <b>event</b> <b>trace</b> API can be used to develop custom performance analysis applications. JPMT comes with an <b>event</b> <b>trace</b> visualizer and a command-line <b>event</b> <b>trace</b> query tool for scripting purposes. The instrumentation required for monitoring the application is added transparently to the user during run-time. Overhead is minimized by only instrumenting for events the user is interested in and by careful implementation of the instrumentation itself. ...|$|E
40|$|Abstract: Development of {{distributed}} systems {{is complicated by}} the absence of reliable global timing, concurrency, and nondeterminism. To deal with these obstacles log files are produced by an instrumented system facilitating analysis, testing, and debugging. This paper presents a formal framework for the analysis of distributed system logs based on <b>event</b> <b>trace</b> concept. A partially ordered trace of events executed by a distributed system is modeled by a collection of communicating automata. We present an implementation of the analysis approach in SDL based on ObjectGEODE. A formalization of a property of an <b>event</b> <b>trace,</b> being a replica of another trace, is discussed. 1...|$|E
40|$|Process mining {{techniques}} aim at extracting non-trivial {{knowledge from}} <b>event</b> <b>traces,</b> which record the concrete execution of business processes. Typically, traces are "dirty" and contain spurious events or miss relevant <b>events.</b> <b>Trace</b> alignment {{is the problem}} of cleaning such traces against a process specification. There has recently been a growing use of declarative process models, e. g., Declare (based on LTL over finite traces) to capture constraints on the allowed task flows. We demonstrate here how state-of-the-art classical planning technologies can be used for trace alignment by presenting a suitable encoding. We report experimental results using a real log from a financial domain...|$|R
40|$|<b>Event</b> <b>tracing</b> {{provides}} the detailed data {{needed to understand}} the dynamics of interactions among application resource demands and system responses. However, capturing the large volume of dynamic performance data inherent in detailed tracing can perturb program execution and stress secondary storage systems. Moreover, it can overwhelm a user or performance analyst with potentially irrelevant data. Using the Pablo performance environment's support for real-time data analysis, we show that dynamic statistical data clustering can dramatically reduce the volume of captured performance data by identifying and recording <b>event</b> <b>traces</b> only from representative processors. In turn, this makes possible low overhead, interactive visualization and performance tuning...|$|R
40|$|In this paper, {{the effect}} of {{communication}} networks to the distributed simulation has been studied. A cellular network application is simulated on a net-work of workstations, where an ordinary 10 Mbps Ethernet LAN {{has been used as}} the communication network. The effect of distribution is analyzed by using the well known concept of critical path analy-sis, which requires <b>event</b> <b>traces</b> from real simula-tions and information about event processing times as well as about their mutual relationships. In order to capture {{the effect of}} conservative synchronization, the <b>event</b> <b>traces</b> are collected from parallel simula-tions instead of sequential. By using <b>event</b> <b>traces</b> and execution times, critical paths are calculated for different numbers of workstations. The use of differ-ent configurations reveals the effect of distribution, as well as the scalability of the problem in the dis-tributed environment. The critical path analysis re-veals that the cellular network application is quite suitable for distributed simulation when conserva-tive synchronization is used. Good approximations for the execution time can be achieved if the problem is suitably partitioned into different workstations...|$|R
3000|$|A problem arises, however, {{when one}} wants to query an <b>event</b> <b>trace</b> using a more {{articulate}} query language than single-line regular expressions. Linear Temporal Logic is a prime illustration of this problem: if p and q define single event patterns, a temporal expression like G (p→X [...]...|$|E
40|$|This {{dissertation}} {{shows that}} integration of dynamic and static information aids {{the performance of}} reverse engineering tasks. An experimental environment called Shimba has been built to support reverse engineering of Java software systems. The static information is extracted from Java byte code [118]. It can be viewed and analyzed with the Rigi reverse engineering tool [74]. The dynamic <b>event</b> <b>trace</b> information is generated automatically {{as a result of}} running the target system under a customized Java Development Kit (JDK) debugger. Information about the dynamic control flow of selected objects or methods can also be extracted. The <b>event</b> <b>trace</b> can then be viewed and analyzed with the SCED tool. To support model comprehension, the models built can be used to modify and improve each other by means of information exchange, model slicing, and building abstraction...|$|E
40|$|ICSSEA 2012, 24 th International Conference on SOFTWARE & SYSTEMS ENGINEERING {{and their}} APPLICATIONS, Telecom ParisTech, Paris, October 23 - 25, 2012 This paper {{suggests}} {{an approach to}} formal software and systems architecture specification based on behavior models. The behavior of a system {{is defined as a}} set of events (<b>event</b> <b>trace)</b> with two basic relations: precedence and inclusion. The structure of an <b>event</b> <b>trace</b> is specified using event grammars and other constraints organized into schemas. Behaviors for both system and its environment can be specified within the same framework. Suggested composition operations on schemas are based on event pattern matching and provide for behavior merging and abstract interface specification. The schema framework is amenable to stepwise refinement, reuse, visualization of multiple architecture views, and application of automated tools for consistency checks and system behavior verification early in the design process...|$|E
50|$|The HTTP {{kernel mode}} driver in Windows Vista, Http.sys has been {{enhanced}} to support server-side authentication, logging, IDN hostnames, <b>Event</b> <b>Tracing</b> and better manageability through netsh http and new performance counters. WinINet, the protocol handler for HTTP and FTP handles IPv6 literal addresses, includes support for Gzip and deflate decompression to improve content encoding performance, Internationalized domain names support and <b>Event</b> <b>Tracing.</b> WinHTTP, the client API for server-based applications and services supports IPv6, AutoProxy, HTTP/1.1 chunked transfer encoding, larger data uploads, SSL and client certificates, server and proxy authentication, automatic handling of redirects and keep-alive connections and HTTP/1.0 protocol, including support for keep-alive (persistent) connections and session cookies. Winsock has been updated with new APIs {{and support for}} <b>Event</b> <b>Tracing.</b> Winsock Layered Service Provider support has been enhanced with logged installations and removals, a new API for reliably installing LSPs, a command to reliably remove LSPs, facilities to categorize LSPs and to remove most LSPs from the processing path for system critical services and support for Network Diagnostics Framework.|$|R
40|$|A {{powerful}} and widely-used method for analyzing the performance behavior of parallel programs is <b>event</b> <b>tracing.</b> When an application is <b>traced,</b> performancerelevant <b>events,</b> such as entering functions or sending messages, are recorded at runtime and analyzed post-mortem {{to identify and}} potentially remove performance problems. While <b>event</b> <b>tracing</b> enables the detection of performance problems {{at a high level}} of detail, growing trace-file size often constrains its scalability on large-scale systems and complicates management, analysis, and visualization of trace data. In this article, we survey current approaches to handle large traces and classify them according to the primary issues they address and the primary benefits they offer. Peer Reviewe...|$|R
40|$|Modern window-based {{applications}} are event-driven. User interface events carry valuable information about user behavior and are considered {{as an important}} source of data for usability evaluation. Aspect-oriented techniques provide an effective way to capture user interface events. However, it is insufficient to analyze <b>event</b> <b>traces</b> based on the information carried within events themselves. We describe a grammatical approach to analyzing <b>event</b> <b>traces</b> and identifying user tasks {{in the context of a}} task model. We also describe a proof-of-concept experiment to demonstrate its feasibility. Our approach paves the way for automatic support for task identification and therefore is beneficial to user interface evaluation that relies on task-based usability data...|$|R
