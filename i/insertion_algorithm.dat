255|155|Public
500|$|To {{insert a}} key–value pair [...] into the table (possibly {{replacing}} any existing pair {{with the same}} key), the <b>insertion</b> <b>algorithm</b> follows the same sequence of cells that would be followed for a search, until finding either an empty cell or a cell whose stored key is [...]|$|E
5000|$|The <b>insertion</b> <b>algorithm</b> only {{receives}} a minor modification (but do note that SIZE {{has to be}} a suitable prime number as explained above): ...|$|E
5000|$|Ea Ea, {{formerly}} Craige Schensted, is {{a physicist}} who first formulated the <b>insertion</b> <b>algorithm</b> [...] {{that defines the}} Robinson-Schensted correspondence; under a different form, that correspondence had earlier been described by Gilbert de Beauregard Robinson in 1938, but it {{is due to the}} Schensted <b>insertion</b> <b>algorithm</b> that the correspondence has become widely known in combinatorics. Schensted also designed several board games including *Star, Star, and Y. In 1995, he changed his name to Ea, the Babylonian name for the Sumerian god Enki, and in 1999 changed it to Ea Ea. He lived on Peaks Island in Portland, Maine.|$|E
40|$|Concurrent and {{parallel}} algorithms are different. However, {{in the case}} of dictionaries, both kinds of algorithms share many common points. We present a unified approach emphasizing these points. It is based on a careful analysis of the sequential algorithm, extracting from it the more basic facts, encapsulated later on as local rules. We apply the method to the <b>insertion</b> <b>algorithms</b> in AVL trees. All the concurrent {{and parallel}} <b>insertion</b> <b>algorithms</b> have two main phases. A percolation phase, moving the keys to be inserted down, and a rebalancing phase. Finally, some other algorithms and balanced structures are discussed. Postprint (published version...|$|R
40|$|A fast B-tree based {{indexing}} {{algorithm is}} presented. In some applications, such as full text indexing or indexing of very large tables, the new algorithm can be {{orders of magnitude}} faster than conventional B-tree <b>insertion</b> <b>algorithms,</b> while still allowing concurrent access. A similar algorithm {{can be used for}} deletion...|$|R
40|$|Abstract. We {{define a}} K-theoretic {{analogue}} of Fomin’s dual graded graphs, {{which we call}} dual filtered graphs. The key formula in the definition is DU −UD = D+ I. Our major examples are K-theoretic analogues of Young’s lattice, of shifted Young’s lattice, and of the Young-Fibonacci lattice. We suggest notions of tableaux, <b>insertion</b> <b>algorithms,</b> and growth rules whenever such objects are not already present in the literature. (See the table below.) We also provide {{a large number of}} other examples. Most of our examples arise via two constructions, which we call the Pieri construction and the Möbius construction. The Pieri construction is closely related to the construction of dual graded graphs from a graded Hopf algebra, as described in [1, 18, 15]. The Möbius construction is more mysterious but also potentially more important, as it corresponds to natural <b>insertion</b> <b>algorithms...</b>|$|R
5000|$|Maintaining {{the height}} always at its minimum value [...] {{is not always}} viable; it can be proven that any <b>insertion</b> <b>algorithm</b> which did so would have an {{excessive}} overhead. Therefore, most self-balanced BST algorithms keep the height within a constant factor of this lower bound.|$|E
5000|$|As {{described}} below, the <b>insertion</b> <b>algorithm</b> {{ensures that}} all fingerprints {{having the same}} quotient are stored in contiguous slots. Such a set of fingerprints {{is defined as a}} run. [...] Note that a run's first fingerprint might not occupy its canonical slot if the run has been forced right by some run to the left.|$|E
5000|$|To {{insert a}} {{key-value}} pair [...] into the table (possibly replacing any existing pair {{with the same}} key), the <b>insertion</b> <b>algorithm</b> follows the same sequence of cells that would be followed for a search, until finding either an empty cell or a cell whose stored key is [...]The new key-value pair is then placed into that cell.|$|E
40|$|AbstractFor {{coherent}} {{families of}} crystals of affine Lie algebras of type B(1) n, D(1) n, A(2) 2 n, and D(2) n+ 1 {{we describe the}} combinatorial R matrix using column <b>insertion</b> <b>algorithms</b> for B,C,D Young tableaux. This {{is a continuation of}} previous work by the authors (2000, in “Physical Combinatorics” (M. Kashiwara and T. Miwa, Eds.), Birkhäuser, Boston) ...|$|R
40|$|We {{define a}} K-theoretic {{analogue}} of Fomin's dual graded graphs, {{which we call}} dual filtered graphs. The key formula in the definition is DU-UD= D + I. Our major examples are K-theoretic analogues of Young's lattice, of shifted Young's lattice, and of the Young-Fibonacci lattice. We suggest notions of tableaux, <b>insertion</b> <b>algorithms,</b> and growth rules whenever such objects are not already present in the literature. We also provide {{a large number of}} other examples. Most of our examples arise via two constructions, which we call the Pieri construction and the Mobius construction. The Pieri construction is closely related to the construction of dual graded graphs from a graded Hopf algebra, as described by Bergeron-Lam-Li, Nzeutchap, and Lam-Shimizono. The Mobius construction is more mysterious but also potentially more important, as it corresponds to natural <b>insertion</b> <b>algorithms.</b> Comment: 54 pages, small edits made in new versio...|$|R
40|$|In today’s VLSI design, one of {{the most}} {{critical}} performance metric is the interconnect delay. As design dimension shrinks, the interconnect delay becomes the dominant factor for overall signal delay. Buffer insertion is proven to be an effective technique to minimize the interconnect delay. In conventional buffer <b>insertion</b> <b>algorithms,</b> the buffers are inserted on the fixed routing paths. However, in a modern design, there are macro blocks that prohibit any buffer insertion in their area. Many conventional buffer <b>insertion</b> <b>algorithms</b> do not consider these obstacles. This paper presents an algorithm for simultaneous routing and buffer insertion using look-ahead optimization technique. Simulation results show that the proposed algorithm can produce up to 47 % better solution compared to the conventional algorithms. Although research has shown that simultaneous routing and buffer insertion is NP-complete, however, with the aid of look-ahead technique, the runtime of the algorithm can be reduced significantly...|$|R
50|$|Hopscotch hashing is {{a scheme}} in {{computer}} programming for resolving hash collisions of values of hash functions in a table using open addressing. It is also {{well suited for}} implementing a concurrent hash table. Hopscotch hashing was introduced by Maurice Herlihy, Nir Shavit and Moran Tzafrir in 2008. The name {{is derived from the}} sequence of hops that characterize the table's <b>insertion</b> <b>algorithm.</b>|$|E
5000|$|In {{a simple}} {{functional}} programming form, the algorithm (in Haskell) would look something like this:data Tree a = Leaf | Node (Tree a) a (Tree a)insert :: Ord a => a -> Tree a -> Tree ainsert x Leaf = Node Leaf x Leafinsert x (Node t y s) | x <= y = Node (insert x t) y s | x > y = Node t y (insert x s)flatten :: Tree a -> aflatten Leaf = flatten (Node t x s) = flatten t ++ x ++ flatten streesort :: Ord a => a -> atreesort = flatten [...] foldr insert LeafIn the above implementation, both the <b>insertion</b> <b>algorithm</b> and the retrieval algorithm have [...] worst-case scenarios.|$|E
5000|$|By {{applying}} the Schensted <b>insertion</b> <b>algorithm</b> {{to the bottom}} line of this two-line array, one obtains a pair consisting of a semistandard tableau [...] and a standard tableau , where the latter can be turned into a semistandard tableau [...] by replacing each entry [...] of [...] by the -th entry of the top line of [...] One thus obtains a bijection from matrices [...] to ordered pairs, [...] of semistandard Young tableaux of the same shape, in which the set of entries of [...] is that of the second line of , and the set of entries of [...] is that of the first line of [...] The number of entries [...] in [...] is therefore equal to the sum of the entries in column [...] of , and the number of entries [...] in [...] is equal to the sum of the entries in row [...] of [...]|$|E
40|$|Abstract. We {{introduce}} control curves for trigonometric splines {{and show}} that they have properties similar to those for classical polynomial splines. In particular, we discuss knot <b>insertion</b> <b>algorithms,</b> {{and show that}} {{as more and more}} knots are inserted into a trigonometric spline, the associated control curves converge to the spline. In addition, we establish a convex-hull property and a variation-diminishing result. 1...|$|R
40|$|For {{coherent}} {{families of}} crystals of affine Lie algebras of type B^{(1) }_n, D^{(1) }_n, A^{(2) }_{ 2 n} and D^{(2) }_{n+ 1 } {{we describe the}} combinatorial R matrix using column <b>insertion</b> <b>algorithms</b> for B,C,D Young tableaux. Comment: 39 pages, LaTeX. This {{is a continuation of}} the authors' work appeared in "Physical Combinatorics", ed. M. Kashiwara and T. Miwa, Birkha"user, Boston, 200...|$|R
40|$|We {{develop an}} R-tree node {{restructuring}} algorithm that performs post-optimization of existing R-trees and improves current dynamic <b>insertion</b> <b>algorithms.</b> On realistic data and relative to state-of-the-art R-trees, our post optimization technique improves point query performance by 36 % [...] 43 % on average (and up to {{a factor of}} 2 in some cases), while only incurring an optimization cost (measured in disk I/Os) equal to STR loading. When used to modify existing dynamic <b>insertion</b> <b>algorithms,</b> our technique results in trees that require between 25 % and 45 % fewer disk accesses on average (up to 70 % in some cases), relative to R -trees and Hilbert R-trees, respectively, at only an additional 10 % insertion cost. 1 Introduction R-trees [5] are a common indexing technique for multidimensional data and are widely used in spatial and multidimensional databases. A significant amount of {{research has focused on}} the efficient construction of good quality Rtrees [1, 2, 3, 4, 6, 7, 9, 13, 14]. This rese [...] ...|$|R
50|$|Rather than storing random {{priorities}} on each node, the randomized {{binary search}} tree stores a small integer at each node, the number of its descendants (counting itself as one); these numbers may be maintained during tree rotation operations at only a constant additional amount of time per rotation. When a key x is to be inserted into a tree that already has n nodes, the <b>insertion</b> <b>algorithm</b> chooses with probability 1/(n + 1) to place x as the new root of the tree, and otherwise it calls the insertion procedure recursively to insert x within {{the left or right}} subtree (depending on whether its key is less than or greater than the root). The numbers of descendants are used by the algorithm to calculate the necessary probabilities for the random choices at each step. Placing x at the root of a subtree may be performed either as in the treap by inserting it at a leaf and then rotating it upwards, or by an alternative algorithm described by Martínez and Roura that splits the subtree into two pieces to be used as the left and right children of the new node.|$|E
5000|$|One {{method of}} proving this uses {{the theory of}} random graphs: one may form an undirected graph called the [...] "cuckoo graph" [...] that has a vertex for each hash table location, and an edge for each hashed value, with the {{endpoints}} of the edge being the two possible locations of the value. Then, the greedy <b>insertion</b> <b>algorithm</b> for adding a set of values to a cuckoo hash table succeeds {{if and only if}} the cuckoo graph for this set of values is a pseudoforest, a graph with at most one cycle in each of its connected components. Any vertex-induced subgraph with more edges than vertices corresponds to a set of keys for which there are an insufficient number of slots in the hash table. When the hash function is chosen randomly, the cuckoo graph is a random graph in the Erdős-Rényi model. With high probability, for a random graph in which the ratio of the number of edges to the number of vertices is bounded below 1/2, the graph is a pseudoforest and the cuckoo hashing algorithm succeeds in placing all keys. Moreover, the same theory also proves that the expected size of a connected component of the cuckoo graph is small, ensuring that each insertion takes constant expected time.|$|E
40|$|We {{introduce}} a generalization of the Robinson-Schensted-Knuth <b>insertion</b> <b>algorithm</b> for semi-standard augmented fillings whose basement is an arbitrary permutation σ ∈ Sn. If σ is the identity, then our <b>insertion</b> <b>algorithm</b> reduces to the <b>insertion</b> <b>algorithm</b> {{introduced by the}} second author [Sém. Lothar. Combin. 57 (2006 / 08), Art. B 57 e, 24 pp. ] for semi-standard augmented fillings and if σ is the reverse of the identity, then our <b>insertion</b> <b>algorithm</b> reduces to the original Robinson-Schensted-Knuth row <b>insertion</b> <b>algorithm.</b> We use our generalized <b>insertion</b> <b>algorithm</b> to obtain new decompositions of the Schur functions into nonsymmetric elements called generalized Demazure atoms (which become Demazure atoms when σ is the identity). Other applications include Pieri rules for multiplying a generalized Demazure atom by a complete homogeneous symmetric function or an elementary symmetric function, a generalization of Knuth’s correspondence between matrices of non-negative integers and pairs of tableaux, and a version of evacuation for composition tableaux whose basement is an arbitrary permutation σ. ...|$|E
40|$|The left {{patience}} sorting (lPS) monoid, {{also known}} in the literature as the Bell monoid, and the right patient sorting (rPS) monoid are introduced by defining certain congruences on words. Such congruences are constructed using <b>insertion</b> <b>algorithms</b> based {{on the concept of}} decreasing subsequences. Presentations for these monoids are given. Each finite-rank rPS monoid is shown to have polynomial growth and to satisfy a non-trivial identity (dependent on its rank), while the infinite rank rPS monoid does not satisfy a non-trivial identity. The lPS monoids of finite rank have exponential growth and thus do not satisfy non-trivial identities. The complexity of the <b>insertion</b> <b>algorithms</b> is discussed. rPS monoids of finite rank are shown to be automatic and to have recursive complete presentations. When the rank is $ 1 $ or $ 2 $, they are also biautomatic. lPS monoids of finite rank are shown to have finite complete presentations and to be biautomatic. Comment: 42 page...|$|R
5000|$|In pseudo-code form, the Straight <b>Insertion</b> Sort <b>algorithm</b> {{could look}} {{something}} like this (array X is zero-based): ...|$|R
40|$|An {{improved}} {{method for}} adaptively constructing a terrain surface representation from {{a set of}} data points is presented. Refinement and decimation steps are repeatedly applied to triangular meshes, incrementally determining a better distribution of the data points, while a specified error tolerance is preserved. Even though not asymptotically optimal or monotonically convergent, it produces approximations that are, experimentally, significantly better than those generated by straightforward greedy <b>insertion</b> <b>algorithms...</b>|$|R
3000|$|Step 2 : Strategy selection. If {{it is an}} {{emergency}} tasks with high priority, use (emergency task <b>insertion</b> <b>algorithm)</b> ETIA. If it is the general emergency tasks with fewer tasks, use general emergency task <b>insertion</b> <b>algorithm</b> (GETIA). If it is the general emergency tasks with more tasks, use general emergency task planning &insertion algorithm (GETPIA); [...]...|$|E
40|$|Fomin (1994) {{introduced}} {{a notion of}} duality between two graded graphs on {{the same set of}} vertices. He also {{introduced a}} generalization to dual graded graphs of the classical Robinson-Schensted-Knuth algorithm. We show how Fomin's approach applies to the binary search tree <b>insertion</b> <b>algorithm</b> also known as sylvester insertion, and to the hypoplactic <b>insertion</b> <b>algorithm.</b> Comment: 11 pages, submitted to the Electronic Journal of Combinatorics on February 200...|$|E
40|$|Based on {{the matrix}} ansatz of Derrida, Evans, Hakim and Pasquier, we prensent {{a new way}} of {{computing}} the stationary probability of a state of the asym- metric simple exclusion process (ASEP). Through an <b>insertion</b> <b>algorithm</b> over staircase tableaux, we give a combinatorial proof to the current interpretation of the ASEP by these tableaux of Corteel and Williams. The <b>insertion</b> <b>algorithm</b> induces a recursive structure which implies nice factorised formulas for the generating polynomials of staircase tableaux, as well as a bijection with some coloured inversion tables. In addi- tion, we adapt the <b>insertion</b> <b>algorithm</b> to the case of type B symmetric tableaux and we define a new matrix ansatz compatible with it. Comment: 12 pages, 4 figures, extended abstrac...|$|E
40|$|Abstract. In {{this paper}} {{we present a}} new {{algorithm}} for merging two linearly ordered sets which requires substantially fewer comparisons than the commonly used tape merge or binary <b>insertion</b> <b>algorithms.</b> Bounds on {{the difference between the}} number of comparisons required by this algorithm and the information theory lower bounds are derived. Results from a computer implementation of the new algorithm are given and compared with a similar implementation of the tape merge algorithm. Key words, algorithms, merging 1. Introduction. Suppos...|$|R
40|$|This paper {{describes}} algorithms for key deletion in B+-trees. There {{are published}} algorithms and pseudocode for searching and inserting keys, but deletion, {{due to its}} greater complexity and perceived lesser importance, is glossed over completely or left as an exercise to the reader. To remedy this situation, we provide a well documented flowchart, algorithm, and pseudo-code for deletion, their relation to search and <b>insertion</b> <b>algorithms,</b> and {{a reference to a}} freely available, complete B+-tree library written in the C programming language...|$|R
40|$|In the {{electric}} GIS, facilities in different voltage levels show a different proportion, and topological relations exist {{in line and}} point. According to the limitations in multi-scale representation and topological connection of traditional spatial index, an extended R-Tree model based on multi-scale clustering(MCER Tree) is proposed, which removed the restrictions of the same height of all leaf nodes, but increased pointer to line list of spatial object. This paper focused on the structure, generation <b>algorithms</b> and <b>insertion</b> <b>algorithms</b> of MCER Tree, and finally proposed the future research...|$|R
40|$|In 2001, Shimozono and White gave a {{description}} of the domino Schensted algorithm of Barbasch, Vogan, Garfinkle and van Leeuwen with the “color-to-spin” property, that is, the property that the total color of the permutation equals the sum of the spins of the domino tableaux. In this paper, we describe the poset of domino Fibonacci shapes, an isomorphic equivalent to Stanley’s Fibonacci lattice Z(2), and define domino Fibonacci tableaux. We give an <b>insertion</b> <b>algorithm</b> which takes colored permutations to pairs of tableaux (P, Q) of domino Fibonacci shape. We then define a notion of spin for domino Fibonacci tableaux for which the <b>insertion</b> <b>algorithm</b> preserves the color-to-spin property. In addition, we give an evacuation algorithm for standard domino Fibonacci tableaux which relates the pairs of tableaux obtained from the domino <b>insertion</b> <b>algorithm</b> to the pairs of tableaux obtained from Fomin’s growth diagrams. ...|$|E
30|$|In the {{experiment}} 1, we simulated different original tasks and considered different positions of emergency tasks {{in the original}} task planning sequence. Besides, we compared ETIA with the traditional emergency <b>insertion</b> <b>algorithm.</b> Taking the calculation efficiency of satellite into consideration, we assumed that the calculation time of satellite was 500 times of the simulation experiment. The experimental {{results showed that the}} average running time of ETIA was less than that of the traditional <b>insertion</b> <b>algorithm.</b> As the number of original task plans increased, the completion time of the algorithm tended to remain stable. However, ETIA is not ideal for inserting multiple emergency tasks, partly because of its greater volatility in profit, and on the other hand, inserting tasks one by one is inefficient for multiple tasks. When the task scale was 100, the emergency <b>insertion</b> <b>algorithm</b> could save 10.306  s than the conventional one. Therefore, we concluded that Algorithm I could effectively solve the problem of reprogramming a few emergency tasks with high priority.|$|E
40|$|We {{extend the}} notion of $k$-ribbon tableaux to the Fibonacci lattice, a {{differential}} poset defined by R. Stanley in 1975. Using this notion, we describe an <b>insertion</b> <b>algorithm</b> that takes $k$-colored permutations to pairs of $k$-ribbon Fibonacci tableaux of the same shape, and we demonstrate a color-to-spin property, similar to that described by Shimozono and White for ribbon tableaux. We give an evacuation algorithm which relates the pair of $k$-ribbon Fibonacci tableaux obtained through the <b>insertion</b> <b>algorithm</b> to the pair of $k$-ribbon Fibonacci tableaux obtained using Fomin's growth diagrams. In addition, we present an analogue of Knuth relations for $k$-colored permutations and $k$-ribbon Fibonacci tableaux. Comment: 33 page...|$|E
40|$|There {{are a few}} {{algorithms}} {{designed to}} solve the problem of the optimal alignment of one sequence, the pattern, of length m, with another, longer sequence the text, of length n These algorithms allow mismatches, deletions and <b>insertions.</b> <b>Algorithms</b> to date run in 0 (mn) time. Let us define an integer. k, which is the maximal number of differences allowed We present a simple algorithm showing that sequences can be optimally aligned in 0 {kzn) time. For long sequences the gain factor over the currently used algorithms is very large. 1...|$|R
40|$|In O'Connell-Pei(2013) a q-weighted {{version of}} the Robinson-Schensted {{algorithm}} was introduced. In this paper we show that this algorithm has a symmetry property analogous to the well known symmetry property of the normal Robinson-Schensted algorithm. The proof uses a generalisation of the growth diagram approach introduced by Fomin(1979, 1986, 1994, 1995). This approach, which uses "growth graphs", can also be applied to a wider class of <b>insertion</b> <b>algorithms</b> which have a branching structure, {{including some of the}} other q-weighted versions of the Robinson-Schensted algorithm which have recently been introduced by Borodin-Petrov(2013). Comment: 28 pages, many picture...|$|R
5000|$|The {{concept of}} {{procedural}} parameter is best explained by examples. A typical application {{is the following}} generic implementation of the <b>insertion</b> sort <b>algorithm,</b> that takes two integer parameters a,b and two procedural parameters prec, swap: ...|$|R
