10000|10000|Public
25|$|In big O notation, the brute-force {{algorithm}} is O(n) and the <b>efficient</b> <b>algorithm</b> is O(1) (assuming constant time arithmetic operations).|$|E
25|$|The {{complexity}} class P {{is often}} seen as a mathematical abstraction modeling those computational tasks that admit an <b>efficient</b> <b>algorithm.</b> This hypothesis is called the Cobham–Edmonds thesis. The complexity class NP, on the other hand, contains many problems that {{people would like to}} solve efficiently, but for which no <b>efficient</b> <b>algorithm</b> is known, such as the Boolean satisfiability problem, the Hamiltonian path problem and the vertex cover problem. Since deterministic Turing machines are special non-deterministic Turing machines, it is easily observed that each problem in P is also member of the class NP.|$|E
25|$|Falls, Powell, and Snoeyink {{develop an}} <b>efficient</b> <b>algorithm</b> for finding {{clusters}} of orthologous groups of genes in genome data, by representing the data as a graph {{and searching for}} large Turán subgraphs.|$|E
40|$|The {{kernel of}} Computational Geometry is {{the design and}} {{analysis}} of <b>efficient</b> <b>algorithms</b> to solve geometric problems. PRESENTATION OF THE COURSE Computational Geometry, Facultat d’Informàtica de Barcelona, UPC The kernel of Computational Geometry is the design and analysis of <b>efficient</b> <b>algorithms</b> to solve geometric problems. PRESENTATION OF THE COURSE Computational Geometry, Facultat d’Informàtica de Barcelona, UPC What kind of geometric problems? The kernel of Computational Geometry is the design and analysis of <b>efficient</b> <b>algorithms</b> to solve geometric problems. PRESENTATION OF THE COURSE Computational Geometry, Facultat d’Informàtica de Barcelona, UPC What kind of geometric problems? The kernel of Computational Geometry is the design and analysis of <b>efficient</b> <b>algorithms</b> to solve geometric problems. Geometric problems that underlie {{a wide variety of}} applicationsPRESENTATION OF THE COURSE Computational Geometry, Facultat d’Informàtica de Barcelona, UPC What kind of geometric problems...|$|R
5000|$|<b>Efficient</b> <b>algorithms</b> for {{structured}} convex {{programs and}} network flow problems, ...|$|R
5000|$|... {{for both}} {{problems}} <b>efficient</b> <b>algorithms</b> on quantum computers are known, ...|$|R
25|$|For harder problems, {{it becomes}} {{increasingly}} important {{to find an}} <b>efficient</b> <b>algorithm.</b> For this problem, we can reduce 1000 operations to a handful by using the inclusion–exclusion principle and a closed-form summation formula.|$|E
25|$|The {{decision}} {{variant of}} the vertex cover problem is NP-complete, which means {{it is unlikely that}} there is an <b>efficient</b> <b>algorithm</b> to solve it exactly. NP-completeness can be proven by reduction from 3-satisfiability or, as Karp did, by reduction from the clique problem. Vertex cover remains NP-complete even in cubic graphs and even in planar graphs of degree at most 3.|$|E
25|$|Group FFTs: The FFT {{may also}} be {{explained}} and interpreted using group representation theory that allows for further generalization. A function on any compact group, including non cyclic, has an expansion {{in terms of a}} basis of irreducible matrix elements. It remains active area of research to find <b>efficient</b> <b>algorithm</b> for performing this change of basis. Applications including efficient spherical harmonic expansion, analyzing certain markov processes, robotics etc.|$|E
5000|$|Examples of {{large-scale}} precomputation {{as part of}} modern <b>efficient</b> <b>algorithms</b> include: ...|$|R
5000|$|E. Bach, J.O. Shallit Algorithmic Number Theory: <b>Efficient</b> <b>algorithms</b> MIT Press, (1996) ...|$|R
5000|$|... both {{problems}} are difficult (no <b>efficient</b> <b>algorithms</b> {{are known for}} non-quantum computers), ...|$|R
25|$|Cheon Jung-Hee is a South Korean {{mathematician}} and cryptographer whose research interest includes computational number theory, cryptography, {{and information}} security. He {{is one of}} the inventors of braid cryptography, one of group-based cryptography. He is particularly known for his work on an <b>efficient</b> <b>algorithm</b> on strong DH problem. He received the best paper award in Asiacrypt 2008 for improving Pollard rho algorithm, and the best paper award in Eurocrypt 2015 for attacking Multilinear Maps.|$|E
25|$|A kind of {{opposite}} of a sorting algorithm is a shuffling algorithm. These are fundamentally different because they require {{a source of}} random numbers. Interestingly, shuffling can also be implemented by a sorting algorithm, namely by a random sort: assigning a random number to each element of the list and then sorting based on the random numbers. This is generally not done in practice, however, {{and there is a}} well-known simple and <b>efficient</b> <b>algorithm</b> for shuffling: the Fisher–Yates shuffle.|$|E
25|$|Another {{technique}} for overcoming the memory-size problem is using external sorting, for example {{one of the}} ways is to combine two algorithms in a way that takes advantage of the strength of each to improve overall performance. For instance, the array might be subdivided into chunks of a size that will fit in RAM, the contents of each chunk sorted using an <b>efficient</b> <b>algorithm</b> (such as quicksort), and the results merged using a k-way merge similar to that used in mergesort. This is faster than performing either mergesort or quicksort over the entire list.|$|E
50|$|<b>Efficient</b> <b>algorithms</b> {{for both}} small N and small P cases are given below.|$|R
50|$|Various <b>efficient</b> <b>algorithms</b> {{have been}} devised for {{estimating}} {{the parameters of the}} VOM model.|$|R
40|$|We {{consider}} whether restricted sets of geometric predicates support <b>efficient</b> <b>algorithms</b> to solve line and curve segment intersection {{problems in the}} plane. Our restrictions {{are based on the}} notion of algebraic degree, proposed by Preparata and others as a way to guide the search for <b>efficient</b> <b>algorithms</b> that can be implemented in more realistic computational models than the Real RAM...|$|R
25|$|When {{the numbers}} are {{sufficiently}} large, no efficient, non-quantum integer factorization algorithm is known. An effort by several researchers, concluded in 2009, to factor a 232-digit number (RSA-768) utilizing hundreds of machines took two years and the researchers estimated that a 1024-bit RSA modulus would take about a thousand times as long. However, {{it has not been}} proven that no <b>efficient</b> <b>algorithm</b> exists. The presumed difficulty of this problem {{is at the heart of}} widely used algorithms in cryptography such as RSA. Many areas of mathematics and computer science have been brought to bear on the problem, including elliptic curves, algebraic number theory, and quantum computing.|$|E
2500|$|While [...] can be {{computed}} very quickly, {{for example}} using exponentiation by squaring, {{there is no}} known <b>efficient</b> <b>algorithm</b> for computing the inverse operation, the discrete logarithm. This {{has been used in}} various cryptographic protocols, see Discrete logarithm for details.|$|E
2500|$|Suppose [...] are {{relatively}} prime integers and set [...] Let [...] be [...] polynomials of maximum degree [...] Suppose {{there exists a}} unique [...] satisfying [...] for all [...] Furthermore, suppose [...] There is an <b>efficient</b> <b>algorithm</b> which, given [...] for all , computes [...]|$|E
30|$|We {{note that}} <b>efficient</b> <b>algorithms</b> are {{available}} to solve the power maximization (7), e.g., from [9].|$|R
5000|$|Formally, A Message Authentication Code (MAC) is {{a triple}} of <b>efficient</b> <b>algorithms</b> (G, S, V) satisfying: ...|$|R
40|$|This paper gives {{a review}} of the most <b>efficient</b> <b>algorithms</b> {{designed}} to track the maximum power point (MPP) for catching the maximum wind power by a variable speed wind turbine (VSWT). We then design a new maximum power point tracking (MPPT) algorithm using the Variable Structure Automatic Systems approach (VSAS). The proposed approach leads <b>efficient</b> <b>algorithms</b> as shown in this paper by the analysis and simulations...|$|R
2500|$|Though {{this problem}} is much simpler than the typical problem, it serves to {{illustrate}} the potential difference that an <b>efficient</b> <b>algorithm</b> makes. The brute-force algorithm examines every natural number less than 1000 and keeps a running sum of those meeting the criteria. This method is simple to implement, {{as shown by the}} following pseudocode: ...|$|E
2500|$|In {{the theory}} of {{three-dimensional}} rotation, Rodrigues' rotation formula, named after Olinde Rodrigues, is an <b>efficient</b> <b>algorithm</b> for rotating a vector in space, given an axis and angle of rotation. By extension, this {{can be used to}} transform all three basis vectors to compute a rotation matrix in , the group of all rotation matrices, from an axis–angle representation. In other words, the Rodrigues' formula provides an algorithm to compute the exponential map from , the Lie algebra of , to [...] without actually computing the full matrix exponential.|$|E
2500|$|While {{there are}} {{a large number of}} sorting algorithms, in {{practical}} implementations a few algorithms predominate. Insertion sort is widely used for small data sets, while for large data sets an asymptotically efficient sort is used, primarily heap sort, merge sort, or quicksort. Efficient implementations generally use a hybrid algorithm, combining an asymptotically <b>efficient</b> <b>algorithm</b> for the overall sort with insertion sort for small lists {{at the bottom of a}} recursion. Highly tuned implementations use more sophisticated variants, such as Timsort (merge sort, insertion sort, and additional logic), used in Android, Java, and Python, and introsort (quicksort and heap sort), used (in variant forms) in some C++ sort implementations and in [...]NET.|$|E
3000|$|Finding <b>efficient</b> <b>algorithms</b> {{to solve}} {{uncertain}} problems directly (without transforming uncertain models to certain ones), and [...]...|$|R
5000|$|Jaideep Srivastava and C V Ramamoorthy. <b>Efficient</b> <b>Algorithms</b> for Maintenance of Large Database. ICDE, pages 402-408, 1988.|$|R
5000|$|Because DFAs can {{be reduced}} to a {{canonical}} form (minimal DFAs), there are also <b>efficient</b> <b>algorithms</b> to determine: ...|$|R
2500|$|Project Euler (named after Leonhard Euler) is {{a website}} {{dedicated}} {{to a series of}} computational problems intended to be solved with computer programs. The project attracts adults and students interested in mathematics and computer programming. [...] Since its creation in 2001 by Colin Hughes, Project Euler has gained notability and popularity worldwide. It includes over 600 problems, with a new one added every weekend (except during the summer). Problems are of varying difficulty but each is solvable {{in less than a minute}} using an <b>efficient</b> <b>algorithm</b> on a modestly powered computer. Problems can be sorted on difficulty. A forum specific to each question may be viewed after the user has correctly answered the given question. [...] Project Euler has about 720,000 users, from all over the world, who have solved at least one problem.|$|E
2500|$|To {{classify}} the {{computation time}} (or similar resources, such as space consumption), one {{is interested in}} proving {{upper and lower bounds}} on the minimum amount of time required by the most <b>efficient</b> <b>algorithm</b> solving a given problem. The complexity of an algorithm is usually taken to be its worst-case complexity, unless specified otherwise. Analyzing a particular algorithm falls under the field of analysis of algorithms. To show an upper bound T(n) on the time complexity of a problem, one needs to show only that there is a particular algorithm with running time at most T(n). However, proving lower bounds is much more difficult, since lower bounds make a statement about all possible algorithms that solve a given problem. The phrase [...] "all possible algorithms" [...] includes not just the algorithms known today, but any algorithm that might be discovered in the future. To show a lower bound of T(n) for a problem requires showing that no algorithm can have time complexity lower than T(n).|$|E
2500|$|Formally, the {{algorithm}} defines a value called badness {{associated with each}} possible line break; the badness is increased if the spaces on the line must stretch or shrink too much to make the line the correct width. Penalties are added if a breakpoint is particularly undesirable: for example, if a word must be hyphenated, if two lines in a row are hyphenated, or if a very loose line is immediately followed by a very tight line. The algorithm will then find the breakpoints that will minimize the sum of squares of the badness (including penalties) of the resulting lines. If the paragraph contains [...] possible breakpoints, the number of situations that must be evaluated naively is [...] However, by using the method of dynamic programming, the complexity of {{the algorithm}} can be brought down to [...] (see Big O notation). Further simplifications (for example, not testing extremely unlikely breakpoints such as a hyphenation in the first word of a paragraph) lead to an <b>efficient</b> <b>algorithm</b> whose running time is almost always of order [...] A similar algorithm is used to determine the best way to break paragraphs across two pages, in order to avoid widows or orphans (lines that appear alone on a page {{while the rest of the}} paragraph is on the following or preceding page). However, in general, a thesis by Michael Plass shows how the page breaking problem can be NP-complete because of the added complication of placing figures. TeX's line breaking algorithm has been adopted by several other programs, such as Adobe InDesign (a desktop publishing application) and the GNU fmt Unix command line utility.|$|E
50|$|In 1978, {{he wrote}} a paper {{describing}} a method to efficiently compute strongly connected members of a directed graph, a method later called Kosaraju's algorithm. Along with Paul Callahan he published many articles on <b>efficient</b> <b>algorithms</b> for computing the well-separated pair decomposition of a point set. His research efforts include <b>efficient</b> <b>algorithms</b> for pattern matching, data structure simulations, universal graphs, DNA sequence assembly, derandomization and investigations of immune system responses.|$|R
30|$|Before {{we develop}} {{algorithms}} for finding valid combinations, we first present a lemma {{that can help}} design <b>efficient</b> <b>algorithms.</b>|$|R
5000|$|... stochvol: <b>Efficient</b> <b>algorithms</b> for fully Bayesian {{estimation}} of stochastic volatility (SV) models via Markov chain Monte Carlo (MCMC) methods.|$|R
