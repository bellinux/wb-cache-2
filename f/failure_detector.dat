460|194|Public
50|$|The Chandra-Toueg {{consensus}} algorithm, {{published by}} Tushar Deepak Chandra and Sam Toueg in 1996, is an algorithm for solving consensus {{in a network}} of unreliable processes equipped with an eventually strong <b>failure</b> <b>detector.</b> The <b>failure</b> <b>detector</b> is an abstract version of timeouts; it signals to each process when other processes may have crashed. An eventually strong <b>failure</b> <b>detector</b> is one that never identifies some specific good process as having failed after some initial period of confusion, {{and at the same}} time eventually identifies all bad processes as failed. The algorithm itself is similar to the Paxos algorithm, which also relies on failure detectors. Both algorithms assume the number of faulty processes is less than n/2, where n is the total number of processes.|$|E
50|$|In {{distributed}} computing, a <b>failure</b> <b>detector</b> is {{an application}} or a subsystem {{that is responsible}} for detection of node failures or crashes.|$|E
5000|$|When {{a process}} P recovers from failure, or the <b>failure</b> <b>detector</b> {{indicates}} that the current coordinator has failed, P performs the following actions: ...|$|E
40|$|Traditionally, <b>failure</b> <b>detectors</b> have {{considered}} a binary model whereby a given {{process can be}} either trusted or suspected. This paper defines a family of <b>failure</b> <b>detectors,</b> called accrual <b>failure</b> <b>detectors,</b> that revisits this interaction model. Accrual <b>failure</b> <b>detectors</b> associate to each process a real value representing a suspicion level. An important advantage of accrual <b>failure</b> <b>detectors</b> over binary ones is to allow distributed applications to trigger different actions depending on the suspicion level. For instance, an application can take precautionary measures when the suspicion level reaches a given level, and then take more drastic actions after it raises above a second (much higher) level. The paper defines accrual <b>failure</b> <b>detectors</b> and their basic properties. Four classes of accrual <b>failure</b> <b>detectors</b> are discussed, {{each of which is}} proved equivalent to a class of binary unreliable <b>failure</b> <b>detectors</b> (P, S, ◇P, and ◇S) リサーチレポート（北陸先端科学技術大学院大学情報科学研究科...|$|R
40|$|Unreliable <b>failure</b> <b>detectors</b> are {{abstract}} devices that, when {{added to}} asynchronous distributed systems, allow to solve distributed computing problems (e. g. Consensus) {{that otherwise would}} be impossible to solve in these systems. This paper focuses on two classes of <b>failure</b> <b>detectors</b> defined by Chandra and Toueg, namely, the classes denoted #P (eventually perfect) and #S (eventually strong). Both classes include <b>failure</b> <b>detectors</b> that eventually detect permanently all process crashes, but while the <b>failure</b> <b>detectors</b> of #P eventually make no erroneous suspicions, the <b>failure</b> <b>detectors</b> of #S are only required to eventually not suspect a single correct process...|$|R
40|$|The paper {{considers}} a consensus algorithm for an asynchronous system augmented with <b>failure</b> <b>detectors,</b> {{and analyze the}} impact on its termination time of various implementations of <b>failure</b> <b>detectors.</b> This study shows that the design of fault-tolerant distributed algorithms in the asynchronous system model augmented with <b>failure</b> <b>detectors</b> is orthogonal to implementing the actual <b>failure</b> <b>detectors.</b> This nicely decouples logical issues (proof of correctness) from engineering issues (e. g., performance and timing constraints) ...|$|R
5000|$|Each process {{waits to}} receive (r, preference) from the {{coordinator}} or for its <b>failure</b> <b>detector</b> {{to identify the}} coordinator as crashed. In the first case, it sets its own preference to the coordinator's preference and responds with ack(r). In the second case, it sends nack(r) to the coordinator.|$|E
5000|$|Termination holds because {{eventually}} the <b>failure</b> <b>detector</b> stops suspecting some non-faulty process p and eventually p becomes the coordinator. If the algorithm has not terminated before this occurs in some round r, then every non-faulty process in round r waits to receive p's preference and responds with ack(r). This allows p to collect enough acknowledgments to send decide(preference), causing every process to terminate. Alternatively, {{it may be}} that some faulty coordinator sends decide only to a few processes; but if any of these processes are non-faulty, they echo the decision to all the remaining processes, causing them to decide and terminate.|$|E
40|$|This paper {{defines the}} {{fault-tolerant}} mutual exclusion {{problem in a}} message-passing asynchronous system and determines the weakest <b>failure</b> <b>detector</b> to solve the problem. This <b>failure</b> <b>detector,</b> which we call the trusting <b>failure</b> <b>detector,</b> and which we denote by T, is strictly weaker than the perfect <b>failure</b> <b>detector</b> P but strictly stronger than the eventually perfect <b>failure</b> <b>detector</b> P. The paper shows {{that a majority of}} correct processes is necessary to solve the problem with T. Moreover, T is also the weakest <b>failure</b> <b>detector</b> to solve the fault-tolerant group mutual exclusion problem...|$|E
40|$|We {{put forward}} a formal model of {{anonymous}} systems. And we concentrate on the anonymous <b>failure</b> <b>detectors</b> in our model. In particular, we give three examples of anonymous <b>failure</b> <b>detectors</b> and show {{that they can be}} used to solve the consensus problem and that they are equivalent to their classic counterparts. Moreover, we show some relationship among them and provide a simple classification of anonymous <b>failure</b> <b>detectors.</b> Comment: 15 page...|$|R
40|$|Paper {{written in}} PortugueseThe {{definition}} of <b>failure</b> <b>detectors</b> {{to be used}} on environments with crash failure hypothesis has some severe restrictions even in its weaker implementations. Yet, <b>failure</b> <b>detectors</b> are possible in distributed asynchronous systems, if we use technics to circumvent these restrictions, like the timeouts. During the construction of <b>failure</b> <b>detectors,</b> the need of reliable communication is an important factor: even if the definition if the <b>failure</b> <b>detectors</b> requires reliable communication, practical experiences show {{that we can use}} unreliable communication in its construction. This paper focuses on the native choices for reliable and unreliable communication, TCP and UDP, examining their impact on failure detectors' behavior...|$|R
40|$|The {{knowledge}} about failures needed to solve distributed agreement {{problems can be}} {{expressed in terms of}} completeness and accuracy properties of <b>failure</b> <b>detectors</b> introduced by Chandra and Toueg. The accuracy properties they have considered restrict the false suspicions that can be made by all the processes in the system. In this paper, we define "Γ" <b>failure</b> <b>detectors,</b> whose accuracy properties (only) restrict the false suspicions that can be made by a subset Γ of the processes. We discuss the relations between the classes of Γ <b>failure</b> <b>detectors,</b> and the classes of <b>failure</b> <b>detectors</b> defined by Chandra and Toueg. Then we point out the impact of these relations on the solvability of agreement problems. 1 Introduction 1. 1 Restricting accuracy Chandra and Toueg have expressed the {{knowledge about}} failures needed to solve distributed agreement problems in terms of completeness and accuracy properties of <b>failure</b> <b>detectors</b> [4]. Completeness pro [...] ...|$|R
40|$|This paper {{considers}} the fault-tolerant mutual exclusion {{problem in a}} message-passing asynchronous system and determines the weakest <b>failure</b> <b>detector</b> to solve the problem, given a majority of correct processes. This <b>failure</b> <b>detector,</b> which we call the trusting <b>failure</b> <b>detector,</b> and which we denote by T, is strictly weaker than the perfect <b>failure</b> <b>detector</b> P but strictly stronger than the eventually perfect <b>failure</b> <b>detector</b> P. The paper shows {{that a majority of}} correct processes is necessary to solve the problem with T. Moreover, T is also the weakest <b>failure</b> <b>detector</b> to solve the fault-tolerant group mutual exclusion problem, given a majority of correct processes...|$|E
40|$|URL] paper {{considers}} the fault-tolerant mutual exclusion {{problem in a}} message-passing asynchronous system and determines the weakest <b>failure</b> <b>detector</b> to solve the problem, given a majority of correct processes. This <b>failure</b> <b>detector,</b> which we call the trusting <b>failure</b> <b>detector,</b> and which we denote by, is strictly weaker than the perfect <b>failure</b> <b>detector</b> but strictly stronger than the eventually perfect <b>failure</b> <b>detector.</b> The paper shows {{that a majority of}} correct processes is necessary to solve the problem with. Moreover, is also the weakest <b>failure</b> <b>detector</b> to solve the fault-tolerant group mutual exclusion problem, given a majority of correct processes...|$|E
40|$|In [1],[3] and [6], respectively, it {{was stated}} that the weakest <b>failure</b> <b>detector</b> for any of {{non-blocking}} atomic commit, terminating reliable broadcast and leader election, is the Perfect <b>failure</b> <b>detector</b> P. This paper presents a counter example of those results. We exhibit a <b>failure</b> <b>detector</b> that is incomparable to P, and yet solves those problems...|$|E
40|$|We {{introduce}} {{the concept of}} unreliable <b>failure</b> <b>detectors</b> and study {{how they can be}} used to solve Consensus in asynchronous systems with crash failures. We characterise unreliable <b>failure</b> <b>detectors</b> in terms of two properties — completeness and accuracy. We show that Consensus can be solved even with unreliable <b>failure</b> <b>detectors</b> that make an infinite number of mistakes, and determine which ones can be used to solve Consensus despite any number of crashes, and which ones require a majority of correct processes. We prove that Consensus and Atomic Broadcast are reducible to each other in asynchronous systems with crash failures; thus the above results also apply to Atomic Broadcast. A companion paper shows that one of the <b>failure</b> <b>detectors</b> introduce...|$|R
40|$|Blocking Atomic Commitment problem (NB-AC) and the Consensus {{problem in}} {{asynchronous}} systems with unreliable <b>failure</b> <b>detectors.</b> We first confirm that NB-AC is harder than Consensus. In contrast to Consensus, NB-AC {{is impossible to}} solve with unreliable <b>failure</b> <b>detectors</b> even with a single crash failure. We define a weaker problem than NB-AC, called Non-Blocking Weak Atomic Commitment (NB-WAC), which is sufficient to solve for most practical situations. A fundamental characteristic of NB-WAC is its reducibility to Consensus. The previous results on solving Consensus with unreliable <b>failure</b> <b>detectors</b> apply therefore to NB-WAC. An interesting intermediate result of this reducibility is that Uniform Consensus and Consensus are equivalent problems. We show actually that any algorithm that solves Consensus with unreliable <b>failure</b> <b>detectors</b> also solves Uniform Consensus. ...|$|R
40|$|This paper shows that, in an {{environment}} where we do not bound the number of faulty processes, the class of Perfect <b>failure</b> <b>detectors</b> is the weakest (among realistic <b>failure</b> <b>detectors)</b> to solve fundamental agreement problems like uniform consensus, atomic broadcast, and terminating reliable broadcast (also called Byzantine Generals) ...|$|R
30|$|In push model, the {{components}} of the grid starts sending heartbeat messages at regular time intervals to a central <b>failure</b> <b>detector.</b> If <b>failure</b> <b>detector</b> does not receive a message from one or more grid components within a specified time, then <b>failure</b> <b>detector</b> assumes and considers the problem as a failure of that component (Garg and Singh 2011).|$|E
40|$|In [CT 96], [FRT 99], and [SM 95], respectively, it {{was stated}} that the weakest <b>failure</b> <b>detector</b> for any of {{non-blocking}} atomic commit, terminating reliable broadcast and leader election, is the Perfect <b>failure</b> <b>detector</b> P. This paper presents a counter example of those results. We exhibit a <b>failure</b> <b>detector</b> that is incomparable to P, and yet solves those problems...|$|E
40|$|We {{model the}} {{probabilistic}} {{behavior of a}} system comprising a <b>failure</b> <b>detector</b> and a monitored crash-recovery target. We extend failure detectors {{to take account of}} failure recovery in the target system. This involves extending QoS measures to include the recovery detection speed and proportion of failures detected. We also extend estimating the parameters of the <b>failure</b> <b>detector</b> to achieve a required QoS to configuring the crash-recovery <b>failure</b> <b>detector.</b> We investigate the impact of the dependability of the monitored process on the QoS of our <b>failure</b> <b>detector.</b> Our analysis indicates that variation in the MTTF and MTTR of the monitored process can {{have a significant impact on}} the QoS of our <b>failure</b> <b>detector.</b> Our analysis is supported by simulations that validate our theoretical results...|$|E
40|$|This paper {{discusses}} {{the relationship between}} the NonBlocking Atomic Commitment problem (NB-AC) and the Consensus problem in asynchronous systems with unreliable <b>failure</b> <b>detectors.</b> We first confirm that NB-AC is harder than Consensus. In contrast to Consensus, NB-AC is impossible to solve with unreliable <b>failure</b> <b>detectors</b> even with a single crash failure. We define a weaker problem than NB-AC, called Non-Blocking Weak Atomic Commitment (NB-WAC), which is sufficient to solve for most practical situations. A fundamental characteristic of NB-WAC is its reducibility to Consensus. The previous results on solving Consensus with unreliable <b>failure</b> <b>detectors</b> apply therefore to NB-WAC. An interesting intermediate result of this reducibility is that Uniform Consensus and Consensus are equivalent problems. We show actually that any algorithm that solves Consensus with unreliable <b>failure</b> <b>detectors</b> also solves Uniform Consensus. 1 Introduction To ensure transaction failure atomicity in a distrib [...] ...|$|R
40|$|In {{a seminal}} paper, Chandra and Toueg showed how {{unreliable}} <b>failure</b> <b>detectors</b> could allows processors to achieve consensus in asynchronous message passing systems. Since then, {{other researchers have}} developed consensus algorithms for other systems or based on different <b>failure</b> <b>detectors.</b> Each algorithm was developed and proven independently. This paper shows how a consensus algorithm {{for any of the}} standard models can be automatically converted to run in any other. These results show more clearly how the different system models and <b>failure</b> <b>detectors</b> can be related. In addition, they may permit the development of new results for new models also through transformations. ...|$|R
40|$|Unreliable <b>failure</b> <b>detectors</b> are oracles {{that give}} {{information}} about process failures. Chandra and Toueg were first to study such <b>failure</b> <b>detectors</b> for distributed systems, and they identified {{a number that}} enabled {{the solution of the}} Consensus problem in asynchronous distributed systems. This paper focuses on two of these, denoted (strong) and #S (eventually strong) ...|$|R
30|$|Bertier et al. [9] {{extend the}} {{approach}} proposed by Chen et al. by implementing a <b>failure</b> <b>detector</b> in two layers: an adaption layer runs {{on top of}} a traditional heartbeat-based <b>failure</b> <b>detector.</b> The adaptation layer configures the Quality of Service (QoS) of the <b>failure</b> <b>detector</b> according to application needs. The purpose is also to minimize both network and processor overhead. While Chen’s <b>failure</b> <b>detector</b> computes the timeout interval based on the expected arrival time of the next message, Berthier’s also uses a safety margin which is continuously updated according to Jacobson’s TCP (Transmission Control Protocol) timeout algorithm.|$|E
30|$|In [19] {{the authors}} design an {{autonomic}} <b>failure</b> <b>detector</b> that {{is capable of}} self-configuration in order to provide the required QoS. In [20] a <b>failure</b> <b>detector</b> {{that is capable of}} self-configuration is applied to a cloud computing environment.|$|E
40|$|This paper {{addresses}} {{the problem of}} determining the weakest <b>failure</b> <b>detector</b> to implement consensus in a message passing system when t out of n processes can crash (including when n/ 2 =< t < n- 1), by addressing the problem of determining the weakest <b>failure</b> <b>detector</b> to implement a register. We complement and, in a precise sense, generalise previous results on the implementability of consensus and registers in a message passing model (augmented with the <b>failure</b> <b>detector</b> abstraction) ...|$|E
40|$|Abstract—Failure {{detectors}} are {{a fundamental}} part of safe fault-tolerant distributed systems. Many <b>failure</b> <b>detectors</b> use heartbeats {{to draw conclusions}} {{about the state of}} nodes within a distributed environment. The contribution of this paper is an approach whose benefits are twofold. On the one hand it reduces the network overhead produced by heartbeat-style <b>failure</b> <b>detectors.</b> On the other hand it improves the quality of these <b>failure</b> <b>detectors</b> by providing them with richer information about the current network condition. We call this approach lazy monitoring since the active sending of heartbeats is avoided if possible. As it is independent of the actual failure detection algorithm it can be used in many domains. For evaluation purposes we applied our approach to the Smart Doorplate Project. In this testbed the proposed technique reduced the traffic to 1. 2 % while providing much more information about the environment to the <b>failure</b> <b>detectors.</b> I...|$|R
40|$|<b>Failure</b> <b>detectors</b> {{have been}} {{proposed}} by Chandra and Toueg for solving the Consensus problem in an asynchronous system with process crash failures. The paper extends <b>failure</b> <b>detectors</b> {{to the case of}} Byzantine failures, by defining the <b>failure</b> <b>detectors</b> 3 M based on the notion of Mute process. The <b>failure</b> <b>detectors</b> 3 M is defined by the Mute Completeness and the Weak Accuracy properties. The paper also defines the Vector Consensus problem, a variation of the traditional Consensus problem. The difference between these two problems lies in the Validity property. The traditional Validity property used to define the Consensus problem is not adequate in the case of Byzantine failures. In the Vector Consensus problem, the Validity property is replaced by a Vector Validity property, which allows the correct processes to decide on a vector that contains at least d(n+ 1) = 3 e messages from correct processes. Interestingly, we can show that this new specification enables to solve the Atomic [...] ...|$|R
30|$|Network {{monitoring}} systems {{based on the}} Internet Simple Network Management Protocol (SNMP) {{have been used to}} feed system information to <b>failure</b> <b>detectors.</b> Lima and Macedo in [21] explore artificial neural networks in order to implement <b>failure</b> <b>detectors</b> that dynamically adapt themselves to communication load conditions. The training patterns used to feed the neural network were obtained from a network monitoring system based on SNMP.|$|R
40|$|Abstract — Many atomic {{broadcast}} algorithms {{have been}} published in the last twenty years. Token-based algorithms represent a large class of these algorithms. Interestingly all the token-based atomic broadcast algorithms rely on a group membership service, i. e., none of them uses failure detectors. The paper presents the first token-based atomic broadcast algorithm that uses an unreliable <b>failure</b> <b>detector</b> – the new <b>failure</b> <b>detector</b> denoted by R – instead of a group membership service. The <b>failure</b> <b>detector</b> R is compared with ♦P and ♦S. In order {{to make it easier to}} understand the atomic broadcast algorithm, the paper derives the atomic broadcast algorithm from a token-based consensus algorithm that also uses the <b>failure</b> <b>detector</b> R. A. Context I...|$|E
40|$|Abstract—The recent {{discovery}} of the weakest <b>failure</b> <b>detector</b> L for message passing set agreement has renewed the interest in exploring the border between solvable and unsolvable problems in message passing systems. This paper contributes to this research by introducing two novel system modelsManti andMsink with very weak synchrony requirements, where L can be implemented. To {{the best of our}} knowledge, they are the first message passing models where set agreement is solvable but consensus is not. We also generalize L by a novel “(n − k) -loneliness ” <b>failure</b> <b>detector</b> L(k), which allows to solve k-set agreement but not (k− 1) -set agreement. We also present an algorithm that solves k-set agreement with L(k), which is anonymous in that it does not require unique process identifiers. This reveals that L is also the weakest <b>failure</b> <b>detector</b> for anonymous set agreement. Finally, we analyze the relationship between L(k) and other failure detectors, namely the limited scope <b>failure</b> <b>detector</b> Sn−k+ 1 and the quorum <b>failure</b> <b>detector</b> Σ...|$|E
40|$|Solving {{agreement}} problems (such as {{consensus and}} k-set agreement) in asynchronous distributed systems prone to process failures {{has been shown}} to be impossible. To circumvent this impossibility, distributed oracles (also called unreliable failure detectors) have been introduced. A <b>failure</b> <b>detector</b> provides information on failures, and a <b>failure</b> <b>detector</b> class is defined by a set of abstract properties that encapsulate (and hide) synchrony assumptions. Some <b>failure</b> <b>detector</b> classes have been shown to be the weakest to solve some agreement problems (e. g., Ω is the weakest class of failure detectors that allow solving the;consensus problem in asynchronous systems where a majority of processes do not crash). This paper considers several <b>failure</b> <b>detector</b> classes and focuses on their additivity or their irreducibility. It mainly investigates two families of <b>failure</b> <b>detector</b> classes (denoted S_x and ϕ^y, 0 ≤ x,y ≤ n), shows that they can be "added" to provide a <b>failure</b> <b>detector</b> of the class Ω^z (a generalization of Ω). It also characterizes the power of such an "addition", namely, S_x +ϕ^y Ω^z x+y+z>t+ 1, where t is the maximum number of processes that can crash in a run. As an example, the paper shows that, while S_t allows solving 2 -set agreement (and not consensus) and ϕ^ 1 allows solving t-set agreement (but not (t- 1) -set agreement), their "addition" allows solving consensus. More generally, the paper studies the <b>failure</b> <b>detector</b> classes S_x, ϕ^y and Ω^z, and shows whic reductions among these classes are possible and which are not. The paper presents also an Ω^k-based k-set set agreement protocol. In that sense, it can be seen as a step toward the characterization of the weakest <b>failure</b> <b>detector</b> class that allows solving the k-set agreement problem.|$|E
40|$|Abstract—We {{investigate}} whether asynchronous computational models and asynchronous algorithms {{can be considered}} for designing real-time distributed fault-tolerant systems. A priori, the lack of bounded finite delays is antagonistic with timeliness requirements. We show how to circumvent this apparent contradiction, via the principle of “late binding ” of a solution to some (partially) synchronous model. This principle is shown to maximize the coverage of demonstrated safety, liveness, and timeliness properties. These general results are illustrated with the Uniform Consensus (UC) and the Real-Time UC problems, assuming processor crashes and reliable communications, considering asynchronous solutions based upon Unreliable <b>Failure</b> <b>Detectors.</b> We introduce the concept of Fast <b>Failure</b> <b>Detectors</b> and we show that the problem of building Strong or Perfect Fast <b>Failure</b> <b>Detectors</b> in real systems can be stated as a distributed message scheduling problem. A generic solution to this problem is given, illustrated considering deterministic Ethernets. In passing, it is shown that, with our construction of Unreliable <b>Failure</b> <b>Detectors,</b> asynchronous algorithms that solve UC have a worst-case termination lower bound that matches the optimal synchronous lower bound, that is, 8 ̆ 5 t 1 D, where t is the maximum number of processors that may crash and D is the maximum interprocess message delay. Finally, we introduce FastUC, a novel solution to UC, that is based upon Fast <b>Failure</b> <b>Detectors.</b> FastUC has a worst-case termination time that is sublinear in tD. For most practical cases and common values of t, FastUC terminates in D, making it a worst-case time optimal solution to Real-Time UC. Index Terms—Asynchronous computational models, partially synchronous computational models, coverage, uniform consensus, real-time distributed fault-tolerant computing, safety, liveness, timeliness, unreliable <b>failure</b> <b>detectors,</b> schedulability analysis. æ...|$|R
40|$|Thèse de MasterThis work {{presents}} our {{observations and}} {{analysis on the}} influence of the <b>failure</b> <b>detectors</b> over the consensus algorithm. <b>Failure</b> <b>detectors</b> are essential to the consensus in an asynchronous distributed system, as they represent one of the few techniques that are able to circumvent the limitation imposed by the FLP Impossibility (the impossibility to distinguish a crashed process from a slow one, in asynchronous systems). While <b>failure</b> <b>detectors</b> are well defined through two properties, completeness and accuracy, there's no rule about their implementation. Thus, in the literature there are many models of <b>failure</b> <b>detectors,</b> each one implemented using different approaches to the communication and detection strategies. However, these detectors seldom compare themselves to the existing ones; their authors usually present only the advantages and innovations of the new model. Indeed, we only found one work that tried to compare different <b>failure</b> <b>detectors.</b> Using simulation techniques, that work evaluated the impact of the <b>failure</b> <b>detectors</b> on the consensus termination time. However, that research was very limited in the number of detectors analyzed and in the evaluation goals. The present work extended that experience, including more detectors in the analysis and evaluating them in a practical environment. Also, the observations were not restricted to those from the original paper, and the detectors were analyzed with more metrics, failure patterns and operational parameters. The evaluation allowed us to identify the behavior from the detectors in face of the most significant failure patterns, their influence on the consensus operation and their interaction with the execution environment. These evaluation also enabled us to compare the detectors, identifying their limitations, their best performance situations and possible optimizations to future developments...|$|R
40|$|Abstract. The {{performance}} of consensus and atomic broadcast algorithms using <b>failure</b> <b>detectors</b> is often {{affected by a}} trade-off {{between the number of}} communication steps and the number of messages needed to reach a decision. In this paper, we model the {{performance of}} three consensus and atomic broadcast algorithms using <b>failure</b> <b>detectors</b> in the oft-neglected setting of wide area networks and validate this model by experimentally evaluating the algorithms in several different setups. ...|$|R
