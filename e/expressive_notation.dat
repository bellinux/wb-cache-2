15|47|Public
5000|$|A {{function}} in type theory is denoted with an arrow [...] The function [...] (commonly called successor), has the judgement [...] Calling or [...] "applying" [...] a function to an argument is sometimes written without parentheses, so [...] instead of [...] (This {{may serve as}} more <b>expressive</b> <b>notation</b> for consistent currying.) ...|$|E
40|$|A {{diagrammatic}} {{approach to}} the semantics of OO modelling notations is proposed. This {{is based on an}} innovative and <b>expressive</b> <b>notation</b> dubbed ''constraint diagrams'', which can be used to precisely characterise a range of sophisticated, static constraints on OO models. Other notations, such as those found in UML, can be viewed as projections of constraint diagrams. Work on using constraint diagrams at the core of a 3 D modelling notation is also briefly described as a means of similarly providing the semantics of diagrams imposing constraints on dynamic behaviour...|$|E
30|$|On {{the other}} hand, {{there are also}} several studies that deal with {{improving}} different CAD-related abilities (spatial abilities, visualisation skills or the relationship between 2 D drawings and 3 D models) using different technologies and methodologies (Contero M, Naya F, Company P, Saorín JL, 2006; Contero M, Naya F, Company P, Saorín JL, Conesa J, 2005; Plumed, Calleja, Varley, & Martin, 2013). Furthermore, Rossignac (2004) presented some particular examples of teaching CAD {{based on what he}} calls education-driven research (EDR). In these examples, new concepts are introduced by mean of analogies or metaphors; <b>expressive</b> <b>notation</b> and evocative names are used to facilitate memorisation, and the focus is placed only on essential aspects, thereby simplifying concepts until they are well understood.|$|E
50|$|Beauchamps also {{originated}} the Beauchamp-Feuillet notation, {{which provided}} detailed indications of the tract of a dance {{and the related}} footwork. Starting in 1700, hundreds of social and theatrical dances were recorded and widely published in this form. Although this has been superseded in modern times by even more <b>expressive</b> <b>notations,</b> the notation is sufficiently detailed that, along with contemporary dancing manuals, these dances can be reconstructed today.|$|R
40|$|This article {{shows how}} CGLF, CGIF, KIF, Formalized-English and Frame-CG {{can be used}} in a {{panorama}} of knowledge representation cases. It highlights various inadequacies of CGLF and CGIF, advantages provided by high-level <b>expressive</b> <b>notations,</b> and the KIF translations provide a logical interpretation. Knowledge providers may see this document as a guide for knowledge representation. Developers may see it as a list of cases to take into account for their notations and inferences engines. Faculty of Engineering and Information TechnologyNo Full Tex...|$|R
40|$|Abstract. This article {{shows how}} RDF/XML, KIF, Frame-CG (FCG) and Formalized-English (FE) {{can be used}} in a {{panorama}} of knowledge representation cases. It highlights various inadequacies of RDF/XML, advantages provided by high-level <b>expressive</b> <b>notations</b> (FCG and FE), and the KIF translations provide a logical interpretation for the other notations. Knowledge providers may see this document as a guide for knowledge representation. Developers may see it as a list of cases to take into account for their notations and inferences engines. We are working to make our tool, WebKB- 2, import and export in these notations. ...|$|R
40|$|Abstract—Many {{parallel}} {{and distributed}} message-passing programs {{are written in}} a parametric way over available re-sources, in particular the number of nodes and their topologies, so that a single parallel program can scale over different environments. This paper presents a parameterised protocol description language, Pabble, which can guarantee safety and progress in a large class of practical, complex parameterised message-passing programs through static checking. Pabble can describe an overall interaction topology, using a concise and <b>expressive</b> <b>notation,</b> designed for a variable number of partic-ipants arranged in multiple dimensions. These parameterised protocols in turn automatically generate local protocols for type checking parameterised MPI programs for communica-tion safety and deadlock freedom. In spite of undecidability of endpoint projection and type checking in the underlying parameterised session type theory, our method guarantees the termination of endpoint projection and type checking. I...|$|E
40|$|Abstract. In {{this paper}} we {{introduce}} ENP-regex, {{a prototype of}} a regular expression matcher developed for <b>Expressive</b> <b>Notation</b> Package (ENP). ENP-regex allows us to use the regular expression syntax to match against several score attributes, such as pitch and rhythm. Instead of writing the regular expression matcher from scratch we implement a scheme where a thin conversion layer is inserted between an existing Lisp-based regular expression library and ENP. The information sent from ENP to the regex matcher {{is transformed into a}} textual format. Similarly, the matches are converted into corresponding score objects. The benefit of the present implementation is that potentially the whole syntax of the regex matcher in question is at our disposal. We have im-plemented a prototype of the regular expression matcher. In this paper we present {{the current state of the}} system through examples...|$|E
40|$|A {{diagrammatic}} {{approach to}} the semantics of OO modelling notations is proposed. This {{is based on an}} innovative and <b>expressive</b> <b>notation</b> dubbed "constraint diagrams", which can be used to precisely characterise a range of sophisticated, static constraints on OO models. Other notations, such as those found in UML, can be viewed as projections of constraint diagrams. Work on using constraint diagrams at the core of a 3 D modelling notation is also briefly described as a means of similarly providing the semantics of diagrams imposing constraints on dynamic behaviour. 1 Introduction This paper outlines a pictorial approach to constructing a precise semantics for objectoriented modelling notations. There are at least four reasons why one might want to build a precise semantics: 1. To clarify meaning leading to refinements of the notation. 2. To clarify meaning for developers using the notation. 3. To clarify meaning for tool developers, thereby increasing the likelihood of interoperabili [...] ...|$|E
40|$|International audienceLarge {{and complex}} {{software}} systems require <b>expressive</b> <b>notations</b> for representing their software architecture. In this context Architecture Description Languages (ADLs) {{can be used}} for describing architectures of components-based software systems. Typical ADLs provide explicit support for specifying components, connectors, and configuration as well as for building hierarchical systems configurations. All of them allow structural dependencies among components to be specified to define static configurations. This may be sufficient for an initial system composition, but does not provide enough information for reasoning about the different kind of connections among elements. Physical and logical connections are defined in this paper. Four kinds of hierarchies are also presented. Each one is used to provide special-purpose view about the architecture...|$|R
40|$|Abstract. In this paper, {{we argue}} that current user {{interface}} modeling tools are developed using a formalism-centric approach that {{does not support the}} needs of modern software development. In order to solve this problem we need both usable and <b>expressive</b> <b>notations</b> and tools that enable the creation of userinterface specifications that leverage the design and thought process. In this paper we present the CanonSketch tool. CanonSketch supports a new UI specification language – Canonical Abstract Prototypes (CAP) – that bridges the gap between envisioned user behavior and the concrete user interface. The tool also supports two additional and synchronized views of the UI: the Wisdom UML presentation extension and concrete HTML user interfaces. In this way the tool seamlessly supports designers while switching from high level abstract views of the UI and low-level concrete realizations. ...|$|R
40|$|Complex {{software}} systems require <b>expressive</b> <b>notations</b> for representing their software architectures. Two competing paths have emerged, one using {{a specialized}} notation for architecture [...] or architecture description language (ADL), the other using notations applied generally throughout design, such as UML. The latter {{has a number}} of benefits, including familiarity to developers, close mappings to implementations, and commercial tool support. However, it remains an open question how best to use object-oriented notations for architectural description and whether they are sufficiently expressive as currently defined. In this paper, we present a mapping between Acme, a notation designed for expressing architectures, and the UML Real-Time Profile [...] an object-oriented design notation. Specifically, we describe (a) how to map Acme descriptions to descriptions in the UML Real-Time Profile, and (b) the places where this mapping breaks down...|$|R
40|$|Introduction We {{carry out}} a small {{exercise}} in programming by {{what might be called}} expression refinement. This is a style of formal programming in which we begin with an expression written in an <b>expressive</b> <b>notation</b> and regarded as a specification, and proceed to manipulate it into a constructive equivalent. This leads to programs making much use of recursive functions and less use of loops. The exercise is to calculate a pattern-matching algorithm, and specifically the algorithm originally due to Knuth, Morris, and Pratt [0]. We begin, however, with a smaller problem, one {{that turns out to be}} both similar to, and a subproblem of, the larger problem. We prefer to start with this because it will give the reader a chance to become familiar in a simple setting with the style and notation we employ. We briefly review some basic notation. Function application is denoted by an infix dot which has the highest operator precedence. Finite sequences are regarded as partial fu...|$|E
40|$|Abstract. In {{this paper}} {{we present a}} {{procedure}} for representing the se-mantics of linear hybrid automata (LHAs) as constraint logic programs (CLP); flexible and accurate analysis and verification of LHAs can then be performed using generic CLP analysis and transformation tools. LHAs provide an <b>expressive</b> <b>notation</b> for specifying real-time systems. The main contributions are (i) a technique for capturing the reachable states of the continuously changing state variables of the LHA as CLP constraints; (ii) a way of representing events in the LHA as constraints in CLP, along with a product construction on the CLP representation including syn-chronisation on shared events; (iii) a framework in which various kinds of reasoning about an LHA can be flexibly performed by combining stan-dard CLP transformation and analysis techniques. We give experimental results to support {{the usefulness of the}} approach and argue that we con-tribute to the general field of using static analysis tools for verification. ...|$|E
40|$|Distributed service-oriented {{traffic control}} mechanisms, {{operating}} with minimum impact on network performance, assume {{a crucial role}} as regards controlling services quality and network resources transparent and efficiently. In this way, we describe and specify a lightweight distributed admission control (AC) model which provides an uniform solution for managing QoS and SLSs in multiclass and multidomain environments. Taking advantage of the consensual need of on-line service monitoring and traffic control at the network edges, AC decisions are driven by feedback from systematic edge-to-edge measurements of relevant QoS parameters for each service type and SLS utilization. This allows self-adaptive service and resource management, while abstracting from network core complexity and heterogeneity. In this paper, introducing an <b>expressive</b> <b>notation,</b> we specify the high-level entities for multiservice provisioning in a domain and formalize service-dependent AC equations to assure both intra and interdomain model operation. A proof-of-concept of the AC criteria effectiveness in satisfying each service class commitments while achieving high network utilization is provided through simulation...|$|E
40|$|Abstract. Complex {{software}} systems require <b>expressive</b> <b>notations</b> for representing their software architectures. Two competing paths have emerged. One {{is to use}} {{a specialized}} notation for architecture – or architecture description language (ADL). The other is to adapt a general-purpose modeling notation, such as UML. The latter has a number of benefits, including familiarity to developers, close mapping to implementations, and commercial tool support. However, it remains an open question as to how best to use object-oriented notations for architectural description, and, indeed, whether they are sufficiently expressive, as currently defined. In this paper we take a systematic look at these questions, examining the space of possible mappings from ADLs into object notations. Specifically, we describe (a) the principle strategies for representing architectural structure in UML; (b) the benefits and limitations of each strategy; and (c) aspects of architectural description that are intrinsically difficult to model in UML using the strategies. ...|$|R
40|$|This paper {{presents}} Smyle, a {{tool for}} synthesizing asynchronous and distributed implementation models from sets of scenarios that are given as message sequence charts (MSCs). The latter specify desired or unwanted behavior of the system to be. Provided with such positive and negative example scenarios, Smyle employs dedicated learning techniques and propositional dynamic logic (PDL) over MSCs to generate a system model that conforms with the given examples. Synthesizing distributed systems from user-specified scenarios is becoming increasingly en vogue [7]. There exists {{a wide range of}} approaches for synthesizing implementation models from a priori given scenarios [6, 11, 8, 5, 14, 15]. The approaches mainly differ in their specification language, the inference procedure, and the final implementation model. Several of them employ MSCs as specification language because they are standardized by the ITU Z. 120 [9] and adopted by the UML as sequence diagrams. Other approaches try to utilize more <b>expressive</b> <b>notations</b> like triggered MSCs [14], high-level MSCs [6], or live sequence charts [8]. On the one hand, more expressive power results in richer specifications. O...|$|R
40|$|Abstract: An ever-growing {{number of}} XML-based {{languages}} {{are used to}} describe Web Service related issues such as security (WS-Security Policy), access control (XAC-ML), or privacy (P 3 P-WS). While it is desirable to specify policies in a declarative way, these languages expose great diversity in both syntax and semantics {{making it hard to}} realize a unified system. Our contribution to this problem is twofold. First, we present an <b>expressive</b> formal <b>notation</b> for policies. Second, we show how requester-, provider-, and third-party policies can be used for choosing a suitable service while making sure that all relevant policies are obeyed. ...|$|R
40|$|In {{this paper}} {{we present a}} {{procedure}} for representing the semantics of linear hybrid automata (LHAs) as constraint logic programs (CLP); flexible and accurate analysis and verification of LHAs can then be performed using generic CLP analysis and transformation tools. LHAs provide an <b>expressive</b> <b>notation</b> for specifying real-time systems. The main contributions are (i) a technique for capturing the reachable states of the continuously changing state variables of the LHA as CLP constraints; (ii) a way of representing events in the LHA as constraints in CLP, along with a product construction on the CLP representation including synchronisation on shared events; (iii) a framework in which various kinds of reasoning about an LHA can be flexibly performed by combining standard CLP transformation and analysis techniques.   We give experimental results to support {{the usefulness of the}} approach and argue that we contribute to the general field of using static analysis tools for verificationVolumne: 543...|$|E
40|$|Apresentação efectuada na International Conference on Integrated Management (IM 2005), Nice, France, May 2005. Distributed service-oriented {{traffic control}} mechanisms, {{operating}} with minimum impact on network performance, assume {{a crucial role}} as regards controlling services quality and network resources transparent and efficiently. In this way, we describe and specify a lightweight distributed admission control (AC) model which provides an uniform solution for managing QoS and SLSs in multiclass and multidomain environments. Taking advantage of the consensual need of on-line service monitoring and traffic control at the network edges, AC decisions are driven by feedback from systematic edge-to-edge measurements of relevant QoS parameters for each service type and SLS utilization. This allows self-adaptive service and resource management, while abstracting from network core complexity and heterogeneity. In this paper, introducing an <b>expressive</b> <b>notation,</b> we specify the high-level entities for multiservice provisioning in a domain and formalize service-dependent AC equations to assure both intra and interdomain model operation. A proof-of-concept of the AC criteria effectiveness in satisfying each service class commitments while achieving high network utilization is provided through simulation...|$|E
40|$|Constraint {{diagrams}} are a diagrammatic notation {{which may}} be used to express logical constraints. They generalize Venn diagrams and Euler circles, and include syntax for quantification and navigation of relations. The notation was designed to complement the Unified Modelling Language in the development of software systems. Since symbols representing quantification in a diagrammatic language can be naturally ordered in multiple ways, some constraint diagrams have more than one intuitive meaning in first order predicate logic. Any equally <b>expressive</b> <b>notation</b> which is based on Euler diagrams and conveys logical statements using explicit quantification will have to address this problem. We explicitly augment constraint diagrams with reading trees, which provides a partial ordering for the quantifiers (determining their scope as well as their relative ordering). Alternative approaches using spatial arrangements of components, or al- phabetical ordering of symbols, for example, can be seen as implicit representations of a reading tree. Whether the reading tree accompanies the diagram explicitly (optimizing ex- pressiveness) or implicitly (simplifying diagram syntax), we show how to construct unambiguous semantics for the augmented constraint diagram...|$|E
40|$|Language-based {{programming}} environments {{provide some}} or all of the functionality of a compiler, an interactive debugger, a browser, and a configuration manager behind a unified user interface based on an editing paradigm. As the user edits a program, the changes are processed incrementally, allowing for low-latency updates to derived information. This information can be made available to interactive environment services, such as browsing, navigation, and "real time" error-reporting. In this dissertation, we address an important subproblem in the construction of such environments, the generation of static semantic analyzers that operate in an incremental mode. Our work is embodied in the Colander II system, which introduces both a new metalanguage for the declarative specification of static semantic analyses and new techniques for generating an incremental analyzer from these specifications automatically. Our specification metalanguage melds the advantages of traditional attribute grammars, including amenability to extensive generation-time analysis, with the expressiveness and clientindependence characteristic of Ballance's Logical Constraint Grammars. In comparison to traditional attribute grammars, our metalanguage allows much more of the incrementality inherent in a particular analysis task to be exposed within the formalism itself, where it can be exploited automatically by our implementation. Our incremental analysis algorithms exploit the attributed objects and function-valued attributes provided by our metalanguage, mapping these <b>expressive</b> <b>notations</b> onto a fine-grained incremental implementation. We are thus able to automatically generate incremental analyzers that handle longdistance dependencies and aggregate attributes efficiently. Our methods allow unusua [...] ...|$|R
40|$|The aim of {{the drawing}} Caves II and the {{practice}} from which it arises is, through archival and field work, to research and reconnect contemporary drawing with significant and overlooked historical practices. The Caves series arose through research in the Turner archive on how artists use sketch books. I examined a group of unusual sketches in the Yorkshire 4 notebook of caves, including Yordas Cave. I returned to the exact location {{to try to understand}} why Turner's language in these drawings was so erratic. After many drawing visits {{it was clear that the}} collision of darkness, discomfort, and fear with his practice of measured accurate topographic drawing combined to make a powerfully <b>expressive</b> shorthand <b>notation...</b>|$|R
40|$|GXL - {{the graph}} {{transformation}} language {{presented in this}} abstract is a programmable graph rewriting language that combines ideas from current tree rewriting technology, exemplified by the TXL language, and general graph rewriting systems. From TXL it inherits the idea of scoping (limitation of a transformation rule to a particular subtree or subgraph) and parameterization (working with multiple independent copies of a subtree or subgraph). From graph rewriting it inherits the generalization to graphs from trees. The resulting language addresses both problems in tree rewriting imposed by the limitation to trees, and problems in graph rewriting imposed {{by the lack of}} scoping and parameterization. 1. Motivation Graph rewriting systems such as PROGRES [1] have proven very powerful and <b>expressive</b> <b>notations</b> for dealing with large graphs, but can be awkward or inefficient when specifying complex graph transformations that involve rules to be limited to particular subgraphs of the host graph, or to deal with multiple copies or views of a matched subgraph. Both of these problems are well solved in the tree rewriting community by borrowing ideas from pure functional programming [2] and rule based programming [3]. Tree rewriting languages such as TXL [4], on the other hand, excel at implementing complex transformations involving multiple copies and views of matched subtrees and application of different rulesets to different matched subtrees, at speeds orders of magnitude faster than the fastest graph rewriting systems. But the limitation to trees can make it awkward or inefficient in TXL to implement transformations such as call graph closure that are more naturally expressed using general graph rewriting. GXL, the graph transformation language presented here, is a programmable [...] ...|$|R
40|$|Dynamic binary {{translation}} {{allows us}} to analyze a program during execution {{without the need for}} a compiler or the program's source code. In this work, we present two applications of dynamic binary translation: tracematches and unread memory detection. Libraries are ubiquitous in modern software development. Each library requires that its clients follow certain conventions, depending on the domain of the library. Tracematches are a particularly <b>expressive</b> <b>notation</b> for specifying library usage conventions, but have only been implemented on top of Java. In this work, we leverage dynamic binary translation to enable the use of tracematches on executables, particularly for compiled C/C++ programs. The presence of memory that is never read, or memory writes that are never read during execution is wasteful, and may be also be indicative of bugs. In addition to tracematches, we present an unread memory detector. We built this detector using dynamic binary translation. We have implemented a tool which monitors tracematches on top of the Pin framework along with unread memory. We describe the operation of our tool using a series of motivating examples and then present our overall monitoring approach. Finally, we include benchmarks showing the overhead of our tool on 4 open source projects and report qualitative results...|$|E
40|$|In {{this article}} we will be {{discussing}} abstract classes, {{and how they are}} implemented in C++. The first part of the article will define abstract classes and describe how to use them as tools for Object Oriented Design. The second half of the article will concern itself with their implementation in C++, and some of the quirks and pitfalls that surround their use. While it is true that all objects are represented by a class, the converse is not true. All classes do not necessarily represent objects. It is possible, and often desirable, for a class to be insufficient to completely represent an object. Such classes are called abstract classes. The illustrations used in this article conform to the “Booch Notation ” for Object Oriented Design. This is a rich and <b>expressive</b> <b>notation</b> which is very useful for presenting OOD concepts. Where necessary I will digress to explain some of this notation. What is an Abstract Class? Simply stated, an abstract class is a class which does not fully represent an object. Instead, it represents a broad range of different classes of objects. However, this representation extends only to the features that those classes of objects have in common. Thus, an abstract class provides only a partial description of its objects. Because abstract classes do not fully represent an object, they cannot be instantiated. At first it may seem a little odd that a class is incapable of having any instances. But everyday life is full of such classes. We may describe a particular animal as belonging to the class of all Mammals. However, we will never see an instance of the class Mammal! At least not a pure instance. Every animal belonging to the class Mammal must also belong to a class which is subordinate to Mammal such as Mouse, Dog, Human, or Platypus. This is because the class Mammal does not fully represent any animal. In Object class, unless it is also an instance of a subordinate class. This is because the abstract class does not fully represent any object. As Booch says: “An abstract class is written with the expectation that its subclasses will add to its structure and behavior [...] . ”...|$|E
40|$|The {{purpose of}} this paper is to give the reader a concise {{overview}} of <b>Expressive</b> <b>Notation</b> Package 2. 0 (henceforward ENP). ENP is music notation program that belongs to a family of music and sound related software packages developed at Sibelius Academy in Finland. ENP has been used in various research projects during the past several years. 1. OVERVIEW ENP [3] is a music notation program that has been developed in order to meet the requirements of computer aided composition, music analysis and virtual instrument control. ENP is intended to represent Western musical notation from 17 th century onward including 20 th century notation. ENP is not a full featured music typesetting program. It is, however, designed to produce automatic, reasonable musical typesetting according to the common practices [12]. ENP output should not generally require adjustments made by the user. There are also some other non-commercial LISP-based programs that are aimed at representing complex musical data such as Common Music Notation [13], PatchWork’s Rhythm-Editor [6] and the musical editors in OpenMusic [1]. ENP is programmed with LispWorks ANSI Common Lisp by Xanalys. LispWorks, in turn, is a Lisp implementation that is source code compatible across Windows, Linux, Mac OS X and UNIX platforms. ENP uses the OpenGL API for graphical output. OpenGL is a widely used 3 D graphics library that is fast and portable with implementations in all of the aforementioned operating systems. It is equally suitable for developing 2 D or 3 D interactive applications. At the time of writing the development version of ENP runs in Mac OS X. However, some preliminary attempts have been made to port it to Windows. Some of the key concepts behind ENP are: 1) ENP can be used to represent a wide range of notational styles. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page...|$|E
40|$|We {{describe}} a systematic approach to building tools for the automated analysis of specifications expressed in higher-order logic (hol) independent of a conventional, interactive theorem proving environment. In contrast to {{tools such as}} HOL and PVS, we have taken “the hol out of HOL ” by building automated analysis procedures from a toolkit for manipulating hol specifications. Our approach eliminates the burden of skilled interaction required by a conventional theorem prover. Our lightweight approach allows a hol specification {{to be used for}} diverse purposes, such as model checking, and the algorithmic generation of test cases. After five years of experience with this approach, we conclude that by decoupling hol from its conventional environment, we retain the benefits of an <b>expressive</b> specification <b>notation,</b> and can generate many useful analysis results automatically. ...|$|R
40|$|Multiperspectives {{naturally}} arise out of co-operative work {{in applying}} appropriate technologies to construct {{different parts of}} an application. The representation styles of various perspectives can be highly heterogeneous and open-ended since those perspectives should be presented in a form appropriate to each participant in the software development process. This {{makes it difficult to}} provide consistency checking and integration mechanisms for the perspectives. This paper presents an approach of dealing with automated consistency checking for multiperspective software specifications regardless of their heterogeneity of representation. We apply <b>expressive</b> graph <b>notations</b> called Conceptual Graphs (CGs) as visual consistency checking notations. The combination of underlying logical reasoning and graph-based reasoning of CGs provide a powerful consistency checking mechanism. Our framework is illustrated with excerpts of a case study using Unified Modeling Language (UML) ...|$|R
40|$|Abstract. Modern {{statistical}} AI {{systems are}} quite large and complex; this interferes with research, development, and education. We observe {{that most of}} the computation involves solving systems of equations of a certain kind. Specifically, recursive queries look up and aggregate relevant or potentially relevant values. If the results of these queries are memoized for reuse, the memos may need to be updated through change propagation. In-memory database systems can do a lot to support this work in a generic way. Through examples, we show that a wide variety of AI algorithms can be concisely captured by writing down systems of equations in an <b>expressive</b> declarative <b>notation</b> that generalizes Datalog, independent of the many strategies {{that could be used to}} actually solve those systems. We use these examples to motivate certain extensions to Datalog, which are connected to functional and object-oriented programming paradigms. 1 Why a New Data-Oriented Language for AI...|$|R
40|$|This paper {{presents}} {{a discussion on}} the complementary roles of testing and proof within automated software verification and validation processes. We demonstrate how {{a combination of the}} two approaches can lead to greater levels of automation and integrity. In particular we discuss the use of automated counter-example generation to support proof, and automated proof as a means of automating and checking test case generation. The high levels of automation are made possible by identifying repeating structures in the proofs, restricting the specification to a subset of an otherwise <b>expressive</b> formal <b>notation</b> and exploiting a general [...] purpose theorem proving tool with built-in constraint solvers. 1 Introduction In the past, testing and proof have not been easy bedfellows. Despite their shared goal of increased software quality, proof has been seen as being for the cognoscenti, testing for software engineering's working class. The authors believe that this artificial dichotomy is harmful a [...] ...|$|R
40|$|TIC) is {{a highly}} <b>expressive</b> set-based <b>notation</b> for specifying and {{reasoning}} about embedded real-time systems. However, it lacks mechanical proving support, as its verification usually involves infinite time intervals and continuous dynamics. In this paper, we develop a system based on a generic theorem prover, Prototype Verification System (PVS), to assist formal verification of TIC at a high grade of automation. TIC semantics has been constructed by the PVS typed higher-order logic. Based on the encoding, we have checked all TIC reasoning rules rigorously and discovered subtle flaws. A translator has been implemented in Java to automatically transform TIC models into PVS specifications. A collection of supplementary rules and PVS strategies has been defined to facilitate the rigorous reasoning of TIC models with functional and non-functional (e. g. real-time) requirements at the interval level. Our approach is generic and can be applied further to support other real-time notations...|$|R
40|$|This {{research}} investigates how {{to create}} a modeling tool specifically for stochastic programming problems with recourse. By taking advantage of the special structure these problems have, we produce a modeling language whose syntax is less redundant, more modular, and more <b>expressive</b> than the <b>notation</b> commonly associated with stochastic programming. We then implement a system that can convert models written using this syntax to instances that can be solved using standard mechanisms. With this approach, we are able to represent models in a very clean, simple, and scalable format. 1...|$|R
40|$|International audienceSoftware {{processes}} and software process modeling approaches were {{and still are}} {{in the heart of}} enterprise preoccupations. This interest is essentially motivated by the increasing need to build reliable and complex software systems in a short time to market. During the three last decades, a variety of Process Modeling Languages were proposed in order to capture the expertise of enterprises. However no one succeeded in gaining the attention of the industry. Main reasons were because that most of them were either imprecise or not suitable to be executed or both. This paper presents UML 4 SPM, a UML 2. 0 -based Language for software process modelling. Expressiveness, understandability, precision and executability were our main objectives while designing UML 4 SPM. Our contribution comes inform of MOF-compliant metamodel, a simple yet <b>expressive</b> graphical <b>notation</b> and diagrams and a precise semantics. In order to validate our work, we evaluate UML 4 SPM with the well-known ISPW- 6 process example, a standard benchmark problem for software process modeling...|$|R
40|$|Usability {{is one of}} {{the most}} {{important}} qualities of a software system. Task-based design has prooved to deliver a high usability level. GTATool is a task analysis tool which combines the well-founded theoretical aspects of Groupware Task Analysis (GTA) method with the <b>expressive</b> and powerful <b>notation</b> Concur Task Trees (CTT). Our goal is to generate presentation and dialog models starting from the task models developed with our tool. In this paper we will focus on presenting a first step in dialog model generation: states identification. We have chosen a formal representation of the dialog model represented by statecharts...|$|R
40|$|Interval-based {{specification}} languages {{have been}} used to formally model and rigorously reason about real-time computing systems. This usually involves logical reasoning and mathematical computation with respect to (continuous or discrete) time. When these systems are complex, analyzing their models by hand becomes error-prone and difficult. In this article, we develop a verification system to facilitate the formal analysis of interval-based specification languages with machine-assisted proof support. The verification system is developed using a generic theorem prover, Prototype Verification System (PVS). Our system elaborately encodes a highly <b>expressive</b> set-based <b>notation,</b> Timed Interval Calculus (TIC), and can rigorously carry out the verification of TIC models at an interval level. All TIC reasoning rules are validated, and subtle flaws in the original rules have been discovered. We also apply TIC to model Duration Calculus (DC), which is a popular interval-based specification language, and thus expand the capacity of the verification system. In particular, we can check the correctness of DC axioms, and execute DC proofs {{in a manner similar to}} the corresponding pencil-and-paper DC arguments. Categories and Subject Descriptors: D. 2. 1 [Software Engineering]: Requirements/Specifications...|$|R
