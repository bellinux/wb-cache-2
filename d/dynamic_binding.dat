580|239|Public
25|$|Late {{static binding}} is {{a variant of}} binding somewhere between static and <b>dynamic</b> <b>binding.</b> The binding of names before the program is run is called static (early); {{bindings}} performed as the program runs are dynamic (late or virtual).|$|E
25|$|Note: The Soviet Era {{computers}} Эльбрус-1 (Elbrus-1) and Эльбрус-2 {{were created}} using high-level language Эль-76 (AL-76), {{rather than the}} traditional assembly. Эль-76 resembles Algol-68, The main difference is the <b>dynamic</b> <b>binding</b> types in Эль-76 supported at the hardware level. Эль-76 is used for application, job control, system programming.|$|E
2500|$|The MKDE was {{retained}} in Pervasive.SQL 7. However, {{due to the}} new component architecture's <b>dynamic</b> <b>binding,</b> the internal architecture was modified. The application using Btrieve calls a services manager which then searches through various configured directories for specific encoded filename. The file name loaded for Btrieve files in Backus-Naur form is: ...|$|E
40|$|Human agents draw {{a variety}} of inferences effortlessly, spontaneously, and with {{remarkable}} efficiency - as though these inferences are a reflex response of their cognitive apparatus. The work {{presented in this paper}} is a step toward a computational account of this remarkable reasoning ability. We describe how a connectionist system made up of simple and slow neuron-like elements can encode millions of facts and rules involving n-ary predicates and variables, and yet perform {{a variety of}} inferences within hundreds of milliseconds. We observe that an efficient reasoning system must represent and propagate, dynamically, a large number of variable bindings. The proposed system does so by propagating rhythmic patterns of activity wherein <b>dynamic</b> <b>bindings</b> are represented as the in-phase, i. e., synchronous, firing of appropriate nodes. The mechanisms for representing and propagating <b>dynamic</b> <b>bindings</b> are biologically plausible. Neurophysiological evidence suggests that similar mechanisms may in fact be used by the brain to represent and process sensorimotor information...|$|R
40|$|This paper {{presents}} {{an approach to}} representing dependencies for object-oriented (OO) Ada 95 programs. This new approach distinguishes subcomponents for different objects and represents the effects of polymorphism and <b>dynamic</b> <b>bindings.</b> Based on this model, we developed approaches to slicing subprograms, packages/types and hierarchies of types. Our slicing algorithm is more efficient {{because most of the}} results can be reused, and inter-subprogram slicing is transformed to intra-subprogram slicing...|$|R
40|$|Abstract: Human agents draw {{a variety}} of inferences effortlessly, spontaneously, and with {{remarkable}} efficiency — as though these inferences are a reflex response of their cognitive apparatus. Furthermore, these inferences are drawn with reference to {{a large body of}} background knowledge. This remarkable human ability seems paradoxical given the results about the complexity of reasoning reported by researchers in artificial intelligence. It also poses a challenge for cognitive science and computational neuroscience: How can a system of simple and slow neuron-like elements represent a large body of systematic knowledge and perform a range of inferences with such speed? We describe a computational model that is a step toward addressing the cognitive science challenge and resolving the artificial intelligence paradox. We show how a connectionist network can encode millions of facts and rules involving n-ary predicates and variables, and perform a class of inferences in a few hundred msec. Efficient reasoning requires the rapid representation and propagation of <b>dynamic</b> <b>bindings.</b> Our model achieves this by i) representing <b>dynamic</b> <b>bindings</b> as the synchronous firing of appropriate nodes, ii) rules as interconnection pattern...|$|R
2500|$|Pervasive.SQL 7 was {{released}} in March, 1998, and included Scalable SQL 4 and Btrieve 7.0. Btrieve 7.0 ran on the same platforms as Btrieve 6.x: Windows 95, Windows NT 3.51 & 4, Netware and DOS. However, the company changed to a component-based architecture called SmartComponents to resolve compatibility issues with upgrades. This used a component identification scheme both embedded into the file and encoded into the file name, along with <b>dynamic</b> <b>binding</b> of [...] "glue files" [...] (DLLs loaded into memory only when needed). The <b>dynamic</b> <b>binding</b> of components was done using a new [...] "Abstract OS Services DLL" [...] that looked for {{the latest version of}} the appropriate needed component via the file name encoding. This [...] "glue module" [...] is then loaded into memory and used. The old log file format of Btrieve 6.x was also replaced with a new centralised log called PVSW.LOG and that had a unified and enhanced log file format. They also improved their error messages and error message reporting mechanisms.|$|E
5000|$|... it has <b>dynamic</b> <b>binding,</b> but {{supports}} closures with {{a special}} construct ...|$|E
5000|$|The {{application}} to inheritance, in particular a formalism for redefinition and <b>dynamic</b> <b>binding</b> ...|$|E
40|$|Starting {{from the}} premise that working memory is a system for {{providing}} access to representations for complex cognition, six requirements for a working memory system are delineated: (1) maintaining structural representations by <b>dynamic</b> <b>bindings,</b> (2) manipulating structural representations, (3) flexible reconfiguration, (4) partial decoupling from long-term memory, (5) controlled retrieval from long-term memory, and (6) encoding of new structures into longterm memory. The chapter proposes an architecture for a system that meets these requirements. The working memory system consists of a declarative and a procedural part, {{each of which has}} three embedded components: the activated part of long-term memory, a component for creating new structural representations by <b>dynamic</b> <b>bindings</b> (the ‘‘region of direct access’’ for declarative working memory, and the ‘‘bridge’’ for procedural working memory), and a mechanism for selecting a single element (‘‘focus of attention’’ for declarative working memory, and ‘‘response focus’’ for procedural working memory). The architecture affords two modes of information processing, an analytical and an associative mode. This distinction provides a theoretically founded formulation of a dual-process theory of reasoning...|$|R
40|$|Abstract. <b>Dynamic</b> service <b>binding</b> is {{essential}} for runtime adaptability of BPEL processes, {{particularly in the case}} of service failure. BPEL’s support for <b>dynamic</b> service <b>binding</b> is coupled with the process business logic, requiring the process developer to deal with dynamic service selection and failure recovery. Changing these aspects requires modification and redeployment of all affected processes. In this paper we present a novel infrastructure that handles <b>dynamic</b> (re) <b>binding</b> of stateful and stateless services independently of process business logic. Our infrastructure is transparent both to the process developer and to the BPEL engine. It offers automated failure recovery and allows for runtime customizations, such as changes of service binding policies. We also assess infrastructure overhead and explore the impact of service failures on system throughput...|$|R
40|$|Modern {{technologies}} {{may prove}} {{their ability to}} support symbolic computing if Computer Algebra Systems are enabled for Service Oriented Architecture, SOA and Grid architectures. This paper introduces a system that allows Computer Algebra Systems to act as clients for Web/Grid services by calling or by combining their functionality, or to expose symbolic computing engines as support for such services. To compose functionality, static workflows with <b>dynamic</b> <b>bindings</b> and potentially, <b>dynamic</b> workflows can be used...|$|R
50|$|Use of an {{interface}} {{also leads}} to <b>dynamic</b> <b>binding</b> and polymorphism, which are central features of object-oriented programming.|$|E
50|$|In {{complexation}} catalysis, {{the term}} <b>dynamic</b> <b>binding</b> refers to any stabilizing interaction that is stronger at the transition state level {{than in the}} reactant-catalyst complex.|$|E
50|$|Kibble, R. 1997. Complement {{anaphora}} and <b>dynamic</b> <b>binding.</b> In Proceedings from Semantics and Linguistic Theory VII, ed. A. Lawson, 258-275. Ithaca, New York: Cornell University.|$|E
40|$|Seeking {{coherent}} explanations — {{a fusion}} of structured connectionism, temporal synchrony, and evidential reasoning A connectionist model capable of performing rapid inferences to establish explanatory and referential coherence is described. The model’s ability to perform such inferences arises from (i) its structure, (ii) its use of mutual inhibition among “sibling” types, entities, and rules, (iii) the use of temporal synchrony for representing <b>dynamic</b> <b>bindings,</b> and (iv) its ability to rapidly modify weights in response to convergent activity...|$|R
40|$|Providing {{end-to-end}} {{communication in}} heterogeneous internetworking environments is a challenge. Two fundamental problems are bridging between different internetworking technologies and hiding of network complexity and differences from both applications and application developers. This paper presents abstraction and naming mechanisms that address these {{challenges in the}} Ambient Networks project. Connectivity abstractions hide the differences of heterogeneous internetworking technologies and enable applications to operate across them. A common naming framework enables end-to-end communication across otherwise independent internetworks and supports advanced networking capabilities, such as indirection or delegation, through <b>dynamic</b> <b>bindings</b> between named entities...|$|R
40|$|Today’s Internet is {{open and}} anonymous. While it permits free traffic from any host, attackers that {{generate}} malicious traffic cannot typically be held accountable. In this paper, we present a system called HostTracker that tracks <b>dynamic</b> <b>bindings</b> between hosts and IP addresses by leveraging application-level data with unreliable IDs. Using a month-long user login trace from a large email provider, we show that HostTracker can attribute most of the activities reliably to the responsible hosts, despite the existence of dynamic IP addresses, proxies, and NATs. With this information, {{we are able to}} analyze the host population, to conduct forensic analysis, and also to blacklist malicious hosts dynamically...|$|R
50|$|Late binding, or <b>dynamic</b> <b>binding,</b> is a {{computer}} programming mechanism in which the method being called upon an object or the function being called with arguments is looked up by name at runtime.|$|E
50|$|Monoliths are {{ideally suited}} for large molecules. As {{mentioned}} previously, particle sizes are decreasing {{in an attempt}} to achieve higher resolution and faster separations, which led to higher backpressures. When the smaller particle sizes are used to separate biomolecules, backpressures increase further because of the large molecule size. In monoliths, where backpressures are low and channel sizes are large, small molecule separations are less efficient. This is demonstrated by the <b>dynamic</b> <b>binding</b> capacities, a measure of how much sample can bind {{to the surface of the}} stationary phase. <b>Dynamic</b> <b>binding</b> capacities of monoliths for large molecules can be an order of ten times greater than that for particulate packings.|$|E
50|$|Late {{static binding}} is {{a variant of}} binding somewhere between static and <b>dynamic</b> <b>binding.</b> The binding of names before the program is run is called static (early); {{bindings}} performed as the program runs are dynamic (late or virtual).|$|E
40|$|Abstract. Wepresent a connectionist {{realization}} of parameterized schemas that can model high-level sensory-motor processes {{and be a}} candidate representation for implementing reactive behaviors. The connectionist realization involves a number of ideas {{including the use of}} focal-clusters and feedback loops to control a distributed process without a central controller and the expression and propagation of <b>dynamic</b> <b>bindings</b> via temporal synchrony. Weemploy a uniform mechanism for interaction between schemas, low-level somatosensory and proprioceptive processes, and high-level reasoning and memory processes. Our representation relates to work in connectionist models of rapid | re exive | reasoning and also suggests solutions to several problems in language acquisition and understanding. ...|$|R
40|$|In the {{presence}} of rst-class continuations, shallow maintenance of <b>dynamic</b> <b>bindings</b> requires more than the traditional stack-based techniques. This paper provides correctness criteria for such dynamic environments, along with contrasting implementations. A store semantics provides the framework for our correctness criteria and presentation of deep- and shallow-binding implementations. The latter implementation is a new state-space algorithm, which isproved correct. A variation of the algorithm implements Scheme's dynamic-wind operation. Finally, a technique for maintaining dynamic state called semi-shallow binding is presented. This compromise between deep- and shallow-binding appears suitable for parallel systems. Applications include uid binding of lexical variables and logic programming with rst-class continuations. ...|$|R
40|$|Dynamic program slicing is an {{effective}} technique for narrowing the errors to the relevant parts of a program when debugging. Given a slicing criterion, the dynamic slice contains only those statements that actually affect the variables in the slicing criterion. This paper proposes a method to dynamically slice object-oriented (OO) programs based on dependence analysis. It uses the object program dependence graph and other static information to reduce the information to be traced during program execution. It deals with OO features such as inheritance, polymorphism and <b>dynamic</b> <b>bindings.</b> Based on this model, we present methods to slice methods, objects and classes. We also modify the slicing criterion to fit for debugging...|$|R
5000|$|Late {{static binding}} is {{a variant of}} binding somewhere between static and <b>dynamic</b> <b>binding.</b> Consider the {{following}} PHP example:class A { static $word = [...] "hello"; static function hello (...) { print self::$word; }}class B extends A { static $word = [...] "bye";}B::hello (...) ...|$|E
50|$|This {{abstraction}} naturally maps to thread-specific storage, and Lisp implementations {{that provide}} threads do this. Common Lisp has numerous standard dynamic variables, and so threads cannot be sensibly added to an {{implementation of the}} language without these variables having thread-local semantics in <b>dynamic</b> <b>binding.</b>|$|E
5000|$|But {{an example}} of <b>dynamic</b> <b>binding</b> is dynamic dispatch, as in a C++ virtual method call. Since the {{specific}} type of a polymorphic object is not known before runtime (in general), the executed function is dynamically bound. Take, for example, the following Java code: ...|$|E
50|$|Proxy {{services}} in WinGate support SSL/TLS connections, <b>dynamic</b> network <b>binding</b> (automatic response to network {{events such as}} addition or removal of network interfaces), and gateway pre-selection (to direct service for a particular application out a specific Internet connection).|$|R
40|$|Abstract—Classical {{approaches}} for program analysis as, e. g., termination analysis {{usually do not}} take into account modern software approaches such as service-oriented systems or cloud computing. Instead, they have a monolithic view on the software system as a single completely available program. As first step to enable such analyses also in a service-oriented or cloud computing context, respectively, this paper considers termination. Since termination is a service quality attribute, we consider a service-level agreement approach that allows <b>dynamic</b> <b>bindings</b> to software services. In contrast to many other service-level agreements, termination is a binary attribute that cannot be measured quantitatively (as, e. g., reliability or response time). The proposed approach shows how clients of services can verify the information provided by the services...|$|R
40|$|In the {{presence}} of first-class continuations, shallow maintenance of <b>dynamic</b> <b>bindings</b> requires more than the traditional stack-based techniques. This paper provides correctness criteria for such dynamic environments, along with contrasting implementations. A store semantics provides the framework for our correctness criteria and presentation of deep- and shallow-binding implementations. The latter implementation is a new state-space algorithm, which is proved correct. A variation of the algorithm implements Scheme's dynamic-wind operation. Finally, a technique for maintaining dynamic state called semi-shallow binding is presented. This compromise between deep- and shallow-binding appears suitable for parallel systems. Applications include fluid binding of lexical variables and logic programming with first-class continuations. 1 Introduction Dynamic state-management is required in many situations. Usually dynamic contexts are associated with control contexts, as with dynamic variables, [...] ...|$|R
50|$|Being {{directly}} related to transition state stabilization, <b>dynamic</b> <b>binding</b> is the very hearth of complexation catalysis. It was defined by A.J. Kirby in 1996 {{as opposed to the}} passive binding, i.e. the whole of interactions that are equally strong at the reactant and the transition state level.|$|E
50|$|Note: The Soviet Era {{computers}} Эльбрус-1 (Elbrus-1) and Эльбрус-2 {{were created}} using high-level language Эль-76 (AL-76), {{rather than the}} traditional assembly. Эль-76 resembles Algol-68, The main difference is the <b>dynamic</b> <b>binding</b> types in Эль-76 supported at the hardware level. Эль-76 is used for application, job control, system programming.|$|E
5000|$|The MKDE was {{retained}} in Pervasive.SQL 7. However, {{due to the}} new component architecture's <b>dynamic</b> <b>binding,</b> the internal architecture was modified. The application using Btrieve calls a services manager which then searches through various configured directories for specific encoded filename. The file name loaded for Btrieve files in Backus-Naur form is: ...|$|E
50|$|Microtubules are hollow {{cylinders}} about 23 nm {{in diameter}} (lumen = approximately 15 nm in diameter), most commonly comprising 13 protofilaments that, in turn, are polymers of alpha and beta tubulin. They {{have a very}} <b>dynamic</b> behavior, <b>binding</b> GTP for polymerization. They are commonly organized by the centrosome.|$|R
40|$|We {{present a}} connectionist {{realization}} of parameterized schemas that can model highlevel sensory-motor processes {{and be a}} candidate representation for implementing reactive behaviors. The connectionist realization involves a number of ideas {{including the use of}} focal-clusters and feedback loops to control a distributed process without a central controller and the expression and propagation of <b>dynamic</b> <b>bindings</b> via temporal synchrony. We employ a uniform mechanism for interaction between schemas, low-level somatosensory and proprioceptive processes, and high-level reasoning and memory processes. Our representation relates to work in connectionist models of rapid — reflexive — reasoning and also suggests solutions to several problems in language acquisition and understanding. This Technical Report is the final manuscript of an article completed in June 1999 that is to appear as a chapter in the boo...|$|R
40|$|Abstract. The REST {{architectural}} style {{is emerging as}} an alternative technology platform for the realization of service-oriented architectures. In this paper, we apply the notion of composition to RESTful services and derive a set of language features that are required by composition languages for RESTful services: <b>dynamic</b> late <b>binding,</b> <b>dynamic</b> typing, content-type negotiation, state inspection, and compliance with the uniform interface principle. To show how such requirements can be satisfied by an existing composition language, we include a case-study using the JOpera visual composition language. In it, we present {{how to build a}} composite application (DoodleMap) out of some well-known, public and currently existing RESTful service APIs. ...|$|R
