18|307|Public
5000|$|<b>Direct</b> <b>indexing</b> of SQL databases. Native {{support for}} MySQL, MariaDB, PostgreSQL, MSSQL, plus ODBC connectivity.|$|E
5000|$|<b>Direct</b> <b>indexing</b> plate: Most {{dividing}} heads have an {{indexing plate}} permanently {{attached to the}} spindle. This plate {{is located at the}} end of the spindle, very close to where the work would be mounted. It is fixed to the spindle and rotates with it. This plate is usually equipped with a series of holes that enables rapid indexing to common angles, such as 30, 45, or 90 degrees. A pin in the base of the dividing head can be extended into the <b>direct</b> <b>indexing</b> plate to lock the head quickly into one of these angles. [...] The advantage of the <b>direct</b> <b>indexing</b> plate is that it is fast and simple and no calculations are required to use it. The disadvantage is that it can only be used for a limited number of angles.|$|E
5000|$|... #Caption: A {{dividing}} head {{mounted on the}} table of a small milling machine. The <b>direct</b> <b>indexing</b> plate and center are visible facing the camera. An interchangeable indexing plate is visible on the left side.|$|E
3000|$|... [...])β∈Γbe a {{decreasing}} {{family of}} nonempty complete lattice subsets of X, where Γ is a <b>directed</b> <b>index</b> set. Then, ⋂β∈ΓX [...]...|$|R
50|$|Main and Solomon {{developed}} {{a set of}} thematic headings for {{the various forms of}} disorganized/disoriented behavior. Infant behaviors coded as disorganized/disoriented include sequential display of contradictory behavior patterns (Index I); simultaneous display of contradictory behavior patterns (II); undirected, misdirected, incomplete, and interrupted movements and expressions (III); stereotypies, asymmetrical movements, mistimed movements, and anomalous postures (IV); freezing, stilling, and slowed movements and expressions (V); <b>direct</b> <b>indices</b> of apprehension regarding the parent (VI); <b>direct</b> <b>indices</b> of disorganization or disorientation (VII).|$|R
40|$|A {{recurrent}} theme when measuring aggregate {{price and}} quantity change between {{more than two}} periods is the choice between the computation of <b>direct</b> or chained <b>index</b> numbers. Suppose we consider periods 0, 1, 2, …,T and wish to measure change relative to the base period 0. A <b>direct</b> <b>index</b> number comparing period t (t = 1,…,T) to period 0 is the result o...|$|R
5000|$|Interchangeable {{indexing}} {{plates are}} used {{when the work}} must be rotated to an angle not available on the <b>direct</b> <b>indexing</b> plate. Because the hand crank is fixed to the spindle at a known ratio (commonly 40:1) the dividing plates mounted at the handwheel {{can be used to}} create finer divisions for precise orientation at arbitrary angles. These dividing plates are provided in sets of several plates. Each plate has rings of holes with different divisions. For example, an indexing plate might have three rows of holes with 24, 30, and 36 holes in each row. A pin on the hand crank engages these holes. Index plates with up to 400 holes are available. [...] Only one such plate can be mounted to the dividing head at a time. The plate is selected by the machinist based on exactly what angle he wishes to index to.|$|E
5000|$|On Unix systems, UTF-32 strings are {{sometimes}} used for storage, {{due to the}} type wchar_t being defined as 32 bit. Python versions up to 3.2 can be compiled to use them instead of UTF-16; from version 3.3 onward, UTF-16 support is dropped, and a system is used whereby strings are stored in UTF-32 but with leading zero bytes optimized away [...] "depending on the character with the largest Unicode ordinal (1, 2, or 4 bytes)" [...] to make all characters that size. Seed7 and Lasso programming languages encode all characters and strings with UTF-32, {{in the belief that}} <b>direct</b> <b>indexing</b> is important, whereas Julia has native UTF-8, UTF-16 and UTF-32 encoding in the standard library, but simplified to UTF-8 only (with all other encodings considered legacy in accordance with the [...] "UTF-8 Everywhere Manifesto" [...] moved to packages and out of the standard library). Use of UTF-32 strings on Windows (where wchar_t is 16 bits) is almost non-existent.|$|E
50|$|The {{chip set}} {{consisted}} of the R2000 microprocessor, R2010 floating-point accelerator, and four R2020 write buffer chips. The core R2000 chip executed all non-floating-point instructions with a simple short pipeline. This chip also controlled the external code and data caches, made of fast standard SRAM chips organized with <b>direct</b> <b>indexing</b> and one-cycle read latency. The R2000 chip contained a small translation lookaside buffer for mapping virtual memory addresses. The R2010 chip held the floating point registers, floating point data paths, and their longer simple pipeline. Writes to main memory DRAM took tens of cycles to fully complete. But the R2020 chips queued and completed up to 4 pending writes to main memory, allowing the R2000 core to proceed without stalling itself. In the absence of cache misses, this chip set sustained an instruction completion rate of one instruction per ALU cycle. This was much faster than non-RISC microprocessors of that time which needed several cycles per instruction. 1986 also saw similar technology in Sun's first SPARC microprocessor and Hewlett Packard's first PA-RISC microprocessor.|$|E
40|$|Classical {{identification}} {{techniques are}} shown; {{their strengths and}} shortcomings are analyzed. The correlations associating <b>direct</b> <b>indexes</b> of transfer characteristic quality of the controlled object and its pole-zero configuration are received. The identification technique of the linear dynamic object based on correlations is developed. The numerical model is given...|$|R
50|$|The chiral hyper-octahedral symmetry, is the <b>direct</b> subgroup, <b>index</b> 2 of hyper-octahedral symmetry.|$|R
40|$|Abstract. An element-index is {{a crucial}} {{mechanism}} for supporting content-only (CO) queries over XML collections. A full element-index that indexes each element along with the content of its descendants involves a high redundancy and reduces query processing efficiency. A <b>direct</b> <b>index,</b> on the other hand, only indexes the content that is directly under each element and disregards the descendants. This results in a smaller index, but possibly in return to some reduction in system effectiveness. In this paper, we propose using static index pruning techniques for obtaining more compact index files that can still result in comparable retrieval performance {{to that of a}} full index. We also compare the retrieval performance of these pruning based approaches to some other strategies that make use of a direct element-index. Our experiments conducted along with the lines of INEX evaluation framework reveal that pruned index files yield comparable to or even better retrieval performance than the full <b>index</b> and <b>direct</b> <b>index,</b> for several tasks in the ad hoc track. ...|$|R
40|$|We present ChronoViz, {{a system}} to aid annotation, visualization, navigation, and {{analysis}} of multimodal time-coded data. Exploiting interactive paper technology, ChronoViz also integrates researcher's paper notes into the composite data set. Researchers can navigate data in multiple ways, taking advantage of synchronized visualizations and annotations. The goal is to decrease {{the time and effort}} required to analyze multimodal data by providing <b>direct</b> <b>indexing</b> and flexible mechanisms to control data exploration...|$|E
40|$|This {{document}} presents HiPS, {{a hierarchical}} scheme for the description, storage and access of sky survey data. The system {{is based on}} hierarchical tiling of sky regions at finer and finer spatial resolution which facilitates a progressive view of a survey, and supports multi-resolution zooming and panning. HiPS uses the HEALPix tessellation of the sky {{as the basis for}} the scheme and is implemented as a simple file structure with a <b>direct</b> <b>indexing</b> scheme that leads to practical implementations. Peer reviewed: NoNRC publication: Ye...|$|E
40|$|Autonomous {{concurrent}} objects can {{be regarded}} as message receivers rather than labeled records by mes-sage senders, each having object references. The sub-type relation on reference types can be determined by judging how various messages can be understood. Based on this idea, this paper presents a type system and compilation techniques for concurrent objects, implementing efficient pattern matching of first class messages, where the look-up can be performed as <b>direct</b> <b>indexing</b> of a small table, and the table size can be bounded by a number slightly more than the number of injection tags which the message value may have. ...|$|E
40|$|The aim of {{this paper}} is to {{construct}} and examine three candidates for local-to-global spectral sequences for the cohomology of diagrams of algebras with <b>directed</b> <b>indexing.</b> In each case, the $E^ 2 $ -terms can be viewed as a type of local cohomology relative to a map or an object in the diagram. Comment: 27 pages; incorporated corrections based on referee's report and added a few reference...|$|R
5000|$|These {{arbitrary}} values {{can thus}} be designed with efficiency in mind - by selecting values {{that can be used}} as <b>direct</b> <b>indexes</b> to data or function pointers. For particular platforms/language, they can be specifically designed to minimize instruction path lengths using branch table values or even, in some cases such as in JIT compilers, consist of directly executable machine code [...] "snippets" [...] (or pointers to them).|$|R
5000|$|The <b>direct</b> subgroup, <b>index</b> 2, is Cn, n+, (nn), order n, as the rotoreflection {{generator}} applied twice.|$|R
40|$|We {{present the}} Discriminative Ferns Ensemble (DFE) {{classifier}} for efficient visual object recognition. The clas-sifier architecture {{is designed to}} optimize both classifica-tion speed and accuracy when a large training set is avail-able. Speed is obtained using simple binary features and <b>direct</b> <b>indexing</b> into a set of tables, and accuracy by using a large capacity model and careful discriminative optimiza-tion. The proposed framework {{is applied to the}} problem of hand pose recognition in depth and infra-red images, using a very large training set. Both the accuracy and the classi-fication time obtained are considerably superior to relevant competing methods, allowing one to reach accuracy targets with run times orders of magnitude faster than the compe-tition. We show empirically that using DFE, we can sig-nificantly reduce classification time by increasing training sample size for a fixed target accuracy. Finally a DFE re-sult is shown for the MNIST dataset, showing the method’s merit extends beyond depth images. 1...|$|E
40|$|Object {{recognition}} {{starts from}} {{a set of}} image measurements (including locations of points, lines, surfaces, color, and shading), which provides access into a database where representations of objects are stored. We describe a complexity theory of indexing, a meta-analysis which identifies the best set of measurements (up to algebraic transformations) such that: (1) the representation of objects are linear subspaces and thus easy to learn; (2) <b>direct</b> <b>indexing</b> is efficient since the linear subspaces are of minimal rank. Index complexity is determined via a simple process, equivalent to computing the rank of a matrix. We readily rederive the index complexity of the few previously analyzed cases. We then compute the best index for new and more interesting cases: 6 points in one perspective image, 6 directions in one para-perspective image, and 2 perspective images of 7 points. With color we get the following result: 4 color sensors are sufficient for color constancy at a point, and the sen [...] ...|$|E
40|$|Polymorphic record calculi have {{recently}} {{attracted much attention}} as a typed foundation for objectoriented programming. This {{is based on the}} fact that a function that selects a eld l of a record can be given a polymorphic type that enables it to be applied to various records containing a eld l. Recent studies have established techniques to develop an ML-style type inference algorithm for such a polymorphic type system. There seems to be, however, no established method to compile an ML-style polymorphic record calculus into ecient code. The purpose of this paper is to present one such method. We dene a polymorphic record calculus as an extension of Damas and Milner's proof system for ML. For this calculus, we dene an implementation calculus where records are represented as arrays of (references to) values and eld selection is performed by <b>direct</b> <b>indexing.</b> To represent polymorphic eld selection, the implementation calculus contains an abstraction mechanism over indexes. We then deve [...] ...|$|E
40|$|An element-index is {{a crucial}} {{mechanism}} for supporting content-only (CO) queries over XML collections. A full element-index that indexes each element along with the content of its descendants involves a high redundancy and reduces query processing efficiency. A <b>direct</b> <b>index,</b> on the other hand, only indexes the content that is directly under each element and disregards the descendants. This results in a smaller index, but possibly in return to some reduction in system effectiveness. In this paper, we propose using static index pruning techniques for obtaining more compact index files that can still result in comparable retrieval performance {{to that of a}} full index. We also compare the retrieval performance of these pruning based approaches to some other strategies that make use of a direct element-index. Our experiments conducted along with the lines of INEX evaluation framework reveal that pruned index files yield comparable to or even better retrieval performance than the full <b>index</b> and <b>direct</b> <b>index,</b> for several tasks in the ad hoc track. © 2010 Springer-Verlag Berlin Heidelberg...|$|R
40|$|The {{problem of}} {{determining}} an objective means for assessing local characteristics of television subpictures in a Hadamard transform multicoder scheme is stated and discussed. Detailed investigations of transform domain coefficient statistical characteristics for different test images have been conducted. Both monochrome and colour signals were used, {{as well as}} different transform sizes and shapes. " <b>Directing</b> <b>Indexes</b> " are proposed which, depending on the inter-relationships among transform coefficients and groups of coefficients, direct each subpicture to the appropriate coder. Three indexes {{in the case of}} monochrome signals are proposed, each with its own computational procedures and application requirements. Necessary modifications and changes for application of some indexes on colour signals are also discussed. The proposed technique of indexing eliminates the necessity of equal distribution of subpictures among 'activity classes', a major disadvantage encountered in present activity index. Coders to be used with each <b>directing</b> <b>index</b> are devised and tested, subject to an arbitrary bit rate of 2 bits per pixel, with satisfactory performance compared with some published results for other techniques...|$|R
5000|$|Partitioned Hierarchical <b>Indexed</b> <b>Direct</b> Access Method (PHIDAM), ...|$|R
40|$|In {{this article}} we propose {{parallel}} algorithms {{for the construction of}} conforming finite-element discretization on linear octrees. Existing octree-based discretizations scale to billions of elements, but the complexity constants can be high. In our approach we use several techniques to minimize overhead: a novel bottom-up tree-construction and 2 : 1 balance constraint enforcement; a Golomb-Rice encoding for compression by representing the octree and element connectivity as an Uniquely Decodable Code (UDC); overlapping communication and computation; and byte alignment for cache efficiency. The cost of applying the Laplacian is comparable to that of applying it using a <b>direct</b> <b>indexing</b> regular grid discretization with the same number of elements. Our algorithm has scaled up to four billion octants on 4096 processors on a Cray XT 3 at the Pittsburgh Supercomputing Center. The overall tree construction time is under a minute in contrast to previous implementations that required several minutes; the evaluation of the discretization of a variable-coefficient Laplacian takes only a few seconds. ...|$|E
40|$|Large {{instruction}} {{windows and}} issue queues {{are key to}} exploiting greater instruction level parallelism in out-of-order superscalar processors. However, the cycle time and energy consumption of conventional large monolithic issue queues are high. Previous efforts to reduce cycle time segment the issue queue and pipeline wakeup. Unfortunately, this results in significant IPC loss. Other proposals which address energy efficiency issues by avoiding only the unnecessary tagcomparisons do not reduce broadcasts. These schemes also increase the issue latency. To address both these issues comprehensively, we propose the Scalable Lowpower Issue Queue (SLIQ). SLIQ augments a pipelined issue queue with <b>direct</b> <b>indexing</b> to mitigate the problem of delayed wakeups while reducing the cycle time. Also, the SLIQ design naturally leads to significant energy savings by reducing both the number of tag broadcasts and comparisons required. A 2 segment SLIQ incurs an average IPC loss of 0. 2 % over the entire SPEC CPU 2000 suite, while achieving a 25. 2 % reduction in issue latency when compared to a monolithic 128 -entry issue queue for an 8 -wide superscalar processor. An 8 segment SLIQ improves scalability by reducing the issue latency by 38. 3 % while incurring an IPC loss of only 2. 3 %. Further, the 8 segment SLIQ significantly reduces the energy consumption and energy-delay product by 48. 3 % and 67. 4 % respectively on average...|$|E
40|$|Workloads present diverse {{performance}} challenges. Consequently, many proposed microarchitecture techniques {{apply to}} only a subset of applications. This limits their appeal, as the added resources tend to be unused by the remaining applications. Designing reconfigurable hardware {{is one way to}} tackle this issue. In this paper, we propose EXACT-S, a software-managed reconfigurable branch predictor that targets workloads with hard-to-predict load-dependent branches encountered in the context of sequencing arrays and linked-lists. EXACT-S is inspired by the previous EXACT predictor and targets its limitations. EXACT is indexed by branches ’ load addresses and actively updated by stores. With EXACT-S, the idea is to have a light-weight run-time layer to convey key information directly to the fetch unit that it can use to generate branches ’ load addresses in a timely manner. This approach is more accurate because it uses branches ’ load addresses directly rather than prior branches ’ load addresses. Moreover, with regard to active updates, {{there is no need for}} a large table to convert store addresses to predictor indices because of the <b>direct</b> <b>indexing</b> strategy. As a result, EXACT-S is simpler, less expensive and more accurate than EXACT. For applications that suffer poor prediction accuracies due to load-dependent branches, EXACT-S removes up to 50 % of their mispredictions. For all other applications, the proposed reconfigurable predictor relinquishes EXACT-S storage to the base L-TAGE predictor, thus achieving the same prediction accuracy as a similarly-sized fixed L-TAGE predictor. 1...|$|E
40|$|Abstract- The price {{factor is}} a <b>direct</b> <b>index</b> of {{profitability}} for any process which produced the items the cost adjustment is a mathematical technique which when implemented gives a better return an investment by keeping extra cost away from main process costing the mathematical method {{used in this}} paper is a system of equation relating fixed parameters of structural expenditure like machinery, transport, raw storage material extras with the main variable parameters like raw material such as natural gas produced from fertilizer. Index Terms- Cost adjustment, prices index variable, cost parameter, fixed cost parameter, profitability index, and modified system. I...|$|R
40|$|Although inverse limits with factor spaces indexed by the {{positive}} integers are most commonly studied, Ingram and Mahavier have defined inverse limits with set-valued functions broadly enough for any <b>directed</b> <b>index</b> {{set to be}} used. In this paper, we investigate generalized inverse limits whose factor spaces are indexed by totally ordered sets. Using information about the projections of such inverse limits onto finitely many coordinates, we generalize various well-known theorems on connectedness in inverse limits. Moreover, numerous theorems and examples are given addressing the special case of an inverse limit with a single idempotent surjective u. s. c. bonding function. Comment: (Preprint...|$|R
50|$|In 2010 {{and though}} {{currently}} out of production, the Warranty <b>direct's</b> Reliability <b>index</b> marks that the SEAT Toledo still ranks within {{the list of}} the UK's 100 most reliable cars of the last decade.|$|R
40|$|The {{motivation}} {{of this work}} {{is to provide a}} type-theoretical basis for developing a practical polymorphic programming language with labeled records and labeled variants. Our goal is to establish both a polymorphic type discipline and an efficient compilation method for a calculus with those labeled data structures. We define a second-order, polymorphic record calculus as an extension of Girard-Reynolds polymorphic lambda calculus. We then develop an ML-style type inference algorithm for a predicative subset of the second-order record calculus. The soundness of the type system and the completeness of the type inference algorithm are shown. These results extend Milner’s type inference algorithm, Damas and Milner’s account of ML’s let polymorphism, and Harper and Mitchell’s analysis on XML. To establish an efficient compilation method for the polymorphic record calculus, we first define an implementation calculus, where records are represented as vectors whose elements are accessed by <b>direct</b> <b>indexing,</b> and variants are represented as values tagged with a natural number indicating the position in the vector of functions in a switch statement. We then develop an algorithm to translate the polymorphic record calculus into the implementation calculus using type information obtained by the type inference algorithm. The correctness of the compilation algorithm is proved; that is, the compilation algorithm is shown to preserve both typing and the operational behavior of a program. Based on these results, Standard ML has been extended with labeled records, and its compiler has been implemented...|$|E
40|$|Longest prefix {{matching}} {{is frequently}} used for IP forwarding in the Internet. Data structures used must {{be not only}} efficient, but also robust against pathological entries caused by an adversary or misconfiguration. In this paper, we attack the longest prefix matching problem by presenting a new algorithm supporting high lookup performance, fast incremental updates and guaranteed compression ratio. High lookup performance is achieved by using only four memory accesses. Guaranteed compression ratio is achieved by combining <b>direct</b> <b>indexing</b> with an implicit tree structure and carefully choosing which construct to use when updating the forwarding table. Fast incremental updates are achieved by a new memory management technique featuring fast variable size allocation and deallocation while maintaining zero fragmentation. An IPv 4 forwarding table data structure can be implemented in software or hardware within 2. 7 Mb of memory to represent 2 18 routing entries. Incremental updates require only 752 memory accesses in worst case for the current guaranteed compression ratio. For a hardware implementation, we can use 300 MHz SRAM organized in four memory banks and four pipeline stages to achieve a guaranteed performance of 300 million lookups per second, corresponding to ∼ 100 Gbit/s wire speed forwarding, and 400, 000 incremental updates per second. In measurements performed on a 3. 0 Ghz Pentium 4 machine using a routing table with more than 2 17 entries, we can forward over 27 million IPv 4 packets per second, which is equivalent to wire speeds exceeding 10 Gbit/s. On the same machine and with the same routing table, we can perform over 230, 000 incremental updates/second...|$|E
40|$|A Large {{instruction}} {{window is}} a key requirement to exploit greater Instruction Level Parallelism in out-of-order superscalar processors. Along with the instruction window size, the size of various other structures including the issue queue, store queue and register file need to increase as well. However, the cycle time and energy consumption of conventional large monolithic Content Addressable Memories (CAMs), the underlying structure of most conventional issue queue and store queue designs, worsen rapidly {{with an increase in}} size. This results in a three way trade-off involving ILP, clock frequency and energy consumption. In this thesis, we propose efficient designs for the issue queue and the store queue that improve the circuit latency and energy consumption while minimizing the loss in IPC. We propose the Scalable Low power Issue Queue (SLIQ) design which segments the issue queue structure to reduce the latency. This is complemented with a fast Wakeup index to a consumer in the issue queue for every instruction. As this consumer instruction can be woken up directly, without any delay, this mitigates the IPC loss faced by the pipelined issue queue. Also, as the scheme incorporates a pipelined broadcast, the indices are not required for correctness and can simply be gang invalidated on branch mispredictions. The IPC loss of an 8 segment SLIQ is Within 2. 3 % for the entire SPEC CPU 2000 benchmark suite while achieving a 39. 3 % reduction in issue latency. Further, in the SLIQ design unnecessary broadcasts to the higher segments are avoided most of the time as in a large majority of the cases, an instruction has a single consumer. This consumer is woken up either by <b>direct</b> <b>indexing</b> or by broadcast in the first segment of the SLIQ. This enables the 8 segment SLIQ to significantly reduce the energy consumption and the energy-delay product by 48. 3 % and 67. 4 % respectively on an average. SLIQ also allows the architects to segment the issue queue carefully so that the latency of the issue logic is just within the per pipeline stage latency goals of the design. We also propose the Scalable Low power Store Queue (SLSQ) to address similar problems associated with the store queue data forwarding logic. We extend the state- of-the-art Store Vector based Disambiguator to also predict the index of the store that will forward to a given load. SLSQ marginally adds to the hardware budget, but predicts the store queue index of the store which will forward with an accuracy of 99. 5 % on an average. SLSQ, thus, eliminates unnecessary address broadcasts and Compares and reduces energy consumption of the store-to-load forwarding logic by 78. 4 % and 91. 6 % for the SPEC Int and FP suites respectively. Another variant of SLSQ, eliminates the need for a CAM in the forwarding logic and achieves a 49. 9 % reduction in store to load data forwarding latency while incurring a minimal IPC loss less than 0. 1 % on average for the entire SPEC CPU 2000 benchmark suite...|$|E
40|$|We use Google {{search query}} data {{to develop a}} novel and <b>direct</b> <b>index</b> of {{investor}} distress in the housing market. This measure is highly correlated with negative housing sentiment. We find that our Housing Distress Index (HDI) is contemporaneously related to and predicts national housing returns, the VIX index, foreclosures, and returns on ABX subprime mortgage credit default swaps. The Housing Distress Index also predicts housing returns among a cross-section of cities. Results further indicate {{that the relationship between}} the HDI and national housing returns is asymmetric and stronger during times of market crisis. Overall, the relationship between the HDI and housing returns resembles that between the VIX and stock returns. JEL Classification: G 02, R 30, G 12...|$|R
40|$|Abstract. The aim of {{this paper}} is to {{construct}} and examine three candidates for local-to-global spectral sequences for the cohomology of diagrams of algebras with <b>directed</b> <b>indexing.</b> In each case, the E 2 -terms can be viewed as a type of local cohomology relative to a map or an object in the diagram. The cohomology of diagrams arises as a natural object of study in several mathematical contexts: in deformation theory (see [GS 2, GS 1, GGS]), and in classifying diagrams of groups, as in [C]. If I is the one-object category corresponding to a group G, a diagram X ∈ CI is just an object in C equipped with a G-action, and it...|$|R
40|$|Abstract—We analyze a {{generalized}} index coding problem that allows multiple users to request the same packet. For this problem we introduce a novel coding scheme called partition multicast. Our scheme {{can be seen}} as a natural generalization of clique cover for <b>directed</b> <b>index</b> coding problems. Further, partition multicast corresponds to an achievable scheme for the generalized bipartite index coding problem that we introduce in this paper. Our scheme partitions the nodes into groups and solves a multicasting problem within each group. We show that Partition Multicast is optimal for a few families of graphs and generalizes previous achievable schemes, namely directed cycle covers. We also show that finding the best partition is computationally intractable to compute in general. I...|$|R
