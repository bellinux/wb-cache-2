38|71|Public
5000|$|... ~ (tilde) for SOFTFAIL, a <b>debugging</b> <b>aid</b> between NEUTRAL and FAIL. Typically, {{messages}} that return a SOFTFAIL are accepted but tagged.|$|E
50|$|The global vector {{also made}} it very simple to replace or augment {{standard}} library routines. A program could save the pointer from the global vector to the original routine {{and replace it with}} a pointer to an alternative version. The alternative might call the original as part of its processing. This could be used as a quick ad hoc <b>debugging</b> <b>aid.</b>|$|E
50|$|VS/9 {{included}} the Interactive <b>Debugging</b> <b>Aid</b> (IDA) which provided commands to view memory and registers, trap program errors, and store memory in locations. Unlike other systems where an interactive debugger required either {{you run a}} program to use it or link a module into a program, IDA {{was a part of}} the operating system and its commands were available from break mode.|$|E
50|$|Core dumps {{can serve}} as useful <b>debugging</b> <b>aids</b> in several situations. On early {{standalone}} or batch-processing systems, core dumps allowed a user to debug a program without monopolizing the (very expensive) computing facility for debugging; a printout could also be more convenient than debugging using switches and lights.|$|R
40|$|This is a {{reference}} document {{to be used}} in the process of getting HAL/S programs compiled and debugged on the IBM 360 computer. Topics from the operating system communication to interpretation of <b>debugging</b> <b>aids</b> are discussed. Features of HAL programming system that have specific system/ 360 dependencies are presented...|$|R
50|$|Seamless3d {{has its own}} {{built in}} script {{compiler}} which compiles SeamlessScript (a very fast light weight scripting language) into native machine code.SeamlessScript is designed to look and feel a lot like JavaScript while {{being able to be}} compiled by a standard C++ compiler. This allows the user to develop complex animation sequences using a C++ IDE which gives the user access to professional <b>debugging</b> <b>aids</b> such as single step execution.|$|R
50|$|The most-significant three {{bits of the}} {{accumulator}} {{were converted}} from digital to analog and connected to a tube audio amplifier contained in the console. This facility {{could be used to}} program audio alerts for the computer operator, or to generate music. Those familiar with {{the inner workings of the}} software could often hear what parts of a task were being performed by the CDC 1604; as a <b>debugging</b> <b>aid,</b> for example, a never-ending repetitive musical phrase indicated the program was stuck in a loop.|$|E
5000|$|Another use of [...] in {{software}} development is as a <b>debugging</b> <b>aid</b> {{in conjunction with}} a machine language monitor. By overwriting an opcode with [...] (...) and directing the [...] hardware vector to the entry point of the monitor, one can cause a program to halt at any desired point, allowing the monitor to take control. At that time, one may examine memory, view the processor's register values, patch code, etc. Debugging, as advocated by Kuckes and Thompson, can be facilitated by liberally sprinkling one's code with [...] instructions (opcode [...] ) that can be replaced by [...] instructions without altering the actual behaviour of the program being debugged.|$|E
50|$|Software tracing is a {{specialized}} use of logging to record {{information about a}} program's execution. This information is commonly used for debugging. In contrast to event logging, {{the primary purpose of}} which is to produce records of events that can be audited by system administrators (see for example Event Viewer) or analyzed by management tools, software tracing is primarily a <b>debugging</b> <b>aid</b> for software developers. As such, many of the non-functional requirements of event logging, such as localizability or a standards-based output format, are explicitly non-goals for most applications of software tracing. On the other hand, software tracing has special requirements for performance that are not generally as important in event logging. For example, one common use of software tracing, in/out tracing, produces output at the entry point and return of functions or methods so that a developer can visually follow the execution path, often including parameters and return values, in a debugger or text-based log file (this {{can be seen as a}} run-time analog of a sequence diagram). This type of tracing, although useful for developers, can greatly hurt performance of a software product if it cannot be disabled (either at compile-time via conditional compilation, or at run-time via flags).|$|E
50|$|Early {{operating}} systems were very diverse, with each vendor or customer producing {{one or more}} {{operating systems}} specific to their particular mainframe computer. Every operating system, even from the same vendor, could have radically different models of commands, operating procedures, and such facilities as <b>debugging</b> <b>aids.</b> Typically, each time the manufacturer brought out a new machine, {{there would be a}} new operating system, and most applications would have to be manually adjusted, recompiled, and retested.|$|R
40|$|This paper {{describes}} a recently-found paper tape of an undebugged program {{written for the}} EDSAC computer in 1949. It is believed that this program is the first real, 'non-trivial' application ever written for a stored-program computer. An examination of the program sheds {{new light on the}} extent to which the debugging problem was unanticipated by early computer programmers, and the motivation for the development of systematic programming practices and <b>debugging</b> <b>aids.</b> the impact of these early developments on programming elsewhere is discussed...|$|R
40|$|The C Language Integrated Production System (CLIPS) is {{a forward}} {{chaining}} rule-based language. The requirements necessary for an expert system tool {{which is used}} for development, delivery, and training are examined. Because of its high portability, low cost, and ease of integration with external systems, CLIPS has great potential as an expert system tool for delivery and training. In addition, its representation flexibility, <b>debugging</b> <b>aids,</b> and performance, along with its other strengths, make it a viable alternative for expert system development...|$|R
40|$|Keyword {{directed}} {{free format}} input routine, {{which has been}} used in large neutronics codes, is described. The routine also sets up variable dimension addresses for use with side entry calls. In addition, as a program <b>debugging</b> <b>aid,</b> a labelled printer dump facility is provided. The suite of routines has been used on IBM 360 computers...|$|E
40|$|IO TEST is {{intended}} as a hardware testing and <b>debugging</b> <b>aid</b> for use with the PDP- 6 and its associated input multiplexer (analog to digital converter) and output multiplexer (digital to analog converter). While all characters typed are echoed, only the following {{have any effect on}} the program' S operations: F, Y, W, V, B, E, D, S, nT, P A...|$|E
40|$|SERVO is {{intended}} as an engineering and programming analyzing and <b>debugging</b> <b>aid</b> {{for use with}} devices connected through the input and output multiplexers to the PDP- 6. Cannel numbers and values to output, {{as well as some}} other numeric arguments, are in octal. Only the frequency of K, N, Q & W, the duration of I & U, and the argument of Z are decimal. Commands are single letters, as follows...|$|E
40|$|This article {{describes}} {{the discovery of a}} paper-tape "relic" consisting of an undebugged program written for the EDSAC computer in 1949. It is believed that this program is the first real, nontrivial application ever written for a stored-program computer. An examination of the program sheds new light {{on the extent to which}} the debugging problem was unanticipated by early computer programmers, and the motivation for the development at Cambridge of systematic programming practices and <b>debugging</b> <b>aids.</b> The impact of these early developments on programming elsewhere is discussed. ...|$|R
40|$|The notion ” {{of program}} {{correctness}} {{with respect to}} an irrterpreta~ion is defined for a class of programming languages. Under this definition, 1 ~ a program!erminates with an incorrect output then it contains an incorrect procedure. Algorithms for detecting incorrect procedures are developed. These algori~hmsformalize what experienced rogrammers may kno w already. A Iogicprogram implementation of these algorithms is described. Itsperformance suggests that thea[gorithms can be ~he backbone of <b>debugging</b> <b>aids</b> that go far beyond what is offered by current programming environments. Applications of algorithmic debugging to automatic program conso-uc~ion are explored. 1...|$|R
25|$|In {{addition}} to the native computer software, there are online JavaScript IDEs, <b>debugging</b> <b>aids</b> that are themselves written in JavaScript and built to run on the Web. An example is the program JSLint, developed by Douglas Crockford {{who has written extensively}} on the language. JSLint scans JavaScript code for conformance to a set of standards and guidelines. Many libraries for JavaScript, such as three.js, provide links to demonstration code that can be edited by users. They are also used as a pedagogical tool by institutions such as Khan Academy to allow students to experience writing code in an environment where they can see the output of their programs, without needing any setup beyond a Web browser.|$|R
40|$|Identifying {{the root}} causes of {{failures}} {{is one of the most}} time-consuming and tedious components of program debugging. Many automated approaches have been proposed to facilitate program debugging. Relative debugging is one of them. In relative debugging, a faulty program is debugged by comparing it to a reference implementation, which is assumed to be correct. Both programs are executed in parallel. The executions are interrupted at certain points during executions. The states of the programs at the point of interruption are then compared and the differences (if any) are visualized as a <b>debugging</b> <b>aid.</b> One downside of existing relative debugging approaches is that they only compare program states, without taking the history of events causing those states into account. In this work we present an event-based relative debugging approach. In this approach, we infer finite state machine models from sequences of events occurring in executions, compute the structural differences between these models, and report them as a <b>debugging</b> <b>aid.</b> A case study conducted at a small-scale shows promise...|$|E
40|$|Program-development time {{decreased}} while program quality increased. FORTRAN Programming Tools are {{series of}} programming tools {{used to support}} development and maintenance of FORTRAN 77 source codes. Included are <b>debugging</b> <b>aid,</b> central-processing-unit time-monitoring program, source-code maintenance aids, print utilities, and library of useful, well-documented programs. Tools assist in reducing development time and encouraging high-quality programming. Although intended primarily for FORTRAN programmers, some tools used on data files and other programming languages. Written in FORTRAN 77...|$|E
40|$|In {{this paper}} we {{translate}} concurrent C/C++ code into PDDL. The system then runs heuristic search planners against the PDDL outcome to generate traces for locating programming bugs. These counter-examples {{result in an}} interactive <b>debugging</b> <b>aid</b> and exploit efficient planner in-built heuristics. Different aspects like parsing, generation of the dependency graph, slicing, abstraction, and property conversion are described. For data abstraction we provide a library, and for increased usability the tool has been integrated in Eclipse...|$|E
40|$|Automated {{localization}} {{of software}} bugs {{is one of}} the essential issues in <b>debugging</b> <b>aids.</b> Previous studies indicated that the evaluation history of program predicates may disclose important clues about underlying bugs. In this paper, we propose a new statistical model-based approach, called SOBER, which localizes software bugs without any prior knowledge of program semantics. Unlike existing statistical debugging approaches that select predicates correlated with program failures, SOBER models evaluation patterns of predicates in both correct and incorrect runs respectively and regards a predicate as bug-relevant if its evaluation pattern in incorrect runs differs significantly from that in correct ones. SOBER features a principled quantification of the pattern difference that measures the bug-relevance of program predicates...|$|R
40|$|Refci is an {{extensible}} re ective language {{based on}} the reflective tower model. The Refci interpreter procedures are reifiable, first-class objects, and user programs can directly modify the interpreter by extending them. This allows user code to be run directly as part of, and at the level of, the interpreter. By installing a modified or extended interpreter, user programs can modularly extend the language and implement <b>debugging</b> <b>aids.</b> We present the extensible first-class interpreter and give examples of its use. Examples include stepping, breakpoints, and interrupts. We show how the re ective tower, modeled by the metacontinuation, maintains the proper level of interpretation when running an interpreter containing both system code and user code...|$|R
50|$|In {{addition}} to the native computer software, there are online JavaScript IDEs, <b>debugging</b> <b>aids</b> that are themselves written in JavaScript and built to run on the Web. An example is the program JSLint, developed by Douglas Crockford {{who has written extensively}} on the language. JSLint scans JavaScript code for conformance to a set of standards and guidelines. Many libraries for JavaScript, such as three.js, provide links to demonstration code that can be edited by users. They are also used as a pedagogical tool by institutions such as Khan Academy to allow students to experience writing code in an environment where they can see the output of their programs, without needing any setup beyond a Web browser.|$|R
40|$|The authors {{consider}} {{the problem of}} providing hardware support {{for the development of}} real-time software {{in the context of a}} specific computer architecture, the Selenia MARA family of multi-microprocessor systems, under the constraint that no modifications to existing MARA hardware be involved. The specification of a programmable <b>debugging</b> <b>aid</b> (PDA), that can support program performance evaluation as well as program debugging and testing is described. The PDA hardware has been fully designed, and is being implemented as a research prototype...|$|E
40|$|This paper proposes an {{interactive}} <b>debugging</b> <b>aid</b> that exhibits a {{deep understanding of}} a narrow class of bugs. This system, called Sniffer, {{will be able to}} find and identify errors, and explain them in terms which are relevant to the programmer. Sniffer is knowledgeable about side-effects. It is capable of citing the data which was in effect at the time an error became manifest. The debugging knowledge in Sniffer is organized as a collection of independent experts which know about particular errors. The experts (sniffers) perform their function by applying a feature recognition process to the text for the program, and to the events which took place during the execution of the code. No deductive machinery is involved. The experts are supported by two systems; the cliche finder which identifies small portions of algorithms from a plan for the code, and the time rover which provides complete access to all program states that ever existed. Sniffer is embedded in a run-time <b>debugging</b> <b>aid.</b> The user of the system interacts with the debugger to focus attention onto a manageable subset of the code, and then submits a complaint to the sniffer system that describes the behavior which was desired. Sniffer outputs a detailed report about any error which is discovered. MIT Artificial Intelligence Laborator...|$|E
40|$|A {{description}} is given {{of the design}} and implementation of a Pascal program for the stepwise visible execution of other Pascal programs. This system operates at the source code level by inserting additional statements into the user program. This additional code causes the stepwise execution of the user program, {{as well as the}} display of the statement currently executed together with variables whose values have just changed. This system is intended as both a teaching aid and a <b>debugging</b> <b>aid.</b> It enables the user to investigate the dynamic properties of his progra...|$|E
40|$|When we {{encounter}} a defect {{in one part}} of a program, {{it is very important to}} find other parts of the program that may contain similar defects. In this paper, we propose a novel system to find similar defects in the large collection of source code. This system takes a code fragment containing a defect as the query input, and returns code fragments containing the same or synonymous identifiers which appear in the input fragment. Case studies with two open source systems and their defect data show the advantages of the proposed retrieval system, compared to the code-clone based retrievals. Categories and Subject Descriptors D. 2. 5 [Software Engineering]: Testing and Debugging— <b>Debugging</b> <b>aids</b> and diagnostics; D. 2. 4 [Software Engineering]...|$|R
40|$|Abstract—Given some test case, {{a program}} fails. Which {{circumstances}} of the test case {{are responsible for the}} particular failure? The Delta Debugging algorithm generalizes and simplifies the failing test case to a minimal test case that still produces the failure. It also isolates the difference between a passing and a failing test case. In a case study, the Mozilla web browser crashed after 95 user actions. Our prototype implementation automatically simplified the input to three relevant user actions. Likewise, it simplified 896 lines of HTML to the single line that caused the failure. The case study required 139 automated test runs or 35 minutes on a 500 MHz PC. Index Terms—Automated <b>debugging,</b> <b>debugging</b> <b>aids,</b> testing tools, combinatorial testing, diagnostics, tracing. æ...|$|R
40|$|Abstract—We {{describe}} {{a method to}} use the source code change history of a software project to drive and help to refine the search for bugs. Based on the data retrieved from the source code repository, we implement a static source code checker that searches for a commonly fixed bug and uses information automatically mined from the source code repository to refine its results. By applying our tool, we have identified a total of 178 warnings that are likely bugs in the Apache Web server source code {{and a total of}} 546 warnings that are likely bugs in Wine, an open-source implementation of the Windows API. We show that our technique is more effective than the same static analysis that does not use historical data from the source code repository. Index Terms—Testing tools, version control, configuration control, <b>debugging</b> <b>aids.</b> ...|$|R
40|$|Substitution: string with (I {{characters}} The {{potential of}} using color {{as a program}} <b>debugging</b> <b>aid</b> was investigated in this research. The study assessed program debugging performance of eighteen subjects in three different color coding conditions: black and white, color-grouping that arranged loops and nested structures in five shades of green, and color-flagging that highlighted potential error areas in orange. Completion time, accuracy, and types of error detected, subjective preferences, and rate of visual comfort for each condition was recorded. This research suggested that color coding substantially improved error detections in C programms...|$|E
30|$|Each column J to T in Figure  7 {{is fired}} in {{sequence}} {{from left to}} right and calls a Java method in row 8 that sends data at the cell intersected by the triggered row and currently processing column to the Java program calling Drools. The action in column S is a dummy text used only to initiate an activity in the Java program, in this case the calculation and storage of a cost item using the data returned by the preceding cells. The action in column T is used as a <b>debugging</b> <b>aid</b> during development.|$|E
40|$|Abstract. After {{over thirty}} years of {{distributed}} computing, debugging distributed applications is still regarded as a difficult task. While {{it could be argued}} that this condition stems from the complexity of distributed executions, the fast pace of evolution witnessed with distributed computing technologies has also played its role by shortening the life-span of many useful debugging tools. In this paper we present an extensible Eclipse-based tool which brings distributed threads and symbolic debuggers together, resulting in a simple and useful <b>debugging</b> <b>aid.</b> This extensible tool is based on a technique that is supported by elements that are common to synchronous-call middleware implementations, making it a suitable candidate for surviving technology evolution. ...|$|E
40|$|A program fails. Under which {{circumstances}} {{does this}} failure occur? One single algorithm, the delta debugging algorithm, suffices to determine these failure-inducing circumstances. Delta debugging tests a program systematically and automatically to isolate failure-inducing circumstances {{such as the}} program input, changes to the program code, or executed statements. Keywords: Testing and <b>debugging,</b> <b>debugging</b> <b>aids,</b> combinatorial testing, execution tracing 1 Debugging by Testing Debugging falls into three phases: reproducing a failure, finding {{the root cause of}} the failure, and correcting the error such that the failure no longer occurs. While failure reproduction and correction are important issues, it is the second phase, finding the root cause, which is the most significant. Early studies have shown that finding the root cause accounts for 95 % of the whole debugging effort [6]. The common definition of a cause is some preceding event without which the effect would not have occurred [...] . ...|$|R
40|$|Debugging nondeterministic {{parallel}} {{programs is}} a difficult and tedious task. We report about a project, which investigate the use of program specifications, which can serve as enhanced <b>debugging</b> <b>aids</b> in existing parallel debugging tools. For parallel programs, an adequate framework for specifying program specification is provided by temporal logic, which allows to describe the dynamic behavior of a parallel program. We developed a checker, called T(emporal) L(ogic) C(hecker) Engine, which is able to check temporal logic formulae for each state of a parallel program along one possible execution. The checker communicates with a debugger, which executes a nondeterministic parallel program. For this we use a well-defined protocol. We extended two parallel debugger such that they use this protocol. This project thus applies the idea of model checking temporal logic specifications {{to the area of}} parallel and distributed debugging, something that has to our knowledge not been investigated before...|$|R
40|$|In program debugging, {{finding a}} failing run {{is only the}} first step; what about {{correcting}} the fault? Can we automate the second task as well as the first? The AutoFix-E tool automatically generates and validates fixes for software faults. The key insights behind AutoFix-E are to rely on contracts present in the software to ensure that the proposed fixes are notion of state based on the boolean queries of a class. Out of 42 faults found by an automatic testing tool in two widely used Eiffel libraries, AutoFix-E proposes successful fixes for 16 faults. Submitting some of these faults to experts shows that several of the proposed fixes are identical or close to fixes proposed by humans. Categories and Subject Descriptors D. 2. 5 [Software Engineering]: Testing and Debugging— <b>debugging</b> <b>aids,</b> diagnostics; D. 2. 4 [Software Engineering]: Software Verification—programming by contract, assertion checkers, reliability; F. 3. 1 [Logics and Meaning...|$|R
