569|253|Public
25|$|G = B^(B >> 1); This gets <b>gray</b> <b>code</b> from binary.|$|E
25|$|The {{row and column}} indices (shown {{across the}} top, and down {{the left side of}} the Karnaugh map) are ordered in <b>Gray</b> <b>code</b> rather than binary {{numerical}} order. <b>Gray</b> <b>code</b> ensures that only one variable changes between each pair of adjacent cells. Each cell of the completed Karnaugh map contains a binary digit representing the function's output for that combination of inputs.|$|E
25|$|The {{sequence}} of numbers generated by an LFSR or its XNOR counterpart {{can be considered a}} binary numeral system just as valid as <b>Gray</b> <b>code</b> or the natural binary code.|$|E
5000|$|Hamiltonicity of the {{hypercube}} is tightly {{related to}} the theory of <b>Gray</b> <b>codes.</b> More precisely there is a bijective correspondence between the set of -bit cyclic <b>Gray</b> <b>codes</b> and the set of Hamiltonian cycles in the hypercube [...] An analogous property holds for acyclic n-bit <b>Gray</b> <b>codes</b> and Hamiltonian paths.|$|R
40|$|Single-track <b>Gray</b> <b>codes</b> are cyclic <b>Gray</b> <b>codes</b> with codewords {{of length}} n, such {{that all the}} tracks which {{correspond}} to the distinct coordinates of the codewords are cyclic shifts of the first track. We investigate the structure of such binary codes and {{show that there is}} no such code with 2 codewords when is a power of 2. This implies that the known codes with 2 0 2 n codewords, when is a power of 2, are optimal. This result is then generalized to codes over GF (p), where p is a prime. A subclass of single-track <b>Gray</b> <b>codes,</b> called single-track <b>Gray</b> <b>codes</b> with k-spaced heads, is also defined. All known systematic constructions for single-track <b>Gray</b> <b>codes</b> result in codes from this subclass. We investigate this class and show it has a strong connection with two classes of sequences, the full-order words and the full-order self-dual words. We present an iterative construction for binary single-track <b>Gray</b> <b>codes</b> which are asymptotically optimal if an infinite family of asymptotically optimal seed-codes exists. This construction is based on an effective way to generate a large set of distinct necklaces and a merging method for cyclic <b>Gray</b> <b>codes</b> based on necklaces representatives...|$|R
40|$|In this paper, a bit-inverted <b>Gray</b> <b>coded</b> bit-plane {{matching}} {{algorithm is proposed}} for low complexity motion estimation. Unlike the typical <b>Gray</b> <b>coded</b> bit-plane {{matching algorithm}}s, the proposed algorithm uses bit-inverted <b>Gray</b> <b>codes</b> for transforming image frames and a corresponding extended matching criterion to enhance the motion estimation accuracy. Experimental {{results show that the}} proposed algorithm outperforms other bit-plane matching based motion estimation algorithms while preserving the binary matching characteristi...|$|R
25|$|The {{required}} Boolean {{results are}} transferred from a truth table onto a two-dimensional grid where, in Karnaugh maps, the cells are ordered in <b>Gray</b> <b>code,</b> and each cell position represents one combination of input conditions, while each cell value represents the corresponding output value. Optimal groups of 1s or 0s are identified, which represent {{the terms of}} a canonical form of the logic in the original truth table. These terms can be used to write a minimal Boolean expression representing the required logic.|$|E
2500|$|Another way of {{handling}} {{this is a}} reduction for the above algorithm. Using <b>Gray</b> <b>code,</b> starting from zero, determine the change to the next value. If the change is a 1 turn left, {{and if it is}} 0 turn right. Given a binary input, B, the corresponding <b>gray</b> <b>code,</b> G, is given by [...] "G = B XOR (B>>1)". Using G'i and G'i−1, turn equals" [...] (not G'i) AND G'i−1".|$|E
50|$|There {{are many}} {{specialized}} types of Gray codes {{other than the}} binary-reflected <b>Gray</b> <b>code.</b> One such type of <b>Gray</b> <b>code</b> is the n-ary <b>Gray</b> <b>code,</b> {{also known as a}} non-Boolean <b>Gray</b> <b>code.</b> As the name implies, this type of <b>Gray</b> <b>code</b> uses non-Boolean values in its encodings.|$|E
5000|$|<b>Gray</b> <b>coding</b> {{compensates}} for errors on rotary encoders and linear encoders.|$|R
40|$|This paper {{employs a}} Markov model {{to study the}} {{relative}} performance of binary and <b>Gray</b> <b>coding</b> in genetic algorithms. The results indicate that while there is little {{difference between the two}} for all possible functions, <b>Gray</b> <b>coding</b> does not necessarily improve performance for functions which have fewer local optima in the Gray representation than in binary. ...|$|R
5000|$|Steinhaus-Johnson-Trotter {{algorithm}}, an algorithm {{that generates}} <b>Gray</b> <b>codes</b> for the factorial number system ...|$|R
50|$|An {{address decoder}} {{converts}} from binary or <b>gray</b> <b>code</b> to one-hot representation.A priority encoder converts from one-hot representation to binary or <b>gray</b> <b>code.</b>|$|E
5000|$|Sometimes digital buses in {{electronic}} systems {{are used to}} convey quantities that can only increase or decrease by one at a time, for example the output of an event counter which is being passed between clock domains or to a digital-to-analog converter. The advantage of Gray codes in these applications is that differences in the propagation delays of the many wires that represent the bits of the code cannot cause the received value to go through states {{that are out of}} the <b>Gray</b> <b>code</b> sequence. This is similar to the advantage of Gray codes in the construction of mechanical encoders, however the source of the <b>Gray</b> <b>code</b> is an electronic counter in this case. The counter itself must count in <b>Gray</b> <b>code,</b> or if the counter runs in binary then the output value from the counter must be reclocked after it has been converted to <b>Gray</b> <b>code,</b> because when a value is converted from binary to <b>Gray</b> <b>code,</b> it is possible that differences in the arrival times of the binary data bits into the binary-to-Gray conversion circuit will mean that the code could go briefly through states that are wildly out of sequence. Adding a clocked register after the circuit that converts the count value to <b>Gray</b> <b>code</b> may introduce a clock cycle of latency, so counting directly in <b>Gray</b> <b>code</b> may be advantageous. A <b>Gray</b> <b>code</b> counter was patented in 1962 , and there have been many others since. In recent times a <b>Gray</b> <b>code</b> counter can be implemented as a state machine in Verilog. In order to produce the next count value, it is necessary to have some combinational logic that will increment the current count value that is stored in <b>Gray</b> <b>code.</b> Probably the most obvious way to increment a <b>Gray</b> <b>code</b> number is to convert it into ordinary binary code, add one to it with a standard binary adder, and then convert the result back to <b>Gray</b> <b>code.</b> This approach was discussed in a paper in 1996 [...] and then subsequently patented by someone else in 1998 [...] Other methods of counting in <b>Gray</b> <b>code</b> are discussed in a report by R. W. Doran, including taking the output from the first latches of the master-slave flip flops in a binary ripple counter.|$|E
5000|$|We {{will now}} show a {{construction}} for well-balanced binary Gray codes which {{allows us to}} generate an n-digit balanced <b>Gray</b> <b>code</b> for every n. The main principle is to inductively construct an (n + 2)-digit <b>Gray</b> <b>code</b> [...] given an n-digit <b>Gray</b> <b>code</b> G {{in such a way}} that the balanced property is preserved. To do this, we consider partitions of [...] into an even number L of non-empty blocks of the form ...|$|E
40|$|The {{past decade}} has seen a flurry of {{research}} into pattern avoiding permutations but little of it is concerned with their exhaustive generation. Many applications call for exhaustive generation of permutations subject to various constraints or imposing a particular generating order. In this paper we present generating algorithms and combinatorial <b>Gray</b> <b>codes</b> for several families of pattern avoiding permutations. Among the families under consideration are those counted by Catalan, Schröder, Pell, even index Fibonacci numbers and the central binomial coefficients. Consequently, this provides <b>Gray</b> <b>codes</b> for _n(τ) for all τ∈_ 3 and the obtained <b>Gray</b> <b>codes</b> have distances 4 and 5. Comment: 18 page...|$|R
50|$|The digital bytes {{are in a}} bit-field {{format that}} have been packed {{together}} into bytes. These bit-fields are also optionally <b>gray</b> <b>coded</b> before being grouped together. The <b>gray</b> <b>coding</b> may be useful if sending raw, but normally an application will just burst the bit-fields out. The bit-fields make-up the various parameters that are stored or exchanged (pitch, energy, voicing booleans, LSP's, etc.).|$|R
40|$|Abstract—We {{explore a}} novel data {{representation}} scheme for multilevel flash memory cells, {{in which a}} set of n cells stores information in the permutation induced by the different charge levels of the individual cells. The only allowed charge-placement mechanism is a “push-to-the-top ” operation, which takes a single cell of the set and makes it the top-charged cell. The resulting scheme {{eliminates the need for}} discrete cell levels, as well as overshoot errors, when programming cells. We present unrestricted <b>Gray</b> <b>codes</b> spanning all possible n-cell states and using only “push-to-the-top ” operations, and also construct balanced <b>Gray</b> <b>codes.</b> One important application of the <b>Gray</b> <b>codes</b> is the realization of logic multilevel cells, which is useful in conventional storage solutions. We also investigate rewriting schemes for random data modification. We present both an optimal scheme for the worst case rewrite performance and an approximation scheme for the average-case rewrite performance. Index Terms—Asymmetric channel, flash memory, <b>Gray</b> <b>codes,</b> permutations, rank modulation. I...|$|R
50|$|More generally, {{combinatorial}} algorithms {{researchers have}} defined a <b>Gray</b> <b>code</b> {{for a set}} of combinatorial objects to be an ordering for the objects in which each two consecutive objects differ in the minimal possible way. In this generalized sense, the Steinhaus-Johnson-Trotter algorithm generates a <b>Gray</b> <b>code</b> for the permutations themselves.|$|E
5000|$|Therefore, {{the coding}} is stable, {{in the sense}} that once a binary number appears in Gn it appears in the same {{position}} in all longer lists; so it makes sense to talk about the reflective <b>Gray</b> <b>code</b> value of a number: G(m) = the m-th reflecting <b>Gray</b> <b>code,</b> counting from 0.|$|E
50|$|More formally, a <b>Gray</b> <b>code</b> is a code {{assigning}} {{to each of}} a contiguous set of integers, or to each member of a circular list, a word of symbols such that each two adjacent code words differ by one symbol. These codes are also known as single-distance codes, reflecting the Hamming distance of 1 between adjacent codes. There can {{be more than one}} <b>Gray</b> <b>code</b> for a given word length, but the term was first applied to a particular binary code for the non-negative integers, the binary-reflected <b>Gray</b> <b>code,</b> or BRGC, the three-bit version of which is shown above.|$|E
5000|$|... #Caption: BER {{comparison}} between BPSK and differentially encoded BPSK with <b>Gray</b> <b>coding</b> operating in white noise ...|$|R
5000|$|... #Caption: Constellation diagram for QPSK with <b>Gray</b> <b>coding.</b> Each {{adjacent}} symbol only differs by one bit.|$|R
40|$|Abstract — <b>Gray</b> <b>codes</b> {{have found}} many {{applications}} in engineering and mathematics. In this work we explain {{how to apply}} <b>Gray</b> <b>codes</b> to {{the determination of the}} control parameter and initial point of a chaotic orbit generated by the Mandelbrot map when the kneading sequence is known. Possible applications to the cryptanalysis of a certain type of cryptosystems based on Baptista’s algorithm are also discussed. I...|$|R
5000|$|The one-bit <b>Gray</b> <b>code</b> is G1 = (0, 1). This can {{be thought}} of as built recursively as above from a zero-bit <b>Gray</b> <b>code</b> G0 = ( [...] Λ [...] ) {{consisting}} of a single entry of zero length. This iterative process of generating Gn+1 from Gn makes the following properties of the standard reflecting code clear: ...|$|E
50|$|A more {{efficient}} <b>Gray</b> <b>code</b> implementation was proposed by Antonov and Saleev.|$|E
5000|$|These {{characteristics}} {{suggest a}} simple and fast method of translating a binary value into the corresponding <b>Gray</b> <b>code.</b> Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: the nth <b>Gray</b> <b>code</b> is obtained by computing ...|$|E
40|$|AbstractThe {{past decade}} has seen a flurry of {{research}} into pattern avoiding permutations but little of it is concerned with their exhaustive generation. Many applications call for exhaustive generation of permutations subject to various constraints or imposing a particular generating order. In this paper we present generating algorithms and combinatorial <b>Gray</b> <b>codes</b> for several families of pattern avoiding permutations. Among the families under consideration are those counted by Catalan, large Schröder, Pell, even-index Fibonacci numbers and the central binomial coefficients. We thus provide <b>Gray</b> <b>codes</b> for the set of all permutations of { 1,…,n} avoiding the pattern τ for all τ∈S 3 and the <b>Gray</b> <b>codes</b> we obtain have distances 4 or 5...|$|R
40|$|Abstract. The {{past decade}} has seen a flurry of {{research}} into pattern avoiding permutations but little of it is concerned with their exhaustive generation. Many applications call for exhaustive generation of permutations subject to various constraints or imposing a particular generating order. In this paper we present generating algorithms and combinatorial <b>Gray</b> <b>codes</b> for several families of pattern avoiding permutations. Among the families under consideration are those counted by Catalan, large Schröder, Pell, even-index Fibonacci numbers and the central binomial coefficients. We thus provide <b>Gray</b> <b>codes</b> for the set of all permutations of { 1, [...] ., n} avoiding the pattern τ for all τ ∈ S 3 and the <b>Gray</b> <b>codes</b> we obtain have distances 4 or 5. 1...|$|R
5000|$|... #Caption: BER {{comparison}} between DBPSK, DQPSK and their non-differential forms using <b>Gray</b> <b>coding</b> and operating in white noise ...|$|R
5000|$|... #Caption: Rotary encoder for angle-measuring devices {{marked in}} 3-bit binary-reflected <b>Gray</b> <b>code</b> (BRGC) ...|$|E
50|$|The {{modulator}} {{uses the}} <b>Gray</b> <b>code</b> to encode 5-bit symbols into the tone numbers.|$|E
5000|$|... #Caption: A collineation of the Fano plane {{corresponding}} to the 3-bit <b>Gray</b> <b>code</b> permutation ...|$|E
40|$|A {{counting}} {{sequence is}} a list of all binary words of the same length. Counting sequences of any fixed odd Hamming distance between successive words (codewords) are discussed. <b>Gray</b> <b>codes</b> are examples of counting sequences having a single-bit change between neighboring codewords. We describe some results on <b>Gray</b> <b>codes</b> and highlight some research questions. The spectrum of bit changes or transition counts for individual variables for some uniform counting sequences is considered. We show some recent minor findings and pose remaining open questions...|$|R
40|$|We provide several {{heuristics}} {{to improve}} the efficiency of exhaustively generating <b>Gray</b> <b>codes</b> on length n binary strings. We then apply the heuristics to a restricted class of <b>Gray</b> <b>codes</b> on binary strings known as Beckett-Gray codes. The resulting algoirthm has a speed-up {{by a factor of}} 60 over the fastest previously known algorithm when n = 6. It was also used to discover over 9500 new Beckett-Gray codes for n = 7 in the equivalent of three months of computation time...|$|R
50|$|In many {{practical}} implementations, {{series of}} measurements combining pattern recognition, <b>Gray</b> <b>codes</b> and Fourier transform are obtained {{for a complete}} and unambiguous reconstruction of shapes.|$|R
