240|4774|Public
25|$|The <b>data</b> <b>phase</b> {{continues}} until {{both parties}} are ready to complete the transfer and continue to the next <b>data</b> <b>phase.</b> The initiator asserts IRDY# (initiator ready) when it no longer needs to wait, while the target asserts TRDY# (target ready). Whichever side is providing the data must drive it on the AD bus before asserting its ready signal.|$|E
25|$|An {{initiator}} must complete each <b>data</b> <b>phase</b> (assert IRDY#) within 8 cycles.|$|E
25|$|A target {{must be able}} to {{complete}} the initial <b>data</b> <b>phase</b> (assert TRDY# and/or STOP#) within 16 cycles of the start of a transaction.|$|E
40|$|Abstract A data {{distribution}} scheme of sparse arrays on a distributed memory mul-ticomputer, in general, {{is composed of}} three <b>phases,</b> <b>data</b> partition, {{data distribution}}, and data compression. To implement the data distribution scheme, many methods proposed in the literature first perform the <b>data</b> partition <b>phase,</b> then the <b>data</b> distri-bution <b>phase,</b> followed by the <b>data</b> compression <b>phase.</b> We called a data distribution scheme with this order as Send Followed Compress (SFC) scheme. In this paper, we propose two other data distribution schemes, Compress Followed Send (CFS) and Encoding-Decoding (ED), for sparse array distribution. In the CFS scheme, the <b>data</b> compression <b>phase</b> is performed before the <b>data</b> distribution <b>phase.</b> In the ED scheme, the <b>data</b> compression <b>phase</b> {{can be divided into}} two steps, encoding and decoding. The encoding step and the decoding step are performed before and after the <b>data</b> dis-tribution <b>phase,</b> respectively. To evaluate the CFS and the ED schemes, we compare them with the SFC scheme. In the <b>data</b> partition <b>phase,</b> the row partition, the col-umn partition, and the 2 D mesh partition with/without load-balancing methods are used for these three schemes. In the compression phase, the CRS/CCS methods ar...|$|R
40|$|A data {{distribution}} scheme of sparse arrays on a distributed memory multicomputer, in general, {{is composed of}} three <b>phases,</b> <b>data</b> partition, {{data distribution}}, and data compression. In the <b>data</b> partition <b>phase,</b> a global sparse array is partitioned into some local sparse arrays. In the <b>data</b> distribution <b>phase,</b> these local sparse arrays are distributed to processors. In the <b>data</b> compression <b>phase,</b> a local sparse array is compressed by some data compression methods {{in order to obtain}} better performance for sparse array operations. To implement the data distribution scheme, methods proposed in the literature first perform the <b>data</b> partition <b>phase,</b> then the <b>data</b> distribution <b>phase,</b> followed by the <b>data</b> compression <b>phase.</b> We called this scheme as Send Followed Compress (SFC) scheme. In this paper, we propose two other data distribution schemes, Compress Followed Send (CFS) and Encoding-Decoding (ED), for sparse array distribution. In the CFS scheme, the <b>data</b> compression <b>phase</b> is performed before the <b>data</b> distribution <b>phase.</b> In the ED scheme, the <b>data</b> compression <b>phase</b> can be divided into two steps, encoding and decoding. The encoding step and the decoding step are performed before and after the <b>data</b> distribution <b>phase,</b> respectively. To evaluate the CFS and the ED schemes, we compare them with the SFC scheme. In theoretical analysis, we analyze the SFC, the CFS, and the ED schemes in terms of the data distribution time and the data compression time. In experimental test, for all test cases, we implemented these schemes on an IBM SP 2 parallel machine. From the experimental results, the CFS and the ED schemes outperform the SFC scheme for all test cases. For the CFS and the ED schemes, the ED scheme outperforms the CFS scheme. Index Terms － Data distribution schemes, Data compression methods, Partition methods, Sparse ratio...|$|R
30|$|Yazan et al. [20] {{suggested}} a big data security lifecycle model extended from Xu et al. [21]. This model {{is designed to}} address the phases of the big data lifecycle and correlate threats and attacks that face big data environment within these phases, while [21] address big data lifecycle from user role perspective: data provider, data collector, data miner, and decision maker. The model proposed in [20] comprised of four interconnecting phases: <b>data</b> collection <b>phase,</b> <b>data</b> storage <b>phase,</b> <b>data</b> processing and analysis, and knowledge creation.|$|R
25|$|The REQ64# and ACK64# {{lines are}} held {{asserted}} {{for the entire}} transaction save the last <b>data</b> <b>phase,</b> and deasserted {{at the same time}} as FRAME# and DEVSEL#, respectively.|$|E
25|$|If the {{initiator}} observes STOP# before asserting its own IRDY#, {{then it can}} end {{the burst}} by deasserting FRAME# {{at the same time}} as it asserts IRDY#, ending the burst after the current <b>data</b> <b>phase.</b>|$|E
25|$|A <b>data</b> <b>phase</b> {{with all}} four C/BE# lines {{deasserted}} is explicitly permitted by the PCI standard, {{and must have}} no effect on the target other than to advance the address in the burst access in progress.|$|E
40|$|A method, {{apparatus}} and article of manufacture provide ionospheric ground-truth measurements {{for use in}} a wide-area augmentation system (WAAS). Ionospheric pseudorange/code and carrier <b>phase</b> <b>data</b> as primary observables is received by a WAAS receiver. A polynomial fit is performed on the <b>phase</b> <b>data</b> that is examined to identify any cycle slips in the <b>phase</b> <b>data.</b> The <b>phase</b> <b>data</b> is then leveled. Satellite and receiver biases are obtained and applied to the leveled <b>phase</b> <b>data</b> to obtain unbiased phase-leveled ionospheric measurements that are used in a WAAS system. In addition, one of several measurements may be selected and data is output that provides information {{on the quality of the}} measurements that are used to determine corrective messages as part of the WAAS system...|$|R
40|$|Abstract—We {{consider}} a single-user correlated MIMO channel with block fading, where each block {{is divided into}} training and <b>data</b> transmission <b>phases.</b> The receiver has a noisy CSI that it obtains through a channel estimation process, while the transmitter has partial CSI {{in the form of}} covariance feedback. We optimize the achievable rate jointly over the parameters of the training and <b>data</b> transmission <b>phases.</b> In particular, we first choose the training signal to minimize the channel estimation error, and then, develop an iterative algorithm to solve for the optimum training duration, the optimum allocation of power between training and <b>data</b> transmission <b>phases,</b> and the optimum allocation of power over the antennas during the <b>data</b> transmission <b>phase.</b> I...|$|R
50|$|The PAR64 line {{operates}} {{just like}} the PAR line, but provides even parity over AD63:32 and C/BE7:4#. It is only valid for address phases if REQ64# is asserted. PAR64 is only valid for <b>data</b> <b>phases</b> if both REQ64# and ACK64# are asserted.|$|R
25|$|On clock edge 6, {{the target}} {{indicates}} that it wants to stop (with data), but the initiator is already holding IRDY# low, {{so there is a}} fifth <b>data</b> <b>phase</b> (clock edge 7), during which no data is transferred.|$|E
2500|$|If the {{initiator}} {{has already}} asserted IRDY# (without deasserting FRAME#) {{by the time}} it observes the target's STOP#, it is committed to an additional <b>data</b> <b>phase.</b> [...] The target must wait through an additional <b>data</b> <b>phase,</b> holding STOP# asserted without TRDY#, before the transaction can end.|$|E
2500|$|Once {{one of the}} {{participants}} asserts its ready signal, it may not become un-ready or otherwise alter its control signals {{until the end of the}} <b>data</b> <b>phase.</b> [...] The data recipient must latch the AD bus each cycle until it sees both IRDY# and TRDY# asserted, which marks the end of the current <b>data</b> <b>phase</b> and indicates that the just-latched data is the word to be transferred.|$|E
30|$|To {{protect the}} {{content in the}} data in a data stream {{environment}} while meeting the requirements for data mining, we use {{the concept of a}} sliding window and propose the CRP algorithm, which can effectively process this type of data. The algorithm has a <b>data</b> protection <b>phase</b> and a <b>data</b> recovery <b>phase.</b> In the <b>data</b> protection <b>phase,</b> a sliding window model is used to protect the content in the continuous data, and the watermarks customised by users are embedded. On the other hand, in the <b>data</b> recovery <b>phase,</b> in addition to recovering the original data from the protected data, one can also extract the embedded watermark to verify whether the protected data has been tampered with. The data protection and recovery phases in CRP are detailed below.|$|R
40|$|In this paper, shift {{multiplex}} {{recording of}} <b>phase</b> <b>data</b> pages on a volume polarization-sensitive medium by retardagraphy is demonstrated. The origin of shift selectivity in volume retardagraphy is explained. In the experiment, four-valued <b>phase</b> <b>data</b> pages are used. Then, a coding method is proposed {{to correct a}} reconstructed phase pattern. The recorded <b>phase</b> <b>data</b> pages are reconstructed using the feature of the coding method. By comparing the reconstructed <b>phase</b> <b>data</b> pages with recording <b>phase</b> <b>data</b> pages, symbol error rates of less than 11 % are achieved. From the experimental result, it is verified that volume retardagraphy is applicable to optical memory...|$|R
50|$|During <b>data</b> {{collection}} <b>phase</b> {{of problem}} identification.|$|R
2500|$|If the {{initiator}} sees DEVSEL# asserted without ACK64#, it performs 32-bit data phases. [...] The data {{which would}} have been transferred on the upper half of the bus during the first <b>data</b> <b>phase</b> is instead transferred during the second <b>data</b> <b>phase.</b> [...] Typically, the initiator drives all 64 bits of data before seeing DEVSEL#. [...] If ACK64# is missing, it may cease driving the upper half of the data bus.|$|E
2500|$|Normally, {{a target}} holds DEVSEL# {{asserted}} {{through the last}} <b>data</b> <b>phase.</b> [...] However, if a target deasserts DEVSEL# before disconnecting without data (asserting STOP#), this indicates a target abort, which is a fatal error condition. [...] The initiator may not retry, and typically treats it as a bus error. [...] Note that a target may not deassert DEVSEL# while waiting with TRDY# or STOP# low; it must do this {{at the beginning of}} a <b>data</b> <b>phase.</b>|$|E
2500|$|While the PCI bus {{transfers}} 32 bits per <b>data</b> <b>phase,</b> the initiator transmits 4 active-low byte enable signals indicating which 8-bit bytes are to {{be considered}} significant. [...] In particular, a write must affect only the enabled bytes in the target PCI device. [...] They are of little importance for memory reads, but I/O reads might have side effects. [...] The PCI standard explicitly allows a <b>data</b> <b>phase</b> with no bytes enabled, which must behave as a no-op.|$|E
50|$|The {{second major}} change is that AGP uses split {{transaction}}s, where the address and <b>data</b> <b>phases</b> of a PCI transaction are separated. The card may send many address phases, {{and the host}} processes them in order. This avoids long delays, with the bus idle, during read operations.|$|R
5000|$|The most {{important}} {{distinction between the}} initial <b>data</b> analysis <b>phase</b> and the main analysis phase, is that during initial data analysis one refrains from any analysis that is aimed at answering the original research question. The initial <b>data</b> analysis <b>phase</b> is guided by the following four questions: ...|$|R
25|$|The {{algorithm}} {{attempts to}} set up a congruence of squares modulo n (the integer to be factorized), which often leads to a factorization of n. The algorithm works in two phases: the <b>data</b> collection <b>phase,</b> where it collects information that may lead to a congruence of squares; and the <b>data</b> processing <b>phase,</b> where it puts all the data it has collected into a matrix and solves it to obtain a congruence of squares. The <b>data</b> collection <b>phase</b> can be easily parallelized to many processors, but the <b>data</b> processing <b>phase</b> requires large amounts of memory, and is difficult to parallelize efficiently over many nodes or if the processing nodes do not each have enough memory to store the whole matrix. The block Wiedemann algorithm can be used {{in the case of a}} few systems each capable of holding the matrix.|$|R
2500|$|Generally, PCI writes are {{faster than}} PCI reads, because a device may buffer the {{incoming}} write data and release the bus faster. [...] For a read, it must delay the <b>data</b> <b>phase</b> until the data has been fetched.|$|E
2500|$|If {{the target}} asserts STOP# without asserting TRDY#, this {{indicates}} that the target wishes to stop without transferring data. [...] STOP# is considered equivalent to TRDY# {{for the purpose of}} ending a <b>data</b> <b>phase,</b> but no data is transferred.|$|E
2500|$|The cache {{would watch}} all memory accesses, without asserting DEVSEL#. [...] If it noticed an access {{that might be}} cached, it would drive SDONE low (snoop not done). [...] A coherence-supporting target would avoid {{completing}} a <b>data</b> <b>phase</b> (asserting TRDY#) until it observed SDONE high.|$|E
40|$|SARTOM is a {{three year}} {{research}} project split in three <b>phases,</b> a <b>data</b> acquisition <b>phase</b> and a <b>data</b> evaluation <b>phase</b> which {{in itself is}} divided into two steps. The radar measurement campaign as part of the <b>data</b> acquisition <b>phase</b> is subject of the work packages 130 and 140 of the project plan and has been executed under the lead of the Microwaves and Radar Institute of the German Aerospace Center (DLR-HR). This document describes the SARTOM radar measurement campaign conducted in September 2006 (the main activity of the first project phase) and summarizes the data acquired...|$|R
5000|$|... sukfrac apply FRACtional {{powers of}} i|k| to <b>data,</b> with <b>phase</b> shift ...|$|R
5000|$|... dropout (this {{should be}} {{identified}} {{during the initial}} <b>data</b> analysis <b>phase)</b> ...|$|R
2500|$|The PERR# line is {{only used}} during data phases, once a target has been selected. [...] If a parity error is {{detected}} during an address phase (or the <b>data</b> <b>phase</b> of a Special Cycle), the devices which observe it assert the SERR# (System error) line.|$|E
2500|$|Either side may {{request that}} a burst end after the current <b>data</b> <b>phase.</b> [...] Simple PCI devices {{that do not}} support multi-word bursts will always request this immediately. [...] Even devices that do support bursts will have some limit on the maximum length they can support, such {{as the end of}} their {{addressable}} memory.|$|E
2500|$|If {{the target}} asserts STOP# and TRDY# {{at the same}} time, this {{indicates}} that the target wishes {{this to be the}} last <b>data</b> <b>phase.</b> [...] For example, a target that does not support burst transfers will always do this to force single-word PCI transactions. [...] This is the most efficient way for a target to end a burst.|$|E
5000|$|... #Caption: Feature {{detection}} on 1D {{time domain}} <b>data</b> using <b>Phase</b> Stretch Transform.|$|R
2500|$|After {{the address}} phase (specifically, {{beginning}} with the cycle that DEVSEL# goes low) comes a burst {{of one or more}} <b>data</b> <b>phases.</b> [...] In all cases, the initiator drives active-low byte select signals on the C/BE# lines, but the data on the AD may be driven by the initiator (in case of writes) or target (in case of reads).|$|R
2500|$|Combining : Write {{transactions}} to consecutive addresses may {{be combined}} into a longer burst write, {{as long as the}} order of the accesses in the burst {{is the same as the}} order of the original writes. [...] It is permissible to insert extra <b>data</b> <b>phases</b> with all byte enables turned off if the writes are almost consecutive.|$|R
