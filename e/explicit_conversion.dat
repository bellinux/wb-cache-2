29|33|Public
2500|$|The cast {{operator}} is not overloadable but you {{can write}} a conversion operator method which lives in the target class. Conversion methods can define two varieties of operators, implicit and <b>explicit</b> <b>conversion</b> operators. The implicit operator will cast without specifying with the cast operator (...) and the explicit operator requires it to be used.|$|E
2500|$|These were {{followed}} by Nvidia's CUDA, which allowed programmers to ignore the underlying graphical concepts {{in favor of more}} common high-performance computing concepts. Newer, hardware vendor-independent offerings include Microsoft's DirectCompute and Apple/Khronos Group's OpenCL. [...] This means that modern GPGPU pipelines can leverage the speed of a GPU without requiring full and <b>explicit</b> <b>conversion</b> of the data to a graphical form.|$|E
50|$|There {{are several}} kinds of <b>explicit</b> <b>conversion.</b>|$|E
50|$|New {{operations}} include Fused multiply-add (FMA), <b>explicit</b> <b>conversions,</b> classification predicates (isNan(x), etc.), various min and max functions, a total ordering predicate, and two decimal-specific operations (samequantum and quantize).|$|R
2500|$|The more type {{restrictions}} that are {{imposed by the}} compiler, the more strongly typed a programming language is. [...] Strongly typed languages often require the programmer to make <b>explicit</b> <b>conversions</b> in contexts where an implicit conversion would cause no harm. [...] Pascal's type system {{has been described as}} [...] "too strong" [...] because, for example, the size of an array or string is part of its type, making some programming tasks difficult. Haskell is also strongly typed but its types are automatically inferred so that <b>explicit</b> <b>conversions</b> are often (but not always) unnecessary.|$|R
40|$|We define type {{theory with}} <b>explicit</b> <b>conversions.</b> When type {{checking}} a term in normal type theory, the system searches for convertibility paths between types. The {{results of these}} searches are not stored in the term, {{and need to be}} reconstructed every time again. In our system, this information is also represented in the term. The system we define has the property that the type derivation of a term has exactly the same structure as the term itself. This has the consequence that there exists a natural LF encoding of such a system in which the encoded type is a dependent parameter of the type of the encoded term. For every Pure Type System we define a system in our style. We show that such a system is always equivalent to the normal system without <b>explicit</b> <b>conversions</b> (even for non-functional systems), {{in the sense that the}} typability relation can be lifted. This proof has been fully formalised in the Coq system, building on a formalisation by Vincent Siles. In our system, <b>explicit</b> <b>conversions</b> are not allowed to be removed when checking for convertibility. This means that all terms in convertibility proofs are well typed, even in the sense of our system. Keywords: Type Theory; Pure Type Systems; Conversion Rule; Convertibility Proofs; Formalisation; Co...|$|R
5000|$|... #Subtitle level 3: Attribute values {{which need}} an <b>explicit</b> <b>conversion</b> ...|$|E
5000|$|If either 1 or 0 are {{specifically}} needed, an <b>explicit</b> <b>conversion</b> {{can be done}} using the conditional operator: ...|$|E
5000|$|As {{the example}} shows, no <b>explicit</b> <b>conversion</b> {{is needed for}} the {{assignment}} [...] "km = one100Miles;" [...] {{to do the right}} thing.|$|E
50|$|In C++ type conversion, the static_cast {{operator}} performs an <b>explicit</b> type <b>conversion.</b>|$|R
5000|$|In C++11, the [...] keyword can now {{be applied}} to {{conversion}} operators. As with constructors, it prevents using those conversion functions in implicit conversions. However, language contexts that specifically need a boolean value (the conditions of if-statements and loops, and operands to the logical operators) count as <b>explicit</b> <b>conversions</b> and can thus use a bool conversion operator.|$|R
5000|$|So far, the {{pseudocode}} {{has avoided}} specifying the ordering of bits within bytes by describing {{shifts in the}} pseudocode as multiplications by [...] and writing <b>explicit</b> <b>conversions</b> from binary to polynomial form. In practice, the CRC is held in a standard binary register using a particular bit-ordering convention. In msbit-first form, the most significant binary bits will be sent first and so contain the higher-order polynomial coefficients, while in lsbit-first form, the least-significant binary bits contain the higher-order coefficients. The above pseudocode can be written in both forms. For concreteness, this uses the 16-bit CRC-16-CCITT polynomial : ...|$|R
5000|$|<b>Explicit</b> <b>conversion</b> operatorclass Foo{ public int Value; public static {{explicit}} operator Foo(int value) { return new Foo(value); }}// Explicit conversionFoo foo = (Foo)2; ...|$|E
5000|$|The cast {{operator}} is not overloadable but you {{can write}} a conversion operator method which lives in the target class. Conversion methods can define two varieties of operators, implicit and <b>explicit</b> <b>conversion</b> operators. The implicit operator will cast without specifying with the cast operator (...) and the explicit operator requires it to be used.|$|E
50|$|The 2/n table {{method that}} was {{validated}} in RMP 36 with an <b>explicit</b> <b>conversion</b> of 3/53 scaled to 60/1060. The best divisors of 1060 were summed to 60 within /1060 and 1/20 + 1/265 + 1/530 + 1/1060. The red number method was used over {{six times in}} RMP 36 and over seven times in RMP 37.|$|E
50|$|<b>Explicit</b> type <b>{{conversion}}</b> is a {{type conversion}} which is explicitly defined within a program (instead of being done by a compiler for implicit type conversion). It {{is defined by the}} user in the program.|$|R
50|$|The pointer {{is still}} one of the most popular types of {{references}} today. It is similar to the assembly representation of a raw address, except that it carries a static datatype which can be used at compile-time to ensure that the data it refers to is not misinterpreted. However, because C has a weak type system which can be violated using casts (<b>explicit</b> <b>conversions</b> between various pointer types and between pointer types and integers), misinterpretation is still possible, if more difficult. Its successor C++ tried to increase type safety of pointers with new cast operators and smart pointers in its standard library, but still retained the ability to circumvent these safety mechanisms for compatibility.|$|R
50|$|In Eiffel, {{the setup}} for type {{conversion}} {{is included in}} the class code, but then appears to happen as automatically as <b>explicit</b> type <b>conversion</b> in client code. The includes not just assignments but other types of attachments as well, such as argument (parameter) substitution.|$|R
5000|$|These were {{followed}} by Nvidia's CUDA, which allowed programmers to ignore the underlying graphical concepts {{in favor of more}} common high-performance computing concepts. Newer, hardware vendor-independent offerings include Microsoft's DirectCompute and Apple/Khronos Group's OpenCL. [...] This means that modern GPGPU pipelines can leverage the speed of a GPU without requiring full and <b>explicit</b> <b>conversion</b> of the data to a graphical form.|$|E
50|$|This {{language}} feature {{was introduced}} in J2SE 5.0. Boxing is the operation of converting a value of a primitive type into a value of a corresponding reference type, {{which serves as a}} wrapper for this particular primitive type. Unboxing is the reverse operation of converting a value of a reference type (previously boxed) into a value of a corresponding primitive type. Neither operation requires an <b>explicit</b> <b>conversion.</b>|$|E
50|$|A {{distinction}} {{exists between}} structural substitution for inferred and non-inferred polymorphism. Some languages, such as Haskell, do not substitute structurally {{in the case}} where an expected type is declared (i.e., not inferred), e.g., only substitute for functions that are signature-based polymorphic via type inference. Then {{it is not possible}} to accidentally subtype a non-inferred type, although it may still be possible to provide an <b>explicit</b> <b>conversion</b> to a non-inferred type, which is invoked implicitly.|$|E
50|$|CLU {{does not}} perform {{implicit}} type conversions. In a cluster, the <b>explicit</b> type <b>conversions</b> {{up and down}} change between the abstract type and the representation. There is a universal type any, and a procedure force to check that an object is a certain type. Objects may be mutable or immutable, the latter being base types such as integers, booleans, characters and strings.|$|R
50|$|Wirth's {{intention}} was to create an efficient language (regarding both compilation speed and generated code) based on structured programming, a recently popularized concept that he promoted in his book Algorithms + Data Structures = Programs. Pascal {{has its roots in}} the ALGOL 60 language, but also introduced concepts and mechanisms which (on top of ALGOL's scalars and arrays) enabled programmers to define their own complex (structured) datatypes, and also made it easier to build dynamic and recursive data structures such as lists, trees and graphs. Important features included for this were records, enumerations, subranges, dynamically allocated variables with associated pointers, and sets. To make this possible and meaningful, Pascal has a strong typing on all objects, which means that one type of data cannot be converted or interpreted as another without <b>explicit</b> <b>conversions.</b> Similar mechanisms are standard in many programming languages today. Other languages that influenced Pascal's development were Simula 67 and Wirth's own ALGOL W.|$|R
5000|$|In C and C++, the {{analogous}} construct is the [...] keyword. This differs substantially from [...] in Java, most {{basically in}} being a type qualifier: [...] {{is part of the}} type, not only part of the identifier (variable). This also means that the constancy of a value can be changed by casting (<b>explicit</b> type <b>conversion),</b> in this case known as [...] "const casting". Nonetheless, casting away constness and then modifying the object results in undefined behavior.|$|R
50|$|The {{requirements}} evaluation involves {{redefining the}} implementation script. The IT and (if possible) organizational requirements {{that were made}} should be tested. Some tests can be run where the organizational responsibilities can be evaluated (Rooijmans, 2003) {{as well as the}} IT-requirements. Here it is also again important to have top-management support and involvement (Eason, 1988). If they do not make resources available to evaluate, the implementation can be unsuccessful as a direct consequence. After this evaluation the implementation script is redefined into a more <b>explicit</b> <b>conversion</b> scenario.|$|E
40|$|We present {{analytical}} results both in momentum and position {{space for the}} massless correlators of the vector and scalar currents to order alpha_s^ 4 {{as well as for}} the tensor currents to order alpha_s^ 3. The evolution equations for the correlators together with all relevant anomalous dimensions are discussed in detail. As an application we present <b>explicit</b> <b>conversion</b> formulas relating the MSbar-renormalized vector, scalar and tensor currents to their counterparts renormalized in the X-space renormalization scheme more appropriate for lattice calculations. Comment: 29 pages, 2 figure...|$|E
40|$|This paper {{proposes a}} small change in C++ grammar {{to permit the}} function-specifier 'explicit ' {{to be applied to}} the {{definition}} of a user-defined conversion operator. The semantic effect is to inhibit automatic conversions in situations where they may not have been intended. This paper introduces a new term "boolean-converted " for use in contexts where a boolean value is expected (but not an integral value). This term is linked to directinitialization, and overload resolution is amended to invoke <b>explicit</b> <b>conversion</b> functions for direct-initialization only. As is general practice, it is expected that the use of explicit casts would suppress warning messages...|$|E
50|$|In the C {{family of}} {{languages}} and ALGOL 68, the word cast typically refers to an <b>explicit</b> type <b>conversion</b> (as opposed to an implicit conversion), causing some ambiguity about {{whether this is a}} re-interpretation of a bit-pattern or a real data representation conversion. More important is the multitude of ways and rules that apply to what data type (or class) is located by a pointer and how a pointer may be adjusted by the compiler in cases like object (class) inheritance.|$|R
50|$|In most languages, {{the word}} {{coercion}} {{is used to}} denote an implicit conversion, either during compilation or during run time. For example, in an expression mixing integer and floating point numbers (like 5 + 0.1), the compiler will automatically convert integer representation into floating point representation so fractions are not lost. <b>Explicit</b> type <b>conversions</b> are either indicated by writing additional code (e.g. adding type identifiers or calling built-in routines) or by coding conversion routines for the compiler to use when it otherwise would halt with a type mismatch.|$|R
50|$|Oberon-07, {{defined by}} Niklaus Wirth in 2007 and revised in 2011, 2013, 2014, 2015 and 2016 {{is based on}} the {{original}} version of Oberon rather than Oberon-2. The main changes are: <b>explicit</b> numeric <b>conversion</b> functions (e.g. FLOOR and FLT) must be used, the LOOP and EXIT statements have been eliminated, WHILE statements have been extended, CASE statements can be used for type extension tests, RETURN statements can only be connected {{to the end of a}} function, imported variables and structured value parameters are read-only and arrays can be assigned without using COPY. For full details, see The Programming Language Oberon-07.|$|R
40|$|We analyze {{approximate}} {{transformations of}} pure entangled quantum states by local operations and classical communication, finding <b>explicit</b> <b>conversion</b> strategies which optimize the fidelity of transformation. These results {{allow us to}} determine the most faithful teleportation strategy via an initially shared partially entangled pure state. They also show that procedures for entanglement manipulation such as entanglement catalysis [Jonathan and Plenio, Phys. Rev. Lett. 83, 3566 (1999) ] are robust against perturbation of the states involved, and motivate the notion of non-local fidelity, which quantifies {{the difference in the}} entangled properties of two quantum states. Comment: 11 pages, 4 figure...|$|E
40|$|AbstractSeveral {{computational}} {{and structural}} properties of Bezoutian matrices expressed {{with respect to}} the Bernstein polynomial basis are shown. The exploitation of such properties allows the design of fast algorithms for the solution of Bernstein–Bezoutian linear systems without never making use of potentially ill-conditioned reductions to the monomial basis. In particular, we devise an algorithm for the computation of the greatest common divisor (GCD) of two polynomials in Bernstein form. A series of numerical tests are reported and discussed, which indicate that Bernstein–Bezoutian matrices are much less sensitive to perturbations of the coefficients of the input polynomials compared to other commonly used resultant matrices generated after having performed the <b>explicit</b> <b>conversion</b> between the Bernstein and the power basis...|$|E
40|$|The Casimir {{force has}} its origin in finite {{modification}} of the infinite zero-point energy induced by a specific boundary condition for the spatial configuration. In terms of the imaginary-time formalism at finite temperature, the root of Planck's law of radiation {{can be traced back}} to finite {{modification of the}} infinite vacuum energy induced by the periodic boundary condition in the temporal direction. We give the <b>explicit</b> <b>conversion</b> from the Casimir force to Planck's law of radiation, which shows the apparent correspondence between the system bounded by parallel conducting plates and the thermodynamic system. The temperature inversion symmetry and the duality relation in the thermodynamics are also discussed. We conclude that the effective temperature characterized by the spatial extension should no longer be regarded as genuine temperature. Comment: 8 pages, 1 figur...|$|E
5|$|Triton had {{a number}} of {{attributes}} that made her a potential NECPA platform. Her size allowed ample room for additional shipboard systems and personnel accommodations. Her designed speed provided the capability for rapid transit, and her nuclear power plant offered virtually unlimited endurance and range. The Combat Information Center (CIC) provided substantial command and control capabilities as did the communication buoy system that could receive and send radio transmissions while submerged. As she was a submarine, Triton offered superior protection against nuclear-biological-chemical (NBC) contaminants over surface ships or an airborne command centre. However, the record remains unclear if such an <b>explicit</b> NECPA <b>conversion</b> was ever undertaken for Triton.|$|R
50|$|Local {{officials}} {{in some areas}} attempted to force Protestants to renounce their faith; however, there were no reports of <b>explicit</b> forced <b>conversion</b> to another faith during the reporting period. In cases where renunciations occurred, villagers were told by local officials {{that they would be}} expelled from their villages if they did not sign documents renouncing their faith. In at least one case, villagers in Nakun Village of Bolikhamsai Province who chose not to renounce their beliefs were reported to have been relocated by local officials. According to Protestants following the incident, village officials had suggested that Protestant villagers convert to Buddhism or to their previously held animist beliefs. The same officials reportedly told villagers that Protestantism is not good because it is an American religion.|$|R
5000|$|Python, from version 2.3 forward, has a [...] type {{which is}} a {{subclass}} of , the standard integer type. It has two possible values: [...] and , which are special versions of 1 and 0 respectively and behave as such in arithmetic contexts. Also, a numeric value of zero (integer or fractional), the null value (...) , the empty string, and empty containers (i.e. lists, sets, etc.) are considered Boolean false; all other values are considered Boolean true by default. Classes can define how their instances are treated in a Boolean context through the special method [...] (Python 2) or [...] (Python 3). For containers, [...] (the special method for determining the length of containers) is used if the <b>explicit</b> Boolean <b>conversion</b> method is not defined.|$|R
