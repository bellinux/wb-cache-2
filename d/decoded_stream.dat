5|201|Public
2500|$|Decoding {{video and}} audio, then sending the <b>decoded</b> <b>stream</b> to the {{graphics}} or audio subsystem for playback. [...] In macOS, QuickTime sends video playback to the Quartz Extreme (OpenGL) Compositor.|$|E
50|$|Another {{way to try}} {{to improve}} {{performance}} is to cache the decoded micro-operations, so the processor can directly access the decoded micro-operations from a special cache, instead of decoding them again. Intel followed this approach with the Execution Trace Cache feature in their NetBurst Microarchitecture (for Pentium 4 processors) and later in the <b>Decoded</b> <b>Stream</b> Buffer (for Core-branded processors since Sandy Bridge).|$|E
40|$|Published in Proc. of BSDCon Europe 2002] The MPEG- 4 {{standard}} encodes a {{video stream}} in 3 different frames, I, P and B, where the P and B frames {{depend on the}} I frame. Loosing an I frame is especially bad. In this paper we exploit the Partial Reliability features of the SCTP transport protocol to selectively retransmit I frames in presence of congestion, obtaining {{a better quality of}} the <b>decoded</b> <b>stream...</b>|$|E
5000|$|MPEG-2 video decode engine {{suitable}} for DVD playback, HDTV <b>decode,</b> and <b>decoding</b> <b>streaming</b> video up to 1920x1080 ...|$|R
40|$|Methods {{and systems}} for {{streaming}} {{data in a}} network. Whether the network is experiencing high packet loss may be determined by a rate control module. If high packet loss is experienced, data is encoded into multiple streams by a coder using temporal domain partitioning. If high packet loss is not experienced, then data may is encoded by using frequency domain partitioning. Unequal error protection is applied {{to each of the}} streams so more important bit planes {{in a bit of a}} stream are provided with more error protection than less important bit planes. The streams are transmitted along, respectively, independent paths to a decoder. The <b>streams</b> are <b>decoded,</b> and errors in the <b>decoded</b> <b>streams</b> are corrected by using information from one or more of the other <b>decoded</b> <b>streams.</b> The <b>decoded</b> corrected <b>streams</b> are reconstructed into the data. Georgia Tech Research Corp...|$|R
5000|$|Effect plug-ins, {{which provide}} various sound {{processing}} on the <b>decoded</b> audio <b>stream</b> ...|$|R
40|$|Streaming {{applications}} are often implemented as task graphs, in which data is communicated from task to task over buffers. Currently, techniques exist to compute buffer capacities that guarantee {{satisfaction of the}} throughput constraint if the amount of data produced and consumed by the tasks is known at design-time. However, applications such as audio and video decoders have tasks that produce and consume an amount of data {{that depends on the}} <b>decoded</b> <b>stream.</b> This paper introduces a dataflow model that allows for data-dependent communication, together with an algorithm that computes buffer capacities that guarantee satisfaction of a throughput constraint. The applicability of this algorithm is demonstrated by computing buffer capacities for an H. 263 video decoder...|$|E
5000|$|... a {{command-line}} program {{based on}} libFLAC to encode and <b>decode</b> FLAC <b>streams</b> ...|$|R
40|$|Abstract. Due to {{the limited}} {{resources}} in thin-clients on mobile devices and {{the large amount of}} computation for <b>decoding</b> <b>streaming</b> media, {{it is not easy to}} support the QoS of streaming media for thin-client on mobile environment. To solve the problems, the terminal servers would be charged for <b>decoding</b> the <b>streaming</b> media and thin-clients have a role to update only the changed areas in their screen. In this paper, an intelligent media player is proposed to provide the improved QoS for streaming media in thin-client computing. Since the proposed method reflects the intrinsic property of streaming media, it provides both the enhanced video quality and the audio streaming fully synchronized with image frames. ...|$|R
50|$|Decoding of N {{elementary}} streams is synchronized {{by adjusting}} the <b>decoding</b> of <b>streams</b> to a common master time base rather than {{by adjusting the}} <b>decoding</b> of one <b>stream</b> to match that of another. The master time base {{may be one of}} the N decoders' clocks, the data source’s clock, or it may be some external clock.|$|R
40|$|We {{explore a}} novel {{approach}} to perform decoding-order optimization in the vertical Bell Labs layered space-time (V-BLAST) architecture. Allowing for simultaneous transmission of multiple, separately encoded data streams, the V-BLAST transmit-receive scheme applies to the uplink of a multi-user communication system. A multi-antenna receiver <b>decodes</b> data <b>streams</b> successively, dealing with inter-stream interference by means of cancelling and nulling; interference from previously <b>decoded</b> <b>streams</b> is cancelled by subtraction, and remaining interference is nulled by linear equalization. The order in which the <b>streams</b> are <b>decoded</b> can have a noticeable impact on system performance. We consider the optimization of a fixed decoding order in fast Rayleigh fading, based on long-term channel-fading parameters. For {{a wide range of}} performance measures, we show that the fast-fading ordering problem can be treated as a classical linear assignment problem, allowing a solution using existing, efficient algorithms...|$|R
3000|$|... [...]) is a {{stationary}} uncorrelated process, we can consider the <b>decoded</b> bit <b>stream</b> as a Poisson process. This yields {{the relationship between}} BER and PER: [...]...|$|R
40|$|This paper {{proposes a}} method for hierar-chical phrase-based <b>stream</b> <b>decoding.</b> A <b>stream</b> decoder is {{able to take a}} contin-uous stream of tokens as input, and seg-ments this stream into word {{sequences}} that are translated and output as a stream of tar-get word sequences. Phrase-based <b>stream</b> <b>decoding</b> techniques {{have been shown to be}} effective as a means of simultaneous in-terpretation. In this paper we transfer the essence of this idea into the framework of hierarchical machine translation. The hi-erarchical decoding framework organizes the decoding process into a chart; this structure is naturally suited to the process of <b>stream</b> <b>decoding,</b> leading to an efficient <b>stream</b> <b>decoding</b> algorithm that searches a restricted subspace containing only rel-evant hypotheses. Furthermore, the de-coder allows more explicit access to the word re-ordering process that is of crit-ical importance in decoding while inter-preting. The decoder was evaluated on TED talk data for English-Spanish and English-Chinese. Our results show that like the phrase-based stream decoder, the hierarchical is capable of approaching the performance of the underlying hierarchi-cal phrase-based machine translation de-coder, at useful levels of latency. In ad-dition the hierarchical approach appeared to be robust to the difficulties presented by the more challenging English-Chinese task. ...|$|R
3000|$|... ≤ r can <b>decode</b> the <b>stream</b> {{successfully}} {{because the}} coding method utilized by the nodes' channels is not slower than that used by i. Taking the WiMAX network as an example, {{based on the}} channel quality, each channel has a different Burst Profile, which records its acceptable modulation schemes and therefore the transmission speed. If a multicast stream is encoded by a certain coding method (i.e., it takes {{a certain number of}} timeslots), all receivers whose channels allow a faster scheme (i.e., they require fewer timeslots) will be able to <b>decode</b> the <b>stream</b> successfully.|$|R
50|$|OpenH264 {{is a free}} {{software}} library for real-time encoding and <b>decoding</b> video <b>streams</b> in the H.264/MPEG-4 AVC format. It is released {{under the terms of}} the Simplified BSD License.|$|R
40|$|This {{thesis is}} focused on a {{receiver}} for digital television broadcasting set-top box, mainly on its features, parameters and measurement. The important point of this work is the possibility to analyze and visualize the parallel transport stream {{in the same time}} and the solution of this problem. The principle of tuner and its measuring is deeply discussed. The text is supported with oscilloscope screenshots in particular parts of <b>decoding</b> <b>stream.</b> The set-top box is modified for laboratory measurement purpose and the transport stream output is added. An example laboratory exercise was created as a part of this work...|$|R
5000|$|... "|AdditionalHeader" [...] - {{an array}} of {{required}} <b>stream</b> <b>decoding</b> informational pairs ...|$|R
50|$|Such {{self-clocking}} signals can be decoded correctly into {{a stream}} of bits without bit slip.To further <b>decode</b> that <b>stream</b> of bits and decide which bit is the first bit of a byte, often a self-synchronizing code is used.|$|R
5000|$|Realtime dual-video <b>stream</b> <b>decoding</b> for HD DVD/Blu-ray Picture-in-Picture (primary video @ 1080p, {{secondary}} video @ 480p) ...|$|R
30|$|This can {{be easily}} seen since, for the {{receiver}} forced to <b>decode</b> all <b>streams,</b> the model reduces to a multiple access channel (MAC) with a single-antenna receiver, which has a sum-DoF of 1. This was discussed in length in [34].|$|R
2500|$|Non-standard bit rates up to 640kbit/s can be {{achieved}} with the LAME encoder and the freeformat option, although few MP3 players can play those files. According to the ISO standard, decoders are only required {{to be able to}} <b>decode</b> <b>streams</b> up to 320kbit/s. Early MPEG Layer III encoders used what is now called Constant Bit Rate (CBR). [...] The software was only able to use a uniform bitrate on all frames in an MP3 file. Later more sophisticated MP3 encoders were able to use the bit reservoir to target an average bit rate selecting the encoding rate for each frame based on the complexity of the sound in that portion of the recording.|$|R
40|$|Wireless {{communication}} using Multiple Input Multiple Output (MIMO) systems increases efficiency {{for a given}} total transmits power. Here {{investigate a}} novel approach to perform decoding- order optimization in the vertical Bell Labs layered space-time (V-BLAST) planning. Allowing for instantaneous transmission of multiple, independently encoded data streams, the V-BLAST transmit-receive method applies to the uplink of a multi-user communication system. A multi-antenna receiver <b>decodes</b> data <b>streams</b> consecutively, trade with inter-stream interference by means of cancelling and nulling; interference from before <b>decoded</b> <b>streams</b> is cancelled by subtraction, and residual interference is nulled by linear equalization. The order in which the <b>streams</b> are <b>decoded</b> can have a visible impact on system presentation. Multiple Input Multiple Output (MIMO) channels can offer high capability to wireless systems and the capacity increases linearly {{with the number of}} antennas. There are many schemes that can be applied to MIMO systems such as space time block codes, space time trellis codes, and the Vertical Bell Labs Space-Time structural design (V-BLAST). We study the broad-spectrum MIMO system, the general V-BLAST structure, and the Successive Interference Cancellation (SIC) Zero-Forcing (ZF) detectors in this paper...|$|R
50|$|Gateway device {{capable of}} <b>decoding</b> six video <b>streams</b> and feeding through a home network to various devices.|$|R
50|$|Adapter device {{capable of}} <b>decoding</b> two video <b>streams</b> and feeding {{directly}} to a television or consumer electronics device.|$|R
5000|$|The GStreamer {{framework}} has {{support for}} parsing raw Theora <b>streams,</b> encoding and <b>decoding</b> raw Theora <b>streams</b> to/from YUV video ...|$|R
40|$|Abstract. Writing {{code that}} manipulates bit streams is a painful and {{error-prone}} programming task, often performed via bit twiddling {{techniques such as}} explicit bit shifts and bit masks in programmer-allocated buffers. Still, this kind of programming is necessary in many application areas ranging from <b>decoding</b> <b>streaming</b> media files to implementing network protocols. In this paper we employ highlevel constructs from declarative programming, such as pattern matching at the bit level and bit stream comprehensions, and show how a variety of bit stream programming applications can be written in a succinct, less error-prone, and totally memory-safe manner. We also describe how these constructs can be implemented efficiently. The resulting performance is superior {{to that of other}} (purely) functional languages and competitive to that of low-level languages such as C. ...|$|R
5000|$|... musikcube {{is based}} on a modular plugin architecture, and uses plugins written in C++. Plugins provide core {{functionality}} for audio <b>decoding,</b> data <b>streaming,</b> output device handling, metadata parsing, digital signal processing, and more. Plugins currently exist to provide support for many popular audio codecs, including MP3, M4A, Ogg Vorbis, and FLAC.|$|R
40|$|Abstract — We {{consider}} a transceiver beamforming design problem for non-regenerative multi-antenna multi-group multi-way relaying channel (MGMWRC) {{when the number}} of communication phases to complete the full data exchange equals to the maximum number of nodes among all groups. The first phase is multiple-access (MAC) and the other phases are broadcast (BC). In each BC phase, the relay station (RS) does not <b>decode</b> <b>streaming</b> data from all nodes and applies beamforming scheme to its received data before sending to all nodes. We propose a hybrid beamforming scheme that combines Minimum Variance Distortion Response (MVDR) -Matched Filter (MF) schemes and Coherent Combining (CC) scheme for bi-directional pairs of odd users in MGMWRC. The average sum rate and symbol error rate simulation results are provided to compare the performance of the proposed scheme and all conventional schemes under 3 types of loads...|$|R
40|$|Writing {{code that}} manipulates bit streams is a painful and errorprone {{programming}} task, currently often performed via bit twiddling {{techniques such as}} explicit bit shifts and bit masks in programmer-allocated buffers. Still, this kind of programming is necessary in many application areas ranging from <b>decoding</b> <b>streaming</b> media files to implementing network protocols. In this paper we show how high-level constructs from functional programming, such as binary pattern matching at the bit level and binary comprehensions, can make bit stream manipulation more succinct, less error-prone, and totally memory-safe. We formally define these language constructs, show a variety of example uses from several different application areas, and describe their implementation in detail. We hold that a binary data structure {{with the ability to}} perform pattern matching at the bit level allows (purely) functional languages to significantly expand the range of their practical uses. 1...|$|R
40|$|Convolutional {{codes are}} {{also known as}} Turbo codes because of their error {{correction}} capability. These codes are also awarded as Super product codes, because these codes have replaced the backward error correction codes. Turbo codes are much more efficient than previous backward error correction codes because these are Forward error correction (FEC) codes {{and there is no}} need for a feedback link to request the transmitter for retransmission of data, when bits are corrupted in the information channel. A Viterbi decoder <b>decodes</b> <b>stream</b> of digital data bits that has been encoded by Convolutional encoder. In this paper we introduce a RSC (Recursive Systematic Convolutional) encoder with constraint length of 2 code rate of 1 / 3. The RSC encoder and Viterbi decoder both are implemented on paper, as well as in MATLAB. Simulation results are also presented by using MATLAB...|$|R
40|$|MPEG {{decoding}} chips have {{to support}} multiple features such as video <b>stream</b> <b>decoding,</b> transport <b>stream</b> parsing, multi-standard support, scan line conversion for on-screen displq, and audiohideo synchronization. Some of these features are computation-intensive, while others are size-intensive. In this papel; an embedded processor specialized for the MPEG decoding is proposed {{to cope with the}} complicated requirements. The proposed processor can execute up to four operations at a time to handle intensive computation, and can change instruction issue rate according to the required performance in order to save code size that is very important in MPEG applications. In addition, the processor can switch tasks rapidly to keep the number of buffers existing between tasks minimal. I...|$|R
30|$|Stream—a special {{dictionary}} object {{followed by}} a sequence of bytes enclosed with the keywords “stream” and “endstream.” The information inside the stream may be compressed or encrypted by a filter. The prefix dictionary contains information on whether and how to <b>decode</b> the <b>stream.</b> Streams are used to store data such as images, text, script code, etc.|$|R
50|$|HTTP servers {{often use}} {{compression}} to optimize transmission, for example with Content-Encoding: gzip or Content-Encoding: deflate. If both compression and chunked encoding are enabled, then the content stream is first compressed, then chunked; so the chunk encoding {{itself is not}} compressed, and the data in each chunk is not compressed individually. The remote endpoint then <b>decodes</b> the <b>stream</b> by concatenating the chunks and uncompressing the result.|$|R
40|$|Displaying {{real time}} video {{captured}} from a camera {{is an essential}} function {{in a variety of}} applications ranging from CCTV security monitoring to webconference meetings. In this project, we propose to build a system on a FPGA, in conjunction with a commercial web camera, that can read a stream of video from a camera, <b>decode</b> this <b>stream,</b> and then display it on a local screen. ...|$|R
50|$|Note {{that the}} choice of a {{variable}} bitrate (VBR) method only affects the encoding process. <b>Decoding</b> a VBR <b>stream</b> is performed identically in all cases, regardless of how the encoder chooses to allocate bits.|$|R
5000|$|The {{library is}} used in VLC media player {{and is able to}} decode DTS audio tracks from DVDs. It can also decode DTS files (.dts) directly, as well as DTS-WAV files (.wav). libdca is able to <b>decode</b> DTS-ES <b>streams</b> as well, however can only decode the {{standard}} 6 channels as the additional [...] "Extended Surround" [...] extensions (for Matrix and 6.1 Discrete) require ES Extensions to the codec.|$|R
