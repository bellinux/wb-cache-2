3937|1938|Public
5|$|The PHP {{language}} evolved {{without a}} written <b>formal</b> <b>specification</b> or standard until 2014, leaving the canonical PHP interpreter as {{a de facto}} standard. Since 2014 work {{has gone on to}} create a formal PHP specification.|$|E
25|$|In the Z <b>formal</b> <b>specification</b> language, braces denote a set and angle {{brackets}} denote a sequence.|$|E
25|$|RFC 850 was {{the first}} <b>formal</b> <b>specification</b> of the {{messages}} exchanged by Usenet servers. It was superseded by RFC 1036 and subsequently by RFC 5536 and RFC 5537.|$|E
40|$|The {{precision}} of <b>formal</b> <b>specifications</b> {{allows us to}} prove program correctness. Even if formal methods are not used throughout the software project, formalisation improves {{our understanding of the}} problem. <b>Formal</b> <b>specifications</b> are amenable to automated analysis and consistency checking. However using them is challenging. Customers do not understand formal notations. Specifiers have difficulty tackling large problems. Once systems are built, <b>formal</b> <b>specifications</b> quickly become outdated during software maintenance. A method of developing <b>formal</b> <b>specifications</b> using concrete scenarios is proposed to tackle the disadvantages just mentioned. A concrete scenario describes system behaviour with successive steps. The pre- and post-states of scenario steps are expressed with actual data rather than variables. Concrete scenarios are expressed in a natural language or formal notation. They increase customer involvement in the creation of <b>formal</b> <b>specifications.</b> Scenarios may be ranked by priorities allowing specifiers to focus on {{a small part of the}} system. <b>Formal</b> <b>specifications</b> are constructed incrementally. New requirements are also captured in concrete scenarios which guide the modification of <b>formal</b> <b>specifications.</b> On one hand, concrete scenarios assist the creation and maintenance of <b>formal</b> <b>specifications.</b> On the other hand, they facilitate program correctness proofs without using conventional <b>formal</b> <b>specifications.</b> This is achieved by adding implementation details to customer scenarios. The resulting developer scenarios, encapsulating decisions of data structures and algorithms, are generalised to operation schemas. With the implementation details, the schemas written in formal notations are programs rather than specifications. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|R
40|$|A Doctoral Thesis {{submitted}} in partial fulfilment of {{the requirements}} for the award of Doctor of Philosophy of Loughborough University. The precision of <b>formal</b> <b>specifications</b> allows us to prove program correctness. Even if formal methods are not used throughout the software project, formalisation improves {{our understanding of the}} problem. <b>Formal</b> <b>specifications</b> are amenable to automated analysis and consistency checking. However using them is challenging. Customers do not understand formal notations. Specifiers have difficulty tackling large problems. Once systems are built, <b>formal</b> <b>specifications</b> quickly become outdated during software maintenance. A method of developing <b>formal</b> <b>specifications</b> using concrete scenarios is proposed to tackle the disadvantages just mentioned. A concrete scenario describes system behaviour with successive steps. The pre- and post-states of scenario steps are expressed with actual data rather than variables. Concrete scenarios are expressed in a natural language or formal notation. They increase customer involvement in the creation of <b>formal</b> <b>specifications.</b> Scenarios may be ranked by priorities allowing specifiers to focus on {{a small part of the}} system. <b>Formal</b> <b>specifications</b> are constructed incrementally. New requirements are also captured in concrete scenarios which guide the modification of <b>formal</b> <b>specifications.</b> On one hand, concrete scenarios assist the creation and maintenance of <b>formal</b> <b>specifications.</b> On the other hand, they facilitate program correctness proofs without using conventional <b>formal</b> <b>specifications.</b> This is achieved by adding implementation details to customer scenarios. The resulting developer scenarios, encapsulating decisions of data structures and algorithms, are generalised to operation schemas. With the implementation details, the schemas written in formal notations are programs rather than specifications...|$|R
40|$|Abstract. Issues {{related to}} large scale systems made of {{autonomous}} components encompass interoperability among independently developed software and adaptability to changing environmental conditions. <b>Formal</b> <b>specifications</b> are traditionally used at design time for software engineering tasks. However, recently, several attempts of using <b>formal</b> <b>specifications</b> at run-time have been realised that let envisage a future use of <b>formal</b> <b>specifications</b> at run-time that will enhance interoperability and adaptability of autonomous components. This paper intends {{to highlight the}} potentialities {{of the use of}} <b>formal</b> <b>specifications</b> at run-time as a support for the correct execution of such components. This paper reviews and discusses the use of <b>formal</b> <b>specifications</b> at run-time from different perspectives: software engineering, run-time code evolution, adaptive middleware, trust and security, or business applications. It highlights the potentialities of the use of <b>formal</b> <b>specifications</b> at run-time as a support for interoperability and adaptability of interacting autonomous components. It identifies as well application domains and open issues related to the combination of specifications and code in the framework of large scale systems. ...|$|R
25|$|In {{artificial}} intelligence and computer science, scientists study and use automated reasoning for diverse applications including automated theorem proving the formal semantics of programming languages, and <b>formal</b> <b>specification</b> in software engineering.|$|E
500|$|The original, only {{complete}} and {{most widely used}} PHP implementation is powered by the Zend Engine and known simply as PHP. To disambiguate it from other implementations, it is sometimes unofficially referred to as [...] "Zend PHP". The Zend Engine compiles PHP source code on-the-fly into an internal format that it can execute, thus it works as an interpreter. It is also the [...] "reference implementation" [...] of PHP, as PHP has no <b>formal</b> <b>specification,</b> and so the semantics of Zend PHP define the semantics of PHP itself. Due to the complex and nuanced semantics of PHP, defined by how Zend works, {{it is difficult for}} competing implementations to offer complete compatibility.|$|E
2500|$|TLA+ (pronounced as tee ell a plus, [...] ) is a <b>formal</b> <b>specification</b> {{language}} {{developed by}} Leslie Lamport. It {{is used to}} design, model, document, and verify concurrent systems. TLA+ {{has been described as}} exhaustively-testable pseudocode ...|$|E
40|$|This paper reports {{results of}} an {{investigation}} into the suitability of object-oriented models as an initial step in developing <b>formal</b> <b>specifications.</b> The requirements for two critical system-level software modules were used as target applications. It was found that creating object-oriented diagrams prior to formally specifying the requirements enhanced the accuracy of the initial <b>formal</b> <b>specifications</b> and reduced the effort required to produce them. However, the <b>formal</b> <b>specifications</b> incorporated some information not found in the object-oriented diagrams, such as higher-level strategy or goals of the software...|$|R
40|$|This paper {{presents}} a systematic approach to developing Java Card applets and/or <b>formal</b> <b>specifications</b> for them, starting from descriptions {{in the form}} of finite state machines. The <b>formal</b> <b>specifications</b> are written in the specification language JML, and can be checked against Java Card source code using the static checker ESC/Java. 1...|$|R
40|$|<b>Formal</b> <b>specifications</b> customarily deal {{exclusively}} with {{the domain of}} functional properties of software. However, other domians are of interest to software desginers and developers. Two particular areas of concern for practical software development are not yet well-served by <b>formal</b> <b>specifications.</b> This note raises issues about how those areas might be better served...|$|R
2500|$|In 2007 he co-authored a {{proposal}} for a new standard written form of Cornish, called Kernowek Standard. [...] Following the publication of the Standard Written Form in 2008, Everson and a group of other users examined the specification and implemented a set of corrections to it, publishing a <b>formal</b> <b>specification</b> in 2012.|$|E
2500|$|Automated theorem provers {{are also}} used to {{implement}} formal verification in computer science. [...] In this setting, theorem provers are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} <b>formal</b> <b>specification.</b> Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|E
2500|$|Even before Hurricane {{production}} {{began in}} March 1937, Sydney Camm had embarked on designing its successor. Two preliminary designs were similar and were {{larger than the}} Hurricane. These later {{became known as the}} [...] "N" [...] and [...] "R" [...] (from the initial of the engine manufacturers), because they were designed for the newly developed Napier Sabre and Rolls-Royce Vulture engines respectively. Both engines used 24 cylinders and were designed for over {{the difference between the two}} was primarily in the arrangement of the cylinders – an H-block in the Sabre and an X-block in the Vulture. Hawker submitted these preliminary designs in July 1937 but were advised to wait until a <b>formal</b> <b>specification</b> for a new fighter was issued.|$|E
40|$|A {{methodology}} for {{the description of}} system requirements and <b>formal</b> <b>specifications</b> and the diagnosis of them is presented. We will specifically deal with the issues (1) mathematical description of system function requirements and their relationship with <b>formal</b> <b>specifications</b> represented as state transition systems, (2) soundness and completeness of the system, (3) Diagnosis of system requirements and specifications...|$|R
40|$|<b>Formal</b> <b>specifications</b> can {{not provide}} the {{correctness}} by themselves, while designing complex systems. Models that are formally specified need correctness proof {{that can be done}} by performing imitation modeling on a computer. This problem can be solved by automated creation of imitation models, so that functionality and correctness of various solutions can be verified in early stages of system design. The article presents the implementation of algorithm for automated creation of imitation models using PLA <b>formal</b> <b>specifications.</b> It also presents an overview of existing modeling techniques and methods. Describes the architecture of <b>formal</b> <b>specifications</b> analysis software and gives experiment results while analyzing network devices interaction...|$|R
40|$|<b>Formal</b> <b>specifications</b> play {{a crucial}} role in the design of {{reliable}} complex software systems. Executable <b>formal</b> <b>specifications</b> allow the designer to attain early validation and verification of design using static analysis techniques and accurate simulation of the runtime behavior of the system-to-be. With increasing complexity of software-intensive computer-based systems and the challenges of validation and verification of abstract software models prior to coding, the need for interactive software tools supporting executable <b>formal</b> <b>specifications</b> is even more evident. In this paper, we discuss how CoreASM, an environment for writing and running executable specifications according to the ASM method, provides flexibility and manages the complexity by using an innovative extensible language architecture...|$|R
2500|$|Boeing {{began work}} on {{pressurized}} long-range bombers in 1938, {{in response to a}} United States Army Air Corps request. Boeing's design study for the Model 334 was a pressurized derivative of the Boeing B-17 Flying Fortress with nosewheel undercarriage. Although the Air Corps did not have money to pursue the design, Boeing continued development with its own funds as a private venture. In April 1939, Charles Lindbergh convinced general Henry H. Arnold to produce a new bomber in large numbers to counter the Nazi production. The Air Corps issued a <b>formal</b> <b>specification</b> for a so-called [...] "superbomber", capable of delivering [...] of bombs to a target [...] away and capable of flying at a speed of [...] in December 1939. Boeing's previous private venture studies formed the starting point for its response to this specification.|$|E
50|$|The use of VDM in the CHILL and Ada {{projects}} {{revealed the}} need for improvements in <b>formal</b> <b>specification</b> techniques, and in 1983 DDC conducted a Formal Methods Appraisal study, producing a number of requirements that a <b>formal</b> <b>specification</b> language should embody.|$|E
5000|$|<b>Formal</b> <b>specification,</b> formal design, validation, verification, testing ...|$|E
5000|$|Security Testing {{automatically}} generates test-case {{from the}} <b>formal</b> top-level <b>specification</b> or <b>formal</b> lower-level <b>specifications.</b>|$|R
40|$|In {{this paper}} we present an {{event-driven}} simulation engine for executing <b>formal</b> <b>specifications</b> of digital {{systems in the}} Prototype Verification System (PVS). The engine {{is intended to be}} used as an efficient debugging mechanism to validate PVS models. Once the simulation experiments give sufficient confidence in the correctness of the <b>formal</b> <b>specifications,</b> the theorem prover of PVS can be used to verify desired properties of interest...|$|R
40|$|This paper {{describes}} {{the application of}} formal methods and object-oriented modeling to reverse engineering, in which <b>formal</b> <b>specifications</b> are developed for existing, or legacy, code. In this project, several layers of <b>formal</b> <b>specifications</b> were constructed {{for a portion of}} the NASA Space Shuttle Digital Auto Pilot (DAP), a software module that is used to control the position of the spacecraft through appropriate jet firings...|$|R
5000|$|... #Subtitle level 2: <b>Formal</b> <b>Specification</b> Versus Exploratory Programming ...|$|E
50|$|Another {{well-known}} {{approach to}} <b>formal</b> <b>specification</b> is algebraic specification.|$|E
50|$|The Z {{notation}} is {{an example}} of a leading <b>formal</b> <b>specification</b> language. Others include the Specification Language(VDM-SL) of the Vienna Development Method and the Abstract Machine Notation (AMN) of the B-Method. In the Web services area, <b>formal</b> <b>specification</b> is often used to describe non-functional properties (Web services Quality of Service).|$|E
40|$|Formal {{verification}} {{approaches that}} check software correctness against <b>formal</b> <b>specifications</b> {{have been shown}} to improve program de-pendability. Tools such as Specification Pattern System (SPS) and Property Specification (Prospec) support the generation of <b>formal</b> <b>specifications.</b> SPS has defined a set of patterns (common recurring properties) and scopes (system states over which a pattern must hold) that allows a user to generate <b>formal</b> <b>specifications</b> by using direct substitution of propositions into parameters of selected patterns and scopes. Prospec extended SPS to support the definition of patterns and scopes that include the ability to specify parameters with multiple propositions (referred to as composite propositions or CPs), allowing the specification of sequential and concurrent behavior. Prospe...|$|R
40|$|The {{research}} community has long understood {{the value of}} <b>formal</b> <b>specifications</b> in building robust software. However, the adoption of any specifications beyond run-time assertions in industrial software has been limited. All of this has changed at Microsoft {{in the last few}} years. Today, <b>formal</b> <b>specifications</b> are a mandated part of the software development process in the largest Microsoft product groups. Millions of specifications have been added, {{and tens of thousands of}} bugs have been exposed and fixed in future versions of products under development. In addition, Windows public interfaces are formally specified and the Visual Studio compiler understands and enforces these specifications, meaning that programmers anywhere can now use <b>formal</b> <b>specifications</b> to make their software more robust...|$|R
40|$|<b>Formal</b> {{methods for}} <b>specification</b> and {{verification}} are promising in developing PLC (Programmable Logic Controller) programs in manufacturing industry. Particularly this holds for safety PLCs, {{used to protect}} humans and equipment from injuries and damages. An important challenge though, {{is the development of}} <b>formal</b> <b>specifications,</b> typically a tough task for control engineers. This paper proposes a systematic work procedure that {{can be used as a}} first step of developing <b>formal</b> <b>specifications</b> of safety PLC programs in industry. The work procedure intends to facilitate the development of relevant formal properties for safety PLC program components. The <b>formal</b> <b>specifications</b> can be used for automatic formal verification of the components, using model checking techniques. The paper shows how the work procedure has been applied to industrial safety components, resulting in relevant and nontrivial specifications...|$|R
5000|$|The {{compiler}} creation process {{went through}} four steps: {{development of a}} <b>formal</b> <b>specification</b> of Ada, development of a <b>formal</b> <b>specification</b> of the compiler components; development of more detailed formal specifications of particular compiler passes; implementation of these specifications in Ada itself. [...] The general idea was {{to prove that the}} implementation was equivalent to the specification. Well-formedness criteria were used to supply additional constraints on operations beyond what was defined by the abstract syntax. The first step in the process, a <b>formal</b> <b>specification</b> for Ada, had already been started by five students at DTU in 1980 as part of their master's theses.|$|E
5000|$|A <b>formal</b> <b>specification</b> [...] {{and source}} code [...] are {{available}} online.|$|E
5000|$|Prototype Verification System (PVS), a {{mechanized}} {{environment for}} <b>formal</b> <b>specification</b> and verification.|$|E
40|$|An {{appropriate}} {{approach for}} translating UML to B <b>formal</b> <b>specifications</b> {{allows one to}} use UML and B jointly in an unified, practical and rigorous software development. We can formally analyse UML specifications via their derived B <b>formal</b> <b>specifications.</b> This point is significant because B support tools like AtelierB are available. We can also use UML specifications {{as a tool for}} building B specifications, so the development of B specifications become easier...|$|R
40|$|Abstract—In general, {{system testing}} and {{verification}} {{should be conducted}} with respect to <b>formal</b> <b>specifications.</b> However, the development of <b>formal</b> <b>specifications</b> is a challenging and error prone task, even for experts. This is especially true when considering complex spatio-temporal requirements in real-time embedded systems, mixed-signal circuits, or more generally, software-controlled physical systems. In this work, we present a framework for the elicitation and debugging of formal spec-ifications. The elicitation of <b>formal</b> <b>specifications</b> is handled through a graphical user interface. The debugging algorithm checks inconsistent and wrong specifications. Namely, it detects validity, redundancy and vacuity issues in <b>formal</b> <b>specifications</b> developed in a fragment of Metric Interval Temporal Logic (MITL). The algorithm informs system engineers on any issues in their specifications. This improves the specification elicitation process and, ultimately, the testing and verification process. Finally, we present experimental results on specifications that typically appear in Cyber Physical Systems (CPS) applications. Application of our specification debugging tool on user derived requirements shows that the aforementioned issues are common. Therefore, the algorithm can help developers to correct their specifications and avoid wasted effort on checking incorrect requirements. I...|$|R
40|$|AbstractThese {{notes are}} {{personal}} reflections, stemming from attempts {{to understand the}} sources of problems and successes {{in the application of}} work on <b>formal</b> <b>specifications.</b> Our intent is to provoke thought about the nature and value of work in the area; not to provide a set of well-tested results. Rather than focusing on yet another specification language, we have tried to take a broad view of the role of <b>formal</b> <b>specifications</b> in the program development process...|$|R
