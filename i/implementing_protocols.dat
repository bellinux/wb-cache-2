35|3004|Public
25|$|Similarly to C# and in {{contrast}} to most other OO languages, Swift offers built-in support for objects using either pass-by-reference or pass-by-value semantics, the former using the class declaration and the latter using struct. Structs in Swift have almost all the same features as classes: methods, <b>implementing</b> <b>protocols,</b> and using the extension mechanisms. For this reason, Apple terms all data generically as instances, versus objects or values. Structs do not support inheritance, however.|$|E
25|$|In {{addition}} to financial assessment, probability {{can be used}} to analyze trends in biology (e.g. disease spread) as well as ecology (e.g. biological Punnett squares). As with finance, risk assessment {{can be used as a}} statistical tool to calculate the likelihood of undesirable events occurring and can assist with <b>implementing</b> <b>protocols</b> to avoid encountering such circumstances. Probability is used to design games of chance so that casinos can make a guaranteed profit, yet provide payouts to players that are frequent enough to encourage continued play.|$|E
5000|$|Similarly to C# and in {{contrast}} to most other OO languages, Swift offers built-in support for objects using either pass-by-reference or pass-by-value semantics, the former using the [...] declaration and the latter using [...] Structs in Swift have almost all the same features as classes: methods, <b>implementing</b> <b>protocols,</b> and using the extension mechanisms. For this reason, Apple terms all data generically as instances, versus objects or values. Structs do not support inheritance, however.|$|E
50|$|Lightweight, easy to <b>implement</b> <b>protocol.</b>|$|R
5000|$|... pimd, <b>implementing</b> <b>Protocol</b> Independent Multicast (PIM-SSM) for Source-specific {{multicast}} ...|$|R
5000|$|... libtorrent <b>implemented</b> <b>protocol</b> {{encryption}} in v0.13 {{released on}} 10th December 2011.|$|R
50|$|In {{addition}} to financial assessment, probability {{can be used}} to analyze trends in biology (e.g. disease spread) as well as ecology (e.g. biological Punnett squares). As with finance, risk assessment {{can be used as a}} statistical tool to calculate the likelihood of undesirable events occurring and can assist with <b>implementing</b> <b>protocols</b> to avoid encountering such circumstances. Probability is used to design games of chance so that casinos can make a guaranteed profit, yet provide payouts to players that are frequent enough to encourage continued play.|$|E
50|$|The Windows Sockets API {{specification}} defines two interfaces: the API used by application developers, and the SPI, {{which provides}} a means for network software developers to add new protocol modules to the system. Each interface represents a contract. The API guarantees that a conforming application will function correctly with a conforming protocol implementation from any network software vendor. The SPI contract guarantees that a conforming protocol module may be added to Windows and will thereby be usable by an API-compliant application. Although these contracts were important when Windows Sockets was first released, since network environments required multi-protocol support (see above) they are now of only academic interest. Included in the Windows Sockets API version 2.0 are functions to use IPX/SPX, although the protocol was all but obsolete already at the time WSA 2.0 shipped. Microsoft has shipped the TCP/IP protocol stack with all recent versions of Windows, {{and there are no}} significant independent alternatives. Nor has there been significant interest in <b>implementing</b> <b>protocols</b> other than TCP/IP.|$|E
40|$|Learn {{about the}} unique {{challenges}} in wireless networking » Starting point is “regular ” wired networks � Gain {{an understanding of}} wireless technologies at the physical, MAC, and higher layers » Focus is on the wireless protocol layer � Get experience in working with wireless networks » <b>Implementing</b> <b>protocols,</b> algorithms » Measurements of wireless networks � Get a broad view of the ongoing research in the wireless domain » Focus on the protocol leve...|$|E
30|$|In this section, we {{evaluate}} {{the performances of}} the <b>implemented</b> <b>protocols</b> for various numbers of primary users in the environment.|$|R
50|$|Mobile device SDKs: Standards-based {{software}} development kits (SDKs) for <b>implementing</b> <b>protocol</b> stack technologies for infrared, Bluetooth, data synchronization and device management.|$|R
5000|$|PPPoX (PPP over X) designates {{a family}} of {{encapsulating}} communications <b>protocols</b> <b>implementing</b> Point-to-Point <b>Protocol.</b>|$|R
40|$|Citizen science {{describes}} the diverse {{ways in which}} the public participates in scientific investigations. Participation covers a spectrum from sending observations to a project coordinator to designing, <b>implementing</b> <b>protocols,</b> analysing and sharing findings. The popularity of citizen science both for educational and scientific purposes has grown in recent decades. Community volunteers now participate in diverse programmes that investigate the effects of climate change on biota, evolutionary processes, invasive species ecology, and changes in water and air quality (Figure 1) ...|$|E
40|$|This {{thesis is}} about the {{efficiency}} of protocol layering. It examines the technique of protocol layering in an abstract way and finds two major sources of inefficiency in protocol implementations which are caused by the imposition on them of a layered structure. The conventional approach to making layered protocol' implementations run efficiently m for avoiding the sources of inefficiency discussed herein [...] are all independent of the protocol specification, and thus all decrease {{the value of the}} protocol specification as a guide for <b>implementing</b> <b>protocols...</b>|$|E
40|$|We {{identify}} three {{problems with}} current techniques for <b>implementing</b> <b>protocols</b> among threads, which complicate and impair the scalability of multicore software development: implementing syn-chronization, implementing coordination, and modularizing protocols. To mend these deficiencies, we {{argue for the}} use of domain-specific languages (DSL) based on existing models of concurrency. To demonstrate the feasibility of this proposal, we explain how to use the model of concurrency Reo as a high-level protocol DSL, which offers appropriate abstractions and a natural separation of protocols and computations. We describe a Reo-to-Java compiler and illustrate its use through examples. ...|$|E
30|$|Evaluation of the {{incidence}} and adherence of the ICU team to an <b>implemented</b> <b>protocol</b> for prevention of central venous catheter- related bloodstream infection (CVCRBI).|$|R
3000|$|Studies {{that merely}} {{reported}} a visual change in NSD as an incidental finding {{and did not}} <b>implement</b> <b>protocols</b> to methodically measure nasal septum pre- and post-expansion were also excluded [...]...|$|R
40|$|This bachelor's thesis {{describes}} {{simulation of}} network using tools Packet Tracer and OMNeT++. Models of network are created according to design guides by Cisco company, which use routing protocols RIP, OSPF and redistribution. In {{order to provide}} full functionality of models in OMNeT++ {{it is necessary to}} <b>implement</b> <b>protocol</b> RIP and redistribution from protocol OSPF to protocol RIP. Practical usage of tools is demonstrated by simulations of accessibility and stability of network. Thesis investigates results of simulations and usage of both tools for simulation of networks. We use design guides, which are destined to design of real networks, and <b>implement</b> <b>protocol</b> according to standard RFC, therefore we suppose that this thesis will have practical usage for analysis and simulation of company's and academical networks...|$|R
40|$|Abstract — The {{elliptic}} curve crypto systems {{are used for}} <b>implementing</b> <b>protocols</b> such as ECDSA digital signature scheme, EC Elgamal Encryption/ Decryption scheme, Diffie-Hellman key exchange scheme and so on. This paper analyzes the {{elliptic curve}} operations of the ECC protocol ECDSA. The steps involved in ECDSA are key-pair generation, signature generation and signature verification. The digital signature is typically created using the hash function. The transmitter sends the encrypted data along with the signature to the receiver. The receiver who knows about the senders public key can authenticate the signature using his private key. Thereby ECC ensures the secured data communication. The proposed algorithm is highly parallelizable and well adapted to VLSI implementation of elliptic curve crypto systems...|$|E
40|$|International audienceThis work {{considers}} {{the problem of}} communication in dense and large scale wireless networks composed of resource-limited nodes. In this kind of networks, a massive amount of data is becoming increasingly available, and consequently <b>implementing</b> <b>protocols</b> achieving error-free communication channels constitutes an important challenge. Indeed, {{in this kind of}} networks, the prevention of message conflicts and message collisions is a crucial issue. In terms of graph theory, solving this issue amounts to solve the distance- 2 coloring problem in an arbitrary graph. The paper presents a distributed algorithm providing the processes with such a coloring. This algorithm is itself collision-free and conflict-free. It is particularly suited to wireless networks composed of nodes with communication or local memory constraints...|$|E
40|$|The use of {{multiple}} wireless channels has been advocated as one approach for enhancing network capacity. In many scenarios, hosts will be equipped with fewer radio interfaces than available channels. Under these scenarios, several protocols, which require interfaces to switch frequently, have been proposed. However, <b>implementing</b> <b>protocols</b> which require frequent interface switching in existing operating systems is non-trivial. In this paper, we identify the features needed in the operating system kernel for supporting frequent interface switching. We present a new channel abstraction module to support frequent interface switching. We identify modifications to interface device driver to reduce switching delay. The channel abstraction module, and an example multi-channel protocol that uses the module, have been implemented in a multi-channel multi-interface testbed. We also present results to quantify the overheads of frequent switching...|$|E
50|$|Simplicity when <b>implementing</b> {{reliable}} <b>protocols</b> over Xcast.|$|R
50|$|Very few display devices <b>implemented</b> this <b>protocol.</b>|$|R
30|$|During {{the audit}} period {{we had a}} low {{incidence}} of CVCRBI. Compliance with <b>implemented</b> <b>protocol</b> was very high. During the same period the ICU mortality rate decreased. Although direct correlation can't be made, we might speculate, {{that the incidence of}} CVCRBI's could aid, in same way, to this decrease in mortality.|$|R
40|$|The current Internet {{is based}} on an {{architecture}} created decades ago. Today however, the use of mobile devices and wireless networks present new challenges for location management and security. Therefore many alternative solutions have been engineered. This paper introduces and compares three mobility <b>implementing</b> <b>protocols,</b> each from a different layer. The purpose of the comparison is to determine which layer - three, three and a half, or four - would be best suited for mobility. The chosen protocols are Mobile IPv 6 (MIPv 6), Host Identity Payload (HIP), and Stream Control Transmission Protocol (SCTP) respectively. I want to emphasize that there is really no straightforward solution to the choice of layer for mobility. On the contrary, approaches used in different layers often complement rather than exclude each other...|$|E
40|$|The {{trade-off}} between protocol {{structure and}} protocol performance is usually {{treated as a}} balancing act, with improvements on one side coming {{at the expense of}} the other side. The project described in this paper treats the structure/ performance trade-off as an obstacle and eliminates it with a combination of structuring and compilation techniques. The structuring techniques are based on data-stream computations and give the protocol developer a convenient way of arranging and implementing protocol function. The compilation techniques remove the inefficiencies introduced by the structuring techniques and further tailor the code to the host system, providing a high performance implementation. 1 Introduction The complexity of designing and <b>implementing</b> <b>protocols</b> is best dealt with by mechanisms such as abstraction and modularization. Unfortunately, these mechanisms extract an execution cost in the form of run-time overhead (because of boundary crossings, for example) and lost optimizat [...] ...|$|E
40|$|Real-time upcalls (RTUs) are an {{operating}} systems mechanism {{that can be}} used by applications to efficiently schedule code segments (or handlers) that must execute periodically. While the mechanism was conceived to support protocol processing with quality-of-service guarantees for networked multimedia applications it is general enough to be applicable in other domains like real-time image processing. Until now real-time threads have been the only mechanism for <b>implementing</b> <b>protocols</b> in user space with QoS guarantees. The RTU mechanism avoids the implementation complexity of the thread based approach while retaining its ability to ensure real-time behavior. In addition, our design simplifies protocol code, improves performance, and can be ported to most systems. A key feature of RTU scheduling is the pre-emption scheme that exploits the iterative nature of protocol processing by allowing an RTU to yield the CPU by returning from the invocation. This obviates the need for RTU handlers to [...] ...|$|E
40|$|Distributed Objects Protocol Layer (DOPL) {{software}} system <b>implements</b> <b>protocol</b> for communications among software objects programmed in C++ computer language. DOPL is application-program interface (API). Enables {{communication of data}} without regard for which specific computer(s) and operating system(s) is (are) in use. No extension of the C++ language necessary for use of DOPL...|$|R
5000|$|Test Studio: A {{tool that}} helps {{software}} developers <b>implement</b> testing <b>protocols.</b>|$|R
40|$|We {{discuss the}} design of multi-hop access {{networks}} with multiple gateways that supports medical response to disasters. We examine and <b>implement</b> <b>protocols</b> to ensure high bandwidth, robust, self-healing and secure wireless multi-hop access networks for extreme conditions. Address management, path setup, gateway discovery and selection protocols are described. Future directions and plans are also considered...|$|R
40|$|A {{composite}} protocol is {{a collection}} of single-function components arranged in an orderly fashion to implement a network communications capability. This thesis presents a template for the design of protocol components. Components are specified in terms of finite state machines, memory objects used and formal properties provided to packets. The linear stacking approach is used as the composition technique to build composite protocols from components. The specification methodology for components has been developed to facilitate formal reasoning of logical correctness of protocols, as is the choice of the composition technique. <b>Implementing</b> <b>protocols</b> as a collection of components has other benefits: better scope for reuse, quick development of variants of protocols and customization of protocols to application requirements. Ensemble, a group communication system, has been chosen as the basis for implementing a framework for composite protocols. The Ensemble system has been adapted for the purposes of a general protocol framework and a state machine executor has been implemented. The functional components of IP and UDP hav...|$|E
40|$|After {{some years}} {{of using a}} {{classical}} approach to teach network programming (C and BSD sockets), we decided to try a different approach, based on Ada as the programming language and Lower Layer as the communication library. After two years of using this new approach in several undergraduate courses, we present here our experience and the lessons learned. In short, the new approach has proven to offer an environment easier to study, to understand, and to use for <b>implementing</b> <b>protocols.</b> Some of these advantages are due to the benefits of using Ada, while others are due to the cleaner interface of the Lower Layer library [...] -if compared to BSD sockets. 1 Introduction Undergraduate students attending courses related to Computer Networks in our University are required to do several practical assignments. Our classical approach {{for the design of}} the assignments of the first of these courses was based on programming on top of BSD sockets [LFJ + 86], using C [KR 88]. We have used this [...] ...|$|E
40|$|Abstract. Interaction {{protocols}} {{are widely}} recognized as an essential mechanism for coordination within multiagent systems. There is thus a need for coordination models for specifying, validating, and <b>implementing</b> <b>protocols,</b> possibly open and concurrent, efficiently and reliably. This paper proposes such a model, which considers protocols as resources and each conversation among agents following the rules of a protocol as a well-identified process. To this end, {{a new kind of}} middle-agent, called Moderator, is introduced. A Moderator is in charge of monitoring a conversation so that it progresses according to the protocol rules, and provides agents with services to ease their involvement in the conversation. This model fits the organization-centered view of multi-agent systems as it strictly distinguishes the agent-level and the organization-level concerns with regard to interaction. In addition, the paper shows that this model is supported by a High-Level Petri Net language that covers all the steps of protocol engineering: design, validation, implementation. This paper presents this Moderator Coordination Model along four related dimensions: a conceptual model of protocols,...|$|E
50|$|It <b>implements</b> XIM <b>protocol,</b> and has GTK+ and Qt {{input method}} modules.|$|R
50|$|The Integrated Vehicle Health Management system, {{also used}} by NASA, on board an {{aircraft}} must process and interpret data {{taken from the}} various sensors on the aircraft. The system {{needs to be able}} to determine the structural integrity of the aircraft. The system also needs to <b>implement</b> <b>protocols</b> in case of any damage taken the vehicle.|$|R
5000|$|The rsync remote file synchronizer, {{which uses}} zlib to <b>implement</b> {{optional}} <b>protocol</b> compression.|$|R
