67|14|Public
25|$|The {{sequential}} {{subset of}} the Erlang language supports <b>eager</b> <b>evaluation,</b> single assignment, and dynamic typing.|$|E
25|$|Whether a term is {{normalising}} or not, and {{how much}} work {{needs to be done}} in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between <b>eager</b> <b>evaluation</b> and lazy evaluation.|$|E
50|$|The {{opposite}} of lazy evaluation is <b>eager</b> <b>evaluation,</b> sometimes known as strict evaluation. <b>Eager</b> <b>evaluation</b> is the evaluation strategy employed in most programming languages.|$|E
40|$|AbstractProgramming {{languages}} such as ML provide function {{calls with}} pattern matching. For each function, {{there is a}} given set of patterns for arguments with the corresponding definition of the function. Cases corresponding to different patterns of a given function may not be exclusive, and often a priority rule (typically {{the order of the}} program text) is followed to disambiguate overlapping cases. In this paper, term rewriting systems are taken as models for function calls with pattern matching. It is shown that, in the useful set of constructors based linear systems, all priority rules are essentially equivalent. Moreover the translation from one rule to another one may be mechanically done. These results hold both for lazy and <b>eager</b> <b>evaluations...</b>|$|R
40|$|A {{medium sized}} algebra system {{supporting}} rational functions and some elementary functions, which {{is written in}} the purely functional subset of LISP is described. This is used to investigate the practicability of writing systems in a no-side effect, no property list, pure style. In addition, using the experimental LISP system in Bath that allows for full environment closures, ways have been discovered in which <b>eager</b> (applicative) <b>evaluation</b> and lazy (normal) evaluation strategies {{can be applied to}} computer algebra. The system is demonstrated on some well known sample programs...|$|R
5000|$|The -calculus is a {{universal}} model of computation. This was first observed by Milner in his paper [...] "Functions as Processes", in which he presents two encodings of the lambda-calculus in the -calculus. One encoding simulates the <b>eager</b> (call-by-value) <b>evaluation</b> strategy, the other encoding simulates the normal-order (call-by-name) strategy. In both of these, the crucial insight is the modeling of environment bindings - for instance, [...] " [...] is bound to term [...] " [...] - as replicating agents that respond to requests for their bindings by sending back {{a connection to the}} term [...]|$|R
50|$|In {{computer}} programming, <b>eager</b> <b>evaluation</b> or {{greedy evaluation}} is the evaluation strategy used by most traditional programming languages. In <b>eager</b> <b>evaluation,</b> an expression is evaluated {{as soon as}} it is bound to a variable. An alternative to <b>eager</b> <b>evaluation</b> is lazy evaluation, where expressions are evaluated only when a dependent expression is evaluated.|$|E
50|$|As {{does the}} Haskell {{functional}} language, Alice also provides facilities to allow using a lazy evaluation strategy in programs, versus the traditional <b>eager</b> <b>evaluation</b> strategy of Standard ML. While Haskell uses the lazy model by default, Alice uses an <b>eager</b> <b>evaluation</b> model by default, needing an explicit programming statement for a computation to evaluate lazily.|$|E
50|$|The {{sequential}} {{subset of}} the Erlang language supports <b>eager</b> <b>evaluation,</b> single assignment, and dynamic typing.|$|E
40|$|International audienceSynchronous Elasticization {{converts}} {{an ordinary}} clocked circuit into Latency-Insensitive (LI) design. The Synchronous Elastic Flow (SELF) is an LI protocol {{that can be}} implemented with <b>eager</b> or lazy <b>evaluation</b> in the data steering network. Compared to lazy implementations, eager SELF designs have no combinational cycles and can have a performance advantage, but consume more area and power. The design space of lazy SELF protocols is evaluated and verified. Several new designs are mapped to hybrid eager/lazy implementations that retain the performance advantage of the eager design but have power advantages of lazy implementations...|$|R
40|$|We {{propose a}} {{framework}} {{for the evaluation of}} implicitly parallel functional programs on message passing multiprocessors with special emphasis on the issue of load bounding. The model is based on a new encoding of the l-calculus in Milner's p-calculus and combines lazy <b>evaluation</b> and <b>eager</b> (parallel) <b>evaluation</b> in the same framework. The p-calculus encoding serves as the specification of a more concrete compilation scheme mapping a simple functional language into a message passing, parallel program. We show how and under which conditions we can guarantee successful load bounding based on this compilation scheme. Finally we discuss the architectural requirements for a machine to support our model efficiently and we present a simple RISC-style processor architecture which meets those criteria. 3 Acknowledgments Many people have had profound influence on this thesis and I want to pay tribute to some of them here. To my supervisor, Tony Davie, for his willingness to supervise what start [...] ...|$|R
40|$|Real-time {{processing}} systems are typically characterised by high processing rates, high reliability, and high input/output rates. Functional programming, {{derived from the}} lambda calculus, is a formal basis for computation which facilitates the design of well-structured, highly reliable programs, and also enables a rigorous implementation on parallel hardware to provide high processing rates and I/O bandwidth. The principles of CTDNet 2, a new reduction mechanism for real-time applications based on graph reduction, and a combination of <b>eager</b> and lazy <b>evaluation,</b> are presented. CTDNet 2 has been designed with real-time processing in mind, and is intended for highly parallel multiprocessor implementation. It is particularly suitable for transputer networks...|$|R
5000|$|Lazy {{suspensions}} - this module implements the suspensions {{necessary for}} lazy evaluation (as opposed to <b>eager</b> <b>evaluation).</b>|$|E
50|$|All {{reductions}} {{that can}} be applied have been applied. This is the result obtained from applying <b>eager</b> <b>evaluation.</b>|$|E
5000|$|... uses <b>eager</b> <b>evaluation</b> and {{includes}} efficient libraries for floating-point calculations, linear algebra, random number generation, fast Fourier transforms and regular expression matching.|$|E
40|$|This paper {{describes}} {{a new perspective}} on a fundamental algorithm of threedimensional computer graphics namely zbuering An imple mentation of the zbuer method in a lazy functional language behaves in a quite dierent manner to the traditional imperative counterpart The main result {{of this paper is to}} show that the lazy zbuer is a scanline method The eective dierence between scanline methods and zbuers is one of order of evaluation A hybrid algorithm with properties common to both zbuer and scanline methods is also described In section we describe the implementation of a simple zbuer algorithm in a functional language 	 We then section examine its behaviour under <b>eager</b> and lazy <b>evaluation</b> schemes	 In this section we brie y describe some o...|$|R
40|$|Since {{the birth}} of XML, the {{processing}} of XML query languages like XQuery/XQueryP has been widely researched in the academic and industrial communities. Most of the approaches consider XQuery as a declarative query language similar to SQL, for which the iterator-based (stream-based), lazy evaluation processing strategy can be applied. The processing is combined with XML indexing, materialized view, XML view query rewrite over source data. An alternative approach views XQuery as a procedural programming language associated with <b>eager,</b> step-based <b>evaluation,</b> where each expression is fully evaluated {{by the end of}} the corresponding expression execution step. Usually, this approach uses a virtual machine running byte-code for compiled programs. In this paper, we share our experience of building a unified XQuery engine for the Oracle XML DB integrating both approaches. The key contribution of our approach is that the unified XQuery processor integrates both declarative and imperati ve XQuery/XQueryP processing paradigms. Furthermore, the processor is designed with a clean separation between the logical XML data model and the physical representation so that it can be optimized with various physical XML storages and data index and view models. We also discuss the challenges in our approach and our overall vision of the evolution of XQuery/XQueryP processors. ...|$|R
40|$|We {{propose a}} {{theoretical}} framework for adding assignments and dynamic data to functional languages without violating their semantic properties. This differs from semi-functional languages like Scheme and ML in that values of expressions remain static and side-effect-free. A new form of abstraction called observer is designed to encapsulate state-oriented computation from the remaining purely applicative computation. The type system ensures that observers are combined linearly, allowing an implementation {{in terms of a}} global store. The utility of this extension is in manipulating shared dynamic data embedded in data structures. Evaluation of well-typed programs is Church-Rosser. Thus, programs produce the same results whether an <b>eager</b> or lazy <b>evaluation</b> order is used (assuming termination). A simple, sound logic permits reasoning about well-typed programs. The benefits of this work include greater expressive power and efficiency (compared to applicative languages), while retaining simplicity of reasoning...|$|R
50|$|Imperative {{programming}} languages, {{where the}} order of execution is implicitly defined by {{the structure of the}} source code, almost always use <b>eager</b> <b>evaluation.</b>|$|E
5000|$|Under Church encoding, <b>eager</b> <b>evaluation</b> of {{operators}} maps {{to strict}} evaluation of functions; for this reason, strict evaluation {{is sometimes called}} [...] "eager".|$|E
50|$|Notice that {{evaluation}} {{now only}} requires four steps. Outermost graph reduction {{is referred to}} as lazy evaluation and innermost graph reduction {{is referred to as}} <b>eager</b> <b>evaluation.</b>|$|E
40|$|AbstractIn {{recent years}} much {{interest}} {{has been shown}} in a class of functional languages including HASKELL, lazy ML, SASL/KRC/MIRANDA, ALFL, ORWELL, and PONDER. It has been seen that their expressive power is great, programs are compact, and program manipulation and transformation is much easier than with imperative languages or more traditional applicative ones. Common characteristics: they are purely applicative, manipulate trees as data objects, use pattern matching both to determine control flow and to decompose compound data structures, and use a “lazy” evaluation strategy. In this paper we describe a technique for data flow analysis of programs in this class by safely approximating the behavior of a certain class of term rewriting systems. In particular we obtain “safe” descriptions of program inputs, outputs and intermediate results by regular sets of trees. Potential applications include optimization, strictness analysis and partial evaluation. The technique improves earlier work because of its applicability to programs with higher-order functions, and with either <b>eager</b> or lazy <b>evaluation.</b> The technique addresses the call-by-name aspect of laziness, but not memoization...|$|R
40|$|This {{thesis is}} {{concerned}} with extending the correspondence between intuitionistic logic and functional programming to include assignments and dynamic data. We propose a theoretical framework for adding these imperative features to functional languages without violating their semantic properties. We also describe a constructive programming logic that embodies the principles for reasoning about the extended language. We present an abstract formal language, called Imperative Lambda Calculus (ILC), that extends the typed lambda calculus with imperative programming features, namely references and assignments. The language shares with typed lambda calculus important properties such as the Church-Rosser property and strong normalization. Thus, programs produce the same results with <b>eager</b> and lazy <b>evaluation</b> orders. ILC permits mutable data structures such as arrays, linked lists, trees, and graphs to be constructed and used. Shared values may be updated destructively rather than by copying. This permits pure functional languages to have efficient implementations of problems such as topological sort, graph reduction, and unification. We describe the logical symmetries that underlie ILC by exhibiting a constructive logic, called Observation Type Theory (OTT), for which ILC forms the language of constructions...|$|R
40|$|We {{refer to}} {{strategies}} setting {{the objective of}} a computation step rather than to <b>evaluation</b> strategies (as <b>eager</b> or lazy <b>evaluations).</b> We use these strategies to define semantics of a system starting from its elementary operational entities, and then combining them. The tactics of a strategy are given by rewriting steps. While a strategy is {{at a higher level}} and defines ”what is the goal ” of a computation, the tactics are at a lower level and tell ”how it is possible to reach the goal”. We use rewriting systems as a general model of computing. In this framework we give an operational semantics of the strategic transitions in terms of tactical rewritings. The approach is inspired by a new model of computation given by membrane systems. We define the strategy semantics for membrane systems involving the maximal parallel rewriting and priorities. We show that strategies are not powerful enough to define alone the semantics of membrane systems involving promoters. This is possible when we encode the state of the membrane in a richer structure. Key words: strategic transitions, tactical rewritings, operational semantics, membrane computing...|$|R
5000|$|Under Church encoding, <b>eager</b> <b>evaluation</b> of {{operators}} maps {{to strict}} evaluation of functions; for this reason, strict evaluation {{is sometimes called}} [...] "eager". Most existing programming languages use strict evaluation for functions.|$|E
50|$|All {{evaluation}} strategy which ends on a purely functional programs returns the same result. In particular, it {{ensures that the}} programmer {{does not have to}} consider in which order programs are evaluated, since <b>eager</b> <b>evaluation</b> will return the same result as lazy evaluation. However, it is still possible that an <b>eager</b> <b>evaluation</b> may not terminate while the lazy evaluation of the same program halts.An advantage of this is that lazy evaluation can be much easily implemented; as all expressions will return the same result at any moment (regardless of program state), their evaluation can be delayed as much as necessary.|$|E
50|$|This {{mathematical}} {{definition is}} structured {{so that it}} represents the result, and {{not the way it}} gets calculated. However the result may be different between lazy and <b>eager</b> <b>evaluation.</b> This difference is described in the evaluation formulas.|$|E
40|$|The {{advantage}} of a non-strict, purely functional language such as Haskell lies in its clean equational semantics. However, lazy implementations of Haskell fall short: they cannot express tail recursion gracefully without annotation. We describe resource-bounded hybrid evaluation, a mixture of strict and lazy evaluation, and its realization in Eager Haskell. From the programmer's perspective, Eager Haskell is simply another implementation of Haskell with the same clean equational semantics. Iteration can be expressed using tail recursion, without the need to resort to program annotations. Under hybrid evaluation, computations are ordinarily executed in program order just as in a strict functional language. When particular stack, heap, or time bounds are exceeded, suspensions are generated for all outstanding computations. These suspensions are re-started in a demand-driven fashion from the root. The Eager Haskell compiler translates Ac, the compiler's intermediate representation, to efficient C code. We use an equational semantics for Ac to develop simple correctness proofs for program transformations, and connect actions in the run-time system to steps in the hybrid evaluation strategy. (cont.) The focus of compilation is efficiency in the common case of straight-line execution; the handling of non-strictness and suspension are left to the run-time system. Several additional contributions have resulted from the implementation of hybrid <b>evaluation.</b> <b>Eager</b> Haskell is the first eager compiler to use a call stack. Our generational garbage collector uses this stack as an additional predictor of object lifetime. Objects above a stack watermark {{are assumed to be}} likely to die; we avoid promoting them. Those below are likely to remain untouched and therefore are good candidates for promotion. To avoid eagerly evaluating error checks, they are compiled into special bottom thunks, which are treated specially by the run-time system. The compiler identifies error handling code using a mixture of strictness and type information. This information is also used to avoid inlining error handlers, and to enable aggressive program transformation in the presence of error handling. by Jan-Willem Maessen. Thesis (Ph. D.) [...] Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science, 2002. Includes bibliographical references (p. 208 - 220). This electronic version was submitted by the student author. The certified thesis is available in the Institute Archives and Special Collections...|$|R
5000|$|The {{result may}} be {{different}} depending on the strategy used. <b>Eager</b> <b>evaluation</b> will apply all reductions possible, leaving the result in normal form, while lazy evaluation will omit some reductions in parameters, leaving the result in [...] "weak head normal form".|$|E
50|$|Whether a term is {{normalising}} or not, and {{how much}} work {{needs to be done}} in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between <b>eager</b> <b>evaluation</b> and lazy evaluation.|$|E
5000|$|The {{operational}} semantics of ISWIM are defined using Landin's SECD machine and use call-by-value, that is <b>eager</b> <b>evaluation.</b> A goal of ISWIM {{was to look}} more like mathematical notation, so Landin abandoned ALGOL's semicolons between statements and [...] blocks {{and replaced them with}} the off-side rule and scoping based on indentation.|$|E
5000|$|Strict {{programming}} {{languages are}} {{often associated with}} <b>eager</b> <b>evaluation,</b> and non-strict languages with lazy evaluation, but other evaluation strategies are possible in each case. The terms [...] "eager programming language" [...] and [...] "lazy programming language" [...] are often used as synonyms for [...] "strict programming language" [...] and [...] "non-strict programming language" [...] respectively.|$|E
5000|$|Oz uses <b>eager</b> <b>{{evaluation}}</b> by default, but {{lazy evaluation}} is possible. Below, {{the fact is}} only computed when value of X is needed to compute the value of Y.fun lazy {Fact N} if N =< 0 then 1 else N*{Fact N-1} endendlocal X Y in X = {Fact 100} [...] Y = X + 1end ...|$|E
50|$|The Church-Rosser theorem {{also holds}} for many {{variants}} of the lambda calculus, {{such as the}} simply-typed lambda calculus, many calculi with advanced type systems, and Gordon Plotkin's beta-value calculus. Plotkin also used a Church-Rosser theorem {{to prove that the}} evaluation of functional programs (for both lazy evaluation and <b>eager</b> <b>evaluation)</b> is a function from programs to values (a subset of the lambda terms).|$|E
50|$|One {{advantage}} of <b>eager</b> <b>evaluation</b> {{is that it}} eliminates the need to track and schedule the evaluation of expressions. It also allows the programmer to dictate the order of execution, {{making it easier to}} control when sub-expressions (including functions) within the expression will be evaluated, as these sub-expressions may have side effects that will affect the evaluation of other expressions.|$|E
5000|$|F# is an expression-based {{language}} using <b>eager</b> <b>evaluation.</b> Every {{statement in}} F#, including [...] expressions, [...] expressions and loops, is a composable expression with a static type. Functions and expressions {{that do not}} return any value have a return type of [...] F# uses the [...] keyword for binding values to a name. For example:let x = 3 + 4binds the value [...] to the name [...]|$|E
