10|14|Public
2500|$|It is {{possible}} to change the mode of operation for the FIRQ interrupt. Instead of stacking the PC and CC registers (normal 6809 behavior) the FIRQ interrupt can be set to stack the entire register set, as the IRQ interrupt does. In addition, the 6309 has two possible trap modes, one for an <b>illegal</b> <b>instruction</b> fetch and one for division by zero. The <b>illegal</b> <b>instruction</b> fetch is not maskable, and many TRS-80 Color Computer users reported that their 6309's were [...] "buggy" [...] when in reality it was an indicator of enhanced and unknown features.|$|E
2500|$|The [...] "exception table" [...] ({{interrupt}} vector table interrupt vector addresses) {{is fixed}} at addresses 0 through 1023, permitting 256 32-bit vectors. The first vector (RESET) consists of 2 vectors, namely the starting stack address, and the starting code address. Vectors 3 through 15 {{are used to}} report various errors: bus error, address error, <b>illegal</b> <b>instruction,</b> zero division, CHK and CHK2 vector, privilege violation (to block privilege escalation), and some reserved vectors that became line 1010 emulator, line 1111 emulator, and hardware breakpoint. Vector 24 starts the real interrupts: spurious interrupt (no hardware acknowledgement), and level 1 through level 7 autovectors, then the 16 TRAP vectors, then some more reserved vectors, then the user defined vectors.|$|E
5000|$|FireTOS {{includes}} 68K emulation {{based on}} an <b>illegal</b> <b>instruction</b> exception handler and CF68KLib ...|$|E
50|$|A {{disturbed}} {{instruction pointer}} {{can lead to}} serious errors, such as an undefined jump to an arbitrary point in the memory, where <b>illegal</b> <b>instructions</b> are read. The state of the system will be undefined. IP errors can be handled by use of software based solutions such as function tokens and an NOP slide(s).|$|R
5000|$|... #Caption: Nico Rosberg {{finished}} third for Mercedes {{after receiving a}} ten-second time penalty for <b>illegal</b> radio <b>instructions</b> from his team.|$|R
50|$|Many {{countries}} {{passed laws}} impeding the manufacture {{and promotion of}} contraceptives. In spite of these restrictions, condoms were promoted by traveling lecturers and in newspaper advertisements, using euphemisms in places where such ads were <b>illegal.</b> <b>Instructions</b> {{on how to make}} condoms at home were distributed in the United States and Europe. Despite social and legal opposition, {{at the end of the}} 19th century the condom was the Western world's most popular birth control method.|$|R
5000|$|... #Caption: One {{version of}} the Sad Mac icon, this one {{indicating}} that an <b>illegal</b> <b>instruction</b> occurred.|$|E
5000|$|It is {{possible}} to change the mode of operation for the FIRQ interrupt. Instead of stacking the PC and CC registers (normal 6809 behavior) the FIRQ interrupt can be set to stack the entire register set, as the IRQ interrupt does. In addition, the 6309 has two possible trap modes, one for an <b>illegal</b> <b>instruction</b> fetch and one for division by zero. The <b>illegal</b> <b>instruction</b> fetch is not maskable, and many TRS-80 Color Computer users reported that their 6309's were [...] "buggy" [...] when in reality it was an indicator of enhanced and unknown features.|$|E
50|$|Many processors, {{such as the}} Motorola 680x0, {{feature a}} {{hardware}} trap upon encountering an <b>illegal</b> <b>instruction.</b> A correct instruction, defined in the trap vector, is executed, rather than the random one. Traps can handle a larger range errors than function tokens and NOP slides. Supplementary to illegal instructions, hardware traps securely handle memory access violations, overflows, or a division by zero.|$|E
50|$|While most <b>illegal</b> <b>instructions</b> have useless or even highly {{undesirable}} effects (such as crashing the computer), a few might by accident {{do something that}} can be useful in certain situations. Such instructions were sometimes exploited in computer games of the 1970s and 1980s to speed up certain time-critical sections. Another common use of them was in the ongoing battle between copy protection implementations and cracking. Here, they were a form of security through obscurity, and their secrecy usually did not last very long.|$|R
40|$|New Features: Cleaner API: Ability {{to handle}} both doubles and floats at runtime Runtime feature control - {{the output of}} all the codes can now be changed at runtime. Previously, even to simply output ravg {{required}} a complete recompilation of the package. Automatic CPU instruction set support detection: no more <b>illegal</b> <b>instructions</b> and runtime errors Future-compatible: The libraries should hopefully be binary compatible with future versions. (This will be changed to backwards-compatible in the future Documentation: Read all of the API at corrfunc. rtfd. i...|$|R
50|$|A danger {{associated}} with the use of <b>illegal</b> <b>instructions</b> was that, given the fact that the manufacturer did not guarantee their existence and function, they might disappear or behave differently with any change of the CPU internals or any new revision of the CPU, rendering programs that use them incompatible with the newer revisions. For example, a number of older Apple II games do not work correctly on the newer Apple IIc, because the latter uses a newer CPU revision — 65C02 — that does away with illegal opcodes.|$|R
5000|$|The Time Stamp Counter (TSC) is a 64-bit {{register}} {{present on}} all x86 processors since the Pentium. It counts {{the number of}} cycles since reset. The instruction [...] returns the TSC in EDX:EAX. In x86-64 mode, [...] also clears the higher 32 bits of RAX and RDX. Its opcode is [...] Pentium competitors such as the Cyrix 6x86 did not always have a TSC and may consider [...] an <b>illegal</b> <b>instruction.</b> Cyrix included a Time Stamp Counter in their MII.|$|E
5000|$|The [...] "exception table" [...] ({{interrupt}} vector table interrupt vector addresses) {{is fixed}} at addresses 0 through 1023, permitting 256 32-bit vectors. The first vector (RESET) consists of 2 vectors, namely the starting stack address, and the starting code address. Vectors 3 through 15 {{are used to}} report various errors: bus error, address error, <b>illegal</b> <b>instruction,</b> zero division, CHK and CHK2 vector, privilege violation (to block privilege escalation), and some reserved vectors that became line 1010 emulator, line 1111 emulator, and hardware breakpoint. Vector 24 starts the real interrupts: spurious interrupt (no hardware acknowledgement), and level 1 through level 7 autovectors, then the 16 TRAP vectors, then some more reserved vectors, then the user defined vectors.|$|E
40|$|In this paper, we {{describe}} TSOtool, {{a program to}} check {{the behavior of the}} memory subsystem in a shared memory multiprocessor. TSOtool runs pseudo-randomly generated programs with data races on a system compliant with the Total Store Order (TSO) memory consistency model; it then checks the results of the program against the formal TSO specification. Such analysis can expose subtle memory errors like data corruption, atomicity violation and <b>illegal</b> <b>instruction</b> ordering. While verifying TSO compliance completely is an NPcomplete problem, {{we describe}} a new polynomial time algorithm which is incorporated in TSOtool. In spite of being incomplete, it has been successful in detecting several bugs in the design of commercial microprocessors and systems, during both pre-silicon and post-silicon phases of validation...|$|E
50|$|More recent CPUs, {{such as the}} 80186, 80286, 68000 and its {{descendants}} or the PowerPC processor, {{usually do}} not have illegal opcodes. Their manufacturers guarantee that the CPU will behave in a well-defined way when it finds an unknown opcode in the instruction stream: usually, this means triggering a certain exception or fault condition. The operating system's exception or fault handler will then usually terminate the application that caused the fault. Another, less common way of handling <b>illegal</b> <b>instructions</b> is by defining them to do nothing except taking up time and space (equivalent to the CPU's official NOP instruction); this method {{is used by the}} TMS9900 and 65C02 processor, among others.|$|R
5000|$|The {{original}} Motorola 68000 family {{implementation of}} the Macintosh operating system executes system calls using that processor's illegal opcode exception handling mechanism. Motorola specified that instructions beginning with 1111 and 1010 would never be used in future 68000 family processors, thus freeing them for use as such by an operating system. As 1111 was reserved for use by co-processors such as the 68881 FPU, Apple chose 1010, which is the binary equivalent of the decimal number ten, as the prefix for operating system calls. Ten is represented in hexadecimal as A, and handling <b>illegal</b> <b>instructions</b> is known as trapping, so these special instructions were called A-traps. When the processor encounters such an instruction, it transfers control to the operating system, which looks up the appropriate task and performs it. There were two advantages to this mechanism: ...|$|R
40|$|Abstract—Core War is a {{game where}} two or more programs, called warriors, are {{executed}} in the same memory area by a timesharing processor. The final goal of each warrior is to crash the others by overwriting them with <b>illegal</b> <b>instructions.</b> The game was popularized by A. K. Dewdney in his Scientific American column in the mid- 1980 s. In order to automatically devise strong warriors, GP, a test program generation algorithm, was extended {{with the ability to}} assimilate existing code and to detect clones; furthermore, a new selection mechanism for promoting diversity independent from fitness calculations was added. The evolved warriors are the first machine-written programs ever able to become King of the Hill (champion) in all four main international Tiny Hills. This paper shows how playing Core War may help generate effective test programs for validation and test of microprocessors. Tackling a more mundane problem, the described techniques are currently being exploited for the automatic completion and refinement of existing test programs. Preliminary experimental results are reported. Index Terms—Automatic programming, Core War, evolutionary program generation, games, microprocessor testing...|$|R
40|$|We {{show how}} to derive a static {{instruction}} scheduler from a formal specification of an instruction-level parallel processor. The mathematical formalism used is SCCS, a synchronous process algebra for specifying timed, concurrent systems. We illustrate the technique by specifying a hypothetical processor that shares many properties of commercial processors (such as the MIPS or SuperSparc) including delayed loads and branches, interlocked floating-point instructions, resource constraints, and multiple instruction issue. We derive parameters necessary for instruction scheduling by developing algorithms that {{operate on the}} labeled transition systems generated by the operational semantics of SCCS. From the labeled transition system we also employ a modal logic, the modal ¯-calculus {{to determine whether there}} are any <b>illegal</b> <b>instruction</b> sequences or instruction sequences that could be executed in parallel. 1 Introduction The problem of automatically generating a code-generator from a mach [...] ...|$|E
40|$|Core War is a {{game where}} two or more programs, called warriors, are {{executed}} in the same memory area by a time-sharing processor. The final goal of each warrior is to crash the others by overwriting them with <b>illegal</b> <b>instructions.</b> The game was popularized by A. K. Dewdney in his Scientific American column in the mid- 1980 s. In order to automatically devise strong warriors, MicroGP, a test program generation algorithm, was extended {{with the ability to}} assimilate existing code and to detect clones; furthermore, a new selection mechanism for promoting diversity independent from fitness calculations was added. The evolved warriors are the first machine-written programs ever able to become King of the Hill (champion) in all four main international Tiny Hills. This paper shows how playing Core War may help generate effective test programs for validation and test of microprocessors. Tackling a more mundane problem, the described techniques are currently being exploited for the automatic completion and refinement of existing test programs. Preliminary experimental results are reported...|$|R
40|$|A small microprocessor, {{suitable}} for use in applications in which high reliability is required, {{was designed to be}} implemented in either an application-specific integrated circuit (ASIC) or a field-programmable gate array (FPGA). The design is based on commercial microprocessor architecture, making it possible to use available software development tools and thereby to implement the microprocessor at relatively low cost. The design features enhancements, including trapping during execution of <b>illegal</b> <b>instructions.</b> The internal structure of the design yields relatively high performance, with a significant decrease, relative to other microprocessors that perform the same functions, in the number of microcycles needed to execute macroinstructions. The problem meant to be solved in designing this microprocessor was to provide a modest level of computational capability in a general-purpose processor while adding as little as possible to the power demand, size, and weight of a system into which the microprocessor would be incorporated. As designed, this microprocessor consumes very little power and occupies {{only a small portion of}} a typical modern ASIC or FPGA. The microprocessor operates at a rate of about 4 million instructions per second with clock frequency of 20 MHz...|$|R
40|$|The Xen Virtual Machine Monitor {{has proven}} to achieve higher {{efficiency}} in virtualizing the x 86 architecture than competing x 86 virtualization technologies. This makes virtualization on the x 86 platform more feasible in High-Performance and mainframe computing, where virtualization can offer attractive solutions for managing resources between users. Virtualization is also attractive on the Itanium architecture. Future x 86 and Itanium computer architectures include extensions which make virtualization more efficient. Moving to virtualizing resources through Xen may ready computer centers for the possibilities offered by these extensions. The Itanium architecture is ``uncooperative'' in terms of virtualization. Privilege-sensitive instructions make full virtualization inefficient and impose the need for para-virtualization. Para-virtualizing Linux involves changing certain native operations in the guest kernel in order to adapt it to the Xen virtual architecture. Minimum para-virtualizing impact on Linux is achieved by, instead of replacing <b>illegal</b> <b>instructions,</b> trapping them by the hypervisor, which then emulates them. Transparent para-virtualization allows the same Linux kernel binary to run on top of Xen and on physical hardware. Itanium region registers allow more graceful distribution of memory between guest operating systems, while not disturbing the Translation Lookaside Buffer. The Extensible Firmware Interface provides a standardized interface to hardware functions, and is easier to virtualize than legacy hardware interfaces. The overhead of running para-virtualized Linux on Itanium is reasonably small and measured to be around 4. 9 %. Also, the overhead of running transparently para-virtualized Linux on physical hardware is reasonably small compared to non-virtualized Linux. </p...|$|R
40|$|Hardware lock elision (HLE) {{concurrently}} executes lock critical sections as hardware transactions, but fallbacks to {{the original}} se-quential lock fallback path when some hardware transaction fails. Recent software-assisted lock-removal based schemes provide a better concurrency by sacrificing safety (opacity). Hardware trans-actions can execute {{at the same time}} with the lock fallback path {{as long as they do}} not try to commit. This limited concurrency is ben-eficial, but enables hardware transactions to see inconsistent mem-ory states, that may lead to <b>illegal</b> <b>instructions,</b> corrupted memory, and other unsafe behaviors. We propose a novel reduced hardware lock elision algorithm (RH-LE). It provides a safe (and opaque) concurrency between hardware transactions and the lock fallback path. The core idea behind the RH-LE approach is to execute the lock fallback path as a rollback-only hardware transaction, that tracks only the mem-ory writes of the transaction. This special hardware transaction is already introduced in the IBM Power 8 ISA specification with the intention to be used only for non-shared writes. We propose to use the rollback-only hardware transaction for all of the writes, shared or non-shared, and in this way to hide all of the write modifica-tions of the lock fallback path till its successful commit. The hiding process preserves opacity of concurrent hardware transactions, and allows read-only hardware transactions to commit even when there is a concurrent fallback execution. Currently, IBM Power 8 processors are unavailable for public use, and therefore we implement a software-based simulation of the RH-LE algorithm. It shows that the new lock elision scheme has the potential to be almost 2 times faster than other lock elision techniques. 1...|$|R
40|$|This Article {{explores the}} lessons that {{we can learn from}} social {{psychology}} regarding a lawyer 2 ̆ 7 s willingness to comply with authority figures, such as senior partners or deep-pocketed clients, when they make unlawful or unethical demands. The Article reviews some of the basic literature in social psychology regarding conformity and obedience, much of which emphasizes the importance of context as a primary factor in predicting people 2 ̆ 7 s behavior. The Article then contends that lawyers frequently find themselves in the kinds of contexts that produce high levels of conformity and obedience and low levels of resistance to <b>illegal</b> or unethical <b>instructions.</b> The result is that subordinate lawyers will find it difficult to resist a superior 2 ̆ 7 s commands in circumstances that should produce forceful dissent. Finally, the Article proposes several changes to existing law in light of these insights, including giving lawyers the benefit of whistleblower protection, strengthening a lawyer 2 ̆ 7 s duty to report the misconduct of other lawyers, and enhancing a subordinate lawyer 2 ̆ 7 s responsibilities upon receiving arguably unethical instructions from superiors...|$|R

