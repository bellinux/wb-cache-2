5|49|Public
50|$|Most {{instructions}} {{can take}} either immediate values or register contents; thus a single <b>instruction</b> <b>mnemonic</b> may correspond {{to one of}} two opcodes.|$|E
5000|$|A {{label to}} the right of an <b>instruction</b> <b>mnemonic</b> takes on the value of the memory address {{referred}} to above. i.e. BRA loopstart ...|$|E
5000|$|A {{label to}} the left of an <b>instruction</b> <b>mnemonic</b> is {{converted}} to the memory address the instruction or data is stored at. i.e. loopstart INP ...|$|E
50|$|The {{assembler}} accepts <b>instruction</b> <b>mnemonics,</b> data declarations and directives and constructs {{an object}} file containing information readily understandable by the CPU {{of the target}} processor, in particular code instructions coded in binary.|$|R
50|$|The {{operations}} are as follows. Not all support all addressing modes; the immediate mode {{in particular is}} unavailable if the flexible operand is written to. <b>Instruction</b> <b>mnemonics</b> use destination, source operand order.|$|R
5000|$|CMPSD and MOVSD {{have the}} same name as the string <b>instruction</b> <b>mnemonics</b> CMPSD (CMPS) and MOVSD (MOVS); however, the former refer to scalar {{double-precision}} floating-points whereas the latters refer to doubleword strings.|$|R
50|$|In this process, the {{mnemonic}} , for LOAD, {{was replaced}} by various abbreviations of the words LOAD, STORE and MOVE, intermixed with other symbolic letters. The mnemonic letter , for memory (referenced by HL), was lifted out from within the <b>instruction</b> <b>mnemonic</b> to become a syntactically freestanding operand, while registers and combinations of registers became very inconsistently denoted; either by abbreviated operands (MVI D, LXI H and so on), within the <b>instruction</b> <b>mnemonic</b> itself (LDA, LHLD and so on), or {{both at the same}} time (LDAX B, STAX D and so on).|$|E
50|$|A 6502 {{assembly}} language statement {{consists of a}} three character <b>instruction</b> <b>mnemonic,</b> followed by an operand {{in the case of}} an instruction that takes an operand. When assembled, the resulting machine code will consist of a one byte operation code (opcode), followed by a one or two byte operand, if the instruction was assembled with an operand, hence 6502 machine instructions vary in length from one to three bytes. The operand will be stored in the 6502's customary little-endian format. The 65C816, the 16-bit CMOS version of the 6502, also supports 24 bit addressing, which addressing modes will result in instructions being assembled with three byte operands, also arranged in little-endian format.|$|E
5000|$|Some notable <b>instruction</b> <b>mnemonics</b> are BALR for a call storing {{the return}} address in a {{register}} before stacks were used, SVC, DIAG, and ZAP. [...] The latter inspired {{the name of}} the SuperZAP utility by a programmer using the pseudonym WAMOZART, cf[...]|$|R
5000|$|Observe, however, that B-B and B-B-J {{do not use}} a {{variable}} [...] "X" [...] in the mnemonics with a specifying parameter (as shown in the Lambek version) --i.e. [...] "X+" [...] and [...] "X-"but rather the <b>instruction</b> <b>mnemonics</b> specifies the registers themselves, e.g. [...] "2+", or [...] "3-": ...|$|R
5000|$|A [...] "run" [...] of {{the program}} is shown below. Time runs down the page. The {{instructions}} are in yellow, the registers in blue. The program is flipped 90 degrees, with the instruction numbers (addresses) along the top, the <b>instruction</b> <b>mnemonics</b> under the addresses, and the instruction parameters under the mnemonics (one per cell): ...|$|R
5000|$|There is a [...] "one-to-one" [...] {{relationship}} with machine <b>instructions.</b> The full <b>mnemonic</b> <b>instruction</b> set {{is described in}} the Principles of Operation manual for each processor.Examples: ...|$|R
5000|$|A basic PDP-8 {{had only}} eight instructions. The {{assembler}} provided more <b>instruction</b> <b>mnemonics</b> to a programmer by translating I/O and operate-mode instructions to combinations of the op-codes and instruction fields. It also {{had only three}} programmer-visible registers: A 12-bit accumulator (AC), a program counter (PC) and a carry bit called the [...] "link register," [...] (L).|$|R
5000|$|In {{assembly}} language, directives, {{also referred}} to as pseudo-operations or [...] "pseudo-ops", generally specify such information as the target machine, mark separations between code sections, invoke macros, define reserved memory areas, and so on. Assemblers use a specific syntax to differentiate pseudo-ops from <b>instruction</b> <b>mnemonics,</b> such as prefacing the pseudo-op with a period, such as the pseudo-op , which might direct the assembler to stop assembling code.|$|R
5000|$|The OPR {{instruction}} {{was said to}} be [...] "microcoded." [...] This did not mean what the word means today (that a lower-level program fetched and interpreted the OPR instruction), but meant that each bit of the instruction word specified a certain action, and the programmer could achieve several actions in a single instruction cycle by setting multiple bits. In use, a programmer would write several <b>instruction</b> <b>mnemonics</b> alongside one another, and the assembler would combine them with OR to devise the actual instruction word. Many I/O devices supported [...] "microcoded" [...] IOT instructions.|$|R
40|$|This report {{describes}} {{the outcomes of}} a 3 -year project that investigated the effectiveness of <b>mnemonic</b> <b>instruction</b> of secondary students with learning disabilities. Classroom-based <b>mnemonic</b> <b>instruction</b> was implemented in junior-high school self-contained classrooms. The report first presents theoretical and empirical support for mnemonic instructional techniques. Second, a thorough review of recent research in <b>mnemonic</b> <b>instruction</b> of special populations is provided. Third, {{a detailed description of}} the research activities undertaken in this federally funded research program is given. Last is a discussion of the knowledge gained from the research and its implications for the special education of students with learning disabilities and other mild disabilities. Results 'found that students when instructed mnemonically scored much higher on tests, including recall tests of up to 8 weeks of instruction, than when they were instructed traditionally. Additionally, teachers rated <b>mnemonic</b> <b>instruction</b> a...|$|R
40|$|This report {{introduces}} XASM, {{a generic}} and retargetable assembler {{that can be}} used as a stand-alone tool, as well as a Java library or framework providing assembler-related Java classes for application programs. It is not necessary to modify or recompile the assembler in order to adapt it to new target architectures. Retargetability is achieved by Opcode Maps, a textual description of the <b>instruction</b> <b>mnemonics</b> and encodings of the target architecture, for which to generate machine code. Opcode maps feature an inheritance model, which makes them clearer and also means less effort in describing an instruction set because only the extensions compared to its binary compatible parent instruction set(s) need to be specified...|$|R
40|$|A {{pilot study}} was {{conducted}} with the lowest performing sixth grade students in two classes in an urban environment. The nine students participating in this pilot study had been performing below grade level {{for at least two years}} despite the provision of supplemental services. With direct instruction, slower pace of <b>instruction,</b> <b>mnemonics,</b> math charts, manipulatives, and metacognitive strategies, gains were noted in the students’ performance. Pretest and posttest measure were administered and the results revealed modest gains in calculations and basic fraction knowledge with significant improvement noted with math fluency. The strategies used are known to both general and special educators and the reminder of the impact that relatively simple strategy instruction can have on students’ overall performance in inclusive environments can be of value to both teachers and students...|$|R
40|$|Abstract—The {{problem of}} {{matching}} between binaries {{is important for}} software copyright enforcement {{as well as for}} identifying disclosed vulnerabilities in software. We present a search engine prototype called Rendezvous which enables indexing and searching for code in binary form. Rendezvous identifies binary code using a statistical model comprising <b>instruction</b> <b>mnemonics,</b> control flow sub-graphs and data constants which are simple to extract from a disassembly, yet normalising with respect to different compilers and optimisations. Experiments show that Rendezvous achieves F 2 measures of 86. 7 % and 83. 0 % on the GNU C library compiled with different compiler optimisations and the GNU coreutils suite compiled with gcc and clang respectively. These two code bases together comprise more than one million lines of code. Rendezvous will bring significant changes to the way patch management and copyright enforcement is currently performed. I...|$|R
50|$|The {{commonly}} encountered Cook and Rechkow {{model is}} a bit like the ternary-register Malzek model (written with Knuth mnemonicsthe original <b>instructions</b> had no <b>mnemonics</b> excepting TRA, Read, Print).|$|R
40|$|ISSN 1476 - 2986 Decompilation is {{the process}} of {{converting}} programs in a low-level representation, such as machine code, into high-level programs that are human readable, compilable and seman-tically equivalent. The current de facto approach to decompilation is largely modelled on compiler theory and only focusses on one or two of these desirable goals at a time. This thesis makes the case that decompilation is more effectively accomplished through search. It is observed that software development is seldom a clean slate process and much software is available in public repositories. To back this claim, evidence is presented from three categories of software development: corporate software development, open source projects and malware creation. Evidence strongly suggests that code reuse is prevalent in all categories. Two approaches to search-based decompilation are proposed. The first approach borrows inspiration from information retrieval, and constitutes the first contribution of this thesis. It uses <b>instruction</b> <b>mnemonics,</b> control-flow sub-graphs and data constants, which ca...|$|R
5000|$|Zeus is a two-pass {{assembler}} {{that allows}} {{full use of}} the Zilog Z80 processor's <b>mnemonic</b> <b>instruction</b> set. It was the first assembler to tokenise the source code, an innovation by Neil Mottershead.|$|R
40|$|ABSTRACT:: Thirty-two {{qualitative}} {{investigations of}} co-teaching in inclusive classrooms were in-cluded in a metasynthesis employing qualitative research integration techniques. It {{was concluded that}} co-teachers generally supported co-teaching, although {{a number of important}} needs were iden-tified, including planning time, student skill level, and training; many of these needs were linked to administrative support. The dominant co-teaching role was found to be "one teach, one assist," in classrooms characterized by traditional instruction, even though this method is not highly rec-ommended in the literature. The special education teacher was often observed to play a subordinate role. Techniques often recommended for special education teachers, such as peer mediation, strategy <b>instruction,</b> <b>mnemonics,</b> and training of study skills, self-advocacy skills, and self-monitoring, were infrequently observed. I n response to recent trends and legisla- Bauwens, Hourcade, and Friend (1989); Cook tion promoting inclusive instruction and and Friend (1995); and Friend (2002) discussed access to the general education curricu- criteria needed for an effective co-teaching rela-lum, many schools have implemented tionship. A number of co-teaching variations "co-teaching " (Cook & Friend, 1995) as have been identified (see also Friend & Cook...|$|R
5000|$|Additionally, in {{assembly}} language, an operand is a value (an argument) {{on which}} the <b>instruction,</b> named by <b>mnemonic,</b> operates. The operand may be a processor register, a memory address, a literal constant, or a label. A simple example (in the x86 architecture) is ...|$|R
5000|$|CPU {{designers}} sometimes incorporate {{one or more}} undocumented {{machine code}} instructions for testing purposes, such as the IBM System/360 DIAGnose instruction. These instructions are {{not intended to be}} executed during normal operation of the CPU; when they are actually executed by a program during normal operation, they can have unusual side-effects. The [...] "Halt and Catch Fire" [...] (HCF) <b>instruction</b> and <b>mnemonic</b> are sometimes appropriated by users who discover these instructions as a humorous way of expressing that the unintended execution of such an instruction causes the system to fail to perform its normal functions.|$|R
40|$|Abstract. One of the {{characteristics}} of learning disabled (LD) students most com-monly mentioned by teachers and researchers is difficulty with semantic memory. Recently, an instructional model has been developed, referred to as <b>mnemonic</b> <b>instruction,</b> which is directly targeted to learners with difficulties in semantic mem-ory. This article describes the concept of <b>mnemonic</b> <b>instruction</b> and how it interacts with the specific learning characteristics of LD students. Additionally, the extraordi-nary effectiveness of the techniques with LD students, as reported in numerous pub-lished research studies, is described. Implications for classroom instruction and further research are provided. One of the most commonly described charac-teristics of learning disabled (LD) students is their failure to remember important information. In addition to frequent reports by teachers of LD students, this characteristic has often been de-monstrated in experimental research (e. g., Coo...|$|R
50|$|Through her research, Brown and {{her colleagues}} {{hypothesized}} that some metacognitive strategies, such as general problem solving routines like summarizing and self-testing, had advantages over other strategies i.e. <b>mnemonic</b> <b>instruction.</b> Instead of recalling relative meaningless material, studies moved towards connecting the material, which allowed Brown to move towards further research in text comprehension.|$|R
40|$|Many {{experimental}} {{studies have demonstrated}} that instructions to use mental imagery give rise to substantial improvements in memory performance. However, the subjects in most of these studies have been college students, and an experiment by Richardson & Barry (1985) which used subjects drawn from the general population failed to show such an improvement. Indeed, arguments may be educed to suggest that imagery <b>mnemonic</b> <b>instructions</b> should enhance performance only in the case of subjects who belong to the higher social classes. An extended analysis of the results obtained by Richardson & Barry classified their experimental subjects into social classes in terms of their current occupation and confirmed the predicted relationship between social class and the efficacy of imagery <b>mnemonic</b> <b>instructions.</b> Such results encourage a considerable degree of scepticism concerning the possibility of generalizing from samples of college students to the general population...|$|R
5000|$|Another {{example is}} the x86 family, of which {{processors}} of three different word lengths (16-bit, later 32- and 64-bit) have been released. As software is routinely ported from one word-length to the next, some APIs and documentation define or refer to an older (and thus shorter) word-length than the full word length on the CPU that software may be compiled for. Also, similar to how bytes are used for small numbers in many programs, a shorter word (16 or 32 bits) {{may be used in}} contexts where the range of a wider word is not needed (especially where this can save considerable stack space or cache memory space). For example, Microsoft's Windows API maintains the programming language definition of WORD as 16 bits, {{despite the fact that the}} API may be used on a 32- or 64-bit x86 processor, where the standard word size would be 32 or 64 bits, respectively. Data structures containing such different sized words refer to them as WORD (16 bits/2 bytes), DWORD (32 bits/4 bytes) and QWORD (64 bits/8 bytes) respectively. A similar phenomenon has developed in Intel's x86 assembly language - because of the support for various sizes (and backward compatibility) in the instruction set, some <b>instruction</b> <b>mnemonics</b> carry [...] "d" [...] or [...] "q" [...] identifiers denoting [...] "double-", [...] "quad-" [...] or [...] "double-quad-", which are in terms of the architecture's original 16-bit word size.|$|R
50|$|Assembly language, or just assembly, is a {{low-level}} programming language, which uses <b>mnemonics,</b> <b>instructions</b> and operands to represent machine code. This enhances the readability while still giving precise {{control over the}} machine instructions. Most programming is currently done using high-level programming languages, which are typically easier to read and write. These languages need to be compiled (translated into assembly language), or run through other compiled programs.|$|R
40|$|Fifty-six {{learning}} disabled students were presented materials de-scribing minerals of North America. For each mineral, {{the students had}} to learn three associated attributes: the minerals hardness level its color, and its common use. The students {{were randomly assigned to}} four different methods of study. The two principal conditions were direct instruction, where students were taught eight minerals according to the basic principles of direct instruction (in particular, student participation with repeated drill and practice), and <b>mnemonic</b> <b>instruction,</b> where students were shown thematic illustrations that integrated each of the eight minerals and its attributes. Also included were a reduced-list direct-instruction condition, where students were required to learn only half the number of minerals (i. e., four minerals) in the same amount of allotted time as in the other conditions, and a free-study condition, where students were instructed to learn the eight minerals however they wished. The results supported previous findings that learning was superior in the <b>mnemonic</b> <b>instruction</b> condition. In addition (a) The second author's contribution to this study was funded in part by a postdoctora...|$|R
5000|$|In a computer's {{assembly}} language, mnemonics {{are used}} that are directly equivalent to machine code <b>instructions.</b> The <b>mnemonics</b> are frequently three letters long, such as ADD, CMP (to compare two numbers), and JMP (jump {{to a different}} location in the program). The HCF instruction was originally a fictitious assembly language instruction, said to be under development at IBM for use in their System/360 computers, {{along with many other}} amusing three-letter acronyms like XPR (Execute Programmer) and CAI (Corrupt Accounting Information), and similar to other joke mnemonics such as [...] "SDI" [...] for [...] "Self Destruct Immediately" [...] and [...] "CRN" [...] for Convert to Roman Numerals. A list of such mnemonics, including HCF, shows up as [...] "Overextended Mnemonics" [...] in the April 1980 Creative Computing flip-side parody issue.|$|R
40|$|The present paper {{explores the}} effects of the use of loci {{mnemonics}} by expert people when series of three items (triples) must be memorized. The most general results of the experiments here presented is that progressive elaboration <b>instructions</b> make loci <b>mnemonics</b> not only powerful with a series of materials, but also capable of maintaining the order of information within and between the loci. Finally {{the effects of}} loci mnemonics appear stronger in subject with good performance on a memory localization test requiring them to remember where pictures appeared on the pages of a book...|$|R
5000|$|The {{assembler}} for BPS is {{the true}} [...] "basic assembler." [...] It {{was intended to be}} loaded from cards and would run on an 8 KB System/360 (except Model 20). It had no support for macro <b>instructions</b> or extended <b>mnemonics</b> (such as BH in place of BC 2 to branch if condition code 2 indicates a high compare). It could assemble only a single control section and did not allow dummy sections (structure definitions). Parenthesized expressions were not allowed and expressions were limited to three terms with the only operators being '+', '-', and '*'.|$|R
40|$|This study {{integrated}} technology tools into {{a reading}} comprehension intervention that used explicit instruction to teach strategies (i. e., asking questions, making connections, and coding {{the text to}} monitor for meaning) to mixed-ability small groups, which included four English Learners with learning disabilities in a fourth-grade general education classroom. We used a multiple baseline design across participants to evaluate the effects of instruction on strategy application as measured through comprehension rubrics (Keene, 2006) and on comprehension-question answering as measured through researcher-developed literal and inferential comprehension questions. Results showed that participants applied comprehension strategies and improved their percentage accuracy with answering comprehension questions after being introduced to explicit strategy <b>instruction,</b> a <b>mnemonic</b> to facilitate strategy application, web-based tools, and peer collaboration to co-construct meaning from text. Participants perceived the instructional technology tools (i. e., mind-mapping applications, web-linked text, weblogs, and an interactive whiteboard recording application) and reading comprehension strategy instruction as helpful. Implications for future research and practice are discussed...|$|R
40|$|The {{relationship}} between <b>mnemonic</b> <b>instruction</b> and academic performance for secondary-school-age youth with disabilities was explored in this systematic review. A total of 20 studies intervening with 669 youth with learning disabilities, {{emotional and behavioral}} disorders, and mild developmental disabilities were reviewed. The findings of this review strongly support the efficacy of mnemonic interventions across study methods, educational settings, student ages, and disabilities in the improvement of academic performance, typically measured by recall of word meanings or factual information. A series of detailed implications for practice is discussed and reference is made to specific literature providing detailed descriptions of mnemonic interventions...|$|R
