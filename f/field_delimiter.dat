7|12|Public
50|$|In many {{computer}} languages commas {{are used}} as a <b>field</b> <b>delimiter</b> to separate arguments to a function, to separate elements in a list, and to perform data designation on multiple variables at once.|$|E
5000|$|In many term {{programs}} and game parsers, a hard space {{was a special}} kind of <b>field</b> <b>delimiter,</b> against which a filename could be examined or listed, or a semantic thought or consideration could be interpreted.|$|E
5000|$|Delimiter {{collision}} is {{a problem}} that occurs when an author or programmer introduces delimiters into text without actually intending them to be interpreted as boundaries between separate regions. In the case of XML, for example, this can occur whenever an author attempts to specify an angle bracket character. In most file types there is both a <b>field</b> <b>delimiter</b> and a record delimiter, both of which are subject to collision. In the case of comma-separated values files, for example, field collision can occur whenever an author attempts to include a comma as part of a field value (e.g., salary = [...] "$30,000"), and record delimiter collision would occur whenever a field contained multiple lines. Both record and <b>field</b> <b>delimiter</b> collision occur frequently in text files.|$|E
50|$|<b>Field</b> <b>delimiters</b> {{separate}} data <b>fields.</b> Record <b>delimiters</b> separate {{groups of}} fields.|$|R
5000|$|... : Bypasses lines {{which contain}} no <b>field</b> <b>delimiters</b> when [...] is specified, unless {{otherwise}} indicated.|$|R
5000|$|... #Caption: A stylistic {{depiction}} of a fragment from a CSV-formatted text file. The commas (shown in red) are used as <b>field</b> <b>delimiters.</b>|$|R
5000|$|... : Delimiter; the {{character}} {{immediately following the}} [...] option is the <b>field</b> <b>delimiter</b> for use {{in conjunction with the}} [...] option; the default delimiter is tab. Space and other characters with special meanings {{within the context of the}} shell in use must be enquoted or escaped as necessary.|$|E
50|$|A {{delimiter}} is {{a sequence}} {{of one or more}} characters used to specify the boundary between separate, independent regions in plain text or other data streams. An example of a delimiter is the comma character, which acts as a <b>field</b> <b>delimiter</b> in {{a sequence of}} comma-separated values. Another example of a delimiter is the time gap used to separate letters and words in the transmission of Morse code.|$|E
40|$|A {{method for}} {{analyzing}} a protocol of a network, comprising: obtaining {{a plurality of}} conversations from the network, wherein each of the plurality of conversations comprises a sequence of messages exchanged between a server and a client of the network using the protocol, wherein each message of the sequence of messages comprise one or more fields separated by a <b>field</b> <b>delimiter</b> of the protocol; extracting, by a computer processor, a plurality of non-alphanumeric tokens from the plurality of conversations, wherein the plurality of non-alphanumeric tokens comprises a non-alphanumeric token associated with a frequency of occurrence in the plurality of conversations; selecting, based on the frequency of occurrence meeting a pre-determined <b>field</b> <b>delimiter</b> candidate selection criterion, the non-alphanumeric token as a <b>field</b> <b>delimiter</b> candidate; dividing, by the computer processor and using the <b>field</b> <b>delimiter</b> candidate, each of the plurality of conversations into a plurality of slices; analyzing, by the computer processor and using a pre-determined <b>field</b> <b>delimiter</b> candidate scoring algorithm, content included in the plurality of slices to: determine a statistical measure of matched slices {{for each of the}} plurality of conversations, wherein the statistical measure of matched slices corresponds to an exact-matched-slices percentage and a prefix-matched-slices percentage that are normalized based on an average number of slices per conversation; determine a <b>field</b> <b>delimiter</b> candidate score by aggregating the statistical measure of matched slices for all of the plurality of conversations; and selecting, by the computer processor and based on the <b>field</b> <b>delimiter</b> candidate score associated with the non-alphanumeric token, the non-alphanumeric token as the <b>field</b> <b>delimiter</b> of the protoco...|$|E
5000|$|Some {{versions}} of [...] lack explicit <b>field</b> <b>delimiters</b> in their printf-generated output, leading to numeric fields running together and thus corrupting the output data.|$|R
5000|$|In addition, {{the term}} [...] "CSV" [...] also denotes some closely related delimiter-separated formats that use {{different}} <b>field</b> <b>delimiters.</b> These include tab-separated values and space-separated values. A delimiter {{that is not}} present in the field data (such as tab) keeps the format parsing simple. These alternate delimiter-separated files are often even given a [...]csv extension despite {{the use of a}} non-comma field separator. This loose terminology can cause problems in data exchange. Many applications that accept CSV files have options to select the delimiter character and the quotation character.|$|R
50|$|<b>Field</b> and Record <b>delimiters</b> (See also, ASCII, Control character).|$|R
40|$|The {{file set}} is a freely {{downloadable}} aggregation {{of information about}} Australian schools. The individual files represent a series of tables which, when considered together, form a relational database. The records cover the years 2008 - 2014 and include information on approximately 9500 primary and secondary school main-campuses and around 500 subcampuses. The records all relate to school-level data; no data about individuals is included. All the information has previously been published and is publicly available {{but it has not}} previously been released as a documented, useful aggregation. The information includes: (a) the names of schools (b) staffing levels, including full-time and part-time teaching and non-teaching staff (c) student enrolments, including the number of boys and girls (d) school financial information, including Commonwealth government, state government, and private funding (e) test data, potentially for school years 3, 5, 7 and 9, relating to an Australian national testing programme know by the trademark 'NAPLAN' Documentation of this Edition 2016. 1 is incomplete but the organization of the data should be readily understandable to most people. If you are a researcher, the simplest way to study the data is {{to make use of the}} SQLite 3 database called 'school-data- 2016 - 1. db'. If you are unsure how to use an SQLite database, ask a guru. The database was constructed directly from the other included files by running the following command at a command-line prompt: sqlite 3 school-data- 2016 - 1. db < school-data- 2016 - 1. sql Note that a few, non-consequential, errors will be reported if you run this command yourself. The reason for the errors is that the SQLite database is created by importing a series of '. csv' files. Each of the. csv files contains a header line with the names of the variable relevant to each column. The information is useful for many statistical packages but it is not what SQLite expects, so it complains about the header. Despite the complaint, the database will be created correctly. Briefly, the data are organized as follows. (a) The. csv files ('comma separated values') do not actually use a comma as the <b>field</b> <b>delimiter.</b> Instead, the vertical bar character '|' (ASCII Octal 174 Decimal 124 Hex 7 C) is used. If you read the. csv files using Microsoft Excel, Open Office, or Libre Office, you will need to set the field-separator to be '|'. Check your software documentation to understand how to do this. (b) Each school-related record is indexed by an identifer called 'ageid'. The ageid uniquely identifies each school and consequently serves as the appropriate variable for JOIN-ing records in different data files. For example, the first school-related record after the header line in file 'students-headed-bar. csv' shows the ageid of the school as 40000. The relevant school name can be found by looking in the file 'ageidtoname-headed-bar. csv' to discover that the the ageid of 40000 corresponds to a school called 'Corpus Christi Catholic School'. (3) In addition to the variable 'ageid' each record is also identified by one or two 'year' variables. The most important purpose of a year identifier will be to indicate the year that is relevant to the record. For example, if one turn again to file 'students-headed-bar. csv', one sees that the first seven school-related records after the header line all relate to the school Corpus Christi Catholic School with ageid of 40000. The variable that identifies the important differences between these seven records is the variable 'studentyear'. 'studentyear' shows the year to which the student data refer. One can see, for example, that in 2008, there were a total of 410 students enrolled, of whom 185 were girls and 225 were boys (look at the variable names in the header line). (4) The variables relating to years are given different names in each of the different files ('studentsyear' in the file 'students-headed-bar. csv', 'financesummaryyear' in the file 'financesummary-headed-bar. csv'). Despite the different names, the year variables provide the second-level means for joining information acrosss files. For example, if you wanted to relate the enrolments at a school in each year to its financial state, you might wish to JOIN records using 'ageid' in the two files and, secondarily, matching 'studentsyear' with 'financialsummaryyear'. (5) The manipulation of the data is most readily done using the SQL language with the SQLite database but it can also be done in a variety of statistical packages. (6) It is our intention for Edition 2016 - 2 to create large 'flat' files suitable for use by non-researchers who want to view the data with spreadsheet software. The disadvantage of such 'flat' files is that they contain vast amounts of redundant information and might not display the data in the form that the user most wants it. (7) Geocoding of the schools is not available in this edition. (8) Some files, such as 'sector-headed-bar. csv' are not used in the creation of the database but are provided as a convenience for researchers who might wish to recode some of the data to remove redundancy. (9) A detailed example of a suitable SQLite query can be found in the file 'school-data-sqlite-example. sql'. The same query, used in the context of analyses done with the excellent, freely available R statistical package ([URL] can be seen in the file 'school-data-with-sqlite. R'...|$|E
5000|$|... {{with the}} records divided into <b>fields</b> {{separated}} by <b>delimiters</b> (typically a single reserved character such as comma, semicolon, or tab; sometimes the delimiter may include optional spaces), ...|$|R
50|$|The use of ASCII 31 Unit {{separator}} as a {{field separator}} and ASCII 30 Record separator solves the problem of both <b>field</b> and record <b>delimiters</b> that appear in a text data stream.|$|R
40|$|Many {{applications}} in security, from understanding unfamiliar protocols to fuzz-testing and guarding against potential attacks, rely on analysing network protocols. In many situations we cannot rely on {{access to a}} specification or even an implementation of the protocol, and must instead rely on raw network data “sniffed” from the network. When this is the case, {{one of the key}} challenges is to discern from the raw data the underlying packet structures – a task that is commonly carried out by using alignment algorithms to identify commonalities (e. g. <b>field</b> <b>delimiters)</b> between packets. For this, most approaches have used variants of the Needleman Wunsch algorthm to perform byte-wise alignment. However, they can suffer when messages are heterogeneous, or in cases where protocol fields are separated by long variable fields. In this paper, we present an alternative alignment algorithm known as segment-based alignment. We show how this technique can produce accurate results on traces from several common protocols, and how the results tend to be more intuitive than those produced by state-of-the-art techniques. Peer-reviewedPost-printIEEE International Conference on Quality, Reliability and Security QRS 201...|$|R
40|$|We {{had a look}} at the Unix {{operating}} system, {{the philosophy}} underlying its design and some basic tools [...] I also circulated a brief tutorial that seems to do a nice job of covering the major commands I think you should know • We emphasized some hands-on tasks [...] We used as our case study six months of traffic across the department’s website www. stat. ucla. edu (or more precisely, the suite of virtual hosts supported by our department) • You had a chance to kick the tires on these tools and address some simple web site usage statistics [...] both in class and for homework Today • We’ll talk a bit about what’s happening with your homework [...] Specifically, we’ll talk about the use of web access logs as a source of data for “web analytics ” (as well as a popular alternative) and then {{get a sense of the}} kinds of analysis the tools you have make easy and the kinds of things that seem hard • We ended last lecture by illustrating the shortcoming of using spaces as <b>field</b> <b>delimiters</b> rather than “parsing ” the log lines [...] Today we’ll start to consider...|$|R
5000|$|Starting {{delimiter}} : Consists of {{a special}} bit pattern denoting {{the beginning of the}} frame. The bits from most significant to least significant are J,K,0,J,K,0,0,0. J and K are code violations. Since Manchester encoding is self clocking, and has a transition for every encoded bit 0 or 1, the J and K codings violate this, and will be detected by the hardware. Both the Starting Delimiter and Ending <b>Delimiter</b> <b>fields</b> are used to mark frame boundaries.|$|R
50|$|FIX {{messages}} are formed {{from a number}} of fields; each field is a tag value pairing that is separated from the next <b>field</b> by a <b>delimiter</b> SOH (0x01). The tag is an integer that indicates the meaning of the field. The value is an array of bytes that hold a specific meaning for the particular tag (e.g. tag 48 is securityID, a string that identifies the security; tag 22 is IDSource, an integer that indicates the identifier class being used). The values may be in plain text or encoded as pure binary (in which case the value is preceded by a length field). The FIX protocol defines meanings for most tags, but leaves a range of tags reserved for private use between consenting parties.|$|R

