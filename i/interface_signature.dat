6|46|Public
40|$|Abstract. Current {{industrial}} {{models for}} software components have made component based software engineering a practical reality. However, these models {{are limited in}} the sense that their support for the specification of component interfaces primarily deals with syntactic issues. As such, component mismatch remains a critical stumbling block in component based software engineering: components may syntctically “plug”, but still not behaviourally “play”. To facilitate proper understanding and use of software components and advance towards full “plug-and-play”, richer interface specification is needed for components. In this paper, we present a framework for rich component interface specification. It address the following issues of component specification: functional capability (<b>interface</b> <b>signature</b> and semantics), proper use (interface configuration and interaction protocols), and usefulness (qualities) ...|$|E
40|$|In {{distributed}} applications, objects {{can live}} independently of any application that interacts with them. For this reason, it becomes difficult {{to modify their}} structure, e. g. their implementation and/or <b>interface</b> <b>signature.</b> In order to support the modification of objects, {{it is necessary to}} decouple clients from potentially morphable objects by inserting an immorphable intermediary (known as the encapsulator). The encapsulator intercepts calls to the morphable object’s methods, enabling the encapsulator to redirect the call, transform the call, or perform preor post-processing on the call. A prototype of morphable objects has been developed in Smalltalk (using VisualWorks 2. 5. 2). The techniques for implementing encapsulators and mutating the objects in Smalltalk are described. 1...|$|E
40|$|Abstract-Type {{compatibility}} is {{an important}} issue in the area of service type evolution as it is desirable for a new-version service to still be compatible with its old version in order that existing clients of the old service are affected by the change as little as possible. This paper introduces a new type relationship called an equivalence relationship which concerns functionality compatibility rather than <b>interface</b> <b>signature</b> compatibility when determining substitutability between two service versions. To support this kind of relationships, parts of the CORBA invocation model will be extended to allow information of equivalent service versions to be discovered at run time from the augmented CORBA Interface Repository. A client request to an old service will then be dynamically and transparently composed as a new-version invocation to a new-version service. The proposed extensions will be useful to provide compatibility not only between versions of the same service but also between two distinct services that have equivalent functionality. I...|$|E
40|$|Although stream {{interfaces}} are steady-state, corotating {{boundaries between}} slow and fast solar wind, their signatures are sometimes associated with transient features. Here the authors illustrate two modes of association: interfaces trailing interplanetary coronal mass ejections (ICMEs) at 1 AU and interfaces within ICMEs {{in the range}} 4 [...] 5 AU. The former are readily understood as boundaries between transient slow wind and steady-state fast wind, where the ICMEs add variability to the <b>interface</b> <b>signatures.</b> The latter are puzzling and {{may be related to}} evolution of interfaces...|$|R
50|$|An {{abstract}} type may provide no implementation, or an incomplete implementation. In some languages, {{abstract type}}s with no implementation (rather than an incomplete implementation) {{are known as}} protocols, <b>interfaces,</b> <b>signatures,</b> or class types. In class-based object-oriented programming, abstract types are implemented as abstract classes (also known as abstract base classes), and concrete types as concrete classes. In generic programming, the analogous notion is a concept, which similarly specifies syntax and semantics, but {{does not require a}} subtype relationship: two unrelated types may satisfy the same concept.|$|R
40|$|Web {{application}} development using distributed components and web services presents new software integration challenges, because solutions often cross vendor, administrative, and other boundaries across which neither binary nor source code can be shared. We present a methodology that addresses this problem through a formalism for specifying and manipulating behavioral interfaces of multithreaded open software components that {{communicate with each}} other through method calls. An interface constrains both the implementation and the user of a web service to fulfill certain assumptions that are specified by the interface. Our methodology consists of three increasingly expressive classes of <b>interfaces.</b> <b>Signature</b> <b>interfaces</b> specify the methods that can be invoked by the user, together with parameters. Consistency interfaces add propositional constraints, enhancing <b>signature</b> <b>interfaces</b> with the ability to specify choice and causality. Protocol interfaces specify, in addition, temporal ordering constraints on method invocations. We provide approaches to check if two or more interfaces are compatible; if a web service can be safely substituted for another one; and if a web service satisfies a specification that represents a desired behavioral property...|$|R
40|$|Abstract. Current {{industrial}} {{models for}} software components have made component-based software engineering a practical reality. However, these models {{are limited in}} the sense that their support for the specication of component interfaces primarily deals with syntactic issues. As such, component mismatch remains a critical stumbling block in component based software engineering: components may syntactically ", but still not behaviourally ". To facilitate proper understanding and use of compo-nents and advance towards full -and-play", richer interface specication is needed for components. In this article, we introduce a framework for rich component interface speci cation. It addresses the issues of <b>interface</b> <b>signature</b> (syntax), interface congu-rations (structure), interface behaviour (semantics), interaction protocols (constraints) and quality properties of software components. In addition to the framework as a whole, two specic contributions are (1) its use of interface congurations in capturing and organising usage-specic characteristics, and (2) its constraint-based approach to the incremental specication of interaction protocols. A number of applications are also highlighted in the article to illustrate the framework's the main objective of immediate practical usability...|$|E
40|$|In the sarcomeric M-band, {{the giant}} ruler {{proteins}} titin and obscurin, its small homologue obscurin-like- 1 (obsl 1), and the myosin cross-linking protein myomesin form a ternary complex that {{is crucial for}} {{the function of the}} M-band as a mechanical link. Mutations in the last titin immunoglobulin (Ig) domain M 10, which interacts with the N-terminal Ig-domains of obscurin and obsl 1, lead to hereditary muscle diseases. The M 10 domain is unusual not only in that it is a frequent target of disease-linked mutations, but also in that it is the only currently known muscle Ig-domain that interacts with two ligands—obscurin and obsl 1 —in different sarcomeric subregions. Using x-ray crystallography, we show the structural basis for titin M 10 interaction with obsl 1 in a novel antiparallel Ig-Ig architecture and unravel the molecular basis of titin-M 10 linked myopathies. The severity of these pathologies correlates with the disruption of the titin-obsl 1 /obscurin complex. Conserved signature residues at the interface account for differences in affinity that direct the cellular sorting in cardiomyocytes. By engineering the <b>interface</b> <b>signature</b> residues of obsl 1 to obscurin, and vice versa, their affinity for titin can be modulated similar to the native proteins. In single-molecule force-spectroscopy experiments, both complexes yield at forces of around 30  pN, much lower than those observed for the mechanically stable Z-disk complex of titin and telethonin, suggesting why even moderate weakening of the obsl 1 /obscurin-titin links has severe consequences for normal muscle functions...|$|E
40|$|Computer {{security}} {{has become a}} crucial issue in recent years. More than ever, computer scientists, developers and clients {{are concerned about the}} vulnerabilities and risks provoked by failures or omissions made in almost every stage of the software development process. More specifically, improper access to sensitive resources by malicious code has been recognized as an important source of failures, information loss, service denial, among others. In practice, software designers and developers are entitled to specify which sensitive resources within a system are to be protected from misuse by imposing access constraints on them. This work proposes a mechanism to produce such constraints by making use of formal specification for software modules, concretely, Java modules. The behavior of a Java module, such as a class or a method, can be specified in a formal way so that such specification can be used by specialized tools in order to reason about the correctness of its implementation with respect to a formal specification. We propose to extend a behavioral interface specification language, called Java Modeling Language (JML), so that access control constraints can be specified along with behavioral descriptions, relating the expected behavior of a module with the constraints imposed to sensitive resources, such as database files, network ports, memory space, etc. We present two different extensions, first, an approach called Permission-based approach, which makes use of the features of the Java security architecture. Next, we introduce a solution called Visibility-based approach, which restricts the visibility of a JML-annotated module in order to allow only certain clients to call the module, depending on its class or <b>interface</b> <b>signature</b> or method name. In order to support our approach we present the overall design and implementation issues of a prototype tool which generates runtime assertion checking (RAC) code based on a subset of the JML and our proposed extensions. We also present the results of evaluating our approach by means of a set of case studies. We discuss the lessons learned during the process, which show that our approach is suitable to specify the behavior of a Java module with respect to access control constraints. We also mention the limitations of our approach we have detected. We conclude by relating our proposal to existing approaches and discussing topics for future work. ...|$|E
40|$|Research reportIn component-based {{software}} development approaches, components are considered as black boxes. Components communicate through required and provided interfaces which describe their visible behaviors. In the best cases, the provided interfaces are checked {{compatible with the}} corresponding required interfaces, but in general cases, adapters have to be introduced to connect them. Compatibility between required and provided interfaces concerns the <b>interface</b> <b>signatures,</b> behavioral aspects and protocol level. We propose to specify component interfaces in B in order to verify these three levels of interoperability. The use of B assembling and refinement mechanisms eases the verification of the interoperability between interfaces and the correctness of the component assembly. The verification {{is done by the}} B prover...|$|R
5000|$|<b>Interface</b> file (ML-like <b>signature)</b> with [...]urs extension:(* the {{environment}} monad is called transaction, corresponds to Haskells IO monad *)val main : unit -> transaction page ...|$|R
50|$|The ETSI-MSS {{specifications}} {{define a}} SOAP <b>interface</b> and mobile <b>signature</b> roaming for systems implementing mobile signature services. ETSI TS 102 204, and ETSI TS 102 207.|$|R
40|$|A {{number of}} {{matchmaking}} {{methods have been}} proposed and used for various applications. However, the issues associated with matchmaking for web services that involve data repository are not well addressed by the existing methods which focus on service capabilities, <b>interface</b> <b>signatures,</b> and so on. This results from that the information and data in repository are not considered for matchmaking. In our previous work, we proposed a fuzzy matchmaking framework which exploits fuzzy logic to abstract and classify the underlying data of web services as fuzzy terms and rules. As a result, it increases {{the efficiency of the}} discovery of web services and allows imprecise or vague terms incorporated in the search. However, the assumption of unified (consensus) value between service providers and consumers for the service is made. In this paper, a fuzzy moderator is introduced in order to provide a tracking mechanism for ����������� feedbacks and moderate their values. 1...|$|R
40|$|Transcriptome {{analysis}} can provide useful data for refining genome sequence annotation. Application of massively parallel signature sequencing (MPSS) revealed reproducible transcription, in multiple MPSS cycles, from 73 % of computationally predicted {{genes in the}} Theileria parva schizont lifecycle stage. Signatures spanning consecutive exons confirmed 142 predicted introns. MPSS identified 83 putative genes, > 100 codons overlooked by annotation software, and 139 potentially incorrect gene models (with either truncated ORFs or overlooked exons) by <b>interfacing</b> <b>signature</b> locations with stop codon maps. Twenty representative models were confirmed {{as likely to be}} incorrect using reverse transcription PCR amplification from independent schizont cDNA preparations. More than 50 % of the 60 putative single copy genes in T. parva that were absent from the genome of the closely related T. annulata had MPSS signatures. This study illustrates the utility of MPSS for improving annotation of small, gene-rich microbial eukaryotic genomes...|$|R
40|$|To {{programmatically}} {{discover and}} interact with services in ubiquitous computing environments, an application needs to solve two problems: (1) is it semantically meaningful to interact with a service? If the task is “printing a file”, a printer service would be appropriate, but a screen rendering service or CD player service would not. (2) If yes, what are the mechanics of interacting with the service – remote invocation mechanics, names of methods, numbers and types of arguments, etc. ? Existing service frameworks such as Jini [1] and UPnP [22] conflate these problems— two services are “semantically compatible ” {{if and only if}} their <b>interface</b> <b>signatures</b> match. As a result, interoperability is severely restricted unless there is a single, globally agreed-upon, unique interface for each service type. By separating the two subproblems and delegating different parts of the problem to the user and the system, we show how applications can interoperate with services even when globally unique interfaces do not exist for certain services. ...|$|R
40|$|Trushar Shah, Etienne de Villiers, Evans Taracha, Roger Pelle and Richard Bishop are ILRI authorsTranscriptome {{analysis}} can provide useful data for refining genome sequence annotation. Application of massively parallel signature sequencing (MPSS) revealed reproducible transcription, in multiple MPSS cycles, from 73 % of computationally predicted {{genes in the}} Theileria parva schizont lifecycle stage. Signatures spanning consecutive exons confirmed 142 predicted introns. MPSS identified 83 putative genes, > 100 codons overlooked by annotation software, and 139 potentially incorrect gene models (with either truncated ORFs or overlooked exons) by <b>interfacing</b> <b>signature</b> locations with stop codon maps. Twenty representative models were confirmed {{as likely to be}} incorrect using reverse transcription PCR amplification from independent schizont cDNA preparations. More than 50 % of the 60 putative single copy genes in T. parva that were absent from the genome of the closely related T. annulata had MPSS signatures. This study illustrates the utility of MPSS for improving annotation of small, gene-rich microbial eukaryotic genomes...|$|R
40|$|In {{component}} software, {{the independence}} of components is achieved by separating their interfaces from implementations. The interface definition of a component serves as the contract with its neighbouring components {{regarding the use of}} its services. In general, such a contract should cover issues beyond <b>interface</b> <b>signatures,</b> such as service functionality, usage and quality. The Interface Definition Languages (IDLs) used by commercial middleware such as CORBA, however, lack mechanisms for capturing such semantic characteristics. In this paper, we introduce a framework and associated techniques that augment commercial IDLs with behavioural contract specifications and validate at runtime component interactions against such contracts. The behavioural contract of a component describes occurrence or sequencing constraints on its interactions with the environment. The validation of such constraints is achieved by intercepting runtime interactions between components and validating them against the finite state automata that semantically represent the constraints. The validation provides a useful tool for testing whether the component services are used properly and whether the component fulfils its behavioural obligations in a distributed system. 1...|$|R
40|$|Interoperability {{remains a}} {{significant}} challenge in today's distributed systems; {{it is necessary}} to quickly compose and connect (often at runtime) previously developed and deployed systems in order to build more complex systems of systems. However, such systems are characterized by heterogeneity at both the application and middleware-level, where application differences are seen in terms of incompatible <b>interface</b> <b>signatures</b> and data content, and at the middleware level in terms of heterogeneous communication protocols. Consider a Flickr client implemented upon the XML-RPC protocol being composed with Picasa's Service; here, the Flickr and Picasa APIs differ significantly, and the underlying communication protocols are different. A number of ad-hoc solutions exist to resolve differences at either distinct level, e. g., data translation technologies, service choreography tools, or protocol bridges; however, we argue that middleware solutions to interoperability should support developers in addressing these challenges using a unified framework. For this purpose we present the Starlink framework, which allows an interoperability solution to be specified using domain specific languages that are then used to generate the necessary executable software to enable runtime interoperability. We demonstrate the effectiveness of Starlink using an application case-study and show that it successfully resolves combined application and middleware heterogeneity...|$|R
40|$|AbstractComponent updates always {{bear the}} risk of {{negatively}} influencing the operativeness of software systems. Due to improper combinations of component versions, dependencies may break. In practise this often {{turns out to be}} due to missing or incompatible <b>interfaces</b> and <b>signatures</b> (syntactical <b>interface)</b> but may also be caused by changes in behavior or quality. In this paper we model the problem of finding a well-configured system consisting of multiple component versions as a Boolean Optimization Problem. To achieve this, we introduce objective functions and constraints that lead to most recent, minimal systems and use Branch-and-Bound to restrict the search space...|$|R
40|$|A {{significant}} hurdle {{confronts the}} software reuser attempting to select candidate components from a software repository - discriminating between those components {{without resorting to}} inspection of the implementation(s). We outline a mixed classification/axiomatic approach to this problem based upon our lattice-based faceted classification technique and Guttag and Horning's algebraic specification techniques. This approach selects candidates by natural language-derived classification, by their <b>interfaces,</b> using <b>signatures,</b> and by their behavior, using axioms. We briefly outline our problem domain and related work. Lattice-based faceted classifications are described; the reader is referred to surveys of the extensive literature for algebraic specification techniques. Behavioral support for reuse queries is presented, followed by the conclusions...|$|R
40|$|Abstract. Available component-oriented {{platforms}} address software interoperability only at {{the signature}} level, while they do not provide suitable mechanisms for adapting components with mismatching interaction behaviour. This paper presents a methodology for automatically developing adaptors capable of solving behaviour mismatches between heterogeneous components. These adaptors are generated from abstract specifications of the intended connection between the components, by taking into account both <b>signature</b> <b>interfaces</b> and component behaviours. ...|$|R
50|$|Krause {{significantly}} broadened conventional {{notions of}} the graphical user interface by applying innovative design principles and providing realtime interaction for the user, neither of which were widely deployed in the 1980s because of the low graphics abilities of the current hardware. Krause's products featured <b>signature</b> <b>interface</b> elements including soft shadows, rounded corners and translucency - all of which would later enjoy wider adoption, such as seen in Mac OS X, Windows XP Luna and Linux.|$|R
40|$|We report {{growth of}} high quality ZnO/Zn 0. 8 Mg 0. 2 O quantum well on M-plane {{oriented}} ZnO substrates. The optical properties of these quantum wells are studied by using reflectance spectroscopy. The optical spectra reveal strong in-plane optical anisotropies, as predicted by group theory, and marked reflectance structures, as an evidence of good <b>interface</b> morphologies. <b>Signatures</b> ofc onfined excitons built from the spin-orbit split-off valence band, the analog of exciton C in bulk ZnO are detected in normal incidence reflectivity experiments using a photon polarized along the c axis of the wurtzite lattice. Experiments performed {{in the context of}} an orthogonal photon polarization, at 90 ^∘; of this axis, reveal confined states analogs of A and B bulk excitons. Envelope function calculations which include excitonic interaction nicely account for the experimental report...|$|R
40|$|Factory 7 {{provide a}} {{solution}} based on abstract <b>interfaces</b> with <b>signatures</b> returning a base class object. Users can customize {{the implementation of}} these interfaces Camera Speaker ################ ################ ####### ############ ##### ATMTransportAdapter TcpTransportAdapter Splitter Combiner AudioCombiner Figure 11. An application of the Layers pattern in MediaBuilder. 182 Bell LabsTechnical Journal uWinter 1997 through inheritance such that an instance of their concrete class is returned. This type of mechanismcan be regarded as an object-oriented form of application callback. Many frameworks use Factory-type patterns. However, framework users still have to explicitly overload factory interfaces. Deriving new classes requires updating the factory and recompiling the application. Problem How can we make a factory whose product line can be configured by plugging in derived classes created by the framework? For example, if we introduce a fax medium into a MediaBuilder [...] ...|$|R
40|$|Abstract. A surface {{plasma wave}} (SPW) over bismuth–vacuum <b>interface</b> has a <b>signature</b> of mass {{anisotropy}} of free electrons. For SPW propagation along the trigonal axis {{there is no}} birefringence. The frequency cutoff of SPW ωcutoff ωp 2 εL ε lies in the far infrared region and can be accessed using free electron laser. The damping rate of waves at low temperatures is low. The surface plasma wave may be excited by an electron beam of current 100 mA propagating parallel to the interface in its close proximity...|$|R
40|$|Component based {{software}} engineering (CBSE) repre-sents an exciting and promising paradigm for software de-velopment, attracting much interest and effort from indus-trial practice and scientific research. Software components {{are one of}} the key issues in CBSE. While practical, the current component models are limited in providing support for CBSE. In this paper, we introduce a framework aimed at comprehensive interface modelling for software compo-nents in the context of CBSE. This framework deals with in-terface <b>signature,</b> <b>interface</b> constraints, interface packaging and configurations, and non-functional properties of soft-ware components. 1...|$|R
40|$|We here {{demonstrate}} the interfacial spin to charge current conversion {{by means of}} spin pumping from a ferromagnetic Permalloy (Py: Ni 80 Fe 20) to a Cu/Bi 2 O 3 <b>interface.</b> A clear <b>signature</b> of the spin to charge current conversion was observed in voltage spectrum of a Py/Cu/Bi 2 O 3 trilayer film whereas no signature in a Py/Cu and Py/Bi 2 O 3 bilayer films. We {{also found that the}} conversion coefficient strongly depended on Cu thickness, reflecting the thickness dependent momentum relaxation time in Cu layer. Comment: 13 pages, 3 figure...|$|R
40|$|International audienceIn {{this work}} we model the {{interaction}} signature concepts in a consistent and compact manner {{as well as}} their related type checking rules. First, we begin by literally analyzing those concepts in order to bring unambiguous definitions out of them. Following this analysis we shall formalize those concepts by mapping them into UML language constructs. Secondly, we specify constraints imposed on computational <b>interfaces</b> interaction <b>signatures</b> related to the computational language typing and subtyping rules. We shall show how we can we literally redefine those rules in order to steadily formalize them. After rewriting those rules in a compact way, we make use of OCL 2. 0 which provides the means to exploit those new definitions. Then we introduce the concept of Functional computational interface and a set of related concepts which unify signal and operation interfaces notions. Based on the new additional concepts introduced, we introduce two new important concepts, namely; QoS-definable interactions and QoS-capable interfaces. We then provide a UML metamodel of <b>interfaces</b> and interaction <b>signatures.</b> The final metamodel being a first step towards a QoS-capable computational metamodel. Finally, as an application of our modeling choices we define ODP QoScapable computational interfaces type checking rules and then specify them using OCL 2. 0 Dans ce travail, nous analysons le concept ODP de signatures d’interfaces de traitement et leurs règles de typages, le but étant de redéfinir les signatures de manière concise et compacte. Pour cela, nous modélisons les signatures par des concepts UML équivalents. Ensuite, nous spécifieons des contraintes imposées sur ces signatures d’interfaces de traitement ODP liées aux règles de typages et sous-typages. Nous allons montrer également comment nous pouvons littéralement redéfinir ces règles afin de mieux les formaliser en utilisant OCL 2. 0. Par la suite nous introduisons trois nouveaux concepts qui sont: functional computational interfaces, QoS-definable interactions and QoS-capable interfaces. Finalement, nous définissons les règles typologiques relatives aux QoS-capable interfaces et les spécifions en OCL 2. ...|$|R
40|$|We analyze stress {{transmission}} in granular media {{involving an}} interstitial cementing matrix of variable volume fraction. We {{rely on a}} lattice-type discretization of both the particles and cemented matrix. This Lattice Element Method gives access to elastic deformations and stress fields inside the particles and matrix, {{as well as at}} their <b>interface.</b> The <b>signature</b> of granular structure appears clearly on the probability density functions (pdf) of node stresses. We show that the stress chains are mainly guided by the particles in compression and by the matrix in tension. In tension, the stress component pdf’s are increasingly broader for a decreasing matrix volume fraction whereas in compression they depend only on the particle stiffness. The pdf’s are found to be gaussian inside the particles and exponential at their contact points. We compare in detail the contact force network computed from stresses localized at the matrix bridges between particles with that obtained from molecular dynamics simulations of the same system by using rigid particles with cohesive interactions. As far as contact forces are concerned the lattice element method yields the same force patterns and distributions as in molecular dynamics. The granular microstructure is the common denomina-tor of a broad class of solid materials including sedimen...|$|R
40|$|Single {{superclass}} inheritance enables {{simple and}} ecient table-driven virtual method dispatch. However, virtual method table dispatch does not handle multiple inheritance and interfaces. This complication {{has led to}} a widespread misimpression that interface method dispatch is inherently inecient. This paper argues that with proper implementation techniques, Java interfaces need not be a source of significant performance degradation. We present an efficient interface method dispatch mechanism, associating a fixed-sized interface method table (IMT) with each class that implements an <b>interface.</b> <b>Interface</b> method <b>signatures</b> hash to an IMT slot, with any hashing collisions handled by custom-generated conflict resolution stubs. The dispatch mechanism is efficient in both time and space. Furthermore, with static analysis and online profile data, an optimizing compiler can inline the dominant target(s) of any frequently executed interface call. Micro-benchmark results demonstrate that the expected cost of an interface method call dispatched via an IMT is comparable to the cost of a virtual method call. Experimental evaluation of a number of interface dispatch mechanisms on a suite of larger applications demonstrates that, even for applications that make only moderate use of interface methods, the choice of interface dispatching mechanism can significantly impact overall performance. Fortunately, several mechanisms provide good performance at a modest space cost...|$|R
40|$|Spin {{transport}} {{currents and}} the spin-transfer torques in voltage-biased superconducting-ferromagnetic nanopillars (SFNFS point contacts) are computed. We {{develop and implement}} an algorithm based on the Ricatti formulation of the quasiclassical theory of superconductivity to solve the time-dependent boundary conditions for the nonequilibrium Green's functions for spin transport through the ferromagnetic <b>interfaces.</b> A <b>signature</b> of the nonequilibrium torque is a component perpendicular to the plane spanned by the two ferromagnetic moments. The perpendicular component is absent in normal-metal-ferromagnetic nanopillars (NFNFN) contacts, but is shown {{to have the same}} order of magnitude as the in-plane torque for non-equilibrium SFNFS contacts. The out-of-plane torque is due to the rotation of quasiparticle spin by the exchange fields of the ferromagnetic layers. In the ballistic limit the equilibrium torque is related to the spectrum of spin-polarized Andreev bound states, while the ac component, for small bias voltages, is determined by the nearly adiabatic dynamics of the Andreev bound states. The nonlinear voltage dependence of the non-equilibrium torque, including the subharmonic gap structure and the high-voltage asymptotics, is attributed to the interplay between multiple Andreev reflections, spin filtering and spin mixing. These properties of spin angular momentum transport may be exploited to control the state of nanomagnets. Comment: 15 pages, 14 figure...|$|R
40|$|The RoleAdapter Design Pattern allows using {{objects of}} any model {{as if they}} {{implemented}} any given programmatic interface, with contextual behavior. To achieve this, it makes objects from many basic building blocks of OOP, like methods, method <b>signatures,</b> <b>interfaces,</b> etc. This allows clients of a data model to define, at run-time, an interface for any data model they have to use. Objects encapsulating methods, defined independently for the model, are chosen and bound to the signatures included in the interface according to external configuration hints. Since the adaptation is done local to a context, different view instances can show different aspects of a complex model. The resulting composite definition of interface is similar in intent to that of subject-oriented programming, but achieved wholly within a traditional OOPL like Java...|$|R
40|$|XML Encryption and XML Signature {{describe}} {{how to apply}} encryption and signing algorithms to XML documents. These specifications are implemented in XML frameworks of major commercial and open source organizations like Apache, IBM, Microsoft, or SAP. They are employed in {{a large number of}} major web applications, ranging from business communications, eCommerce, and financial services over healthcare applications to governmental and military infrastructures. This thesis analyzes the security of these specifications and presents several practical and highly critical attacks. First, it describes different classical and novel XML Signature Wrapping (XSW) attack techniques, which allow to break integrity of signed XML documents. The attacks exploit weak <b>interfaces</b> between XML <b>Signature</b> validation and XML processing modules deployed in different frameworks. Their criticality is confirmed by applications to cloud and Single Sign-On interfaces: an attacker was able to use them to gain control over victim’...|$|R
40|$|International audienceComponent {{models for}} {{autonomous}} robots control architectures {{are much more}} constrained than traditional ones: obeying strict timing constraints, coping with a large spectrum of rapidly changing hardware (e. g. sensors and actuators), etc. Beyond introducing new concepts into components themselves, composition in such models must go much farther than the standard connection through method <b>signature</b> <b>interfaces.</b> Viewing components as full-fledged sensori-motor behaviors, our model follows the concept of rich interfaces introduced by Henzinger et al. to attach to each component all the necessary syntactical and behavioral information to make them externally composable. This paper presents two kinds of composition, parallel and by modes, their semantics, their compositionality properties {{and the impact of}} these on the composition model. A prototype implementation in Java is backed by a constructive semantics defined as a constraint system solved in this prototype with the ECLIPSe constraint programming system...|$|R
40|$|Breaking without air {{entrainment}} of very short wind-forced waves, or microscale wave breaking, is undoubtedly widespread over the oceans and {{may prove to}} be a significant mechanism for enhancing the transfer of heat and gas across the air-sea interface. However, quantifying the effects of microscale wave breaking has been difficult because the phenomenon lacks the visible manifestation of whitecapping. In this brief report we present limited but promising laboratory measurements which show that microscale wave breaking associated with evolving wind waves disturbs the thermal boundary layer at the air-water <b>interface,</b> producing <b>signatures</b> that can be detected with infrared imagery. Simultaneous video and infrared observations show that the infrared signature itself may serve as a practical means of defining and characterizing the microscale breaking process. The infrared imagery is used to quantify microscale breaking waves in terms of the frequency of occurrence and the areal coverage, which is substantial under the moderate wind speed conditions investigated. The results imply that ”bursting“ phenomena observed beneath laboratory wind waves are likely produced by microscale breaking waves but that not all microscale breaking waves produce bursts. Oceanic measurements show the ability to quantify microscale wave breaking in the field. Our results demonstrate that infrared techniques can provide the information necessary to quantify the breaking process for inclusion in models of air-sea heat and gas fluxes, as well as unprecedented details on the origin and evolution of microscale wave breaking...|$|R
40|$|Cardelli and Wegner {{developed}} a simple theory of object subtyping which was later {{to form the}} basis for a second-order theory of bounded quantification [Card 84, CW 85, Ghel 90] and the higher-order theory of F-bounded quantification explored by Cook and others [CCHO 89 a, CHC 90]. In all of these presentations, the abstract type of objects is only expressed syntactically, in terms of an external <b>interface</b> of function <b>signatures.</b> Here, we re-introduce semantic descriptions for objects, in terms of sets of axioms constraining the operation of some invocations of their functions. We use the well-understood technique of definition by comprehension to motivate subtyping rules for object axioms and prove how these rules interact properly with Cardelli-Wegner style subtyping rules. For languages like Eiffel [Meye 88, Meye 92] and Sather [Omoh 94] in which programmers can write object axioms, rules governing the addition of preconditions, postconditions and data type invariants can now be motivated fr [...] ...|$|R
