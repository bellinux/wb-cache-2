19|402|Public
25|$|Has {{powerful}} <b>indexed</b> <b>addressing</b> modes.|$|E
25|$|MIPS IV is {{the fourth}} version of the architecture. It is a superset of MIPS III and is {{compatible}} with all existing versions of MIPS. MIPS IV was designed to mainly improve floating-point (FP) performance. To improve access to operands, an <b>indexed</b> <b>addressing</b> mode (base + index, both sourced from GPRs) for FP loads and stores was added, as were prefetch instructions for performing memory prefetching and specifying cache hints (these supported both the base + offset and base + index addressing modes).|$|E
5000|$|... 4 bits (20 to 23) {{specifying the}} Index {{register}} {{to use with}} <b>indexed</b> <b>addressing</b> modes ...|$|E
50|$|<b>Index</b> <b>addressing</b> {{was only}} {{possible}} for index registers.|$|R
50|$|Below is {{an example}} that will strength-reduce all the loop multiplications that arose from array <b>indexing</b> <b>address</b> calculations.|$|R
5000|$|It was an 18-bit machine, with 17 {{magnitude}} {{bits and}} a sign bit. The addresses were 13 bits long; MSB indicated <b>index</b> <b>addressing.</b>|$|R
50|$|The fetch/execute {{mechanism}} {{was completely}} redesigned, optimizing {{the timing and}} allowing partial fetches when the P or Q fields were not needed. Instructions took either 1, 4, or 6 Memory cycles (10 µs, 40 µs, or 60 µs) to fetch and a variable number of memory cycles to execute. Indirect addressing added 3 memory cycles (30 µs) for each level of indirection. <b>Indexed</b> <b>addressing</b> added 5 memory cycles (50 µs) for each level of indexing. Indirect and <b>indexed</b> <b>addressing</b> could be combined at any level of indirection or indexing.|$|E
50|$|The {{address space}} was 15 bits, {{limiting}} the 1130 to 32,768 16-bit words (65,536 bytes) of memory. The 1130 used magnetic-core memory, which the processor addressed on word boundaries, using direct, indirect, and <b>indexed</b> <b>addressing</b> modes.|$|E
5000|$|One of {{the reasons}} for the 8051s {{popularity}} is its range of operations on single bits. Bits are always specified by absolute addresses; there is no register-indirect or <b>indexed</b> <b>addressing.</b> Instructions that operate on single bits are: ...|$|E
50|$|This {{is similar}} to scaled <b>index</b> <b>addressing,</b> except that the {{instruction}} has two extra operands (typically constants), and the hardware checks that the index value is between these bounds.|$|R
40|$|Several {{different}} adressing {{mechanisms are}} evaluated {{within the context}} of VLIW and superscalar processor design. The results suggest that traditional RISC addressing mechanisms are less effective than the other simpler addressing mechanisms considered. In particular, the ORed <b>indexing</b> <b>addressing</b> mechanism significantly improves performance...|$|R
40|$|This {{publication}} {{is available}} in microform and annually on CD-Rom. Papers published in this journal are covered in BECITM, INSPEC, Chemical Abstracts, and Science Citation <b>Index.</b> <b>Address</b> remittances, orders for subscriptions and single copies, claims for missing numbers, and notices of change of address to IS&T at 7003 Kilworth Lane...|$|R
50|$|<b>Indexed</b> <b>addressing</b> modes add a 16-bit {{extension}} {{word to the}} instruction. If both {{source and}} destination are indexed, the source extension word comes first. x refers to the next extension word in the instruction stream in the table below.|$|E
50|$|The {{proposed}} {{specifications for}} the 8104 appear {{similar to the}} 8103. It featured {{a full complement of}} instructions for fixed and floating point arithmetic and storage-to-storage character operations. All instructions were 32 bits in length. The 8104 supported direct addressing, indirect addressing, and <b>indexed</b> <b>addressing</b> with 255 index registers.|$|E
50|$|Most operands {{can apply}} any of eight {{addressing}} modes to eight registers. The addressing modes provide register, immediate, absolute, relative, deferred (indirect), and <b>indexed</b> <b>addressing,</b> and can specify autoincrementation and autodecrementation of a register by one (byte instructions) or two (word instructions). Use of relative addressing lets a machine-language program be position-independent.|$|E
50|$|This {{addressing}} mode {{is closely related}} to the <b>indexed</b> absolute <b>addressing</b> mode.|$|R
5000|$|... #Caption: This {{illustration}} {{shows how}} a cube map is <b>indexed</b> and <b>addressed.</b>|$|R
50|$|Interleaving has {{performance}} {{implications for}} cache coherency, ease of leveraging SIMD hardware, and leveraging a computer's addressing modes. (e.g. - interleaved data may require one address to be calculated, from which individual fields may then be accessed via immediate offsets; conversely {{if only one}} field is required by index, de-interleaved data may leverage scaled <b>index</b> <b>addressing).</b>|$|R
5000|$|Within the subprogram, {{parameters}} {{could be}} accessed by indirect <b>indexed</b> <b>addressing</b> as shown above in Variations, so, given that XR1 has been suitably prepared, an integer parameter could be {{loaded into the}} accumulator with an instruction like this: LD I1 0 Load {{the value of the}} first parameter (offset 0) into the accumulator ...|$|E
5000|$|If SIMPL took {{parameters}} coded in-line {{following the}} BSI instruction, SIMPL could {{gain access to}} them with <b>indexed</b> <b>addressing</b> off XR1. The first could be obtained by , the second by , and so on. If the second parameter was {{the address of the}} actual parameter, then [...] would obtain its value. Before returning, SIMPL would increment XR1 past the n parameters with an instruction such as [...] so as to place the right value at RETN+1.|$|E
5000|$|Structure of arrays (or SoA) is a layout {{separating}} {{elements of}} a record (or 'struct' in the C programming language) into one parallel array per field. The motivation is easier manipulation with packed SIMD instructions in most instruction set architectures, since a single SIMD register can load homogeneous data, possibly transferred by a wide internal datapath (e.g. 128-bit). The downside is requiring more cache ways when traversing data, and inefficient <b>indexed</b> <b>addressing.</b> (see also: planar image format) ...|$|E
5000|$|Whitespace, if {{instruction}} specifies any <b>index</b> registers, <b>addressing</b> mode or a parameter {{and then}} comma-separated: ...|$|R
40|$|Issued {{also under}} title: Account of the centennial celebration in Danvers. Another edition with similar t. p. has 63 p. Includes bibliographical {{references}} and <b>index.</b> <b>Address</b> / by J. W. Proctor [...] Danvers, a poem / by Andrew Nichols [...] Danvers centennial celebration [...] Proceedings {{of the town}} of Danvers, in relation to the donation of George Peabody, Esq., of London. Mode of access: Internet...|$|R
5000|$|He never married, and, in the Posts {{employee}} <b>index,</b> his <b>address</b> {{was listed}} as simply [...] "The Washington Post".|$|R
50|$|MIPS IV is {{the fourth}} version of the architecture. It is a superset of MIPS III and is {{compatible}} with all existing versions of MIPS. MIPS IV was designed to mainly improve floating-point (FP) performance. To improve access to operands, an <b>indexed</b> <b>addressing</b> mode (base + index, both sourced from GPRs) for FP loads and stores was added, as were prefetch instructions for performing memory prefetching and specifying cache hints (these supported both the base + offset and base + index addressing modes).|$|E
50|$|Internally, the 9S08 {{instruction}} set is upward {{compatible with the}} 6805, {{with the addition of}} stack <b>indexed</b> <b>addressing</b> modes. (Instructions using the SP register have opcodes prefixed with the byte 0x9E). It has a single eight-bit accumulator, A, one eight-bit index register, X, or one sixteen-bit index registers, HX (formed from the combination of H and X registers), a condition code register, a 16-bit stack pointer, and a program counter. For compatibility with the 6805 which does not have an H register, the most significant byte of the HX register, H, is cleared during reset, and H is the only register not stacked automatically when entering any ISR (Interrupt Service Routine). Some instructions treat the H and X registers as a combined 16-bit HX register. Unlike the 6805, the stack can be placed anywhere in memory using appropriate instructions.|$|E
40|$|A {{scalable}} parallel algorithm for matrix multiplication on SISAMD computers is presented. Our method {{enables us}} to implement an efficient BLAS library on the Italian APE 100 /Quadrics SISAMD massively parallel computer on which hitherto scalable parallel BLAS- 3 were not available. The approach proposed {{is based on a}} one-dimensional ring connectivity. The flow of data is hyper-systolic. The communication overhead is competitive with that of established algorithms for SIMD and MIMD machines. Advantages are that (i) the layout of the matrices is preserved during the computation, (ii) BLAS- 2 fit well into this layout and (iii) <b>indexed</b> <b>addressing</b> is avoided, which renders the algorithm suitable for SISAMD machines and! in this way, for all other types of parallel computers. On the APE 100 /Quadrics, a performance of nearly 25 % of the peak performance for multiplications of complex matrices is achieved...|$|E
30|$|Inversion {{process is}} preferably {{replaced}} by look-up table (LUT). LUT is appraised as an efficient implementation of inversion process by using memory instead {{of large numbers}} of logical elements. Both resource utilization and propagation delay are reduced at the cost of accuracy. The utilized LUT should contain all possible inverse values. The value x intended to be inverted is used directly as the LUT <b>index</b> (<b>address)</b> to retrieve the inverse value 1 /x.|$|R
50|$|Each {{instruction}} contained six bits of opcode, one bit specifying whether {{indirect addressing}} used, two bits of <b>index</b> register <b>address</b> and fifteen bits of address.|$|R
5000|$|The 2010 Human Development Report {{continued}} the HDI tradition of measurement innovation by introducing new <b>indices</b> that <b>address</b> crucial development factors not directly {{reflected in the}} HDI: ...|$|R
40|$|Many application-specific {{architectures}} provide {{indirect addressing}} modes with auto-increment/decrement arithmetic. Since these architectures {{generally do not}} feature an <b>indexed</b> <b>addressing</b> mode, stack-allocated variables must be accessed by allocating address registers and performing address arithmetic. Subsuming address arithmetic into auto-increment/decrement arithmetic improves both the performance {{and size of the}} generated code. Our objective in this paper is to provide a method for comprehensively analyzing the performance benefits and hardware cost due to an auto-increment/decrement feature that varies from,l to +l, and allowing access to k address registers in an address generator. We provide this method via a parameterizable optimization algorithm that operates on a procedure-wise basis. Hence, the optimization techniques in a compiler can be used not only to generate efficient or compact code, but also to help the designer of a custom DSP architecture make decisions on addre [...] ...|$|E
40|$|Many {{embedded}} architectures provide {{indirect addressing}} modes with autoincrement /decrement arithmetic. Since these architectures {{generally do not}} feature an <b>indexed</b> <b>addressing</b> mode, automatic variables must be accessed by allocating address registers and performing address arithmetic. Subsuming address arithmetic into auto-increment/decrement arithmetic improves both the performance {{and size of the}} generated code. Our objective in this paper is to provide a method for comprehensively analyzing the performance benefits and hardware cost resulting from an auto-increment/decrement feature that varies from to +l, and a file of k address registers in an address generator. We provide this method via a parameterizable optimization algorithm that operates on a procedure-wise basis. We present two sets of experimental results based on selected benchmark programs: (1) the values of l and k beyond which {{there is little or no}} improvement in performance, and (2) the values of l and k whic [...] ...|$|E
40|$|When multi port {{memories}} {{are used in}} the design of digital systems it becomes necessary to assign the accesses to the memory to its ports. This problem {{is referred to as the}} port assignment (PA) problem. Here we present techniques for the PA of memories with two and three ports. PA occurs in conjunction with memory formation where it desirable to know the cost of PA for a packing of variables to a particular memory without the actual assignment. We present an estimator for the cost of PA of dual port memories. 1 Introduction Memories constitute an important part of digital systems. Memories support <b>indexed</b> <b>addressing</b> which is a common programming practice. Individual variables used in a program which might otherwise have been implemented in individual registers may be packed into memories. The latter is an important source of interconnect optimization because a large number of individual registers in the design would lead to the use of more interconnection hardware. For the design of [...] ...|$|E
40|$|The {{development}} of an index to compare different sources of energy is presented; the <b>index</b> <b>address</b> the appraisal {{of the source of}} energy from its sustainable performance and also using the factors that influence the user's decision making process of adopting an alternative energy. The index is used to compare the fuel cell system and the traditional grid system powered by coal fired power plants, for a typical residential unit located in the rural Appalachian region in Ohio. M. S. Committee Chair: Castro-Lacouture, Daniel; Committee Member: Gentry, Russell; Committee Member: Thomas-Mobley, Lind...|$|R
40|$|Simplified S 08 {{instruction}} set with added high-performance instructions — LDA, STA, and CLR instructions support the short addressing mode; address $ 0000 to $ 001 F {{can be accessed}} via a single-byte instruction — ADD, SUB, INC, and DEC instructions support the tiny addressing mode; address $ 0000 to $ 000 F can be accessed via a single-byte instruction with reduced instruction cycle — Shadow PC register instructions: SHA and SLA Pending interrupt indication <b>Index</b> <b>addressing</b> via D[X] and X register Direct page access to the entire memory map through paging windo...|$|R
40|$|Original article can {{be found}} at: [URL] Copyright Elsevier B. V. DOI: 10. 1016 / 0165 - 6074 (93) 90060 -X [Full text {{of this article is}} not {{available}} in the UHRA]RISC processors employ simple addressing modes which allow memory addresses to be calculated in a single processor cycle. This paper demonstrates that VLIW and Superscalar processor performance can be improved by further simplifying the addressing modes. In particular, the distinctive ORed <b>indexing</b> <b>addressing</b> mechanism employed by the HARP VLIW processor boosts performance by 10 %. Register indirect addressing on its own yields a similar performance improvement...|$|R
