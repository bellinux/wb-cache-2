0|10000|Public
5000|$|One triply {{indirect}} pointer (a pointer {{that points}} to a block <b>of</b> <b>pointers</b> that point to other blocks <b>of</b> <b>pointers</b> that point to other blocks <b>of</b> <b>pointers</b> that then point to blocks of the file's data) ...|$|R
50|$|The Ca Mè {{is part of}} {{an ancient}} racial breed, with {{presence}} in the <b>hunting</b> <b>of</b> Majorca in the 13th century. It belongs to a trunk of dog breeds pointing dogs, very old and appreciated. Of this trunk have been derived modern breeds, that which as in the case <b>of</b> the <b>Pointer</b> (English Pointer), same have shifted its ancestors.|$|R
5000|$|One doubly {{indirect}} pointer (a pointer {{that points}} to a block <b>of</b> <b>pointers</b> that point to other blocks <b>of</b> <b>pointers</b> that then point to blocks of the file's data) ...|$|R
50|$|Shaul Elovitch's Eurocom Group began accumulating shares <b>of</b> <b>Pointer</b> in August 2008, {{acquiring}} 9.03% of the company. Since December 2008 Eurocom holds 14.66% <b>of</b> <b>Pointer's</b> shares. DBSI Investments controls 37.27% of the company.|$|R
30|$|Although {{we did not}} {{test for}} {{significance}} due to a few observations <b>of</b> <b>pointer</b> years, we found seasonal analysis <b>of</b> <b>pointer</b> years showing negative pointer years were more often associated with dry conditions both in the previous and current year.|$|R
40|$|We {{propose a}} novel notion <b>of</b> <b>pointer</b> race for {{concurrent}} programs manipulating a shared heap. A pointer race is an {{access to a}} memory address which was freed, and {{it is out of}} the accessors control whether or not the cell has been re-allocated. We establish two results. (1) Under the assumption <b>of</b> <b>pointer</b> race freedom, it is sound to verify a program running under explicit memory management as if it was running with garbage collection. (2) Even the requirement <b>of</b> <b>pointer</b> race freedom itself can be verified under the garbage-collected semantics. We then prove analogues of the theorems for a stronger notion <b>of</b> <b>pointer</b> race needed to cope with performance-critical code purposely using racy comparisons and even racy dereferences <b>of</b> <b>pointers.</b> As a practical contribution, we apply our results t o optimize a thread-modular analysis under explicit memory management. Our experiments confirm a speed-up of up to two orders of magnitude...|$|R
40|$|The safety <b>of</b> <b>pointer</b> {{programs}} {{is an important}} issue in high-assurance software design, and their verification re-mains a major challenge. Pointer Logic has been proposed to verify basic safety properties <b>of</b> <b>pointer</b> programs in our previous work, but still lacks support for a wide range <b>of</b> <b>pointer</b> programs. In this work, we present an extension to Pointer Logic by: 1) introducing modular reasoning to scale better on programs involving function calls; 2) allow-ing pointer arithmetic to take more advantage <b>of</b> <b>pointers</b> in programming. Moreover, to demonstrate that Pointer Logic is a useful approach to verification, we implement a tool – plcc to automatically verify a range of non-trivial programs, including basic operations on singly-linked lists, trees, cir-cular doubly-linked list, dynamic arrays etc [...] 1...|$|R
5000|$|ParaSail—object-oriented, parallel, free <b>of</b> <b>pointers,</b> race {{conditions}} ...|$|R
40|$|Pointer warping {{can be an}} {{effective}} alternative to relocate the mouse pointer to a remote display in multi-display environments. It minimizes the mouse pointer travel and does not require the user to search for a path to the target display. However, {{little is known about the}} factors that influence the performance <b>of</b> <b>pointer</b> warping. In this paper we explore the characteristics <b>of</b> <b>pointer</b> warping compared to standard mouse behavior on a dual-monitor setup with varying physical distance. Our results show that the performance <b>of</b> <b>pointer</b> warping is hardly affected by the distance <b>of</b> the <b>pointer</b> warp, but is influenced by the direction of the warp. Author Keywords Pointer warping, multi-display environment...|$|R
5000|$|Automatic {{building}} and dereferencing <b>of</b> <b>pointers</b> from type context.|$|R
2500|$|Argument envp is {{an array}} <b>of</b> <b>pointers</b> to {{environment}} settings.|$|R
2500|$|... Specifies an unsafe context, {{which allows}} the use <b>of</b> <b>pointers.</b>|$|R
5000|$|Customization <b>of</b> <b>pointer</b> appearance, such as size, {{color and}} shape.|$|R
5000|$|... Specifies an unsafe context, {{which allows}} the use <b>of</b> <b>pointers.</b>|$|R
40|$|In this paper, {{we compare}} the {{behavior}} <b>of</b> <b>pointers</b> in C programs, as approximated by static pointer analysis algorithms, {{with the actual}} behavior <b>of</b> <b>pointers</b> when these programs are run. In order to perform this comparison, we have implemented several well known pointer analysis algorithms, and we have built an instrumentation infrastructure for tracking pointer values during program execution...|$|R
40|$|In {{contemporary}} computer systems, {{data layout}} has great influence on performance. Traditionally, automatic restructuring in type-unsafe languages has been hard, {{especially in the}} presence <b>of</b> <b>pointers.</b> In this thesis, the foundations are laid for successful restructuring <b>of</b> <b>pointer</b> linked data structures in type-unsafe languages such as C. Promotor: H. A. G. Wijshoff, Co-promotor: E. M. BakkerWith summary in Dutc...|$|R
40|$|Pointer {{analysis}} {{is a fundamental}} static program analysis, with a rich literature and wide applications. The goal <b>of</b> <b>pointer</b> {{analysis is}} to compute an approximation of the set of program objects that a pointer variable or expression can refer to. We present an introduction and survey <b>of</b> <b>pointer</b> analysis techniques, {{with an emphasis on}} distilling the essence of common analysis algorithms. To this end, we focus on a declarative presentation of a common core <b>of</b> <b>pointer</b> analyses: algorithms are modeled as configurable, yet easy-to-follow, logical specifications. The specifications serve {{as a starting point for}} a broader discussion of the literature, as independent threads spun from the declarative model...|$|R
40|$|This note {{presents}} a calculational method {{for dealing with}} pointers in weakest precondition semantics. It aims at facilitating the verification of program fragments that use pointers, without recourse to operational reasoning. It {{is true that the}} unrestricted use <b>of</b> <b>pointers</b> may be considered somewhat oldfashioned. There is a growing consensus (to which the present author subscribes) that the derivation of correct programs is much to be preferred over any a posteriori verification. Types such as lists and trees have mathematical properties that are simpler than those <b>of</b> <b>pointers,</b> hence are more useful in program derivation. Recent publications concerning pointers typically propose schemes for their abolition [6, 7]. Nevertheless the study <b>of</b> <b>pointers</b> retains some importance, because the more abstract types are usually implemented by means <b>of</b> <b>pointers</b> and one wishes to prove the correctness of such an implementation. Moreover, there exist algorithms that exploit the aliasing effect provided by pointers for efficiency reasons [3]...|$|R
2500|$|... v – Command-line {{arguments}} are {{passed to the}} function as an array (vector) <b>of</b> <b>pointers.</b>|$|R
5000|$|... {{implements}} a persistent, global heap <b>of</b> <b>pointer</b> {{and object}} variables, using reference counting for garbage collection.|$|R
40|$|This paper {{presents}} {{a pair of}} algorithms for output and input <b>of</b> <b>pointer</b> structures in binary format. Both algorithms operate in linear space and time. They {{have been inspired by}} copying compacting garbage collection algorithms, and make similar assumptions about the representations <b>of</b> <b>pointer</b> structures. In real programs, the transfer <b>of</b> entire <b>pointer</b> structures is often inappropriate. The algorithms are extended to lazily transfer partitions <b>of</b> a <b>pointer</b> structure: the receiver requests partitions when it needs them. A remote procedure call mechanism is presented that uses the binary transfer algorithms for communicating arguments and results. A use of this as an enabling mechanism in the implementation of a software engineering environment is discussed. 1. The Proble...|$|R
2500|$|... e – An array <b>of</b> <b>pointers</b> to {{environment}} variables {{is explicitly}} {{passed to the}} new process image.|$|R
5000|$|The {{following}} example builds {{an array}} <b>of</b> <b>pointers</b> {{to all the}} date fields present in the database: ...|$|R
5000|$|... e - An array <b>of</b> <b>pointers</b> to {{environment}} variables {{is explicitly}} {{passed to the}} new process image.|$|R
40|$|AbstractWe {{show that}} the {{well-known}} unfold/fold transformation strategy is also fruitful for the (formal) derivation <b>of</b> correct <b>pointer</b> algorithms. The key to this extension is an algebra of partial maps which allows convenient description and manipulation <b>of</b> <b>pointer</b> structures at the functional level...|$|R
5000|$|Pascal doesn't {{have the}} same kind <b>of</b> <b>pointers</b> as C, but it does have an indirection {{operator}} that covers the most common use <b>of</b> C <b>pointers.</b> Each pointer is bound to a single dynamic data item, and can only be moved by assignment: ...|$|R
5000|$|... is {{a signed}} {{integral}} type {{used to represent}} the difference between pointers. It is only guaranteed to be valid against <b>pointers</b> <b>of</b> the same type; subtraction <b>of</b> <b>pointers</b> consisting <b>of</b> different types is implementation-defined.|$|R
50|$|The {{source code}} of an {{extended}} example of the use <b>of</b> <b>pointers</b> to support a data structure is in pointer.f90.|$|R
50|$|GLSL {{contains}} the operators in C and C++, {{with the exception}} <b>of</b> <b>pointers.</b> Bitwise operators were added in version 1.30.|$|R
50|$|The major {{advantage}} <b>of</b> tagged <b>pointers</b> is {{that they}} take up less space than a pointer along with a separate tag field. This can be especially important when a pointer is a return value from a function. It can also be important in large tables <b>of</b> <b>pointers.</b>|$|R
40|$|In {{this paper}} we present an {{abstract}} representation <b>of</b> <b>pointer</b> structures in Kleene algebras and {{the properties of}} a particular selective update function. These {{can be used as}} prerequisites for the definition <b>of</b> in-situ <b>pointer</b> updates and a general framework to derive in-situ pointer algorithms from their specification...|$|R
40|$|Abstract: Safety is an {{important}} issue among the properties of high-assurance software and the verification methods for software to meet safety policies are one of the hot research. In terms of our sketch of design and verification of safety programs, we design a pointer logic system for a subset of C-like language. This logic system is an extension of Hoare logic system and inference rules are designed to express the modification <b>of</b> <b>pointer</b> information for every kind of statements. It can be used for accurate <b>pointer</b> analysis <b>of</b> <b>pointer</b> programs. The information from the analysis can be used to verify if pointer programs satisfy the side conditions of typing rules and then support safety verification for programs. The logic system {{can also be used to}} verify other properties <b>of</b> <b>pointer</b> programs...|$|R
30|$|Learning {{based on}} {{observations}} and comparisons of target program code, memory image, and target domain world {{would contribute to}} understanding <b>of</b> <b>pointers.</b>|$|R
50|$|The {{resulting}} list <b>of</b> <b>pointers</b> to functions {{is almost}} identical to direct threaded code, and is conceptually similar to a control table.|$|R
5000|$|One singly {{indirect}} pointer (a pointer {{that points}} to a block <b>of</b> <b>pointers</b> that then point to blocks of the file's data) ...|$|R
5000|$|The tower clock swapped size <b>of</b> <b>pointers</b> because <b>of</b> {{economic}} reasons. The big pointer shows {{hours and}} the small pointer shows minutes.|$|R
