33|3288|Public
25|$|The {{ability of}} DOS {{versions}} 5.0 {{and later to}} move their own system core code into the <b>high</b> <b>memory</b> <b>area</b> (HMA) through the DOS=HIGH command gave another boost to free memory.|$|E
25|$|Later, two new {{versions}} were released: Windows/286 2.1 and Windows/386 2.1. Like prior {{versions of}} Windows, Windows/286 2.1 used the real-mode memory model, but {{was the first}} version to support the <b>High</b> <b>Memory</b> <b>Area.</b> Windows/386 2.1 had a protected mode kernel with LIM-standard EMS emulation. All Windows and DOS-based applications {{at the time were}} real mode, running over the protected mode kernel by using the virtual 8086 mode, which was new with the 80386 processor.|$|E
2500|$|Version 5.0 (Retail) – {{includes}} a full-screen editor. [...] A number of bugs required re issue. First version to support 3.5-inch, 2.88 MB floppy drives and diskettes. Hard disk partitions greater than 32 MiB {{and up to}} a maximum size of 2 GiB was now provided by the MS-DOS kernel. First version to load portions of the operating system into the <b>high</b> <b>memory</b> <b>area.</b>|$|E
40|$|This paper quantitatively {{analyzes}} {{thermal gradient}} of SoC and proposes a thermal flattening procedure. First, {{the impact of}} dominant parameters, such as area occupancy of memory/logic, power density, and floorplan on thermal gradient and clock skew are studied. Important results obtained here are 1) the maximum temperature difference increases with <b>higher</b> <b>memory</b> <b>area</b> occupancy and 2) the difference is very floorplan sensitive. Then, we propose a procedure to amend thermal gradient. A slight floorplan modification using the proposed procedure improves on-chip thermal gradient significantly. I...|$|R
5000|$|With {{the arrival}} of {{expanded}} memory boards and especially of Intel 80386 processors {{in the second half}} of the 1980s, it became possible to use memory above 640 KB to load TSRs. This required complex software solutions, named expanded memory managers. Some memory managers are QRAM and QEMM by Quarterdeck, 386MAX by Qualitas, CEMM by Compaq and later EMM386 by Microsoft. The <b>memory</b> <b>areas</b> usable for loading TSRs above 640 KB are called [...] "upper memory blocks" [...] (UMBs) and loading programs into them is called loading <b>high.</b> Later, <b>memory</b> managers started including programs which would try to automatically determine how to best allocate TSRs between low and <b>high</b> <b>memory</b> (Quarterdeck's Optimize or Microsoft's MemMaker) in order to try to maximize the available space in the first 640 KB.|$|R
40|$|This thesis {{describes}} {{a study done}} on a 2 -dimensional wavelet transform hardwarearchitecture that has high throughput, a small <b>memory</b> <b>area,</b> and low energyconsumption and an evaluation of it. Also, the thesis {{describes a}}n applicationstudy done {{to evaluate the effectiveness}} of the wavelet architecture. For the applicationstudy, we used an architecture of a novel digital watermark that detectstampering in a digital image. The method has low overhead in countering illegalattacks to copy digital watermarks. We describe the design of the hardwarearchitecture and our evaluation of it with the wavelet architecture. A wavelet transform has been used for various applications such as image/videocompression, recognition, and watermarking because of its useful characteristicssuch as time-frequency analysis. Also, demand has increased for mobile devices tohandle the many complex applications that can be done on personal computers. In these mobile devices, applications are implemented into the hardware becausethey should have low energy consumption with high throughput. As a result, awavelet architecture that has <b>high</b> throughput, small <b>memory,</b> and low energyconsumption is required. However, no one has been able to design a waveletarchitecture with <b>high</b> throughput, small <b>memory,</b> and low energy consumptionyet. We focused on optimizing memory access by designing two architectures toeliminate the bottleneck of the wavelet operation. One of the architectures balancesthroughput, <b>memory</b> <b>area</b> and energy consumption. The other optimizeshigh throughput and low energy consumption. The evaluation results show thatthe throughput, energy consumption, and <b>memory</b> <b>area</b> of the balanced architecture are 10 times higher, 10 to 20 times lower, and 4 to 50 times lower thanthat of conventional architectures, respectively. Furthermore, the throughput ofthe optimized architecture for high throughput and low energy consumption is 20 times higher than, the energy consumption is 20 to 30 times lower than, andthe <b>memory</b> <b>area</b> is comparable with that of the conventional architectures. We applied the two aforementioned architectures to a watermarking application{{to evaluate the effectiveness of}} the wavelet architecture. Watermarking isone of the information hiding technology for music, image, and video for copyrightauthentication and tampering detection. This thesis describes a new semifragilewatermarking that detects tampering. We also designed an watermarkinghardware architecture for mobile devices. Our watermarking architecture wascombined with the aforementioned wavelet architectures, and its performancewas evaluated. The results show that the throughput and energy consumption of the conventionalwavelet architecture is lower and higher than those of the watermarkingarchitecture, while those of our wavelet architectures are comparable to thoseof the watermarking architecture. Also the size of the internal memory of ourarchitectures is lower than that of the watermarking architecture. These resultsare due to the fact that the 2 -D DWT dataflow is optimized for DRAM accessand that coefficients that should be stored in the internal memory are reduced. These results provide evidence that our wavelet architecture has <b>high</b> throughput,a small <b>memory</b> <b>area,</b> and low energy consumption. The effectiveness of thearchitecture was also demonstrated in our application study. 電気通信大学 200...|$|R
2500|$|Windows 2.1 was {{released}} in two different versions: Windows/286 and Windows/386. Windows/386 uses the virtual 8086 mode of the Intel 80386 to multitask several DOS programs and the paged memory model to emulate expanded memory using available extended memory. Windows/286, {{in spite of its}} name, runs on both Intel 8086 and Intel 80286 processors. It runs in real mode but can make use of the <b>high</b> <b>memory</b> <b>area.</b>|$|E
50|$|The {{second line}} loads the HIMEM.SYS driver that enables DOS {{to use the}} <b>high</b> <b>memory</b> <b>area.</b>|$|E
5000|$|... #Caption: The <b>high</b> <b>memory</b> <b>area</b> is {{available}} in real mode on 80286 processors if the A20 gate is not disabled.|$|E
25|$|The first {{memory segment}} (64 KB) of the {{conventional}} <b>memory</b> <b>area</b> is named lower memory or low <b>memory</b> <b>area.</b>|$|R
50|$|Windows Vista {{binaries}} include intrinsic {{support for}} detection of stack-overflow. When a stack overflow in Windows Vista binaries is detected, {{the process is}} killed so that it cannot be used {{to carry on the}} exploit. Also Windows Vista binaries place buffers <b>higher</b> in <b>memory</b> and non buffers, like pointers and supplied parameters, in lower <b>memory</b> <b>area.</b> So to actually exploit, a buffer underrun is needed to gain access to those locations. However, buffer underruns are much less common than buffer overruns.|$|R
40|$|The present {{invention}} {{relates to}} a digital right management device (20), the device comprising a <b>memory</b> <b>area</b> (22) for storing {{information on a}} rights object that has been transferred from the DRM device (20) to another DRM device, wherein the rights object comprises permissions linked to a digital media object, and a processor (24) for receiving a rights object, wherein the processor is operative to access the <b>memory</b> <b>area</b> (22) to check whether information on the received rights object is stored in the <b>memory</b> <b>area</b> (22) and {{to set up the}} received rights object on the digital right management device (20) in case the information on the received rights object is not stored in the <b>memory</b> <b>area</b> (22) and to reject the received rights object in case the information on the received rights object is stored in the <b>memory</b> <b>area</b> (22) ...|$|R
5000|$|The A20 handler is {{software}} controlling {{access to}} the <b>high</b> <b>memory</b> <b>area.</b> Extended memory managers usually provide this functionality. In DOS, <b>high</b> <b>memory</b> <b>area</b> managers, such as HIMEM.SYS had the extra task of managing A20 and provided an API for opening/closing A20. DOS itself could utilize the area for some of its storage needs, thereby freeing up more conventional memory for programs. This functionality was enabled by the [...] "DOS=HIGH" [...] directive in the CONFIG.SYS configuration file.|$|E
50|$|The {{first line}} causes DOS {{to use the}} <b>high</b> <b>memory</b> <b>area</b> and upper memory when possible, freeing up more {{conventional}} memory for applications to use.|$|E
50|$|In memory management, the <b>high</b> <b>memory</b> <b>area</b> (HMA) is the RAM area {{consisting}} of 65520 bytes beyond the upper memory area of an IBM AT or compatible computer.|$|E
40|$|One of {{the most}} {{powerful}} features of the Real-Time Specification for Java (RTSJ) is the new memory management model based on scoped <b>memory</b> <b>areas.</b> This model allows programmers to ensure timely reclamation of memory and predictable performance, at the cost of an unfamiliar programming model. We report on experience using and implementing scoped <b>memory</b> <b>areas.</b> Our contribution is twofold: (i) wegive an informal introduction to the semantics of the scope management rules of the RTSJ, (ii) wepresent a number of design patterns for effectively using the scoped <b>memory</b> <b>area</b> API. 1...|$|R
50|$|Other {{potential}} {{causes of}} data loss included {{the corruption of}} DoubleSpace's <b>memory</b> <b>areas</b> by other programs, DoubleSpace's <b>memory</b> <b>areas</b> were not protected, because MS-DOS ran in real mode. Microsoft attempted to remedy this in the MS-DOS 6.2 version of DoubleSpace (via a feature called DoubleGuard that would check for such corruption).|$|R
50|$|The <b>memory</b> <b>area</b> from 9800h to 987Fh behaves as RAM {{as long as}} the {{deformation}} register is reset. The <b>memory</b> <b>area</b> from 9880h to 98FFh is write only; if {{you read}} it, it'll always return FFh. Watch out for reading from the deformation register, as this will set bit 6.|$|R
50|$|The <b>high</b> <b>memory</b> <b>area</b> (HMA) is the RAM area {{consisting}} of the first 64 KiB, minus 16 bytes, of the extended memory on an IBM PC/AT or compatible microcomputer.|$|E
50|$|The {{ability of}} DOS {{versions}} 5.0 {{and later to}} move their own system core code into the <b>high</b> <b>memory</b> <b>area</b> (HMA) through the DOS=HIGH command gave another boost to free memory.|$|E
50|$|Using a quirk in the 286 CPU architecture, the <b>high</b> <b>memory</b> <b>area</b> (HMA) was accessible, as {{the first}} 64 kB above the 1 MB limit of 20-bit {{addressing}} in the x86 architecture.|$|E
40|$|The {{invention}} {{relates to}} {{a method for}} handling data (A, B) between two <b>memory</b> <b>areas</b> (W, R 1, R 2) of an electronic component comprising at least one working <b>memory</b> <b>area</b> (W) for carrying out operations on said component bringing into play {{at least one of}} said data. The inventive method is characterized in that it involves the use of the same <b>memory</b> <b>areas</b> for executing an operation whatever the operation to be executed is in such a manner that each operation has a hidden signal trace that is identical in terms of location leakage outside this component...|$|R
5000|$|Data window - a {{hexadecimal}} dump of a user-specified <b>memory</b> <b>area.</b>|$|R
50|$|Zero-filled <b>memory</b> <b>area,</b> {{interpreted}} as a null-terminated string, is an empty string.|$|R
5000|$|DOS (DOS 5.0 and DR DOS 6.0 and higher; OS/2) : Specifies {{whether to}} load DOS into the <b>high</b> <b>memory</b> <b>area</b> and/or use upper memory. (Similar to HIDOS=ON under DR DOS 5.0.) ...|$|E
5000|$|As of MS-DOS 5.0, [...] was {{introduced}} {{and could be}} used to load the DOS kernel code into the <b>High</b> <b>Memory</b> <b>Area</b> (HMA) {{to increase the amount of}} available conventional memory by specifying [...] in [...]|$|E
50|$|The A20 handler is IBM PC memory manager {{software}} that controls {{access to the}} <b>high</b> <b>memory</b> <b>area</b> (HMA). Extended memory managers usually provide this functionality. A20 handlers are named after the 21st address line of the microprocessor, the A20 line.|$|E
50|$|The Global Descriptor Table or GDT is a data {{structure}} used by Intel x86-family processors {{starting with the}} 80286 in order to define {{the characteristics of the}} various <b>memory</b> <b>areas</b> used during program execution, including the base address, the size and access privileges like executability and writability. These <b>memory</b> <b>areas</b> are called segments in Intel terminology.|$|R
50|$|The third line loads the EMM386 memory manager, which emulates {{expanded}} memory. The {{command line}} argument RAM allows {{the use of}} the upper <b>memory</b> <b>area.</b> Another argument that can be given to EMM386.EXE is NOEMS, which allows use of the upper <b>memory</b> <b>area</b> without emulating expanded memory. The NOEMS switch also frees up more upper memory blocks.|$|R
50|$|The fourth line loads the ANSI.SYS {{device driver}} {{into the upper}} <b>memory</b> <b>area.</b>|$|R
50|$|High {{memory is}} the part of {{physical}} memory in a computer which is not directly mapped by the page tables of its operating system kernel. The phrase is also sometimes used as shorthand for the <b>High</b> <b>Memory</b> <b>Area,</b> which is a different concept entirely.|$|E
50|$|The {{next stage}} in the {{evolution}} of DOS was for the operating system to use upper memory blocks (UMBs) and the <b>high</b> <b>memory</b> <b>area</b> (HMA). This occurred with the release of DR DOS 5.0 in 1990. DR DOS' built-in memory manager, EMM386.EXE, could perform most of the basic functionality of QEMM and comparable programs.|$|E
50|$|The {{extended}} memory manager is {{also responsible for}} managing allocations in the <b>high</b> <b>memory</b> <b>area</b> (HMA) and the upper memory area (UMA; {{also referred to as}} upper memory blocks or UMBs). In practice the upper memory area will be provided by the expanded memory manager (EMM), after which DOS will try to allocate them all and manage them itself.|$|E
5000|$|... #Caption: The upper <b>memory</b> <b>area</b> {{is located}} between 640 KB and 1024 KB.|$|R
5000|$|Memory {{protection}} (tasks {{are allowed}} to allocate to protected <b>memory</b> <b>areas</b> if need be) ...|$|R
40|$|The kernel <b>memory</b> <b>area</b> is {{the most}} secure place to save and manage the secret {{information}} in a normal computer system. User programs cannot arbitrarily access and see the kernel <b>memory</b> <b>area.</b> Even the attacker who has already gained root or super user priviledge cannot see {{the contents of the}} kernel <b>memory</b> <b>area</b> arbitrarily. This memory-access protection is the basic requirement that should be satisfied to support the C 2 -level security evaluation criteria, which is supported by most of the current commercial and non-commercial computer operating systems, such as Linux, Solaris, and Windows NT. But, {{there is no way to}} save and retrieve the secret information into and out of the kernel <b>memory</b> <b>area.</b> In this paper, we propose a new kernel memory key management facility, which we call the KEYBOX system. We describe the major user interface of the KEYBOX system, a system call sys_keybox(), semantics and show how the KEYBOX system can be used to manage the secret information that the CGI application requires...|$|R
