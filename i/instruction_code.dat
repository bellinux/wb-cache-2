88|520|Public
5|$|The machine's {{instruction}} set was increased from the 7 of the SSEM to 26 initially, including multiplication done in hardware. This increased to 30instructions in the Final Specification version. Ten bits of each word were allocated {{to hold the}} <b>instruction</b> <b>code.</b> The standard instruction time was 1.8 milliseconds, but multiplication was much slower, {{depending on the size}} of the operand.|$|E
5|$|Of the 20 bits {{allocated}} for each program instruction, 10 {{were used to}} hold the <b>instruction</b> <b>code,</b> which allowed for 1,024 (210) different instructions. The machine had 26 initially, increasing to 30 when the function codes to programmatically control the data transfer between the magnetic drum and the cathode ray tube (CRT) main store were added. On the Intermediary Version programs were input by key switches, and the output was displayed {{as a series of}} dots and dashes on a cathode ray tube known as the output device, just as on the SSEM from which the Mark 1 had been developed. However, the Final Specification machine, completed in October 1949, benefitted from the addition of a teleprinter with a 5-hole paper-tape reader and punch.|$|E
25|$|On June 22, 2016, Necurs {{released}} {{a new version}} of Locky with a new loader component, which includes several detection-avoiding techniques, such as detecting whether it is running within a virtual machine or within a physical machine, and relocation of <b>instruction</b> <b>code.</b>|$|E
50|$|The IBM 653 options could {{implement}} additional <b>instruction</b> <b>codes.</b>|$|R
5000|$|Two more {{instructions}} were not specified but were commonly present in simulators and took <b>instruction</b> <b>codes</b> 000aaaaa and 111aaaaa: ...|$|R
50|$|The VEX {{coding scheme}} uses a code prefix {{consisting}} {{of two or three}} bytes, which is added to existing or new <b>instruction</b> <b>codes.</b>|$|R
25|$|Though the {{predicate}} {{takes up}} {{four of the}} 32bits in an <b>instruction</b> <b>code,</b> and thus cuts down significantly on the encoding bits available for displacements in memory access instructions, it avoids branch instructions when generating code for small if statements. Apart from eliminating the branch instructions themselves, this preserves the fetch/decode/execute pipeline {{at the cost of}} only one cycle per skipped instruction.|$|E
2500|$|Assigning a data type, termed typing, gives {{meaning to}} a {{sequence}} of bits such as a value in memory or some object such as a variable. The hardware of a general purpose computer is unable to discriminate between for example a memory address and an <b>instruction</b> <b>code,</b> or between a character, an integer, or a floating-point number, because it makes no intrinsic distinction between any of the possible values that {{a sequence of}} bits might mean. Associating a sequence of bits with a type conveys that [...] to the programmable hardware to form a symbolic system composed of that hardware and some program.|$|E
2500|$|The EDSAC's {{main memory}} {{consisted}} of 1024 locations, though only 512 locations were initially installed. Each contained 18 bits, but the topmost bit was always unavailable due to timing problems, so only 17 bits were used. An instruction {{consisted of a}} five-bit <b>instruction</b> <b>code,</b> one spare bit, a ten bit operand (usually a memory address), and a length bit to control whether the instruction used a 17-bit or a 35-bit operand (two consecutive words, little-endian). [...] All instruction codes were by design represented by one mnemonic letter, so that the Add instruction, for example, used the EDSAC character code for the letter A.|$|E
5000|$|It allows <b>instruction</b> <b>codes</b> to {{have up to}} five operands, {{where the}} {{original}} scheme allows only two operands (in rare cases three operands).|$|R
5000|$|The VEX {{coding scheme}} allows the {{definition}} of new instructions and the extension or modification of previously existing <b>instruction</b> <b>codes.</b> This serves the following purposes: ...|$|R
50|$|All these {{instructions}} take a constant, representing an offset or an arithmetic constant. If this constant {{was less than}} 16, all these <b>instructions</b> <b>coded</b> to a single byte.|$|R
50|$|Type A {{instructions}} have, in sequence, a 3-bit prefix (<b>instruction</b> <b>code),</b> a 15-bit decrement field, a 3-bit tag field, and a 15-bit address field. They are {{conditional jump}} operations {{based on the}} values in the decrement registers specified in the tag field. Some also subtract the decrement field from {{the contents of the}} index registers. The implementation requires that the second two bits of the <b>instruction</b> <b>code</b> be non-zero, giving a total of six possible type A instructions. One (STR, <b>instruction</b> <b>code</b> binary 101) was not implemented until the IBM 709.|$|E
5000|$|Operation Code Register (5 bit): holds 5-bit <b>instruction</b> <b>code</b> {{during its}} {{execution}} ...|$|E
5000|$|... smaller {{executable}} program size (since implementations have flexibility {{to choose the}} <b>instruction</b> <b>code)</b> ...|$|E
50|$|The {{assembler}} accepts instruction mnemonics, data declarations and directives and constructs {{an object}} file containing information readily understandable by the CPU {{of the target}} processor, in particular <b>code</b> <b>instructions</b> <b>coded</b> in binary.|$|R
50|$|Due to the {{complexities}} {{of what is being}} measured, simulations must be analyzed in unbiased ways; however, with the model running on a pre-made set of <b>instructions</b> <b>coded</b> into it by a modeler, biases exist almost universally.|$|R
3000|$|... (iii)Dynamic re{{configuration}}: by loading new <b>instruction</b> <b>codes</b> {{into the}} configuration memory through the SPI structure, new operations can be executed on the desired PEs without any interruption with others. The number of PEs {{involved in the}} application is also adjustable for different system requirements.|$|R
50|$|The AEA {{instruction}} format consisted of 5-bit <b>instruction</b> <b>code,</b> index bit and a 12-bit address.|$|E
50|$|The {{programmed}} operator facility {{allows the}} <b>instruction</b> <b>code</b> field {{to indicate a}} call to a vector of subroutine addresses. The six bit <b>instruction</b> <b>code</b> allows up to 64 programmed operators (octal 00 through 77). If the P bit is set, an <b>instruction</b> <b>code</b> of xx is treated as a call to location 1xx (octal). The location of the POP instruction is saved in location zero. Bit zero of location zero is set to the current value of the overflow indicator and the indicator is reset. Bit 9 of location zero is set to '1'b to indicate an indirect address, allowing the programmed operator routine to indirectly access the data specified in {{the address of the}} POP instruction.|$|E
5000|$|Beginners All purpose Symbolic <b>Instruction</b> <b>Code</b> (BASIC) it was {{developed}} to enable more people to write programs.|$|E
5000|$|Instruction {{register}} sizes {{tend to be}} small, perhaps four {{or seven}} bits wide. Except for BYPASS and EXTEST, all instruction opcodes are defined by the TAP implementor, as are their associated data registers; undefined <b>instruction</b> <b>codes</b> should not be used. Two key instructions are: ...|$|R
5000|$|Provide graphics, advertising, warnings, <b>instructions,</b> bar <b>codes,</b> etc.|$|R
50|$|This program ({{instruction}} 901 {{to instruction}} 000) is written just using numeric codes. The program takes two numbers as input and outputs the difference. Notice that execution starts at Mailbox 00 and finishes at Mailbox 07. The disadvantages of programming the LMC using numeric <b>instruction</b> <b>codes</b> are discussed below.|$|R
5000|$|Read {{whatever}} data {{the instruction}} requires from cells in memory (or perhaps from an input device). The location of this required data is typically stored within the <b>instruction</b> <b>code.</b>|$|E
5000|$|Many {{acronyms}} {{which are}} the same as words are written with capital letters: basic is similar to fundamental, while BASIC is the Beginner's All-purpose Symbolic <b>Instruction</b> <b>Code,</b> a computer language.|$|E
50|$|On June 22, 2016, Necurs {{released}} {{a new version}} of Locky with a new loader component, which includes several detection-avoiding techniques, such as detecting whether it is running within a virtual machine or within a physical machine, and relocation of <b>instruction</b> <b>code.</b>|$|E
50|$|The NX bit, {{which stands}} for No-eXecute, is a {{technology}} used in CPUs to segregate areas of memory for use by either storage of processor <b>instructions</b> (<b>code)</b> or for storage of data, a feature normally only found in Harvard architecture processors. However, the NX bit is being increasingly used in conventional von Neumann architecture processors, for security reasons.|$|R
50|$|Depending on {{the type}} and success of load operations, the mill also assigns {{metadata}} to each belt item, including status, width, and vectorization count. Operations operate on the item described. Thus, the width and vector count {{are not part of}} the <b>instruction</b> <b>coding.</b> If an operation fails, the failure information is hashed, and placed in the destination, with its metadata, for use in debugging.|$|R
50|$|Instructions {{that need}} more than three operands have an extra suffix byte specifying one or two {{additional}} register operands. <b>Instructions</b> <b>coded</b> with the VEX prefix can have up to five operands. At most one of the operands can be a memory operand; and at most one of the operands can be an immediate constant of 4 or 8 bits. The remaining operands are registers.|$|R
50|$|Type B {{instructions}} have, in sequence, a 12-bit <b>instruction</b> <b>code</b> (with {{the second}} and third bits set to 0 to distinguish them from type A instructions), a 2-bit flag field, four unused bits, a 3-bit tag field, and a 15-bit address field.|$|E
50|$|For address generation, indexing, if specified, is {{performed}} before indirection. The word at the effective indirect address is decoded {{as if it}} were an instruction (except that the <b>instruction</b> <b>code</b> is ignored), allowing an indirect address to also specify indirection or indexing. Multiple levels of indirect addressing are allowed.|$|E
5000|$|Paravirtualization is a {{new term}} for an old idea. IBM's VM {{operating}} system has offered such a facility since 1972 (and earlier as CP-67). In the VM world, this is designated a [...] "DIAGNOSE code", because it uses an <b>instruction</b> <b>code</b> used normally only by hardware maintenance software and thus undefined.|$|E
50|$|Dense <b>instruction</b> <b>coding,</b> and {{extensive}} use of the register sets, meant that relatively few store accesses were needed for common scientific codes, such as scalar product and polynomial inner loops. This did much to offset the relatively slow core cycle time, giving the KDF9 {{about a third of}} the speed of its much more famous, but 8 times more expensive and much less commercially successful contemporary, the Manchester/Ferranti Atlas Computer.|$|R
5000|$|Cortical Cafe CGH Kit is a CGH related {{hobbyist}} {{site with}} <b>instructions,</b> source <b>code,</b> and a web-application for CGH creation.|$|R
5000|$|Some of Control Data Corporation's (CDC) Cyber 70/170 series {{machines}} {{included a}} population count instruction; in COMPASS, this <b>instruction</b> was <b>coded</b> as [...]|$|R
