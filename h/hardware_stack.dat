38|70|Public
5000|$|Stack is in RAM (with W15 as stack pointer); {{there is}} no <b>hardware</b> <b>stack</b> ...|$|E
5000|$|The <b>hardware</b> <b>stack</b> is {{available}} {{in a number of}} different forms. [...] These currently include: ...|$|E
5000|$|The program bank {{register}} ( [...] , the [...] part of {{the address}} bus) is pushed onto the <b>hardware</b> <b>stack</b> (65C816/65C802 only when operating in native mode).|$|E
50|$|This {{simulator}} {{was designed}} and built by a government-industry team at Langley Research Center in Virginia. It was flown to Kennedy Space Center by C-5 transport and was {{the last piece of}} <b>hardware</b> <b>stacked</b> onto the rocket in the Vehicle Assembly Building.|$|R
5000|$|The <b>hardware</b> call <b>stack</b> is not addressable, so {{preemptive}} task switching {{cannot be}} implemented ...|$|R
40|$|The {{majority}} of existing digital preservation solutions {{are focusing on}} the long-term storage of digital content such as documents, images, video, audio files and other domain specific data. Preservation of an Information Technology infrastructure for supporting business processes {{is a much more}} challenging task. It requires the preservation of software and <b>hardware</b> <b>stacks</b> as well as relevant contexts, which together, provide an execution layer for running business processes. The proposed TIMBUS architecture addresses limitations of existing digital preservation solutions and provides a complete framework for preserving business processes implemented upon a service oriented architecture...|$|R
50|$|PICs have a {{hardware}} call stack, {{which is used}} to save return addresses. The <b>hardware</b> <b>stack</b> is not software-accessible on earlier devices, but this changed with the 18 series devices.|$|E
5000|$|Though the PDP-8 did {{not have}} a <b>hardware</b> <b>stack,</b> it could be {{implemented}} in software.Here are example PUSH and POP subroutines, simplified to omit issues such as testing for stack overflow and underflow: ...|$|E
50|$|The IBM System/360 {{is another}} {{architecture}} without a <b>hardware</b> <b>stack.</b> The examples below illustrate the calling convention used by OS/360 and successors {{prior to the}} introduction of 64-bit z/Architecture; other operating systems for System/360 might have different calling conventions.|$|E
40|$|In this paper, {{we define}} a <b>hardware</b> Evaluation <b>Stack</b> for MSIL and we propose a {{conservative}} implementation over the EPIC architecture. This new <b>hardware</b> evaluation <b>stack,</b> named virtual stack, {{is based upon}} the EPIC architecture’s register files. An additional register renaming logic, to offload the run-time type checking performed by the Common Language Runtime is also proposed. Finally, we introduce a mechanism to overcome the sequential nature of the evaluation stack allowing the code generator to better use the parallel instructions execution of instruction bundles. The virtual stack’s final purpose is to simplify the implementation of fast one-pass JIT compiler...|$|R
40|$|Abstract- In many applications, {{especially}} {{signal processing}} and matrix computations, algorithms {{are in a}} highly regular iterative form; access patterns for most variables are highly regular and uniform. Instead of always storing the values of variables back to and retrieving them from memory or register files, {{it will be much}} more efficient and cost effective to let those variables intelligently “stay ” or “flow ” in the data path for future use. In this paper, low cost and simple structured sequencers which are best exemplified by <b>hardware</b> <b>stacks</b> and queues are introduced in the data path for efficiently implementing such a novel concept. Various algorithms are developed to map variables to sequencers and to integrate sequencers into conventional high-level synthesis procedures. Experimental results show very encouraging improvement in the performance of designs as well as significant reduction in hardware cost. I...|$|R
40|$|Abstract—Data {{acquisition}} and transmission {{based on the}} Ethernet is a very popular solution in {{many different kinds of}} monitoring system. This paper introduces a chip W 5100 which is with network interface. The chip integrates TCP/IP <b>hardware</b> protocol <b>stack</b> and supports a variety of network protocols. The internal structure of the W 5100 and its register function are introduced, besides that, the hardware circuit and the program design are given based on the STM 32 processor. Focuses on the MAC address binding and resuming send program in multiple points building energy consumption monitoring system so as to enable quality of data transfer. At present, this data transmission system has been successfully applied in many building energy consumption monitoring projects, and the results show that the system is reliable and stability, and can satisfy the requirement of data transfer. Index Terms—Internet, data transmission, <b>hardware</b> protocol <b>stack,</b> STM 32 I...|$|R
50|$|Early {{languages}} like Fortran did {{not initially}} support recursion because variables were statically allocated, {{as well as}} the location for the return address. Most computers before the late 1960s such as the PDP-8 did not have support for <b>hardware</b> <b>stack</b> registers.|$|E
5000|$|CK-AI - open {{experimental}} framework {{powered by}} Collective Knowledge to enable collaborative co-design and optimization {{of the whole}} software and <b>hardware</b> <b>stack</b> of Deep learning in terms of speed, accuracy, energy, size and cost across diverse models, inputs and devices ...|$|E
5000|$|Enhanced {{mid-range}} core devices {{introduce a}} deeper <b>hardware</b> <b>stack,</b> additional reset methods, 14 additional instructions and ‘C’ programming language optimizations. In particular. {{there are two}} [...] ( [...] and [...] ), and two corresponding [...] register pairs ( [...] and [...] ). Special instructions use [...] registers like address registers, {{with a variety of}} addressing modes.|$|E
30|$|First, {{a failure}} is called “transient” when {{caused by a}} cloud service and was {{encountered}} {{for a short period}} of time. Network glitches, routers unavailability due to a host reboot and network packet loss are typical examples of such failures caused by the cloud platform but, in most cases, they are only observed {{for a short period of}} time (seconds or a few minutes) and when disappeared the infrastructure is completely functional. Various works study those types of failures (e.g., [34]) and attribute them to the complexity of the cloud software and <b>hardware</b> <b>stacks</b> which presents strong correlations between seemingly independent cloud components [35]. Although most cloud providers protect their customers from such failures through their SLAs [36], they openly discuss them and provide instruction for failures caused by sporadic host maintenance tasks [37] and various other reasons [38]. Since the cloud environment is so dynamic and the automation demanded by the cloud orchestration tools requires the coordination of different parties, script re-execution is suggested on the basis that such transient failures will eventually disappear and the script will become effective.|$|R
40|$|The Lilith {{computer}} is particularly suited to execute Modula- 2 programs. The instruction set is chosen {{to reflect the}} needs of the compiler. Compilations, therefore, are easy and produce dense and fast code. There are special purpose high-level instructions as well as quite primitive operations. The Lilith computer uses a stack for the evaluation of expressions. These evaluations are done {{with the use of a}} small <b>hardware</b> expression <b>stack.</b> The <b>hardware</b> expression <b>stack</b> permits arithmetic operations without memory access. It allows to combine the · simplicity of a stack computer with the efficiency of a computer with general registers. The compiler guarantees that the expression stack never overflows. Lilith is also a stack computer in another sense; it allocates data segments of procedures on a stack located in main memory. The memory is subdivided into several areas. Local data, global data, and code are accessed relative to specific registers. These registers are updated on execution of a call or return instruction. Data of external modules are accessed indirectly throug...|$|R
40|$|Many factors {{contribute}} to overall application performance in today’s high-performance cluster computing environments. These factors include the memory sub-system, network <b>hardware</b> and software <b>stack,</b> compilers and libraries, and I/O sub-system. The large variability in hardware and software configurations present i...|$|R
50|$|Not mapped {{into the}} address space is a 12-bit program counter and an {{associated}} <b>hardware</b> <b>stack</b> (four or six levels deep, depending on model). There {{are only two}} status bits (carry and zero), and they are banked based on processor mode, with separate status bits for normal, interrupt and non-maskable interrupt operation.|$|E
5000|$|The ST6 is a Harvard {{architecture}} with an 8-bit (256 byte) {{data address}} {{space and a}} separate 12-bit (4096 byte) program space. Operands are always 1 byte long, and some instructions support two operands, such as [...] "move 8-bit immediate to 8-bit memory address". Subroutine calls are done using a separate <b>hardware</b> <b>stack.</b> Data registers (but not the program counter or flags) are memory-mapped.|$|E
5000|$|R6, {{also written}} SP, {{is used as}} a <b>hardware</b> <b>stack</b> for traps and interrupts. A {{convention}} enforced by the set of modes the PDP-11 provides is that a stack grows downward—toward lower addresses—as items are pushed onto it. When a mode is applied to SP, or to any register the programmer elects to use as a software stack, the addressing modes have the following effects: ...|$|E
30|$|Control-flow {{integrity}} defense: Control-flow integrity (CFI) (Abadi et al. 2005; Davi 2015; Burow et al. 2017) {{is considered}} as one general and promising defense against code-reuse attacks (Shacham 2007; Bletsch et al. 2011; Carlini and Wagner 2014; Schuster et al. 2015). CFI restricts the control-flow of an application program to valid execution traces; and the program’s predefined Control-Flow Graph (CFG) tells what is valid. Forward-edge control-flow represents transfers caused by indirect jumps and function calls. Backward-edge control-flow represents transfers caused by function return instructions. Intel has an ISA-level CFI extension, named as Control-flow Enforcement Technology (CET) (Intel Corporation 2016), which protects forward-edge CFI by indirect branch tracking and ensures backward-edge CFI by <b>hardware</b> shadow <b>stacks.</b> However, CET suffers from two problems. One is the difficulty in defining a complete and precise legal CFG (Evans et al. 2015), because some informaion is only available at runtime, such as the target of an indirect jump. The other is the limited size of the <b>hardware</b> shadow <b>stack.</b> The stack has {{to rely on the}} operating system (OS) for handling context switches and deeply nested function calls (Frantzen and Shuey 2001).|$|R
50|$|WHEA allows {{third-party}} software {{to interact with}} the operating system and react to certain hardware events. For example, when a new CPU is added to a running system—a Windows Server feature known as Dynamic Hardware Partitioning—the <b>hardware</b> error component <b>stack</b> is notified when a new processor is installed.|$|R
40|$|Despite {{computation}} {{becomes much}} complex on data with an unprecedented scale, we argue computers or smart devices should and will consistently provide information and knowledge to {{human being in}} the order of a few tens milliseconds. We coin a new term 10 -millisecond computing to call attention to this class of workloads. 10 -millisecond computing raises many challenges for both software and <b>hardware</b> <b>stacks.</b> In this paper, using a typical workload-memcached on a 40 -core server (a main-stream server in near future), we quantitatively measure 10 -ms computing's challenges to conventional operating systems. For better communication, we propose a simple metric-outlier proportion to measure quality of service: for N completed requests or jobs, if M jobs or requests' latencies exceed the outlier threshold t, the outlier proportion is M/N. For a 1 K-scale system running Linux (version 2. 6. 32), LXC (version 0. 7. 5) or XEN (version 4. 0. 0), respectively, we surprisingly find that so as to reduce the service outlier proportion to 10 % (10 % users will feel QoS degradation), the outlier proportion of a single server has to be reduced by 871 X, 2372 X, 2372 X accordingly. Also, we discuss the possible design spaces of 10 -ms computing systems from perspectives of datacenter architectures, networking, OS and scheduling, and benchmarking...|$|R
5000|$|Parameters {{are pushed}} onto the <b>hardware</b> <b>stack</b> as 16-bit {{integers}} {{in the order}} specified in the [...] function in low byte, high byte order. The last value pushed to the stack is a byte indicating the number of arguments. The machine language code must remove all of these vaues before returning via the [...] instruction. A value can {{be returned to the}} BASIC program by placing it in addresses 21210 and 21310 (D416 and D516) as a 16-bit integer.|$|E
50|$|PIC10F32x devices {{feature a}} {{mid-range}} 14-bit wide code memory of 256 or 512 words, a 64-byte SRAM register file, and an 8-level deep <b>hardware</b> <b>stack.</b> These devices {{are available in}} 6-pin SMD and 8-pin DIP packages (with two pins unused). One input only and three I/O pins are available. A complex set of interrupts are available. Clocks are an internal calibrated high-frequency oscillator of 16 MHz {{with a choice of}} selectable speeds via software and a 31 kHz low-power source.|$|E
50|$|The Eagle Project was {{the subject}} of Tracy Kidder's Pulitzer prize-winning book, The Soul of a New Machine, making the MV line the best-documented {{computer}} project in recent history. The MV/8000 was a straightforward, 32-bit extension of the Nova-based Eclipse, yet still lacking a <b>hardware</b> <b>stack</b> pointer adopted by most new computers since the late 1960s. It was backwards-compatible with 16-bit Eclipse applications, used the same command-line interpreter as the 16-bit Eclipse, and achieved improved 32-bit performance over the VAX 11/780 while using fewer components.|$|E
40|$|This paper {{describes}} the design goals, micro-architecture, {{and implementation of}} the microprogrammed processor for a compact high performance personal com-puter. This computer supports a range of high level lang-uage environments and high bandwidth I/O devices. Besides the processor, it has a cache, a memory map, main storage, and an instruction fetch unit; these are described in other papers. The processor can be shared among 16 microcoded tasks, performing microcode context switches on demand with essentially no overhead. Conditional branches are done without any Iookahead or delay. Micro-instructions are fairly tightly encoded, and use an interes-ting variant on control field sharing. The processor imple-ments a large number of internal registers, <b>hardware</b> <b>stacks,</b> a cyclic shifter/masker, and an arithmetic/logic unit, together with external data paths for instruction fetching, memory interface, and t/O, in a compact, pipe-lined organization. The machine has a 50 ns microcycle, and can execute a simple macroinstruction in one cycle; the available 1 /O bandwidth is 640 Mhits/sec. The entire machine, including disk, display and network interfaces, is implemented with approximately 3000 MSI components, mostly ECL 10 K; the processor is about 35 % of this. In addition there are up to 4 storage modules, each with about 300 16 K or 64 K RAMS and 200 MS! components, for a total of 8 Mbytes. Several prototypes are currently running. 1...|$|R
5000|$|Since {{bytecode}} {{instructions are}} processed by software, {{they may be}} arbitrarily complex, but are nonetheless often akin to traditional <b>hardware</b> instructions: virtual <b>stack</b> machines are the most common, but virtual register machines have been built also. [...] Different parts may often be stored in separate files, similar to object modules, but dynamically loaded during execution.|$|R
5000|$|A <b>stack</b> <b>hardware</b> {{optimization}} is {{the provision}} of D (or [...] "display") registers. These are registers that point {{to the start of}} each called stack frame. These registers are updated automatically as procedures are entered and exited and are not accessible by any software. There are 32 D registers, which is what limits to 32 levels of lexical nesting.|$|R
5000|$|A well-designed and succinct {{interrupt}} handler or interrupt service routine (ISR) {{will not only}} expeditiously service any event that causes an interrupt, it will do so without interfering in any way with the interrupted foreground task - the ISR must be [...] "transparent" [...] to the interrupted task (although exceptions may apply in specialized cases). This means that the ISR must preserve the microprocessor (MPU) state and not disturb anything in memory {{that it is not}} supposed to disturb. Additionally, the ISR should be fully reentrant, meaning that if two interrupts arrive in close succession, the ISR will be able to resume processing the first interrupt after the second one has been serviced. Reentrancy is achieved by using only the MPU <b>hardware</b> <b>stack</b> for storage.|$|E
50|$|The {{idea of a}} {{subroutine}} was {{worked out}} after computing machines had already existed for some time.The arithmetic and conditional jump instructions were planned {{ahead of time and}} have changed relatively little; but the special instructions used for procedure calls have changed greatly over the years.The earliest computers and microprocessors, such as the Small-Scale Experimental Machine and the RCA 1802, did not have a single subroutine call instruction.Subroutines could be implemented, but they required programmers to use the call sequence—a series of instructions—at each call site.Some very early computers and microprocessors, such as the IBM 1620, the Intel 8008, and the PIC microcontrollers, have a single-instruction subroutine call that uses dedicated <b>hardware</b> <b>stack</b> to store return addresses—such hardware supports only a few levels of subroutine nesting, but can support recursive subroutines.Machines before the mid 1960s—such as the UNIVAC I, the PDP-1, and the IBM 1130—typically use a calling convention which saved the instruction counter in the first memory location of the called subroutine. This allows arbitrarily deep levels of subroutine nesting, but does not support recursive subroutines.The PDP-11 (1970) {{is one of the first}} computers with a stack-pushing subroutine call instruction; this feature supports both arbitrarily deep subroutine nesting and also supports recursive subroutines.|$|E
40|$|We {{propose a}} VLIW <b>hardware</b> <b>stack</b> {{processor}} (in short, VLIW-HSP) for real-time signal processing. We {{suppose that the}} signals are the multimedia data from high-speed networks or storage devices. The VLIW-HSP consist of four <b>hardware</b> <b>stack</b> units (HSUs) and one control unit (CU). Each HSU has a data stack, a local register and a multiport register, and can execute the same operation set for macro level parallelism. First we discuss the usefulness of VLIW and <b>hardware</b> <b>Stack.</b> Next we show the design of VLIW-HSP and its evaluation...|$|E
40|$|Abstract. Post-link {{and dynamic}} {{optimizations}} have become important to achieve program performance. A major challenge in post-link and dynamic optimizations is {{the acquisition of}} registers for inserting optimization code in the main program. It is difficult to achieve both correctness and transparency when software-only schemes for acquiring registers are used, as described in [1]. We propose an architecture feature that builds upon existing <b>hardware</b> for <b>stacked</b> register allocation on the Itanium processor. The hardware impact of this feature is minimal, while simultaneously allowing post-link and dynamic optimization systems to obtain registers for optimization in a “safe ” manner, thus preserving the transparency and improving the performance of these systems. ...|$|R
30|$|However, picoJava {{implements}} a 64 -word stack buffer as discrete registers. Spill {{and fill}} of that stack buffer is performed in background by the <b>hardware.</b> Therefore, the <b>stack</b> buffer closely {{interacts with the}} data cache. The interference between the folding unit, the instruction buffer, the instruction cache, the stack buffer, the data cache, and the memory interface causes complications in modeling picoJava for WCET analysis.|$|R
50|$|This {{notation}} is {{the root}} of the idea of the recursive stack, a last-in, first-out computer memory store proposed by several researchers including Turing, Bauer and Hamblin, and first implemented in 1957. In 1960, Łukasiewicz notation concepts and stacks were used as the basis of the Burroughs B5000 computer designed by Robert S. Barton and his team at Burroughs Corporation in Pasadena, California. The concepts also led to the design of the English Electric multi-programmed KDF9 computer system of 1963, which had two such <b>hardware</b> register <b>stacks.</b> A similar concept underlies the reverse Polish notation (RPN, a postfix notation) of the Friden EC-130 calculator and its successors, many Hewlett Packard calculators, the Forth programming language, or the PostScript page description language.|$|R
