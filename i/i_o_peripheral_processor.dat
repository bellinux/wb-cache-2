0|8477|Public
50|$|Each <b>peripheral</b> <b>processor</b> can {{communicate}} with any peripheral device if another <b>peripheral</b> <b>processor</b> is not using the data channel connected to that device. In other words, only one <b>peripheral</b> <b>processor</b> at a time can use a particular data channel.|$|R
50|$|The TPC was {{responsible}} for call sequence and state control. It received signalling inputs collected from <b>peripheral</b> <b>processors</b> (see MXU, RLU, RSU, and TCU below) and sent control information back to the <b>peripheral</b> <b>processors.</b>|$|R
50|$|The central {{processor}} shares access to central memory with ten <b>peripheral</b> <b>processors.</b> Each <b>peripheral</b> <b>processor</b> {{is an individual}} computer with its own 1 μs memory of 4K words, each with 12 bits. (They were somewhat similar to CDC 160A minicomputers, sharing the 12-bit word length and portions of the instruction set.) <b>Peripheral</b> <b>processors</b> are used primarily for input/output: the transfer of information between central memory and peripheral devices such as disks and magnetic tape units. They relieve the {{central processor}} of all input/output tasks, {{so that it can}} perform calculations while the <b>peripheral</b> <b>processors</b> are engaged in input/output functions. This feature promotes rapid overall processing of user programs. Each <b>peripheral</b> <b>processor</b> can add, subtract, and perform logical operations. Special instructions performed data transfer between <b>processor</b> memory and <b>peripheral</b> devices at up to 1 μs per word. The <b>peripheral</b> <b>processors</b> were collectively implemented as a barrel processor. Each executes routines independently of the others. (For comparison, on the IBM 360 series of machines, these processors were called channels.) They are a loose predecessor of bus mastering or Direct memory access.|$|R
50|$|<b>Peripheral</b> <b>processor</b> (PP or PPU) {{instructions}} are {{completely different from}} CPU instructions. <b>Peripheral</b> <b>processor</b> hardware is simpler; it has an 18-bit A (accumulator register, a 12-bit Program Address register, a 12-bit Q register (not programmer-visible), and a 22-bit R register (used to accomplish address relocation during central memory read and write instructions on Cyber 180 systems). No special job validation was required to assemble <b>peripheral</b> <b>processor</b> programs, but to be executed, such programs were required to installed into the operating system via special system editing commands.|$|R
50|$|KMC11 - <b>Peripheral</b> <b>processor</b> for Digital Equipment Corporation PDP-11.|$|R
50|$|Subsequent {{modifications}} to the series in 1969 included the extension to 20 <b>peripheral</b> and control <b>processors</b> with 24 channels. (A 30-PPU 6600 machine was operated by Control Data's Software Research Lab during 1971-1973, but this version was never sold commercially.) Control Data also marketed a CDC 6400 with {{a smaller number of}} <b>peripheral</b> <b>processors,</b> the CDC 6415-7 with seven <b>peripheral</b> <b>processors</b> to reduce cost.|$|R
40|$|This paper {{gives some}} results from {{monitoring}} <b>peripheral</b> <b>processor</b> activity on CDC 6000 series machines at the European Nuclear Research Centre (CERN). It relates <b>peripheral</b> <b>processor</b> activity to a (single) central processor {{and argues that}} such an architecture {{is more likely to}} meet future user demands for higher levels of multiprogramming data security and error recovery. (12 refs) ...|$|R
50|$|HCS12 {{products}} {{contain a}} single processor, the HCS12X feature the additional XGATE <b>peripheral</b> <b>processor.</b>|$|R
40|$|This {{thesis is}} a {{continuation}} of work done in a specialization project. The result from the preliminary work have been used to implement a programmable <b>peripheral</b> <b>processor</b> in HDL that can replace non-programmable hardware modules. The implemented solution have then been tested to find out if it is capable of doing the most basic operations that a UART protocol require to do parallel-to-serial and serial-to-parallel conversions. The results of the implementation and testing have been analysed and the performance, area and power consumption have been presented. The resulting performance and area have also been compared to traditional hardware solutions. The results from the tests demonstrates that the presented <b>peripheral</b> <b>processor</b> is capable of doing the basic operations that is required to do parallel-to-serial and serial-to-parallel conversions. However, the area of the <b>peripheral</b> <b>processor</b> is significantly larger than the total area of multiple non-programmable hardware modules. The result of this is that the cost of utilizing a <b>peripheral</b> <b>processor</b> will be greater than with existing solutions...|$|R
50|$|The <b>peripheral</b> <b>processor</b> {{subsystem}} used {{a technique}} known as barrel and slot {{to share the}} execution unit; each PP had its own memory and registers, but the processor (the slot) itself executed one instruction from each PP in turn (the barrel). This is a crude form of hardware multiprogramming. The <b>peripheral</b> <b>processors</b> had 4096 bytes of 12-bit memory words and an 18-bit accumulator register. Each PP had access to all I/O channels {{and all of the}} system's central memory (CM) in addition to the PP's own memory. The PP instruction set lacked, for example, extensive arithmetic capabilities and did not run user code; the <b>peripheral</b> <b>processor</b> subsystem's purpose was to process I/O and thereby free the more powerful central processor unit(s) to running user computations.|$|R
50|$|However, {{since the}} Cray {{machines}} {{did not have}} <b>peripheral</b> <b>processors,</b> the main central processor executed the operating system code.|$|R
5000|$|COMPASS PP is the {{assembly}} language for the PP (<b>Peripheral</b> <b>Processor),</b> only running operating system code. See CDC 6600 PP architecture.|$|R
50|$|The 160 {{architecture}} {{was modified}} {{to become the}} basis of the <b>peripheral</b> <b>processors</b> (PPs) in the CDC 6000 series mainframe computers and its successors. Large parts of the 160 instruction set were unchanged in the <b>peripheral</b> <b>processors.</b> However there were changes to incorporate the 6000 data channel programming, and control of the central processor. In {{the early days of the}} 6000s, almost the entire operating system ran in the PPs. This left the central processor unencumbered by operating system demands and available for user programs.|$|R
25|$|In computing, channel I/O is a {{high-performance}} input/output (I/O) architecture that is implemented {{in various forms}} {{on a number of}} computer architectures, especially on mainframe computers. In the past, channels were generally implemented with custom processors, variously named channel, <b>peripheral</b> <b>processor,</b> I/O processor, I/O controller, or DMA controller.|$|R
40|$|This paper {{describes}} some of {{the results}} of a study directed to the specification and procurement of a new cockpit simulator for an advanced class of helicopters. A part of the study was the definition of a challenging benchmark problem, and detailed analyses of it were made to assess the suitability of a variety of simulation techniques. The analyses showed that a particularly cost-effective approach to the attainment of adequate speed for this extremely demanding application is to employ a large minicomputer acting as host and controller for a special-purpose digital <b>peripheral</b> <b>processor.</b> Various realizations of such <b>peripheral</b> <b>processors,</b> all employing state-of-the-art electronic circuitry and a high degree of parallelism and pipelining, are available or under development. The types of <b>peripheral</b> <b>processors</b> array processors, simulation-oriented processors, and arrays of processing elements - are analyzed and compared. They are particularly promising approaches which should be suitable for high-speed simulations of all kinds, the cockpit simulator being a case in point...|$|R
5000|$|KXJ11 - QBUS card (M7616) with PDP-11 based <b>peripheral</b> <b>processor</b> and DMA controller. Based on a J11 CPU {{equipped}} with 512 kB RAM, 64 kB ROM and parallel and serial interfaces.|$|R
50|$|ASP {{evolved from}} {{the design of the}} 7094/7044 Direct Coupled System, using data channel to data channel communication. By {{attaching}} an IBM 7044 as a <b>peripheral</b> <b>processor</b> throughput was more than doubled.|$|R
5000|$|KXJ11 - QBUS card (M7616) with PDP-11 based <b>peripheral</b> <b>processor</b> and DMA controller. Based on a J11 CPU {{equipped}} with 512 kB of RAM, 64 kB of ROM, and parallel and serial interfaces.|$|R
50|$|In {{addition}} to communication between peripheral devices and <b>peripheral</b> <b>processors,</b> communication takes {{place between the}} computer operator and the operating system. This {{was made possible by}} the computer console, which had two CRT screens.|$|R
50|$|ASP {{evolved from}} {{the design of the}} 7094/7044 direct coupled system, using data channel to data channel communication. By {{attaching}} an IBM 7044 as a <b>peripheral</b> <b>processor</b> throughput of the 7094 was more than doubled.|$|R
50|$|In general organization, the STAR {{was similar}} to CDC's earlier supercomputers, where a simple CPU was {{supported}} by a number of <b>peripheral</b> <b>processors</b> that offloaded housekeeping tasks and allowed the CPU to crunch numbers as quickly as possible. In the STAR, both the CPU and <b>peripheral</b> <b>processors</b> were deliberately further simplified, to lower the cost and complexity of implementation. The STAR also differed from the earlier designs by being based on a 64-bit architecture instead of 60-bit, a side effect of the increasing use of 8-bit ASCII processing. Also unlike previous machines, the STAR made heavy use of microcode and also supported a virtual memory capability.|$|R
5000|$|The central {{processor}} (CPU) and central memory (CM) operated in units of 60-bit words. In CDC lingo, the term [...] "byte" [...] referred to 12-bit entities (which {{coincided with the}} word size used by the <b>peripheral</b> <b>processors).</b> Characters were six bits, operation codes were six bits, and central memory addresses were 18 bits. Central processor instructions were either 15 bits or 30 bits.The 18-bit addressing inherent to the Cyber 170 series imposed a limit of 262,144 (256K) words of main memory, which was semiconductor memory in this series. The {{central processor}} had no I/O instructions, relying upon the <b>peripheral</b> <b>processor</b> (PP) units to do I/O.|$|R
50|$|Internally, COS {{was divided}} into a very small message-passing EXEC, {{and a number of}} System Task Processors (STP tasks). Each STP task was similar in nature to the <b>peripheral</b> <b>processor</b> {{programs}} in earlier Control Data operating systems.|$|R
50|$|For input or output, each <b>peripheral</b> <b>processor</b> accesses a <b>peripheral</b> device over a {{communication}} link called a data channel. One peripheral device can {{be connected to}} each data channel; however, a channel can be modified with hardware to service more than one device.|$|R
50|$|These {{systems were}} {{organized}} quite {{differently from the}} other multiprocessors in this article. The operating system ran on the <b>peripheral</b> <b>processors,</b> while the user's application ran on the CPUs. Thus, the terms ASMP and SMP do not properly apply to these multiprocessors.|$|R
5000|$|The MDS 2400 {{was a small}} {{floor-standing}} computer {{manufactured by}} Mohawk Data Sciences Corporation. The machine was originally developed by Atron Corporation as the Atron 501, introduced in 1969. [...] It was marketed primarily for remote job entry applications and promoted as The <b>Peripheral</b> <b>Processor.</b>|$|R
50|$|One of the {{earliest}} examples of a barrel processor was the I/O processing system in the CDC 6000 series supercomputers. These executed one instruction (or a portion of an instruction) from each of 10 different virtual <b>processors</b> (called <b>peripheral</b> <b>processors)</b> {{before returning to the}} first processor.|$|R
5000|$|The CDC 6600 (c. 1964) had a dead start {{panel with}} 144 toggle {{switches}}; the dead start switch entered 12 {{words from the}} toggle switches {{to the memory of}} <b>peripheral</b> <b>processor</b> (PP) 0 and initiated the load sequence. PP 0 loaded the necessary code into its own memory and then initialized the other PPs.|$|R
5000|$|In computing, bus {{mastering}} is {{a feature}} supported by many bus architectures that enables a device {{connected to the}} bus to initiate transactions. It is {{also referred to as}} first-party DMA, in contrast with [...] "third-party DMA" [...] where a system DMA controller (also known as <b>peripheral</b> <b>processor,</b> I/O processor, or channel) actually does the transfer.|$|R
50|$|Other systems {{allowed the}} {{operating}} system to run on all processors, but either attached all the <b>peripherals</b> to one <b>processor</b> or attached particular <b>peripherals</b> to particular <b>processors.</b>|$|R
50|$|The central {{processor}} was the high-speed arithmetic unit that functioned as the workhorse of the computer. It performed the addition, subtraction, and logical operations {{and all of}} the multiplication, division, incrementing, indexing, and branching instructions for user programs. Note that in the CDC 6000 architecture, the central processing unit performed no input/output (I/O) operations. Input/Output was totally asynchronous, and performed by <b>peripheral</b> <b>processors.</b>|$|R
5000|$|While some {{authorities}} list {{as many as}} five subspecies (<b>I.</b> <b>o.</b> fusciventer, <b>I.</b> <b>o.</b> obesulus, <b>I.</b> <b>o.</b> peninsulae, <b>I.</b> <b>o.</b> affinus, <b>I.</b> <b>o.</b> nauticus), {{the most}} recent edition of [...] "Mammal Species of the World" [...] only lists <b>I.</b> <b>o.</b> nauticus as a valid subspecies, aside from the nominate; the others are given synonym status.|$|R
5000|$|The console screens were calligraphic, not raster based. Analog {{circuitry}} actually {{steered the}} electron beams {{to draw the}} individual characters on the screen. One of the <b>peripheral</b> <b>processors</b> ran a dedicated program called [...] "DSD" [...] (Dynamic System Display), which drove the console. Coding in DSD needed to be fast as it needed to continually redraw the screen quickly enough to avoid visible flicker.|$|R
2500|$|Welsh {{uses the}} circumflex, diaeresis, acute, and grave on its seven vowels a, e, <b>i,</b> <b>o,</b> u, w, y (â, ê, <b>î,</b> <b>ô,</b> û, ŵ, ŷ, ä, ë, <b>ï,</b> <b>ö,</b> ü, ẅ, ÿ, à, è, <b>ì,</b> <b>ò,</b> ù, ẁ, ỳ, á, é, <b>í,</b> <b>ó,</b> ú, ẃ, ý) ...|$|R
40|$|Abstract – This paper {{deals with}} {{reconfigurable}} hardware platform for different purposes real-time speech and audio signal processing. A design conception and turnkey solution are described. Much {{attention is paid}} to reconfigurable <b>peripheral</b> <b>processor</b> meant for external interface realization, pre- and post- data processing as well as digital signal processing algorithms implementation with the object of the DSP unloads. Moreover, three applications implemented on the considered platform are demonstrated...|$|R
50|$|The CDC 6000 series {{computer}} {{is composed of}} four main functional devices: the central memory, one or two high-speed central processors, seven to ten <b>peripheral</b> <b>processors</b> (<b>Peripheral</b> Processing Unit, or PPU), and a display console. The four computer types differ primarily {{in the number of}} and kind of central processor. It had a distributed architecture and was a reduced instruction set (RISC) machine many years before such a term was invented.|$|R
