74|438|Public
25|$|The 2.4 branch also {{includes}} performance improvements to hash table, Array#max, Array#min, and <b>instance</b> <b>variable</b> access.|$|E
25|$|Python's {{property}} descriptors are similar, {{but come}} with a tradeoff in the development process. If one begins in Python by using a publicly exposed <b>instance</b> <b>variable,</b> and later changes the implementation to use a private <b>instance</b> <b>variable</b> exposed through a property descriptor, code internal to the class {{may need to be}} adjusted to use the private variable rather than the public property. Ruby’s design forces all instance variables to be private, but also provides a simple way to declare set and get methods. This is in keeping with the idea that in Ruby, one never directly accesses the internal members of a class from outside the class; rather, one passes a message to the class and receives a response.|$|E
2500|$|One of the {{differences}} of Ruby compared to Python and Perl is that Ruby keeps all of its instance variables completely private to the class and only exposes them through accessor methods (attr_writer, attr_reader, etc.). Unlike the [...] "getter" [...] and [...] "setter" [...] methods of other languages like C++ or Java, accessor methods in Ruby can be created with a single line of code via metaprogramming; however, accessor methods can also be created in the traditional fashion of C++ and Java. As invocation of these methods {{does not require the}} use of parentheses, it is trivial to change an <b>instance</b> <b>variable</b> into a full function, without modifying a single line of calling code or having to do any refactoring achieving similar functionality to C# and VB.NET property members.|$|E
50|$|The <b>Instance</b> <b>Variables</b> are {{the only}} {{components}} of the kernel which are fully encapsulated. It {{is not possible to}} access these variables from outside the boundary. In this model, the <b>Instance</b> <b>Variables</b> can be of any type. Primitive data types such as integers, characters and user-defined data types such as classes and enumerations are all considered to be <b>Instance</b> <b>Variables.</b>|$|R
50|$|Variables are {{properties}} {{an object}} knows about itself. All instances {{of an object}} have their own copies of <b>instance</b> <b>variables,</b> even if the value is the same from one object to another. One object instance can change values of its <b>instance</b> <b>variables</b> without affecting all other <b>instances.</b> <b>Instance</b> <b>variables</b> {{can be used by}} all methods of a class unless the method is declared as static.|$|R
5000|$|Objective-C classes cannot have <b>instance</b> <b>variables</b> of C++ {{classes that}} lack a default {{constructor}} or that {{have one or}} more virtual methods, but pointers to C++ objects {{can be used as}} <b>instance</b> <b>variables</b> without restriction (allocate them with new in the -init method).|$|R
5000|$|In {{object-oriented}} programming with classes, an <b>instance</b> <b>variable</b> is a variable defined {{in a class}} (i.e. a member variable [...] ), for which each instantiated object of the class has a separate copy, or instance. An <b>instance</b> <b>variable</b> {{is similar to a}} class variable.|$|E
5000|$|... @interface ExampleClass : NSObject { // <b>instance</b> <b>variable</b> {{declarations}} go here}- (NSString*) name;@end ...|$|E
5000|$|In this C++ example, the <b>instance</b> <b>{{variable}}</b> [...] is {{a copy of}} {{the class}} variable [...] where each instance constructed is assigned a sequential value of [...] before it is incremented. Since [...] is an <b>instance</b> <b>variable,</b> each [...] object contains its own distinct value; in contrast, there is only one object [...] available to all instances with the same value.|$|E
50|$|The alloc message allocates enough {{memory to}} hold all the <b>{{instance}}</b> <b>variables</b> for an object, sets all the <b>instance</b> <b>variables</b> to zero values, {{and turns the}} memory into an instance of the class; at no point during the initialization is the memory an instance of the superclass.|$|R
5000|$|Refactoring: local to <b>instance</b> <b>variables,</b> extract methods, inlining, renaming… ...|$|R
5000|$|Objective-C has {{categories}} {{as well as}} non-fragile <b>instance</b> <b>variables.</b>|$|R
5000|$|<b>Instance</b> <b>variable</b> initializers and {{instance}} initializers (in {{the order}} {{they appear in}} the source code) ...|$|E
50|$|Each <b>instance</b> <b>variable</b> {{lives in}} memory {{for the life}} of the object it is owned by.|$|E
50|$|The 2.4 branch also {{includes}} performance improvements to hash table, Array#max, Array#min, and <b>instance</b> <b>variable</b> access.|$|E
5000|$|... direct {{assignment}} to the <b>instance</b> <b>variables</b> {{of an object}} in Java and C# ...|$|R
40|$|Abstract—The {{existing}} cohesion metrics {{for classes}} {{do not consider}} the characteristics of dependent <b>instance</b> <b>variables</b> that are commonly used in a class and, thus, do not properly reflect the cohesiveness of the class. This paper presents an approach for improving the cohesion metrics by considering {{the characteristics of the}} dependent <b>instance</b> <b>variables</b> in an object-oriented program. Index Terms—Cohesion, object-oriented design, metrics/measurement. ...|$|R
40|$|The {{decoupling}} {{of clients}} of abstractions from the implementations of those abstractions {{is a key}} benefit of objectoriented programming. However, many object-oriented languages provide <b>instance</b> <b>variables</b> {{in such a way}} that implementation-level representation decisions seep through interfaces, introducing coupling between clients and abstractions. As part of the Cecil language, we have developed a semantics for flexible <b>instance</b> <b>variables</b> based on the principle that a class should be decoupled from its clients, its subclasses, and its role extensions. We describe our design of <b>instance</b> <b>variables</b> and provide examples where their additional flexibility has been useful. However, implementing our semantics naively can impose significant performance penalties. To achieve reasonable performance, we have developed a number of optimizations that are effective at eliminating many of the costs of our flexible model. We discuss these optimizations and report on the results of experiments to assess the costs of our design under different optimization scenarios. Keywords: Object-oriented programming, <b>instance</b> <b>variables,</b> language design, compiler optimization, Cecil, subject-oriented programming, role...|$|R
50|$|Objective-C 2.0 {{provides}} non-fragile instance variables {{by having}} an extra level of indirection for <b>instance</b> <b>variable</b> access.|$|E
5000|$|The {{compiler}} {{generates a}} private <b>instance</b> <b>variable</b> {{and the appropriate}} accessor and mutator given code such as: public string Name { get; private set; } ...|$|E
5000|$|... struct Request { static int count; int number; Request (...) { number = count; // modifies the <b>instance</b> <b>{{variable}}</b> [...] "this->number" [...] ++count; // modifies {{the class}} variable [...] "Request::count" [...] }};int Request::count = 0; ...|$|E
50|$|<b>Instance</b> <b>variables</b> of {{an object}} use lowerCamelCase prefixed with an underscore, like _delegate and _tableView.|$|R
5000|$|... {{assuming}} , , [...] and [...] {{were not}} <b>instance</b> <b>variables</b> of [...] but were, in fact, methods.|$|R
5000|$|Member {{variables}} - {{refers to}} both the class and <b>instance</b> <b>variables</b> that are defined by a particular class ...|$|R
5000|$|... struct Request { static int count1; // {{variable}} {{name is not}} of importance int number; Request (...) { number = count1; // modifies the <b>instance</b> <b>variable</b> [...] "this->number" [...] ++count1; // modifies the class variable [...] "Request::count1" [...] }};int Request::count1 = 0; ...|$|E
5000|$|Python's {{property}} descriptors are similar, {{but come}} with a tradeoff in the development process. If one begins in Python by using a publicly exposed <b>instance</b> <b>variable,</b> and later changes the implementation to use a private <b>instance</b> <b>variable</b> exposed through a property descriptor, code internal to the class {{may need to be}} adjusted to use the private variable rather than the public property. Ruby’s design forces all instance variables to be private, but also provides a simple way to declare [...] and [...] methods. This is in keeping with the idea that in Ruby, one never directly accesses the internal members of a class from outside the class; rather, one passes a message to the class and receives a response.|$|E
50|$|A class {{variable}} {{is not an}} <b>instance</b> <b>variable.</b> It is a special type of class attribute (or class property, field, or data member). The same dichotomy between instance and class members applies to methods ("member functions") as well; a class may have both instance methods and class methods.|$|E
5000|$|<b>Instance</b> <b>variables</b> or {{attributes}} - {{data that}} belongs to individual objects; every object has its own copy of each one ...|$|R
5000|$|In early Smalltalks, {{there was}} only one {{metaclass}} called [...] This implied that the methods all classes have were the same, in particular the method to create new objects, i.e., [...] To allow classes to have their own methods and their own <b>instance</b> <b>variables</b> (called class <b>instance</b> <b>variables</b> and {{should not be confused with}} class variables), Smalltalk-80 introduced for each class [...] their own metaclass [...] This means that each metaclass is effectively a singleton class.|$|R
5000|$|It allows <b>instance</b> <b>variables</b> {{that provide}} the backing for {{properties}} to be synthesized at runtime without them being declared in the class's interface.|$|R
50|$|Objects are {{accessed}} {{somewhat like}} variables with complex internal structure, {{and in many}} languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. They provide a layer of abstraction {{which can be used}} to separate internal from external code. External code can use an object by calling a specific instance method with a certain set of input parameters, read an <b>instance</b> <b>variable,</b> or write to an <b>instance</b> <b>variable.</b> Objects are created by calling a special type of method in the class known as a constructor. A program may create many instances of the same class as it runs, which operate independently. This is an easy way for the same procedures to be used on different sets of data.|$|E
50|$|An <b>instance</b> <b>{{variable}}</b> {{is not a}} {{class variable}} although there are similarities. It {{is a type of}} class attribute (or class property, field, or data member). The same dichotomy between instance and class members applies to methods ("member functions") as well; a class may have both instance methods and class methods.|$|E
5000|$|Like {{conjoined}} twins, {{classes and}} metaclasses are born together. [...] has an <b>instance</b> <b>variable</b> , which points to its conjoined class.Note that the usual Smalltalk class browser {{does not show}} metaclasses as separate classes. Instead the class browser allows to edit the class together with its metaclass at the same time.|$|E
5000|$|The posing class {{must not}} define any new <b>instance</b> <b>variables</b> that are {{absent from the}} target class (though it may define or {{override}} methods).|$|R
40|$|This {{research}} {{is concerned with}} inheritance as used in object-oriented database. More specifically, partial bi-directional inheritance among classes is examined. In partial inheritance, a class can inherit a proper subset of <b>instance</b> <b>variables</b> from another class. Two subclasses of the same superclass {{do not need to}} inherit the same proper subset of <b>instance</b> <b>variables</b> from their superclass. Bi-directional partial inheritance allows a class to inherit <b>instance</b> <b>variables</b> from its subclass. The prototype of an object-oriented database that supports both full and partial bi-directional inheritance among classes was developed on top of an existing relational database management system. The prototype was tested with two database applications. One database application needs full and partial inheritance. The second database application required bi-directional inheritance. The result of this testing suggests both advantages and disadvantages of partial bi-directional inheritance. Future areas of research are also suggested...|$|R
5000|$|Instance methods - {{belong to}} {{individual}} objects, and {{have access to}} <b>instance</b> <b>variables</b> for the specific object they are called on, inputs, and class variables ...|$|R
