86|479|Public
5000|$|The PBKDF2 <b>key</b> <b>derivation</b> <b>function</b> {{has five}} input parameters: ...|$|E
5000|$|PBKDF2, {{a widely}} used {{standard}} password-based <b>key</b> <b>derivation</b> <b>function</b> ...|$|E
5000|$|NeoScrypt, a {{password}} based <b>key</b> <b>derivation</b> <b>function,</b> employs BLAKE2s within its FastKDF component.|$|E
50|$|<b>Key</b> <b>derivation</b> <b>functions</b> {{are often}} used as {{components}} of multiparty key-agreement protocols.Examples of such <b>key</b> <b>derivation</b> <b>functions</b> include KDF1, defined in IEEE Std 1363-2000, and similar functions in ANSI X9.42.|$|R
50|$|The DACS {{distribution}} includes various cryptographic functionality,such as message digests, HMACs,symmetric {{and public}} key encryption,ciphers (ChaCha20, OpenSSL),digital signatures,password-based <b>key</b> <b>derivation</b> <b>functions</b> (HKDF, PBKDF2),andmemory-hard <b>key</b> <b>derivation</b> <b>functions</b> (scrypt, Argon2),much {{of which is}} available from a simple scripting language.|$|R
5000|$|... #Subtitle level 2: <b>Key</b> <b>derivation</b> <b>functions</b> {{supported}} by crypt ...|$|R
5000|$|Can provide outputs of any desired length, {{behaving}} as a <b>Key</b> <b>Derivation</b> <b>Function</b> (KDF) ...|$|E
50|$|A <b>key</b> <b>derivation</b> <b>function</b> is used {{to derive}} the {{different}} keys used in a crypto context (SRTP and SRTCP encryption keys and salts, SRTP and SRTCP authentication keys) from one single master key in a cryptographically secure way. Thus, the key management protocol needs to exchange only one master key, all the necessary session keys are generated by applying the <b>key</b> <b>derivation</b> <b>function.</b>|$|E
50|$|In 2013 a Password Hashing Competition {{was held}} to develop an {{improved}} <b>key</b> <b>derivation</b> <b>function.</b>|$|E
40|$|Abstract. We {{introduce}} {{the concepts of}} memory-hard algorithms and sequential memory-hard functions, and argue {{that in order for}} <b>key</b> <b>derivation</b> <b>functions</b> to be maximally secure against attacks using custom hardware, they should be constructed from sequential memory-hard functions. We present a family of <b>key</b> <b>derivation</b> <b>functions</b> which, under the random oracle model of cryptographic hash functions, are provably sequential memory-hard, and a variation which appears to be marginally stronger at the expense of lacking provable strength. Finally, we provide some estimates of the cost of performing brute force attacks on a variety of password strengths and <b>key</b> <b>derivation</b> <b>functions.</b> 1...|$|R
50|$|<b>Key</b> <b>derivation</b> <b>functions</b> {{are also}} used to derive keys from secret {{passwords}} or passphrases.|$|R
50|$|More formally, crypt {{provides}} cryptographic <b>key</b> <b>derivation</b> <b>functions</b> for password validation {{and storage}} on Unix systems.|$|R
5000|$|The use of MD5 as a <b>Key</b> <b>derivation</b> <b>function</b> {{makes it}} {{computationally}} feasible {{to perform a}} brute-force attack on a Jungle Disk password.|$|E
5000|$|In cryptography, PBKDF1 and PBKDF2 (Password-Based <b>Key</b> <b>Derivation</b> <b>Function</b> 2) are key {{derivation}} functions with {{a sliding}} computational cost, aimed {{to reduce the}} vulnerability of encrypted keys to brute force attacks.|$|E
5000|$|One {{weakness}} of PBKDF2 {{is that while}} its number of iterations can be adjusted to make it take an arbitrarily large amount of computing time, it can be implemented with a small circuit and very little RAM, which makes brute-force attacks using application-specific integrated circuits or graphics processing units relatively cheap. [...] The bcrypt <b>key</b> <b>derivation</b> <b>function</b> requires a larger amount of RAM (but still not tunable separately, i.&thinsp;e. fixed for a given amount of CPU time) and is slightly stronger against such attacks, while the more modern scrypt <b>key</b> <b>derivation</b> <b>function</b> can use arbitrarily large amounts of memory and is therefore more resistant to ASIC and GPU attacks.|$|E
50|$|Modern password-based <b>key</b> <b>derivation</b> <b>functions,</b> such as PBKDF2, use a {{cryptographic}} hash, such as MD5 or SHA1, {{a longer}} salt (e.g. 64 bits) {{and a high}} iteration count (tens or hundreds of thousands).|$|R
50|$|Modern password-based <b>key</b> <b>derivation</b> <b>functions,</b> such as PBKDF2 (specified in RFC 2898), use a {{cryptographic}} hash, such as SHA-2, {{more salt}} (e.g. 64 bits and greater) {{and a high}} iteration count (often tens or hundreds of thousands).|$|R
40|$|Cryptographic {{keys are}} vital to the {{security}} of internet security applications and protocols. Many widely-used internet security protocols have their own applicationspecific <b>Key</b> <b>Derivation</b> <b>Functions</b> (KDFs) that are used to generate the cryptographic keys required for their cryptographic functions. This Recommendation provides securit...|$|R
5000|$|Alice computes point [...] Bob computes point [...] The shared {{secret is}} [...] (the x {{coordinate}} of the point). Most standardized protocols based on ECDH derive a symmetric key from [...] using some hash-based <b>key</b> <b>derivation</b> <b>function.</b>|$|E
5000|$|Instead of {{generating}} a random symmetric key M, Bob first generates a random m, [...] He derives his symmetric key M by , where KDF is a <b>key</b> <b>derivation</b> <b>function,</b> {{such as a}} cryptographic hash. He then computes the ciphertext [...] corresponding to m: ...|$|E
5000|$|... {{cryptographic}} suite to be used, {{including a}} <b>key</b> <b>derivation</b> <b>function</b> (e.g., ANSI-X9.63-KDF with SHA-1 option), a {{message authentication code}} (e.g., HMAC-SHA-1-160 with 160-bit keys or HMAC-SHA-1-80 with 80-bit keys) and a symmetric encryption scheme (e.g., TDEA in CBC mode or XOR encryption scheme)â€”noted ...|$|E
50|$|Some systems {{attempt to}} derive a {{cryptographic}} key {{directly from a}} password. However, such practice is generally ill-advised {{when there is a}} threat of brute-force attack. Techniques to mitigate such attack include passphrases and iterated (deliberately slow) password-based <b>key</b> <b>derivation</b> <b>functions</b> such as PBKDF2 (RFC 2898).|$|R
50|$|For {{messages}} {{selected from}} a limited set of messages, for example passwords or other short messages, it can be feasible to invert a hash by trying all possible messages in the set. Because cryptographic hash functions are typically designed to be computed quickly, special <b>key</b> <b>derivation</b> <b>functions</b> that require greater computing resources have been developed that make such brute force attacks more difficult.|$|R
40|$|Cryptographic hash {{functions}} that compute a fixed- length message digest from arbitrary length messages {{are widely used}} for many purposes in information security. This document provides security guidelines for achieving the required or desired security strengths when using cryptographic applications that employ the approved cryptographic hash functions specified in Federal Information Processing Standard (FIPS) 180 - 3. These include functions such as digital signature applications, Keyed-hash Message Authentication Codes (HMACs) and Hash-based <b>Key</b> <b>Derivation</b> <b>Functions</b> (HKDFs). <b>KEY</b> WORDS: digital signatures, hash algorithms, cryptographic hash function, hash <b>function,</b> hash-based <b>key</b> <b>derivation</b> algorithms, hash value, HMAC, message digest...|$|R
50|$|HKDF is an HMAC based <b>key</b> <b>derivation</b> <b>function</b> that {{transforms}} any {{weak key}} material into cryptographically strong key material. It can be used, for example, to convert Diffie Hellman exchanged shared secrets into key material {{suitable for use}} in encryption, integrity checking or authentication.|$|E
50|$|The shared secret can be {{used for}} {{authentication}} (for instance when logging into a remote system) using methods such as challenge-response or it can be fed to a <b>key</b> <b>derivation</b> <b>function</b> to produce one or more keys to use for encryption and/or MACing of messages.|$|E
5000|$|Periodical {{application}} of the <b>key</b> <b>derivation</b> <b>function</b> will result in security benefits. It prevents an attacker from collecting large amounts of ciphertext encrypted with one single session key. Certain attacks are easier to carry out when {{a large amount of}} ciphertext is available. Furthermore, multiple applications of the <b>key</b> <b>derivation</b> <b>function</b> provides backwards and forward security in the sense that a compromised session key does not compromise other session keys derived from the same master key. This means that even if an attacker managed to recover a certain session key, he is not able to decrypt messages secured with previous and later session keys derived from the same master key. (Note that, of course, a leaked master key reveals all the session keys derived from it.) ...|$|E
30|$|Key freshness: Since the keying {{materials}} are {{transferred from the}} old AS, this property could be verified by considering the <b>key</b> <b>derivation</b> <b>functions</b> (KDFs) for the MS = PRF (UUK, R 1 |R 2), AK = PRF (MS, R 1 |R 2) and SK = PRF 2 (MS, R 1 |R 2) in the initial AKA protocol. We could claim that, this property is guaranteed since fresh random values R 1, R 2 {{are included in the}} KDFs of the MS, AK and SK keys.|$|R
5000|$|<b>Key</b> <b>derivation</b> <b>functions</b> {{are often}} used in {{conjunction}} with non-secret parameters to derive one or more keys from a common secret value (which is sometimes also referred to as [...] "key diversification"). Such use may prevent an attacker who obtains a derived key from learning useful information about either the input secret value {{or any of the other}} derived keys. A KDF may also be used to ensure that derived keys have other desirable properties, such as avoiding [...] "weak keys" [...] in some specific encryption systems.|$|R
40|$|The cloud {{prevents}} {{cheap and}} convenient ways to create shared remote repositories. One concern when creating systems that provide security {{is if the}} system {{will be able to}} remain secure when new attacks are developed. As tools and techniques for breaking security systems advance, new ideas are required to provide the security guarantees that may have been exploited. This project presents a framework which can handle the ever growing need for new security defenses. This thesis describes the <b>Key</b> <b>Derivation</b> Module that I have constructed, including many new <b>Key</b> <b>Derivation</b> <b>Functions,</b> that is used in our system. by Matthew D. Falk. Thesis: M. Eng., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2013. Cataloged from PDF version of thesis. Includes bibliographical references (page 59) ...|$|R
50|$|Threefish's {{nonlinearity}} comes {{entirely from}} {{the combination of}} addition operations and exclusive-ORs; it does not use S-boxes. The function is optimized for 64-bit processors, and the Skein paper defines optional features such as randomized hashing, parallelizable tree hashing, a stream cipher, personalization, and a <b>key</b> <b>derivation</b> <b>function.</b>|$|E
50|$|One {{approach}} to preventing related-key attacks is to design protocols and applications so that encryption keys {{will never have}} a simple relationship with each other. For example, each encryption key can be generated from the underlying key material using a cryptographic hash function or other <b>key</b> <b>derivation</b> <b>function.</b>|$|E
5000|$|Argon2 is a <b>key</b> <b>derivation</b> <b>function</b> {{that was}} {{selected}} as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from University of Luxembourg. Argon2 is released under a Creative Commons CC0 license, and provides three related versions: ...|$|E
40|$|We {{provide a}} {{framework}} enabling the construction of IBE schemes that are secure under relatedkey attacks (RKAs). Specific instantiations of the framework yield RKA-secure IBE schemes for sets of related <b>key</b> <b>derivation</b> <b>functions</b> that are non-linear, thus overcoming a current barrier in RKA security. In particular, we obtain IBE schemes that are RKA secure for sets consisting of all affine functions and all polynomial functions of bounded degree. Based on this we obtain the first constructions of RKA-secure schemes for the same sets for the following primitives: CCA-secure public-key encryption, CCA-secure symmetric encryption and Signatures. All our results are in the standard model and hold under reasonable hardness assumptions...|$|R
40|$|We {{revisit the}} venerable {{question}} of "pure password"-based <b>key</b> <b>derivation</b> and encryption,and expose security weaknesses in current implementations that stem from structural flaws in <b>Key</b> <b>Derivation</b> <b>Functions</b> (KDF). We advocate a fresh redesign, named Halting KDF (HKDF),which we thoroughly motivate on these grounds: 1. By letting password owners choose the hash iteration count, we gain operational flexibilityand eliminate the rapid obsolescence faced by many existing schemes. 2. By throwing a Halting-Problem wrench {{in the works}} of guessing that iteration count, wewiden the security gap with any attacker to its theoretical optimum. 3. By parallelizing the <b>key</b> <b>derivation,</b> we let legitimate users exploit all the computationalpower they can muster, which in turn further raises the bar for attackers. HKDFs are practical and universal: they work with any password, any hardware, and aminor change to the user interface. As a demonstration, we offer real-world implementations for the TrueCrypt and GnuPG packages, and discuss their security benefits in concrete terms...|$|R
5000|$|... v is the host's {{password}} verifier, v = g {{where at}} a minimum x = H(s, p). As x is only computed on the client it is free to choose a stronger algorithm. Usage of <b>key</b> <b>derivation</b> <b>functions</b> like PBKDF2 instead of simple hash functions for password hashing is highly recommended [...] An implementation could choose to use x = H(s | I | p) without affecting any steps required of the host. The standard RFC2945 defines x = H(s | H ( [...] I | [...] ":" [...] | p) [...] ). Use of [...] within x avoids a malicious server {{from being able to}} learn if two users share the same password.|$|R
