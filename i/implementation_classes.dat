17|548|Public
5000|$|Guice allows <b>implementation</b> <b>classes</b> to {{be bound}} {{programmatically}} to an interface, then injected into constructors, methods or fields using an [...] annotation. When more than one implementation of the same interface is needed, the user can create custom annotations that identify an implementation, then use that annotation when injecting it.|$|E
5000|$|Live Class Reloading: Tapestry {{monitors}} the file system for changes to Java page classes, component classes, service <b>implementation</b> <b>classes,</b> HTML templates and component property files, and it hot-swaps the changes into the running application without requiring a restart. This provides {{a very short}} code-save-view feedback cycle that is claimed to greatly improve developer productivity.|$|E
5000|$|In Dec 2011, Hibernate Core 4.0.0 Final was released. This {{includes}} {{new features}} such as multi-tenancy support, introduction of ServiceRegistry (a major change in how Hibernate builds and manages [...] "services"), better session opening from SessionFactory, improved integration via org.hibernate.integrator.spi.Integrator and auto discovery, internationalization support, message codes in logging, and a more distinction between the API, SPI or <b>implementation</b> <b>classes.</b>|$|E
50|$|With EJB 2.1 and earlier, each EJB had {{to provide}} a Java <b>implementation</b> <b>class</b> and two Java interfaces. The EJB {{container}} created instances of the Java <b>implementation</b> <b>class</b> to provide the EJB implementation. The Java interfaces were used by client code of the EJB.|$|R
5000|$|... <b>{{implementation}}</b> <b>class</b> HelloWorld int main Array argv { nl; } end; implementation instance HelloWorld end; ...|$|R
5000|$|Interface: a {{specification}} of behavior. An <b>implementation</b> <b>class</b> must be written {{to support the}} behavior of an interface class.|$|R
50|$|In SARL, a Multiagent System (MAS) is a {{collection}} of Agents interacting together in shared distributed Spaces.Each agent has {{a collection}} of Capacities describing what it is able to perform, its personal competences.Each Capacity may then be realized/implemented by various Skills.For understanding the relationship between the concepts of Capacity and Skill, a parallel can be drawn with concepts of Interface and their <b>implementation</b> <b>classes</b> in object-oriented languages.To implement specific architectures (like BDI, reasoning, reactive, hybrid, etc.) developers should develop their own capacities and skills providing the agents with new exploitable features.|$|E
50|$|The {{classes in}} the library could be divided into roughly two categories: abstractions and implementations. Classes, that fall into abstractions category, provide an {{interface}} which is sufficient for working with any type of a stream. The code using such classes doesn't depend on the exact location the data is read from or is written to. For example, such code could write data to a file, a memory buffer or a web socket without a recompilation. The <b>implementation</b> <b>classes</b> inherit the abstraction classes and provide an implementation for concrete type of data source or sink. The library provides implementations only for file-based streams and memory buffer-based streams.|$|E
40|$|Programming {{languages}} provide various {{mechanisms to}} support information hiding. One problem with information hiding, however, is that providing a stable interface behind which to hide implementation details involves fixing in advance the services offered through the interface. We introduce a flexible approach {{to define and}} manage interfaces to achieve separation of concerns in evolving software. Our approach involves explicitly specifying interface and <b>implementation</b> <b>classes</b> for individual concerns, and automatically classifying <b>implementation</b> <b>classes</b> based on their relation to the interface. Our approach is supported by JMantlet, a tool that provides advanced interface management within an integrated development environment. We report on {{a case study of}} a large system that provides evidence that flexible interface management is desirable and adequately supported by our approach. 1...|$|E
40|$|A `class' in {{object-oriented}} paradigm represents both interface and <b>implementation</b> of the <b>class.</b> However, interface and <b>implementation</b> of a <b>class</b> {{are needed}} on different purposes, since class interface is shared among most users, while <b>class</b> <b>implementation</b> is used {{only to the}} implementors of the class. In this paper 1, we introduce {{a new level of}} data abstraction, called the `class-implementation level', which is based on the separated management of interface and <b>implementation</b> of a <b>class.</b> And we describe a new model for OODBMS which provides users with the abstract view of the <b>class</b> <b>implementation.</b> 1 Introduction Most OODBMSs are based on `classes[6]'. The definition of a `class' can be divided into two part [...] class interface and <b>class</b> <b>implementation.</b> <b>Class</b> interface represents data semantics which is shared among users, while <b>class</b> <b>implementation</b> implements a <b>class</b> including data structures and method definitions. Many extended relational database management systems (ERDBMS) a [...] ...|$|R
50|$|In {{object-oriented}} programming the implementation details of an API-level class can be hidden in an own <b>implementation</b> <b>class.</b> An opaque pointer (or reference) to that class {{is stored in}} the API-level class.|$|R
50|$|Using {{annotations}} {{from the}} JSR 181, you can annotate a Web service <b>implementation</b> <b>class</b> or a Web service interface. It enables developers to create portable Java Web Services {{from a simple}} Plain Old Java Object (POJO) class by adding annotations, and also helps in generating a Web service with a wizard or by publishing the service on to a server.|$|R
40|$|AbstractA modal {{transition}} {{system has}} {{a class of}} implementations, its maximal refinements. This class determines satisfiability and validity judgments, and their compositional approximations, for formulas of Hennessy-Milner logic. Using topology, we prove structural properties of these judgments: refinement is reverse containment of classes of implementations, Hennessy-Milner logic characterizes refinement through validity judgments, <b>implementation</b> <b>classes</b> are topologically closed sets, Hennessy-Milner logic enjoys a compactness theorem on such classes, and a robust consistency measure between modal transition systems is definable. In particular, every formula of Hennessy-Milner logic is the finite disjunction of Hennessy-Milner logic formulas for which validity checks are reducible to model checks...|$|E
40|$|A modal {{transition}} {{system has}} {{a class of}} implementations, its maximal refinements. This class determines satisfiability and validity judgments, and their compositional approximations, for formulas of Hennessy-Milner logic. Using topology, we prove structural properties of these judgments: refinement is reverse containment of classes of implementations, Hennessy-Milner logic characterizes refinement through validity judgments, <b>implementation</b> <b>classes</b> are topologically closed sets, Hennessy-Milner logic enjoys a compactness theorem on such classes, and a robust consistency measure between modal transition systems is definable. In particular, every formula of Hennessy-Milner logic is the finite disjunction of Hennessy-Milner logic formulas for which validity checks are reducible to model checks. Â© 2006 Elsevier B. V. All rights reserved...|$|E
40|$|Resource Description Framework (RDF) is {{a general}} {{description}} technology {{that can be applied}} to many application domains. Redland is a exible and ecient implementation of RDF that complements this power and provides highlevel interfaces allowing instances of the model to be stored, queried and manipulated in C, Perl, Python, Tcl and other languages. Redland is implemented using an object-based API, providing several of the <b>implementation</b> <b>classes</b> as modules which can be added, removed or replaced to allow dierent functionality or application-specic optimisations. The framework provides the core technology for developing new RDF applications, experimenting with implementation techniques, APIs and representation issues. Keywords RDF, metadata, application framework 1...|$|E
40|$|This paper {{presents}} an implementation in Java of two abstract data types for graphs: directed and undirected graphs. We view the concrete class of directed graphs as the parent class with undirected graphs as an immediate subclass. Each is designed using facilities available from Java 5. 0. This paper describes {{the use of}} adjacency lists using the predefined List interface and the LinkedList <b>implementation</b> <b>class</b> from java. util...|$|R
40|$|This paper {{continues}} {{the discussion of}} the implementation of graphs using Java 5. 0 begun in [1] with special emphasis on weighted graphs, both directed and undirected, as well as the treatment of minimal spanning trees and shortest paths. Again the emphasis will be on implementing a number of the key results in this regard using the predefined List interface and the LinkedList <b>implementation</b> <b>class</b> from the Java Colllections hierarchy...|$|R
5000|$|Various {{improvements}} {{have been}} made within the JavaFX libraries for multithreading. The Task APIs have been updated to support much more concise threading capabilities (i.e. the JavaTaskBase class is no longer necessary since all the APIs are in Java, and the requirement to have a callback interface and Java <b>implementation</b> <b>class</b> are no longer necessary). In addition, the scene graph {{has been designed to}} allow scenes to be constructed on background threads and then attached to [...] "live" [...] scenes in a threadsafe manner.|$|R
40|$|Software reuse {{is one of}} {{the most}} advertised {{advantages}} of object-orientation. Inheritance, in all its forms, plays an important part in achieving greater reuse, at all stages of development. Class hierarchies start taking shape at the analysis level, where classes that share application-significant data and application-meaningful external behavior are grouped under more general classes. At the design level, such hierarchies are augmented with <b>implementation</b> <b>classes,</b> and possibly reorganized to take into account implementation factors such as performance or code reuse [22]. Getting the analysis-level hierarchy "right" is very important for the understandability and traceability of the models and the reusability of the resulting code [22]. In this paper, we propose a formal method that organizes a set of class interfaces into a lattice structure called Galois Lattice [10]. Such a lattice has several advantages including: 1) embodying protocol conformance, 2) supporting an incremental up [...] ...|$|E
40|$|Applicationsbased on the {{client-server}} model place a {{special emphasis on}} the specification of interfaces, the separation of interface and implementation and on the support for multiple implementations of the same interface. The class hierarchy of such an application has to be designed while taking these issues into account. In this paper we present a model for writing client-server applications in C++, based in our experience with the Mach 3 multi-server system. Interfaces are defined by C++ abstract classes, from which implementations are derived. Implementations generally use multiple-inheritance to inherit functionality from other <b>implementation</b> <b>classes.</b> We describe how this simple model {{was applied to the}} construction of the clients and servers that compose the Mach 3 multi-server, using standard C++. We discuss how multiple-inheritance simplified the design of the system and the need for run-time, type-safe pointer conversion. Finally, we give an overview of our class library and [...] ...|$|E
40|$|This paper {{discusses}} {{a realization}} of object persistence in a CORBA-based distributed system. In our approach, persistence of CORBA objects {{is accomplished by}} {{the integration of the}} ORB with an ODBMS. This approach is not limited to pure object-oriented database systems, as the ODBMS may be a combination of a relational DBMS and an object-relational mapper. The design and implementation of an Object Database Adapter that integrates an ORB and an ODBMS with C++ bindings is presented. The ODA uses delegation (rather than inheritance) to connect user-provided <b>implementation</b> <b>classes</b> and IDL-generated classes. Only the user-defined parts of CORBA objects are actually stored in a database. Their IDL-generated parts are dynamically instantiated, in transient memory, by the ODA. Persistent relationships between CORBA objects within a server are not realized at the CORBA level, but at the level of implementation objects. Database traversals and queries can therefore be executed at ODBMS speeds. The paper discusses in some detail a number of implementation issues, such as caching. ODA support to local transactions, ODA interfaces, and CORBA server organization are also examined. ...|$|E
50|$|A {{document}} is {{an object that}} contains a number of properties. A property can for an example be a value like a number or a string, {{or it can be}} a list of other documents. Every property is referenced using a key. When traversing the document tree, the user specifies a constructor to be used for creating the <b>implementation</b> <b>class</b> of the next level. The implementations are often a union of various traits that extend the Document interface, making it possible for them to handle setting and getting properties on their own.|$|R
40|$|This study {{examines}} {{the understanding of}} various aspects relating {{to the concept of}} interface class by Management Information Systems students. The examined aspects were: definition, <b>implementation,</b> <b>class</b> hierarchy and polymorphis m. The main contributions of this paper are as follows: we developed a questionnaire addressing the above aspects; we classified and analysed the students' responses to determine the students' understanding of the above aspects and to highlight common faulty solutions. The results obtained reveal that majority of the students demonstrated understanding of definition and <b>implementation</b> of interface <b>class,</b> however, only twothirds of the students demonstrated understanding of interface class in the context of class hierarchy and only one third of them demonstrated understanding of polymorphis m in the context of interface class. The studentsâ utterances from the interviews shed light on their difficultie...|$|R
5000|$|... #Subtitle level 2: The {{structure}} of a <b>class</b> <b>implementation</b> file ...|$|R
40|$|The {{object-oriented}} {{paradigm is}} becoming very popular for database applications and several object-oriented DBMSs have been developed. A basic notion in this paradigm is the inheritance hierarchy {{that allows the}} users to define objects and the associated operations starting from already defined objects. However, in database applications the inheritance hierarchy must provide a conceptual modeling function, {{in addition to the}} re-usability function. Another important requirement is to provide support for data distribution in (possibly) heterogeneous environments. This means that object implementation may differ depending on the object location. This paper presents a model that decouples these two aspects, modeling vs implementation, by using the concept of abstract and <b>implementation</b> <b>classes.</b> An abstract class specifies properties and methods for a set of similar objects, like in other object-oriented data models. An abstract class is however independent of the object implementation and location. An implementation class defines the implementation of an abstract class. In our model an abstract class may have several implementations. This allows the user to provide different implementations for the same set of objects, without requiring the objects to change class...|$|E
40|$|The reverse {{engineering}} methodology we developed {{is based on}} the reverse specification of the use-cases linked to the execution trace of the legacy system. Basically we aim at recovering the traceability links between the robustness model that represents the analysis of the use-case and its actual <b>implementation</b> <b>classes.</b> Therefore {{we need to be able}} to edit the use-cases and the scenarios of the system so that the environment could process this information together with the robustness model and the execution trace to recover the traceability links. We then developed a use-case and scenario editor that is coupled to a robustness model editor. In this paper, we present the UML meta-model extensions we made to formalize the use case and scenario models. Then we present the techniques we developed to assure the coherence between both models. Next we present the way we link the use-case and scenarios to the robustness model and present the Eclipse-based tool we developed. The key contributions of the paper are the definition of the use-cases and scenarios metamodels, the link between the specification and analysis meta models and the mechanisms we developed to assure their mutual coherence. Finally, we present the way these models can be edited and processed in the context of a real tool...|$|E
40|$|Abstract â Trace {{links between}} {{requirements}} and code {{are essential for}} many software development and maintenance activities. Despite significant advances in traceability research, creating links remains a human-intensive activity and surprisingly {{little is known about}} how humans perform basic tracing tasks. We investigate fundamental research questions regarding the effort and quality of recovering traces between requirements and code. Our paper presents two exploratory experiments conducted with 100 subjects (half with industrial experience, the other half without) who recovered trace links for two open source software systems in a controlled environment and cast over 125. 000 votes. In the first experiment, subjects recovered trace links between the two systems â requirements and <b>implementation</b> <b>classes.</b> In the second experiment trace links were established between requirements and implementation methods. In order to assess the validity of the trace links cast by subjects, key developers of the two software systems participated in our research and provided benchmarks. Our study yields surprising observations: trace capture is surprisingly fast and can be done within minutes even for larger classes; the quality of the captured trace links, while good, does not improve with higher trace effort; it is not harder though slightly more expensive to recover the trace links for larger, more complex classes; and, trace capture should be performed by multiple engineers because âhard-to-do â traces differed per subject and were not uniform to certain parts of code. These findings open interesting possibilities for future research...|$|E
5000|$|Hiding the <b>implementations</b> of a <b>class</b> {{library or}} product, {{revealing}} only their interfaces.|$|R
40|$|The {{aim of this}} {{research}} was to examine the perceptions of principals, literacy co-ordinators and teachers on the implementation of Children 2 Ì 7 s Literacy Success Strategy (CLaSS) as a literacy and professional development strategy and their insights for future literacy innovation. CLaSS is a whole-school and sector approach to literacy for the early years of schooling. Introduced in 1998 to Catholic primary schools in the Archdiocese of Melbourne, schools implementing CLaSS were supported by a professional development model throughout the <b>implementation.</b> <b>CLaSS</b> introduced to many schools a two-hour daily literacy block, data-driven instruction and the incorporation of professional learning teams within the professional development model...|$|R
50|$|The {{template}} {{pattern is}} useful working with auto-generated code. The challenge {{of working with}} generated code is that any refinement of the source material will lead {{to changes in the}} generated code, which could overwrite hand-written modifications. This may be solved using the Template pattern, by generating abstract code, and making hand-written modifications to a concrete subclass or <b>implementation</b> <b>class.</b> The abstract code may be {{in the form of an}} abstract class in C++, or an interface in Java or C#. The hand-written code would go into a subclass in C++, and an implementing class in Java or C#. When used with code generation, this pattern is sometimes referred to as the Generation Gap pattern.|$|R
40|$|Implementing a {{concurrent}} {{data structure}} typically begins with defining its sequential specification. However, when used as is, a nontrivial sequential data structure, {{such as a}} linked list, a search tree, or a hash table, may expose incorrect behavior: lost updates, inconsistent responses, etc. To ensure correctness, portions of the sequential code operating on the shared data must be "protected" from data races using synchronization primitives and, thus, certain schedules of the steps of concurrent operations must be rejected. But can we ensure {{that we do not}} "overuse" synchronization, i. e., that we reject a concurrent schedule only if it violates correctness? In this paper, we treat this question formally by introducing the notion of a concurrency-optimal implementation. A program's concurrency is defined here as its ability to accept concurrent schedules, i. e., interleavings of steps of its sequential implementation. An implementation is concurrency-optimal if it accepts all interleavings that do not violate the program's correctness. We explore the concurrency properties of search data structures which can be represented in the form of directed acyclic graphs exporting insert, delete and search operations. We prove, for the first time, that pessimistic e. g., based on conservative locking) and optimistic serializable e. g., based on serializable transactional memory) implementations of search data-structures are incomparable in terms of concurrency. Specifically, there exist simple interleavings of sequential code that cannot be accepted by any pessimistic (and resp., serializable optimistic) implementation, but accepted by a serializable optimistic one (and resp., pessimistic). Thus, neither of these two <b>implementation</b> <b>classes</b> is concurrency-optimal. Comment: Extended version of results in arXiv: 1203. 475...|$|E
40|$|The {{scheduling}} {{of tasks}} in real-time, resource-constrained embedded systems is typically performed using a simple scheduler. Scheduling algorithm is the key scheduler component which determines {{the way in which}} tasks can be executed to meet their timing constraints. To ensure precise task scheduling, the right decisions about the scheduler implementation have to be made. It has been argued that there is a wide gap between scheduling theory and its practical implementation which must be bridged to achieve a meaningful validation of embedded systems. The work described in this thesis attempts to address this gap by proposing a simple (generic) technique, called the Scheduler Test Case (STC), which provides the facility to explore how a particular real-time scheduler implementation can be expected to behave under a range of both normal and abnormal operating conditions. The primary focus of this thesis is on single-processor embedded systems employing Time-Triggered Co-operative (TTC) architectures. The technique proposed is a testing method which helps facilitate an empirical âblack-boxâ comparison between the behaviour of a set of representative <b>implementation</b> <b>classes</b> of the TTC scheduling algorithm. The key criterion against which scheduler behaviour is weighed up is the system predictability manifested by predictable task execution sequence, low timing jitter and unplanned error handling capabilities. The implementation costs (including CPU, memory and power requirements) involved in creating each scheduler are also considered for distinguishing between the different TTC implementations. The STC technique is then extended to provide a practical means for assessing the behaviour of multi-processor embedded designs employing Shared-Clock (S-C) scheduling architectures and TTC algorithm on the Controller Area Network (CAN) hardware protocol. In this part of the study, the STC technique explores the impact of using particular implementations of the S-C scheduler on the overall timing behaviour of multi-processor embedded systems. In addition to jitter behaviour which is measured empirically, the STC evaluates the communication behaviour by assessing the message latencies between any two communicating nodes in the network and the time frame required by the network to detect a temporary node failure. The results are expressed using mathematical equations. Moreover, the implementation costs (including network utilisation and memory overheads) are also considered to differentiate between the compared S-C schedulers. The thesis finally concludes by discussing the overall findings of this project and making some proposals for future work in the area concerned with in the project. EThOS - Electronic Theses Online ServiceGBUnited Kingdo...|$|E
50|$|In 2006 SWD {{was honored}} by the College Board {{as a model of}} {{excellence}} for AP <b>class</b> <b>implementation.</b>|$|R
5000|$|The Java {{platform}} (since version 1.5) {{provides a}} binary heap <b>implementation</b> with <b>class</b> [...] in the Java Collections Framework. This class implements by default a min-heap; {{to implement a}} max-heap, programmer should write a custom comparator. There is no support for the decrease/increase-key operation.|$|R
40|$|We {{propose a}} method for {{implementing}} behavioral interface specifications on the. NET platform. Our interface specifications are expressed as executable model programs. Model programs can be run either as stand-alone simulations or used as contracts to check the conformance of an <b>implementation</b> <b>class</b> to its specification. We focus on the latter, which we call runtime verification. In our framework, model programs are expressed in the new specification language AsmL. We describe how AsmL {{can be used to}} describe contracts independently from any implementation language, how AsmL allows properties of component interaction to be specified using mandatory calls, and how AsmL is used to check the behavior of a component written in any of the. NET languages, such as VB, C], orCÃ¾Ã¾...|$|R
40|$|Factory [3] Figure 7 hypermediacontext object, {{representing}} the system configuration resolver path hypermedia context activate(anchor) determineResolver(anchor) resolveToDocument(anchor) createDocument(docSpec) resolveToDocSpec(anchor) targetDocument activated() anchor edit() resolveToAnchor(anchor) createAnchor(anchSpec) resolveToAnchorSpec(anchor) targetAnchor select() 7. Design Guidelines for Tailorable Frameworks This single hypermedia context object provides the framework hot spot {{in which an}} OO programmer can tailor the system configuration without altering {{the rest of the}} system. Thus, the third guideline addresses the extensibility requirement. Conclusion The proposed design guidelines cover only some {{of the state of the}} art in framework design. But because of the way they are formulated, they fit nicely with the other techniques available today [...] -i. e., design patterns, open <b>implementations,</b> <b>class</b> refactoring [...] -making them especially attractive. The fact t [...] ...|$|R
