12|10|Public
5000|$|Binary {{arithmetic}} {{uses the}} S/360 [...] "halfword" [...] instructions {{to operate on}} 16-bit quantities. Load <b>Halfword,</b> Add <b>Halfword,</b> Subtract <b>Halfword,</b> Compare <b>Halfword,</b> and Store <b>Halfword</b> were available, along with Add Register and Subtract register, ...|$|E
5000|$|Integers {{are stored}} as two's {{complement}} binary <b>halfword</b> or fullword values.|$|E
5000|$|... The Model 20 {{offers a}} stripped-down {{version of the}} {{standard}} instruction set with <b>halfword</b> (16-bit) instructions only plus the commercial instruction set and unique instructions for input/output.|$|E
50|$|Memory in the Sigma {{systems can}} be {{addressed}} as individual bytes, <b>halfwords,</b> words, or doublewords.|$|R
50|$|The media {{registers}} hold two {{new data}} types: octo byte (OB) and quad half (QH) that contain eight bytes (8-bit) and four <b>halfwords</b> (16-bit) integers.|$|R
40|$|This paper {{defines a}} {{functionally}} complete machine as a machine which {{is capable of}} evaluating every two place function over its data space. Necessary conditions on memory size for completeness are developed. These conditions are applied to System/ 360 as modelled by the space of bytes, the space of <b>halfwords,</b> and the space of words. Sufficiently large (> 64 K bytes) models of System/ 360 are shown to be complete for the space of bytes. No models of System/ 360 are complete for the spaces of <b>halfwords</b> or words. The inequalities developed and known examples of universal decision elements suggest structures for complete machines...|$|R
50|$|Memory (storage) in System/360 is {{addressed}} {{in terms of}} 8-bit bytes. Various instructions operate on larger units called <b>halfword</b> (2 bytes), fullword (4 bytes), doubleword (8 bytes), quad word (16 bytes) and 2048 byte storage block, specifying the leftmost (lowest address) of the unit. Within a <b>halfword,</b> fullword, doubleword or quadword, low numbered bytes are more significant than high numbered bytes; this is {{sometimes referred to as}} big-endian. Many uses for these units require aligning them on the corresponding boundaries. Within this article the unqualified term word refers to a fullword.|$|E
5000|$|The non-privileged {{instruction}} {{set of the}} System 4-50 and 4-70 included the integer, floating-point, character, and decimal instructions—in short, the full non-privileged {{instruction set}} of the IBM System 360, except for Test and Set (TS). [...] The ICL System 4-30 included the half-word instructions, LH, AH, SH, MH, and divide <b>halfword</b> (DH), etc., but not the fullword instructions L, A, etc.|$|E
50|$|Y is {{used for}} two byte (<b>halfword)</b> addresses. 'Y' adcons can {{directly}} address up to 32K bytes of storage, and are not widely used since early System/360. Early DOS/360 and BOS/360 systems made more use of Y adcons, since the machines these systems ran on had limited storage. The notation 'AL2(value)' is now usually used in preference to 'Y(value)' to define a 16 bit value.|$|E
5000|$|The major datatypes {{which are}} {{directly}} {{supported by the}} architecture are two's complement 36-bit integer arithmetic (including bitwise operations), 36-bit floating-point, and <b>halfwords.</b> Extended, 72-bit, floating point is supported through special instructions designed {{to be used in}} multi-instruction sequences. Byte pointers are supported by special instructions. A word structured as a [...] "count" [...] half and a [...] "pointer" [...] half facilitates the use of bounded regions of memory, notably stacks.|$|R
5000|$|Wireless MMX: 43 new SIMD {{instructions}} {{containing the}} full MMX instruction {{set and the}} integer instructions from Intel's SSE instruction set along with some instructions unique to the XScale. Wireless MMX provides 16 extra 64-bit registers that can be treated as an array of two 32-bit words, four 16-bit <b>halfwords</b> or eight 8-bit bytes. The XScale core can then perform up to eight adds or four MACs in parallel in a single cycle. This capability is used to boost speed in decoding and encoding of multimedia and in playing games.|$|R
5000|$|The 8106 was to {{have been}} the {{principal}} processor in the 8000 line, designed to bracket the performance of the IBM 7090 system. [...] The 8106 used a 64 bit word in one or more storage units of 4 K, 8 K, or 16 K words of core memory with an access time of 2 μs. Some of the storage units were {{supposed to be able to}} have been shared with other processors in the product line. Instructions could be one, two, or three 32-bit <b>halfwords</b> in length, allowing one, two, or three address instructions respectively. The system used nonpaged virtual memory, addressing blocks of 256 words through an address translation table.|$|R
50|$|In the mid-1970s, DEC {{designed}} the VAX to be a successor of the PDP-11. They used {{word for a}} 16-bit quantity, while longword referred to a 32-bit quantity. This was in contrast to earlier machines, where the natural unit of addressing memory would be called a word, while a quantity that is one half a word would be called a <b>halfword.</b> In fitting with this scheme, a VAX quadword is 64 bits.|$|E
50|$|The term 'word' is {{used for}} {{a small group of}} bits that are handled {{simultaneously}} by processors of a particular architecture. The size of a word is thus CPU-specific. Many different word sizes have been used, including 6-, 8-, 12-, 16-, 18-, 24-, 32-, 36-, 39-, 40-, 48-, 60-, and 64-bit. Since it is architectural, the size of a word is usually set by the first CPU in a family, rather than the characteristics of a later compatible CPU. The meanings of terms derived from word, such as longword, doubleword, quadword, and <b>halfword,</b> also vary with the CPU and OS.|$|E
5000|$|As {{part of the}} IPL {{facility}} {{the operator}} has a means of specifying a 12-bit device address, typically with three dials {{as shown in the}} operator controls drawing. When the operator selects the Load function, the system performs a System Reset, sends a Read IPL channel command to the selected device in order to read 24 bytes into locations 0-23 and causes the channel to begin fetching CCWs at location 8; the effect is as if the channel had fetched a CCW with a length of 24, and address of 0 and the flags containing Command Chaining + Suppress Length Indication. At the completion of the operation, the system stores the I/O address in the <b>halfword</b> at location 2 and loads the PSW from location 0.|$|E
40|$|Increasing cache latencies limit L 1 cache sizes. In {{this paper}} we {{investigate}} restrictive compression techniques for level 1 data cache, {{to avoid an}} increase in the cache access latency. The basic technique — All Words Narrow (AWN) — compresses a cache block only if all the words in the cache block are of narrow size. We extend the AWN technique to store a few upper <b>halfwords</b> (AHS) in a cache block to accommodate a small number of normal-sized words in the cache block. Further, we make the AHS technique adaptive, where the additional half-words space is adaptively allocated to the various cache blocks. We also propose techniques to reduce the increase in the tag space that is inevitable with compression techniques. Overall, the techniques in this paper increase the average L 1 data cache capacity (in terms of the average number of valid cache blocks per cycle) by about 50 %, compared to the conventional cache, with no or minimal impact on the cache access time. In addition, the techniques have the potential of reducing the average L 1 data cache miss rate by about 23 %. ...|$|R
40|$|This paper {{presents}} VEGAS, a new soft vector architecture, {{in which}} the vector processor reads and writes directly to a scratchpad memory instead of a vector register file. The scratchpad memory is a more efficient storage medium than a vector register file, allowing up to 9 × more data elements to fit into on-chip memory. In addition, the use of fracturable ALUs in VEGAS allow efficient processing of bytes, <b>halfwords</b> and words in the same processor instance, providing up to 4 × the operations compared to existing fixedwidth soft vector ALUs. Benchmarks show the new VE-GAS architecture is 10 × to 208 × faster than Nios II and has 1. 7 × to 3. 1 × better area-delay product than previous vector work, achieving much higher throughput per unit area. To put this performance in perspective, VEGAS is faster than a leading-edge Intel processor at integer matrix multiply. To ease programming effort and provide full debug support, VEGAS uses a C macro API that outputs vector instructions as standard NIOS II/f custom instructions. Categories and Subject Descriptors C. 1. 2 [Multiple Data Stream Architectures (Multiprocessors) ]: Array and vector processors; C. 3 [Specialpurpos...|$|R
2500|$|MIPS I has {{instructions}} that load and store 8-bit bytes, 16-bit <b>halfwords,</b> and 32-bit words. Only one addressing mode is supported: base + displacement. Since MIPS I is a 32-bit architecture, loading quantities fewer than 32 bits requires the datum {{to be either}} signed- or zero-extended to 32 bits. The load instructions suffixed by [...] "unsigned" [...] perform zero extension; otherwise sign extension is performed. Load instructions source the base from {{the contents of a}} GPR (rs) and write the result to another GPR (rt). Store instructions source the base from the contents of a GPR (rs) and the store data from another GPR (rt). All load and store instructions compute the memory address by summing the base with the sign-extended 16-bit immediate. MIPS I requires all memory accesses to be aligned to their natural word boundaries, otherwise an exception is signaled. To support efficient unaligned memory accesses, there are load/store word instructions suffixed by [...] "left" [...] or [...] "right". All load instructions are followed by a load delay slot. The instruction in the load delay slot cannot use the data loaded by the load instruction. The load delay slot can be filled with an instruction that is not dependent on the load; a nop is substituted if such an instruction cannot be found.|$|R
50|$|The arithmetic, logical, {{and move}} {{operations}} include variants which operate immediate-to-register, memory-to-register, register-to-memory, register-and-memory-to-both or memory-to-memory. Since registers may be addressed {{as part of}} memory, register-to-register operations are also defined. (Not all variants are useful, though they are well-defined.) For example, the ADD operation has as variants ADDI (add an 18-bit Immediate constant to a register), ADDM (add register contents to a Memory location), ADDB (add to Both, that is, add register contents to memory and also put the result in the register). A more elaborate example is HLROM (Half Left to Right, Ones to Memory), which takes the Left half of the register contents, places them in the Right half of the memory location, and replaces the left half of the memory location with Ones. <b>Halfword</b> instructions are also used for linked lists: HLRZ is the Lisp CAR operator; HRRZ is CDR.|$|E
50|$|The size or {{length of}} an {{instruction}} varies widely, from {{as little as}} four bits in some microcontrollers to many hundreds of bits in some VLIW systems. Processors used in personal computers, mainframes, and supercomputers have instruction sizes between 8 and 64 bits. The longest possible instruction on x86 is 15 bytes (120 bits). Within an instruction set, different instructions may have different lengths. In some architectures, notably most reduced instruction set computers (RISC), , typically corresponding with that architecture's word size. In other architectures, instructions have variable length, typically integral multiples of a byte or a <b>halfword.</b> Some, such as the ARM with Thumb-extension have mixed variable encoding, that is two fixed, usually 32-bit and 16-bit encodings, where instructions can not be mixed freely but must be switched between on a branch (or exception boundary in ARMv8).|$|E
5000|$|An IBM program RPQ {{added support}} for the IBM 3330 direct access storage facility, and this RPQ was applied by most users of ATS/360 which had {{migrated}} to early IBM System/370 processors. Essentially, this RPQ appended selected instances of the cannonical Load <b>Halfword</b> (LH) instruction (which implicitly featured [...] "sign extension" [...] from the halfword's high-order bit, conceptually bit 15 to the remaining 16 bits of the specified general purpose register, conceptually bits 31 to 16) with a logical and (N) instruction which specified a [...] "mask" [...] of 0x0000ffff, and which eliminated {{the effect of the}} high-order bit extension. This, then, allowed for 16-bit disk block addresses, which could later be converted into the expected and required CCHHR format. This approach was also applicable to IBM 3350 direct access storage facilities which were operated in 3330 compatibility mode, and which sacrificed 117 MB of the 3350's 317 MB total capacity in order to implement compatibility mode (two 3300 equivalent drives on one 3350 drive).|$|E

