256|14|Public
50|$|AIS {{includes}} a <b>deadlock</b> <b>avoidance</b> mechanism using null messages. The mechanism {{requires that the}} processes have exploitable lookahead characteristics.|$|E
5000|$|The Banker's algorithm, {{sometimes}} referred to as the detection algorithm, is a resource allocation and <b>deadlock</b> <b>avoidance</b> algorithm developed by Edsger Dijkstra that tests for safety by simulating the allocation of predetermined maximum possible amounts of all resources, and then makes an [...] "s-state" [...] check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.|$|E
50|$|He {{developed}} {{a number of}} techniques used in modern interconnection networks including routing-based <b>deadlock</b> <b>avoidance,</b> wormhole routing, link-level retry, virtual channels, global adaptive routing, and high-radix routers. He has developed efficient mechanisms for communication, synchronization, and naming in parallel computers including message-driven computing and fast capability-based addressing. He has {{developed a}} number of stream processors starting in 1995 including Imagine, for graphics, signal, and Image processing, and Merrimac, for scientific computing.|$|E
40|$|This paper {{discusses}} distributed deadlock detection. A detection {{scheme is}} evaluated by two criteria: first is if there exists an actual deadlock, {{it must be}} detected in a finite amount of time, and; second is the scheme must not find a deadlock that is not actually there. One way to detect deadlocks in distributed systems is for each site to construct a local WFG on the part it knows about. This paper describes about <b>deadlock</b> detection, <b>avoidance</b> and prevention. I...|$|R
40|$|Automated Guided Vehicle Systems (AGVS) form a very {{important}} part of automated material handling and its performance affects the efficiency of the entire system. Deadlock formation is a serious problem as it stalls the AGVS. The objective of this project is to develop an efficient <b>deadlock</b> prediction and <b>avoidance</b> algorithm...|$|R
30|$|A {{hierarchical}} CPN-based {{multi-agent system}} {{is presented in}} [32]. Each agent is modelled as a separate net that is connected with other agents’ nets and forms a hierarchical net. The behaviour of the multi-agent system is analysed through the dynamic properties such as reachability, <b>deadlock</b> detection and <b>avoidance,</b> fairness etc.|$|R
50|$|Habermann's {{research}} included programming languages, operating systems, {{and development}} of large software systems. He {{was known for his}} work on inter-process communication, process synchronization and <b>deadlock</b> <b>avoidance,</b> and software verification, but particularly for the computer languages ALGOL 60, BLISS, Pascal, and Ada. He also contributed to new operating systems such as Edsger Dijkstra's THE multiprogramming system, the Family of Operating Systems (FAMOS) at Carnegie Mellon, Berlin's Dynamically Adaptable System (DAS), and UNIX.|$|E
5000|$|Lockout-freedom {{guarantees}} that any process wishing {{to enter the}} critical section {{will be able to}} do so eventually. This is distinct from <b>deadlock</b> <b>avoidance,</b> which requires that some waiting process be able to get access to the critical section, but does not require that every process gets a turn. If two processes continually trade a resource between them, a third process could be locked out and experience resource starvation, even though the system is not in deadlock. If a system is free of lockouts, it ensures that every process can get a turn at some point in the future.|$|E
50|$|A state (as in {{the above}} example) is {{considered}} safe if {{it is possible for}} all processes to finish executing (terminate). Since the system cannot know when a process will terminate, or how many resources it will have requested by then, the system assumes that all processes will eventually attempt to acquire their stated maximum resources and terminate soon afterward. This is a reasonable assumption in most cases since the system is not particularly concerned with how long each process runs (at least not from a <b>deadlock</b> <b>avoidance</b> perspective). Also, if a process terminates without acquiring its maximum resource it only makes it easier on the system.A safe state is considered to be the decision maker if it's going to process ready queue.|$|E
40|$|This course {{introduces}} {{the design and}} implementation of modern operating systems. Topics covered include the history of operating systems, process synchronization and scheduling, <b>deadlock</b> detection and <b>avoidance,</b> memory management, file systems, protection and security, and input/output systems. Laboratory projects provide experience in using operating system facilities available on a Unix-like system. ...|$|R
40|$|The {{main goal}} of this PhD thesis is to propose and {{implement}} a methodology {{for the construction of}} programs based on the SCOOP model, and for modular reasoning about their correctness and liveness properties. In particular, the set of correctness rules that guarantee the absence of data races will be refined and formalized; an augmented type system will be proposed to enforce these rules at compile time. Furthermore, an efficient methodology for <b>deadlock</b> prevention, <b>avoidance,</b> detection, and resolution will be developed. A working implementation of SCOOP will be provided. It will take into consideration the proposed mechanisms and serve as a basis for further refinements of the model...|$|R
40|$|Abstract: Deadlock is {{a common}} problem in {{concurrent}} processing where two or more processes compete for resources in mutually exclusive way to access critical resources. The in-depth analysis and discussion about deadlock would be conducive to the improvement of reliability of the operating system. In this paper, problems about deadlock is analyzed and overviewed, including concept, cause of the <b>deadlock,</b> and prevention, <b>avoidance,</b> detection, and recovery from deadlock, etc. Operating system, the most important system software that runs on a computer, performs the task of interfacing users with computer hardware and managing software and hardware resources. In multi-user and multi-task computer systems, two or more processes may have to compete for {{a certain type of}} resources, in which case, a deadlock may occur if they continue to proceed in a...|$|R
5000|$|An {{extension}} of worm-hole flow control is Virtual-Channel flow control, where several virtual channels may be multiplexed across one physical channel. Each unidirectional virtual channel is realized by an independently managed pair of (flit) buffers. Different packets can then share the physical channel on a flit-by-flit basis. Virtual channels were originally introduced {{to solve the}} <b>deadlock</b> <b>avoidance</b> problem, {{but they can be}} also used to reduce wormhole blocking, improving network latency and throughput. Wormhole blocking occurs when a packet acquires a channel, thus preventing other packets from using the channel and forcing them to stall. Suppose a packet P0 has acquired the channel between two routers. In absence of virtual channels, a packet P1 arriving later would be blocked until the transmission of P0 has been completed. If virtual channels are implemented, the following improvements are possible: ...|$|E
50|$|For {{several years}} {{parallel}} hardware was only available for distributed computing but recently {{it is becoming}} available for the low end computers as well. Hence it has become inevitable for software programmers to start writing parallel applications. It is quite natural for programmers to think sequentially and hence they are less acquainted with writing multi-threaded or parallel processing applications. Parallel programming requires handling various issues such as synchronization and <b>deadlock</b> <b>avoidance.</b> Programmers require added expertise for writing such applications apart from their expertise in the application domain. Hence programmers prefer to write sequential code {{and most of the}} popular programming languages support it. This allows them to concentrate more on the application. Therefore, {{there is a need to}} convert such sequential applications to parallel applications with the help of automated tools. The need is also non-trivial because large amount of legacy code written over the past few decades needs to be reused and parallelized.|$|E
40|$|In {{automated}} manufacturing systems, <b>deadlock</b> <b>avoidance</b> policies guarantee deadlock-free operation while performance controllers, such as dispatching rules, {{attempt to}} achieve performance thresholds. In an automated system, dispatching rules must {{work within the}} constraints imposed by the <b>deadlock</b> <b>avoidance</b> policy in order to assure continuing system operation, and thus, the <b>deadlock</b> <b>avoidance</b> logic defines the decision space over which the dispatching rule can work. This paper investigates the interactions that arise between <b>deadlock</b> <b>avoidance</b> flexibility {{and the effectiveness of}} dispatching rules in achieving good system performance. Two major findings are that the positive effects of intelligent dispatching are highly influenced by the flexibility of the <b>deadlock</b> <b>avoidance</b> policy, and that a naive dispatching rule can sometimes achieve better system performance under an inflexible <b>deadlock</b> <b>avoidance</b> policy...|$|E
40|$|Multi-vehicle systems {{composed}} of Autonomous Guided Vehicles (AGVs) are largely used for industrial transportation in manufacturing and logistics systems. Deployment {{of a team}} of AGVs raises management and coordination problems such as <b>deadlock</b> and collision <b>avoidance,</b> conflict resolution, and shared resources negotiation. Decentralized approaches are more suitable than centralized ones for dealing with coordination problems due to the gains in terms of scalability. In a decentralized approach reliable dissemination of AGV state is a crucial operation that is however often neglected. The present paper proposes an efficient reliable protocol for multi-vehicle systems state information exchange among neighbours. This "Neighbourhood Monitoring" protocol allows for developing a reliable decentralized coordination scheme which is suitable for systems with large number of vehicles. The performance of the protocol is evaluated from several standpoints...|$|R
40|$|Abstract. In {{a process}} calculus, an agent {{guarantees}} responsive usage of a channel name r if a communication along r {{is guaranteed to}} eventually take place. Responsiveness is important, for instance, to ensure that any request to a service be eventually replied. We propose two distinct type systems, each of which statically guarantees responsive usage of names in well-typed pi-calculus processes. In the first system, we achieve responsiveness by combining techniques for <b>deadlock</b> and livelock <b>avoidance</b> with linearity and receptiveness. The latter is a guarantee that a name is ready to receive {{as soon as it}} is created. These conditions imply relevant limitations on the nesting of actions and on multiple use of names in processes. In the second system, we relax these requirements so as to permit certain forms of nested inputs and multiple outputs. ...|$|R
40|$|A system {{guarantees}} responsive {{usage of}} a channel r if a communication along r {{is guaranteed to}} eventually take place. Responsiveness is important, for instance, to ensure that any request to a service be eventually replied. We propose two distinct type systems, each of which statically guarantees responsive usage of names in well-typed pi-calculus processes. In the first system, we achieve responsiveness by combining techniques for <b>deadlock</b> and livelock <b>avoidance</b> with linearity and receptiveness. The latter is a guarantee that a name is ready to receive {{as soon as it}} is created. These conditions imply relevant limitations on the nesting of actions and on multiple use of names in processes. In the second system, we relax these requirements so as to permit certain forms of nested inputs and multiple outputs. We demonstrate the expressive power of the two systems by showing that primitive recursive functions – {{in the case of the}} first system – and Cook and Misra’s service orchestration language ORC – in the case of the second system – can be encoded into well-typed processes...|$|R
40|$|Avoiding {{deadlock}} {{is essential}} {{in the operation of}} highly automated manufacturing systems. Many of these systems support sufficient redundancy to permit flexible part routing. Although flexible routing improves the inherent operational flexibility of these systems, it also requires more highly sophisticated supervisory control techniques. The objective of this work is to characterize the <b>deadlock</b> <b>avoidance</b> problem for systems with flexible routing capabilities. Specifically, the paper addresses <b>deadlock</b> <b>avoidance</b> for single capacity systems (each machine has a single unit of buffer capacity), and mixed capacity systems (some machines have multiple units of buffer capacity). For each of these, we characterize deadlock and prove the correctness of several methods of suboptimal <b>deadlock</b> <b>avoidance.</b> We also address two interesting special cases. The first assumes that every stage of every part type can be performed on at least one multiple capacity machine, whereas the second provides a finite central buffer that can be revisited after every processing stage. For the first case, we present two suboptimal <b>deadlock</b> <b>avoidance</b> approaches, while for the second, we show optimal <b>deadlock</b> <b>avoidance</b> to be computationally tractable...|$|E
40|$|Abstract. We study <b>deadlock</b> <b>avoidance</b> for {{resource}} allocation in distributed systems. While a general solution of distributed <b>deadlock</b> <b>avoidance</b> is considered impractical, we propose an efficient {{solution of the}} important particular case where the possible sequences of remote calls, modeled as call graphs, are known a-priori. The algorithm presented here generalizes to recursive processes our earlier work on <b>deadlock</b> <b>avoidance</b> for non-recursive call-graphs. An essential part of this generalization is that when a new process is created, it announces the recursive depth corresponding {{to the number of}} times a recursive call can be performed in any possible sequence of remote invocations. 1 Introduction and Related Work We study the problem of <b>deadlock</b> <b>avoidance</b> in distributed systems. In particular, we focus on distributed computations that can require invocations at different sites; at each of them a local resource must be obtained to proceed...|$|E
40|$|The {{need for}} e#ective and e#cient <b>deadlock</b> <b>avoidance</b> {{policies}} (DAP's) is ever increasing {{due to the}} higher demand for system automation. This paper considers the <b>deadlock</b> <b>avoidance</b> problem for the class of Conjunctive/Disjunctive (sequential) resource allocation systems (C/D-RAS), in which multiple resource acquisitions and flexible routings are allowed. A new siphon-based characterization of deadlocks arising in C/D-RAS is developed, and subsequently, this characterization facilitates {{the development of a}} polynomial complexity <b>deadlock</b> <b>avoidance</b> policy for the considered RAS class. The developed policy can be perceived as a generalization of RUN DAP, originally developed for sequential RAS with unit resource allocations and no routing flexibility. The proposed approach is demonstrated by an example. 1. Introduction <b>Deadlock</b> <b>avoidance</b> in (sequential) resource allocation systems (S-RAS) is a well-defined problem in Discrete Event System literature. From a theoretical standpoint, the pr [...] ...|$|E
40|$|AbstractA system {{guarantees}} responsive {{usage of}} a channel r if a communication along r {{is guaranteed to}} eventually take place. Responsiveness is important, for instance, to ensure that any request to a service be eventually replied. We propose two distinct type systems, each of which statically guarantees responsive usage of names in well-typed pi-calculus processes. In the first system, we achieve responsiveness by combining techniques for <b>deadlock</b> and livelock <b>avoidance</b> with linearity and receptiveness. The latter is a guarantee that a name is ready to receive {{as soon as it}} is created. These conditions imply relevant limitations on the nesting of actions and on multiple use of names in processes. In the second system, we relax these requirements so as to permit certain forms of nested inputs and multiple outputs. We demonstrate the expressive power of the two systems by showing that primitive recursive functions–in the case of the first system–and Cook and Misra’s service orchestration language orc–in the case of the second system–can be encoded into well-typed processes...|$|R
40|$|Transactional memory (TM) systems seek to {{increase}} scalability, reduce programming complexity, and overcome the various semantic {{problems associated with}} locks. Software TM proposals run on stock processors and provide substantial flexibility in policy, but incur significant overhead for data versioning and validation {{in the face of}} conflicting transactions. Hardware TM proposals have the advantage of speed, but are typically highly ambitious, embed significant amounts of policy in silicon, and provide no clear migration path for software that must also run on legacy machines. We advocate an intermediate approach, in which hardware is used to accelerate a TM implementation controlled fundamentally by software. We present a system, RTM, that embodies this approach. It consists of a novel transactional MESI (TMESI) protocol and accompanying TM software. TMESI eliminates the key overheads of data copying, garbage collection, and validation without introducing any global consensus algorithm in the cache coherence protocol, or any new bus transactions. The only change to the snooping interface is a “threatened ” signal analogous to the existing “shared ” signal. By leaving policy to software, RTM allows us to experiment {{with a wide variety of}} policies for contention management, <b>deadlock</b> and livelock <b>avoidance,</b> data granularity, nesting, and virtualization. ...|$|R
40|$|Synchronization {{is used in}} {{real life}} so as to {{organize}} the work to grantee its continuation and preventing what we call blocking, which means no one go on working. Synchronization has a technical meaning in computer field that is related to this meaning but somewhat different. However, synchronization is increasingly used and being an important issue {{with the development of}} operating systems which improve the possibility for processes to cooperate with each other even in distributed systems. Processes can operate within one machine using shared memory or through multiple machines using message passing. This thesis searches how to achieve process synchronization either on a single machine or multicomputer systems. In the former one, synchronization can be achieved using multiple methods such as semaphore and monitor, where as in the later one we can use centralized, distributed or token ring algorithms. Then we focus on one of synchronization problems, deadlock. Deadlock is a situation where two or more processes are all blocked and none of them can become unblocked until one of others become unblocked. Three methods for handling <b>deadlock</b> situation: prevention <b>avoidance,</b> and detection. A C++ program has been designed using Message-Passing Interface (MPI) under LINUX operating system to execute a producer – consumer synchronization problem...|$|R
40|$|For a case-study of a wafer scanner {{from the}} {{semiconductor}} industry it is shown how model checking techniques {{can be used to}} compute (i) a simple yet optimal <b>deadlock</b> <b>avoidance</b> policy, and (ii) an infinite schedule that optimizes throughput. <b>Deadlock</b> <b>avoidance</b> is studied based on a simple finite state model using Smv, and for throughput analysis a more detailed timed automaton model has been constructed and analyzed using the Uppaal tool...|$|E
40|$|Abstract-Deadlocks {{constitute}} {{an important issue}} to he addressed {{in the design and}} operation of flexible manufacturing systems (FMS’s). In this paper, we show that prevention and avoidance of FMS deadlocks can he implemented using Petri net models. For deadlock prevention, we use the reachability graph of a Petri net model of the given FMS, whereas for <b>deadlock</b> <b>avoidance,</b> we propose a Petri net-based on-line controller. We discuss the modeling of the General Electric FMS at Erie, PA. For such real-world systems, deadlock prevention using the reacha-bility graph is not feasible. We develop a generic, Petri net-based on-line controller for implementing <b>deadlock</b> <b>avoidance</b> in such real-world FMS’s. Key Words-Flexible manufacturing system (FMS), General Electric FMS, deadlock prevention, <b>deadlock</b> <b>avoidance,</b> Petri Net models...|$|E
40|$|Efficient control schemes are {{required}} for effective cooperation of robot teams in a mobile wireless sensor network. If the robots (resources) are also in charge of executing multiple simultaneous missions, then risks of deadlocks due {{to the presence of}} shared resources among different missions increase and have to be tackled. Discrete event control with <b>deadlock</b> <b>avoidance</b> has been used in the past for robot team coordination for the case of multi reentrant flowline models with shared resources. In this paper we present an analysis of <b>deadlock</b> <b>avoidance</b> for a generalized case of multi reentrant flow line systems (MRF) called the Free Choice Multi Reentrant Flow Line systems (FMRF). In FMRF, some tasks have multiple resource choices; hence routing decisions have to be made and current results in <b>deadlock</b> <b>avoidance</b> for MRF do not hold. This analysis is based on the so-called Circular Waits (CW) of the resources in the system. For FMRF, the well known notions of Critical Siphons and Critical Subsystems must be generalized and we redefine these objects for such systems. Our second contribution provides a matrix formulation that efficiently computes the objects required for <b>deadlock</b> <b>avoidance</b> in FMRF systems. A MAXWIP dispatching policy is formulated for <b>deadlock</b> <b>avoidance</b> in FMRF systems. According to this policy, deadlock in FMRF is avoided by limiting the work in progress (WIP) in the critical subsystems of each CW. Implemented results of the proposed scheme in a WSN test-bed is presented in the paper...|$|E
40|$|Job {{deployment}} {{is essentially}} a vehicle-dispatching problem. In this problem, the impact of vehicle dispatching polices on the ship makespan for discharging and/or loading operations is analyzed. In particular, given a storage location for each container to be discharged from the ship and given the current location of each container to be loaded onto the ship, the problem is to propose an efficient deployment scheme to dispatch vehicles to containers so as to minimize the makespan of the ship so as to increase the throughput. The makespan of the ship refers to the time a ship spends at the port for loading and unloading operations. In this paper, we will compare the performance of current deployment scheme used with the new proposed deployment scheme, both with <b>deadlock</b> prediction & <b>avoidance</b> algorithm done in previous study [1]. The prediction & avoidance algorithm predicts and avoids cyclic deadlock. The current deployment scheme, namely pmds makes use of a greedy heuristics which dispatches the available vehicle that will reach the quay with the minimum amount of time the vehicle has to spend waiting for the crane to discharge/load the container from/onto the ship. The new deployment scheme, namely m c f aims to formulate the problem as a minimum cost flow problem, which will then be solved by network simplex code. The two simulation models are implemented using discrete-event simulation software, AutoMod, and the performances of both deployment schemes are analyzed. The simulation {{results show that the}} new deployment scheme will result in a higher throughput and lower ship makespan than the current deployment scheme. I...|$|R
40|$|Abstract—We {{describe}} a natural {{extension of the}} banker’s algorithm for <b>deadlock</b> <b>avoidance</b> in operating systems. Representing the control flow of each process as a rooted tree of nodes corresponding to resource requests and releases, we propose a quadratic-time algorithm which decomposes each flow graph into a nested family of regions, such that all allocated resources are released before the control leaves a region. Also, information on the maximum resource claims for each of the regions can be extracted prior to process execution. By inserting operating system calls when entering a new region for each process at runtime, and applying the original banker’s algorithm for <b>deadlock</b> <b>avoidance,</b> this method has the potential to achieve better resource utilization because information on the “localized approximate maximum claims ” is used for testing system safety. Index Terms—Banker’s algorithm, deadlock, <b>deadlock</b> <b>avoidance,</b> graph reduction, operating system, worst-case complexity. ...|$|E
40|$|This {{research}} {{addressed the}} design and implementation of a polynomial-complexity <b>deadlock</b> <b>avoidance</b> controller for a flexible manufacturing cell modeled using Colored Petri Nets. The cell model is robust {{to changes in the}} part types to be manufactured in the system and is automatically generated using the interaction of the resources in the cell and the technological capabilities of the machines. The model also captures dynamic routing flexibility options. The framework introduced separates the cell model from the control logic allowing the system designer to implement and test various control algorithms using the same cell model. The controller adopts the neighborhood <b>deadlock</b> <b>avoidance</b> policy to resolve deadlocks and control the resource allocation decisions within the system. The evaluation of the performance of systems controlled by not maximally permissive algorithms is important in determining the applicability of the control algorithms. There are many polynomial time <b>deadlock</b> <b>avoidance</b> algorithms proposed for the control of general resource allocation systems. However, the permissiveness of these algorithms is not quantified and the applicability of these algorithms in terms of effective resource utilization remains unanswered. The performance of automated manufacturing cells controlled using the neighborhood <b>deadlock</b> <b>avoidance</b> policy is benchmarked by comparing its performance with other control policies...|$|E
40|$|<b>Deadlock</b> <b>avoidance</b> in {{sequential}} {{resource allocation}} systems is a well-defined problem in Discrete Event System literature, as it underlies {{the operation of}} many contemporary technological systems. In the past, {{the problem has been}} studied by means of a number of formal frameworks, including the finite state automata (FSA) and Petri nets (PN). In this paper, it is shown that a significant class of <b>deadlock</b> <b>avoidance</b> policies (DAP), known as algebraic PK-DAP's, originally developed in the FSA paradigm, can be analyzed using recent results from PN structural analysis. Furthermore, the approach to DAP analysis and design taken in this paper has led to the e#ective generalization of the currently available algebraic PK-DAP's, and to their enrichment with new and more flexible policy implementations. 1. Introduction <b>Deadlock</b> <b>avoidance</b> is an essential control requirement for automated operation of modern technological systems that involve resource sharing. For instance, in a flexible manufa [...] ...|$|E
40|$|Recent {{results in}} the {{literature}} have provided efficient control synthesis techniques for the problem of <b>deadlock</b> <b>avoidance</b> in Petri nets. These results are shown to fit within an established framework for the enforcement of linear constraints on the marking behavior of a net. Framing the problem in this way allows uncontrollable transitions {{to be included in}} the plant model when <b>deadlock</b> <b>avoidance</b> is performed. This method for constructing deadlock avoiding supervisors in the face of uncontrollable transitions is described and illustrated with an example. 1 Introduction <b>Deadlock</b> <b>avoidance</b> is an important and difficult problem in the area of supervisory control. When the discrete event system (DES) is modeled by a Petri net (PN) [15 [...] 17], the net is said to be deadlocked if no transition in the net is able to fire. A net is called live if every transition can be, eventually, fired again and again. A deadlock-free net may not necessarily be completely live. An efficient supervisory co [...] ...|$|E
40|$|Abstract- With the {{transition}} from buses to on-chip networks in SoCs the problem of deadlocks in on-chip interconnects arises. Deadlocks {{can be caused by}} routing cycles in the network, or by message dependencies, even if the network itself is actually free of routing cycles. Two basic approaches to counter message dependent deadlocks exist: <b>deadlock</b> <b>avoidance,</b> which is most popular in NoCs, and deadlock recovery, which has until now only been used in parallel computer networks. Deadlock recovery promises low buffer space requirements and does not impose restrictions on connections between individual communication partners. For this study, we have adapted a deadlock recovery scheme for the use in NoCs and compared it to strict ordering as a representative of <b>deadlock</b> <b>avoidance</b> in terms of throughput and buffer space. The results show significant buffer space savings for deadlock recovery, however, at the cost of reduced data throughput. Network-on-chip, message dependent deadlocks, deadlock recovery, <b>deadlock</b> <b>avoidance,</b> strict ordering I...|$|E
40|$|This paper {{proposes a}} novel <b>Deadlock</b> <b>Avoidance</b> Algorithm (DAA) and its {{hardware}} implementation, the <b>Deadlock</b> <b>Avoidance</b> Unit (DAU), as an Intellectual Property (IP) core {{that provides a}} mechanism for very fast and automatic <b>deadlock</b> <b>avoidance</b> in MultiProcessor System-on-a-Chip (MP-SoC) with multiple (e. g., 10) processing elements and multiple (e. g., 40) resources. The DAU avoids deadlock by not allowing any grant or request {{that leads to a}} deadlock. In case of livelock, the DAU asks one of the processes involved in the livelock to release resource(s) so that the livelock can also be resolved. We simulated two realistic examples that can benefit from the DAU, and demonstrated that the DAU not only avoids deadlock in a few clock cycles but also achieves a 37 % speed-up of application execution time over avoiding deadlock in software. Finally, the SoC area overhead due to the DAU is small, under 0. 01 % in our example...|$|E
40|$|The {{number of}} virtual {{channels}} required for deadlock-free routing {{is important for}} cost-effective and high-performance system design. The planar adaptive routing scheme is an effective <b>deadlock</b> <b>avoidance</b> technique using only three virtual channels for each physical channel in 3 D or higher dimensional mesh networks with a very simple <b>deadlock</b> <b>avoidance</b> scheme. However, there exist one idle virtual channel for all physical channels along the first dimension and two idle virtual channels for channels along the last dimension in a mesh network based on the planar adaptive routing algorithm. A new <b>deadlock</b> <b>avoidance</b> technique is proposed for 3 D meshes using only two virtual channels by {{making full use of}} the idle channels. The deadlock-free adaptive routing scheme is then modified to a deadlock-free adaptive fault-tolerant routing scheme based on a planar network (PN) fault model. The proposed deadlock-free adaptive routing scheme is also extended to n-dimensional meshes still using two virtual channels. Sufficient simulation results are presented to demonstrate the effectiveness of the proposed algorithm...|$|E
40|$|A {{deadlock}} {{condition for}} flexible manufacturing systems {{is characterized by}} a set of parts, which have been processed but cannot be discharged by a set of machines or buffers. To avoid such problems, it is necessary to adopt suitable control policies which limit the resource allocation in the system, thus affecting the overall system performance. In the present work, we address the problem of evaluating and comparing the performance of <b>deadlock</b> <b>avoidance</b> control policies applied to FMS. The problem is discussed for both untimed and timed models, and for models both with and without <b>deadlock</b> <b>avoidance</b> control policies. Different control algorithms, among the most common in the literature, have been considered. Imperfect <b>deadlock</b> <b>avoidance</b> control policies are also considered. In addition, some indices are proposed to assess the structural properties of FMS with respect to deadlock occurrence and their performance. Two different application examples are analyzed, {{with the help of a}} commercial simulation package. Finally, an adaptive algorithm which can learn from system evolution to avoid deadlocks is illustrated...|$|E
