2086|10000|Public
25|$|A {{classifier}} is a {{generalization of}} a <b>finite</b> <b>state</b> <b>machine</b> that, similar to an acceptor, produces a single output on termination but {{has more than}} two terminal states.|$|E
25|$|Counter machine – {{the most}} {{primitive}} and reduced theoretical {{model of a}} computer hardware. Lacks indirect addressing. Instructions are in the <b>finite</b> <b>state</b> <b>machine</b> {{in the manner of}} the Harvard architecture.|$|E
25|$|Random access machine (RAM) – {{a counter}} machine with {{indirect}} addressing and, usually, an augmented instruction set. Instructions {{are in the}} <b>finite</b> <b>state</b> <b>machine</b> {{in the manner of}} the Harvard architecture.|$|E
40|$|In {{this paper}} the <b>finite</b> <b>state</b> <b>machines</b> are defined and formalized. There are {{presented}} the collaborative banking systems and their correspondence {{is done with}} <b>finite</b> <b>state</b> <b>machines.</b> It highlights the role of <b>finite</b> <b>state</b> <b>machines</b> in the complexity analysis and performs operations on very large virtual databases as <b>finite</b> <b>state</b> <b>machines.</b> It builds the state diagram and presents the commands and documents transition between the collaborative systems states. The paper analyzes the data sets from Collaborative Multicash Servicedesk application and performs a combined analysis {{in order to determine}} certain statistics. Indicators ar...|$|R
40|$|A new {{methodology}} {{to teach}} about the topic of <b>Finite</b> <b>State</b> <b>Machines</b> is presented in this paper. For this purpose, nine learning objectives which are classified into the three categories Basics of <b>Finite</b> <b>State</b> <b>Machines,</b> parallels between <b>Finite</b> <b>State</b> <b>Machines</b> and stock trading, {{and the application of}} <b>Finite</b> <b>State</b> <b>Machines</b> were developed and implemented into a Serious Game solution. This paper covers the third category about the application of <b>Finite</b> <b>State</b> <b>Machines</b> and its use to create Artificial Intelligence. The learning objectives were determined by using the widely-known Taxonomy of Bloom and integrated into the Serious Game The <b>Finite</b> <b>State</b> Trading Game (FSTG). In this turn-based trading game, the user aims to beat a Non-Player Character by skillfully trading shares while the user faces increasing complexity throughout the game. For the evaluation of the Serious Game approach a pre-test and post-test setting was performed with students of a local upper vocational school class at the Technical University of Munich. The results of the following analysis demonstrated significant progress in terms of the students’ knowledge about <b>Finite</b> <b>State</b> <b>Machines</b> for every tested statement...|$|R
40|$|The control {{software}} of the CERN Compact Muon Solenoid experiment contains over 27 500 <b>finite</b> <b>state</b> <b>machines.</b> These <b>state</b> <b>machines</b> are organised hierarchically: commands {{are sent}} down the hierarchy and state changes are sent upwards. The {{sheer size of}} the system makes it virtually impossible to fully understand the details of its behaviour at the macro level. This is fuelled by unclarities that already exist at the micro level. We have solved the latter problem by formally describing the <b>finite</b> <b>state</b> <b>machines</b> in the mCRL 2 process algebra. The translation has been implemented using the ASF+SDF meta-environment, and its correctness was assessed by means of simulations and visualisations of individual <b>finite</b> <b>state</b> <b>machines</b> and through formal verification of subsystems of the control software. Based on the formalised semantics of the <b>finite</b> <b>state</b> <b>machines,</b> we have developed dedicated tooling for checking properties that can be verified on <b>finite</b> <b>state</b> <b>machines</b> in isolation. © 2012 Elsevier B. V. All rights reserved...|$|R
25|$|A nondeterministic finite {{automaton}} (NFA), or nondeterministic <b>finite</b> <b>state</b> <b>machine,</b> {{does not need}} to obey these restrictions. In particular, every DFA is also an NFA. Sometimes the term NFA is used in a narrower sense, referring to a NDFA that is not a DFA, but not in this article.|$|E
25|$|A (possibly infinite) set of symbol sequences, aka. formal {{language}}, {{is called}} a regular language {{if there is some}} <b>Finite</b> <b>State</b> <b>Machine</b> that accepts exactly that set. For example, the set of binary strings with an even number of zeroes is a regular language (cf. Fig. 5), while the set of all strings whose length is a prime number is not.|$|E
25|$|A <b>finite</b> <b>state</b> <b>machine</b> {{can be used}} as a {{representation}} of a Markov chain. Assuming a sequence of independent and identically distributed input signals (for example, symbols from a binary alphabet chosen by coin tosses), if the machine is in state y at time n, then the probability that it moves to state x at time n+1 depends only on the current state.|$|E
50|$|In {{addition}} to their use in modeling reactive systems presented here, <b>finite</b> <b>state</b> <b>machines</b> are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, and logic. <b>Finite</b> <b>state</b> <b>machines</b> are a class of automata studied in automata theory and the theory of computation.In computer science, <b>finite</b> <b>state</b> <b>machines</b> are widely used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, {{and the study of}} computation and languages.|$|R
40|$|AbstractGiven a {{collection}} of <b>finite</b> <b>state</b> <b>machines,</b> Mi, with the same input alphabet, let M be the product machine, M = ΠMj. In general, not every state in M is reachable. A natural question is whether there are any inherent limits {{to the number of}} reachable states in a system that is the product of many small <b>finite</b> <b>state</b> <b>machines.</b> This note constructs a family of product machines M where the number of states is doubly exponential in the number of states in any individual machine Mi and every product state is reachable. Products of <b>finite</b> <b>state</b> <b>machines</b> such as discussed in this note occur when analyzing large collections of independently designed telecommunications services. These examples raise the possibility that product <b>finite</b> <b>state</b> <b>machines</b> modeling systems of independently designed services may have different characteristics from <b>finite</b> <b>state</b> <b>machines</b> modeling communications protocols. Consequently, analyzing collections of telecommunications services may require new heuristic methods...|$|R
2500|$|State diagrams, {{graphical}} {{representations of}} <b>finite</b> <b>state</b> <b>machines</b> ...|$|R
25|$|However, {{with only}} 4 registers, this machine has not nearly {{big enough to}} build a RASP that can execute the {{multiply}} algorithm as a program. No matter how big we build our <b>finite</b> <b>state</b> <b>machine</b> {{there will always be}} a program (including its parameters) which is larger. So by definition the bounded program machine that does not use unbounded encoding tricks such as Gödel numbers cannot be universal.|$|E
25|$|In {{the early}} 1980s, Evans & Sutherland (E) {{decoupled}} their PS300 graphics processor/display, which contained its own display information transformable through a dataflow architecture. Complex graphical objects could be downloaded over a serial line (e.g. 9600, 56K baud) or Ethernet interface and then manipulated without {{impact on the}} host. The architecture was excellent for high performance display but very inconvenient for domain-specific calculations, such as electron-density fitting and energy calculations. Many crystallographers and modellers spent arduous months trying to fit such activities into this architecture. E designed a card for the PS-300 which had several calculation algorithms using a 100 bit wide <b>finite</b> <b>state</b> <b>machine</b> {{in an attempt to}} simplify this process but it was so difficult to program that it quickly became obsolete.|$|E
500|$|The adder is {{designed}} to overflow when {{the sum of the}} absolute value of its operands exceeds its capacity (2N−1). The overflow bit is discarded so the output word width is always equal to its input word width. The remainder , called the residual, is stored in the register and the cycle repeats, starting this time from [...] (see figure 2). Since a phase accumulator is a <b>finite</b> <b>state</b> <b>machine,</b> eventually the residual at some sample K must return to the initial value [...] The interval K {{is referred to as the}} grand repetition rate (GRR) given by ...|$|E
5000|$|Low-level {{protocol}} descriptions specified as <b>finite</b> <b>state</b> <b>machines.</b>|$|R
25|$|In {{addition}} to their use in modeling reactive systems presented here, <b>finite</b> <b>state</b> <b>machines</b> are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, and logic. <b>Finite</b> <b>state</b> <b>machines</b> are a class of automata studied in automata theory and the theory of computation.|$|R
40|$|<b>Finite</b> <b>State</b> <b>Machines</b> {{have been}} widely used as a tool for {{developing}} video games, especially as pertains to solving problems related to AI, input handling, and game progression. In this paper, we introduce a practical technique that can highly improve the productivity of development of <b>Finite</b> <b>State</b> <b>Machines</b> in video games. This technique consists of adapting concepts of OOP for use with Hierarchical <b>Finite</b> <b>State</b> <b>Machines</b> in an entirely visual system. An open source implementation of the technique that can be used as middleware in most games is also provided...|$|R
2500|$|A {{deterministic}} <b>finite</b> <b>state</b> <b>machine</b> or acceptor deterministic <b>finite</b> <b>state</b> <b>machine</b> is a quintuple , where: ...|$|E
2500|$|A <b>finite</b> <b>state</b> <b>machine</b> {{just looks}} at the input signal and the current state: it has no stack to work with. [...] It chooses a new state, the result of {{following}} the transition. A pushdown automaton (PDA) differs from a <b>finite</b> <b>state</b> <b>machine</b> in two ways: ...|$|E
2500|$|A <b>finite</b> <b>state</b> <b>machine</b> has {{the same}} {{computational}} power as a Turing machine that is restricted such that its head may only perform [...] "read" [...] operations, and always has to move from left to right. That is, each formal language accepted by a <b>finite</b> <b>state</b> <b>machine</b> is accepted by such a kind of restricted Turing machine, and vice versa.|$|E
5000|$|State {{diagrams}} {{are directed}} multigraphs that represent <b>finite</b> <b>state</b> <b>machines.</b>|$|R
40|$|Regarding <b>finite</b> <b>state</b> <b>machines</b> as Markov chains {{facilitates}} {{the application of}} probabilistic methods to very large logic synthesis and formal verification problems. In this paper we present symbolic algorithms to compute the steady-state probabilities for very large <b>finite</b> <b>state</b> <b>machines</b> (up to 10 27 states). These algorithms, based on Algebraic Decision Diagrams (ADDs) [...] - an extension of BDDs that allows arbitrary values {{to be associated with}} the terminal nodes of the diagrams [...] - determine the steady-state probabilities by regarding <b>finite</b> <b>state</b> <b>machines</b> as homogeneous, discrete-parameter Markov chains with <b>finite</b> <b>state</b> spaces, and by solving the corresponding Chapman-Kolmogorov equations. We first consider <b>finite</b> <b>state</b> <b>machines</b> with <b>state</b> graphs composed of a single terminal strongly connected component; for this type of systems we have implemented two solution techniques: One is based on the Gauss-Jacobi iteration, the other one is based on simple matrix multiplication. Then we [...] ...|$|R
40|$|Abstract. The control {{software}} of the CERN Compact Muon Solenoid exper-iment contains over 30, 000 <b>finite</b> <b>state</b> <b>machines.</b> These <b>state</b> <b>machines</b> are or-ganised hierarchically: commands {{are sent}} down the hierarchy and state changes are sent upwards. The {{sheer size of}} the system makes it virtually impossible to fully understand the details of its behaviour at the macro level. This is fuelled by unclarities that already exist at the micro level. We have solved the latter problem by formally describing the <b>finite</b> <b>state</b> <b>machines</b> in the mCRL 2 process algebra. The translation has been implemented using the ASF+SDF meta-environment, and its correctness was assessed by means of simulations and visualisations of individual <b>finite</b> <b>state</b> <b>machines</b> and through formal verification of subsystems of the control software. Based on the formalised semantics of the <b>finite</b> <b>state</b> ma-chines, we have developed dedicated tooling for checking properties that can be verified on <b>finite</b> <b>state</b> <b>machines</b> in isolation. ...|$|R
2500|$|In automata theory, a <b>finite</b> <b>state</b> <b>machine</b> {{is called}} a {{deterministic}} finite automaton (DFA), if ...|$|E
2500|$|SDL embeds {{basic data}} types called [...] "Abstract Data Types", an action language, and an {{execution}} semantic {{in order to}} make the <b>finite</b> <b>state</b> <b>machine</b> executable.|$|E
2500|$|Pointer machine [...] – a {{blend of}} counter machine and RAM models. Less common and more {{abstract}} than either model. Instructions are in the <b>finite</b> <b>state</b> <b>machine</b> {{in the manner of}} the Harvard architecture.|$|E
40|$|The signal SAVE {{construct}} {{is one of}} {{the features}} distinguishing SDL from convent specification and programming languages. On the other hand, this feature increase testing SDL-specified software. We present a testing approach consisting of the foll SDL specifications are first abstracted into <b>finite</b> <b>state</b> <b>machines</b> with save constructs machines are transformed to equivalent <b>finite</b> <b>state</b> <b>machines</b> without save construc are selected from the resulting <b>finite</b> <b>state</b> <b>machines.</b> In particular, we give a fault m selection. We come up with an equivalent transformation method which works for constructs for which equivalent FSMs exist. We also investigate the detection of fa queue...|$|R
25|$|<b>Finite</b> <b>state</b> <b>machines</b> can be {{subdivided}} into transducers, acceptors, classifiers and sequencers.|$|R
40|$|This paper proposes an {{approach}} for generating test cases in Concurrent TTCN from {{a system of}} asynchronously communicating <b>finite</b> <b>state</b> <b>machines.</b> We give an algorithm for generating a noninterleaving model of prime event structures from a generalized model of asynchronously communicating <b>finite</b> <b>state</b> <b>machines</b> {{and deal with the}} generation of test cases from prime event structures...|$|R
2500|$|State register: A special Instruction Register [...] "IR", finite and {{separate}} from the registers above, stores the current instruction to be executed and its address in the TABLE of instructions; this register and its TABLE {{is located in the}} <b>finite</b> <b>state</b> <b>machine.</b>|$|E
2500|$|A <b>finite</b> <b>state</b> <b>machine</b> {{with only}} one state is called a [...] "combinatorial FSM". It only allows actions upon {{transition}} into a state. This concept is useful in cases where a number of finite state machines are required to work together, {{and when it is}} convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.|$|E
2500|$|A {{channel command}} word (CCW) is an {{instruction}} to a specialized I/O channel processor which is, in fact, a <b>finite</b> <b>state</b> <b>machine.</b> It {{is used to}} initiate an I/O operation, such as [...] "read", [...] "write" [...] or [...] "sense", on a channel-attached device. On system architectures which implement channel I/O, typically all devices are connected by channels, and so all I/O {{requires the use of}} CCWs.|$|E
50|$|For {{all that}} {{on the basis of}} data domain {{analysis}} the sources of input events, the control system (the system of interacting <b>finite</b> <b>state</b> <b>machines)</b> and the control objects implementing output actions are singled out. These control objects can also form yet another type of input actions that are transmitted through a feedback from control objects back to the <b>finite</b> <b>state</b> <b>machines.</b>|$|R
40|$|We {{propose a}} new {{algorithm}} {{to the problem}} of state reduction in incompletely specified <b>finite</b> <b>state</b> <b>machines.</b> This algorithm is not based on the enumeration of compatible sets, and, therefore, its performance is not dependent on the number of prime compatibles. We prove that the algorithm is exact and present results that show that, in a set of hard problems, it is much more efficient than both the explicit and implicit approaches based on the enumeration of compatible sets. 1 Introduction The reduction of <b>finite</b> <b>state</b> <b>machines</b> is a well known problem of great importance in sequential circuit synthesis. For completely specified <b>finite</b> <b>state</b> <b>machines</b> (FSM), the <b>state</b> reduction problem can be solved in polynomial time [13]. For incompletely specified <b>finite</b> <b>state</b> <b>machines</b> (ISFSM), the problem is known to be NP-complete [15]. Nonetheless, exact and heuristic algorithms are commonly used in practice, and it is possible, in many cases of practical importance, to obtain exact solutions. The [...] ...|$|R
5000|$|ASM: {{a precise}} form of pseudo-code, generalizing <b>Finite</b> <b>State</b> <b>Machines</b> to operate over {{arbitrary}} data structures ...|$|R
