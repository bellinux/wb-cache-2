1|1361|Public
5000|$|PCR4 - IPL (<b>Initial</b> <b>Program</b> <b>Loader)</b> Code (usually the Master Boot Record - MBR) ...|$|E
5000|$|Wine, {{which runs}} some Microsoft Windows {{binaries}} on Unix-like systems using a <b>program</b> <b>loader</b> and the Windows API implemented in DLLs ...|$|R
50|$|In {{an attempt}} {{to provide a more}} {{user-friendly}} environment, numerous software manufacturers wrote file management programs that provided users with menu- and/or icon-based interfaces. Microsoft Windows is a notable example, eventually resulting in Microsoft Windows 9x becoming a self-contained <b>program</b> <b>loader,</b> and replacing DOS as the most-used PC-compatible <b>program</b> <b>loader.</b> Text user interface programs included Norton Commander, DOS Navigator, Volkov Commander, Quarterdesk DESQview, and Sidekick. Graphical user interface programs included Digital Research's Graphics Environment Manager (originally written for CP/M) and GEOS.|$|R
50|$|The <b>program</b> <b>loader</b> {{uses the}} {{high-order}} {{bit of the}} instruction, ignored by all models, as a flag indicating that the instruction currently being loaded is to be relocated.|$|R
50|$|Under Unix-like {{operating}} systems, when {{a script}} with a shebang is {{run as a}} <b>program,</b> the <b>program</b> <b>loader</b> parses {{the rest of the}} script's initial line as an interpreter directive; the specified interpreter program is run instead, passing to it as an argument the path that was initially used when attempting to run the script. For example, if a script is named with the path path/to/script, and it starts with the following line: #!/bin/shthen the <b>program</b> <b>loader</b> is instructed to run the program /bin/sh instead, passing path/to/script as the first argument.|$|R
5000|$|... # MTS command mode #- MTS command {{continuation}} mode ? Prompts > [...] COPY and LIST commands [...] <b>Program</b> <b>loader</b> blank User <b>programs</b> : Editor + Symbolic Debugging System (SDS) @ Message System ftp> [...] FTP (File-Transfer) ...|$|R
50|$|With proof-carrying code, the kernel {{publishes a}} {{security}} policy specifying properties that any packet filter must obey: for example, will not access memory {{outside of the}} packet and its scratch memory area. A theorem prover is used {{to show that the}} machine code satisfies this policy. The steps of this proof are recorded and attached to the machine code which is given to the kernel <b>program</b> <b>loader.</b> The <b>program</b> <b>loader</b> can then rapidly validate the proof, allowing it to thereafter run the machine code without any additional checks. If a malicious party modifies either the machine code or the proof, the resulting proof-carrying code is either invalid or harmless (still satisfies the security policy).|$|R
5000|$|In the BASIC {{programming}} language, [...] is used {{to start}} program execution from direct mode, or to start a overlay <b>program</b> from a <b>loader</b> <b>program.</b>|$|R
5000|$|Typically {{only the}} length of the bss section, but no data, is stored in the object file. The <b>program</b> <b>loader</b> allocates and initializes memory for the bss section when it loads the program. Operating systems may use a {{technique}} called copy on write to efficiently implement the bss segment [...] In embedded software, the bss segment is mapped into memory that is initialized to zero by the C run-time system before [...] is entered.|$|R
40|$|The Commission on Teacher Credentialing (Commission) is reorganizing its {{process for}} {{reviewing}} <b>initial</b> <b>program</b> proposals. Historically, {{the review of}} <b>initial</b> <b>program</b> proposals (program narrative addressing the adopted standards and supporting documentation) has been facilitated by staff from the Professional Services Division (PSD) and organized separately {{by the type of}} prospective credential program. To provide institutions specific dates when <b>initial</b> <b>program</b> proposals will be read, reduce delays in the review of <b>initial</b> <b>program</b> proposals, and to coordinate the necessary steps in reviewing a prospective program proposal, Commission staff has developed a comprehensive <b>initial</b> <b>program</b> review process that will support the timely review of all prospective <b>program</b> proposals. <b>Initial</b> <b>Program</b> Review (IPR) Beginning in February 2010, the staff will facilitate a two-day meeting on a monthly basis where all <b>initial</b> <b>program</b> proposals that have been received in the prior month will be reviewed. By coordinating the <b>Initial</b> <b>Program</b> Review (IPR) across all types of credential programs, but continuing to assign individuals to review programs in which they have experience, staff can reduce duplicative work of scheduling meetings, contacting individuals to review the submission, and arranging the travel and lodging for the reviewers. PSD staff is now publishing the dates for the IPR for February 2010 through July 2010. They are...|$|R
50|$|Some {{embedded}} system designs may also include an intermediary boot sequence step {{in form of}} additional code that gets loaded into system RAM by the integrated boot ROM. Additional code loaded that way usually serves {{as a way for}} overcoming platform limitations, such as small amounts of RAM, so a dedicated primary boot loader, such as Das U-Boot, can be loaded as the next step in system's boot sequence. The additional code and boot sequence step are usually referred to as secondary <b>program</b> <b>loader</b> (SPL).|$|R
5000|$|Fastboot is a {{diagnostic}} protocol {{included with the}} SDK package used primarily to modify the flash filesystem via a USB connection from host computer. It requires that the device be started in a boot <b>loader</b> or Secondary <b>Program</b> <b>Loader</b> mode, in which only the most basic hardware initialization is performed. After enabling the protocol on the device itself, it will accept {{a specific set of}} commands sent to it via USB using a command line. Some of the most commonly used fastboot commands include: ...|$|R
5000|$|... HIGH SCHOOL : Three -Year <b>Initial</b> <b>Program</b> April 2004 to April 2007 dated March 28, 2004. -EDUCATION : Three -Year <b>Initial</b> <b>Program</b> April 2004 to April 2007 dated March 28, 2004.|$|R
25|$|In the Unix model, the {{operating}} system consists of two parts; first, the huge collection of utility programs that drive most operations, the other the kernel that runs the programs. Under Unix, from a programming standpoint, {{the distinction between the}} two is fairly thin; the kernel is a program, running in supervisor mode, that acts as a <b>program</b> <b>loader</b> and supervisor for the small utility programs making {{up the rest of the}} system, and to provide locking and I/O services for these programs; beyond that, the kernel didn't intervene at all in user space.|$|R
5000|$|Symbolic debuggers {{have existed}} since the {{mainframe}} era, almost {{since the first}} introduction of suitable computer displays on which to display the symbolic debugging information (and even earlier with symbolic dumps on paper). They were not restricted to high level compiled languages and were available also for Assembly language programs. For the IBM/360, these produced object code (on request) that included [...] "SYM cards". These were usually ignored by the <b>program</b> <b>loader</b> but were useful to a symbolic debugger as they were kept on the same program library as the executable logic code.|$|R
5000|$|On Unix systems, the execute {{permission}} controls {{access to}} invoking the file as a program, and applies both to executables and scripts.As the permission is enforced in the <b>program</b> <b>loader,</b> no obligation is needed from the invoking program, nor the invoked program, in enforcing the execute permission — this also goes for shells and other interpreter programs.The behaviour is {{mandated by the}} POSIX C library that is used for interfacing with the kernel: POSIX specifies that the [...] family of functions shall fail with EACCESS (permission denied) if the file denies execution permission (see [...] ).|$|R
5000|$|... ptrace only {{provides}} the most basic interface necessary to support debuggers and similar tools. Programs using it must have intimate knowledge of {{the specifics of the}} OS and architecture, including stack layout, application binary interface, system call mechanism, name mangling, the format of any debug data, and are responsible for understanding and disassembling machine code themselves. Further, programs that inject executable code into the target process or (like gdb) allow the user to enter commands that are executed {{in the context of the}} target must generate and load that code themselves, generally without the help of the <b>program</b> <b>loader.</b>|$|R
50|$|MACRO-11 is an {{assembly}} language with macro facilities for PDP-11 minicomputers from Digital Equipment Corporation (DEC). It is {{the successor to}} PAL-11 (<b>Program</b> Assembler <b>Loader),</b> {{an earlier version of}} the PDP-11 assembly language without macro facilities.|$|R
50|$|Position-independent code can be {{executed}} at any memory address without modification. This differs from relocatable code, {{in which a}} linker or <b>program</b> <b>loader</b> modifies a <b>program</b> before execution {{so it can be}} run only from a particular memory location. Generating position-independent code is often the default behavior for compilers, but they may place restrictions on the use of some language features, such as disallowing use of absolute addresses (position-independent code has to use relative addressing). Instructions that refer directly to specific memory addresses sometimes execute faster, and replacing them with equivalent relative-addressing instructions may result in slightly slower execution, although modern processors make the difference practically negligible.|$|R
5000|$|... a {{paper-tape reader}} (1000cps) for data and (<b>initial)</b> <b>program</b> input, ...|$|R
5000|$|A {{bootstrap}} process (a {{process called}} <b>Initial</b> <b>Program</b> Load or IPL) ...|$|R
5000|$|... #Caption: <b>Initial</b> <b>program</b> load {{punched card}} for the IBM 1130 (1965) ...|$|R
5000|$|The channels' {{programming}} is a best of A&E shows. Some of <b>initial</b> <b>programs</b> were: ...|$|R
40|$|SimCore/Alpha Functional Simulator Version 2. 0 (SimCore Version 2. 0), for {{processor}} architecture {{research and}} processor education. This paper describes {{the design and}} implementation of SimCore Version 2. 0. The main features of SimCore Version 2. 0 are as follows: (1) It offers many functions as a function-level simulator. (2) It is implemented compactly with 2, 800 lines in C++. (3) It separates {{the function of the}} <b>program</b> <b>loader.</b> (4) No global variable is used, and so it improves the readability and function. (5) It offers a powerful verification mechanism. (6) It operates on many platforms. (7) Compared with sim-fast in the SimpleScalar Tool Set, SimCore Version 2. 0 attains a 19 % improvement in simulation speed...|$|R
50|$|The {{university}} {{has plans to}} install over 20 degree <b>programs.</b> However the <b>initial</b> <b>programs</b> are as listed below.|$|R
5000|$|High flexibility: the bootmanager can boot every {{operating}} system {{which can be}} booted by the <b>Initial</b> <b>Program</b> Load.|$|R
40|$|The Pumping Instrumentation and Control Skids (PICS) {{contain a}} flow meter {{to display the}} flow in the {{discharge}} line and two digital displays to show the pressure in the suction and discharge lines of the jet pump. These three instruments require <b>programming</b> during <b>initial</b> setup. <b>Programming</b> consists of inputting parameters to fit the field application of the instruments. This guidance document provides the <b>initial</b> <b>programming</b> parameters for the Yokogawa AE 14 flow meter and the Yokogawa UM 330 digital display units. The guidance applies only to <b>initial</b> <b>programming</b> and may be changed in the field during setup of the PICS at specific tanks...|$|R
40|$|A {{message passing}} program {{composition}} methodology, called Ensemble, applied for Parix is presented. Ensemble overcomes the implementation problems and complexities in developing applications in message passing environments. Parallel applications are virtually specified by Process Communication Graphs (PCGs) annotated with communication information for Parix processes. Annotated PCGs are generated from application scripts by supporting tools. Reusable Parix executable components are defined {{from which all}} processes are created. A universal Parix <b>program</b> <b>loader</b> interprets the annotated PCGs creating the application processes from the reusable components and establishing their communication dependencies. Ensemble is applied to compose variations of Parix applications using the same reusable components. The methodology has been applied for PVM. Keywords: software engineering for parallel systems, message passing program composition, reusable message passing components, annotated process c [...] ...|$|R
40|$|We have {{developed}} a function-level processor simulator, SimCore/Alpha Functional Simulator Version 2. 0 (SimCore Version 2. 0), for processor architecture research and processor education. This paper describes the design and implementation of SimCore Version 2. 0. The main features of SimCore Version 2. 0 are as follows: (1) It offers many functions as a function-level simulator. (2) It is implemented compactly with 2, 800 lines in C++. (3) It separates {{the function of the}} <b>program</b> <b>loader.</b> (4) No global variable is used, and so it improves the readability and function. (5) It offers a powerful verification mechanism. (6) It operates on many platforms. (7) Compared with sim-fast in the SimpleScalar Tool Set, SimCore Version 2. 0 attains a 19 % improvement in simulation speed. ...|$|R
50|$|U-Boot {{is both a}} first-stage and second-stage bootloader. It {{is loaded}} by the system's ROM or BIOS from a {{supported}} boot device, such as an SD card, SATA drive, NOR flash (e.g. using SPI or I²C), or NAND flash. If there are size constraints, U-Boot may be split into stages: the platform would load a small SPL (Secondary <b>Program</b> <b>Loader),</b> and the SPL would do initial hardware configuration and load the rest of U-Boot. Regardless of whether the SPL is used, U-Boot performs both first-stage (e.g., configuring memory controllers and SDRAM) and second-stage booting (performing multiple steps to load a modern operating system {{from a variety of}} devices that must be configured, presenting a menu for users to interact with and control the boot process, etc.).|$|R
50|$|Dr. Jordan Sparks {{has done}} {{most of the}} <b>initial</b> <b>programming.</b> They have a team of {{additional}} programmers employed these days.|$|R
50|$|In the IBM System/360 and its successors, {{including}} the current z/Architecture machines, the boot process {{is known as}} <b>Initial</b> <b>Program</b> Load (IPL).|$|R
5000|$|The Sanfe Bagar Medical Clinic {{was opened}} on 6 April 2008. <b>Initial</b> <b>programs</b> focused on {{maternal}} health, child malnutrition, and HIV and tuberculosis treatment.|$|R
40|$|AbstractThis paper {{shows that}} Tamaki-Sato's unfold/fold {{transformation}} of Prolog programs preserves equivalence in a stronger sense {{that of the}} usual least Herbrand model semantics, which Tamaki and Sato originally showed. Conventionally, the semantics of Prolog program {{is defined by the}} least Herbrand model. However, the least Herbrand model does not always characterize what answer substitutions are returned. This paper proves that any program obtained from an <b>initial</b> <b>program</b> by applying Tamaki-Sato's transformation returns the same answer substitutions as the <b>initial</b> <b>program</b> for any given top-level goal...|$|R
40|$|In {{this paper}} we present an {{approach}} to the induction of recursive structures from examples {{which is based on}} the notion of recursive program schemes. We separate induction from examples in two stages: (1) constructing <b>initial</b> <b>programs</b> from examples and (2) folding <b>initial</b> <b>programs</b> to recursive program schemes. By this separation, the induction of recursive program schemes can be reduced to a pattern-matching problem which can be handled by a generic algorithm. Construction of <b>initial</b> <b>programs</b> is performed with {{an approach to}} universal planning. "Background knowledge" is given in the form of operators and their conditions of application. Furthermore synthesizing recursive program schemes instead of programs in a predefined programming language enables us to combine program synthesis and analogical reasoning. A recursive program scheme represents the class of structural identical programs and can be assigned different semantics by interpretation. We believe that our appr [...] ...|$|R
50|$|The station {{began as}} TV3 on 24 December 1995. Majority {{ownership}} was originally {{held by the}} Roman Catholic Church, {{and much of the}} <b>initial</b> <b>programming</b> was faith-oriented.|$|R
