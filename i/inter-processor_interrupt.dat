8|6|Public
5|$|In DragonFly, each CPU {{has its own}} thread scheduler. Upon creation, threads are {{assigned}} to processors and are never preemptively switched from one processor to another; they are only migrated by the passing of an <b>inter-processor</b> <b>interrupt</b> (IPI) message between the CPUs involved. Inter-processor thread scheduling is also accomplished by sending asynchronous IPI messages. One advantage to this clean compartmentalization of the threading subsystem is that the processors' on-board caches in Symmetric Multiprocessor Systems do not contain duplicated data, allowing for higher performance by giving each processor in the system {{the ability to use}} its own cache to store different things to work on.|$|E
5000|$|IRQ 13 CPU co-processor or {{integrated}} {{floating point}} unit or <b>inter-processor</b> <b>interrupt</b> (use depends on OS) ...|$|E
5000|$|<b>Inter-processor</b> <b>{{interrupt}}</b> (IPI): {{a special}} case of interrupt that is generated by one processor to interrupt another processor in a multiprocessor system.|$|E
50|$|The {{improved}} interface {{reduces the}} number of needed APIC register access for sending <b>Inter-processor</b> <b>interrupts</b> (IPIs). Because of this advantage, QEMU can and does emulate x2APIC for older processors that do not physically support it, going back to Conroe and even for AMD Opteron G-series processors (neither of which natively support x2APIC).|$|R
40|$|This report {{gives an}} {{overview}} of the techniques used in the multiprocessor implementation of the L 4 microkernel on the Alpha processor family. The implementation is designed to be scalable to a large number of processors, which is supported by keeping kernel data processor-local as much as possible, and minimising the use of spinlocks and <b>inter-processor</b> <b>interrupts...</b>|$|R
50|$|Local APICs (LAPICs) manage all {{external}} interrupts for some specific processor in an SMP system. In addition, {{they are able}} to accept and generate <b>inter-processor</b> <b>interrupts</b> (IPIs) between LAPICs. LAPICs may support up to 224 usable interrupt vectors from an I/O APIC. Vector numbers 0 to 31, out of 0 to 255, are reserved for exception handling by x86 processors.|$|R
5000|$|An <b>inter-processor</b> <b>{{interrupt}}</b> (IPI) is {{a special}} type of interrupt by which one processor may interrupt another processor in a multiprocessor system if the interrupting processor requires action from the other processor. Actions that might be requested include: ...|$|E
5000|$|The {{technology}} {{also provides}} a more secure way for the operating system to initialize the platform. In contrast to the normal processor initialization involved the boot-strap-processor (BSP) sending a Start-up <b>Inter-Processor</b> <b>Interrupt</b> (SIPI) to each Application Processor, thus starting each processor in [...] "real mode" [...] and then transitioning to [...] "virtual mode" [...] and finally to [...] "protected mode", the operating system avoids that vulnerability by performing a secure launch (a.k.a. measured launch) which puts the Application Processors in a special sleep state from which they are directly started in [...] "protected mode".|$|E
50|$|In DragonFly, each CPU {{has its own}} thread scheduler. Upon creation, threads are {{assigned}} to processors and are never preemptively switched from one processor to another; they are only migrated by the passing of an <b>inter-processor</b> <b>interrupt</b> (IPI) message between the CPUs involved. Inter-processor thread scheduling is also accomplished by sending asynchronous IPI messages. One advantage to this clean compartmentalization of the threading subsystem is that the processors' on-board caches in Symmetric Multiprocessor Systems do not contain duplicated data, allowing for higher performance by giving each processor in the system {{the ability to use}} its own cache to store different things to work on.|$|E
50|$|A purely {{software-based}} {{implementation of}} the receiving traffic distribution, known as receive packet steering (RPS), distributes received traffic among cores later in the data path, {{as part of the}} interrupt handler functionality. Advantages of RPS over RSS include no requirements for specific hardware, more advanced traffic distribution filters, and reduced rate of interrupts produced by a NIC. As a downside, RPS increases the rate of <b>inter-processor</b> <b>interrupts</b> (IPIs). Receive flow steering (RFS) takes the software-based approach further by accounting for application locality; further performance improvements are achieved by processing interrupt requests by the same cores on which particular network packets will be consumed by the targeted application.|$|R
40|$|This report {{presents}} Fiasco-SMP, a port of the Fiasco microkernel to the multiprocessor-x 86 architecture. We the discuss design principles we used, and {{the resulting}} design for remote-thread manipulation in Fiasco. In particular, we show how we extended Fiasco's implementation of priority inheritance to fit a multiprocessor environment. Our design has two desirable properties. First, it minimizes the number of <b>inter-processor</b> <b>interrupts</b> (IPIs) in the system. Second, for the normal (uncontented) case, it avoids synchronous inter-processor notifications (where one CPU needs {{to wait for the}} result of an IPI it sent to another CPU), thereby removing the effect of IPI latency on CPU-local execution [...] -even when manipulating remote threads. Moreover, we propose an extension to the L 4 interface that allows server threads to specify that the kernel is allowed to schedule them on a remote CPU (i. e., not on their home CPU) when they become runnable after an IPC. We believe that this behavior h [...] ...|$|R
40|$|Interrupt {{coalescing}} is a {{well known}} and proven technique for reducing CPU utilization when processing high IO rates in network and storage controllers. Virtualization introduces a layer of virtual hardware for the guest operating system, whose interrupt rate can be controlled by the hypervisor. Unfortunately, existing techniques based on high-resolution timers are not practical for virtual devices, due to their large overhead. In this paper, we present the design and implementation of a virtual interrupt coalescing (vIC) scheme for virtual SCSI hardware controllers in a hypervisor. We use the number of commands in flight from the guest {{as well as the}} current IO rate to dynamically set the degree of interrupt coalescing. Compared to existing techniques in hardware, our work does not rely on high-resolution interrupt-delay timers and thus leads to a very efficient implementation in a hypervisor. Furthermore, our technique is generic and therefore applicable to all types of hardware storage IO controllers which, unlike networking, donâ€™t receive anonymous traffic. We also propose an optimization to reduce <b>inter-processor</b> <b>interrupts</b> (IPIs) resulting in better application performance during periods of high IO activity. Our implementation of virtual interrupt coalescing has been shipping with VMware ESX since 2009. We present our evaluation showing performance improvements in micro benchmarks of up to 18 % and in TPC-C of up to 5 %. ...|$|R
40|$|Interrupt-based {{programming}} {{is widely used}} for interfacing a processor with peripherals and allowing software threads to interact. Many hardware/software architectures have been proposed {{in the past to}} support this kind of programming practice. In the context of FPGA-based multiprocessors this topic has not been thoroughly faced yet. This paper presents the architecture of an interrupt controller for a FPGA-based multiprocessor composed of standard off-of-the-shelf softcores. The main feature of this device is to distribute multiple interrupts across the cores of a multiprocessor. In addition, our architecture supports several advanced features like booking, broadcasting and <b>inter-processor</b> <b>interrupt.</b> On the top of this hardware layer, we provide a software library to effectively exploit this mechanism. We realized a prototype of this system. Our experiments show that our interrupt controller efficiently distributes multiple interrupts on the system...|$|E

