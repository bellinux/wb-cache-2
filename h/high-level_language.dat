1301|2670|Public
25|$|GNU Octave, a <b>high-level</b> <b>language,</b> {{primarily}} {{intended for}} numerical computations.|$|E
25|$|Situations {{where no}} <b>high-level</b> <b>language</b> exists, {{on a new}} or {{specialized}} processor, for example.|$|E
25|$|Assemblers {{can be used}} to {{generate}} blocks of data, with no <b>high-level</b> <b>language</b> overhead, from formatted and commented source code, to be used by other code.|$|E
40|$|<b>High-level</b> <b>languages</b> (Matlab, Python) {{are popular}} in {{neuroscience}} {{because they are}} flexible and accelerate development. However, for simulating spiking neural networks, the cost of interpretation is a bottleneck. We describe a set of algorithms to simulate large spiking neural networks efficiently with <b>high-level</b> <b>languages</b> using vector-based operations. These algorithms constitute the core of Brian, a spiking neural network simulator written in the Python language. Vectorised simulation {{makes it possible to}} combine the flexibility of <b>high-level</b> <b>languages</b> with the computational efficiency usually associated with compiled languages...|$|R
5000|$|... #Subtitle level 2: Low-level {{programming}} in <b>high-level</b> <b>languages</b> ...|$|R
50|$|Support {{for other}} <b>high-level</b> <b>languages</b> apart from C is possible.|$|R
25|$|Note: The Soviet Era {{computers}} Эльбрус-1 (Elbrus-1) and Эльбрус-2 {{were created}} using <b>high-level</b> <b>language</b> Эль-76 (AL-76), {{rather than the}} traditional assembly. Эль-76 resembles Algol-68, The main difference is the dynamic binding types in Эль-76 supported at the hardware level. Эль-76 is used for application, job control, system programming.|$|E
25|$|A {{microkernel}} {{allows the}} implementation of the remaining part of the operating system as a normal application program written in a <b>high-level</b> <b>language,</b> and the use of different operating systems on top of the same unchanged kernel. It is also possible to dynamically switch among operating systems and to have more than one active simultaneously.|$|E
25|$|The Unix {{operating}} system was conceived and implemented in 1969 at AT's Bell Laboratories in the United States by Ken Thompson, Dennis Ritchie, Douglas McIlroy, and Joe Ossanna. First released in 1971, Unix was written entirely in assembly language, as was common {{practice at the}} time. Later, in a key pioneering approach in 1973, it was rewritten in the C programming language by Dennis Ritchie (with the exception of some hardware and I/O routines). The availability of a <b>high-level</b> <b>language</b> implementation of Unix made its porting to different computer platforms easier.|$|E
50|$|The system API was {{presented}} to both <b>high-level</b> <b>languages</b> and assembly language.|$|R
50|$|Support of <b>high-level</b> <b>languages,</b> {{including}} Fortran, COBOL, Pascal, RPG II, and BASIC.|$|R
25|$|Some <b>high-level</b> <b>languages</b> (Eiffel, Esterel) {{optimize}} {{their programs}} {{by using an}} intermediate language.|$|R
25|$|At {{the lowest}} level, writing code using an {{assembly}} language, {{designed for a}} particular hardware platform can produce the most efficient and compact code if the programmer {{takes advantage of the}} full repertoire of machine instructions. Many operating systems used on embedded systems have been traditionally written in assembler code for this reason. Programs (other than very small programs) are seldom written from start to finish in assembly due to the time and cost involved. Most are compiled down from a high level language to assembly and hand optimized from there. When efficiency and size are less important large parts may be written in a <b>high-level</b> <b>language.</b>|$|E
25|$|OpenGL 2.0 was {{originally}} conceived by 3Dlabs to address concerns that OpenGL was stagnating and lacked a strong direction. 3Dlabs proposed {{a number of}} major additions to the standard. Most of these were, at the time, rejected by the ARB or otherwise never came to fruition in the form that 3Dlabs proposed. However, their proposal for a C-style shading language was eventually completed, resulting in the current formulation of the OpenGL Shading Language (GLSL or GLslang). Like the assembly-like shading languages it was replacing, it allowed replacing the fixed-function vertex and fragment pipe with shaders, though this time written in a C-like <b>high-level</b> <b>language.</b>|$|E
25|$|In 1961, Burroughs Corporation {{introduced}} the B5000 with the MCP, (Master Control Program) operating system. The B5000 was a stack machine designed to exclusively support high-level languages with no machine language or assembler, {{and indeed the}} MCP was the first OS to be written exclusively in a <b>high-level</b> <b>language</b> ESPOL, a dialect of ALGOL. MCP also introduced many other ground-breaking innovations, such as being the first commercial implementation of virtual memory. During development of the AS/400, IBM made an approach to Burroughs to license MCP to run on the AS/400 hardware. This proposal was declined by Burroughs management to protect its existing hardware production. MCP is still in use today in the Unisys ClearPath/MCP line of computers.|$|E
50|$|Here {{documents}} {{originate in}} the Unix shell, and are found in sh, csh, ksh, bash and zsh, among others. Here document-style string literals are found in various <b>high-level</b> <b>languages,</b> notably the Perl programming language (syntax inspired by Unix shell) and languages influenced by Perl, such as PHP and Ruby. Other <b>high-level</b> <b>languages</b> such as Python and Tcl have other facilities for multiline strings.|$|R
40|$|The paper {{presents}} a performance evaluation of commonly-used open-source software for manipulation and offline analysis of traffic traces. In traffic analysis, {{there is a}} tradeoff between either implementing ad-hoc, low-level software that is optimized for performance or using off-the-shelf open-source software written in <b>high-level</b> <b>languages</b> such as Python. Clearly, the former approach has a penalty in development time. While using <b>high-level</b> <b>languages</b> is easier in terms of development, the size of traffic traces is increasing {{and so is the}} processing time. We conclude that the use of <b>high-level</b> <b>languages</b> provides similar processing times in comparison with the low-level languages counterpart, provided that a pre-filtering of the traffic can be performed (by means of tcdump...|$|R
50|$|System calls: <b>High-level</b> <b>languages</b> {{rarely have}} a direct {{facility}} to make arbitrary system calls, so assembly code is used.|$|R
25|$|Sierra's initial games, labeled {{as part of}} the Hi-Res Adventure series, {{followed}} the same approach as Mystery House, using a first-person perspective graphical view along with text commands; Roberta would design each game's story and puzzles, while Ken would program it. In 1983, IBM contacted Sierra to develop a game for their new system, the PCjr, which featured more advanced graphics at the time as well as a more advanced sound system. Roberta designed a fairy-tale style adventure that would better visualized by the PCjr's graphics, and Ken developed software to allow animations include the player's character to occur on-screen in response to the player's typed commands. This was aided by the development of the Adventure Game Interpreter, a virtual machine that used a <b>high-level</b> <b>language</b> to control. This game became known as King's Quest I. It initially had poor sales due to its tie-in to the PCjr, but when IBM later abandoned the system, the Williamses were free to port the game to other systems, where it became highlight successful. Sierra began to expand, producing more games in the King's Quest series, which prompted thematic spinoffs in the Space Quest series by Mark Crowe and Scott Murphy, the Police Quest series by Jim Walls. The company would also produce other adventure games including the Leisure Suit Larry series by Al Lowe, Quest for Glory by Corey and Lori Ann Cole, and Gabriel Knight by Jane Jensen. As games featuring point-and-click interfaces began to become popular in the mid-1990s, Sierra also began to produce these types of games, including the forementioned Gabriel Knight series, Phantasmagoria, and Shivers.|$|E
500|$|Some other projects, such as Zephir, {{provide the}} ability for PHP {{extensions}} to be created in a <b>high-level</b> <b>language</b> and compiled into native PHP extensions. [...] Such an approach, instead of writing PHP extensions directly in C, simplifies the development of extensions and reduces the time required for programming and testing.|$|E
2500|$|Written in prose {{but much}} closer to the <b>high-level</b> <b>language</b> of a {{computer}} program, the following is the more formal coding of the algorithm in pseudocode or pidgin code: ...|$|E
5000|$|The {{increased}} use of <b>high-level</b> <b>languages</b> introduced a requirement for low-level programming languages or system programming languages. These languages, to varying degrees, provide facilities between assembly <b>languages</b> and <b>high-level</b> <b>languages</b> {{and can be used}} to perform tasks which require direct access to hardware facilities but still provide higher-level control structures and error-checking. The period from the 1960s to the late 1970s brought the development of the major language paradigms now in use: ...|$|R
25|$|Some compilers {{translate}} <b>high-level</b> <b>languages</b> into assembly {{first before}} fully compiling, allowing the assembly code {{to be viewed}} for debugging and optimization purposes.|$|R
30|$|Basic {{data types}} are the types usually found in {{imperative}} <b>high-level</b> <b>languages</b> [4]: characters, integers (signed and unsigned), {{floating point numbers}} and strings.|$|R
2500|$|... {{existing}} binaries {{that may}} or may not have originally been written in a <b>high-level</b> <b>language,</b> for example when trying to recreate programs for which source code is not available or has been lost, or cracking copy protection of proprietary software.|$|E
2500|$|Most early {{microcomputers}} {{relied on}} hand-coded assembly language, including most operating systems and large applications. This was because these systems had severe resource constraints, imposed idiosyncratic memory and display architectures, and provided limited, buggy system services. Perhaps more {{important was the}} lack of first-class <b>high-level</b> <b>language</b> compilers suitable for microcomputer use. A psychological factor may have also played a role: the first generation of microcomputer programmers retained a hobbyist, [...] "wires and pliers" [...] attitude.|$|E
2500|$|Current {{research}} is exploring {{the potential of}} modular reconfigurable robotics and the complex software necessary to control the “shape changing” robots. [...] “Locally Distributed Predicates or LDP is a distributed, <b>high-level</b> <b>language</b> for programming modular reconfigurable robot systems (MRRs)”. There are many challenges associated with programming and controlling {{a large number of}} discrete modular systems due to the degrees of freedom that correspond with each module. For example, reconfiguring from one formation to one similar may require a complex path of movements controlled by an intricate string of commands even though the two shapes differ slightly.|$|E
50|$|Some compilers {{translate}} <b>high-level</b> <b>languages</b> into assembly {{first before}} fully compiling, allowing the assembly code {{to be viewed}} for debugging and optimization purposes.|$|R
50|$|Like {{most other}} <b>high-level</b> <b>languages,</b> PEARL {{supports}} procedures and functions, and passing parameters to {{these can be}} done by value or by reference (via pointers).|$|R
40|$|Given {{the growing}} size and {{heterogeneity}} of Systems on Chip (SOC), {{the design process}} from initial specification to chip fabrication has become increasingly complex. This growing complexity provides incentive for designers to use <b>high-level</b> <b>languages</b> such as C, SystemC, and SystemVerilog for system-level design. While a major goal of these <b>high-level</b> <b>languages</b> is to enable verification {{at a higher level}} of abstraction, allowing early exploration of system-level designs, the focus so far for validation purposes has been on traditional testing techniques such as random testing and scenario-base...|$|R
2500|$|Adventure International is a {{development}} company founded by programmer Scott Adams alongside his wife Alexis. Adams {{was a fan}} of Colossal Cave Adventure, and had spent days to run through the game to achieve the highest score possible, [...] "Adventure Grandmaster". From this, he was inspired to write a similar game for the home computer system TRS-80, which lacked the memory capacity of the mainframes that Colossal Cave Adventure ran on. To get around this, he wrote a reusable <b>high-level</b> <b>language</b> and an interpreter written in BASIC. Adventure International was founded to sell the title, becoming the first commercially-sold adventure game. Adams' second title, Pirate Adventure, was an original game in a similar style to Colossal Cave Adventure, and its source code, written in BASIC, {{was published in the}} December 1980 issue of Byte. In his subsequent games, starting with Mission Impossible, Adams reworked his interpreter in assembly language that improved the speed of his software. Adventure International went on to produce a total of twelve adventure games before a downturn in the industry led to the company's bankruptcy in 1985. Several adventure game designers and writers cite Adams' games as an influence on their own creations.|$|E
2500|$|Macro {{assemblers}} often allow macros to take parameters. Some assemblers include quite sophisticated macro languages, incorporating such <b>high-level</b> <b>language</b> {{elements as}} optional parameters, symbolic variables, conditionals, string manipulation, and arithmetic operations, all usable during {{the execution of}} a given macro, and allowing macros to save context or exchange information. Thus a macro might generate numerous assembly language instructions or data definitions, based on the macro arguments. This {{could be used to}} generate record-style data structures or [...] "unrolled" [...] loops, for example, or could generate entire algorithms based on complex parameters. For instance, a [...] "sort" [...] macro could accept the specification of a complex sort key and generate code crafted for that specific key, not needing the run-time tests that would be required [...] for a general procedure interpreting the specification. An organization using assembly language that has been heavily extended using such a macro suite can be considered to be working in a higher-level language, since such programmers are not working with a computer's lowest-level conceptual elements. Underlining this point, macros were used to implement an early virtual machine in SNOBOL4 (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine, which was then targeted to physical machines by transpiled to a native assembler via a macro assembler. This allowed a high degree of portability for the time.|$|E
5000|$|Requirement for a {{convenient}} <b>high-level</b> <b>language</b> and a translator {{for such a}} <b>high-level</b> <b>language</b> to the corresponding machine code ...|$|E
50|$|High-level {{assemblers}} {{also provide}} data abstractions normally found in <b>high-level</b> <b>languages.</b> Examples include structures, unions, classes, and sets. Some high-level assemblers (e.g., TASM and HLA) support object-oriented programming.|$|R
5000|$|The next advance was the {{development}} of procedural languages. These third-generation languages (the first described as <b>high-level</b> <b>languages)</b> use vocabulary related to the problem being solved. For example, ...|$|R
5000|$|... "High-level language" [...] {{refers to}} the higher level of {{abstraction}} from machine language. Rather than dealing with registers, memory addresses and call stacks, <b>high-level</b> <b>languages</b> deal with variables, arrays, objects, complex arithmetic or boolean expressions, subroutines and functions, loops, threads, locks, and other abstract computer science concepts, {{with a focus on}} usability over optimal program efficiency. Unlike low-level assembly <b>languages,</b> <b>high-level</b> <b>languages</b> have few, if any, language elements that translate directly into a machine's native opcodes. Other features, such as string handling routines, object-oriented language features, and file input/output, may also be present.|$|R
