121|318|Public
50|$|Termination {{check is}} very {{important}} in dependently typed programming language and theorem proving systems like Coq and Agda. These systems use Curry-Howard isomorphism between programs and proofs. Proofs over inductively defined data types were traditionally described using <b>induction</b> <b>principles.</b> However, it was found later that describing a program via a recursively defined function with pattern matching is a more natural way of proving than using <b>induction</b> <b>principles</b> directly. Unfortunately, allowing non-terminating definitions leads to logical inconsistency in type theories. That's why Agda and Coq have termination checkers built-in.|$|E
50|$|Originally {{pioneered by}} Nikola Tesla in the 1890s, {{wireless}} power transfer systems, largely based on Michael Faraday's electromagnetic <b>induction</b> <b>principles</b> of 1831, have seen many applications, from electronic toothbrushes to HP's smartphones based on webOS.|$|E
50|$|In {{core type}} theory, {{induction}} and recursion principles {{are used to}} prove theorems about inductive types. In Agda, dependently typed pattern matching is used instead. For example, natural number addition can be defined like this: add zero n = n add (suc n) m = suc (add n m)This way of writing recursive functions/inductive proofs is more natural than applying raw <b>induction</b> <b>principles.</b> In Agda, dependently typed pattern matching is a primitive of the language; the core language lacks the induction/recursion principles that pattern matching translates to.|$|E
40|$|AbstractThe equational {{properties}} of the iteration operation in Lawvere theories are captured by the notion of iteration theories axiomatized by the Conway identities together with a complicated equation scheme, the “commutative identity”. The first result of the paper shows that the commutative identity is implied by the Conway identities and the Scott <b>induction</b> <b>principle</b> formulated to involve only equations. Since the Scott <b>induction</b> <b>principle</b> holds in free iteration theories, we obtain a relatively simple first order axiomatization of the equational {{properties of}} iteration theories. We show, {{by means of an}} example that a simplified version of the Scott <b>induction</b> <b>principle</b> does not suffice for this purpose: There exists a Conway theory satisfying the scalar Scott <b>induction</b> <b>principle</b> which is not an iteration theory. A second example shows that there exists an iteration theory satisfying the scalar version of the Scott <b>induction</b> <b>principle</b> in which the general form fails. Finally, an example is included to verify the expected fact that there exists an iteration theory violating the scalar Scott <b>induction</b> <b>principle.</b> Interestingly, two of these examples are ordered theories in which the iteration operation is defined via least pre-fixed points...|$|R
30|$|The {{following}} theorem is {{the main}} result of [21]. The proof uses the above two lemmas and the <b>induction</b> <b>principle.</b>|$|R
50|$|The main related {{concepts}} are initial F-algebras which {{may serve to}} encapsulate the <b>induction</b> <b>principle,</b> and the dual construction F-coalgebras.|$|R
40|$|Reasoning by {{induction}} is {{common practice in}} computer science and mathematics. In formal logic, however, standard <b>induction</b> <b>principles</b> exist only for a certain class of inductively defined structures that satisfy the positivity condition. This is a major restriction considering that many structures in programming languages and logics are best expressed using higher-order representation techniques that violate exactly this condition. In this paper we develop <b>induction</b> <b>principles</b> for higherorder encodings {{in the setting of}} first-order intuitionistic logic. They differ from standard <b>induction</b> <b>principles</b> in that they rely on the concept of worlds [Sch 01] which admits reasoning about open terms in regularly formed contexts. The soundness of these <b>induction</b> <b>principles</b> follows from external termination and coverage considerations about a realizability interpretation of proofs...|$|E
40|$|AbstractRecursion {{is one of}} {{the main}} tools in denotational semantics. This paper deals with the problem of {{establishing}} <b>induction</b> <b>principles</b> for domains defined by simultaneous recursion. We are particularly interested in <b>induction</b> <b>principles</b> supporting verification of properties of elements from (any) one of the domains defined by the simultaneous recursion. We offer two such principles, with the second principle being especially well-suited for implementation in a machine system such as LCF [5]...|$|E
40|$|In this paper, we {{deal with}} various <b>induction</b> <b>principles</b> {{incorporated}} in an underlying tableau calculus with equality. The induction formulae are restricted to literals. Induction is formalized as modified closure conditions which are triggered by applications of the ffi-rule. Examples dealing with (weak forms of) arithmetic and strings illustrate the simplicity and usability of our induction handling. We prove the correctness of the closure conditions and discuss possibilities to strengthen the <b>induction</b> <b>principles.</b> 1 Introduction The use of <b>induction</b> <b>principles</b> in various forms certainly is an important and prominent topic in Automated Deduction, as witnessed, e. g., by [15, 6, 1] and quite recently in [17]. The complexity of the problem [...] - both, in terms of proof search and formulation of appropriate deduction mechanisms [...] - is well known. Our aim is to demonstrate that various forms of induction {{can be incorporated into}} classical free variable tableaux in an elegant way. We were [...] ...|$|E
40|$|We revisit {{both the}} usual ``going-up'' <b>induction</b> <b>principle</b> and Manna and Waldinger's ``going-down'' <b>induction</b> <b>principle</b> for {{primitive}} recursion,`a la Goedel, and primitive iteration, `a la Church. We use 'Kleene's trick' {{to show that}} primitive recursion and primitive iteration are as expressive as the other, even {{in the presence of}} accumulators. As a result, we can directly extract a variety of recursive and iterative functional programs of the kind usually written or optimized by hand...|$|R
3000|$|... [...]. The {{first part}} of the {{assertion}} now follows by the <b>induction</b> <b>principle.</b> The second part is a consequence of [...]...|$|R
5000|$|By {{applying}} the <b>induction</b> <b>principle</b> {{for the standard}} integers N and the transfer principle we get the principle of internal induction: ...|$|R
40|$|In {{this paper}} we {{describe}} the extraction of "e#cient" recursion schemes from proofs of well-founded <b>induction</b> <b>principles.</b> This {{is part of a}} larger methodology; when these well-founded <b>induction</b> <b>principles</b> are used in proofs, the structure of the program extracted from the proof is determined by the recursion scheme inhabiting the induction principle. Our development is based on Paulson's paper Constructing recursion operators in intuitionistic type theory, but we specifically address two possibilities raised in the conclusion of his paper: the elimination of non-computational content from the recursion schemes themselves and, the use of the Y combinator to allow the recursion schemes to be extracted directly from the proofs of well-founded relations...|$|E
40|$|This paper {{describes}} {{the process of}} mechanically certifying a compiler {{with respect to the}} semantic specification of the source and target languages. The proofs are performed in type theory using the Coq system. These proofs introduce specific theoretical tools: fragmentation theorems and general <b>induction</b> <b>principles...</b>|$|E
40|$|We {{investigate}} how formal logic can {{be introduced to}} students {{who are familiar with}} functional programming in a way that takes advantage of their familiarity with higher order functions, free data-types, homomorphisms, and <b>induction</b> <b>principles.</b> In our experience, students often struggle with formal logic because they are unclea...|$|E
40|$|AbstractThe (in) equational {{properties}} of iteration, i. e., least (pre-) fixed point solutions over cpo's, are {{captured by the}} axioms of iteration theories. All known axiomatizations of iteration theories consist of the Conway identities and a complicated equation scheme, the commutative identity. The results of this paper show that the commutative identity is implied by the Conway identities and a weak form of the Park <b>induction</b> <b>principle.</b> Hence, we obtain a simple first order axiomatization of the (in) equational theory of iteration. It follows that a few simple identities and a weak form of the Scott <b>induction</b> <b>principle,</b> formulated to involve only inequations, are also complete. We also show that the Conway identities and the Park <b>induction</b> <b>principle</b> are not complete for the universal Horn theory of iteration...|$|R
3000|$|... but an {{existence}} {{assumption of}} barrier strips. Our proof {{is based upon}} the well-known Leray-Schauder <b>principle</b> and the <b>induction</b> <b>principle</b> on time scales.|$|R
40|$|We prove a {{compactness}} theorem in {{the context}} of Hennessy-Milner logic and use it to derive a sufficient condition on modal characterisations for the approximation <b>induction</b> <b>principle</b> to be sound modulo the corresponding process equivalence. We show that this condition is necessary when the equivalence in question is compositional with respect to the projection operators. Furthermore, we derive different upper bounds for the constructive version of the approximation <b>induction</b> <b>principle</b> with respect to simulation and decorated trace semantics. © 2012 Cambridge University Press...|$|R
40|$|Abstract. We present BiCoq 3, a deep {{embedding}} of the B {{system in}} Coq, {{focusing on the}} technical aspects of the development. The main subjects discussed are related to the representation of sets and maps, the use of <b>induction</b> <b>principles,</b> and the introduction of a new de Bruijn notation providing solutions to various problems related to the mechanisation of languages and logics...|$|E
40|$|It is {{critical}} to have an induction method for reasoning about recursive programs expressed as fixed points, for otherwise our reasoning ability is severely impaired. The fixed point induction rule developed by deBakker and Scott is one such well known principle. Here we propose a new induction method, computational induction, which is an induction on the computation process. Computational induction is founded on different principles than the fixed point induction principle [...] -it can only be defined in deterministic settings, and it cannot be modeled denotationally. Fixed point induction and computational induction prove {{many of the same}} facts; the relation between the two is examined in detail. 1 Introduction In a theory for reasoning about programs, in particular recursive functions defined via fixed points, there must exist <b>induction</b> <b>principles</b> if interesting results are to be proven. A number of different <b>induction</b> <b>principles</b> have been developed; for a review, see [Man 74]. Author' [...] ...|$|E
40|$|User defined {{recursive}} {{types are}} a fundamental feature of modern functional programming languages like Haskell, Clean, and the ML family of languages. Properties of programs defined by recursion {{on the structure}} of recursive types are generally proved by structural induction on the type. It is well known in the theorem proving community how to generate structural <b>induction</b> <b>principles</b> from data type declarations. These methods deserve to be better know in the functional programming community. Existing functional programming textbooks gloss over this material. And yet, if functional programmers {{do not know how to}} write down the structural induction principle for a new type - how are they supposed to reason about it? In this paper we describe an algorithm to generate structural <b>induction</b> <b>principles</b> from data type declarations. We also discuss how these methods are taught in the functional programming course at the University of Wyoming. A Haskell implementation of the algorithm is included in an appendix. Comment: In Proceedings TFPIE 2013, arXiv: 1312. 221...|$|E
40|$|The {{research}} on detection device design of Cu contaminated water using <b>induction</b> <b>principle</b> has been done. The {{purpose of this}} research is to create a detection device of Cu contaminated water using <b>induction</b> <b>principle,</b> characterize the precision of core sensor on detection device, characterize the stability of detection device, and implement the detection device to Cu contaminated water. This research was conducted in four phases: manufacturing of detection device, characterization of core sensor precision, characterization of detection devices stability, and implementation of detection device to Cu contaminated water. The results showed that the detection device of Cu contaminated water using <b>induction</b> <b>principle</b> has been successfully made. The precision of core sensor was 99. 96 %, while the stability of detection device was the 60 th second after turn-on. The success rate of detection device implementation on Cu contaminated water was 100. 00 %...|$|R
500|$|Thus, by {{the strong}} <b>induction</b> <b>principle,</b> for every , [...] Thus, , which contradicts X being a nonempty subset of N. Thus X has a least element.|$|R
40|$|In [11], an <b>induction</b> <b>principle</b> for {{processes}} {{was given}} which {{allows one to}} apply modelchecking techniques to parameterized families of processes. A limitation of the <b>induction</b> <b>principle</b> {{is that it does}} not apply to the case in which one process depends directly upon a parameterized number of processes, which grows without bound. This would seem to preclude its application to families of N processes interconnected in a star topology. Nonetheless, we show that if the dependency can be computed incrementally, then the direct dependency upon the parameterized number of processes may be re-expressed recursively in terms of a linear cascade of processes, yielding in effect a "linearization" of the inter-process dependencies and allowing the <b>induction</b> <b>principle</b> to apply. Keywords: Automatic verification, distributed algorithms, induction, invariant, linearization, model checking, star topology. 1. Introduction Distributed multi-processor systems often are specified as consisting of a fini [...] ...|$|R
40|$|We present Bicoq 3, a deep {{embedding}} of the B {{system in}} Coq, {{focusing on the}} technical aspects of the development. The main subjects discussed are related to the representation of sets and maps, the use of <b>induction</b> <b>principles,</b> and the introduction of a new de Bruijn notation providing solutions to various problems related to the mechanisation of languages and logics. Comment: 16 page...|$|E
30|$|SVM can be {{used for}} classification, {{regression}} and other tasks. Applying the SVM to solve regression problems is called the support vector regression (SVR) method (Basak et al. 2007). The SVR tries to find an optimal hyper-plane as a decision function in high-dimensional space. SVR is different from conventional regression techniques, since it uses structural risk minimization (SRM), instead of empirical risk minimization (ERM) <b>induction</b> <b>principles</b> (Boser et al. 1992; Cristianini and Taylor 2000).|$|E
40|$|In {{this article}} we {{introduce}} the Suslin quantification functional E 1 into the framework of Feferman’s explicit mathematics and analyze it {{from the point of}} view of proof theory. More precisely, we work in the first order part of explicit mathematics augmented by appropriate axioms for E 1. Then we establish the exact proof-theoretic relationship between these applicative theories and (subsystems of) the second order theory (∆ 1 2 -CA), depending on the <b>induction</b> <b>principles</b> permitted. ...|$|E
50|$|If N were an {{internal}} set, then instantiating the internal <b>induction</b> <b>principle</b> with N, it would follow N = *N {{which is known}} {{not to be the}} case.|$|R
40|$|We {{propose a}} uniform, category-theoretic account of {{structural}} induction for inductively defined data types. The account {{is based on}} the understanding of inductively defined data types as initial algebras for certain kind of endofunctors T : B !B on a bicartesian/distributive category B. Regarding a predicate logic as a fibration p : P!B over B, we consider a logical predicate lifting of T to the total category P. Then, a predicate is inductive precisely when it carries an algebra structure for such lifted endofunctor. The validity of the <b>induction</b> <b>principle</b> is formulated by requiring that the `truth' predicate functor ? : B !Ppreserve initial algebras. We then show that when the fibration admits a comprehension principle, analogous to the one in set theory, it satisfies the <b>induction</b> <b>principle.</b> We also consider the appropriate extensions of the above formulation to deal with initiality (and induction) in arbitrary contexts, i. e. the `stability' property of the <b>induction</b> <b>principle.</b> 1 [...] ...|$|R
5000|$|... whereupon the <b>induction</b> <b>principle</b> [...] "automates" [...] log log n {{applications}} of this inference in getting from P(0) to P(n). This form of induction has been used, analogously, to study log-time parallel computation.|$|R
40|$|Nonuniform (or “nested” or “heterogeneous”) datatypes are recursively defined {{types in}} which the type {{arguments}} vary recursively. They arise {{in the implementation of}} finger trees and other efficient functional data structures. We show how to reduce a large class of nonuniform datatypes and codatatypes to uniform types in higher-order logic. We programmed this reduction in the Isabelle/HOL proof assistant, thereby enriching its specification language. Moreover, we derive (co) recusion and (co) <b>induction</b> <b>principles</b> based on a weak variant of parametricity...|$|E
40|$|Abstract. Isabelle/HOL has {{recently}} been enriched with a definitional package for datatypes and codatatypes. The package introduces the specified types and derives auxiliary constants and characteristic theorems, notably (co) recursors and (co) <b>induction</b> <b>principles.</b> We now introduce support for high-level specifications of (co) recursive functions, {{in the form of}} three commands: primrec, primcorec, and primcorecursive. The commands internally reduce the specifications to argu-ments to the (co) recursors and generate a number of theorems about the function definition, automating a tedious process. ...|$|E
40|$|Using {{standard}} domain-theoretic fixed-points, {{we present}} an approach for defining recursive functions that are formulated in monadic style. The method works {{both in the}} simple option monad and the state-exception monad of Isabelle/HOL’s imperative programming extension, which results in a convenient definition principle for imperative programs, which were previously hard to define. For such monadic functions, the recursion equation can always be derived without preconditions, even if the function is partial. The construction is easy to automate, and convenient <b>induction</b> <b>principles</b> can be derived automatically. ...|$|E
50|$|Thus, by {{the strong}} <b>induction</b> <b>principle,</b> for every n ∈ N, n ∉ X. Thus, X ∩ N = ∅, which contradicts X being a nonempty subset of N. Thus X has a least element.|$|R
40|$|Abstract. We {{develop an}} {{algebraic}} theory of threads, synchronous co-operation of threads and interaction of threads with Maurer machines, and investigate program parallelization using the resulting theory. Pro-gram parallelization underlies techniques for speeding up instruction pro-cessing {{on a computer}} that {{make use of the}} abilities of the computer to process instructions simultaneously in cases where the state changes in-volved do no in uence each other. One of our ndings is that a strong <b>induction</b> <b>principle</b> is needed when proving theorems about sucient conditions for the correctness of program parallelizations. The <b>induction</b> <b>principle</b> introduced has brought us to construct a projective limit model for the theory developed...|$|R
30|$|We have {{obtained}} the global solution of a non-classical heat conduction {{problem in a}} semi-n-dimensional space. Moreover, for the one-dimensional case, we {{have obtained}} the explicit solution by using the Adomian method with a double <b>induction</b> <b>principle.</b>|$|R
