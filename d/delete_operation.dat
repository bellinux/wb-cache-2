57|262|Public
25|$|In {{the worst}} case, the new root {{has to be}} swapped with its child on each level until it reaches the bottom level of the heap, meaning that the <b>delete</b> <b>operation</b> has a time {{complexity}} relative to {{the height of the}} tree, or O(log n).|$|E
25|$|When moving or copying files, Windows Explorer {{displays}} the full source and destination path, size {{and number of}} items and the transfer speed in megabytes per second (MB/s). If a conflict or error is encountered, it does not terminate the copy, move or <b>delete</b> <b>operation.</b> Rather, the file is skipped {{and the rest of}} the files processed. At the end of the operation, the errors are presented to the user with resolution options (if available). If two files have the same name, an option is available to rename the file; in previous versions of Windows, the only options were to either replace the destination file or cancel the process. The user can also choose to apply the same action to further conflicts, if any. Also, for the first time in Windows, processing of dates when moving trees is somewhat consistent. Until now, every folder and subfolder obtained all three dates new to the time of operation. This was from the own nature of the operation at the file system level, create destination folders, move files, delete origin folders. Moved folders in Vista preserve creation and modification dates. Access date gets the time of the operation.|$|E
50|$|The skip graph {{contains}} {{an average of}} O(log n) levels; at each level u must send 2 messages to complete a <b>delete</b> <b>operation</b> on a doubly linked list. As operations on each level may be done in parallel the <b>delete</b> <b>operation</b> may be finished using O(1) time and expected O(log n) messages.|$|E
5000|$|The R*-tree {{uses the}} same {{algorithm}} as the regular R-tree for query and <b>delete</b> <b>operations.</b>|$|R
50|$|In 1993, Arne Andersson {{introduced}} {{the idea of}} right leaning tree to simplify insert and <b>delete</b> <b>operations.</b>|$|R
50|$|<b>Delete</b> (x) <b>operation</b> <b>deletes</b> element x from queue if it exists.|$|R
5000|$|... delete - The <b>delete</b> <b>operation</b> {{enables a}} {{requestor}} to remove an object from a target.|$|E
5000|$|Since {{we always}} rename the smaller sub-component, the amortized {{time for a}} <b>delete</b> <b>operation</b> is [...]|$|E
5000|$|Database {{transactions}} where {{a transaction}} atomically includes perhaps a write, a read and a matching <b>delete</b> <b>operation.</b>|$|E
5000|$|The Log Trigger works {{writing the}} changes (INSERT, UPDATE and <b>DELETE</b> <b>operations)</b> {{on the table}} in another, history table, defined as following: ...|$|R
5000|$|Only changes (INSERT, UPDATE and <b>DELETE</b> <b>operations)</b> are registered, so {{the growing}} {{rate of the}} history tables are {{proportional}} to the changes.|$|R
30|$|Insert and <b>delete</b> <b>operations</b> are {{commutative}} operations encoding a {{key that}} uniquely identifies a set element, typically {{derived from the}} element via a hash function.|$|R
5000|$|A 2-4 tree is {{used when}} a <b>delete</b> <b>operation</b> occurs. If the item x {{is already in}} tree T, the item is removed using the 2-4 tree <b>delete</b> <b>operation.</b> Otherwise, the item x is in list L (done by {{checking}} if the bit variable is set). All the elements stored in list L are then added to the 2-4 tree, setting the bit variable of each element to zero. x is then removed from T.|$|E
5000|$|... use {{an extra}} 'back_link' field so the <b>delete</b> <b>operation</b> can {{traverse}} {{back to a}} node {{that has not been}} deleted from the list ...|$|E
5000|$|Several RDBMS (DB2, MySQL) do {{not support}} that the same trigger can be {{attached}} {{to more than one}} operation (INSERT, DELETE, UPDATE). In such a case a trigger must be created for each operation; For an INSERT operation only the inserting section must be specified, for a <b>DELETE</b> <b>operation</b> only the deleting section must be specified, and for an UPDATE operation both sections must be present, just as it is shown above (the deleting section first, then the inserting section), because an UPDATE operation is logically represented as a <b>DELETE</b> <b>operation</b> followed by an INSERT operation.|$|E
50|$|The Insert and <b>Delete</b> <b>operations</b> on the cutset {{structure}} {{are done}} {{in exactly the same}} way: the edge inserted/deleted is XORed into both its endpoints.|$|R
3000|$|... [DE]) {{are used}} to model the CRUD (Create, Read, Update and <b>Delete)</b> <b>operations</b> which are most {{commonly}} implemented in NoSQL systems such as Riak and MongoDB.|$|R
30|$|For {{seeking an}} (ε,η)-optimal {{solution}} of problem (P), a division and cut algorithm {{to be developed}} includes three essential operations: division <b>operation,</b> <b>deleting</b> <b>operation,</b> and reduction operation.|$|R
5000|$|Workloads {{which are}} {{executed}} on the generated data. A workload {{is a set}} of transactions. A transaction can be a query in XQuery or SQL/XML notation or an insert, update or <b>delete</b> <b>operation.</b>|$|E
50|$|Related objects can be {{configured}} {{to cascade}} operations {{from one to}} the other. For example, a parent Album object can be configured to cascade its save and/or <b>delete</b> <b>operation</b> to its child Track objects.|$|E
50|$|The Query and Insert {{operations}} {{use only}} the largest forest FL. The smaller subgraphs are consulted only during a <b>Delete</b> <b>operation,</b> and in particular, deleting an edge which {{is contained in}} one of the spanning trees of FL.|$|E
40|$|This paper {{contains}} {{a brief description}} of the most important operations that can be performed on spatial data such as spatial queries, create, update, insert, <b>delete</b> <b>operations,</b> conversions, operations on the map or analysis on grid cells. Each operation has a graphical example and some of them have code examples in Oracle and PostgreSQL...|$|R
5000|$|Each edge in {{the graph}} is {{assigned}} a level. Let L=lg n. The level of each edge inserted to the graph is initialized to L, and may decrease towards 0 during <b>delete</b> <b>operations.</b>|$|R
5000|$|All items have {{a unique}} URI that gets exposed via HTTP. It uses the HTTP methods POST, GET, PUT and DELETE for the four basic CRUD (Create, Read, Update, <b>Delete)</b> <b>operations</b> on all resources.|$|R
50|$|The insert {{operation}} is extended to increment {{the value of}} the buckets, and the lookup operation checks that each of the required buckets is non-zero. The <b>delete</b> <b>operation</b> then consists of decrementing the value of each of the respective buckets.|$|E
5000|$|It is {{necessary}} to test the nullity of the fields of the [...] record that define the primary key (when a <b>DELETE</b> <b>operation</b> is performed), {{in order to avoid}} the insertion of a new row with null values in all columns.|$|E
5000|$|If x is in tree T, {{then the}} amortized cost is not modified. The <b>delete</b> <b>operation</b> is O(1) amortized 2-4 tree. Since x {{was removed from}} the tree, [...] and [...] {{pointers}} may need updating. At most, there will be [...] updates.|$|E
40|$|Many {{applications}} {{require that}} {{large amounts of}} data are deleted from the database [...] typically, such bulk deletes are carried out periodically and involve old or out-of-date data. If the data is not partitioned {{in such a way}} that bulk deletes can be carried out by simply deleting whole partitions, then most current database products execute such bulk <b>delete</b> <b>operations</b> very poorly. The reason is that every record is deleted from each index individually. This paper proposes and evaluates a new class of techniques to support bulk <b>delete</b> <b>operations</b> more efficiently. These techniques outperform the "record-at-a-time" approach implemented in many database products by about one order of magnitude...|$|R
40|$|We present {{three models}} for a data-oriented {{coordination}} language and show several {{relationships between the}} models. We consider a distributed model and two centralized shared dataspace models, one preserving {{the order in which}} data is produced and a second one not necessarily preserving this order. For example, we show that if dataspaces are multisets then the distributed and the centralized systems are observationally equivalent for any program using read, write and <b>delete</b> <b>operations.</b> The same result does not hold if dataspaces are sets or databases. 1 Introduction Coordination languages consist of a number of primitives that can be added to programming languages such that a number of programs, running in parallel, can coordinate their activities. Usually coordination is achieved using a number of primitives like read, write, <b>delete</b> and test <b>operations</b> that work on shared data. Synchronization and communication happen through these primitives. Read and <b>delete</b> <b>operations</b> are potenti [...] ...|$|R
50|$|EMCO MoveOnBoot allows {{selecting}} one {{or multiple}} file system resources and scheduling move, rename or <b>delete</b> <b>operations</b> {{to be performed}} with these resources on the next reboot. It is possible to schedule multiple actions, as well as review and cancel the already scheduled actions.|$|R
5000|$|MTP allows no parallelism, unlike USB {{mass storage}} or NAS. MTP {{has been built}} to only allow a single {{operation}} at a time (for example, read, write or <b>delete</b> <b>operation),</b> while no other operation can be executed until the previous operation is complete.|$|E
50|$|In {{the worst}} case, the new root {{has to be}} swapped with its child on each level until it reaches the bottom level of the heap, meaning that the <b>delete</b> <b>operation</b> has a time {{complexity}} relative to {{the height of the}} tree, or O(log n).|$|E
5000|$|If {{the bit of}} {{the element}} x is set to zero, x is a leaf of T. Delete x using the 2-4 tree <b>delete</b> <b>operation.</b> Starting from node x, walk in T to node , {{updating}} [...] and [...] pointers. Decrement n and k by 1.|$|E
40|$|Hyper-{{heuristics}} are (meta-) heuristics {{that operate}} {{at a higher}} level to choose or generate a set of low-level (meta-) heuristics in an attempt of solve difficult optimization problems. Iterated local search (ILS) is a well-known approach for discrete optimization, combining perturbation and hill-climbing within an iterative framework. In this study, we introduce an ILS approach, strengthened by a hyper-heuristic which generates heuristics based on a fixed number of add and <b>delete</b> <b>operations.</b> The performance of the proposed hyper-heuristic is tested across two different problem domains using real world benchmark of course timetabling instances from the second International Timetabling Competition Tracks 2 and 3. The results show that mixing add and <b>delete</b> <b>operations</b> within an ILS framework yields an effective hyper-heuristic approach...|$|R
50|$|If {{the table}} size {{increases}} or decreases by a fixed percentage at each expansion, {{the total cost}} of these resizings, amortized over all insert and <b>delete</b> <b>operations,</b> is still a constant, independent of the number of entries n and of the number m of operations performed.|$|R
50|$|Windows {{implements}} TRIM command {{for more}} than just file <b>delete</b> <b>operations.</b> The TRIM operation is fully integrated with partition- and volume-level commands like format and delete, with file system commands relating to truncate and compression, and with the System Restore (also known as Volume Snapshot) feature.|$|R
