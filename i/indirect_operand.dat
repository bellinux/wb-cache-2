1|6|Public
5000|$|Addressing modes include Immediate (operand in instruction), Direct or [...] "Symbolic" [...] (operand {{address in}} instruction), Register (operand in {{workspace}} register), Register <b>Indirect</b> (<b>operand</b> address in workspace register) {{with or without}} auto-increment, Indexed (operand address in instruction indexed with workspace register content), and Program Counter Relative.|$|E
50|$|The {{instruction}} set consists of single and double word instructions.Operands can be immediate, direct or <b>indirect.</b> Immediate <b>operands</b> areencoded {{directly in the}} instruction as a literal value. Direct operandsare encoded as {{the address of the}} <b>operand.</b> <b>Indirect</b> <b>operands</b> encode theaddress of the word containing a pointer to the operand.|$|R
2500|$|Counter machine: no <b>indirect</b> addressing, {{immediate}} <b>operands</b> {{possible in}} highly atomized models ...|$|R
40|$|Abstract. This paper {{addresses}} {{the problem of}} recovering variable-like entities when analyzing executables {{in the absence of}} debugging information. We show that variable-like entities can be recovered by iterating Value-Set Analysis (VSA), a combined numeric-analysis and pointer-analysis algorithm, and Aggregate Structure Identification, an algorithm to identify the structure of aggregates. Our initial experiments show that the technique is successful in correctly identifying 88 % of the local variables and 89 % of the fields of heap-allocated objects. Previous techniques recovered 83 % of the local variables, but 0 % of the fields of heap-allocated objects. Moreover, the values computed by VSA using the variables recovered by our algorithm would allow any subsequent analysis {{to do a better job}} of interpreting instructions that use indirect addressing to access arrays and heap-allocated data objects: <b>indirect</b> <b>operands</b> can be resolved better at 4 % to 39 % of the sites of writes and up to 8 % of the sites of reads. (These are the memory-access operations for which it is the most difficult for an analyzer to obtain useful results.) ...|$|R
50|$|The OPD Mini Processor was an IBM single-chip FET {{microprocessor}} {{designed by}} Richard Vrba {{and used in}} the OS/6 word processors during the 1970s. It had a 16-bit little-endian instruction set built on an 8-bit internal architecture. Sixteen general purpose registers, implemented as a 32-byte window in memory that operated as a stack, {{could be used as}} instruction <b>operands</b> or for <b>indirect</b> references to <b>operands</b> in memory.|$|R
50|$|There was no {{expansion}} of the register set but the registers and instructions were significantly orthogonalized {{in order to make}} them more general purpose and powerful. Many new 8-bit and 16-bit operations were added, and the HL, IX, and IY registers were upgraded from their rather limited possibilities as accumulators in the Z80 to more versatile accumulators. In addition to the register operands possible in the Z80, they could be used with immediate data, direct address, register <b>indirect,</b> or indexed <b>operands,</b> even program counter-relative. Eight-bit operations had even more possibilities, including stack pointer-relative addressing and a choice of 8-bit or 16-bits immediate offsets.|$|R

