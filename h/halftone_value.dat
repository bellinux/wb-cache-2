5|3|Public
40|$|Abstract â€” A Parallel {{algorithm}} and its hardware {{implementation of}} Inverse Halftone operation is proposed in this paper. The algorithm {{is based on}} Lookup Tables from which the inverse <b>halftone</b> <b>value</b> of a pixel is directly determined using a pattern of pixels. A method has been developed that allows accessing more than one value from the lookup table at any time. The lookup table is divided into smaller lookup tables, such that each pattern selected at any time goes to a separate smaller lookup table. The 15 -pixel parallel version of the algorithm was tested on sample images and a simple and effective method {{has been used to}} overcome quality degradation due to pixel loss in the proposed algorithm. It can provide at least 4 times decrease in lookup table size when compared with serial lookup table method implemented multiple times for same number of pixels. I...|$|E
40|$|Lookup table (LUT) {{method for}} inverse halftoning is {{computation}} less, fast and also yields goods results. This paper introduces {{a method to}} parallelize the LUT method of inverse halftoning. This is accomplished by dividing the single Look-Up Table of LUT method for inverse halftoning into many smaller Look-up Tables (sLUTs). In the parallelized method for LUT inverse halftoning up-to four pixels can be fetched from the halftone image in parallel and go to their separate smaller Look-Up Tables (sLUT) from where each template fetches its inverse <b>halftone</b> <b>value</b> independent to other templates. The parallelization can increase the speed of inverse halftoning by up-to 4 times while the total entries in all smaller Look-Up Tables (sLUTs) remains equal to the entries in the single LUT of LUT method for inverse halftoning. Some degradation in image quality is noticed due to parallelization. The complete implementation of the method takes two CPLD devices with external content addressable memories (CAM) and static RAMs to store sLUTs. ...|$|E
40|$|Abstract Lookup Table (LUT) {{method for}} inverse halftoning is {{computation}} less, fast and also yields goods results. This paper proposes a parallel algorithm for inverse halftoning by parallelizing the LUT method of inverse halftoning. The LUT method for inverse halftoning is parallelized {{by dividing the}} single Look-Up Table of LUT method for inverse halftoning into many smaller Look-up Tables (sLUTs). In the parallel algorithm up-to four pixels can be fetched from the halftone image concurrently and go to their separate smaller Look-Up Tables (sLUT) from where each template fetches its inverse <b>halftone</b> <b>value</b> independent to other pixels. The parallelization can increase the speed of inverse halftoning by up-to 4 times while the total entries in all smaller Look-Up Tables (sLUTs) remains equal to the entries in the single LUT of LUT method for inverse halftoning. Some degradation in image quality is noticed due to parallelization. The complete implementation of the method takes two CPLD devices with external content addressable memories (CAM) and static RAMs to store sLUTs. Keywords: (1) Inverse Halftoning (2) Hardware Implementation (3) Look-Up Table Inverse Halftoning (4) Complex Programmable Logic Devices (CPLD) (5) Image Processin...|$|E
40|$|In this paper, {{we propose}} a new {{technique}} for halftoning color images. Our technique parallels recent work in modell, etscd halftoning fm both monochrome and color image, we iucorpurat, c t hunion visual model t, liat account, for {{the difference in the}} responses of the hnman viewer to lnminance and chrominance information. Thus, the RGB color space must be transformed to a hlminartce/chrominance based color space. The color transformation we use is a linearization of/. he uniIbrm color space L*a'/' which alo alecouples change between the lnminance and chrominance colnponents. After deriving a tractable expression for total-squared perceived error, we then apply the method of Iterated Conditional Modes (ICM) to iteratively toggle <b>halftone</b> <b>values</b> and exploit several degrees of freedom in reducing the perceived error as predicted by the model...|$|R
40|$|Halftones, or {{periodic}} cluster dithers, are point-to-point, contone pixel to halftone dot, conversion processes. This paper {{describes an}} approach to achieving accurate halftone reproduction by using the errors caused during the scan conversion process without comparison to the source pixels and maintaining the point-to-point scan conversion paradigm. Two types of density errors encounter in the halftoning process are considered. 1. An error describing {{the difference between the}} input pixel <b>value</b> and the <b>halftone</b> threshold <b>value.</b> 2. An error describing the difference between the density level of the output data and the reflection density of the ink or toner on the page...|$|R
30|$|Flicker and DWE are related. Reducing one {{artifact}} {{could result}} in an increase of the other. If <b>halftone</b> pixels toggle <b>values</b> between <b>halftone</b> frames within a spatial area that does not change much between continuous-tone frames, flicker might be observed at medium frame rates. If they do not toggle in spatial areas that change between successive frames or exhibit motion, DWE might be observed. To minimize both artifacts, a halftoning algorithm should produce halftone frames that have their pixels toggle values only in spatial regions that have a perceptual change (due to motion, e.g.) between the corresponding successive continuous-tone frames. Certain halftoning algorithms produce videos that have high DWE but low flicker. An example is a binary halftone video produced by using ordered-dither technique on each grayscale continuous-tone frame independently. Similarly, there are halftoning algorithms that produce videos with high flicker but low DWE. An example is a binary halftone video produced by halftoning each grayscale continuous-tone frame independently using Floyd and Steinberg [14] error diffusion algorithm.|$|R

