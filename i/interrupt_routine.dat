38|197|Public
25|$|The memory {{manager and}} {{processes}} scheduler have been improved. The scheduler was modified {{to use the}} cycle counter register of modern processors {{to keep track of}} exactly how many CPU cycles a thread has executed, rather than just using an interval-timer <b>interrupt</b> <b>routine.</b> This new CPU cycle-based thread scheduling gives a greater fairness and more deterministic app behavior. Many kernel data structures and algorithms have been rewritten. Lookup algorithms now run in constant time, instead of linear time as with previous versions.|$|E
2500|$|Interrupt Chaining – {{supports}} {{the service of}} pending interrupts without the need to exit the initial <b>interrupt</b> <b>routine,</b> saving the cycles required to store and restore multiple active interrupts ...|$|E
2500|$|The 68000 is also {{unable to}} easily support virtual memory, which {{requires}} {{the ability to}} trap and recover from a failed memory access. The 68000 does provide a bus error exception {{which can be used}} to trap, but it does not save enough processor state to resume the faulted instruction once the operating system has handled the exception. Several companies did succeed in making 68000-based Unix workstations with virtual memory that worked by using two 68000 chips running in parallel on different phased clocks. When the [...] "leading" [...] 68000 encountered a bad memory access, extra hardware would interrupt the [...] "main" [...] 68000 to prevent it from also encountering the bad memory access. This <b>interrupt</b> <b>routine</b> would handle the virtual memory functions and restart the [...] "leading" [...] 68000 in the correct state to continue properly synchronized operation when the [...] "main" [...] 68000 returned from the interrupt.|$|E
5000|$|Instruction set: LSI-11 (/ included, FIS codes {{implemented}} by ROM <b>interrupt</b> <b>routines)</b> ...|$|R
50|$|OProfile can profile {{an entire}} system or its parts, from <b>interrupt</b> <b>routines</b> or drivers, to user-space processes. It has low overhead.|$|R
30|$|The {{software}} {{implementing the}} embedded system {{is made of}} four main parts: initialization, timing and <b>interrupt</b> <b>routines,</b> acquisition of sensor measurements and controller implementation. In the following subsections, these parts will be introduced.|$|R
5000|$|Set the Display List Interrupt address VDSLST ($0200hex/512dec) to the {{starting}} address of the <b>interrupt</b> <b>routine.</b>|$|E
5000|$|Trigger a CPU-serviced <b>interrupt</b> <b>routine,</b> {{called the}} [...] "Vertical Blank Interrupt", {{at the end}} of the display frame.|$|E
50|$|If {{multiple}} DLIs {{are used}} the first interrupt updates VDSLST {{to point to}} the address of the next interrupt, and so on for subsequent interrupts. The last Display List <b>Interrupt</b> <b>routine</b> on the screen points VDSLST back to the address of the first Display List Interrupt. Alternatively, a Vertical Blank <b>Interrupt</b> <b>routine</b> can be used to reset the VDSLST address to guarantee the DLIs remain in sync with the screen.|$|E
25|$|<b>Interrupt</b> <b>routines</b> {{called by}} Windows to inform MS-DOS that Windows is starting/exiting, {{information}} that MS-DOS retained in an IN_WINDOWS flag, {{in spite of}} the fact that MS-DOS and Windows were supposed to be two separate products.|$|R
50|$|The Rabbit {{processor}} {{family has}} unique features. For example, the Z80/Z180 family disables interrupts once an interrupt is serviced by an <b>interrupt</b> service <b>routine.</b> However, the Rabbit processors permit interrupts to <b>interrupt</b> service <b>routines</b> according to priorities (a total of 4).|$|R
5000|$|All INT_NUM between 0x0 and 0x1F, inclusive, are {{reserved}} for exceptions;INT_NUM bigger than 0x1F are used for <b>interrupt</b> <b>routines.</b> (Note that the IBM PC did not always obey this rule, for instance using interrupt 5 to indicate the Print Screen key was pressed.) ...|$|R
5000|$|The Operating System vector for the Display List Interrupt (VDSLST, $0200hex/512dec) {{points to}} the {{starting}} address of the <b>interrupt</b> <b>routine.</b>|$|E
5000|$|Interrupt Chaining - {{supports}} {{the service of}} pending interrupts without the need to exit the initial <b>interrupt</b> <b>routine,</b> saving the cycles required to store and restore multiple active interrupts ...|$|E
5000|$|Trigger a CPU-serviced <b>interrupt</b> <b>routine,</b> {{called the}} [...] "Display List Interrupt", at {{specific}} scan lines (also called [...] "raster interrupt" [...] or [...] "Horizontal Blank Interrupt" [...] on other systems) ...|$|E
5000|$|Graphics BASIC also {{supports}} automatic sprite movement (change in place), animation (change in shape), and collision detection. This is {{implemented in the}} language core itself by adding hooks into the Commodore 64's software <b>interrupt</b> <b>routines.</b> (The language does not support adding your own interrupt hooks.) ...|$|R
50|$|LynxOS {{components}} {{are designed for}} absolute determinism (hard real-time performance), {{which means that they}} respond within a known period of time. Predictable response times are ensured even in the presence of heavy I/O due to the kernel's unique threading model, which allows <b>interrupt</b> <b>routines</b> to be extremely short and fast.|$|R
50|$|In {{computer}} science, a {{vectored interrupt}} is a processing technique {{in which the}} interrupting device directs the processor to the appropriate <b>interrupt</b> service <b>routine.</b> This {{is in contrast to}} a polled interrupt system, in which a single <b>interrupt</b> service <b>routine</b> must determine the source of the interrupt by checking all potential interrupt sources, a slow and relatively laborious process.|$|R
50|$|If ANTIC {{register}} NMIEN ($D40Ehex/54286dec) has Bit7 ($80) set then on {{the last}} scanline of the Mode line an <b>interrupt</b> <b>routine</b> will be triggered which is vectored through address VDSLST ($200hex/512dec).|$|E
50|$|If {{multiple}} DLIs {{are used}} the first interrupt updates VDSLST {{to point to}} the address of the next interrupt, and so on for subsequent interrupts. The last Display List <b>Interrupt</b> <b>routine</b> on the screen points VDSLST back to the address of the first Display List Interrupt.|$|E
5000|$|This {{specific}} behavior permitted initial {{execution of}} an interrupt routines, since base registers {{would not necessarily}} be set to 0 {{during the first few}} instruction cycles of an <b>interrupt</b> <b>routine.</b> It isn't needed for IPL ("Initial Program Load" [...] or boot), as one can always clear a register without the need to save it.|$|E
5000|$|PSoC {{most closely}} resembles a {{microcontroller}} {{combined with a}} PLD and programmable analog. Code is executed {{to interact with the}} user-specified peripheral functions (called [...] "Components"), using automatically generated APIs and <b>interrupt</b> <b>routines.</b> PSoC Designer or PSoC Creator generate the startup configuration code. Both integrate APIs that initialize the user selected components upon the users needs in a Visual-Studio-like GUI.|$|R
5000|$|User {{programs}} can insert execution of custom code either before (Immediate) or after (Deferred) the Operating System's Vertical Blank <b>Interrupt</b> <b>routines.</b> Since the OS Vertical Blank interrupt {{could be called}} while a user program is updating the vectors, the Operating system provides a routine, SETVBV ($E45Chex/58460dec), that will safely update the VVBLKI or VVBLKD vectors to point to a new routine: ...|$|R
50|$|The design {{philosophy}} of the Propeller is that a hard real-time multi-core architecture negates the need for dedicated interrupt hardware and support in assembly. In traditional CPU architecture, external interrupt lines are fed to an on-chip interrupt controller and are serviced {{by one or more}} <b>interrupt</b> service <b>routines.</b> When an <b>interrupt</b> occurs, the interrupt controller suspends normal CPU processing and saves internal state (typically on the stack), then vectors to the designated <b>interrupt</b> service <b>routine.</b> After handling the <b>interrupt,</b> the service <b>routine</b> executes a return from interrupt instruction which restores the internal state and resumes CPU processing.|$|R
50|$|Once a UART, and a timer if necessary, {{has been}} configured, the {{programmer}} needs only write a simple <b>interrupt</b> <b>routine</b> to refill the send shift register whenever {{the last bit}} is shifted out by the UART and/or empty the full receive shift register (copy the data somewhere else). The main program then performs serial reads and writes simply by reading and writing 8-bit data to stacks.|$|E
5000|$|... 32 single-color sprites in defined layers {{allowing}} higher-numbered sprites to transparently flow over lower-numbered sprites. Sprites {{are available}} at 8×8 pixels or 16×16 pixels, with a 'magnify' bit that doubled all sprites' size but not their resolution. A single bit is available in hardware for coincidence (collision detection), and the console supports automatic movement via an <b>interrupt</b> <b>routine</b> in the ROM. There can {{be no more than}} 4 visible sprites per horizontal scanline.|$|E
5000|$|The memory {{manager and}} {{processes}} scheduler have been improved. The scheduler was modified {{to use the}} cycle counter register of modern processors {{to keep track of}} exactly how many CPU cycles a thread has executed, rather than just using an interval-timer <b>interrupt</b> <b>routine.</b> This new CPU cycle-based thread scheduling gives a greater fairness and more deterministic app behavior. Many kernel data structures and algorithms have been rewritten. Lookup algorithms now run in constant time, instead of linear time as with previous versions.|$|E
2500|$|Automated Interrupt Prologue – adds {{hardware}} {{to save and}} update system status before the <b>interrupt</b> handling <b>routine</b> ...|$|R
50|$|A FLIH {{implements}} {{at minimum}} platform-specific interrupt handling similar to <b>interrupt</b> <b>routines.</b> In {{response to an}} interrupt, there is a context switch, and the code for the interrupt is loaded and executed. The job of a FLIH is to quickly service the interrupt, or to record platform-specific critical information which is only {{available at the time}} of the interrupt, and schedule the execution of a SLIH for further long-lived interrupt handling.|$|R
50|$|Most {{processors}} include store {{operations that}} are not atomic with respect to memory. These include multiple words stores and string operations. Should a high priority interrupt occur when {{a portion of the}} store is complete, the operation must be completed when the interrupt level is returned. The routine that processes the interrupt must not access the memory being changed. It is important to take this into account when writing <b>interrupt</b> <b>routines.</b>|$|R
50|$|Often, the {{graphics}} chips used in home computers and video game consoles had limited capabilities. Raster interrupts {{were incorporated into}} these video chips allowing skilled programmers to transcend these limitations. A software-serviced interrupt would be set to trigger when a given screen line was refreshed, and the <b>interrupt</b> <b>routine</b> could then reload the chip's registers. In doing so, {{the graphics}} chip state could be changed at a specific screen position allowing sprites to be repositioned, additional colors inserted, or graphics modes to be changed giving the graphics hardware the appearance of greater capability than it was inherently endowed.|$|E
5000|$|It {{should also}} be noted that the Z80 {{supports}} a non-maskable interrupt with /NMI being on Pin 17 of the original 40 pin DIP package. [...] Since a non-maskable interrupt will regain control of the CPU even after executing the instruction sequence DI / HALT, that pair does not represent a true HCF, it will only result in a HCF condition if either the /NMI pin is connected directly to the +5V rail, making the generation of that signal impossible, or if the <b>interrupt</b> <b>routine</b> that services /NMI ends with a return, placing it back in the HALT state.|$|E
5000|$|By {{reloading}} the VIC-II's control registers via {{machine code}} hooked into the raster <b>interrupt</b> <b>routine</b> (the scanline interrupt), one can program the chip to generate {{significantly more than}} 8 concurrent sprites (a process known as sprite multiplexing), and generally give every program-defined slice of the screen different scrolling, resolution and color properties. The hardware limitation of 8 sprites per scanline could be increased further by letting the sprites flicker rapidly on and off. Mastery of the raster interrupt was essential in order to unleash the VIC-II's capabilities. Many demos and some later games would establish a fixed [...] "lock-step" [...] between the CPU and the VIC-II so that the VIC registers could be manipulated at exactly the right moment.|$|E
3000|$|The OUT {{primitive}} {{is called}} when an ISR (<b>interrupt</b> service <b>routine)</b> or a thread needs {{to communicate with}} one another. Defining [...]...|$|R
25|$|The AGC {{responded to}} each {{interrupt}} by temporarily suspending the current program, executing a short <b>interrupt</b> service <b>routine,</b> and then resuming the interrupted program.|$|R
50|$|The Operating System's Non-Maskable <b>Interrupt</b> {{dispatch}} <b>routine</b> reads this {{register to}} determine {{the reason for the}} interrupt and so which service routine to execute.|$|R
