37|10000|Public
50|$|Cameleon {{language}} is a graphical <b>data</b> <b>flow</b> <b>language</b> following a two-scale paradigm. It allows an easy up-scale, that is, the integration of any library writing in C++ into the <b>data</b> <b>flow</b> <b>language.</b> Cameleon language aims to democratize macro-programming by an intuitive interaction between the human and the computer where building an application based on a data-process and a GUI is a simple task to learn and to do. Cameleon language allows conditional execution and repetition to solve complex macro-problems.|$|E
50|$|The toolkit has {{the ability}} to work with HLSL Shaders which are written in their common textual form but are {{embedded}} in the <b>data</b> <b>flow</b> <b>language</b> and are instantly compiled and uploaded as soon any part of their source code is changed.|$|E
30|$|Pig [20]: A {{high-level}} <b>data</b> <b>flow</b> <b>language</b> {{and execution}} framework for parallel computation.|$|E
40|$|The <b>data</b> <b>flow</b> {{model is}} a popular model {{on which to base}} a visual {{programming}} language. This paper describes alternatives available to a designer of <b>data</b> <b>flow</b> <b>languages,</b> describes many of the languages, discusses some strengths of the languages, and discusses some unsolved problems in the design of <b>data</b> <b>flow</b> <b>languages.</b> 1...|$|R
40|$|Embedded systems {{often are}} {{described}} with graphical <b>data</b> <b>flow</b> <b>languages</b> like Matlab/Simulink or Lustre/SCADE, {{which are used}} at {{the first stage of}} development cycle, that is at the specification level. Most of program verification activities currently are applied to the source code that is a low level description of systems. We propose to study a new approach based on frequency analysis to apply static analysis to <b>data</b> <b>flow</b> <b>languages...</b>|$|R
5000|$|SPL - <b>Data</b> <b>Flow</b> {{description}} <b>language</b> of IBM InfoSphere Streams {{streaming engine}} ...|$|R
30|$|DIF is {{designed}} as an extensible repository of representation, analysis, transformation, and scheduling of <b>data</b> <b>flow</b> <b>language.</b> DIF is a Java library {{which allows the}} user to go from graph specification using the DIF language to C code generation. However, the hierarchical Synchronous Data Flow (SDF) model used in the SDF 4 J library and PREESM is not available in DIF.|$|E
40|$|AbstractIn this paper, {{we present}} a {{compilation}} scheme along with optimizations for array iterators in the synchronous <b>data</b> <b>flow</b> <b>language</b> Lustre. We present the iterators (inspired from functional languages mechanisms such as map and foldl…) and show how to compile them into efficient imperative code that manipulates arrays and loops instead of inefficient code were arrays are expanded into independent variables...|$|E
40|$|The {{underlying}} {{principles of}} concurrency and data flow are summarized {{along with a}} survey of the current data flow languages. A high level <b>data</b> <b>flow</b> <b>language,</b> DIVA, is developed that provides the basic data types and language constructs of traditional languages as well as some unique features of data flow. The organization and data structures of the compiler and assembler are also discussed...|$|E
40|$|This paper {{describes}} how object-oriented software construction principles allow to develop extensible and reusable {{building blocks for}} the development of <b>data</b> <b>flow</b> based visual <b>languages.</b> First we’ll present the <b>data</b> <b>flow</b> visual <b>language</b> ProtoHyperflow whose object-oriented realization is discussed {{in the second part of}} the paper...|$|R
40|$|AbstractIn an extensional {{treatment}} of dataflow deadlock Wadge (1981) introduced an elegant nonoperational test for proving {{that many of}} Kahn's <b>data</b> <b>flow</b> message passing networks (Kahn, 1974) must be free of deadlock; a test that “should extend to a much wider context” {{in the study of}} program correctness. Such a context has now been provided with the introduction of partial metric spaces (Matthews, 1992). These spaces can be used to describe semantic domains such as those used in lazy <b>data</b> <b>flow</b> <b>languages</b> (Wadge and Ashcroft, 1985). This paper develops Wadge's ideas on establishing an extensional theory of program correctness by using partial metric spaces to give a nonoperational {{treatment of}} lazy <b>data</b> <b>flow</b> deadlock...|$|R
40|$|This report {{describes}} the design, functionality, {{and implementation of}} a <b>data</b> <b>flow</b> query <b>language</b> (DFQL), that visually represents a query as a directed acyclic <b>data</b> <b>flow</b> graph. The <b>language</b> is well suited for application domains such as scientific databases, where data analysis and visualization need to be tightly coupled with data retrieval, and {{the relationships between the}} entities are ill-defined. Unlike most visual query languages that are declarative, DFQL is a functional language and thus provides the ability to combine data retrieval, analysis, and visualization, intuitively in a single query. Minnesota Department of Transportatio...|$|R
40|$|Currently, {{we witness}} an {{increased}} interest in large-scale analytical data flows on non-relational data. The predom-inant building blocks of such data flows are user-defined functions (UDFs), a fact that is not well taken into ac-count for <b>data</b> <b>flow</b> <b>language</b> design and optimization in current systems. In this demonstration, we present Me-teor, a declarative <b>data</b> <b>flow</b> <b>language,</b> and Sofa, a logical optimizer for UDF-heavy data flows, which are both part of the Stratosphere system. Meteor queries seamlessly com-bine self-descriptive, domain-specific operators with stan-dard relational operators. Such queries are optimized by Sofa, building on a concise set of UDF annotations and a small set of rewrite rules to enable semantically equivalent plan rewriting of UDF-heavy data flows. A salient feature of Meteor and Sofa is extensibility: User-defined operators and their properties are arranged into a subsumption hierar-chy, which considerably eases integration and optimization of new operators. In this demonstration, we will let users pose arbitrary Meteor queries and graphically showcase ver-satility and extensibility of Sofa during query optimization. 1...|$|E
40|$|A <b>data</b> <b>flow</b> <b>language</b> {{above the}} level of a {{traditional}} high level language is presented for the purpose of b adapting programs written in a conventional programming language to a parallel enhment A program written in EASY-FLOW is a set of subprogram calls as units, structllfed by iteration, branching, and distribution constructs. The sequencing of execution within these structures is dictated by the data dependencies between units...|$|E
30|$|Both Lustre and Signal {{deal with}} {{inputs and outputs}} based on {{different}} clocks. Again, those clocks are different to the clocks of the Quartz extension since their computation steps are refined internally. In addition, since Signal is able to solve some of the introductory problems, {{it is a matter}} of taste whether to use a (descriptive) <b>data</b> <b>flow</b> <b>language</b> like Signal or to use a control-flow-based language like Quartz.|$|E
40|$|Programming in {{parallel}} is an error-prone and complex task {{compounded by the}} lack of tool support for both programming and debugging. Recent advances in compiler-directed shared memory APIs, such as OpenMP, have made shared-memory parallelism more widely accessible for users of traditional procedural languages: however, the mechanisms provided are difficult to use and error-prone. This paper examines the use of visual notations for <b>data</b> <b>flow</b> programming to enable the creation of shared memory parallel programs. We present a model, arising from research on the ReactoGraph visual programming language, that allows code in a general class of visual <b>data</b> <b>flow</b> <b>languages</b> to be parallelized using visual annotations, and discuss the advantages this has over current textual methods...|$|R
40|$|We {{present a}} new {{application}} for graph drawing {{in the context}} of graphical model-based system design, where manual placing of graphical items is still state-of-the-practice. The KIELER framework aims at improving this by oﬀering novel user interaction techniques, enabled by automatic layout of the diagrams. In this paper we present extensions of the well-known hierarchical layout approach, originally suggested by Sugiyama et al. to support port constraints, hyperedges, and compound graphs in order to layout diagrams of <b>data</b> <b>ﬂow</b> <b>languages.</b> A case study and experimental results show that our algorithm is well suited for application in interactive user interfaces. ...|$|R
40|$|<b>Data</b> <b>flow</b> based visual {{programming}} languages are an active {{area of research}} in {{visual programming}} <b>languages.</b> Some recent <b>data</b> <b>flow</b> visual programming <b>languages</b> have implemented higher order functions, allowing functions to be passed to/from functions. This paper describes a <b>data</b> <b>flow</b> visual programming <b>language</b> in which the first class citizenship of programs have been taken a step further, and programs can be manipulated as data {{with the same kind}} of flexibility that LISP offers in manipulating programs as data. 1...|$|R
40|$|We {{prove that}} both the {{synchronous}} <b>data</b> <b>flow</b> <b>language</b> Lustre restricted to finite value types and the synchronous state oriented language Argos are embedded in the synchronous paradigm Timed Concurrent Constraint (tcc). In fact, {{for each of the}} two languages we provide a tcc language encoding it compositionally w. r. to the structure of programs. Moreover, we prove that the "strong abortion" mechanism of the synchronous imperative language Esterel can be encoded in tcc. ...|$|E
40|$|This paper {{describes}} {{the research and}} development associated with the parallel functional language called EPL - Equational Programming Language - and its compiler. The emphasis is on opportunities and challenges arising from the use of a functional paradigm for specifying parallel programs. The EPL approach is based on a two-level computation description: the specification of the individual processes in EPL and the description of their interactions in a macro <b>data</b> <b>flow</b> <b>language,</b> called configuration...|$|E
40|$|Data flow {{languages}} form a subclass of {{the languages}} {{which are based}} primarily upon function application (i. e., applicative languages). By <b>data</b> <b>flow</b> <b>language</b> we mean any applicative language based entirely upon the notion of data flowing from one function entity to another or any language that directly supports such flowing. This flow concept gives data flow languages the advantage of allowing program definitions to be represented exclusively by graphs. Graphical representations and their applications {{are the subject of}} this article...|$|E
40|$|Programs for <b>data</b> <b>flow</b> {{machines}} {{are written in}} functional languages, some of which require efficient support for dynamic procedure invocation to achieve high performance and programming flexibility. Among the proposed <b>data</b> <b>flow</b> machines, few support procedures in any generality. Our machine, which is a hardware realization of the U-interpreter for <b>data</b> <b>flow</b> <b>languages,</b> provides support {{for a variety of}} procedure calling conventions. Because the U-interpreter assigns a unique activity name to each instance of a computation (activity), an activity name may become arbitrarily large in the case of nested or recursive procedure calls. Hardware considerations, however, require that an activity name be represented by a fixed-size tag. We describe a mechanism that uses fixed-size, reusable tags in hardware. Like processor and memory resources, a group of tags is allocated and deallocated for each procedure activation. The proposed mechanism passes procedure arguments and results efficiently, given the distributed environment of our machine...|$|R
40|$|The {{specification}} of embedded systems often contains several different specification or modeling languages with fundamental {{differences in their}} underlying models of computation. In this paper, we present the SPI model, a common internal representation that integrates the aspects of several models of computation and is targeted to scheduling and allocation as well as performance validation. The model and its applications are explained using an example combining a periodic process model as used in real-time operating systems (RTOS) with the synchronous <b>data</b> <b>flow</b> model (SDF). 1 Introduction Many applications of embedded systems include functions from different domains. Each of these functions is best modeled with a specification language that matches the application domain of the function, i. e. transformative functions are usually modeled using <b>data</b> <b>flow</b> <b>languages</b> whereas reactive control functions are modeled with event driven models of computation. Therefore, specifications of embedd [...] ...|$|R
40|$|Abstract: Both visual <b>data</b> <b>flow</b> {{and logic}} based {{programming}} languages have their merits as declarative languages for certain application domains. Combining their concepts to program with <b>data</b> <b>flows</b> and backtracking {{seems to be}} a promising idea, which lead to the development of BDL. BDL is a visual <b>data</b> <b>flow</b> programming <b>language</b> with constructs for nondeterministic programming and constraint checking. Its nondeterminism is resolved by using depth-first search and backtracking à la Prolog...|$|R
40|$|Almost all {{structural}} engineers {{work for}} structural design with some computer software as useful tools. However, it {{is concerned that}} such programs would not be good training tools for the beginners on structural design in spite that those have very high performance in the practical design field. This paper describes a new design tool of steel deck concrete slab system for the beginners in structural design field. The introduced system was developed using a popular spreadsheet application Excel employing VBA and DSP, which is <b>data</b> <b>flow</b> <b>language.</b> It is demonstrated {{that the system is}} useful for the stage of preliminary design...|$|E
40|$|SIGNAL is a {{synchronized}} <b>data</b> <b>flow</b> <b>language</b> {{designed for}} programming real-time systems. A SIGNAL program defines both data and control processing, from {{a system of}} equations, the variables of the system are signals. These equations can be organized as sub-systems (or processes). A signal is a sequence of values which has a clock associated with; this clock specifies the instants at which the values are available. This reference manual defines the syntax and the semantics of the INRIA version of the SIGNAL V 4 language. The original official definition of the SIGNAL V 4 language was published in french in june 1994. It {{is available at the}} following address...|$|E
40|$|Emergence {{is the way}} {{complex systems}} arise out of a {{multiplicity}} of relatively simple interactions between primitives. Since programming problems {{become more and more}} complexes and transverses, our vision is that application development should be process at two scales: micro- and macro-programming where at the micro-level the paradigm is step-by-step and at macro-level the paradigm is emergence. For micro-programming, which focuses on how things happen, popular languages, Java, C++, Python, are imperative writing languages where the code is a sequence of sentences executed by the computer. For macro-programming, which focuses on how things connect, popular languages, labVIEW, Blender, Simulink, are graphical data flow languages such that the program is a composition of operators, a unit-process consuming input data and producing output data, and connectors, a data-flow between an output data and an input data of two operators. However, despite their fruitful applications, these macro-languages are not transversal since different data-structures of native data-structures cannot be integrated in their framework easily. Cameleon language is a graphical <b>data</b> <b>flow</b> <b>language</b> following a two-scale paradigm. It allows an easy up-scale that is the integration of any library writing in C++ in the <b>data</b> <b>flow</b> <b>language.</b> Cameleon language aims to democratize macro-programming by an intuitive interaction between the human and the computer where building an application based on a data-process and a GUI is a simple task to learn and to do. Cameleon language allows conditional execution and repetition to solve complex macro-problems. In this paper we introduce a new model based on the extension of the petri net model for the description of how the Cameleon language executes a composition. Comment: 10 page...|$|E
5000|$|Like Max, Pd is a <b>data</b> <b>flow</b> {{programming}} <b>language.</b> As {{with most}} DSP software, {{there are two}} primary rates at which data is passed: sample (audio) rate, usually at 44,100 samples per second, and control rate, at 1 block per 64 samples. Control messages and audio signals generally flow {{from the top of}} the screen to the bottom between [...] "objects" [...] connected via inlets and outlets.|$|R
40|$|The {{languages}} for modeling reactive {{systems can}} be divided in two styles: the imperative ones and the declarative ones. This paper shows a way to translate a Statecharts specification (imperative) to a Signal one (declarative, equational, synchronous). This translation gives access to the Signal tools from a Statecharts specification: verification, efficient / distributed / compact code generation using the clock calculus available in Signal. 1 Introduction 1. 1 Objective Different languages exist {{for the design of}} reactive systems: the languages Lustre [6] and Signal [5],[2] are declarative and equational <b>data</b> <b>flow</b> <b>languages,</b> while Esterel [4], Statecharts [7] and Argos [12] are imperative ones. The choice between the declarative and the imperative approach has an influence upon facility to handle a given application area. For instance, declarative languages easily handle signal processing while imperative formalism are often used for control systems. The need for a control mechanis [...] ...|$|R
40|$|Model-based {{development}} is gaining {{more and more}} importance {{for the creation of}} software-intensive embedded systems. One important aspect of software models is model quality. This does not imply functional correctness, but non-functional properties, such as maintainability, scalability, extensibility. Lots of effort was put into development of metrics for control flow models. In the embedded systems domain however, domain specific- and <b>data</b> <b>flow</b> <b>languages</b> are commonly applied for model creation. For these languages, existing metrics are not applicable. Domain and project specific quality metrics therefore are informally defined; tracking conformance to these metrics is a manual and effort consuming task. To resolve this situation, we developed INProVE. INProVE is a model-based framework that supports definition of quality metrics in an intuitive, yet formal notion. It provides automated evaluation of design models through its indicators. Applied in different industry projects to complex models, INProVE has proven its applicability for quality assessment of data flow-oriented design models not only in research, but also in practice...|$|R
40|$|Most {{distributed}} real-time {{embedded systems}} are specified combining state diagram and data flow languages. This leads to several real-time codes which together {{do not necessarily}} satisfy the global specification, and consequently increases the development cycle because more tests are needed. Then, we propose, {{in order to obtain}} a single real-time code, to translate state diagram specification into data flow specification because it best exhibits the potential parallelism necessary for efficient distributed implementation. We choose to translate SyncCharts, a state diagram language which is deterministic and then well adapted to real-time, into SynDEx, a <b>data</b> <b>flow</b> <b>language</b> which allows automatic distributed code generation. This approach optimizes the distributed real-time code, and reduces the development cycle of complex distributed real-time embedded systems...|$|E
40|$|International audienceWe {{present a}} {{methodology}} for the verification of reactive systems, and {{its application to}} a case study. Systems are specified using the synchronous <b>data</b> <b>flow</b> <b>language</b> Signal. As this language {{is based on an}} equational approach (i. e. Signal programs are constraint equations between signals), it is natural to translate its Boolean part into a system of polynomial equations over three values denoting true, false and absent. Using operations in algebraic geometry on the polynomials, it is possible to check properties concerning the system, such as liveness, invariance, reachability and attractivity. We apply this method to the verification of the automatic circuit breaking control system of an electric power transformer station. This system handles the reaction to electrical defects on high voltage lines...|$|E
40|$|New {{computational}} {{tools and}} methodologies for the digital simulation of continuous systems were explored. Programmability, and cost effective performance in multiprocessor organizations for real time simulation was investigated. Approach {{is based on}} functional style languages and data flow computing principles, which allow for the natural representation of parallelism in algorithms and provides a suitable basis {{for the design of}} cost effective high performance distributed systems. The objectives of this research are to: (1) perform comparative evaluation of several existing data flow languages and develop an experimental <b>data</b> <b>flow</b> <b>language</b> suitable for real time simulation using multiprocessor systems; (2) investigate the main issues that arise in the architecture and organization of data flow multiprocessors for real time simulation; and (3) develop and apply performance evaluation models in typical applications...|$|E
40|$|We {{describe}} the design, functionality, {{and implementation of}} a <b>data</b> <b>flow</b> query <b>language</b> (DFQL), that graphically represents a query as a directed acyclic <b>data</b> <b>flow</b> graph. The <b>language</b> is well suited for application domains such as scientific databases, where data analysis and visualization need to be tightly coupled with data retrieval, and {{the relationships between the}} entities are ill-defined. Being a functional language, unlike most visual query languages that are declarative, DFQL provides the ability to combine data retrieval, analysis, and visualization, intuitively in a single query. We have implemented this language in a system being used in a long term data-intensive pavement research project. 1 Introduction To define a query in a conventional database query language, a user must be familiar with the logical design of the database and the query language. With the recent advances in graphical user interfaces (GUI), visual query languages have been proposed to ease the user's [...] ...|$|R
40|$|We {{suggest a}} {{solution}} for iterative processing in <b>data</b> <b>flow</b> diagrams based {{on the notion of}} a conditional <b>data</b> <b>flow</b> switch, and a specialized iterative construct based on pattern matching for vectors and matrices. Both of these constructs can be seamlessly incorporated into a <b>data</b> <b>flow</b> visual programming <b>language.</b> We demonstrate how these constructs may be used to reveal the spatial/temporal dualism of data streams...|$|R
40|$|Recent {{advances}} in modeling languages {{have made it}} feasible to formally specify and analyze the behavior of large system components. Synchronous <b>data</b> <b>flow</b> <b>languages,</b> such as Lustre, SCR, and RSML-e are particularly well suited to this task, and commercial versions of these tools such as SCADE and Simulink are growing in popularity among designers of safety critical systems, largely due to their ability to automatically generate code from the models. At the same time, {{advances in}} formal analysis tools have made it practical to formally verify important properties of these models to ensure that design defects are identified and corrected early in the lifecycle. This report describes how these tools have been applied to the ADGS- 2100 Adaptive Display and Guidance Window Manager being developed by Rockwell Collins Inc. The Window Manager acts as “switchboard ” between display applications and physical displays. It is also responsible for ensuring that critical information is displayed to pilots even in the presence of application and hardware failures. In this effort, the majority of the functional behavior of the window manager, with ove...|$|R
