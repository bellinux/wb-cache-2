635|1275|Public
2500|$|In other countries, {{the letter}} is not marked on the keyboard, but a {{combination}} of other keys can produce it. Often, {{the letter is}} input using a modifier and the s key. The details of the keyboard layout depend on the <b>input</b> <b>language</b> and operating system, such as Ctrl+Alt+s, on some keyboards such as US-International also AltGr+s in Microsoft Windows or Option+s on the [...] US, US-Extended, and UK keyboards in macOS. In Windows, one can also use alt code 0223.|$|E
2500|$|A {{separate}} subcategory of behavior-driven {{development is}} formed by tools that use specifications as an <b>input</b> <b>language</b> rather than user stories. An {{example of this}} style is the RSpec tool that was also developed by Dan North. Specification tools don't use user stories as an input format for test scenarios but rather use functional specifications for units that are being tested. These specifications often have a more technical nature than user stories and are usually less convenient for communication with business personnel than are user stories. An example of a specification for a stack might look like this: ...|$|E
50|$|The native <b>input</b> <b>language</b> for LilyPond is comprehensive, {{consisting}} of many commands needed for expressing {{any sort of}} articulation, dynamic, meter, etc. The ability to embed Scheme code within a LilyPond source file permits arbitrary extensions to the <b>input</b> <b>language</b> and assists with algorithmic composition. Some general syntactic features are listed below.|$|E
40|$|AbstractWe {{consider}} {{a variant of}} Gold’s learning paradigm where a learner receives as <b>input</b> n different <b>languages</b> (in the form of one text where all <b>input</b> <b>languages</b> are interleaved). Our goal is to explore the situation when a more “coarse” classification of <b>input</b> <b>languages</b> is possible, whereas more refined classification is not. More specifically, we answer the following question: under which conditions, a learner, being fed n different languages, can produce m grammars covering all <b>input</b> <b>languages,</b> but cannot produce k grammars covering <b>input</b> <b>languages</b> for any k>m. We also {{consider a}} variant of this task, where each of the output grammars may not cover more than r <b>input</b> <b>languages.</b> Our main {{results indicate that the}} major factor affecting classification capabilities is the difference n−m between the number n of <b>input</b> <b>languages</b> and the number m of output grammars. We also explore the relationship between classification capabilities for smaller and larger groups of <b>input</b> <b>languages.</b> For the variant of our model with the upper bound on the number of languages allowed to be represented by one output grammar, for classes consisting of disjoint languages, we found complete picture of relationship between classification capabilities for different parameters n (the number of <b>input</b> <b>languages),</b> m (number of output grammars), and r (bound on the number of languages represented by each output grammar). This picture includes a combinatorial characterization of classification capabilities for the parameters n,m,r of certain types...|$|R
40|$|We {{consider}} {{a variant of}} Gold’s learning paradigm where a learner receives as <b>input</b> n different <b>languages</b> (in form of one text where all <b>input</b> <b>languages</b> are interleaved). Our goal is to explore the situation when a more “coarse ” classification of <b>input</b> <b>languages</b> is possible, whereas more refined classification is not. More specifically, we answer the following question: under which conditions, a learner, being fed n different languages, can produce m grammars covering all <b>input</b> <b>languages,</b> but cannot produce k grammars covering <b>input</b> <b>languages</b> for any k> m. We also {{consider a}} variant of this task, where each of the output grammars may not cover more than r <b>input</b> <b>languages.</b> Our main {{results indicate that the}} major factor affecting classification capabilities is the difference n − m between the number n of <b>input</b> <b>languages</b> and the number m of output grammars. We also explore relationship between classification capabilities for smaller and larger groups of <b>input</b> <b>languages.</b> For the variant of our model with the upper bound on the number of languages allowed to be represented by one output grammar, for classes consisting of disjoint languages, we found complete picture of relationship between classification capabilities for different parameters n (the number of <b>input</b> <b>languages),</b> m (number of output grammars), and r (bound on the number of languages represented by each output grammar). This picture includes a combinatorial characterization of classification capabilities for the parameters n, m, r of certain types. ...|$|R
40|$|A {{separator}} for {{two languages}} {{is a third}} language containing the first one and disjoint from the second one. We investigate the following decision problem: given two regular <b>input</b> <b>languages,</b> decide whether there exists a locally testable (resp. a locally threshold testable) separator. In both cases, we design a decision procedure based on the occurrence of special patterns in automata accepting the <b>input</b> <b>languages.</b> We prove {{that the problem is}} computationally harder than deciding membership. The correctness proof of the algorithm yields a stronger result, namely a description of a possible separator. Finally, we discuss the same problem for context-free <b>input</b> <b>languages.</b> ...|$|R
5000|$|... a Source Grammar for the <b>input</b> <b>language</b> which builds {{syntactic}} constructions from input sentences; ...|$|E
50|$|In ex-USSR Unix community, Caps Lock key is {{traditionally}} used as <b>input</b> <b>language</b> switcher, convenient for usage with touch typing. Support {{for this is}} present in KDE, GNOME and other desktop environments. Default Russian, Ukrainian layouts for FreeBSD specifies Caps Lock as <b>input</b> <b>language</b> switcher. Additional programs {{can be used for}} this goal in Microsoft Windows,. The original Caps Lock function is reached in such layouts with Shift + Caps Lock.|$|E
5000|$|Format Engine {{for data}} {{connectivity}} link between various geoscience software applications. The format engine uses Output <b>Input</b> <b>Language</b> (OIL), an interpreted language to define various data formats.|$|E
5000|$|Added <b>input</b> <b>languages</b> for Japanese (Hand-writing), Korean, Arabic, Thai, and Greek ...|$|R
40|$|This book {{examines}} {{the place of}} creoles from a typological perspective using modern phylogenetic modeling tools. Exploring {{the similarities and differences}} that exist among creoles and between creoles and their <b>input</b> <b>languages,</b> the authors aim to generate new insights into persistent and at times hotly debated topics such as creole genesis and the relationships among creoles and between creoles and other languages, most specifically their <b>input</b> <b>languages...</b>|$|R
50|$|TouchPal v3 English {{version is}} {{released}} in April 2008, together with extra European <b>input</b> <b>languages.</b> TouchPal v3 Chinese input version comes out one month later.|$|R
5000|$|Automatic {{keyboard}} mode and <b>input</b> <b>language</b> tracking: [...] If Bengali and English are being typed {{in two different}} programs then Avro can detect the language and can continue typing in the correct language.|$|E
50|$|Contrary to most SMT solvers, Alt-Ergo uses a {{specific}} <b>input</b> <b>language</b> with prenex polymorphism. This helps {{reducing the number}} of quantified axioms and the complexity of problems. It also partially supports SMT-LIB 2 language, but performs less efficiently on SMT files.|$|E
50|$|Parse trees concretely {{reflect the}} syntax of the <b>input</b> <b>language,</b> making them {{distinct}} from the abstract syntax trees used in computer programming. Unlike Reed-Kellogg sentence diagrams used for teaching grammar, parse trees do not use distinct symbol shapes for different types of constituents.|$|E
25|$|The {{study of}} {{simultaneous}} bilingualism supplements general (monolingual) theories of child language acquisition. It particularly illuminates {{the critical role}} {{of the nature of}} <b>language</b> <b>input</b> in <b>language</b> development. This indicates that the form of <b>language</b> <b>input</b> must be similarly influential in monolinguals.|$|R
40|$|International audienceA {{separator}} for {{two languages}} {{is a third}} language containing the first one and disjoint from the second one. We investigate the following decision problem: given two regular <b>input</b> <b>languages,</b> decide whether there exists a locally testable (resp. a locally threshold testable) separator. In both cases, we design a decision procedure based on the occurrence of special patterns in automata accepting the <b>input</b> <b>languages.</b> We prove {{that the problem is}} computationally harder than deciding membership. The correctness proof of the algorithm yields a stronger result, namely a description of a possible separator. Finally, we discuss the same problem for context-free input~languages...|$|R
40|$|Over {{the past}} few years the study of first {{language}} acquisition has profited enormously from the detailed investigation of different child languages. One important finding from this line of cross-linguistic research is that form the very earliest stages children are sensitive to morphosyntactic differences in the various <b>input</b> <b>languages.</b> Child languages manifest as much typological variatio...|$|R
50|$|The Language Bar is {{the core}} user {{interface}} for Text Services Framework. The language bar enables text services to add UI elements to the toolbar and enables these elements when an application has focus. From the Language Bar, users can select the <b>input</b> <b>language,</b> and control keyboard input, handwriting recognition and speech recognition.|$|E
5000|$|A grammar is {{the set of}} {{patterns}} or syntax rules for the <b>input</b> <b>language.</b> It doesn't cover all language rules, such as the size of numbers, or the consistent use of names and their definitions {{in the context of}} the whole program. Shift-reduce parsers use a context-free grammar that deals just with local patterns of symbols.|$|E
5000|$|A JavaScript {{compiler}} from OCaml to JavaScript named js_of_ocaml. It {{makes it}} possible to run OCaml programs in a Web browser, with portability and without having to install anything. The compilator takes as <b>input</b> <b>language</b> an OCaml bytecode, that is a compiled OCaml program. It allows you to use existing OCaml libraries whose source code isn't available.|$|E
40|$|International audienceGiven two languages, a {{separator}} {{is a third}} {{language that}} contains the first one and is disjoint from the second one. We investigate the following decision problem: given two regular <b>input</b> <b>languages</b> of finite words, decide whether there exists a first-order definable separator. We prove {{that in order to}} answer this question, sufficient information can be extracted from semigroups recognizing the <b>input</b> <b>languages,</b> using a fixpoint computation. This yields an EXPTIME algorithm for checking first-order separability. Moreover, the correctness proof of this algorithm yields a stronger result, namely a description of a possible separator. Finally, we generalize this technique to answer the same question for regular languages of infinite words...|$|R
50|$|The MathJax {{architecture}} {{is designed to}} support the addition of <b>input</b> <b>languages</b> and display methods in the future via dynamically loaded modules. MathJax also includes a JavaScript API for enumerating and interacting with math instances in a page.|$|R
40|$|This thesis {{deals with}} source-code {{migration}} of high-level programming languages using decompilation. A migration tool developed within the thesis {{is built on}} top of the middle-end and back-end parts of Lissom project decompiler. Several compilers generating LLVM IR code from <b>input</b> <b>languages</b> are discussed. Compilers suitable for integration to the migration tool were chosen. Compiled LLVM IR code is an input of the decompiler's optimizing middle-end. The output from the migration tool is a code in the C language or Python-like language generated by the back-end of the decompiler. The <b>input</b> <b>languages</b> are Fortran and its dialects, C/C++/Objective-C/Objective-C++, and D. The thesis describes problems connected with migration of these languages, their solutions, and ways to improve quality and readability of the produced source code...|$|R
50|$|The {{most widely}} used systems of {{predictive}} text are Tegic's T9, Motorola's iTap, and the Eatoni Ergonomics' LetterWise and WordWise. T9 and iTap use dictionaries, but Eatoni Ergonomics' products uses a disambiguation process, a set of statistical rules to recreate words from keystroke sequences. All predictive text systems require a linguistic database for every supported <b>input</b> <b>language.</b>|$|E
50|$|In {{the fall}} of 1996, Professor Hank Dietz was the {{instructor}} for the undergraduate Compiler Construction course at Purdue University's School of Electrical and Computer Engineering. For this course, he assigned a series of projects in which the students would build a simple compiler targeting MMX. The <b>input</b> <b>language</b> was a subset dialect of MasPar's MPL called NEMPL (Not Exactly MPL).|$|E
50|$|LilyPond is a text-based application, so it {{does not}} contain its own {{graphical}} user interface to assist with score creation. It does, however, have a flexible <b>input</b> <b>language</b> that strives to be simple, easing the learning curve for new users. LilyPond adheres to the WYSIWYM paradigm; the workflow for typesetting music notation with LilyPond {{is similar to that}} of preparing documents with LaTeX.|$|E
40|$|Abstract—For second {{language}} acquisition (SLA), {{having access to}} <b>language</b> <b>input</b> is critical. Although the theories of SLA attach different importance {{to the role of}} <b>language</b> <b>input,</b> they all acknowledge the need for it (Ellis, 2008). Learners of English as a second (ESL) or a foreign language (EFL) are always encouraged to avail themselves of all forms of authentic <b>language</b> <b>input</b> within the classroom and beyond. In contexts with limited social interaction in the English language, however, various audiovisual technologies are available to be utilized as sources of authentic <b>language</b> <b>input</b> for enhancing <b>language</b> learning in both formal and informal learning settings. In the same line, the present aims at considering the role of <b>language</b> <b>input</b> for SLA development in informal setting. Index Terms—{{second language}} acquisition, informal setting, authentic language inpu...|$|R
40|$|Abstract. In {{the context}} of the INTEGRA project, {{compilation}} and code generation features for behavior definition are to be integrated in an existing model-based engineering environment for control systems. The devised compiler architecture is domain-specific and provides support for multiple <b>input</b> <b>languages</b> and multiple target platforms. In this paper we discuss an architectural approach in which the compiling process is organized in two different stages: the compiling stage and the linking stage. The compiling stage generates target independent code from possibly multiple <b>input</b> <b>languages.</b> The linking stage assembles precompiled code modules and generates a target specific executable code for a given virtual machine. To be more specific this paper describes the integration of the ST language in the tool core meta-model and the ST compiler is presented as an application case study...|$|R
40|$|International audienceThis book {{examines}} {{the place of}} creoles from a typological perspective using modern phylogenetic modeling tools. Exploring {{the similarities and differences}} that exist among creoles and between creoles and their <b>input</b> <b>languages,</b> the authors aim to generate new insights into persistent and at times hotly debated topics such as creole genesis and the relationships among creoles and between creoles and other languages, most specifically their <b>input</b> <b>languages.</b> The volume casts a very wide net. It investigates creoles from the Atlantic, Asian, Pacific and Africa region and also considers creoles associated with a range of so-called lexifiers (Arabic, Dutch, English, French and Iberian), common superstrates and some of the substrate inputs. But diversity does not stop there either. The authors also examine data from a range of linguistic levels, including phonological, morphological, syntactic and semantic phenomena...|$|R
50|$|Well-known {{examples}} of declarative domain-specific languages (DSLs) include the yacc parser generator <b>input</b> <b>language,</b> QML, the Make build specification language, Puppet's configuration management language, regular expressions, and {{a subset of}} SQL (SELECT queries, for example). DSLs {{have the advantage of}} being useful while not necessarily needing to be Turing-complete, which makes it easier for a language to be purely declarative.|$|E
50|$|The <b>input</b> <b>language</b> used by eqn {{allows the}} user to write {{mathematical}} expressions {{in much the same}} way as they would be spoken aloud. The language is defined by a context-free grammar, together with operator precedence and operator associativity rules. The eqn language is similar to the mathematical component of TeX, which appeared several years later, but is simpler and less complete.|$|E
5000|$|... troff {{features}} {{commands to}} designate fonts, spacing, paragraphs, margins, footnotes and more. Unlike many other text formatters, troff can position characters arbitrarily on a page, even overlapping them, {{and has a}} fully programmable <b>input</b> <b>language.</b> Separate preprocessors are used for more convenient production of tables, diagrams, and mathematics. Inputs to troff are plain text files that can be created by any text editor.|$|E
25|$|For more details, see {{the section}} on East Asian {{languages}} above, and the articles Japanese language and computers, Japanese <b>input</b> methods, and <b>Language</b> <b>input</b> keys.|$|R
40|$|Abstract. COXER is {{new test}} case {{generation}} tool for models of real-time and embedded systems. It generates test cases from a timed automata model and a coverage criteria expressed in an observer language. In this paper we describe current {{architecture of the}} tool, its <b>input</b> <b>languages,</b> and an application of the tool in an industrial case-study. ...|$|R
40|$|Contents 1 Introduction 3 1. 1 tlv-Basic.......................................... 3 1. 2 Notation........................................... 4 1. 3 Variable Ordering...................................... 4 1. 4 Beginning to {{work with}} tlv................................ 4 1. 5 Command line options................................... 6 I <b>Input</b> <b>Languages</b> of tlv 8 2 tlv-Basic 9 2. 1 Examples.......................................... 10 2. 2 Data types......................................... 12 2. 3 Predefined Dynamic Variables............................... 13 2. 4 Expressions.......... ...|$|R
