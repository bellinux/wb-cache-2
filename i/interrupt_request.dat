65|71|Public
25|$|FIQ mode: A {{privileged mode}} that is entered {{whenever}} the processor accepts a Fast <b>interrupt</b> <b>request.</b>|$|E
25|$|Windows XP {{frequently}} accesses CPU's APIC task-priority register (TPR) when <b>interrupt</b> <b>request</b> level changes, {{causing a}} performance degradation when running as guests on Hyper-V. Microsoft has fixed {{this problem in}} Windows Server 2003 and later.|$|E
2500|$|... /PCILOCK [...] For x86-based systems, this {{stops the}} {{operating}} system from dynamically assigning hardware input, hardware output, and <b>interrupt</b> <b>request</b> resources to PCI devices. Instead, the BIOS configures the devices.|$|E
5000|$|GPU sends <b>interrupt</b> <b>requests</b> to CPU {{on various}} events (such as page faults) ...|$|R
60|$|My Lady <b>interrupts,</b> <b>requesting</b> him to miss {{as many of}} {{the formal}} horrors as he can.|$|R
5000|$|Priority {{encoders}} {{establish the}} priority of competing inputs (such as <b>interrupt</b> <b>requests)</b> by outputting a binary code representing the highest-priority active input.|$|R
5000|$|<b>Interrupt</b> <b>request.</b> A {{device with}} lower {{priority}} is requesting {{access to the}} CPU.|$|E
5000|$|It has an <b>{{interrupt}}</b> <b>request</b> line IRQ, for interrupt driven {{data transfer}} with processor.|$|E
5000|$|FIQ mode: A {{privileged mode}} that is entered {{whenever}} the processor accepts a Fast <b>interrupt</b> <b>request.</b>|$|E
50|$|On the PC, the BIOS (and thus also DOS) {{traditionally}} maps {{the master}} 8259 <b>interrupt</b> <b>requests</b> (IRQ0-IRQ7) to <b>interrupt</b> vector offset 8 (INT08-INT0F) and the slave 8259 (in PC/AT and later) <b>interrupt</b> <b>requests</b> (IRQ8-IRQ15) to <b>interrupt</b> vector offset 112 (INT70-INT77). This was done despite the first 32 (INT00-INT1F) interrupt vectors being reserved by the processor for internal exceptions (this was ignored {{for the design}} of the PC for some reason). Because of the reserved vectors for exceptions most other operating systems map (at least the master) 8259 IRQs (if used on a platform) to another interrupt vector base offset.|$|R
5000|$|When the Caps Lock key is {{repeatedly}} pressed approx. 10 times, the Caps Lock LED {{turning on}} and off each time indicates the CPU is correctly reading the CIAs. If the Caps Lock LED sticks on or off, the CPU is not servicing CIA <b>interrupt</b> <b>requests.</b>|$|R
50|$|The {{interrupt}} {{priority level}} (IPL) {{is a part of}} the current system interrupt state, which indicates the <b>interrupt</b> <b>requests</b> that will currently be accepted. The IPL may be indicated in hardware by the registers in a Programmable Interrupt Controller, or in software by a bitmask or integer value.|$|R
50|$|The {{serial port}} is an 8250 or a {{derivative}} (such as the 16450 or 16550), mapped to eight consecutive IO addresses and one <b>interrupt</b> <b>request</b> line.|$|E
5000|$|The three {{semi-circular}} legends on {{the bottom}} left of the board marked positions for optional push switches to trigger the board's RESET, IRQ (<b>Interrupt</b> <b>ReQuest)</b> and NMI (Non Maskable Interrupt) lines.|$|E
5000|$|... /PCILOCK [...] - [...] For x86-based systems, this {{stops the}} {{operating}} system from dynamically assigning hardware input, hardware output, and <b>interrupt</b> <b>request</b> resources to PCI devices. Instead, the BIOS configures the devices.|$|E
50|$|Assigning {{different}} priorities to <b>interrupt</b> <b>requests</b> can {{be useful}} in trying to balance system throughput versus interrupt latency: some kinds of interrupts need to be responded to more quickly than others, but the amount of processing might not be large, so it makes sense to assign a higher priority to that kind of interrupt.|$|R
5000|$|With the {{introduction}} of multitasking operating systems on PC hardware, such as OS/2, Windows NT or various flavours of UNIX, the short time available to serve character-by-character <b>interrupt</b> <b>requests</b> became a problem, therefore the IBM PS/2 serial ports introduced the 16550(A) UARTs that had a built-in 16 byte FIFO or buffer memory to collect incoming characters.|$|R
50|$|At the beginning, the {{protocol}} works in continuous mode. At {{the end of}} each complete bus transaction (after the host has driven SERIRQ low and then waited for all devices to send <b>interrupt</b> <b>requests)</b> the host sends a final message: it drives the SERIRQ line low for two or three clocks depending on the mode that will be used in the next transaction.|$|R
5000|$|... 3. INTR (<b>Interrupt</b> <b>request)</b> - It is {{a signal}} that often {{interrupts}} the microprocessor when the external device receives the data via the signal. this pin is qualified by the internal INTE(interrupt enable) bit.|$|E
50|$|Windows XP {{frequently}} accesses CPU's APIC task-priority register (TPR) when <b>interrupt</b> <b>request</b> level changes, {{causing a}} performance degradation when running as guests on Hyper-V. Microsoft has fixed {{this problem in}} Windows Server 2003 and later.|$|E
5000|$|Serialized {{interrupts}} {{are transmitted}} over a single shared SERIRQ {{line with the}} help of the clock. A time slot is dedicated to each <b>interrupt</b> <b>request,</b> with the initial synchronization being done by the host. As a simplified example: ...|$|E
50|$|An End Of Interrupt (EOI) is {{a signal}} {{sent to a}} Programmable Interrupt Controller (PIC) to {{indicate}} the completion of interrupt processing for a given interrupt. An EOI is used to cause a PIC to clear the corresponding bit in the In-Service Register (ISR), and thus allow more <b>interrupt</b> <b>requests</b> of equal or lower priority to be generated by the PIC.|$|R
50|$|An integer based IPL may be {{as small}} as a single bit, with just two values: 0 (all {{interrupts}} enabled) or 1 (all interrupts disabled), as in the MOS Technology 6502. However, some architectures permit a greater range of values, where each value enables <b>interrupt</b> <b>requests</b> that specify a higher level, while blocking ones from the same or lower level.|$|R
50|$|When {{working with}} {{personal}} computer hardware, installing and removing devices, the system relies on <b>interrupt</b> <b>requests.</b> There are default settings that are configured {{in the system}} BIOS and recognized by the operating system. These default settings can be altered by advanced users. Modern plug and play technology has not only reduced the need for concern for these settings, but has also virtually eliminated manual configuration.|$|R
50|$|VME also decodes {{all seven}} of the 68000's {{interrupt}} levels onto a 7-pin interrupt bus. The interrupt scheme is one of prioritized vectored interrupts. The <b>interrupt</b> <b>request</b> lines (IRQ1 - IRQ7) prioritize interrupts. An interrupting module asserts one of the <b>interrupt</b> <b>request</b> lines. Any module on the bus may potentially handleany interrupt. When an interrupt handling module recognizes an <b>interrupt</b> <b>request</b> at a priority it handles, it arbitrates for the bus in the usual fashion described above. It then performs a read of the interrupt vector by driving the binary version of the IRQ line it handles (e.g. if IRQ5 is being handled, then binary 101) onto the address bus. It also asserts the IACK line, along with the appropriate data transfer strobes for {{the width of the}} status/ID being read. Again, LWORD*, DS0* and DS1* allow status/ID read cycles to be 8, 16, or 32 bit wide transfers but most existing hardware interrupters use 8 bit status/IDs. The interrupter responds by transferring a status/ID on the data bus to describe the interrupt. The interrupt handling module (usually a CPU) will usually use this status/ID number to identify and run the appropriate software interrupt service routine.|$|E
5000|$|... 3. INTR (<b>Interrupt</b> <b>request)</b> - It is an output that {{requests}} an interrupt. The INTR pin {{becomes a}} logic 1 when the STB input returns to a logic 1, and is cleared when {{the data are}} input from the port by the microprocessor.|$|E
5000|$|LSMI#: System {{management}} <b>interrupt</b> <b>request.</b> This is only required if an LPC device {{needs to}} trigger an SMI# {{in response to}} a bus access (e.g. to perform software emulation of a missing hardware peripheral). Otherwise, the slower SERIRQ protocol can be used to request an SMI.|$|E
40|$|Embedded {{systems can}} fail to operate {{correctly}} due to interrupt overload: starvation caused by too many <b>interrupt</b> <b>requests.</b> This paper describes three new techniques, two software-based and one hardware-based, for creating systems that delay or drop excessive <b>interrupt</b> <b>requests</b> {{before they can}} overload a processor. Our solutions to the interrupt overload problem have several desirable properties. During underload, overhead is proportional to interrupt load. During overload, both {{the amount of work}} performed in interrupt context and its granularity are bounded, making it possible to provide strong progress guarantees to low-priority interrupts and noninterrupt tasks. These guarantees permit developers to avoid making assumptions about the worst-case interrupt rates of peripherals such as sensors and network interfaces, filling an important gap in the chain of reasoning leading to a validated embedded system. We show that our solutions successfully prevent interrupt overload with modest overhead by evaluating them on embedded processors. We have also taken a description for a microprocessor in VHDL, modified it to include logic that prevents interrupt overload, synthesized the processor, and verified that it works using simulation...|$|R
40|$|This chapter {{discusses}} how {{to write}} programs to handle exceptions in the Nios ® II processor architecture. Emphasis is placed on how to process hardware <b>interrupt</b> <b>requests</b> by registering a user-defined interrupt service routine (ISR) with the hardware abstraction layer (HAL). This information applies to embedded software projects created with the Nios II Software Build Tools (SBT), either in Eclipse ™ or on the command line. This chapter contains the following sections...|$|R
5000|$|An [...] "interrupt vector table" [...] (IVT) is a data {{structure}} that associates {{a list of}} interrupt handlers {{with a list of}} <b>interrupt</b> <b>requests</b> in a table of interrupt vectors. Each entry of the interrupt vector table, called an interrupt vector, is the address of an interrupt handler. While the concept is common across processor architectures, IVTs may be implemented in architecture-specific fashions. For example, a dispatch table is one method of implementing an interrupt vector table.|$|R
50|$|The {{hardware}} interrupt system supports a 4-bit interrupt priority input, which {{needed to be}} higher than the priority level stored in the status register (bits 12-15) in order for the <b>interrupt</b> <b>request</b> to be served. In addition, the /LOAD input provides a non-maskable interrupt facility with a dedicated vector.|$|E
5000|$|Level-triggered {{interrupt}} {{is favored}} by some {{because it is}} easy to share the <b>interrupt</b> <b>request</b> line without losing the interrupts, when multiple shared devices interrupt at the same time. Upon detecting assertion of the interrupt line, the CPU must search through the devices sharing the <b>interrupt</b> <b>request</b> line until one who triggered the interrupt is detected. After servicing this device, the CPU may recheck the interrupt line status to determine whether any other devices also needs service. If the line is now de-asserted, the CPU avoids checking the remaining devices on the line. Since some devices interrupt more frequently than others, and other device interrupts are particularly expensive, a careful ordering of device checks is employed to increase efficiency. The original PCI standard mandated level-triggered interrupts because of this advantage of sharing interrupts.|$|E
50|$|The PIA {{interfaces}} to the 65xx microprocessor {{family with}} a reset line, a ϕ2 clock line, a read/write line, two <b>interrupt</b> <b>request</b> lines, two register select lines, three chip select lines and an 8-bit bidirectional data bus. The PIA interfaces to the peripheral devices with four interrupt/control lines and two 8-bit bidirectional buses.|$|E
30|$|It is very {{difficult}} to classify some VMI techniques in the categories mentioned above. Although some have the capabilities to introspect two or more regions, few have the additional capability to introspect system calls and introspect <b>interrupt</b> <b>requests</b> from devices. This is possible with hypervisors like Xen that use a special data structure called an event channel for passing interrupts and system calls and techniques such as process monitoring of system calls and memory. These abilities of hypervisors help in monitoring allied fields.|$|R
50|$|The Apple version prefers {{additional}} hardware {{that contains}} DACs, {{although it can}} instead use the computer's one-bit audio output (with the addition of much distortion) if the card is not present. The Atari makes use of the embedded POKEY audio chip. Speech playback on the Atari normally disables <b>interrupt</b> <b>requests</b> and shuts down the ANTIC chip during vocal output. The audible output is extremely distorted speech when graphic and text display is turned on. The Commodore 64 makes use of the 64's embedded SID audio chip.|$|R
50|$|The Blue Pill {{concept is}} to trap a running {{instance}} of the operating system by starting a thin hypervisor and virtualizing {{the rest of the}} machine under it. The previous operating system would still maintain its existing references to all devices and files, but nearly anything, including hardware <b>interrupts,</b> <b>requests</b> for data and even the system time could be intercepted (and a fake response sent) by the hypervisor. The original concept of Blue Pill was published by another researcher at IEEE Oakland on May 2006, under the name VMBR (virtual-machine based rootkit).|$|R
