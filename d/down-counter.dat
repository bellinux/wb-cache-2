4|3|Public
5000|$|The {{state diagram}} from Figure 2 {{is an example}} of an {{extended}} state machine, in which the complete condition of the system (called the extended state) is the combination of a qualitative aspect—the [...] "state"—and the quantitative aspects—the extended state variables (such as the <b>down-counter</b> [...] ).|$|E
5000|$|The obvious {{advantage}} of extended state machines is flexibility. For example, extending the lifespan of the [...] "cheap keyboard" [...] from 1,000 to 10,000 keystrokes would not complicate the extended state machine at all. The only modification required would be changing the initialization {{value of the}} [...] <b>down-counter</b> in the initial transition.|$|E
50|$|State {{machines}} {{supplemented with}} variables are called extended state machines and UML state machines belong to this category. Extended state machines can apply the underlying formalism to {{much more complex}} problems than is practical without including extended state variables. For instance, suppose {{the behavior of the}} keyboard depends on the number of characters typed on it so far and that after, say, 1,000 keystrokes, the keyboard breaks down and enters the final state. To model this behavior in a state machine without memory, you would need to introduce 1,000 states (e.g., pressing a key in state stroke123 would lead to state stroke124, and so on), which is clearly an impractical proposition. Alternatively, you could construct an extended state machine with a key_count <b>down-counter</b> variable. The counter would be initialized to 1,000 and decremented by every keystroke without changing state. When the counter reached zero, the state machine would enter the final state.|$|E
40|$|Model 104 -DA 12 - 8 is a PC/ 104 Bus {{board with}} eight DACs, 128 K SRAM for {{waveform}} data storage, eight 4 - 20 mA current sinks and three 16 -bit counter/timers. The DACs can be updated individually or simultaneously. An automatic circuit sets the analog outputs to zero at power-on or reset. Each output is buffered by a short-circuit protected op-amp sourcing up to 5 mA. Data for updating each DAC {{may come from}} either the card's onboard RAM or from the PC/ 104 bus. The on-board 64 K sample RAM and onboard intelligent circuitry provides flexible allocation of between one and eight FIFO buffers/waveforms. Counter/Timers Three 16 -bit <b>down-counters,</b> in a type 8254 IC, are included. These are configured as two frequency sources derived from an on-board 2 MHz crystal-controlled oscillator. Counter/Timers 1 and 2 are concatenated by the card to form a single 32 -bit counter. Input/Output Connections Primary I/O connections (analog reference, voltage and current outputs) are made via a 40 pin header. Fused + 5 V and + 12 V are also available on this header. Control and statu...|$|R
40|$|This paper {{describes}} a hardware architectural {{design of a}} real-time counter based entropy coder at a register transfer level (RTL) computing model. The architecture {{is based on a}} lossless compression algorithm called Rice coding, which is optimal for an entropy range of bits per sample. The architecture incorporates a word-splitting scheme to extend the entropy coverage into a range of bits per sample. We have designed a data structure in a form of independent code blocks, allowing more robust compressed bitstream. The design focuses on an RTL computing model and architecture, utilizing 8 -bit buffers, adders, registers, loader-shifters, select-logics, <b>down-counters,</b> up-counters, and multiplexers. We have validated the architecture (both the encoder and the decoder) in a coprocessor for 8 bits/sample data on an FPGA Xilinx XC 4005, utilizing 61 % of F&G-CLBs, 34 % H-CLBs, 32 % FF-CLBs, and 68 % IO resources. On this FPGA implementation, the encoder and decoder can achieve 1. 74 Mbits/s and 2. 91 Mbits/s throughputs, respectively. The architecture allows pipelining, resulting in potentially maximum encoding throughput of 200 Mbit/s on typical real-time TTL implementations. In addition, it uses a minimum number of register elements. As a result, this architecture can result in low cost, low energy consumption and reduced silicon area realizations...|$|R
40|$|Abstract. This paper {{describes}} a hardware architectural {{design of a}} real-time counter based entropy coder at a register transfer level (RTL) computing model. The architecture {{is based on a}} lossless compression algorithm called Rice coding, which is optimal for an entropy range of 5. 25. 1 H bits per sample. The architecture incorporates a word-splitting scheme to extend the entropy coverage into a range of 5. 75. 1 H bits per sample. We have designed a data structure in a form of independent code blocks, allowing more robust compressed bitstream. The design focuses on an RTL computing model and architecture, utilizing 8 -bit buffers, adders, registers, loader-shifters, select-logics, <b>down-counters,</b> up-counters, and multiplexers. We have validated the architecture (both the encoder and the decoder) in a coprocessor for 8 bits/sample data on an FPGA Xilinx XC 4005, utilizing 61 % of F&G-CLBs, 34 % H-CLBs, 32 % FF-CLBs, and 68 % IO resources. On this FPGA implementation, the encoder and decoder can achieve 1. 74 Mbits/s and 2. 91 Mbits/s throughputs, respectively. The architecture allows pipelining, resulting in potentially maximum encoding throughput of 200 Mbit/s on typical real-time TTL implementations. In addition, it uses a minimum number of register elements. As a result, this architecture can result in low cost, low energy consumption and reduced silicon area realizations...|$|R
40|$|A {{spacecraft}} (8) {{includes a}} movable appendage such as solar panels (12) {{operated by a}} stepping motor (28) driven by pulses (311). In order to reduce vibration andor attitude error, the drive pulses are generated by a clock <b>down-counter</b> (312) with variable count ratio. Predetermined desired clock ratios are stored in selectable memories (314 a-d), and the selected ratio (R) is coupled to a comparator (330) together with the current ratio (C). An up-down counter (340) establishes the current count-down ratio by counting toward the desired ratio {{under the control of}} the comparator; thus, a step change of solar panel speed never occurs. When a direction change is commanded, a flag signal generator (350) disables the selectable memories, and enables a further store (360), which generates a count ratio representing a very slow solar panel rotational rate, so that the rotational rate always slows to a low value before direction is changed. The principles of the invention are applicable to any movable appendage...|$|E

