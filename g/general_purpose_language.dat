114|10000|Public
25|$|As a <b>general</b> <b>purpose</b> <b>language,</b> Prolog also {{provides}} various built-in predicates to perform routine activities like input/output, using graphics and otherwise {{communicating with the}} operating system. These predicates are not given a relational meaning and are only useful for the side-effects they exhibit on the system. For example, the predicate write/1 displays a term on the screen.|$|E
5000|$|Programming Language One (PL/I) {{a hybrid}} commercial-scientific <b>general</b> <b>purpose</b> <b>language</b> {{supporting}} pointers.|$|E
50|$|For general semi-structured data one may use a <b>general</b> <b>purpose</b> <b>language</b> such as XML.|$|E
50|$|Even though Unix {{scripting}} {{languages are}} Turing complete, they differ from <b>general</b> <b>purpose</b> <b>languages.</b>|$|R
5000|$|Commercial {{implementations}} {{are either}} <b>general</b> <b>purpose</b> or tied to specific hardware by a vendor. Examples of <b>general</b> <b>purpose</b> <b>languages</b> include: ...|$|R
40|$|International audienceGrammar metrics {{have been}} {{introduced}} to measure the quality and {{the complexity of the}} formal grammars. The aim {{of this paper is to}} explore the meaning of these notions and to experiment, on several grammars of domain speciﬁc <b>languages</b> and of <b>general</b> <b>purpose</b> <b>languages,</b> existing grammar metrics together with new metrics based on grammar LR automaton and on the produced language. We discuss the results of this experiment and focus on the comparison between domain speciﬁc <b>languages</b> and <b>general</b> <b>purpose</b> <b>languages</b> grammars and on the evolution of the metrics between several versions of the same language...|$|R
50|$|The PSM may use {{different}} DSLs or a <b>general</b> <b>purpose</b> <b>language..</b> Automated tools generally perform this translation.|$|E
5000|$|WFL [...] is {{used for}} {{high-level}} system operations, such as running tasks, moving and copying files, providing high-level recoverability. Thus {{it is not a}} <b>general</b> <b>purpose</b> <b>language</b> in that you would not use it to do general computations. You can open and close files to check their attributes for example; however, you cannot read or change their contents in WFL - that you do in a <b>general</b> <b>purpose</b> <b>language,</b> and invoke it as a task from WFL.|$|E
5000|$|... domain-specific {{languages}} {{which are}} implemented using programming language macro systems, {{and which are}} converted or expanded into a host <b>general</b> <b>purpose</b> <b>language</b> at compile-time or read-time ...|$|E
50|$|Microcontrollers were {{originally}} programmed only in assembly language, but various high-level programming languages, such as C, Python and JavaScript, are now also in common use to target microcontrollers and embedded systems. These languages are either designed specially for the purpose, or versions of <b>general</b> <b>purpose</b> <b>languages</b> {{such as the}} C programming <b>language.</b> Compilers for <b>general</b> <b>purpose</b> <b>languages</b> will typically have some restrictions as well as enhancements to better support the unique characteristics of microcontrollers. Some microcontrollers have environments to aid developing certain types of applications. Microcontroller vendors often make tools freely available {{to make it easier}} to adopt their hardware.|$|R
40|$|Abstract—Grammar metrics {{have been}} {{introduced}} to measure the quality and {{the complexity of the}} formal grammars. The aim {{of this paper is to}} explore the meaning of these notions and to experiment, on several grammars of domain specific <b>languages</b> and of <b>general</b> <b>purpose</b> <b>languages,</b> existing grammar metrics together with new metrics based on grammar LR automaton and on the produced language. We discuss the results of this experiment and focus on the comparison between domain specific <b>languages</b> and <b>general</b> <b>purpose</b> <b>languages</b> grammars and on the evolution of the metrics between several versions of the same language. Index Terms—grammar metrics, software language engineering, grammar engineering, grammarwar...|$|R
5000|$|... is a <b>general</b> <b>purpose</b> {{programming}} <b>language</b> {{which can}} be verified statically.|$|R
50|$|Syntactic preprocessors are {{typically}} used to customize the syntax of a language, extend a language by adding new primitives, or embed a domain-specific programming language (DSL) inside a <b>general</b> <b>purpose</b> <b>language.</b>|$|E
5000|$|... {{embedded}} (or internal) domain-specific languages, implemented as libraries which {{exploit the}} syntax of their host <b>general</b> <b>purpose</b> <b>language</b> or a subset thereof, while adding domain-specific language elements (data types, routines, methods, macros etc.). (e.g. Embedded SQL, LINQ) ...|$|E
50|$|These {{approaches}} bases {{on existing}} <b>general</b> <b>purpose</b> <b>language</b> (GPL) code base Cerny2012. They inspect the code through meta-programming and assemble a structural model that is transformed to the UI. This approach addresses information restatement. These approaches {{does not fit}} to adaptive and context-aware UIs.|$|E
5000|$|The Perl 6 Grammars {{feature of}} the <b>general</b> <b>purpose</b> {{programming}} <b>language</b> Perl 6.|$|R
40|$|Several {{attempts}} have been made to construct high-level languages for implementing TinyOSbased applications. Some of these {{attempts have}} taken the form of <b>general</b> <b>purpose</b> <b>languages</b> (TinyScript and Mottle in Maté [3]), some were designed for a specific application domain (TinyDB [4], Regiment [6], WaveScope [5], etc), while others explored specific programmin...|$|R
5000|$|<b>General</b> <b>purpose</b> {{programming}} <b>languages</b> rarely {{support such}} idioms, but domain-specific languages can describe them, e.g.: ...|$|R
5000|$|As a <b>general</b> <b>purpose</b> <b>language,</b> Prolog also {{provides}} various built-in predicates to perform routine activities like input/output, using graphics and otherwise {{communicating with the}} operating system. These predicates are not given a relational meaning and are only useful for the side-effects they exhibit on the system. For example, the predicate [...] displays a term on the screen.|$|E
50|$|P4 is a {{programming}} language designed to allow programming of packet forwarding planes. In contrast to a <b>general</b> <b>purpose</b> <b>language</b> such as C or Python, P4 is a domain-specific language {{with a number of}} constructs optimized around network data forwarding. P4 is an open-source, permissively licensed language and is maintained by a non-profit organization called the P4 Language Consortium. The language was originally described in a SIGCOMM CCR paper in 2014 titled “Programming Protocol-Independent Packet Processors” - the alliterative name shortens to “P4”.|$|E
50|$|Natural {{language}} programming (NLP) is an ontology-assisted way {{of programming}} {{in terms of}} natural language sentences, e.g. English. A structured document with Content, sections and subsections for explanations of sentences forms a NLP document, which is actually a computer program. Natural languages and natural language user interfaces include Inform7, a natural programming language for making interactive fiction, Ring, a <b>general</b> <b>purpose</b> <b>language,</b> Shakespeare, an esoteric natural programming language {{in the style of}} the plays of William Shakespeare, and Wolfram Alpha, a computational knowledge engine, using natural language input.|$|E
5000|$|Jinja — a <b>general</b> <b>purpose</b> {{templating}} <b>language.</b> CherryPy has a {{tool for}} using Jinja templates.|$|R
2500|$|Idris, a <b>general</b> <b>purpose</b> {{functional}} <b>language</b> {{with dependent}} types, {{developed at the}} University of St Andrews ...|$|R
5000|$|... pbLua is a port of the Lua {{programming}} <b>language,</b> a <b>general</b> <b>purpose</b> scripting <b>language,</b> for Lego Mindstorms.|$|R
5000|$|A {{combinator}} {{library is}} a software library which implements combinators for a functional programming language; [...] "the key idea is this: a combinator library offers functions (the combinators) that combine functions {{together to make}} bigger functions". These kinds of libraries are particularly useful for allowing domain-specific programming languages to be easily embedded into a <b>general</b> <b>purpose</b> <b>language</b> by defining a few primitive functions for the given domain and turning over the task of expanding higher-level constructs to the general language. An example would be the monadic Parsec parser http://www.haskell.org/haskellwiki/Parsec for Haskell. The library approach allows the parsers to be first-class citizens of the language.|$|E
50|$|To summarize, {{an analogy}} might be useful: a Very Little Language {{is like a}} knife, {{which can be used}} in {{thousands}} of different ways, from cutting food to cutting down trees. A domain-specific language is like an electric drill: it is a powerful tool {{with a wide variety of}} uses, but a specific context, namely, putting holes in things. A <b>General</b> <b>Purpose</b> <b>Language</b> is a complete workbench, with a variety of tools intended for performing a variety of tasks. Domain-specific languages should be used by programmers who, looking at their current workbench, realize they need a better drill, and find that a particular domain-specific language provides exactly that.|$|E
5000|$|Zonnon is {{a member}} of the Pascal family of languages, which has two {{beneficial}} consequences: a) it is a <b>general</b> <b>purpose</b> <b>language</b> and b) it is immediately familiar to Pascal, Modula-2 and Oberon programmers. Most Pascal programs from the domain of algorithms and data structures are successfully compiled by the Zonnon compiler after just a few minor modifications. However, from the perspective of “programming-in-the-large”, Zonnon is much more elaborate compared to its predecessors. There are four different kinds of program units in Zonnon: objects, modules, definitions and implementations. The first two are instantiated at runtime, the third is a compile time unit of abstraction, and the fourth is a unit of composition. Here is a brief characterization: ...|$|E
50|$|Judoscript {{was one of}} {{the first}} <b>general</b> <b>purpose</b> {{scripting}} <b>languages</b> designed specifically for use with the Java platform.|$|R
30|$|The {{languages}} used {{mostly in}} our sample set were Java and JavaScript by a wide margin. This means in turn {{that the results of}} this study should be mostly interpreted with regard to projects with these languages, since we do not know the effect of the use of different <b>general</b> <b>purpose</b> <b>languages</b> on the questions asked.|$|R
5000|$|... domain-specific {{languages}} {{which are}} called (at runtime) from programs written in <b>general</b> <b>purpose</b> <b>languages</b> like C or Perl, {{to perform a}} specific function, often returning the results of operation to the [...] "host" [...] programming language for further processing; generally, an interpreter or virtual machine for the domain-specific language is embedded into the host application (e.g. format strings, a regular expression engine) ...|$|R
50|$|This Forth use of {{metacompiler}} is disputed {{in mainstream}} computer science. See Forth (programming language) and History of compiler construction. The actual Forth process of compiling {{itself is a}} combination of a Forth being a Self-hosting Extensible programming language and sometimes Cross compilation, long established terminology in computer science. Metacompilers are a general compiler writing system. Besides the FORTH metacompiler concept being indistinguishable from self-hosting and extensible language. The actual process acts at a lower level defining a minimum subset of forth words, {{that can be used to}} define additional forth words, A full FORTH implementation can then be defined from the base set. This sounds like a bootstrap process. The problem is that almost ever <b>general</b> <b>purpose</b> <b>language</b> compiler also fits the FORTH metacompiler description.|$|E
50|$|Gosu is a statically-typed {{programming}} language {{that runs on}} the Java Virtual Machine released under the Apache 2. This general-purpose {{programming language}} is used in several open-source software projects including SparkGS and Ragnar DB among several others, and is widely used in the insurance industry via Guidewire Software's commercial products. The language borrows from several existing languages including Java, C#, and ECMAScript. A notable and unique feature is its Open Type System, which allows the language to be easily extended to provide compile-time checking and IDE awareness of information that is typically checked only at runtime in most other languages. Also of note is the language's ability to serve as both a full-featured <b>general</b> <b>purpose</b> <b>language</b> and as a concise scripting language. For instance, Gosu has free-form Program types (.gsp files) for scripting as well as statically verified Template files (.gst files). Gosu can optionally execute these and all other types directly from source without precompilation, which also distinguishes it from other static languages.|$|E
40|$|Domain {{specific}} {{languages are}} one approach for achieving reuse in a domain. Instead of creating systems from scratch in a <b>general</b> <b>purpose</b> <b>language,</b> a domain specific language is used, which provides high level domain specific abstractions, for specifying domain instances. Thus reducing production time and cost and potentially increasing qualit...|$|E
50|$|The Euphoria <b>language</b> is a <b>general</b> <b>purpose</b> {{procedural}} <b>language</b> {{that focuses}} on simplicity, legibility, rapid development and performance via several means.|$|R
50|$|There are <b>general</b> <b>purpose</b> {{programming}} <b>languages,</b> {{in addition}} to topic-specific programs (see Traffic Simulation). Examples include JAS-mine, LIAM2, MODGEN, and OpenM++.|$|R
40|$|Approved {{for public}} release; {{distribution}} unlimited. <b>General</b> <b>Purpose</b> Graphic <b>Language</b> (GPGL) is an interactive language which {{is intended for}} both two-dimensional and three-dimensional displays. The thesis contains {{a survey of the}} attributes and capabilities of an interactive <b>general</b> <b>purpose</b> graphic <b>language.</b> The more popular <b>general</b> <b>purpose</b> graphic <b>languages</b> are compared and the results included. The system and user-defined functions (including the construction of user-defined functions) of GPGL are explained. The implementation of a subset of GPGL at the Naval Postgraduate School on an Adage AGT- 10 graphics terminal is described. The main purpose of implementing a selected subset of functions from GPGL is to examine the tri-level hierarchy established within the components of the graphical display; the manner in which this hierarchy is implemented is addressed in the thesis. [URL] United States Marine Corp...|$|R
