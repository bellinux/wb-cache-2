5|14|Public
50|$|Placeholders {{may have}} special markup syntax {{that allows the}} editor to {{identify}} the boundaries of placeholders relative to the other text in the current <b>edit</b> <b>buffer.</b>|$|E
5000|$|... nvi is an {{implementation}} of the ex/vi text editor originally distributed {{as part of the}} final official Berkeley Software Distribution (4.4 BSD-Lite). This is the version of vi that is shipped with all BSD-based open source distributions. It adds command history and editing, filename completions, multiple edit buffers, multi-windowing (including multiple windows on the same <b>edit</b> <b>buffer).</b> Beyond 1.79, from October, 1996, which is the recommended stable version, there have been [...] "development releases" [...] of nvi, the most recent of which is 1.81.6, from November, 2007.|$|E
40|$|A CRDT is a {{data type}} whose {{operations}} commute {{when they are}} concurrent. Replicas of a CRDT eventually converge without any complex concurrency control. As an existence proof, we exhibit a non-trivial CRDT: a shared <b>edit</b> <b>buffer</b> called Treedoc. We outline the design, implementation and performance of Treedoc. We discuss how the CRDT concept can be generalised, and its limitations...|$|E
5000|$|Multiple windows, {{so those}} <b>edit</b> <b>buffers</b> can share screen space.|$|R
5000|$|Multiple <b>edit</b> <b>buffers,</b> {{so you can}} edit several files at {{the same}} time.|$|R
5000|$|The [...] "word erase", [...] "literal next", and [...] "reprint" [...] {{characters}} (by default , , and [...] - [...] ASCII , , and [...] ) performed {{additional line}} editing functions. [...] "word erase" [...] erased {{the last word}} {{at the end of}} the line <b>editing</b> <b>buffer.</b> [...] "literal next" [...] allowed any special character to be entered into the line <b>editing</b> <b>buffer</b> (a function available, somewhat inconveniently, in Seventh Edition Unix via the backslash character). [...] "reprint" [...] caused the line discipline to reprint the current contents of the line <b>editing</b> <b>buffer</b> on a new line (useful for when another, background, process had generated output that had intermingled with line editing).|$|R
40|$|Commuting {{operations}} greatly simplify {{consistency in}} distributed systems. This paper focuses on designing for commutativity, a topic neglected previously. We {{show that the}} replicas of any data type for which concurrent operations commute converges to a correct value, under some simple and standard assumptions. We also show that such a data type supports transactions with very low cost. We identify a number of approaches and techniques to ensure commutativity. We re-use some existing ideas (non-destructive updates coupled with invariant identification), but propose a much more efficient implementation. Furthermore, we propose a new technique, background consensus. We illustrate these ideas with a shared <b>edit</b> <b>buffer</b> data type...|$|E
40|$|A topological map can be {{the basis}} for {{additional}} thematic layers, successively converting it into a complex system for management and planning purposes. This paper presents the problem and gives our solution of applying Topological Map- Planar Map package of the CGAL library in building a tool to manipulate (includes to edit and to query) spatial objects contained in topological maps such as cadastral maps, route maps â€¦ To many developers who use Planar Map CGAL, the most restricted feature of Planar Map class is the ability to store and load a very large data of a real map into Planar Map object to edit because that job takes too much time to accept for real software. The core of our solution is using Planar Map CGAL object as an <b>edit</b> <b>buffer.</b> We implemented our study in SmartMap Editor, which {{is an important part of}} the whole HCM GIS- SmartMap System. SmartMap Editor provides functions to edit and query spatial data in a GIS system which contains several thematic layers. The spatial information in each thematic layer is stored in a topological structure. Some examples of its thematic layers and their usages are presented here. The structure and information content of the map is presented and the processes of map creation, update and query are described...|$|E
5000|$|In {{canonical}} mode, {{data are}} accumulated {{in a line}} <b>editing</b> <b>buffer,</b> and do not become [...] "available for reading" [...] until line editing has been terminated by the user (at the terminal) sending a line delimiter character. Line delimiter characters are special characters, and they are end of file, end of line, and linefeed (ASCII [...] ). The former two are settable programmatically, whilst the latter is fixed. The latter two {{are included in the}} line <b>editing</b> <b>buffer,</b> whilst the former one is not.|$|R
5000|$|More strictly, zero or more {{lines are}} {{accumulated}} {{in the line}} <b>editing</b> <b>buffer,</b> separated by line delimiters (which {{may or may not}} be discarded once [...] comes around to reading them), and line editing operates upon the part of the line <b>editing</b> <b>buffer</b> that follows the last (if any) line delimiter in the buffer. So, for example, the [...] "erase" [...] character (whatever that has been programmed to be) will erase the last character in the line buffer only up to (but not including) a preceding line delimiter.|$|R
5000|$|AUCTeX {{provides}} syntax highlighting, smart indentation and formatting, previews {{of mathematics}} and other elements directly in the <b>editing</b> <b>buffer,</b> smart folding of syntactical elements, macro and environment completion. It also supports the self-documenting [...]dtx format from the LaTeX project and, to a limited extent, ConTeXt and plain TeX.|$|R
5000|$|The {{terminal}} interface provided by Seventh Edition Unix and UNIX/32V, and also presented by BSD version 4 {{as the old}} terminal driver, was a simple one, largely geared towards teletypewriters as terminals. Input was entered a line at a time, with the terminal driver in the operating system (and not the terminals themselves) providing simple line <b>editing</b> capabilities. A <b>buffer</b> was maintained by the kernel in which editing took place. Applications reading terminal input would receive {{the contents of the}} buffer only when the [...] key was pressed on the terminal to end line editing. The [...] key sent from the terminal to the system would erase ("kill") the entire current contents of the <b>editing</b> <b>buffer,</b> and would be normally displayed as an '@' symbol followed by a newline sequence to move the print position to a fresh blank line. The [...] key sent from the terminal to the system would erase the last character {{from the end of the}} <b>editing</b> <b>buffer,</b> and would be normally displayed as an '#' symbol, which users would have to recognize as denoting a [...] "rubout" [...] of the preceding character (teletypewriters not being physically capable of erasing characters once they have been printed on the paper).|$|R
5000|$|In non-canonical mode, {{data are}} {{accumulated}} in a buffer (which {{may or may}} not be the line <b>editing</b> <b>buffer</b> [...] - [...] some implementations having separate [...] "processed input" [...] and [...] "raw input" [...] queues) and become [...] "available for reading" [...] according to the values of two input control parameters, the [...] and [...] members of the [...] data structure. Both are unsigned quantities (because [...] is required to be an alias for an unsigned type). The former specifies a minimum number of characters, and the latter specifies a timeout in tenths of a second. There are four possibilities: ...|$|R
5000|$|The use of [...] "minor modes" [...] enables further customization. A GNU Emacs <b>editing</b> <b>buffer</b> can {{use only}} one major mode at a time, but {{multiple}} minor modes can operate simultaneously. These may operate directly on documents, {{as in the}} way the major mode for the C programming language defines a separate minor mode for each of its popular indent styles, or they may alter the editing environment. Examples of the latter include a mode that adds the ability to undo changes to the window configuration and one that performs on-the-fly syntax checking. There is also a minor mode that allows multiple major modes to be used in a single file, for convenience when editing a document in which multiple programming languages are embedded.|$|R
5000|$|The TECO editor {{was itself}} {{implemented}} as an RTS {{to maximize the}} amount of memory available for the <b>editing</b> <b>buffer,</b> and also because it was first implemented in RSTS V5B, before {{the release of the}} general purpose runtime systems (RSX and RT11). TECO was the only RTS distributed with RSTS that did not contain a built-in KBM. The user would start up TECO (like any other program) by running a TECO program (TECO.TEC). TECO and the affine QEDIT were the direct ancestors of the first UNIX-based text editor, ED. Most RSTS systems used CCL's to create a file (MAKE filespec), edit a file (TECO filespec), or run a TECO program (MUNG filespec,data). The following program {{is an example of how}} TECO could be used to calculate pi (currently set to 20 digits): ...|$|R
50|$|A {{program called}} MENU, closely {{resembling}} the PC utility XTree, facilitates complex file management tasks and {{can serve as}} a replacement shell. Other utilities allow to change disk names, search disks for files, undelete them, install keyboard <b>buffer,</b> <b>edit</b> system files (CONFIG.SYS and AUTOEXEC.BAT) and so on. A port of ARC (SEA's archiver, very popular before ZIP has appeared) gives archiving facilities.|$|R
40|$|EMACS is a {{real-time}} editor primarily {{intended for}} display terminals. The intent of this memo {{is to describe}} EMACS in enough detail to allow a user to edit comfortably in most circumstances, knowing how {{to get more information}} if needed. Basic commands described cover <b>buffer</b> <b>editing,</b> file handling, and getting help. Two sections cover commands especially useful for editing LISP code, and text (word- and paragraph-commands). A brief "cultural interest" section describes the environment that supports EMACS commands...|$|R
50|$|Another problem, {{which may}} or may not appear, {{depending}} on the technique, the design of more polygons in one part of the shadow, resulting in darker and lighter parts of the same shade. All three problems can be solved geometrically, but because of the possibility that hardware acceleration is directly used, it is far more elegant implementations using the stencil buffer: 1. Enable lights and the lights 2. Draw a scene without any polygon that should be projected shadows 3. Draw all polygons which should be projected shadows, but without lights. In doing so, the stencil buffer, pixel of each polygon to be assigned to a specific value for the ground to which they belong. The distance between these values should be at least two, because for each plane to be used two values for two states: in the shadows and bright. 4. Disable any global illumination (to ensure that the next steps will affect only individual selected light) For each plane: For each light: 1. <b>Edit</b> a stencil <b>buffer</b> and only the pixels that carry a specific value for the selected level. Increase the value of all the pixels that are projected objects between the date of a given level and bright. 2. Allow only selected light for him to draw level at which part of her specific value was not changed.|$|R

