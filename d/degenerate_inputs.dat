11|35|Public
50|$|Quicksort is a familiar, {{commonly}} used algorithm in which randomness can be useful. Any deterministic {{version of this}} algorithm requires O(n2) time to sort n numbers for some well-defined class of <b>degenerate</b> <b>inputs</b> (such as an already sorted array), with the specific class of inputs that generate this behavior defined by the protocol for pivot selection. However, if the algorithm selects pivot elements uniformly at random, it has a provably high probability of finishing in O(n log n) time regardless {{of the characteristics of}} the input.|$|E
50|$|For {{a finite}} set of points, the convex hull is a convex {{polyhedron}} in three dimensions, or in general a convex polytope {{for any number}} of dimensions, whose vertices are some of the points in the input set. Its representation is not so simple as in the planar case, however. In higher dimensions, even if the vertices of a convex polytope are known, construction of its faces is a non-trivial task, as is the dual problem of constructing the vertices given the faces. The size of the output face information may be exponentially larger than the size of the input vertices, and even in cases where the input and output are both of comparable size the known algorithms for high-dimensional convex hulls are not output-sensitive due both to issues with <b>degenerate</b> <b>inputs</b> and with intermediate results of high complexity.|$|E
40|$|The {{problem of}} {{determining}} whether a polyhedron has a constrained Delaunay tetrahedralization is NP-complete. However, if no five vertices of the polyhedron lie on a common sphere, the problem has a polynomial-time solution. Constrained Delaunay tetrahedralization has the unusual status (for a small-dimensional problem) of being NP-hard only for <b>degenerate</b> <b>inputs.</b> ...|$|E
40|$|This {{thesis is}} {{concerned}} with the numerical issues resulting from the implementation of geometric algorithms on finite precision digital computers. From an examination of the general problem and a survey of previous research, it appears that the central problem of numerical computational geometry is how to deal with degenerate and nearly <b>degenerate</b> <b>input.</b> For some applications, such as solid modeling, degeneracy is often intended but we cannot always ascertain its existence using finite precision. For other applications, <b>degenerate</b> <b>input</b> is unwanted but nearly <b>degenerate</b> <b>input</b> is unavoidable. Near degeneracy is associated with ill-conditioning of the input and can lead to a serious loss of accuracy and program failure. These observations lead us to a discussion of problem condition in the context of computational geometry. We use the Voronoi diagram construction problem as a case study and show that problem condition can also play a role in algorithm design...|$|R
40|$|We {{present a}} robust {{approximate}} assembly partitioning algorithm for polyhedral parts. We achieve robustness by applying our controlled linear perturbation strategy to Minkowski sums of polyhedra and to arrangements of great circle arcs. Our algorithm is far {{faster than a}} prior robust algorithm based on exact computational geometry. Its error is small even on <b>degenerate</b> <b>input.</b> ...|$|R
40|$|We {{present a}} {{symbolic}} perturbation scheme for arbitrary polynomial geometric predicates which combines {{the benefits of}} Emiris and Canny's simple randomized linear perturbation scheme with Yap's multiple infinitesimal scheme for general predicates. Like the randomized scheme, our method accepts black box polynomial functions as input. For nonmaliciously chosen predicates, our method is {{as fast as the}} linear scheme, scaling reasonably with the degree of the polynomial even for fully <b>degenerate</b> <b>input.</b> Like Yap's scheme, the computed sign is deterministic, never requiring an algorithmic restart (assuming a high quality pseudorandom generator), and works for arbitrary predicates with no knowledge of their structure. We also apply our technique to exactly or nearly exactly rounded constructions that work correctly for <b>degenerate</b> <b>input,</b> using l'Hopital's rule to compute the necessary singular limits. We provide an open source prototype implementation including example algorithms for Delaunay triangulation and Boolean operations on polygons and circular arcs in the plane. Comment: 15 pages, 2 figure...|$|R
40|$|AbstractWe {{propose a}} fast and memory-efficient {{algorithm}} for lexicographically sorting the suffixes of a string, {{a problem that}} has important applications in data compression as well as string matching. Our algorithm eliminates much of the overhead of previous specialized approaches while maintaining their robustness for <b>degenerate</b> <b>inputs.</b> For input size n, our algorithm operates in only two integer arrays of size n, and has worst-case time complexity O(nlogn). We demonstrate experimentally that our algorithm has stable performance compared with other approaches...|$|E
40|$|We present robust {{algorithms}} for set {{operations and}} Euclidean transformations of curved shapes {{in the plane}} using approximate geometric primitives. We use a refinement algorithm to ensure consistency. Its computational complexity is (n n+k) for an input of size n with k=(n^ 2) consistency violations. The output is as accurate as the geometric primitives. We validate our algorithms in floating point using sequences of six set operations and Euclidean transforms on shapes bounded by curves of algebraic degree 1 to 6. We test generic and <b>degenerate</b> <b>inputs.</b> Keywords: robust computational geometry, plane subdivisions, set operations...|$|E
40|$|The {{main goal}} {{of this paper is}} to argue against the belief that {{perturbation}} is a “theoretical paradise ” and to put forward the claim that it is simpler (in terms of programming effort) and more efficient (in terms of running time) to avoid the perturbation technique and to deal directly with <b>degenerate</b> <b>inputs.</b> We substantiate our claim on two basic problems in computational geometry, the line segment intersection problem and the convex hull problem. 1 Introduction. Following Emiris and Canny [EC 921 we view a geometric problem P as a function from IRnd to S x IR,“, where n, m, and d are integers and S is some discrete space, modelling the symbolic part o...|$|E
40|$|AbstractThe {{fundamental}} problem of finding all intersections among {{a set of}} line segments in the plane has numerous important applications. Reliable implementations need to cope with <b>degenerate</b> <b>input</b> and limited precision. Representing intersection points with fixed precision can introduce extraneous intersections. This paper presents simple solutions to these problems and shows that they impose only a very modest performance penalty. Test data came from a data compression problem involving a map database...|$|R
40|$|This paper {{describes}} a general-purpose programming technique, called Simulation of Simplicity, {{that can be}} used to cope with <b>degenerate</b> <b>input</b> data for geometric algorithms. It relieves the programmer from the task of providing a cons:istent treatment for every single special case that can occur. The programs that use the technique tend to be considerably smaller and more robust than those that do not use it. We believe that this technique will become a standard tool in writing geometric software...|$|R
40|$|This movie {{illustrates}} exact {{construction and}} maintenance of arrangements induced by arcs of great circles embedded on the sphere, also known as geodesic arcs, and exact computation of Voronoi diagrams on the sphere, the bisectors of which are geodesic arcs. This class of Voronoi diagrams includes the subclass of Voronoi diagrams of points and its generalization, power diagrams, also known as Laguerre Voronoi diagrams. The resulting diagrams are represented as arrangements, and can be passed as input to consecutive operations supported by the Arrangement_ 2 package of Cgal and its derivatives. The implementation handles well <b>degenerate</b> <b>input</b> and produces exact results...|$|R
40|$|We {{present a}} method for {{analytically}} calculating an anti-aliased rasterization of arbitrary polygons or fonts bounded by Bézier curves in 2 D as well as oriented triangle meshes in 3 D. Our algorithm rasterizes multiple resolutions simultaneously using a hierarchical wavelet representation and is robust to <b>degenerate</b> <b>inputs.</b> We show that using the simplest wavelet, the Haar basis, is equivalent to performing a box-filter to the rasterized image. Because we evaluate wavelet coefficients through line integrals in 2 D, {{we are able to}} derive analytic solutions for polygons that have Bézier curve boundaries of any order, and we provide solutions for quadratic and cubic curves. In 3 D, we compute the wavelet coefficients through analytic surface integrals over triangle meshes and show how to do so in a computationally efficient manner...|$|E
40|$|Abstract. We {{consider}} the {{minimum spanning tree}} problem in a setting where information about the edge weights of the given graph is uncertain. Initially, for each edge e of the graph only a set Ae, called an uncertainty area, that contains the actual edge weight we is known. The algorithm can ‘update ’ e to obtain the edge weight we ∈ Ae. The task is to output the edge set of a minimum spanning tree after a minimum number of updates. An algorithm is k-update competitive if it makes at most k times as many updates as the optimum. We present a 2 -update competitive algorithm if all areas Ae are open or trivial, {{which is the best}} possible among deterministic algorithms. The condition on the areas Ae is to exclude <b>degenerate</b> <b>inputs</b> for which no constant update competitive algorithm can exist. Next, we consider a setting where the vertices of the graph correspond to points in Euclidean space and the weight of an edge is equal to the distance of its endpoints. The location of each point is initially given as an uncertainty area, and an update reveals the exact location of the point. We give a general relation between the edge uncertainty and the vertex uncertainty versions of a problem and use it to derive a 4 -update competitiv...|$|E
40|$|International audienceWe {{consider}} the {{minimum spanning tree}} problem in a setting where information about the edge weights of the given graph is uncertain. Initially, for each edge e of the graph only a set A_e, called an uncertainty area, that contains the actual edge weight w_e is known. The algorithm can `update' e to obtain the edge weight w_e ∈ A_e. The task is to output the edge set of a minimum spanning tree after a minimum number of updates. An algorithm is k-update competitive if it makes at most k times as many updates as the optimum. We present a 2 -update competitive algorithm if all areas A_e are open or trivial, {{which is the best}} possible among deterministic algorithms. The condition on the areas A_e is to exclude <b>degenerate</b> <b>inputs</b> for which no constant update competitive algorithm can exist. Next, we consider a setting where the vertices of the graph correspond to points in Euclidean space and the weight of an edge is equal to the distance of its endpoints. The location of each point is initially given as an uncertainty area, and an update reveals the exact location of the point. We give a general relation between the edge uncertainty and the vertex uncertainty versions of a problem and use it to derive a 4 -update competitive algorithm for the minimum spanning tree problem in the vertex uncertainty model. Again, we show that this is best possible among deterministic algorithms...|$|E
40|$|The Minkowski sum (also {{known as}} the vector sum) of two sets P and Q in IR 2 is the set fp + q j p 2 P; q 2 Qg. Minkowski sums are useful in robot motion planning, {{computer-aided}} design and manufacturing (CAD/CAM) and many other areas. We present a software package for robust and efficient construction of Minkowski sums of planar polygonal sets. We describe the different algorithms that we implemented and an experimental comparison between them. A distinctive feature of our implementation {{is that it can}} accurately handle <b>degenerate</b> <b>input</b> and in particular it can identify degenerate "holes" in th...|$|R
40|$|Although the {{validation}} of single polygons has received considerable attention, the automatic repair of invalid polygons has not. Automated repair methods {{can be considered}} as interpreting ambiguous or ill-defined polygons and giving a coherent and clearly defined output. At this moment, automatic tools are not satisfactory and repairing is thus mostly a semi-automatic task. We present in this paper a novel method, based on a constrained triangulation, to automatically repair invalid polygons. We describe our method, highlight some implementation details and describe an experiment with highly <b>degenerate</b> <b>input</b> for which predictable output is obtained. We believe our approach is superior to other tools since it is simple, intuitive and scales to big polygons. OTB ResearchOTB Research Institute for the Built Environmen...|$|R
40|$|We {{present a}} new {{algorithm}} for computing the straight {{skeleton of a}} polygon. For a polygon with n vertices, among which r are reflex vertices, we give a deterministic algorithm that reduces the straight skeleton computation to a motorcycle graph computation in O(n (log n) log r) time. It improves on the previously best known algorithm for this reduction, which is randomised, and runs in expected O(n √(h+ 1) log² n) time for a polygon with h holes. Using known motorcycle graph algorithms, our result yields improved time bounds for computing straight skeletons. In particular, we can compute the straight skeleton of a non-degenerate polygon in O(n (log n) log r + r^(4 / 3 + ε)) time for any ε > 0. On <b>degenerate</b> <b>input,</b> our time bound increases to O(n (log n) log r + r^(17 / 11 + ε) ...|$|R
40|$|This {{doctoral}} dissertation presents {{a range of}} results concerning efficient algorithms and data structures for string processing, including several schemes contributing to sequential data compression. It comprises both theoretic results and practical implementations. We study the suffix tree data structure, presenting an efficient representation and several generalizations. This includes augmenting the suffix tree to fully support sliding window indexing (including a practical implementation) in linear time. Furthermore, we consider a variant that indexes naturally word-partitioned data, and present a linear-time construction algorithm for a tree that represents only suffixes starting at word boundaries, requiring space linear {{in the number of}} words. By applying our sliding window indexing techniques, we achieve an efficient implementation for dictionary-based compression based on the LZ- 77 algorithm. Furthermore, considering predictive source modelling, we show that a PPM* style model can be maintained in linear time using arbitrarily bounded storage space. We also consider the related problem of suffix sorting, applicable to suffix array construction and block sorting compression. We present an algorithm that eliminates superfluous processing of previous solutions while maintaining robust worst-case behaviour. We experimentally show favourable performance {{for a wide range of}} natural and <b>degenerate</b> <b>inputs,</b> and present a complete implementation. Block sorting compression using BWT, the Burrows-Wheeler transform, has implicit structure closely related to context trees used in predictive modelling. We show how an explicit BWT context tree can be efficiently generated as a subset of the corresponding suffix tree and explore the central problems in using this structure. We experimentally evaluate prediction capabilities of the tree and consider representing it explicitly as part of the compressed data, arguing that a conscious treatment of the context tree can combine the compression performance of predictive modelling with the computational efficiency of BWT. Finally, we explore offline dictionary-based compression, and present a semi-static source modelling scheme that obtains excellent compression, yet is also capable of high decoding rates. The amount of memory used by the decoder is flexible, and the compressed data has the potential of supporting direct search operations...|$|E
40|$|AbstractArrangements of planar curves are {{fundamental}} structures in computational geometry. Recently, the arrangement package of Cgal, the Computational Geometry Algorithms Library, has been redesigned and re-implemented exploiting several advanced programming techniques. The resulting software package, which constructs and maintains planar arrangements, {{is easier to}} use, to extend, and {{to adapt to a}} variety of applications. It is more efficient space- and time-wise, and more robust. The implementation is complete {{in the sense that it}} handles <b>degenerate</b> <b>input,</b> and it produces exact results. In this paper we describe how various programming techniques were used to accomplish specific tasks within the context of computational geometry in general and arrangements in particular. These tasks are exemplified by several applications, whose robust implementation is based on the arrangement package. Together with a set of benchmarks they assured the successful application of the various programming techniques...|$|R
40|$|Project co-funded by the European Commission within FP 6 (2002 – 2006) Arrangements of planar curves are {{fundamental}} structures in computational geometry. Recently, the arrangement package of cgal, the Computational Geometry Algorithms Library, has been redesigned and re-implemented exploiting several advanced programming techniques. The resulting software package, which constructs and maintains planar arrangements, {{is easier to}} use, to extend, and {{to adapt to a}} variety of applications. It is more efficient space- and time-wise, and more robust. The implementation is complete {{in the sense that it}} handles <b>degenerate</b> <b>input,</b> and it produces exact results. The new package will be distributed as part of the forthcoming public version of cgal 3. 2. In this report we list the new features and major improvements of the new package compared to the old packages replaced by the new one. ...|$|R
40|$|A {{conservative}} {{implementation of}} a predicate returns true only if the exact predicate is true. That is, we accept a one sided error for the implementation. For geometric predicates, such as orientation- or incircle-tests, this allows efficient floating point implementations of the predicates with rare occurrences of the one sided error. We discuss {{the use of such}} conservative implementations for convex hull and triangulation algorithms for point sets in the plane. The resulting programs show a minor slowdown compared to an implementation that completely ignores the finite precision issue. However, our programs always produce output that satisfies basic desirable properties. The output can be easily checked for correctness and [...] if necessary [...] it can be repaired with an exact implementation of the needed predicates. Although (or since?) conservative implementations of predicates cannot detect degeneracies, the programs work for <b>degenerate</b> <b>input.</b> In fact, in our experiments the advanta [...] ...|$|R
40|$|We {{present an}} exact {{implementation}} of an efficient algorithm that computes Minkowski sums of convex polyhedra in R 3. Our implementation is complete {{in the sense}} that it does not assume general position, namely, it can handle <b>degenerate</b> <b>input,</b> and produces exact results. Our software also includes applications of the Minkowski-sum computation to answer collision and proximity queries about the relative placement of two convex polyhedra in R 3. The algorithms use a dual representation of convex polyhedra, and their implementation is mainly based on the Arrangement package of Cgal, the Computational Geometry Algorithm Library. We compare our Minkowski-sum construction with a naïve approach that computes the convex hull of the pairwise sums of vertices of two convex polyhedra. Our method is significantly faster. The video demonstrates the techniques used on simple cases as well as on degenerate cases. The relevant programs, source code, data sets, and documentation are availabl...|$|R
40|$|Project co-funded by the European Commission within FP 6 (2002 – 2006) In {{this report}} we {{concentrate}} on exact construction {{and maintenance of}} arrangements induced by arcs of great circles embedded on the sphere, also known as geodesic arcs, and exact computation of Voronoi diagrams on the sphere, the bisectors of which are geodesic arcs. This class of Voronoi diagrams includes the subclass of Voronoi diagrams of points and its generalization, power diagrams, also known as Laguerre Voronoi diagrams. The resulting diagrams are represented as arrangements, and can be passed as input to consecutive operations supported by the Arrangement 2 package of cgal and its derivatives. The implementation handles well <b>degenerate</b> <b>input</b> and produces exact results. Some of the implementation details and concepts referred to in this report are described and illustrated in [9, 8]. An example that uses real world data is included. Additional material is available a...|$|R
40|$|We {{present a}} general {{framework}} for computing two-dimensional Voronoi diagrams of different site classes under various distance functions. The computation of the diagrams employs the cgal software for constructing envelopes of surfaces in 3 -space, which implements a divide-and-conquer algorithm. A straightforward {{application of the}} divide-and-conquer approach for Voronoi diagrams yields highly inefficient algorithms. We show that through randomization, the expected running time is near-optimal (in a worst-case sense). We believe this result, which also holds for general envelopes, to be of independent interest. We describe the interface between {{the construction of the}} diagrams and the underlying construction of the envelopes, together with methods we have applied to speed up the (exact) computation. We then present results, where a variety of diagrams are constructed with our implementation, including power diagrams, Apollonius diagrams, diagrams of line segments, Voronoi diagrams on a sphere, and more. In all cases the implementation is exact and can handle <b>degenerate</b> <b>input...</b>|$|R
40|$|For a {{wide variety}} of regularization methods, {{algorithms}} computing the entire solution path have been developed recently. Solution path algorithms do not only compute the solution for one particular value of the regularization parameter but the entire path of solutions, making the selection of an optimal parameter much easier. Most of the currently used algorithms are not robust {{in the sense that they}} cannot deal with general or <b>degenerate</b> <b>input.</b> Here we present a new robust, generic method for parametric quadratic programming. Our algorithm directly applies to nearly all machine learning applications, where so far every application required its own different algorithm. We illustrate the usefulness of our method by applying it to a very low rank problem which could not be solved by existing path tracking methods, namely to compute part-worth values in choice based conjoint analysis, a popular technique from market research to estimate consumers preferences on a class of parameterized options. Comment: 7 Pages, 1 Figur...|$|R
40|$|We {{describe}} the algorithms and implementation details {{involved in the}} concretizations of a generic framework that enables exact construction, maintenance, and manipulation of arrangements embedded on certain two-dimensional orientable parametric surfaces in three-dimensional space. The fundamentals of the framework are described in a companion paper. Our work covers arrangements embedded on elliptic quadrics and cyclides induced by intersections with other algebraic surfaces, and a specialized case of arrangements induced by arcs of great circles embedded on the sphere. We also demonstrate how such arrangements {{can be used to}} accomplish various geometric tasks efficiently, such as computing the Minkowski sums of polytopes, the envelope of surfaces, and Voronoi diagrams embedded on parametric surfaces. We do not assume general position. Namely, we handle <b>degenerate</b> <b>input,</b> and produce exact results in all cases. Our implementation is realized using Cgal and, in particular, the package that provides the underlying framework. We have conducted experiments on various data sets, and documented the practical efficiency of our approach...|$|R
40|$|This paper {{describes}} {{an attempt to}} cast several essential, quite abstract, properties of natural languages {{within the framework of}} Kauffman's random Boolean nets. These properties are: complexity, interconnectedness, stability, diversity, and underdeterminedness. Specifically, in the research reported here, a language is modelled as an attractor of a Boolean net. (Groups of) nodes in the net might be thought of as linguistic principles or parameters as posited by Chomskyan theory of the 1980 s. According to this theory, the task of the language learner is to set parameters to appropriate values, on the basis of very limited experience of the language in use. The setting of one parameter can have a complex effect on the settings of other parameters. A random Boolean net is generated and run to find an attractor. A state from this attractor is degraded, to represent the <b>degenerate</b> <b>input</b> of language to the language learner, and this degraded state is then input to a net with the same conne [...] ...|$|R
40|$|We {{present a}} general {{framework}} for computing two-dimensional Voronoi diagrams of different classes of sites under various distance functions. Most diagrams {{mentioned in the}} paper are in the plane. However, the framework is sufficiently general to support diagrams embedded on a family of two-dimensional parametric surfaces in R 3. The computation of the diagrams is carried out through the construction of envelopes of surfaces in 3 -space provided by CGAL (the Computational Geometry Algorithm Library). The construction of the envelopes follows a divide-and-conquer approach. A straightforward application of the divide-and-conquer approach for Voronoi diagrams yields algorithms that are inefficient in the worst case. We prove that through randomization, the expected running time becomes near-optimal in the worst case. We also show how to apply the new framework and other existing tools from CGAL to compute minimum-width annuli of sets of disks, which requires the computation of two Voronoi diagrams of two different types, and of the overlay of the two diagrams. We do not assume general position. Namely, we handle <b>degenerate</b> <b>input,</b> and produce exact results. Additional material is available at...|$|R
40|$|Abstract Assembly {{partitioning}} with {{an infinite}} translation is {{the application of}} an infinite translation to partition an assembled product into two complementing subsets of parts, {{referred to as a}} subassemblies, each treated as a rigid body. We present an exact implementation of an efficient algorithm to obtain such a motion and subassemblies given an assembly of polyhedra in R 3. We do not assume general position. Namely, we handle <b>degenerate</b> <b>input,</b> and produce exact results. As often occurs, motions that partition a given assembly or subassembly might be isolated in the infinite space of motions. Any perturbation of the input or of intermediate results, caused by, for example, imprecision, might result with dismissal of valid partitioning-motions. In the extreme case, where there is only a finite number of valid partitioning-motions, no motion may be found, even though such exists. The implementation is based on software components that have been developed and introduced only recently. They paved the way to a complete, efficient, and concise implementation. Additional information is available a...|$|R
40|$|Given {{a finite}} set L of {{lines in the}} plane we wish to compute the zone of an {{additional}} curve fl in the arrangement A(L), namely the set of faces of the planar subdivision induced by the lines in L that are crossed by fl, where fl is not given in advance but rather provided on-line portion by portion. This problem is motivated by the computation of the area bisectors of a polygonal set in the plane. We present four algorithms which solve this problem efficiently and exactly (giving precise results even on <b>degenerate</b> <b>input).</b> We implemented the four algorithms. We present implementation details, comparison of performance, and {{a discussion of the}} advantages and shortcomings of each of the proposed algorithms. 1 Introduction Given a finite collection L of lines in the plane, the arrangement A(L) is the subdivision of the plane into vertices, edges and faces induced by L. Arrangements of lines in the plane, as well as arrangements of other objects and in higher dimensional spaces, [...] ...|$|R
40|$|Recently, the Arrangement 2 {{package of}} Cgal, the Computational Geometry Algorithms Library, {{has been greatly}} {{extended}} to support arrangements of curves embedded on two-dimensional parametric surfaces. The general framework for sweeping a set of curves embedded on a two-dimensional parametric surface was introduced in [3]. In this paper we concentrate on the specific algorithms and implementation details involved in the exact construction and maintenance of arrangements induced by arcs of great circles embedded on the sphere, also known as geodesic arcs, and on the exact computation of Voronoi diagrams on the sphere, the bisectors of which are geodesic arcs. This class of Voronoi diagrams includes the subclass of Voronoi diagrams of points and its generalization, power diagrams, also known as Laguerre Voronoi diagrams. The resulting diagrams are represented as arrangements, and can be passed as input to consecutive operations supported by the Arrangement 2 package and its derivatives. The implementation is complete {{in the sense that}} it handles <b>degenerate</b> <b>input,</b> and it produces exact results. An example that uses real world data is included. Additional material is available a...|$|R
25|$|The {{input stage}} with Q1 and Q3 {{is similar to}} an emitter-coupled pair (long-tailed pair), with Q2 and Q4 adding some <b>degenerating</b> {{impedance}}. The <b>input</b> impedance is relatively high {{because of the small}} current through Q1-Q4.|$|R
40|$|Transforming a {{geometric}} algorithm into {{an effective}} computer {{program is a}} difficult task. This transformation is particularly made hard by the basic assumptions of most theoretical geometric algorithms concerning complexity measures and (more crucially) the handling of robustness issues, namely issues related to arithmetic precision and <b>degenerate</b> <b>input.</b> The paper starts {{with a discussion of}} the gap between the theory and practice of geometric algorithms, together with a brief review of existing solutions to {{some of the problems that}} this dichotomy brings about. We then turn to an overview of the CGAL project and library. The CGAL project is a joint effort by a number of research groups in Europe and Israel to produce a robust software library of geometric algorithms and data structures. The library is now available for use with significant functionality. We describe the main goals and results of the project. The central part of the paper is devoted to arrangements (i. e., space subdivisions induced by geometric objects) and motion planning. We concentrate on the maps and arrangements part of the CGAL library. Then we describe two packages developed on top of CGAL for constructing robust geometric primitives for motion algorithms. KEY WORDS—Computational geometry, robustness and precision, arrangements, algorithmic motion planning 1...|$|R
40|$|We present two exact {{implementations}} of efficient output-sensitive algorithms that compute Minkowski sums of two convex polyhedra in 3 D. We do {{not assume}} general position. Namely, we handle <b>degenerate</b> <b>input,</b> and produce exact results. We provide a tight bound {{on the exact}} maximum complexity of Minkowski sums of polytopes in 3 D {{in terms of the}} number of facets of the summand polytopes. The algorithms employ variants of a data structure that represents arrangements embedded on two-dimensional parametric surfaces in 3 D, and they make use of many operations applied to arrangements in these representations. We have developed software components that support the arrangement data-structure variants and the operations applied to them. These software components are generic, as they can be instantiated with any number type. However, our algorithms require only (exact) rational arithmetic. These software components together with exact rational-arithmetic enable a robust, efficient, and elegant implementation of the Minkowski-sum constructions and the related applications. These software components are provided through a package of the Computational Geometry Algorithm Library (CGAL) called Arrangement_on_surface_ 2. We also present exact implementations of other applications that exploit arrangements of arcs of great circles embedded on the sphere. We use them as basic blocks in an exact implementation of an efficient algorithm that partiti ons an assembly of polyhedra in 3 D with two hands using infinite translations. This application distinctly shows the importance of exact computation, as imprecise computation might result with dismissal of valid partitioning-motions...|$|R
50|$|The {{input stage}} with Q1 and Q3 {{is similar to}} an emitter-coupled pair (long-tailed pair), with Q2 and Q4 adding some <b>degenerating</b> {{impedance}}. The <b>input</b> impedance is relatively high {{because of the small}} current through Q1-Q4.A typical 741 op amp has an differential input impedance of about 2 M&Omega;. The common mode input impedance is even higher, as the input stage works at an essentially constant current.|$|R
