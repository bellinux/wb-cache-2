0|12|Public
5000|$|... // <b>debugging</b> <b>macros</b> {{so we can}} {{pin down}} message origin at a glance#define WHERESTR [...] "%s, line %d: [...] "#define WHEREARG __FILE__, __LINE__#define DEBUGPRINT2(...) fprintf(stderr, __VA_ARGS__)#define DEBUGPRINT(_fmt, ...) DEBUGPRINT2(WHERESTR _fmt, WHEREARG, __VA_ARGS__)//... DEBUGPRINT("hey, x=%d\n", x); ...|$|R
40|$|This {{technical}} report gathers together three papers that were written during 1992 and 1993 and submitted {{for publication in}} ACM Lisp Pointers. Chapter 1 "Using the New Common Lisp Pretty Printer" explains how the pretty printing facilities that have been adopted {{as part of the}} forthcoming Common Lisp standard can be used to gain detailed control over the printing of lists. As an example, it shows how the pretty printer can be used to print a subset of Lisp as Pascal. Chapter 2 "Macroexpand-All: An Example of a Simple Lisp Code Walker" presents a function macroexpand-all for expanding all the macro calls in a Lisp expression. This is useful when <b>debugging</b> <b>macros</b> and can be helpful as a subroutine when writing complex macros. In addition, the chapter serves as an introduction to code walkers [...] -the general class of programs of which macroexpand-all is an example. Code walkers are important because they are {{a vital part of the}} foundation of many Lisp programming tools and macro packages. [...] ...|$|R
40|$|The macro {{facility}} {{is an important}} feature of the SAS Language. Mastering this facility will enable the novice user to become an accomplished programmer. This tutorial session will use a building block approach taking the user from the most basic %LET statements to parameter driven, code generating macros that can save time and effort. In most SAS applications for the social sciences or business {{there is a great}} deal of data manipulation to prepare for the tasks at hand whether it involves reporting, data warehousing, or statistics. The use of Macros will reduce the repetitiveness of manipulating data and will facilitate uniform and easy maintenance of the system. This paper will use step by step examples to show the user how to use macro substitution to provide simple yet powerful SAS code. The user will learn how to create variables on the fly, and how to use the macro facility to generate code. We will explore the way macros relate to SAS code and how to avoid common errors and easily <b>debug</b> <b>macros...</b>|$|R
5000|$|Libcwd {{provides}} several macros {{that are}} easily extensible, allowing {{the user to}} basically do anything that one can normally do with ostreams. However, if one just wants to write <b>debug</b> output, two <b>macros</b> will suffice: Dout and DoutFatal. The latter {{is to be used}} for fatal debug output, after which the application needs to be terminated. For example: if (error) DoutFatal(dc::fatal, [...] "An unrecoverable error occurred.");The difference with Dout is that when the application is compiled without <b>debug</b> code, the <b>macro</b> Dout (...) is replaced with nothing, while DoutFatal (...) is replaced with code that prints its output and terminates (in a way that the user can define).|$|R
40|$|We {{have found}} {{spreadsheets}} very useful for teaching statistics, operations research, and other quantitative methods in commerce: students learn quickly when typing and <b>debugging</b> formulae and <b>macros,</b> {{and get a}} real feeling for the relation between computation and theory. However, after a while, {{it is necessary to}} tum to...|$|R
2500|$|Assembly {{language}} {{has long been}} the primary development language for many popular home computers of the 1980s and 1990s (such as the MSX, [...] Sinclair ZX Spectrum, Commodore 64, Commodore Amiga, and Atari ST). This was in large part because interpreted BASIC dialects on these systems offered insufficient execution speed, as well as insufficient facilities {{to take full advantage of}} the available hardware on these systems. Some systems even have an integrated development environment (IDE) with highly advanced <b>debugging</b> and <b>macro</b> facilities. Some compilers available for the Radio Shack TRS-80 and its successors had the capability to combine inline assembly source with high-level program statements. Upon compilation a built-in assembler produced inline machine code.|$|R
40|$|Passwords {{are things}} {{not to be}} shared. As good SAS ® programmers we don't hard-code our {{passwords}} in our programs, but keep them in separate files or macro variables. However this is not enough! Unfortunately the casual (or malicious) user can "turn on " <b>macro</b> <b>debugging</b> utilities like MPRINT, MLOGIC or SYMBOLGEN and literally read our password right from the LOG, in plain view. This paper presents a series of simple methods to keeping your secret password secret when accessing remote databases with PROC SQL...|$|R
40|$|Over {{the past}} two decades, Scheme macros have evolved into a {{powerful}} API for the compiler front-end. Like Lisp macros, their predecessors, Scheme macros expand source programs into a small core language; unlike Lisp systems, Scheme macro expanders preserve lexical scoping, and advanced Scheme macro systems handle other important properties such as source location. Using such macros, Scheme programmers now routinely develop the ultimate abstraction: embedded domain-specific programming languages. Unfortunately, a typical Scheme programming environment provides little support for macro development. This lack {{makes it difficult for}} programmers to <b>debug</b> their <b>macros</b> and for novices to study the behavior of macros. In response, we have developed a stepping debugger specialized to the concerns of macro expansion. This debugger presents the macro expansion process as a linear rewriting sequence of annotated terms; it graphically illustrates the binding structure of the program as expansion reveals it; and it adapts to the programmer’s level of abstraction, hiding details of syntactic forms that the programmer considers built-in...|$|R
40|$|Over {{the past}} two decades, Scheme macros have evolved into a pow-erful API for the {{compiler}} front-end. Like Lisp macros, their predecessors, Scheme macros expand source programs into a small core language; unlike Lisp systems, Scheme macro expanders preserve lexical scoping, and advanced Scheme macro systems handle other important properties such as source location. Using such macros, Scheme programmers now routinely develop the ultimate abstraction: embedded domain-specific programming languages. Unfortunately, a typical Scheme programming environment provides little support for macro development. The tools for understanding macro expansion are poor, which {{makes it difficult for}} experienced programmers to <b>debug</b> their <b>macros</b> and for novices to study the behavior of macros. At the same time, the language for specifying macros is limited in expressive power, and it fails to validate syntactic correctness of macro uses. This dissertation presents tools for macro development that specifically address these two needs. The first is a stepping debugger specialized to the pragmatics of hygienic macros. The second is a system for writing macros and specifying syntax that automatically validates macro uses and reports syntax errors...|$|R
40|$|We {{have found}} {{spreadsheets}} very useful for teaching statistics, operations research, and other quantitative methods in commerce: students learn quickly when typing and <b>debugging</b> formulae and <b>macros,</b> {{and get a}} real feeling for the relation between computation and theory. However, after a while, {{it is necessary to}} tum to a more traditional statistical package to find both standard and advanced procedures needed for real~world data examination. WEST AT Associates has developed the MASS system for some years, a stand-alone statistical package of some size and power, and we have used it extensively for teaching, at second course but not at introductory level. In the past six months we (1. 5 persons) have ported it to sit on the new spreadsheet WingZ (by Informix Inc) on the Mac to form a new program StatZ, which combines the advantages of a spreadsheet and a specialised program for the teaching and practice of statistics. (See Section 3 (ii) for other computers.) Porting a program from one language or machine or system to another is usually a painful exercise. However, the power and flexibility of the "scripting" and of the facilities for linking external code provided by WingZ and its Hyper Script macro language, which we have used for incorporating our MASS code into their highly commercial, well-tested base ptoduct, seems destined to {{have a profound effect on}} related areas of program development. This will yield new research and teaching software, as already pioneered by Apple's HyperCard, the technical precursor of WingZ's HyperScript...|$|R

