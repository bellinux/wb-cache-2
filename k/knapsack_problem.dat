1823|388|Public
25|$|The {{quadratic}} <b>knapsack</b> <b>problem</b> (QKP) maximizes a quadratic {{objective function}} {{subject to a}} binary and linear capacity constraint.|$|E
25|$|As {{with many}} useful but {{computationally}} complex algorithms, {{there has been}} substantial research on creating and analyzing algorithms that approximate a solution. The <b>knapsack</b> <b>problem,</b> though NP-Hard, {{is one of a}} collection of algorithms that can still be approximated to any specified degree. This means that the problem has a polynomial time approximation scheme. To be exact, the <b>knapsack</b> <b>problem</b> has a fully polynomial time approximation scheme (FPTAS).|$|E
25|$|Neal Stephenson {{provides}} an example of the <b>knapsack</b> <b>problem</b> in chapter 70 of his novel Cryptonomicon to distribute family heirlooms.|$|E
40|$|We briefly {{describe}} {{genetic algorithms}} (GAs) and {{focus attention on}} initial population generation methods for twodimensional <b>knapsack</b> <b>problems.</b> Based on work describing the probability a random solution vector is feasible for 0 - 1 <b>knapsack</b> <b>problems,</b> we propose a simple heuristic for randomly generating good initial populations for genetic algorithm applications to two-dimensional <b>knapsack</b> <b>problems.</b> We report on an experiment comparing a current population generation technique with our proposed approach and find our proposed approach does {{a very good job}} of generating good initial populations...|$|R
40|$|A simple {{algorithm}} is described for {{the reduction of}} 0 - 1 single <b>knapsack</b> <b>problems</b> to significantly smaller problems. The time required by the reduction {{algorithm is}} proportional to the number of variables. When used in conjunction with available algorithms for <b>knapsack</b> <b>problems</b> it substantially reduces total time and space requirements. ...|$|R
40|$|When solving {{large-scale}} multiobjective optimization problems, solvers can {{get stuck}} with the memory or time limit. In such cases, one is left with no information how far is the best feasible solution, found before the optimization process has stopped, to the true Pareto optimal solution. In this work, we show how to provide such information when solving multiobjective multidimensional <b>knapsack</b> <b>problems</b> by a commercial mixed-integer linear solver. We illustrate the proposed approach on biobjective multidimensional <b>knapsack</b> <b>problems</b> derived from singleobjective multidimensional <b>knapsack</b> <b>problems</b> from the Beasley OR Library. Comment: Section 6. 1 needs major corrections. 28 pages, 5 figures, 8 tables, 31 referenc...|$|R
25|$|The {{decision}} problem {{form of the}} <b>knapsack</b> <b>problem</b> (Can a value of at least V be achieved without exceeding the weight W?) is NP-complete, thus there is no known algorithm both correct and fast (polynomial-time) on all cases.|$|E
25|$|While many {{algorithms}} {{reach an}} exact solution, approximation algorithms seek an approximation that {{is closer to}} the true solution. Approximation can be reached by either using a deterministic or a random strategy. Such algorithms have practical value for many hard problems. One of the examples of an approximate algorithm is the <b>Knapsack</b> <b>problem.</b> The <b>Knapsack</b> <b>problem</b> is a problem where there is a set of given items. The goal of the problem is to pack the knapsack to get the maximum total value. Each item has some weight and some value. Total weight that we can carry is no more than some fixed number X. So, we must consider weights of items as well as their value.|$|E
25|$|There {{are many}} {{variations}} of the <b>knapsack</b> <b>problem</b> that have arisen from the vast number of applications of the basic problem. The main variations occur by changing the number of some problem parameter such {{as the number of}} items, number of objectives, or even the number of knapsacks.|$|E
40|$|Abstract—The {{implementation}} via CUDA of {{a hybrid}} dense dynamic programming method for <b>knapsack</b> <b>problems</b> on a multi-GPU architecture is considered. Tests {{are carried out}} on a Bull cluster with Tesla S 1070 computing systems. A first series of computational results shows substantial speedup close to 30 with two GPUs. Keywords-hybrid computing, multi GPU architectures, CUDA, dynamic programming, <b>knapsack</b> <b>problems,</b> combinatorial optimization. I...|$|R
30|$|This {{paper is}} {{motivated}} by several features. First, incorporating the rough set with bat algorithm to solve large-scale 0 – 1 KP has not been yet studied. Second, many optimization algorithms suffer from entanglement in local optima when solving large-scale problems. Last, solving large-scale <b>knapsack</b> <b>problems</b> have not received adequate attention yet. Hence solving large-scale <b>knapsack</b> <b>problems</b> to optimality undoubtedly becomes a true challenge.|$|R
40|$|AbstractWe {{consider}} {{the problem of}} minimizing a quadratic function with a knapsack constraint. Quadratic <b>knapsack</b> <b>problems</b> have numerous applications, including the least distance problem, quadratic programming defined on the convex hull {{of a set of}} points, and the maximum clique problem. We propose and analyze three algorithms for solving quadratic <b>knapsack</b> <b>problems.</b> Two algorithms are based on recently developed interior point methods. The first solves convex quadratic problems, and the second computes a stationary point for the indefinite case. For both, computational results on a variety of test problems are presented. The third algorithm, based on simplicial partitioning and convex underestimating functions, can be used to compute the global optimum of indefinite quadratic <b>knapsack</b> <b>problems...</b>|$|R
25|$|The <b>knapsack</b> <b>problem</b> occurs {{commonly}} in role-playing games, both {{digital and}} paper-based (prominent examples include The Elder Scrolls series and the Dungeons and Dragons game, respectively), where the player character is constrained by their encumbrance threshold when carrying items and treasure, which regularly forces the player {{to evaluate the}} items' value-to-weight ratio {{in order to bring}} only the most value-dense items to a merchant.|$|E
25|$|The <b>knapsack</b> <b>problem</b> or {{rucksack}} {{problem is}} a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is {{less than or equal to}} a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most valuable items.|$|E
25|$|The fully {{polynomial}} time approximation scheme (FPTAS) for the <b>knapsack</b> <b>problem</b> {{takes advantage of}} the fact that the reason the problem has no known {{polynomial time}} solutions is because the profits associated with the items are not restricted. If one rounds off some of the least significant digits of the profit values then they will be bounded by a polynomial and 1/ε where ε is a bound on the correctness of the solution. This restriction then means that an algorithm can find a solution in polynomial time that is correct within a factor of (1-ε) of the optimal solution.|$|E
40|$|To {{enhance the}} {{performance}} of harmony search (HS) algorithm on solving the discrete optimization problems, this paper proposes a novel harmony search algorithm based on teaching-learning (HSTL) strategies to solve 0 - 1 <b>knapsack</b> <b>problems.</b> In the HSTL algorithm, firstly, a method is presented to adjust dimension dynamically for selected harmony vector in optimization procedure. In addition, four strategies (harmony memory consideration, teaching-learning strategy, local pitch adjusting, and random mutation) are employed to improve {{the performance of}} HS algorithm. Another improvement in HSTL method is that the dynamic strategies are adopted to change the parameters, which maintains the proper balance effectively between global exploration power and local exploitation power. Finally, simulation experiments with 13 <b>knapsack</b> <b>problems</b> show that the HSTL algorithm can be an efficient alternative for solving 0 - 1 <b>knapsack</b> <b>problems...</b>|$|R
25|$|Several {{algorithms}} {{are available}} to solve <b>knapsack</b> <b>problems,</b> based on dynamic programming approach, branch and bound approach or hybridizations of both approaches.|$|R
40|$|Abstract—This paper {{proposes a}} multi-objective {{membrane}} algorithm, called MOMA, for solving multi-objective <b>knapsack</b> <b>problems.</b> MOMA is designed with the framework and rules of a cell-like P system, and concepts {{and principles of}} quantuminspired evolutionary algorithms. Three bench <b>knapsack</b> <b>problems</b> used frequently in the literature are applied to test MOMA performance. Experimental results show that MOMA outperforms its counterpart quantum-inspired evolutionary algorithm and several good multi-objective evolutionary algorithms reported in the literature, in terms of Pareto front and performance measures. I...|$|R
25|$|However, this {{identification}} is inexact: a polynomial-time solution with large exponent or large constant term grows quickly, {{and may be}} impractical for practical size problems; conversely, an exponential-time solution that grows slowly may be practical on realistic input, or a solution that {{takes a long time}} in the worst case may take a short time in most cases or the average case, and thus still be practical. Saying that a problem is not in P does not imply that all large cases of the problem are hard or even that most of them are. For example, the decision problem in Presburger arithmetic has been shown not to be in P, yet algorithms have been written that solve the problem in reasonable times in most cases. Similarly, algorithms can solve the NP-complete <b>knapsack</b> <b>problem</b> over a wide range of sizes in less than quadratic time and SAT solvers routinely handle large instances of the NP-complete Boolean satisfiability problem.|$|E
2500|$|... nonnegative integers, the <b>knapsack</b> <b>problem</b> can {{be solved}} in pseudo-polynomial time using dynamic programming. The {{following}} describes a dynamic programming solution for the unbounded <b>knapsack</b> <b>problem.</b>|$|E
2500|$|The {{quadratic}} <b>knapsack</b> <b>problem</b> (QKP), {{first introduced}} in 19th century, ...|$|E
30|$|The <b>knapsack</b> {{feasibility}} <b>problems</b> {{have been}} intensively studied {{both because of}} their immediate applications in industry and financial management, but more pronounced for theoretical reasons, as <b>knapsack</b> <b>problems</b> frequently occur by relaxation of various integer programming problems. In this work, the large-scale <b>knapsack</b> feasibility <b>problem</b> {{is divided into two}} subproblems. The first subproblem is transforming of the <b>knapsack</b> feasibility <b>problem</b> into a polytope judgement problem which is based on lattice basis reduction. In the next subproblem, a distributed implementation of Dang and Ye’s fixed-point iterative algorithm is introduced to solve the polytope judgement problem generated in the former subproblem. Compared with the branch and bound method, numerical results show that this distributed fixed-point method is effective.|$|R
40|$|The <b>knapsack</b> <b>problems</b> are {{a classic}} NP-hard {{problem in the}} combinational optimization. Inspired by the {{conclusion}} of the cognitive psychology about the human memory system, a Tabu Search method based on Double Tabu-List (DTL-TS) has been proposed to solve it. With the addition of the search strategy of intensification and diversification, the excellent experiment results have been gotten. Compared with ImmunoDominance Clone Algorithm, DTL-TS is shown to be an efficient approach of solving complex problems like 0 - 1 multidimensional <b>knapsack</b> <b>problems.</b> Key words...|$|R
40|$|Cataloged from PDF {{version of}} article. In this thesis, the {{potential}} {{use of a}} recently proposed cut (the search based cut) for 0 - 1 programming problems by Oguz (2002) is analyzed. For this purpose, the search based cuts and a new algorithm based on the search based cuts are applied to multidimensional 0 - 1 <b>knapsack</b> <b>problems</b> from the literature as well as randomly generated multidimensional 0 - 1 <b>knapsack</b> <b>problems.</b> The results are compared {{with the implementation of}} CPLEX v 8. 1 in MIP mode and the results reported. Pekbey, DuyguM. S...|$|R
2500|$|The <b>knapsack</b> <b>problem</b> is {{interesting}} {{from the perspective}} of computer science for many reasons: ...|$|E
2500|$|The {{quadratic}} <b>knapsack</b> <b>problem</b> {{was discussed}} under that title by Gallo, Hammer, and Simeone in 1980. [...] However, Gallo and Simeone attribute the first {{treatment of the}} problem to Witzgall in 1975.|$|E
2500|$|A 1998 {{study of}} the [...] showed that, out of 75 {{algorithmic}} problems, the <b>knapsack</b> <b>problem</b> was the 18th most popular and the 4th most needed after kd-trees, suffix trees, and the bin packing problem.|$|E
40|$|This paper {{proposes a}} novel global harmony search {{algorithm}} (NGHS) to solve 0 – 1 <b>knapsack</b> <b>problems.</b> The proposed algorithm includes two important operations: position updating and genetic mutation {{with a small}} probability. The former enables the worst harmony of harmony memory {{to move to the}} global best harmony rapidly in each iteration, and the latter can effectively prevent the NGHS from trapping into the local optimum. Computational experiments with a set of large-scale instances show that the NGHS can be an efficient alternative for solving 0 – 1 <b>knapsack</b> <b>problems.</b> ...|$|R
40|$|We present how {{to apply}} Constraint Based Column Generation to a large class of subproblems, namely Constrained <b>Knapsack</b> <b>Problems</b> (CKP). They evolve e. g. from Cutting Stock Problems (see [7]) with {{additional}} constraints on the cutting patterns. Focussing on Constrained <b>Knapsack</b> <b>Problems,</b> we developed a new reduction algorithm for KP. It is being used as propagation routine for the CKP with O(n log n) preprocessing time and O(n) time per call. This sums up to an amortized time of O(n) for (log n) calls. Keywords: Constrained Based Column Generation, Constrained <b>Knapsack</b> <b>Problems,</b> Cutting Stock Problems, Reduction Algorithms. 1 Introduction Recently, a new framework for the integration of CP and OR within column generation approaches was developed, the so called Constraint Based Column Generation [11]. It describes a generic way of how to treat arbitrary constraints for the constrained subproblem in the column generation phase. The approach has been successfully used for the C [...] ...|$|R
40|$|Differential {{evolution}} (DE) {{is one of}} {{the most}} popular and powerful evolutionary algorithms for the real-parameter global continuous optimization problems. However, how to adapt into combinatorial optimization problems without sacrificing the original evolution mechanism of DE is harder work to the researchers to design an efficient binary differential evolution (BDE). To tackle this problem, this paper presents a novel BDE based on dichotomous mechanism for <b>knapsack</b> <b>problems,</b> called DBDE, in which two new proposed methods (i. e., dichotomous mutation and dichotomous crossover) are employed. DBDE almost has any difference with original DE and no additional module or computation has been introduced. The experimental studies have been conducted on a suite of 0 - 1 <b>knapsack</b> <b>problems</b> and multidimensional <b>knapsack</b> <b>problems.</b> Experimental results have verified the quality and effectiveness of DBDE. Comparison with three state-of-the-art BDE variants and other two state-of-the-art binary particle swarm optimization (PSO) algorithms has proved that DBDE is a new competitive algorithm...|$|R
2500|$|The bounded <b>knapsack</b> <b>problem</b> (BKP) {{removes the}} {{restriction}} {{that there is}} only one of each item, but restricts the number [...] of copies of each kind of item to a maximum non-negative integer value : ...|$|E
2500|$|One {{example of}} the {{unbounded}} <b>knapsack</b> <b>problem</b> is given using the figure shown {{at the beginning of}} this article and the text [...] "if any number of each box is available" [...] in the caption of that figure.|$|E
2500|$|The {{unbounded}} <b>knapsack</b> <b>problem</b> (UKP) places no {{upper bound}} {{on the number of}} copies of each kind of item and can be formulated as above except for that the only restriction on [...] {{is that it is a}} non-negative integer.|$|E
40|$|Abstract: A new repair method {{based on}} QEA for 0 / 1 <b>knapsack</b> <b>problems</b> is proposed. In this approach, the qubit {{chromosome}} {{is used as}} heuristic knowledge to evaluate each element for the knapsack. The main idea is to delete the knapsack elements in the ascending order of qubit chromosome’s probability value whilst avoid violating the constraints on its capacity. To minimize the influence of initialization, three different methods are adopted for obtaining the initial probability. Experimental {{results showed that the}} proposed method is promising. Key-Words: Quantum-inspired evolutionary algorithm, repair algorithm, 0 / 1 <b>knapsack</b> <b>problems</b> 1...|$|R
40|$|The Knapsack Cryptosystem of Merkle and Hellman, 1978, {{is one of}} the {{earliest}} public-key cryptography schemes. The security of the method relies on the difficulty in solving Subset Sum Problems (also known as <b>Knapsack</b> <b>Problems).</b> In this paper, we first provide a brief history of knapsack-based cryptosystems and their cryptanalysis attacks. Following that, we review the advances in integer programming approaches to 0 − 1 <b>Knapsack</b> <b>Problems,</b> with a focus on the polyhedral studies of the convex hull of the integer set. Last of all, we discuss potential future research directions in applying integer programming in the cryptanalysis of knapsack ciphers...|$|R
40|$|International audienceIn this paper, {{we propose}} {{a method to}} solve exactly the <b>knapsack</b> sharing <b>problem</b> (KSP) by using dynamic programming. The {{original}} problem (KSP) is decomposed into a set of <b>knapsack</b> <b>problems.</b> Our method is tested on correlated and uncorrelated instances from the literature. Computational results show that our method is able to find an optimal solution of large instances within reasonable computing time and low memory occupancy...|$|R
