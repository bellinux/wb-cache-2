100|646|Public
2500|$|<b>Generic</b> <b>interfaces</b> and delegates {{can have}} their type {{parameters}} marked as covariant or contravariant, using keywords [...] and , respectively. These declarations are then respected for type conversions, both implicit and explicit, and both compile-time and run-time. For example, the existing interface [...] has been redefined as follows: ...|$|E
5000|$|Because many {{unit testing}} tools rely on {{inheritance}} to accomplish mocking, {{the usage of}} <b>generic</b> <b>interfaces</b> between classes (not only between modules when {{it makes sense to}} use generality) became the rule.|$|E
5000|$|Libdmc [...] is {{a library}} {{designed}} at the LIP6 [...] laboratory. Its {{goal is to}} ease the distribution of existing model checkers. It has also been designed to provide the most <b>generic</b> <b>interfaces,</b> without sacrificing performance, thanks to the C++ language.|$|E
5000|$|A <b>generic</b> <b>interface</b> and its {{corresponding}} generic module, prefix the [...] or [...] keyword with , {{and take}} as formal arguments other interfaces. Thus (like C++ templates) {{one can easily}} define and use abstract data types,but unlike C++, the granularity is at the module level.An interface is passed to the <b>generic</b> <b>interface</b> and implementation modules as actual arguments, and thecompiler will generate concrete modules.|$|R
40|$|HepRep, the <b>Generic</b> <b>Interface</b> Definition for HEP Event Display Representables, {{forms the}} central part of a {{complete}} <b>generic</b> <b>interface</b> for client server event displays. The HepRep interface supports all of the desirable features of a client server event display, provides for the correct distribution of computing work between the two parts of the system and effectively addresses the many important maintenance issues involved in such a system...|$|R
40|$|Many {{different}} constraint programming (CP) systems exist today. For each CP system, {{there are}} many dierent ltering algorithms. Researchers and developers usually choose a CP system of their choice to implement their filtering algorithms. To use these ltering algorithms on another system, we have to port the code over. This situation is clearly not desirable. In this paper, we propose a <b>generic</b> C++ <b>interface</b> for writing ltering algorithms called GIFT (<b>Generic</b> <b>Interface</b> for FilTers). By providing the <b>generic</b> <b>interface</b> on different CP systems, we can reuse any filtering algorithms easily. A case study on reusing scheduling filtering algorithms between Mozart and Figaro further highlights the feasibility of this approach...|$|R
5000|$|Implementing <b>generic</b> <b>interfaces</b> {{everywhere}} {{in a project}} makes it by far harder to understand and maintain. At each step the reader will ask themself what are the other implementations of this interface and the response is generally : only mocks.|$|E
5000|$|On Solaris it is {{possible}} to control bindings of processes and LWPs to processor using the pbind(1) [...] program. To control the affinity programmatically processor_bind(2) [...] can be used. There are more <b>generic</b> <b>interfaces</b> available such as pset_bind(2) [...] or lgrp_affinity_get(3LGRP) [...] using processor set and locality groups concepts.|$|E
50|$|Covariance and contravariance is {{supported}} by both languages. Java has use-site variance that allows a single generic class to declare members using both co- and contravariance. C# has define-site variance for <b>generic</b> <b>interfaces</b> and delegates. Variance is unsupported directly on classes but {{is supported}} through their implementation of variant interfaces. C# also has use-site covariance support for methods and delegates.|$|E
50|$|Persistency {{provides}} abstraction at {{the storage}} level. This <b>generic</b> <b>interface</b> {{can be used}} to implement any data-saving back-end, as long as transaction mechanism is provided.|$|R
5000|$|Introspection {{support for}} core {{libraries}} allowing external applications to query, get, set and operate on all {{classes in the}} scene graph, via a <b>generic</b> <b>interface</b> ...|$|R
50|$|A type {{variable}} is an unqualified identifier. Type variables are introduced by generic class declarations, <b>generic</b> <b>interface</b> declarations, <b>generic</b> method declarations, and by generic constructor declarations.|$|R
50|$|Another {{benefit of}} {{modularity}} {{is the use}} of <b>generic</b> <b>interfaces</b> for plug-ins. A single interface may be developed which allows old as well as new modules to be integrated seamlessly at run-time into pre-existing applications, without any modification to the application itself. This concept of dynamic extensibility is taken to the extreme with the Component Object Model, the underpinnings of ActiveX.|$|E
5000|$|... {{is an open}} {{standard}} {{developed by}} the World Wide Web Consortium since 2005. It was published as a Recommendation of the W3C on October 25, 2012. The document is a technical report specifying a multimodal system architecture and its <b>generic</b> <b>interfaces</b> to facilitate integration and multimodal interaction management in a computer system. It has been developed by the W3C's Multimodal Interaction Working Group.|$|E
50|$|There is an {{overlap with}} the naked objects pattern, in that both are {{concerned}} with creating <b>generic</b> <b>interfaces</b> to domain objects models. But while the latter creates some kind of user interface, Restful Objects creates an API - specifically a Restful API. The first two frameworks to implement the Restful Objects standard were both built on top of existing frameworks that implement the Naked Objects pattern.|$|E
50|$|<b>Generic</b> <b>Interface</b> Definition {{is a set}} {{of common}} {{services}} used for enterprise integration in the utility industry. It is defined in IEC standard IEC 61970 Part 4.|$|R
50|$|PKCS#11 is an API {{designed}} to be platform-independent, defining a <b>generic</b> <b>interface</b> to cryptographic tokens such as smart cards. This allows applications to work without knowledge of the reader details.|$|R
5000|$|The Change Management Interface (CMI): CMI {{provides}} a <b>generic</b> <b>interface</b> for associating tasks with element versions and UCM activities. CMI can be configured {{to support the}} task providers ClearQuest, Rational Team Concert, and JIRA.|$|R
5000|$|The Location API is {{designed}} to work with many different positioning methods. <b>Generic</b> <b>interfaces</b> lets application developers implement systems that can retrieve location data from multiple sources, based on their availability on the device. It has advantages over a single means of tracking, including fail-over, indoor/outdoor transparency, and a choice between the speed and accuracy trade-offs between GPS, cellular, or other positioning methods. The API supports: ...|$|E
50|$|MessagePlus/Open {{provides}} generic {{and application}} specific integration options. The <b>generic</b> <b>interfaces</b> {{can be used}} by any backend application, but require some programming effort. Examples are the data exchange through relational databases like IBM DB2 and Oracle Database, middleware like IBM WebSphere MQ, or a file interface. Application specific interfaces exploit product specific APIs like e.g. the RFC architecture of SAP. In addition interfaces are provided for legacy applications and available end-user interfaces include e-mail, a Client, and virtual printer.|$|E
50|$|OptiY is an {{open and}} {{multidisciplinary}} design environment, which provides direct and <b>generic</b> <b>interfaces</b> to many CAD/CAE-systems and house-intern codes. Furthermore, a complex COM-interface and a user-node with predefined template are available so that user can self-integrate extern programs for ease of use. The insertion of any system to an arbitrary process chain is very easy using the graphical workflow editor. Collaborating different simulation model classes is possible as networks, finite-element-method, multi-body-system, material test bench etc.|$|E
30|$|Bounded set {{reconciliation}} {{is implemented}} in the SET service. The SET service provides a <b>generic</b> <b>interface</b> for set operations between two peers; the operations currently implemented are the IBF-based set reconciliation and set intersection [54].|$|R
30|$|Flexibility. A <b>generic</b> user <b>interface</b> {{should be}} based on generic data models which are {{flexible}} to deal with different building operating systems. A <b>generic</b> user <b>interface</b> is not specifically designed for a particular building operating system, but on the contrary, the architecture of the <b>generic</b> user <b>interface</b> should be loosely coupled with its underlying building operating system, so that it is flexible enough to apply to different household buildings with different kinds of devices.|$|R
50|$|NIOS neither {{required}} nor used DPMS or Cloaking directly, {{and it did}} {{not provide}} a <b>generic</b> <b>interface</b> which could be used by non-NLM modules, however, it was certainly inspired by the DPMS technology and it can coexist with both of them.|$|R
50|$|The {{abstract}} factory pattern {{provides a}} way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects {{that are part of}} the theme. The client doesn't know (or care) which concrete objects it gets from each of these internal factories, since it uses only the <b>generic</b> <b>interfaces</b> of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface.|$|E
30|$|Composition {{could include}} {{previously}} unknown services that implement certain <b>generic</b> <b>interfaces.</b>|$|E
30|$|<b>Generic</b> <b>interfaces</b> to {{exchange}} information across the protocol stack have been defined.|$|E
40|$|Many di#erent {{constraint}} programming (CP) systems exist today. For each CP system, {{there are}} many di#erent filtering algorithms. Researchers and developers usually choose a CP system of their choice to implement their filtering algorithms. To use these filtering algorithms on another system, we have to port the code over. This situation is clearly not desirable. In this paper, we propose a <b>generic</b> C++ <b>interface</b> for writing filtering algorithms called GIFT (<b>Generic</b> <b>Interface</b> for FilTers). By providing the <b>generic</b> <b>interface</b> on di#erent CP systems, we can reuse any filtering algorithms easily. A case study on reusing scheduling filtering algorithms between Mozart and Figaro further highlights the feasibility of this approach. 1 Introduction Today many programming systems and libraries make extensive use of the constraint programming technology. Examples include ILOG [ILO 97 b], CHIP [BSKC 97], GNU Prolog [DC 00], CLAIRE [CJL 99], Mozart [Moz 99]. A central theme of these recent CP [...] ...|$|R
5000|$|... • Grid Handler Interface: {{this is a}} <b>generic</b> <b>interface</b> {{above the}} grid plugins. By using this generic layer, no 3G Bridge {{components}} other than the grid plugins must contain grid-specific code. The methods a grid plugin should implement is: submission and status update.|$|R
50|$|The {{purpose of}} Pspell (Portable Spell Checker Interface Library) {{was to provide}} a <b>generic</b> <b>interface</b> to the system {{spelling}} checking libraries. It was, and sometimes still is, used in computer programming such as C, and is licensed under the GNU Lesser General Public License.|$|R
40|$|Abstract: Cognitive {{wireless}} {{networks are}} envisioned {{as a solution}} for intelligent ubiquitous networks {{that are capable of}} adapting to the dynamic environment through programmable radio devices. Each functional module and protocol accomplishes such learning by observing the various environmental, networking and application related parameters and adapts its behaviour to improve the performance. While access to a variety of parameters provide a large margin to improve the performance, it hinders the practical use of the system by restricting portability. In this paper, we argue that standard <b>generic</b> <b>interfaces</b> can be effectively used to overcome the above problem and enable seamless communication between modules at different layers and radio technologies. We examine the various parts of a cognitive wireless network, categorise different types of <b>generic</b> <b>interfaces,</b> analyse the suitable abstractions, and propose architectural principles for a cognitive radio system. We discuss four such categories of <b>generic</b> <b>interfaces</b> that abstract different layers of networking, application utility and policy enforcement. Various business benefits arising from such standard <b>generic</b> <b>interfaces</b> are briefly discussed. We believe that the proposed architecture and the benefits greatly enhance a feasible realisation of cognitive wireless networks. Keywords...|$|E
40|$|<b>Generic</b> <b>interfaces</b> to robot {{hardware}} {{can improve}} the programming process by {{making it easier for}} developers to port applications between different robotic systems. The Player project provides abstract interfaces to aide porting, but until recently did not have any direct support for robotic limbs. This paper describes the design and implementation of three new <b>generic</b> <b>interfaces</b> for robotic limbs and grippers: a low-level interface for controlling limb joints, a high-level interface for controlling end-effector pose, and an interface for controlling grippers. The design of the interfaces allows robot applications to quickly be ported between different robotic limbs and different robots. The interfaces are implemented in the Player project, with support provided in the driver for Pioneer robots, allowing the interfaces to be used to control the Pioneer robot arm and gripper. Other drivers are expected to be developed in the future, providing support for other robotic limbs. ...|$|E
40|$|International audienceObject algebras {{are a new}} {{programming}} {{technique that}} enables a simple solution to basic extensibility and modularity issues in programming languages. While object algebras excel at deﬁning modular features, the composition mechanisms for object algebras (and features) are still cumbersome and limited in expressiveness. In this paper we leverage two well-studied type system features, intersection types and type-constructor polymorphism, to provide object algebras with expressive and practical composition mechanisms. Intersection types are used for deﬁning expressive run-time composition operators (combinators) that produce objects with multiple (feature) interfaces. Type-constructor polymorphism enables <b>generic</b> <b>interfaces</b> for the various object algebra combinators. Such <b>generic</b> <b>interfaces</b> {{can be used as}} a type-safe front end for a generic implementation of the combinators based on reﬂection. Additionally, we also provide a modular mechanism to allow diﬀerent forms of self-references in the presence of delegation-based combinators. The result is an expressive, type-safe, dynamic, delegation-based composition technique for object algebras, implemented in Scala, which eﬀectively enables a form of Feature-Oriented Programming using object algebras...|$|E
5000|$|GenICam (abbreviated for <b>Generic</b> <b>Interface</b> for Cameras) is a <b>generic</b> {{programming}} <b>interface</b> for {{machine vision}} (industrial) cameras. The {{goal of the}} standard is to decouple industrial camera interfaces technology (such as GigE Vision or Camera Link) from the user application programming interface (API). GenICam {{is administered by the}} European Machine Vision Association (EMVA). The work on the standard began in 2003 [...] and the first module in GenICam, i.e., GenApi, was ratified in 2006 whereas the final module, i.e., GenTL was ratified in 2008.|$|R
5000|$|Browsing is an {{important}} principle in Moose, and it is supported in multiple ways as well. A <b>generic</b> <b>interface</b> enables the analyst to browse any model. To be able to specify specific browsers, Moose offers a generic engine that eases the specification through a specific fluent interface.|$|R
5000|$|<b>GENERIC</b> <b>INTERFACE</b> GenericStack(Element); (* Here Element.T is {{the type}} to be stored in the generic stack. *) TYPE T = Public OBJECT; Public = OBJECT METHODS init (...) : TStack; format (...) : TEXT; isEmpty (...) : BOOLEAN; count (...) : INTEGER; push(elm: Element.T); pop(VAR elem: Element.T): BOOLEAN; END; END GenericStack.|$|R
