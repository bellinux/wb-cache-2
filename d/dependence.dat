10000|8912|Public
5|$|At a {{particularly}} {{high risk for}} misuse and <b>dependence</b> are people {{with a history of}} alcoholism or drug abuse and/or <b>dependence</b> and people with borderline personality disorder.|$|E
5|$|Based on {{combined}} {{data from}} SAMHSA's 2004–2005 National Surveys on Drug Use & Health, {{the rate of}} past-year alcohol <b>dependence</b> or abuse among persons aged 12 or older varied by level of alcohol use: 44.7% of past month heavy drinkers, 18.5% binge drinkers, 3.8% past month non-binge drinkers, and 1.3% {{of those who did}} not drink alcohol in the past month met the criteria for alcohol <b>dependence</b> or abuse in the past year. Males had higher rates than females for all measures of drinking in the past month: any alcohol use (57.5% vs. 45%), binge drinking (30.8% vs. 15.1%), and heavy alcohol use (10.5% vs. 3.3%), and males were twice as likely as females to have met the criteria for alcohol <b>dependence</b> or abuse in the past year (10.5% vs. 5.1%).|$|E
5|$|Some of {{the largest}} world {{reserves}} of lithium and other rare metals are located in countries with strong resource nationalism, unstable governments or hostility to U.S. interests, raising concerns {{about the risk of}} replacing <b>dependence</b> on foreign oil with a new <b>dependence</b> on hostile countries to supply strategic materials.|$|E
40|$|Selected for {{presentation}} at the HiPEAC 2013 Conf. International audienceTo preserve the validity of loop nest transformations and parallelization, data-dependences need to be analyzed. Memory <b>dependences</b> come in two varieties: true <b>dependences</b> or false <b>dependences.</b> While true <b>dependences</b> must be satisfied {{in order to preserve}} the correct order of computations, false <b>dependences</b> are induced by the reuse of a single memory location to store multiple values. False <b>dependences</b> reduce the degrees of freedom for loop transformations. In particular, loop tiling is severely limited in the presence of these <b>dependences.</b> While array expansion removes all false <b>dependences,</b> the overhead on memory and the detrimental impact on register-level reuse can be catastrophic. We propose and evaluate a compilation technique to safely ignore a large number of false <b>dependences</b> in order to enable loop nest tiling in the polyhedral model. It is based on the precise characterization of interferences between live range intervals, and it does not incur any scalar or array expansion. Our algorithms have been implemented in the Pluto polyhedral compiler, and evaluated on the PolyBench suite...|$|R
40|$|Identifying and {{understanding}} data <b>dependences</b> {{is important for}} a variety of software-engineering tasks. The presence of pointers, arrays, and dynamic memory allocation introduces subtle and complex data <b>dependences</b> that may be difficult to understand. In this paper, we present a refinement of our previously developed classification that also distinguishes the types of memory locations, considers interprocedural data <b>dependences,</b> and further distinguishes such data <b>dependences</b> based on the kinds of interprocedura paths on which they occur. This new classification enables reasoning about the complexity of data <b>dependences</b> in programs using features such as pointers, arrays, and dynamic memory allocation. We present an algorithm for computing interprocedural data <b>dependences</b> according to our classification. To evaluate the classification, we compute the distribution of data <b>dependences</b> for a set of real C programs and we discuss how the distribution can be useful in understanding the characteristics of a program. We also evaluate how alias information provided by different algorithms, varying in precision, affects the distribution. Finally, we investigate how the classification can be exploited to estimate complexity of the data <b>dependences</b> in a program...|$|R
40|$|Data <b>dependences</b> are {{building}} blocks for techniques such as program slicing and, thus, are useful for program comprehension and debugging. Unfortunately, static analysis identifies many data <b>dependences</b> that are infeasible or unlikely to occur at runtime. Dynamic analysis, in contrast, does not identify all data <b>dependences</b> that can occur in a program. To address this inaccuracy, we present a new static analysis that predicts the likelihood of occurrence of data <b>dependences</b> to help engineers prioritize their inspection of those <b>dependences.</b> Our preliminary results indicate that our analysis, while having room for improvement, has a promising predictive power. 1...|$|R
5|$|The {{new group}} of drugs was {{initially}} greeted with optimism by the medical profession, but gradually concerns arose; in particular, the risk of <b>dependence</b> became evident in the 1980s. Benzodiazepines have a unique history in that they {{were responsible for the}} largest-ever class-action lawsuit against drug manufacturers in the United Kingdom, involving 14,000 patients and 1,800 law firms that alleged the manufacturers knew of the <b>dependence</b> potential but intentionally withheld this information from doctors. At the same time, 117 general practitioners and 50 health authorities were sued by patients to recover damages for the harmful effects of <b>dependence</b> and withdrawal. This led some doctors to require a signed consent form from their patients and to recommend that all patients be adequately warned of the risks of <b>dependence</b> and withdrawal before starting treatment with benzodiazepines. The court case against the drug manufacturers never reached a verdict; legal aid had been withdrawn and there were allegations that the consultant psychiatrists, the expert witnesses, had a conflict of interest. This litigation led to changes in the British law, making class action lawsuits more difficult.|$|E
5|$|Substance misuse, <b>dependence</b> and {{withdrawal}} {{are associated}} with self-harm. Benzodiazepine <b>dependence</b> as well as benzodiazepine withdrawal is associated with self-harming behaviour in young people. Alcohol is a major risk factor for self-harm. A study which analysed self-harm presentations to emergency rooms in Northern Ireland found that alcohol was a major contributing factor and involved in 63.8% of self-harm presentations. A recent study in the relation between cannabis use and deliberate self-harm (DSH) in Norway and England found that, in general, cannabis use {{may not be a}} specific risk factor for DSH in young adolescents.|$|E
5|$|The benzodiazepines {{diazepam}} (Valium) and oxazepam (Serepax) {{have been}} found to produce fewer withdrawal reactions than alprazolam (Xanax), temazepam (Restoril/Normison), or lorazepam (Temesta/Ativan). Factors that determine the risk of psychological <b>dependence</b> or physical <b>dependence</b> and the severity of the benzodiazepine withdrawal symptoms during dose reduction of alprazolam include: dosage used, length of use, frequency of dosing, personality characteristics of the individual, previous use of cross-dependent/cross-tolerant drugs (alcohol or other sedative-hypnotic drugs), current use of cross-dependent/-tolerant drugs, use of other short-acting, high-potency benzodiazepines, and method of discontinuation.|$|E
40|$|Data <b>dependences,</b> which relate {{statements}} that compute data value to {{statements that}} use those values, {{are useful for}} automating a variety of program-comprehension-related activities, such as reverse engineering, impact analysis, and debugging. Unfortunately, data <b>dependences</b> are difficult to compute and understand {{in the presence of}} commonly-used language features such as pointers, arrays, and structures. To facilitate the comprehension of data <b>dependences</b> in programs that use such features, we define a technique for computing and classifying data <b>dependences</b> that takes into account the complexities introduced by specific language constructs. The classification that we present is finer-grained than previously proposed classification. Moreover, unlike previous work, we present empirical results that illustrate the distribution of data <b>dependences</b> for a set of C subjects. We also present a potential application for the proposed classification: program slicing. We propose a technique that allows for computing slices based on data-dependence types. This technique facilitates the use of slicing for understanding a program because a user can either incrementally augment a slice by incorporating data <b>dependences</b> based on their relevance, or focus on specific kinds of <b>dependences.</b> Finally, we present a case study that shows how the incremental computation of slices can (1) highlight subtle data <b>dependences</b> within a program, and (2) provide useful information about those <b>dependences...</b>|$|R
40|$|Abstract—Data <b>dependences</b> play {{a central}} role in program {{debugging}} and comprehension. They serve as building blocks for program slicing and statistical fault localization, among other debugging approaches. Unfortunately, static analysis reports many data <b>dependences</b> that, in reality, are infeasible or unlikely to occur at runtime. This phenomenon is exacerbated by the extensive use of pointers and object-oriented features in modern software. Dynamic analysis, in contrast, reports only data <b>dependences</b> that occur in an execution but misses all other <b>dependences</b> that can occur in the program. To tackle the imprecision of data-dependence analysis, we present a novel static analysis that predicts the likelihood of occurrence of data <b>dependences.</b> Although it is hard to predict execution frequencies accurately, our preliminary results suggest that our analysis can distinguish the data <b>dependences</b> most likely to occur from those less likely to occur, which helps engineers prioritize their inspection of <b>dependences</b> in slices. These are promising results that encourage further research. Keywords-data dependence; runtime prediction; static analysis; program slicing; I...|$|R
40|$|Abstract. In {{geometric}} constraints solving, {{the detection}} of <b>dependences</b> and the decomposition of the system into smaller subsystems are two important steps that characterize any solving process, but nowadays solvers, which are graph-based {{in most of the}} cases, fail to detect <b>dependences</b> due to geometric theorems and to decompose such systems. In this paper, we discuss why detecting all <b>dependences</b> between constraints is a hard problem and propose to use the witness method published recently to detect both structural and non structural <b>dependences.</b> We study various examples of constraints systems and show the promising results of the witness method in subtle <b>dependences</b> detection and systems decomposition. ...|$|R
25|$|Bromazepam {{shares with}} other benzodiazepines {{the risk of}} abuse, misuse, {{psychological}} <b>dependence</b> or physical <b>dependence.</b> A withdrawal study demonstrated both psychological <b>dependence</b> and physical <b>dependence</b> on bromazepam including marked rebound anxiety after 4 weeks chronic use. Those whose dose was gradually reduced experienced no withdrawal.|$|E
25|$|However, {{according}} to a 2014 report by the World Health Organizations Expert Committee on Drug <b>Dependence</b> '"....in many cases of tramadol <b>dependence,</b> a history of substance abuse is present....but....the evidence for physical <b>dependence</b> was considered minimal. Consequently, Tramadol is generally considered as a drug with low potential for <b>dependence.</b> In a recent German study (including a literature study, an analysis of two drug safety databases, and questionnaires analyses), the low abuse and low <b>dependence</b> potential of Tramadol were re-confirmed. The German expert group found a low prevalence of abuse or <b>dependence</b> in clinical practice in Germany, and concluded that Tramadol has a low potential for misuse, abuse, and <b>dependence</b> in Germany”.|$|E
25|$|Another way of {{extending}} <b>dependence</b> logic {{is to add}} some generalized quantifiers {{to the language of}} <b>dependence</b> logic. Very recently there has been some study of <b>dependence</b> logic with monotone generalized quantifiers and <b>dependence</b> logic with a certain majority quantifier, the latter leading to a new descriptive complexity characterization of the counting hierarchy.|$|E
40|$|The {{article is}} {{dedicated}} to designing of a subject-oriented method of making <b>dependences</b> between software metrics. Existing environments for making <b>dependences</b> are reviewed, and the conclusion about need for development of special environment for making <b>dependences</b> between software metrics is made. Article describes the experiments which defined specifics of a method, offers its scheme, and defined special features of the method. </p...|$|R
40|$|Inter-iteration <b>dependences</b> in loops can hinder loop-level parallelism. For some loops, {{existing}} thread-level speculation (TLS) techniques fail {{to expose}} their inherent loop-level parallelism, because some inter-iteration <b>dependences</b> are too costly to synchronize, predict, pre-compute and isolate. This paper presents a compiler technique called loop recreation {{to change the}} nature of some <b>dependences</b> (by turning some inter-iteration <b>dependences</b> into intra-iteration ones and vice versa) in a loop so that the inter-iteration <b>dependences</b> in the transformed loop are less costly to enforce at run time than those in the original loop. We present an algorithm for finding an optimal loop recreation transformation with respect to a simple misspeculation cost model and demonstrate performance advantages of loop recreation over two recent techniques for multicore systems running nine representative irregular applications. 1...|$|R
40|$|Although weights of some system {{poles of}} the AR model are {{asymptotically}} constant for model order change, they have transient model-order <b>dependences.</b> These transient order <b>dependences</b> cause the robustness of the decay ratio near the hard-model instability, when {{the value of}} it is determined by using an AR model. The relationship between the robustness of the decay ratio and transient order <b>dependences</b> of the AR weights are discussed qualitatively...|$|R
25|$|Because only 3 of the 7 DSM-IV {{criteria}} for alcohol <b>dependence</b> are required, not all patients meet the same criteria {{and therefore not}} {{all have the same}} symptoms and problems related to drinking. Not everyone with alcohol <b>dependence,</b> therefore, experiences physiological <b>dependence.</b> Alcohol <b>dependence</b> is differentiated from alcohol abuse by the presence of symptoms such as tolerance and withdrawal. Both alcohol <b>dependence</b> and alcohol abuse are sometimes referred to by the less specific term alcoholism. However, many definitions of alcoholism exist, and only some are compatible with alcohol abuse. There are two major differences between alcohol <b>dependence</b> and alcoholism as generally accepted by the medical community.|$|E
25|$|Psychoactive {{drugs are}} often {{associated}} with addiction or drug <b>dependence.</b> <b>Dependence</b> {{can be divided into}} two types: psychological <b>dependence,</b> by which a user experiences negative psychological or emotional withdrawal symptoms (e.g., depression) and physical <b>dependence,</b> by which a user must use a drug to avoid physically uncomfortable or even medically harmful physical withdrawal symptoms. Drugs that are both rewarding and reinforcing are addictive; these properties of a drug are mediated through activation of the mesolimbic dopamine pathway, particularly the nucleus accumbens. Not all addictive drugs are associated with physical <b>dependence,</b> e.g., amphetamine, and not all drugs that produce physical <b>dependence</b> are addictive drugs, e.g., caffeine.|$|E
25|$|Intuitionistic <b>dependence</b> logic, that is, <b>dependence</b> logic {{supplemented}} with the intuitionistic implication, {{is equivalent to}} second-order logic.|$|E
40|$|Efficient inter-thread value {{communication}} {{is essential for}} improving performance in thread-level speculation (TLS). Although several mechanisms for improving value communication using hardware support have been proposed, there is relatively little work on exploiting the potential of compiler optimization. Building on recent research on compiler optimization of scalar value communication between speculative threads, we propose compiler techniques for the optimization of memory-resident values. In TLS, data <b>dependences</b> through memory-resident values are tracked by the underlying hardware and preserved by re-executing any speculative thread that violates a dependence; however, re-execution incurs a large performance penalty and should be used only to resolve data <b>dependences</b> that are infrequent. In contrast, value communication for frequently-occurring data <b>dependences</b> must be very efficient. We propose using the compiler to first identify frequently-occurring memory-resident data <b>dependences,</b> then insert synchronization for communicating values to preserve these <b>dependences.</b> We find that by synchronizing frequently-occurring data <b>dependences</b> we can significantly improve the efficiency of parallel execution. A comparison between compiler-inserted and hardware-inserted memory synchronization reveals that the two techniques are complementary, with each technique benefitting different benchmarks...|$|R
40|$|Program slicing {{is useful}} for {{assisting}} with many software-maintenance tasks. The presence and frequent usage of pointers in languages such as C causes complex data <b>dependences.</b> To function effectively on such programs, slicing techniques must account for pointer-induced data <b>dependences.</b> Existing slicing techniques do not distinguish data <b>dependences</b> based on their types. This paper presents a new slicing technique, in which slices are computed based on types of data <b>dependences.</b> This new slicing technique offers several benefits and can be exploited in different ways, such as identifying subtle data <b>dependences</b> for debugging, computing reduced-size slices quickly for complex programs, and performing incremental slicing. This paper describes an algorithm for incremental slicing that increases the scope of a slice in steps, by incorporating different types of data <b>dependences</b> at each step. The paper also presents empirical results to illustrate {{the performance of the}} technique in practice. The results illustrate that incremental slices can be significantly smaller than complete slices. Finally, the paper presents a case study that explores the usefulness of incremental slicing for debugging. ...|$|R
40|$|Automatic parallelization of {{imperative}} {{programs has}} focused on nests of do loops with affine bounds and affine <b>dependences,</b> because in this case execution domains and <b>dependences</b> can be precisely known at compile-time. When dynamic control structures, such as while loops, are used, existing methods for conversion to single-assignment form and domain scanning are inapplicable. This paper gives an algorithm to automatically generate parallel code, together with an algorithm to possibly convert the program to single-assignment form. 1 Introduction Automatic parallelization of imperative programs {{has focused on}} nests of do loops with affine bounds and affine <b>dependences</b> [10], mainly because <b>dependences</b> can then precisely be known at compile-time. Data or "memory-based" <b>dependences</b> are due to reuse of memory cells, and thus are language- and program-dependent, whereas dataflows or "value-based dependences" denote transmissions of values and thus are algorithm-dependent. Memory-b [...] ...|$|R
25|$|The <b>dependence</b> atom, or a {{suitable}} variant thereof, {{can be added}} to the language of modal logic, thus obtaining modal <b>dependence</b> logic.|$|E
25|$|Benzodiazepine <b>dependence</b> is the {{condition}} resulting from repeated use of benzodiazepine drugs. It can include both a physical <b>dependence</b> {{as well as}} a psychological <b>dependence</b> and is typified by a withdrawal syndrome upon a fall in blood plasma levels of benzodiazepines, e.g., during dose reduction or abrupt withdrawal.|$|E
25|$|The Severity of Alcohol <b>Dependence</b> Questionnaire (SADQ or SAD-Q) is a 20 item {{clinical}} {{screening tool}} {{designed to measure}} the presence and level of alcohol <b>dependence.</b>|$|E
40|$|This paper {{presents}} a technique for computing and classifying data <b>dependences</b> {{that takes into}} account the complexities introduced by specific language constructs, such as pointers, arrays, and structures. The classification is finergrained than previously proposed classifications. Moreover, unlike previous work, the paper presents empirical results that illustrate the distribution of data <b>dependences</b> for a set of C subjects. The paper also {{presents a}} potential application for the proposed classification [...] -program slicing [...] -and a technique that computes slices based on data-dependence types. This technique facilitates the use of slicing for program understanding because a user can either augment a slice incrementally, by incorporating data <b>dependences</b> based on their relevance, or focus on specific kinds of <b>dependences.</b> Finally, the paper presents a case study that shows how the incremental addition of data <b>dependences</b> allows for growing the size of the slices in steps...|$|R
40|$|Program slicing {{is useful}} for {{assisting}} with software-maintenance tasks, such as program understanding, debugging, impact analysis, and regression testing. The presence and frequent usage of pointers, in languages such as C, causes complex data <b>dependences.</b> To function e#ectively on such programs, slicing techniques must account for pointerinduced data <b>dependences.</b> Although many existing slicing techniques function {{in the presence of}} pointers, none of those techniques distinguishes data <b>dependences</b> based on their types. This paper presents a new slicing technique, in which slices are computed based on types of data <b>dependences.</b> This new slicing technique o#ers several benefits and can be exploited in di#erent ways, such as identifying subtle data <b>dependences</b> for debugging purposes, computing reduced-size slices quickly for complex programs, and performing incremental slicing. In particular, this paper describes an algorithm for incremental slicing that increases the scope of a slice in [...] ...|$|R
40|$|Several {{compiling}} methods currently {{exist for}} parallelizing sequential programs. These compile-time methods inevitably overestimate <b>dependences</b> among parts of program, and miss {{many opportunities for}} parallelization. Experiences so far indicate compile-time analysis works only for regular scientific code in practice. To discover much more legitimate parallelism, we propose an approach to parallelizing programs with access traces gathered at trial-run time. This approach can precisely discover interprocedural <b>dependences</b> that actually occur while avoiding <b>dependences</b> that never occur in parallel execution. However, <b>dependences</b> may depend on input to the program, so this approach cannot guarantee an always-true solution for every executions. Therefore it suits to be a hint-provider for semi-automatic or interactive parallelizers...|$|R
25|$|The {{information}} {{given by}} a correlation coefficient {{is not enough to}} define the <b>dependence</b> structure between random variables. The correlation coefficient completely defines the <b>dependence</b> structure only in very particular cases, for example when the distribution is a multivariate normal distribution. (See diagram above.) In the case of elliptical distributions it characterizes the (hyper-)ellipses of equal density; however, it does not completely characterize the <b>dependence</b> structure (for example, a multivariate t-distribution's degrees of freedom determine the level of tail <b>dependence).</b>|$|E
25|$|Cation-π {{interactions}} have {{an approximate}} distance <b>dependence</b> of 1/rn where n<2. The interaction is less sensitive to distance {{than a simple}} ion-quadrupole interaction which has 1/r3 <b>dependence.</b>|$|E
25|$|In practice, Archimedean copulas {{are popular}} because they allow {{modeling}} <b>dependence</b> in arbitrarily high dimensions {{with only one}} parameter, governing the strength of <b>dependence.</b>|$|E
40|$|The article {{justifies the}} {{possibility}} {{and the necessity}} of complex approach to adolescents’ social <b>dependences</b> study and prevention, defines this phenomenon, reveals its essential features, presents author’s classification of adolescents’ social <b>dependences</b> by addiction features, describes standard scenarios and the mechanisms of their origin. The essence and principles of complex approach to adolescents’ social <b>dependences</b> prevention were described. Classification of the integrated pedagogical toolkits of prevention, developed by the key targets was made...|$|R
3000|$|On {{the other}} hand, an {{indirect}} evidence of some recombination center existence {{has been found}} in both the structures from the PV <b>dependences</b> on excitation intensity. All the PV <b>dependences</b> tend to be superlinear close to (I [...]...|$|R
40|$|This paper {{studies the}} {{relationship}} between storage requirements and performance. Storage-related <b>dependences</b> inhibit optimizations for locality and parallelism. Techniques such as renaming and array expansion can eliminate all storage-related <b>dependences,</b> but do so {{at the expense of}} increased storage. This paper introduces the universal occupancy vector (UOV) for loops with a regular stencil of <b>dependences.</b> The UOV provides a schedule-independent storage reuse pattern that introduces no further <b>dependences</b> (other than those implied by true flow <b>dependences).</b> OV-mapped code requires less storage than full array expansion and only slightly more storage than schedule-dependent minimal storage. We show that determine if a vector is a UOV is NP-complete. However, an easily constructed but possibly nonminimal UOV can be used. We also present a branch and bound algorithm which finds the minimal UOV, while still maintaining a legal UOV at all times. Our experimental results show that the use [...] ...|$|R
