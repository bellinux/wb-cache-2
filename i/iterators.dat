400|323|Public
5|$|ECMAScript {{borrowed}} <b>iterators,</b> generators, and list comprehensions from Python.|$|E
25|$|Already {{present at}} this stage of {{development}} were many of the features familiar in later releases of Ruby, including object-oriented design, classes with inheritance, mixins, <b>iterators,</b> closures, exception handling and garbage collection.|$|E
25|$|Parameters {{can also}} be passed to {{arbitrary}} blocks, which act as closures. This is how, for example, for and while loop <b>iterators</b> are named. In the following example, a list is traversed, 3 elements at a time, and passed to the loop's block as the variables, $a, $b, $c.|$|E
40|$|The <b>iterator</b> {{abstraction}} {{is one of}} {{the most}} commonly used in programming, but implementing an <b>iterator</b> type can be challenging. The requirements for a standard-conforming <b>iterator</b> are at once tedious and subtle: tedious because much of an <b>iterator's</b> rich interface is "boilerplate" surrounding a few core operations, and subtle because of the intricate details involved in getting that interface right. This paper presents the generalized <b>iterator</b> template from the Boost <b>Iterator</b> Adaptor Library...|$|R
50|$|From {{the field}} of {{software}} engineering, a Fail Fast <b>Iterator</b> is an <b>iterator</b> that attempts to raise an error if the sequence of elements processed by the <b>iterator</b> is changed during iteration.|$|R
40|$|The Super <b>Iterator</b> pattern, {{like the}} {{standard}} <b>Iterator</b> pattern, traverses an unknown data structure without exposing that structure. With the standard <b>Iterator</b> pattern, clients must create a different <b>iterator</b> for each new structure, {{and the object}} returned must be of the specific type stored in the structure, even when they share a common super class. With the Super <b>Iterator</b> pattern, the object returned is of the common super class, and the <b>iterator</b> itself need not be altered when adding a new subtype with custom data structures. The client, however, must change two lines of code to load and instantiate the new subclass. Software patterns, Generalisation, Software Architecture...|$|R
25|$|A {{large part}} of the C++ library is based on the Standard Template Library (STL). Useful tools {{provided}} by the STL include containers as the collections of objects (such as vectors and lists), <b>iterators</b> that provide array-like access to containers, and algorithms that perform operations such as searching and sorting.|$|E
25|$|Furthermore, (multi)maps (associative arrays) and (multi)sets are provided, all {{of which}} export {{compatible}} interfaces. Therefore, using templates {{it is possible to}} write generic algorithms that work with any container or on any sequence defined by <b>iterators.</b> As in C, the features of the library are accessed by using the #include directive to include a standard header. C++ provides 105 standard headers, of which 27 are deprecated.|$|E
2500|$|Lexical closures, <b>iterators</b> and generators, with a block syntax ...|$|E
50|$|In {{object-oriented}} programming, the <b>iterator</b> {{pattern is}} a design pattern {{in which an}} <b>iterator</b> is used to traverse a container and access the container's elements. The <b>iterator</b> pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.|$|R
5000|$|In Magik {{generator}} {{methods are}} called <b>iterator</b> methods. New <b>iterator</b> methods {{can be defined}} using the [...] and [...] statements: ...|$|R
5000|$|Any {{user-defined}} {{class can}} support standard iteration (either implicit or explicit) by defining an [...] method that returns an <b>iterator</b> object. The <b>iterator</b> object then needs {{to define a}} [...] method that returns the next element and an [...] method that returns the next <b>iterator</b> object to use.|$|R
2500|$|Continuations in Scheme are {{first-class}} objects. [...] Scheme {{provides the}} procedure call-with-current-continuation (also known as call/cc) {{to capture the}} current continuation by packing it up as an escape procedure bound to a formal argument in a procedure provided by the programmer. (R5RS sec. 6.4) First-class continuations enable the programmer to create non-local control constructs such as <b>iterators,</b> coroutines, and backtracking.|$|E
2500|$|Visual Studio 2008 {{is focused}} on {{development}} of Windows Vista, 2007 Office system, and Web applications. For visual design, a new Windows Presentation Foundation visual designer and a new HTML/CSS editor influenced by Microsoft Expression Web are included. J# is not included. Visual Studio 2008 requires [...]NET 3.5 Framework and by default configures compiled assemblies to run on [...]NET Framework 3.5, but it also supports multi-targeting which lets the developers choose which version of the [...]NET Framework (out of 2.0, 3.0, 3.5, Silverlight CoreCLR or [...]NET Compact Framework) the assembly runs on. Visual Studio 2008 also includes new code analysis tools, including the new Code Metrics tool (only in Team Edition and Team Suite Edition). For Visual C++, Visual Studio adds {{a new version of}} Microsoft Foundation Classes (MFC 9.0) that adds support for the visual styles and UI controls introduced with Windows Vista. For native and managed code interoperability, Visual C++ introduces the STL/CLR, which is a port of the C++ Standard Template Library (STL) containers and algorithms to managed code. STL/CLR defines STL-like containers, <b>iterators</b> and algorithms that work on C++/CLI managed objects.|$|E
50|$|The STL {{implements}} {{five different}} types of <b>iterators.</b> These are input <b>iterators</b> (that can only be used to read a sequence of values), output <b>iterators</b> (that can only be used to write a sequence of values), forward <b>iterators</b> (that can be read, written to, and move forward), bidirectional <b>iterators</b> (that are like forward <b>iterators,</b> but can also move backwards) and s (that can move freely any number of steps in one operation).|$|E
5000|$|An <b>iterator</b> {{may allow}} the {{container}} object {{to be modified}} without invalidating the <b>iterator.</b> For instance, once an <b>iterator</b> has advanced beyond the first element {{it may be possible}} to insert additional elements into the beginning of the container with predictable results. With indexing this is problematic since the index numbers must change.|$|R
40|$|We {{investigate}} using algebraic {{methods and}} the support tool Maude to formally specify and reason about the well known <b>iterator</b> design pattern. We begin by specifying instances of the <b>iterator</b> pattern which can be described equationally using Maude. We then develop an abstract specification which we argue captures {{the essence of the}} <b>iterator</b> pattern. We conclude by specifying a possible refinement for <b>iterator</b> instances, a so called filter refinement, and by formally proving that this refinement is correct with respect to our abstract specification...|$|R
50|$|<b>Iterator</b> {{safety is}} defined {{separately}} {{for the different}} types of standard containers, in some cases the <b>iterator</b> is very permissive in allowing the container to change while iterating.|$|R
5000|$|The C++ {{language}} makes wide use of <b>iterators</b> in its Standard Template Library, {{which provides}} several {{different kinds of}} <b>iterators,</b> including forward <b>iterators,</b> bidirectional <b>iterators,</b> and random access <b>iterators.</b> All of the standard container template types provide a rich and consistent set of iterator types. The syntax of standard <b>iterators</b> is designed to resemble that of ordinary C pointer arithmetic, where the [...] and [...] operators are used to reference the element to which the iterator points, and pointer arithmetic operators like [...] are used to advance the iterator to the next element.|$|E
50|$|XL <b>iterators</b> allow programmers to {{implement}} both generators and <b>iterators.</b>|$|E
50|$|With {{respect to}} the field of {{reinforcement}} learning, learning automata are characterized as policy <b>iterators.</b> In contrast to other reinforcement learners, policy <b>iterators</b> directly manipulate the policy Ï€. Another example for policy <b>iterators</b> are evolutionary algorithms.|$|E
5000|$|PHP {{supports}} the <b>iterator</b> pattern via the <b>Iterator</b> interface, {{as part of}} the standard distribution. Objects that implement the interface can be iterated over with the [...] language construct.|$|R
5000|$|... getcontext(&loop_context); /* Initialise the <b>iterator</b> context. uc_link {{points to}} main_context1, the * point {{to return to}} when the <b>iterator</b> finishes. */ loop_context.uc_link = &main_context1; loop_context.uc_stack.ss_sp = iterator_stack; loop_context.uc_stack.ss_size = sizeof(iterator_stack); ...|$|R
50|$|Servelat Pieces - The Servelat Pieces {{project by}} Yevhen Bobrov {{provides}} transparent asynchrony for Silverlight WCF services {{and ability to}} asynchronously call any synchronous method. The implementation is based on Caliburn's Coroutines <b>iterator</b> and C# <b>iterator</b> blocks.|$|R
5000|$|Java <b>iterators</b> and {{collections}} can be automatically converted into Scala <b>iterators</b> {{and collections}}, respectively, simply {{by adding the}} single line ...|$|E
50|$|The global / {{functions}} were augmented with / functions, which return constant <b>iterators,</b> and / and / which return reverse <b>iterators.</b>|$|E
50|$|It is {{possible}} to have bidirectional <b>iterators</b> act like random access <b>iterators,</b> so moving forward ten steps could be done by simply moving forward a {{step at a time}} a total of ten times. However, having distinct random access <b>iterators</b> offers efficiency advantages. For example, a vector would have a random access iterator, but a list only a bidirectional iterator.|$|E
5000|$|For {{collection}} {{types that}} support it, the [...] method of the <b>iterator</b> removes the most recently visited element from the container {{while keeping the}} <b>iterator</b> usable. Adding or removing elements by calling the methods of container (also from the same thread) makes the <b>iterator</b> unusable. An attempt to get the next element throws the exception. An exception is also thrown {{if there are no}} more elements remaining ( [...] has previously returned false).|$|R
50|$|For example, the {{hypothetical}} algorithm SearchForElement {{can be implemented}} generally using a specified type of <b>iterator</b> rather than implementing it as a container-specific algorithm. This allows SearchForElement to be used on any container that supports the required type of <b>iterator.</b>|$|R
5000|$|One of {{the more}} exotic {{features}} is the implicit [...] variable: every procedure in Nim with a non-void return type has an implicit result variable that represents the value that will be returned. In the for loop we see an invocation of [...] which is an <b>iterator,</b> if an <b>iterator</b> is omitted then the compiler will attempt to use an [...] <b>iterator</b> if one is defined for the type that was specified in the for loop.|$|R
50|$|In Scala, <b>iterators</b> have a rich set {{of methods}} similar to collections, {{and can be used}} {{directly}} in for loops. Indeed, both <b>iterators</b> and collections inherit from a common base trait - scala.collection.TraversableOnce. However, because of the {{rich set of}} methods available in the Scala collections library, such as map, collect, filter etc., it is often not necessary to deal with <b>iterators</b> directly when programming in Scala.|$|E
50|$|The {{philosophy}} of the Standard Template Library (STL) embedded in the C++ Standard Library is to use generic algorithms {{in the form of}} templates using <b>iterators.</b> <b>Iterators</b> are hard to implement efficiently which caused Alexander Stepanov to blame some compiler writers for their initial weak performance. The complex categories of <b>iterators</b> have also been criticized, and ranges have been proposed for the C++ standard library.|$|E
50|$|Another {{key feature}} of the CLU type system are <b>iterators,</b> which return objects from a {{collection}} serially, one after another. <b>Iterators</b> offer an identical application programming interface (API) no matter what data they are being used with. Thus the iterator for a collection of s can be used interchangeably with that for an array of s. A distinctive feature of CLU <b>iterators</b> {{is that they are}} implemented as coroutines, with each value being provided to the caller via a yield statement. <b>Iterators</b> like those in CLU are now a common feature of many modern languages, such as C#, Ruby, and Python, though recently they are often referred to as generators.|$|E
40|$|The need to parallelise desktop {{applications}} is becom-ing increasingly essential {{with the}} mainstream adoption of multi-cores. In object-oriented languages, sequential itera-tors handle iterative computations of a sequential program; similarly, the parallel <b>iterator</b> {{was developed to}} handle the iterative computations of a parallel program. This paper presents {{the progress of the}} parallel <b>iterator</b> concept. New features, such as support for reductions and global break semantics, allow the parallel <b>iterator</b> to undertake more sit-uations. With a slight contract modification, the parallel <b>iterator</b> interface now imitates that of the sequential itera-tor. All these features combine together to promote minimal, if any, code restructuring. The reduction frequently outper-forms related work and the importance of providing simple and flexible fine-tuning capability is affirmed...|$|R
25|$|An {{enumerator}} is an <b>iterator.</b>|$|R
5000|$|The Vector {{class in}} Java has two means for iterating over its elements. One {{may use the}} <b>Iterator</b> interface, {{as seen in the}} {{previous}} example, or one may use the Enumeration interface. Besides the addition of a remove method for the <b>Iterator</b> interface, the main difference is that <b>Iterator</b> is [...] "fail fast" [...] while Enumeration is not. What this means is that if one modifies the Vector (other than by using the <b>Iterator</b> remove method) when one is iterating over the Vector using an <b>Iterator,</b> a ConcurrentModificationException is thrown. However, when using an Enumeration this is not a case, as mentioned. This can result in non-deterministic results from a program because the Vector is left in an inconsistent state {{from the perspective of the}} Enumeration. For legacy programs that still use the Enumeration interface, one may wish to enforce that Enumerations are not used when their underlying Vector is modified. The following parametric regular pattern can be used to enforce this behavior: ...|$|R
