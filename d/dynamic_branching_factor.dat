0|842|Public
40|$|A crack curving {{criterion}} {{based on}} its directional stability and a crack branching criterion requiring a <b>dynamic</b> <b>branching</b> stress intensity <b>factor</b> and the crack curving criterion are presented. These criteria are used to predict crack curvings and crack branchings in Homalite- 100 and polycarbonate fracture specimens, and bursting steel and aluminum pipes...|$|R
40|$|Wish branches, a {{new class}} of control-flow instructions, allow the {{hardware}} to dynamically {{decide whether or not to}} use predicated execution for a <b>dynamic</b> <b>branch</b> instruction. The goal of wish branches is to use predicated execution for hard-to-predict <b>dynamic</b> <b>branches</b> and branch prediction for easy-to-predict <b>dynamic</b> <b>branches,</b> thereby obtaining the best of both worlds. Wish loops, one class of wish branches, utilize predication to reduce the misprediction penalty for hard-to-predict backward (loop) branches. 1...|$|R
40|$|Branches {{that depend}} {{directly}} or indirectly on load instructions are {{a leading cause of}} mispredictions by state-of-the-art branch predictors. For a branch of this type, there is a unique dynamic instance of the branch for each unique combination of producer-load addresses. Based on this definition, a study of mispredictions reveals two related problems: (i) Global branch history often fails to distinguish between different <b>dynamic</b> <b>branches.</b> In this case, the predictor is unable to specialize predictions for different <b>dynamic</b> <b>branches,</b> causing mispredictions if their outcomes differ. Ideally, the remedy is to predict a <b>dynamic</b> <b>branch</b> using its program counter (PC) and the addresses of its producer loads, since this context uniquely identifies the <b>dynamic</b> <b>branch.</b> We call this context the identity, or ID, of the <b>dynamic</b> <b>branch.</b> In general, producer loads are unlikely to have generate...|$|R
50|$|The 740 and 750 added <b>dynamic</b> <b>branch</b> {{prediction}} and a 64-entry branch {{target instruction}} cache (BTIC). <b>Dynamic</b> <b>branch</b> prediction uses the recorded {{outcome of a}} branch stored in a 512-entry by 2-bit branch history table (BHT) to predict its outcome. The BTIC caches the first two instructions at a branch target.|$|R
5000|$|For example, if the <b>branching</b> <b>factor</b> is 10, {{then there}} will be 10 nodes one level down from the current position, 102 (or 100) nodes two levels down, 103 (or 1,000) nodes three levels down, and so on. The higher the <b>branching</b> <b>factor,</b> the faster this [...] "explosion" [...] occurs. The <b>branching</b> <b>factor</b> can be cut down by a pruning algorithm.|$|R
50|$|<b>Dynamic</b> <b>branch</b> {{prediction}} uses {{information about}} taken or not taken branches gathered at run-time {{to predict the}} outcome of a branch.|$|R
5000|$|In computing, tree data structures, {{and game}} theory, the <b>branching</b> <b>factor</b> {{is the number}} of {{children}} at each node, the outdegree. If this value is not uniform, an average <b>branching</b> <b>factor</b> can be calculated.|$|R
40|$|In {{a highly}} {{parallel}} computer system, performance losses due to conditional branch instructions can be minimized by branch prediction to fetch and issue subsequent instructions {{before the actual}} branch outcome is known. This paper discusses several software-based static and hardware-based <b>dynamic</b> <b>branch</b> prediction strategies and uses the modified release 3. 0 of the SimpleScalar simulation tool set to evaluate their performance. According to our test result, the hardware-based <b>dynamic</b> <b>branch</b> prediction strategies always achieve high prediction accuracy than the software-based static branch prediction strategies. 1...|$|R
5000|$|BRUN [...] - [...] Branch {{unconditional}} (offset {{given by}} following code syllables)DBUN [...] - [...] <b>Dynamic</b> <b>branch</b> unconditional (offset given in top of stack)BRFL [...] - [...] Branch if last result false (offset given by following code syllables)DBFL [...] - [...] <b>Dynamic</b> <b>branch</b> if last result false (offset given in top of stack)BRTR [...] - [...] Branch if last result true (offset given by following code syllables)DBTR [...] - [...] <b>Dynamic</b> <b>branch</b> if last result true (offset given in top of stack)EXIT [...] - [...] Exit current environment (terminate process)STBR [...] - [...] Step and branch (used in loops; operand must be SIW)ENTR [...] - [...] Execute a procedure call {{as given by}} a tag 7 PCW, resulting in an RCW at Dn + 1RETN [...] - [...] Return from current routine to place given by RCW at Dn + 1 and remove the stack frame ...|$|R
5000|$|The {{higher the}} <b>branching</b> <b>factor,</b> {{the lower the}} {{overhead}} of repeatedly expanded states, but even when the <b>branching</b> <b>factor</b> is 2, iterative deepening search only takes about {{twice as long as}} a complete breadth-first search. This means that the time complexity of iterative deepening is still [...]|$|R
40|$|Modern {{processors}} implement hardware branch pre-dictors {{to increase}} their peak performance. However, the behavior of <b>dynamic</b> <b>branch</b> prediction schemes {{is strongly dependent on}} the runtime execution paths which makes them very difficult to analyze with usual static anal-ysis techniques. In many processors, <b>dynamic</b> <b>branch</b> prediction can be disabled to favor timing predictability. However this will limit the processor performance which might not be desirable if high execution rates are needed. These last six years, several approaches have been pro-posed to model <b>dynamic</b> <b>branch</b> predictors within Worst-Case Execution Time (WCET) analysis. In this paper, we focus on solutions that integrate the branch predic-tor analysis into the WCET computation with the IPET method [8]. We analyze the modeling complexity of dy-namic branch prediction schemes, i. e. the difficulty of de-scribing a branch predictor for WCET estimation. Our purpose is to give an insight into the impact of the branch predictor features on the effort required to build a model for WCET analysis. 1...|$|R
40|$|This paper proposes an {{improved}} branch predictor {{that reduces the}} number execution cycles of applications by selectively accessing a specific element in 4 -way associative cache. When a branch instruction is fetched, the proposed branch predictor acquires a branch target address from the selected element in the cache by referring to MRU buffer. Branch prediction rate and application execution speed are considerably improved by {{increasing the number of}} BTAC entries in restricted power condition, when compared with that of previous branch predictor which accesses all elements. The effectiveness of the proposed <b>dynamic</b> <b>branch</b> predictor is verified by executing benchmark applications on the core simulator. Experimental results show that number of execution cycles decreases by an average of 10. 1 %, while power consumption increases an average of 7. 4 %, when compared to that of a core without a <b>dynamic</b> <b>branch</b> predictor. Execution cycles are reduced by 4. 1 % in comparison with a core which employs previous <b>dynamic</b> <b>branch</b> predictor...|$|R
5000|$|Consider {{the cost}} of an {{insertion}}. Each message gets flushed [...] times, and {{the cost of}} a flush is [...] Therefore, {{the cost of an}} insertion is [...] Finally, note that the <b>branching</b> <b>factor</b> can vary, but for any <b>branching</b> <b>factor</b> , the cost of a flush is , thereby providing a smooth tradeoff between search cost, which depends on the depth of the search tree, and therefore the <b>branching</b> <b>factor,</b> versus the insertion time, which depends on the depth of the tree but more sensitively {{on the size of the}} buffer flushes.|$|R
50|$|It also {{launched}} magazine Yemen Today http://www.yemen-today.com is {{the most}} <b>dynamic</b> <b>branch</b> of the Publishing House, promoting investment and tourism in Yemen, a country which has promising potential in this field.|$|R
40|$|Abstract. <b>Dynamic</b> <b>branch</b> {{predictor}} logic alone {{accounts for}} approximately 10 % of total processor power dissipation. Recent {{research indicates that}} the power cost of a large <b>dynamic</b> <b>branch</b> predictor is offset by the power savings created by its increased accuracy. We describe a method of reducing dynamic predictor power dissipation without degrading prediction accuracy by {{using a combination of}} local delay region scheduling and run time profiling of branches. Feedback into the static code is achieved with hint bits and avoids the need for dynamic prediction for some individual branches. This method requires only minimal hardware modifications and coexists with a dynamic predictor. ...|$|R
5000|$|For example, in chess, if a [...] "node" [...] is {{considered}} to be a legal position, the average <b>branching</b> <b>factor</b> has been said to be about 35. This means that, on average, a player has about 35 legal moves at his disposal at each turn. By comparison, the <b>branching</b> <b>factor</b> for the game Go is 250.|$|R
2500|$|Good {{heuristics}} {{are those}} with low effective <b>branching</b> <b>factor</b> (the optimal being [...] ).|$|R
40|$|This {{technical}} report is a preliminary {{investigation into the}} use of Support Vector Machines (SVMs) {{as a method of}} branch prediction. We present a new <b>dynamic</b> <b>branch</b> predictor based on SVMs. The SVM predictor, at the cost of a much larger hardware budget, can return a greater accuracy than current state-of-the-art predictors by exploiting its ability to learn linearly inseparable boolean functions, a limitation of many well-known <b>dynamic</b> <b>branch</b> predictors. Our untuned SVM predictor yields a 24 % improvement over the best available <b>dynamic</b> neuralmethod <b>branch</b> predictor and a 16 % improvement over gshare on the SPEC 95 go benchmark at a cost of 10 MB. Tuning the SVM parameters would likely result in further performance gains. Branch prediction with SVMs is largely unexplored in the literature. These favorable results suggest it is worthy of further investigation. ...|$|R
40|$|Efforts {{to reduce}} power {{consumption}} of processors have gained much attention recently. <b>Dynamic</b> <b>branch</b> predictor, including BTB, is exercised in every instruction cycle, yet branch instructions only constitute {{a small percentage}} of instructions during program execution. This study proposes a novel method to collect the next branch distances of the recent branch instructions at runtime, in order to eliminate unnecessary branch predictor lookups. Simulation results show that the proposed design reduces the energy consumption in the <b>dynamic</b> <b>branch</b> predictor by an average of 56. 95 % without performance degradation. The proposed method is fully compatible with BPP and SEPAS, and saves more energy than PPD, Lazy BTB, and EIB does...|$|R
40|$|AbstractWe {{analyze the}} time {{complexity}} of iterative-deepening-A∗ (IDA∗). We first show {{how to calculate}} {{the exact number of}} nodes at a given depth of a regular search tree, and the asymptotic brute-force <b>branching</b> <b>factor.</b> We then use this result to analyze IDA∗ with a consistent, admissible heuristic function. Previous analyses relied on an abstract analytic model, and characterized the heuristic function in terms of its accuracy, but do not apply to concrete problems. In contrast, our analysis allows us to accurately predict the performance of IDA∗ on actual problems such as the sliding-tile puzzles and Rubik's Cube. The heuristic function is characterized by the distribution of heuristic values over the problem space. Contrary to conventional wisdom, our analysis shows that the asymptotic heuristic <b>branching</b> <b>factor</b> {{is the same as the}} brute-force <b>branching</b> <b>factor.</b> Thus, the effect of a heuristic function is to reduce the effective depth of search by a constant, relative to a brute-force search, rather than reducing the effective <b>branching</b> <b>factor...</b>|$|R
40|$|In recent years, {{a number}} of {{reliable}} multicast protocols on transport layer have been proposed. Previous analysis and simulation studies gave evidence for the superiority of tree-based approaches in terms of throughput and bandwidth requirements. In many tree-based protocols, the nodes of the tree are formed of multicast group members. In this case, the <b>branching</b> <b>factor,</b> i. e. {{the maximum number of}} child nodes is adjustable. In this paper we analyze the influence of the <b>branching</b> <b>factor</b> on a protocol's throughput and bandwidth consumption. This knowledge is important to configure protocols for best performance and to optimize the tree creation process. Our results show that the optimal <b>branching</b> <b>factor</b> depends mainly on the probability for receiving messages from other local groups. If local groups are assigned to a separate multicast address, the optimal <b>branching</b> <b>factor</b> is 2. On the other hand, if TTL scoping is used and therefore the probability for receiving messages from other local groups is greater than zero, larger local groups provide better performance...|$|R
5000|$|A rough {{estimate}} {{of the number of}} nodes in the game tree can be obtained as an exponential function of the average <b>branching</b> <b>factor</b> and the average number of plies in a game thus: bd where d is the ply depth and b is the <b>branching</b> <b>factor.</b> In Hex, the average <b>branching</b> <b>factor</b> {{is a function of the}} ply depth. It has been stated that the average <b>branching</b> <b>factor</b> is about 100; that implies an average ply depth of 43 (there will be 121 open spaces on the board when the first player is to make his first move, and 79 when he is to make his 22nd move, the 43rd ply - the average number of open spaces, i.e. <b>branching</b> <b>factor,</b> during the game is (121+120+...+79)/43=100). Therefore, the game tree size has an upper bound of approximately 10043 = 1086. [...] The bound includes some number of illegal positions due to playing on when there is a complete chain for one player or the other, as well as excludes legal positions for games longer than 43 ply. Another researcher obtained a state space estimate of 1057 and a game tree size of 1098 using an upper limit of 50 plies for the game. This compares to 10123 node game tree size of chess.|$|R
40|$|Games {{with large}} <b>branching</b> <b>factors</b> pose a {{significant}} challenge for game tree search algorithms. In this paper, we {{address this problem}} with a sampling strategy for Monte Carlo Tree Search (MCTS) algorithms called naïve sampling, based on {{a variant of the}} Multi-armed Bandit problem called Combinatorial Multi-armed Bandits (CMAB). We analyze the theoretical properties of several variants of naïve sampling, and empirically compare it against the other existing strategies in the literature for CMABs. We then evaluate these strategies in the context of real-time strategy (RTS) games, a genre of computer games characterized by their very large <b>branching</b> <b>factors.</b> Our results show that as the <b>branching</b> <b>factor</b> grows, naïve sampling outperforms the other sampling strategies...|$|R
5000|$|... #Caption: The {{unsustainable}} exponential {{progression of}} a classic pyramid scheme (here with a <b>branching</b> <b>factor</b> of 6) ...|$|R
50|$|Static {{prediction}} {{is used as}} a fall-back technique in some processors with <b>dynamic</b> <b>branch</b> prediction when there isn't any information for dynamic predictors to use. Both the Motorola MPC7450 (G4e) and the Intel Pentium 4 use this technique as a fall-back.|$|R
40|$|Accurate branch {{prediction}} {{is essential for}} obtaining high performance in pipelined superscalar processors. Though many <b>dynamic</b> <b>branch</b> predictors have been proposed to obtain high prediction accuracy, they cannot perform as expected under context switches. It is observed that context switches, even at fairly large intervals, can seriously degrade the performance of <b>dynamic</b> <b>branch</b> predictors. In this paper we measure the effect of context switch on {{branch prediction}}, and present a new scheme which saves and restores branch predictor table when a context switch occurs. This scheme takes advantage of multiple small predictors which preserve branch predictor tables of independent processes. The effectiveness of reducing interprocess interference is evaluated by simulations. q 2002 Elsevier Scienc...|$|R
40|$|<b>Dynamic</b> <b>branch</b> {{prediction}} in high-performance processors is {{a specific}} instance of a general Time Series Prediction problem that occurs {{in many areas of}} science. In contrast, most branch prediction research focuses on Two-Level Adaptive Branch Prediction techniques, a very specific solution to the branch prediction problem. An alternative approach is to look to other application areas and fields for novel solutions to the problem. In this paper, we examine the application of neural networks to <b>dynamic</b> <b>branch</b> prediction. Two neural networks are considered: a Learning Vector Quantisation (LVQ) Network and a Backpropagation Network. We demonstrate that a neural predictor can achieve misprediction rates comparable to conventional Two-level Adaptive Predictors and suggest that neural predictors merit further investigation...|$|R
2500|$|A rough {{estimate}} {{of the number of}} nodes in the game tree can be obtained as an exponential function of the average <b>branching</b> <b>factor</b> and the average number of plies in a game thus: b'd where d is the ply depth and b is the <b>branching</b> <b>factor.</b> [...] In Hex, the average <b>branching</b> <b>factor</b> {{is a function of the}} ply depth. It has been stated that the average <b>branching</b> <b>factor</b> is about 100; that implies an average ply depth of 43 (there will be 121 open spaces on the board when the first player is to make his first move, and 79 when he is to make his 22nd move, the 43rd ply - the average number of open spaces, i.e. <b>branching</b> <b>factor,</b> during the game is (121+120+...+79)/43=100). [...] Therefore, the game tree size has an upper bound of approximately 10043 = 1086.. [...] The bound includes some number of illegal positions due to playing on when there is a complete chain for one player or the other, as well as excludes legal positions for games longer than 43 ply. [...] Another researcher obtained a state space estimate of 1057 and a game tree size of 1098 using an upper limit of 50 plies for the game. This compares to 10123 node game tree size of chess.|$|R
40|$|In many {{experiment}}s, some of {{the factors}} exist only within the level of another factor. Such factors are often called nested factors. A factor within which other factors are nested is called a <b>branching</b> <b>factor.</b> For example, suppose we want to experiment with two processing methods. The factors involved in these two methods can be different. Thus, in this experiment the processing method is a <b>branching</b> <b>factor</b> and the other factors are nested within the <b>branching</b> <b>factor.</b> Design and analysis of experiments with <b>branching</b> and nested <b>factors</b> are challenging and have not received much attention in the literature. Motivated by a computer experiment in a machining process, we develop optimal Latin hypercube designs and kriging methods that can accommodate <b>branching</b> and nested <b>factors.</b> Through {{the application of the}} proposed methods, optimal machining conditions and tool edge geometry are attained, which resulted in a remarkable improvement in the machining process. KEY WORDS: Finite element models; Kriging; Latin hypercube designs. ...|$|R
40|$|We {{analyze the}} {{asymptotic}} time complexity of admis-sible heuristic search algorithms such as A*, IDA*, and depth-first branch-and-bound. Previous analyses relied on an abstract analytical model, and character-ize the heuristic function {{in terms of}} its accuracy, but do not apply to real problems. In contrast, our anal-ysis allows us to accurately predict the performance of these algorithms on problems such as the sliding-tile puzzles and l~ubik’s Cube. The heuristic function is characterized simply by the distribution of heuris-tic values in the problem space. Contrary to conven-tional wisdom, our analysis shows that the asymptotic heuristic <b>branching</b> <b>factor</b> {{is the same as the}} brute-force <b>branching</b> <b>factor,</b> and that the effect of a heuris-tic function is to reduce the effective depth of search, rather than the effective <b>branching</b> <b>factor...</b>|$|R
40|$|To {{obtain the}} {{benefits}} of aggressive, wide-issue, architectures, a large window of valid instructions must be available. While researchers {{have been successful in}} obtaining high accuracies with a range of <b>dynamic</b> <b>branch</b> predictors, there still remains the need for more aggressive instruction delivery...|$|R
5000|$|Like most AI game playing programs, {{the default}} engine plays poorly in games with large <b>branching</b> <b>factors,</b> such as shogi.|$|R
40|$|In this paper, {{we present}} a new tree mining algorithm, DRYADEPARENT, based on the hooking {{principle}} first introduced in DRYADE [9]. In the experiments, we demonstrate that the <b>branching</b> <b>factor</b> and depth of the frequent patterns to find are key factor of complexity for tree mining algorithms. We show that DRYADEPARENT outperforms the current fastest algorithm, CMTreeMiner, by orders of magnitude on datasets where the frequent patterns have a high <b>branching</b> <b>factor.</b> 1...|$|R
50|$|When brute-force searching {{is applied}} to Arimaa, {{the depth of the}} search is limited by the huge number of options each player has on each turn. Computationally, the number of options a player has {{available}} to them governs the number of different paths play can go down. This is known as the <b>branching</b> <b>factor.</b> The average <b>branching</b> <b>factor</b> in a game of Chess is about 35, whereas in Arimaa it is about 17,000.|$|R
40|$|It is {{well known}} that the <b>branching</b> <b>factor</b> of a {{computer}} based board game has an effect on how long a searching AI algorithm takes to search through the game tree of the game. Something that is not as known is that the <b>branching</b> <b>factor</b> may have an additional effect for certain types of AI algorithms. The aim of this work is to evaluate if the win rate of an evolutionary AI algorithm is affected by the <b>branching</b> <b>factor</b> of the board game it is applied to. To do that, an experiment is performed where an evolutionary algorithm known as “Genetic Minimax” is evaluated for the two low <b>branching</b> <b>factor</b> board games Othello and Gomoku (Gomoku is also known as 5 in a row). The performance here is defined as how many times the algorithm manages to win against another algorithm. The results from this experiment showed both some promising data, and some data which could not be as easily interpreted. For the game Othello the hypothesis about this particular evolutionary algorithm appears to be valid, while for the game Gomoku the results were somewhat inconclusive. For the game Othello the performance of the genetic minimax algorithm was comparable to the alpha-beta algorithm it played against up to and including depth 4 in the game tree. After that however, the performance started to decline more and more the deeper the algorithms searched. The <b>branching</b> <b>factor</b> of the game may be an indirect cause of this behaviour, {{due to the fact that}} as the depth increases, the search space increases proportionally to the <b>branching</b> <b>factor.</b> This increase in the search space due to the increased depth, in combination with the settings used by the genetic minimax algorithm, may have been the cause of the performance decline after that point...|$|R
40|$|The paper {{introduces}} a <b>dynamic</b> <b>branch</b> prediction scheme suitable for energy-aware Very Long Instruction Word (VLIW) processors. The proposed technique {{is based on}} a compiler hint mechanism to filter the accesses to the branch predictor blocks. We define a configurable hint instruction which anticipates some static information about the upcoming branch to reduce the hardware involved in the prediction, thus, the energy consumption. To analyze the effectiveness of the proposed low-power branch prediction scheme, we combined it with some well-known <b>dynamic</b> <b>branch</b> prediction techniques suitable for VLIW processors. The analyzed branch predictors are characterized by simple hardware implementations, matching the low-power characteristics of the target VLIW processors. Experimental results have been carried out on Lx, an industrial 4 -issue VLIW architecture...|$|R
