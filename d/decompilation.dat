238|0|Public
500|$|On August 28, 1992, the Ninth Circuit {{overturned}} the district court's verdict and ruled that Accolade's <b>decompilation</b> of the Sega software constituted fair use. [...] The court's written opinion followed on October 20 {{and noted that}} the use of the software was non-exploitative, despite being commercial, and that the trademark infringement, being required by the TMSS for a Genesis game to run on the system, was inadvertently triggered by a fair use act and the fault of Sega for causing false labeling. As a result of the verdict being overturned, the costs of the appeal were assessed to Sega. The injunction remained in force, however, because Sega petitioned the appeals court to rehear the case.|$|E
500|$|As {{a result}} of the appeal, the Ninth Circuit {{overturned}} the district court's verdict and ruled that Accolade's <b>decompilation</b> of the Sega software constituted fair use. [...] The court's written opinion followed on October 20, 1992, and noted that the use of the software was non-exploitative, although commercial. Further, the court found that the trademark infringement, being required by the TMSS for a Genesis game to run on the system, had been inadvertently triggered by a fair use act and was the fault of Sega for having caused false labeling. [...] Ultimately, Sega and Accolade settled the case on April 30, 1993. As a part of this settlement, Accolade became an official licensee of Sega, and later developed and released Barkley Shut Up and Jam! while under license. [...] The terms of the licensing, including whether or not any special arrangements or discounts were made to Accolade, were not released to the public. The financial terms of the settlement were also not disclosed, although both companies agreed to pay their own legal costs.|$|E
50|$|Overall, the <b>decompilation</b> right {{provided}} by Article 6 codifies what is {{claimed to be}} common practice in the software industry. Few European lawsuits {{are known to have}} emerged from the <b>decompilation</b> right. This could be interpreted as meaning one of three things: 1) the <b>decompilation</b> right is not used frequently and the <b>decompilation</b> right may therefore have been unnecessary, 2) the <b>decompilation</b> right functions well and provides sufficient legal certainty not to give rise to legal disputes or 3) illegal <b>decompilation</b> goes largely undetected. In a recent report regarding implementation of the Software Directive by the European member states, the European Commission seems to support the second interpretation.|$|E
50|$|Chapter 13: <b>Decompilation.</b>|$|E
50|$|With {{computer}} programs, {{fair dealing}} is explicitly excluded for <b>decompilation</b> or copying during <b>decompilation.</b> However, <b>decompilation</b> is allowed {{if it is}} to gain information vital to creating an independent program to interact with the decompiled program, provided that the information obtained by <b>decompilation</b> is not used for any other purpose. The observation of programs to determine their functions and the ideas underlying them is explicitly allowed while performing the normal functions of a program, such as loading and running it. As with database use, any terms which purport to restrict this sort of activity are null and void. Backup copies of computer programs are allowed if these are necessary for the lawful use of a computer program, and again restrictive licence terms are null and void.|$|E
50|$|Third, the <b>decompilation</b> process must, if possible, be {{confined}} to {{the parts of the}} target program relevant to interoperability. Since one of the purposes of <b>decompilation</b> is to gain an understanding of the program structure, this third limitation may be difficult to meet. Again, the burden of proof is on the decompiler.|$|E
5000|$|Grimp: an {{aggregated}} {{version of}} Jimple suitable for <b>decompilation</b> and code inspection.|$|E
50|$|The main activities: {{information}} security, {{protection against}} unauthorized copying, modification and analysis (<b>decompilation).</b>|$|E
50|$|The {{majority}} of computer programs {{are covered by}} copyright laws. Although the precise scope of what is covered by copyright differs from region to region, copyright law generally provides the author (the programmer(s) or employer) {{with a collection of}} exclusive rights to the program. These rights include the right to make copies, including copies made into the computer's RAM (unless creating such a copy is essential for using the program).Since the <b>decompilation</b> process involves making multiple such copies, it is generally prohibited without the authorization of the copyright holder. However, because <b>decompilation</b> is often a necessary step in achieving software interoperability, copyright laws in both the United States and Europe permit <b>decompilation</b> to a limited extent.|$|E
50|$|In the United States, the {{copyright}} fair use defense {{has been successfully}} invoked in <b>decompilation</b> cases. For example, in Sega v. Accolade, {{the court held that}} Accolade could lawfully engage in <b>decompilation</b> in order to circumvent the software locking mechanism used by Sega's game consoles. Additionally, the Digital Millennium Copyright Act (PUBLIC LAW 105-304) has proper exemptions for both Security Testing and Evaluation in §1205(i), and Reverse Engineering in §1205(f).|$|E
50|$|<b>Decompilation</b> of an {{executable}} {{program can be}} used to generate source code, either in assembly code or in a high-level language.|$|E
5000|$|Breach of license {{agreement}} based on Louisiana License Act, which Vault utilized {{to attempt to}} prohibit <b>decompilation</b> and disassembly of its software ...|$|E
50|$|Decompilers can {{be thought}} of as {{composed}} of a series of phases each of which contributes specific aspects of the overall <b>decompilation</b> process.|$|E
5000|$|<b>Decompilation</b> is the act {{of using}} a decompiler, {{although}} the term can also refer to the output of a decompiler. It {{can be used for}} the recovery of lost source code, and is also useful in some cases for computer security, interoperability and error correction. The success of <b>decompilation</b> depends on the amount of information present in the code being decompiled and the sophistication of the analysis performed on it. The bytecode formats used by many virtual machines (such as the Java Virtual Machine or the [...]NET Framework Common Language Runtime) often include extensive metadata and high-level features that make <b>decompilation</b> quite feasible. The presence of debug data can make it possible to reproduce the original variable and structure names and even the line numbers. Machine language without such metadata or debug data is much harder to decompile.|$|E
5000|$|In 2012, {{a branch}} of JDEclipse-Realign by Martin [...] "Mchr3k" [...] Robertson {{extended}} the functionality by manual <b>decompilation</b> control and support for Eclipse 4.2 (Juno).|$|E
50|$|In addition, Article 6 prescribes {{that the}} {{information}} obtained through <b>decompilation</b> {{may not be used}} for other purposes and that it may not be given to others.|$|E
50|$|<b>Decompilation</b> using a decompiler, {{a process}} that tries, with varying results, to {{recreate}} the source code in some high-level language for a program only available in machine code or bytecode.|$|E
5000|$|Reverse {{engineering}} {{is the process}} of retrieving a protocol’s details from a software implementation of the specification. Methods of reverse-engineering a protocol include packet sniffing and binary <b>decompilation</b> and disassembly.|$|E
50|$|The {{decompiler}} was a curiosity. The {{first version}} {{ran on the}} Countess, but it was later ported to the CDC 1604 and to other computers and received some notice in University circles. However, {{it turned out that}} there were few programs worthy of <b>decompilation</b> available at the time.|$|E
50|$|Bugwise is {{a service}} that {{performs}} bug detection in Linux executable binaries. It does this by using static program analysis. More specifically, it is performed using <b>decompilation</b> and data flow analysis. Currently, the service checks {{for the presence of}} some double frees in sequential code that use the libc allocator functions.|$|E
5000|$|In Europe, the 1991 Software Directive {{explicitly}} {{provides for}} a right to decompile {{in order to achieve}} interoperability. The result of a heated debate between, on the one side, software protectionists, and, on the other, academics as well as independent software developers, Article 6 permits <b>decompilation</b> only if a number of conditions are met: ...|$|E
50|$|For {{proprietary}} software, {{the provisions}} of the various copyright laws, trade secrecy and patents are used to keep the source code closed. Additionally, many pieces of retail software come with an end-user license agreement (EULA) which typically prohibits <b>decompilation,</b> reverse engineering, analysis, modification, or circumventing of copy protection. Types of source code protection beyond traditional compilation to object code include code encryption, code obfuscation or code morphing.|$|E
50|$|Second, <b>decompilation</b> must be {{necessary}} to achieve interoperability with the target program or other programs. Interoperability information should therefore not be readily available, such as through manuals or API documentation. This is an important limitation. The necessity must be proven by the decompiler. The purpose of this important limitation is primarily to provide an incentive for developers to document and disclose their products' interoperability information.|$|E
50|$|JRuby is {{designed}} {{to work as a}} mixed-mode virtual machine for Ruby, where code can be either interpreted directly, just-in-time compiled at runtime to Java bytecode, or ahead-of-time compiled to Java bytecode before execution. Until October 2007, only the interpreted mode supported all Ruby's constructs, but a full AOT/JIT compiler is available since version 1.1. The compiler design allows for interpreted and compiled code to run side-by-side, as well as <b>decompilation</b> to reoptimize and outputting generated bytecode as Java class files.|$|E
5000|$|The {{penultimate}} <b>decompilation</b> phase involves structuring of the IR {{into higher}} level constructs such as [...] loops and [...] conditional statements. For example, the machine code xor eax, eax l0002: or ebx, ebx jge l0003 add eax,ebx mov ebx,ebx+0x4 jmp l0002 l0003: mov 0x10040000,eaxcould be translated into: eax = 0; while (ebx < 0) { eax += ebx->v0000; ebx = ebx->v0004; } v10040000 = eax;Unstructured code {{is more difficult}} to translate into structured code than already structured code. Solutions include replicating some code, or adding boolean variables.|$|E
50|$|Rybka {{has been}} accused of being based on Fruit, but Rajlich has denied this categorically, saying that Rybka is 100% {{original}} at the source code level. Further allegations of violating the GPL have been brought forward by chess programmer Zach Wegner based on a new <b>decompilation</b> effort and a one-year study of the Rybka 1.0 executable. Rajlich has since declined to respond to these allegations. The Fruit author Fabien Letouzey has since appeared from a 5-year absence in January 2011 and published an open letter asking for more information regarding Rybka and GPL violations.|$|E
50|$|However, {{these rights}} {{are subject to}} certain {{limitations}} (Art. 5). The legal owner of a program is assumed to have a licence to create any copies necessary to use the program and to alter the program within its intended purpose (e.g. for error correction). The lawful may also make a back-up copy {{for his or her}} personal use. The program may also be decompiled if this is necessary to ensure its operates with another program or device (Art. 6), but the results of the <b>decompilation</b> may not be used for any other purpose without infringing the copyright in the program.|$|E
50|$|In general, {{it is best}} {{to delay}} {{detection}} of idiomatic sequences if possible, to later stages that are less affected by instruction ordering. For example, the instruction scheduling phase of a compiler may insert other instructions into an idiomatic sequence, or change the ordering of instructions in the sequence. A pattern matching process in the disassembly phase would probably not recognize the altered pattern. Later phases group instruction expressions into more complex expressions, and modify them into a canonical (standardized) form, making it more likely that even the altered idiom will match a higher level pattern later in the <b>decompilation.</b>|$|E
5000|$|On August 28, 1992, the Ninth Circuit {{overturned}} the district court's verdict and ruled that Accolade's <b>decompilation</b> of the Sega software constituted fair use. [...] The court's written opinion followed on October 20 {{and noted that}} the use of the software was non-exploitative, despite being commercial, and that the trademark infringement, being required by the TMSS for a Genesis game to run on the system, was inadvertently triggered by a fair use act and the fault of Sega for causing false labeling. As a result of the verdict being overturned, the costs of the appeal were assessed to Sega. The injunction remained in force, however, because Sega petitioned the appeals court to rehear the case.|$|E
5000|$|The first <b>decompilation</b> phase {{loads and}} parses the input machine code or {{intermediate}} language program's binary file format. It {{should be able}} to discover basic facts about the input program, such as the architecture (Pentium, PowerPC, etc.) and the entry point. In many cases, it {{should be able to}} find the equivalent of the [...] function of a C program, which is the start of the user written code. This excludes the runtime initialization code, which should not be decompiled if possible. If available the symbol tables and debug data are also loaded. The front end may be able to identify the libraries used even if they are linked with the code, this will provide library interfaces. If it can determine the compiler or compilers used it may provide useful information in identifying code idioms.|$|E
5000|$|...NET Reflector was {{the first}} CLI {{assembly}} browser. It {{can be used to}} inspect, navigate, search, analyze, and browse the contents of a CLI component such as an assembly and translates the binary information to a human-readable form. By default Reflector allows <b>decompilation</b> of CLI assemblies into C#, Visual Basic [...]NET, C++/CLI and Common Intermediate Language and F# (alpha version). Reflector also includes a [...] "Call Tree" [...] {{that can be used to}} drill down into intermediate language methods to see what other methods they call. It will show the metadata, resources and XML documentation[...]NET Reflector can be used by [...]NET developers to understand the inner workings of code libraries, to show the differences between two versions of the same assembly, and how the various parts of a CLI application interact with each other. There are a large number of add-ins for Reflector.|$|E
5000|$|The license {{agreement}} for PROLOK {{depended on the}} Louisiana Software License Enforcement Act {{to give it the}} authority to prohibit users from decompiling or disassembling the software. The Act purported to permit certain {{license agreement}}s to contain [...] "...prohibitions on translating, reverse engineering, decompiling, disassembling, and/or creating derivative works based on the computer software." [...] Vault had included such a provision in its license agreement and claimed that Quaid violated this provision when it reverse engineered PROLOK. The district court held that the Louisiana License Act was unenforceable because it was preempted by the Copyright Act. The circuit court ruled only on the clause permitting a licensor to prohibit <b>decompilation</b> or disassembly, holding that this clause was preempted by the exemptions of 17 U.S.C. §117, which grant permission to make [...] "essential step" [...] and archival copies.|$|E
5000|$|Just before code generation, {{it may be}} {{desirable}} to allow an interactive editing of the IR, perhaps using some form of graphical user interface. This would allow the user to enter comments, and non-generic variable and function names. However, these are almost as easily entered in a post <b>decompilation</b> edit. The user may want to change structural aspects, such as converting a [...] loop to a [...] loop. These are less readily modified with a simple text editor, although source code refactoring tools may assist with this process. The user may need to enter information that failed to be identified during the type analysis phase, e.g. modifying a memory expression to an array or structure expression. Finally, incorrect IR {{may need to be}} corrected, or changes made to cause the output code to be more readable.|$|E
5000|$|Vault Corporation v Quaid Software Ltd. 847 F.2d 255 (5th Cir. 1988) {{is a case}} {{heard by}} the United States Court of Appeals for the Fifth Circuit that tested the extent of {{software}} copyright. The court held that making RAM copies as an essential step in utilizing software was permissible under §117 of the Copyright Act {{even if they are}} used for a purpose that the copyright holder did not intend. It also applied the [...] "substantial noninfringing uses" [...] test from Sony Corp. of America v. Universal City Studios, Inc. to hold that Quaid's software, which defeated Vault's copy protection mechanism, did not make Quaid liable for contributory infringement. It held that Quaid's software was not a derivative work of Vault's software, despite having approximately 30 characters of source code in common. Finally, it held that the Louisiana Software License Enforcement Act clause permitting a copyright holder to prohibit software <b>decompilation</b> or disassembly was preempted by the Copyright Act, and was therefore unenforceable.|$|E
5000|$|As {{a result}} of the appeal, the Ninth Circuit {{overturned}} the district court's verdict and ruled that Accolade's <b>decompilation</b> of the Sega software constituted fair use. [...] The court's written opinion followed on October 20, 1992, and noted that the use of the software was non-exploitative, although commercial. Further, the court found that the trademark infringement, being required by the TMSS for a Genesis game to run on the system, had been inadvertently triggered by a fair use act and was the fault of Sega for having caused false labeling. [...] Ultimately, Sega and Accolade settled the case on April 30, 1993. As a part of this settlement, Accolade became an official licensee of Sega, and later developed and released Barkley Shut Up and Jam! while under license. [...] The terms of the licensing, including whether or not any special arrangements or discounts were made to Accolade, were not released to the public. The financial terms of the settlement were also not disclosed, although both companies agreed to pay their own legal costs.|$|E
50|$|This {{process is}} {{sometimes}} termed Reverse Code Engineering, or RCE. As an example, <b>decompilation</b> of binaries for the Java platform {{can be accomplished}} using Jad. One famous case of reverse engineering was the first non-IBM implementation of the PC BIOS which launched the historic IBM PC compatible industry {{that has been the}} overwhelmingly dominant computer hardware platform for many years. Reverse engineering of software is protected in the U.S. by the fair use exception in copyright law. The Samba software, which allows systems that are not running Microsoft Windows systems to share files with systems that are, {{is a classic example of}} software reverse engineering, since the Samba project had to reverse-engineer unpublished information about how Windows file sharing worked, so that non-Windows computers could emulate it. The Wine project does the same thing for the Windows API, and OpenOffice.org is one party doing this for the Microsoft Office file formats. The ReactOS project is even more ambitious in its goals, as it strives to provide binary (ABI and API) compatibility with the current Windows OSes of the NT branch, allowing software and drivers written for Windows to run on a clean-room reverse-engineered Free Software (GPL) counterpart. WindowsSCOPE allows for reverse-engineering the full contents of a Windows system's live memory including a binary-level, graphical reverse engineering of all running processes.|$|E
