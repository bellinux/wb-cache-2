43|10000|Public
40|$|Arby is a {{software}} for writing expert electronic systems system or <b>higher</b> <b>order</b> <b>language</b> systems to do diagnosis in As such, it {{is similar to}} EMYCIN (van &lle 1962) in application, but quite different in design. It is rule-based to an extent, but the rules are written in predicate calculus. It resembles Caduceus (Pople 1977) in its me&a-nisms for refining and combining hypotheses. 1. Ovemiew Arby is {{a software}} system or <b>higher</b> <b>order</b> <b>language</b> for writing expert systems to do diagnosis. As such...|$|E
40|$|Deforestation is an {{automatic}} transformation scheme for functional programs which attempts to remove unnecessary intermediate data structures. The algorithm presented {{here is a}} variant of the original, adapted for a <b>higher</b> <b>order</b> <b>language.</b> A detailed description of how this may be implemented in an optimising compiler is also given...|$|E
40|$|This report {{deals with}} the feasibility, problems, solutions, and mapping of a GOAL {{language}} to HAL language translator. Ground Operations Aerospace Language, or GOAL, is a test-oriented <b>higher</b> <b>order</b> <b>language</b> developed by the John F. Kennedy Space Center {{to be used in}} checkout and launch of the space shuttle. HAL is a structured <b>higher</b> <b>order</b> <b>language</b> developed by the Johnson Space Center to be used in writing the flight software for the onboard shuttle computers. Since the onboard computers will extensively support ground checkout of the space shuttle, and since these computers and the software development facilities on the ground use the HAL language as baseline, the translation of GOAL to HAL becomes significant. The issue of feasibility was examined and it was found that a GOAL to HAL translator is feasible. Special problems are identified and solutions proposed. Finally, examples of translation are provided for each category of complete GOAL statement...|$|E
50|$|Mohol {{refers to}} Machine Oriented <b>High</b> <b>Order</b> <b>Languages</b> in Dijkstra's terminology.|$|R
40|$|The {{discussion}} of applying a (distributed) <b>High</b> <b>Order</b> <b>Language</b> (HOL) to applications which require real-time performance invariably invokes {{the subject of}} excessive overhead. In a related paper, {{some of the basic}} language-specific issues involved in distributing a <b>High</b> <b>Order</b> <b>Language,</b> with special attention paid to the Ada language, are discussed. In a traditional implementation, several of these issues imply considerable, if not prohibitive overhead. An implementation strategy is introduced which promises to deal with these issues in a manner that will provide significant performance improvements. These improvements should in fact be sufficient to make use of distributed Ada feasible even in highly-constrained application domains. Additionally, the general approach should be applicable to nondistributed implementations as well...|$|R
40|$|An {{algorithm}} {{was developed}} that detects, isolates, and accommodates sensor failures using analytical redundancy. The performance of this algorithm {{has been demonstrated}} on a full-scale F 100 turbofan engine. The algorithm was implemented in real-time on a microprocessor-based controls computer which includes parallel processing and <b>high</b> <b>order</b> <b>language</b> programming. Parallel processing was used to achieve the required computational power for the real-time implementation. <b>High</b> <b>order</b> <b>language</b> programming was used {{in order to reduce}} the programming and maintenance costs of the algorithm implementation software. The sensor failure algorithm was combined with an existing multivariable control algorithm to give a complete control implementation with sensor analytical redundancy. The real-time microprocessor implementation of the algorithm, which resulted in the successful completion of the algorithm engine demonstration, is described...|$|R
40|$|International Telemetering Conference Proceedings / October 13 - 16, 1986 / Riviera Hotel, Las Vegas, NevadaA {{telemetry}} {{processing capability}} {{is being developed}} for the Air Force Satellite Control Network which will process telemetry data from Air Force satellites of various families in several Mission Control Complexes using identical hardware and software. A Telemetry <b>Higher</b> <b>Order</b> <b>Language</b> is the key element in allowing this commonality...|$|E
40|$|Generalization is a {{fundamental}} operation of inductive inference. While first order syntactic generalization (anti-unification) is well understood, its various extensions are needed in applications. This paper discusses syntactic higher order generalization in a <b>higher</b> <b>order</b> <b>language</b> 2 [1]. Based on the application ordering, we proved the least general generalization exists and is unique up to renaming. An algorithm to compute the least general generalization is presented...|$|E
40|$|This paper {{describes}} the University of Cambridge submission to the Eighth Workshop on Statistical Machine Translation. We report {{results for the}} Russian-English translation task. We use multiple segmentations for the Russian input language. We employ the Hadoop framework to extract rules. The decoder is HiFST, a hierarchical phrase-based decoder implemented using weighted finitestate transducers. Lattices are rescored with a <b>higher</b> <b>order</b> <b>language</b> model and minimum Bayes-risk objective...|$|E
50|$|The <b>High</b> <b>Order</b> <b>Language</b> Working Group (HOLWG) was {{a working}} group {{instrumental}} in developing the Ada computer programming language. The group was established in 1975 {{with the goal of}} establishing a single high level programming language appropriate for United States Department of Defense (DoD) real-time embedded computer systems. Colonel William A. Whitaker chaired the group.|$|R
5000|$|The Steelman {{language}} requirements were {{a set of}} requirements which a high-level general-purpose programming language should meet, created by the United States Department of Defense in The Department of Defense Common <b>High</b> <b>Order</b> <b>Language</b> program in 1978. The predecessors of this document were called, in order, [...] "Strawman", [...] "Woodenman", [...] "Tinman" [...] and [...] "Ironman".|$|R
50|$|The International Algebraic Language (IAL) was {{extremely}} influential and generally considered the ancestor {{of most of}} the modern programming languages (the so-called Algol-like languages). Additionally, ALGOL object code was a simple, compact, and stack-based instruction set architecture commonly used in teaching compiler construction and other <b>high</b> <b>order</b> <b>languages</b> (of which Algol is generally considered the first).|$|R
40|$|HAL/S is a <b>higher</b> <b>order</b> <b>language</b> and system, now operational, {{adopted by}} NASA for {{programming}} Space Shuttle on-board software. Program reliability is enhanced through language clarity and readability, modularity through program structure, {{and protection of}} code and data. Salient features of HAL/S include output orientation, automatic checking (with strictly enforced compiler rules), the availability of linear algebra, real-time control, a statement-level simulator, and compiler transferability (for applying HAL/S to additional object and host computers). The compiler is described briefly...|$|E
40|$|This paper {{presents}} an efficient low-memory method for constructing high-order approximate n-gram frequency counts. The method {{is based on}} a deterministic streaming algorithm which efficiently computes approximate frequency counts over a stream of data while employing a small memory footprint. We show that this method easily scales to billion-word monolingual corpora using a conventional (4 GB RAM) desktop machine. Statistical machine translation experimental results corroborate that the resulting high-n approximate language model is as effective as conventional <b>higher</b> <b>order</b> <b>language</b> models. ...|$|E
40|$|New {{design and}} {{programming}} techniques for shuttle software. Based on previous Apollo experience, recommendations {{are made to}} apply top-down structured programming techniques to shuttle software. New software verification techniques for large software systems are recommended. HAL, the <b>higher</b> <b>order</b> <b>language</b> selected for the shuttle flight code, is discussed and found to be adequate for implementing these techniques. Recommendations are made to apply the workable combination of top-down, bottom-up methods {{in the management of}} shuttle software. Program structuring is discussed relevant to both programming and management techniques...|$|E
5000|$|William A. Whitaker (1936-2010) was {{a colonel}} in the United States Air Force. While at the Defense Advanced Research Projects Agency (DARPA), he chaired the <b>High</b> <b>Order</b> <b>Language</b> Working Group that {{recommended}} development of the computer language Ada, in which Words is written. An amateur Latinist, he created the translation software [...] "Whitaker's Words" [...] after his retirement from the forces.|$|R
40|$|This paper {{takes into}} account the Etchemendy’s {{argument}} which critiques classic tarskian notion of logical truth and it casts light on some doubtful aspect of his approach. The focus is the extensional inadequacy of tarskian logical truth with respect to the relationship between the concept of logical truth and <b>higher</b> <b>order</b> <b>languages.</b> In the end, it offers a series of philosophical reflections on Etchemendy’s challenge...|$|R
5000|$|In an {{important}} 1973 report entitled [...] "Ada - The Project : The DoD <b>High</b> <b>Order</b> <b>Language</b> Working Group" [...] to the Defense Advanced Research Projects Agency (DARPA), Boehm predicted that software costs would overwhelm hardware costs. DARPA had {{expected him to}} predict that hardware would remain the biggest problem, encouraging them to invest in even larger computers. The report inspired a change of direction in computing.|$|R
40|$|The Engineering Scripting Language (ESL) is a {{language}} {{designed to allow}} nonprogramming users to write <b>Higher</b> <b>Order</b> <b>Language</b> (HOL) programs by drawing directed graphs to represent the program and having the system generate the corresponding program in HOL. The ESL system supports user generation of HOL programs through the manipulation of directed graphs. The components of this graphs (nodes, ports, and connectors) are objects {{each of which has}} its own properties and property values. The purpose of the ESL graphical editor is to allow the user to create or edit graph objects which represent programs...|$|E
40|$|Methods {{by which}} {{real-time}} executive {{programs can be}} implemented in a <b>higher</b> <b>order</b> <b>language</b> are discussed, using HAL/S and Path Pascal languages as program examples. Techniques are presented by which noncyclic tasks can readily {{be incorporated into the}} executive system. Situations are shown where the executive system can fail to meet its task scheduling and yet be able to recover either by rephasing the clock or stacking the information for later processing. The concept of deadline processing is shown to enable more effective mixing of time and information synchronized systems...|$|E
40|$|This study {{employed}} {{the distinction between}} lexical and supralexical processes in reading {{in order to gain}} a more fine-grained picture of the relationships between early language impairment and later reading disabilities. We hypothesized that early se-mantic–syntactic deficits would be only weakly related, if at all, to the characteristi-cally modular word recognition processes involved in reading isolated words and pseudowords. On the other hand, early language deficiencies were expected to be sig-nificantly associated with processes operating beyond the level of individual words when children are required to read and understand connected text. These predictions were tested using data from a longitudinal study of over 500 unselected children fol-lowed from kindergarten to the end of Grade 1. Both traditional categorical analyses of specific subgroups with early language impairment or later reading disability as well as dimensional (regression) analyses were carried out. As predicted, <b>higher</b> <b>order</b> <b>language</b> was found to be related to supralexical aspects of reading after controlling IQ, age, gender and socioeconomic status, with only a weak and statistically marginal association with lexical processing. With biosocial variables and phonological awareness partialled out, <b>higher</b> <b>order</b> <b>language</b> was unrelated to lexical aspects of reading. These data highlight the multicomponential nature of reading and suggest that different measures of reading cannot simply be regarded as interchangeable mea-sures of a single undifferentiated reading construct...|$|E
40|$|It {{has often}} been assumed that the {{performance}} of languages with rst-class procedures is necessarily inferior to that of more traditional languages. Both experience and benchmarks appear to support this assumption. This work shows that the performance penalty is only a result of applying conventional compiler technologies to the compilation of <b>higher</b> <b>order</b> <b>languages.</b> These technologies do not adapt well {{to the situation in}} which closures of unlimited extent can be created dynamically. The ORBIT compiler is based on a continuation-passing model instead of the traditional procedure call/return. The problem of reducing heap storage is solved using new algorithms for closure analysis, allowing many objects to be allocated on a stack or, better still, in machine registers. Closure packing and hoisting allow more than one procedure to share an environment without introducing indirection. Move instructions and memory references are reduced by passing arguments in registers and using a dynamic register allocation strategy. Register allocation and code generation are accomplished at the same time, with environ-ment pointers being treated as variables. Environment pointers are kept in a lazy display, being brought into registers and cached when needed. The interaction of this strategy with the closure analysis also allows many optimizations based on type information to be performed. Benchmarks are presented to show that, using these new techniques, the performance of programs written in <b>higher</b> <b>order</b> <b>languages</b> almost equals that of programs written in Pascal in both space and time. Thus the greater expressive power of <b>higher</b> <b>order</b> <b>languages</b> and debugging ease of traditional LISP systems need not be sacri ced to attain good performance. c Copyright byDavid A Kranz, 199...|$|R
2500|$|... 1976 – Evaluation of ALGOL 68, JOVIAL J3B, Pascal, Simula 67, and TACPOL Versus TINMAN - Requirements for a Common <b>High</b> <b>Order</b> Programming <b>Language.</b>|$|R
40|$|A {{comparative}} evaluation {{was made}} of eight <b>higher</b> <b>order</b> <b>languages</b> of general interest in the aerospace field: PL/ 1; HAL; JOVIAL/J 3; SPL/J 6; CLASP; ALGOL 60; FORTRAN 4; and MAC 360. A summary of the functional requirements for a language for general use in manned aerodynamic applications is presented. The evaluation supplies background material {{to be used in}} assessing the worth of each language for some particular application...|$|R
40|$|Although <b>higher</b> <b>order</b> <b>language</b> models (LMs) {{have shown}} benefit of {{capturing}} word dependencies for Information retrieval (IR), the tuning {{of the increased}} number of free parameters remains a formidable engineering challenge. Consequently, in many real–world retrieval systems, applying higher order LMs is an {{exception rather than the}} rule. In this study, we address the parameter tuning problem using a framework based on a linear ranking model in which different component models are incorporated as features. Using unigram and bigram LMs with 2 –stage smoothing as examples, we show that our method leads to a bigram LM that outperforms significantly its unigram counterpart and the well–tuned BM 25 model. 1...|$|E
40|$|A {{programming}} language is presented {{for the flight}} software of the NASA Space Shuttle program. It is intended to satisfy {{virtually all of the}} flight software requirements of the space shuttle. To achieve this, it incorporates a wide range of features, including applications-oriented data types and organizations, real time control mechanisms, and constructs for systems programming tasks. It is a <b>higher</b> <b>order</b> <b>language</b> designed to allow programmers, analysts, and engineers to communicate with the computer in a form approximating natural mathematical expression. Parts of the English language are combined with standard notation to provide a tool that readily encourages programming without demanding computer hardware expertise. Block diagrams and flow charts are included. The semantics of the language is discussed...|$|E
40|$|Management {{concepts}} are presented for software development {{for a new}} technology area, i. e., real-time autonomous, computer-based spacecraft control. Flight computer selection and sizing are done initially to maximize performance within constraints of size, power, and cost. A <b>higher</b> <b>order</b> <b>language</b> is chosen to enhance productivity. Because the computer {{is embedded in the}} control systems hardware and is tied to the iterative design process of the spacecraft, the management and configuration control of the software is different from more typical applications. The development process must permit early coding but accept late changes. Margin management must be a continuing process in the development. Validation and verification is a special problem because it is not feasible to test the software in the actual operating environment prior to launch...|$|E
40|$|NASA {{software}} requirement specifications {{were used}} {{in the development of a}} system for validating and verifying computer programs. The software specification and evaluation system (SSES) provides for the effective and efficient specification, implementation, and testing of computer software programs. The system as implemented will produce structured FORTRAN or ANSI FORTRAN programs, but the principles upon which SSES is designed allow it to be easily adapted to other <b>high</b> <b>order</b> <b>languages...</b>|$|R
2500|$|... 1976 – Evaluation of ALGOL 68, Jovial J3B, PASCAL, SIMULA 67, and TACPOL Versus [...] Requirements for a Common <b>High</b> <b>Order</b> Programming <b>Language.</b> Oct 1976 ...|$|R
50|$|ESPOL (short for Executive Systems Problem Oriented Language) was a superset of ALGOL 60 that {{provided}} capabilities {{of what would}} later be known as Mohols, machine oriented <b>high</b> <b>order</b> <b>languages,</b> such as interrupting a processor on a multiprocessor system (the Burroughs large systems were multiprocessor processor systems). It was used to write the MCP (Master Control Program) on Burroughs computer systems from the B5000 to the B6700. The single-pass compiler for ESPOL could compile over 250 lines per second.|$|R
40|$|We present {{preliminary}} experiments of a binary-switch, static-grid typing interface {{making use}} of varying language model contributions. Our motivation is to quantify {{the degree to which}} language models can make the simplest scanning interfaces – such as showing one symbol at a time rather than a scanning a grid – competitive in terms of typing speed. We present a grid scanning method {{making use of}} optimal Huffman binary codes, and demonstrate the impact of <b>higher</b> <b>order</b> <b>language</b> models on its performance. We also investigate the scanning methods of highlighting just one cell in a grid at any given time or showing one symbol at a time without a grid, and show that they yield commensurate performance when using higher order n-gram models, mainly due to lower error rate and a lower rate of missed targets...|$|E
40|$|In this paper, we {{describe}} the RWTH statistical machine translation (SMT) system {{which is based on}} log-linear model combination. All knowledge sources are treated as feature functions which depend on the source language sentence, the target language sentence and possible hidden variables. The main feature of our approach are the alignment templates which take shallow phrase structures into account: a phrase level alignment between phrases and a word level alignment between single words within the phrases. Thereby, we directly consider word contexts and local reorderings. In order to incorporate additional models (the IBM- 1 statistical lexicon model, a word deletion model, and <b>higher</b> <b>order</b> <b>language</b> models), we perform n-best list rescoring. Participating in the International Workshop on Spoken Language Translation (IWSLT 2004), we evaluate our system on the Basic Travel Expression Corpus (BTEC...|$|E
40|$|The {{software}} {{developed for}} the Fault-Tolerant Multiprocessor (FTMP) is described. The FTMP executive is a timer-interrupt driven dispatcher that schedules iterative tasks which run at 3. 125, 12. 5, and 25 Hz. Major tasks which run under the executive include system configuration control, flight control, and display. The flight control task includes autopilot and autoland functions for a jet transport aircraft. System Displays include status displays of all hardware elements (processors, memories, I/O ports, buses), failure log displays showing transient and hard faults, and an autopilot display. All software is in a <b>higher</b> <b>order</b> <b>language</b> (AED, an ALGOL derivative). The executive is a fully distributed general purpose executive which automatically balances the load among available processor triads. Provisions for graceful performance degradation under processing overload {{are an integral part}} of the scheduling algorithms...|$|E
40|$|Based on an {{analysis}} of previously developed test oriented languages and a study of test <b>language</b> requirements, a <b>high</b> <b>order</b> <b>language</b> was designed to enable test and flight engineers to checkout and operate the proposed space shuttle and other NASA vehicles and experiments. The language is called ALOFT (a language oriented to flight engineering and testing). The language is described, its terminology is compared to similar terms in other test languages, and its features and utilization are discussed. The appendix provides the specifications for ALOFT...|$|R
50|$|The Bernstein-Robinson proof the {{invariant}} subspace conjecture uses non-standard {{models of}} <b>higher</b> <b>order</b> predicate <b>languages,</b> and when Robinson sent me his reprint I {{really had to}} sweat to pinpoint and translate its mathematical insight.|$|R
40|$|This report, A Review of Non-Ada to Ada Conversion, {{provides}} {{a discussion of}} the processes and problems involved with the conversion of software from early <b>High</b> <b>Order</b> <b>Languages</b> (HOLs) to Ada. Specific compatibility and format difficulties are discussed for each HOL examined, including C, Cobol, Fortran, Jovial, Modula- 2, and Pascal. Several conversion approaches are presented, along with {{the advantages and disadvantages of}} each. Three specific conversion projects are overviewed. Several currently available Off the Shelf (OTS) tools to help the conversion process are included for reference, with a short discussion of each...|$|R
