138|1211|Public
5|$|It is also {{possible}} to check whether a given directed graph is a DAG in linear time, either by attempting to find a topological ordering and then testing for each edge whether the resulting ordering is valid or alternatively, for some topological sorting algorithms, by verifying that the algorithm successfully orders all the vertices without meeting an <b>error</b> <b>condition.</b>|$|E
5|$|Handshake packets {{consist of}} only a single PID byte, and are {{generally}} sent in response to data packets. Error detection is provided by transmitting four bits, which represent the packet type twice, in a single PID byte using complemented form. The three basic types are ACK, indicating that data was successfully received; NAK, indicating that the data cannot be received and should be retried; and STALL, indicating that the device has an <b>error</b> <b>condition</b> and cannot transfer data until some corrective action (such as device initialization) occurs.|$|E
2500|$|RFC 3629 states [...] "Implementations of the {{decoding}} algorithm MUST {{protect against}} decoding invalid sequences." [...] The Unicode Standard requires decoders to [...] "...treat any ill-formed code unit sequence as an <b>error</b> <b>condition.</b> This guarantees {{that it will}} neither interpret nor emit an ill-formed code unit sequence." ...|$|E
25|$|The MMU {{may also}} {{generate}} illegal access <b>error</b> <b>conditions</b> or invalid page faults upon illegal or non-existing memory accesses, respectively, leading to segmentation fault or bus <b>error</b> <b>conditions</b> when {{handled by the}} operating system.|$|R
40|$|Adaptive error-correction {{has been}} {{investigated}} to make more efficient use of the storage capacity of a digital magnetic recording channel compared to fixed error-correction, without loss of data reliability. Conventional data storage devices employ a fixed level of error-correction designed to correct worst-case <b>error</b> <b>conditions.</b> Consequently, typical redundancies of between 30 % and 40 % are required to correct these worst-case <b>error</b> <b>conditions.</b> Because these worst-case <b>error</b> <b>conditions</b> occur infrequently this level of redundancy is unnecessary {{for much of the}} time. Adaptive error-correction permits only the necessary level of error-correction, and hence level of redundancy, to be applied according to the prevailing <b>error</b> <b>conditions</b> of the channel. A compact-cassette write-read-write recording system that monitors the digital magnetic recording channel, assessing the prevailing <b>error</b> <b>conditions</b> has been developed. Severe bit error rates of up to 7 x 10 - 5 have been introduced to the channel of this system. Using specially developed software Reed-Solomon codes and product codes have been employed under these severe <b>error</b> <b>conditions</b> to determine appropriate error-correction strategies for an adaptive error-correction system. This adaptive error-correction system has been compared to a fixed error-correction system. Results show that potential storage capacity savings of 40 % can be achieved over fixed error-correction under these severe <b>error</b> <b>conditions</b> with no loss in data reliability. Under less severe error rates even greater savings should be obtainable. An adaptive error-correction algorithm to select the appropriate level of error-correction according to the prevailing <b>error</b> <b>conditions</b> has been developed. Also, FPGA (Field Programmable Gate Array) technology to vary the level of error-correction eliminating the requirement for multiple encoder/decoder hardware {{has been investigated}}. Finally, a microprocessor controlled adaptive error-correction digital magnetic recording system incorporating an FPGA has been designed...|$|R
5000|$|Performance {{increases}} {{by avoiding}} needless calculations, and <b>error</b> <b>conditions</b> in evaluating compound expressions.|$|R
2500|$|Normally, {{a target}} holds DEVSEL# {{asserted}} {{through the last}} data phase. [...] However, if a target deasserts DEVSEL# before disconnecting without data (asserting STOP#), this indicates a target abort, which is a fatal <b>error</b> <b>condition.</b> [...] The initiator may not retry, and typically treats it as a bus error. [...] Note that a target may not deassert DEVSEL# while waiting with TRDY# or STOP# low; it must do this {{at the beginning of}} a data phase.|$|E
2500|$|Languages {{that are}} {{strongly}} typed and don't allow direct memory access, such as COBOL, Java, Python, and others, prevent buffer overflow from occurring in most cases. Many programming languages other than C/C++ provide runtime checking {{and in some}} cases even compile-time checking which might send a warning or raise an exception when C or C++ would overwrite data and continue to execute further instructions until erroneous results are obtained which might or might not cause the program to crash. [...] Examples of such languages include Ada, Eiffel, Lisp, Modula-2, Smalltalk, OCaml and such C-derivatives as Cyclone, Rust and D. The Java and [...]NET Framework bytecode environments also require bounds checking on all arrays. Nearly every interpreted language will protect against buffer overflows, signaling a well-defined <b>error</b> <b>condition.</b> Often where a language provides enough type information to do bounds checking an option is provided to enable or disable it. Static code analysis can remove many dynamic bound and type checks, but poor implementations and awkward cases can significantly decrease performance. Software engineers must carefully consider the tradeoffs of safety versus performance costs when deciding which language and compiler setting to use.|$|E
2500|$|The {{regulatory}} {{intent of}} OBD-I was to encourage auto manufacturers to design reliable {{emission control systems}} that remain effective for the vehicle's [...] "useful life". The Diagnostic Trouble Codes (DTCs) of OBD-I vehicles can usually be found without an expensive 'scan tool'. Each manufacturer used their own diagnostic link connector (DLC), DLC location, DTC definitions, and procedure to read the DTCs from the vehicle. DTCs from OBD-I cars are often read through the blinking patterns of the 'Check Engine Light' (CEL) or 'Service Engine Soon' (SES) light. By connecting certain pins of the diagnostic connector, the 'Check Engine' light will blink out a two-digit number that corresponds to a specific <b>error</b> <b>condition.</b> The DTCs of some OBD-I cars are interpreted in different ways, however. Cadillac (gasoline) fuel-injected vehicles are equipped with actual on-board diagnostics, providing trouble codes, actuator tests and sensor data through the new digital Electronic Climate Control display. Holding down 'Off' and 'Warmer' for several seconds activates the diagnostic mode {{without the need for}} an external scan tool. Some Honda engine computers are equipped with LEDs that light up in a specific pattern to indicate the DTC. General Motors, some 1989–1995 Ford vehicles (DCL), and some 1989–1995 Toyota/Lexus vehicles have a live sensor data stream available, however, many other OBD-I equipped vehicles do not. OBD-I vehicles have fewer DTCs available than for OBD-II equipped vehicles.|$|E
5000|$|... 1h - OK - {{element is}} {{installed}} and no <b>error</b> <b>conditions</b> are known ...|$|R
50|$|Event Reporting: Extended {{reporting}} to {{a client of}} <b>error</b> <b>conditions</b> and device state changes at a server.|$|R
5000|$|Abort (ABORTB) {{input and}} {{associated}} vector supports processor repairs of bus <b>error</b> <b>conditions,</b> such as page faults and memory access violations.|$|R
5000|$|On any <b>error</b> <b>condition</b> {{which may}} {{indicate}} instability or tampering; ...|$|E
50|$|Any <b>error</b> <b>condition</b> {{reported}} by the storage device to the HWB device shall be reported to the host.|$|E
5000|$|Caching failure: Forgetting {{to clear}} a cache that holds a {{negative}} result (error) after the <b>error</b> <b>condition</b> has been corrected ...|$|E
50|$|The NMT {{protocols}} {{are used}} to issue state machine change commands (e.g. to start and stop the devices), detect remote device bootups and <b>error</b> <b>conditions.</b>|$|R
50|$|The status {{register}} indicates {{the status of}} the IRQ, DSR and DCD lines, transmitter and receiver data Registers, and overrun, framing and parity <b>error</b> <b>conditions.</b>|$|R
50|$|Access to the {{computing}} environment (e.g., the program's command line, environment variables, textual explanation of <b>error</b> <b>conditions)</b> remained a problem {{until it was}} addressed by the 2003 standard.|$|R
5000|$|If a timer expires {{before a}} Keepalive message is received, or if an <b>error</b> <b>condition</b> occurs, the router {{transitions}} {{back to the}} Idle state.|$|E
50|$|Each command {{data packet}} has a {{corresponding}} response data packet. The {{response to a}} particular packet isvariable in size and may indicate an <b>error</b> <b>condition.</b>|$|E
5000|$|... checked: Before the {{conversion}} is performed, a runtime check {{is done to}} see if the destination type can hold the source value. If not, an <b>error</b> <b>condition</b> is raised.|$|E
50|$|Error {{codes are}} slowly disappearing from the programmer's {{environment}} as modern object-oriented programming languages {{replace them with}} exceptions. Exceptions {{have the advantage of}} being handled with explicit blocks of code, separate {{from the rest of the}} code. While it is considered poor practice in methodologies that use error codes and return codes to indicate failure, programmers often neglect to check return values for <b>error</b> <b>conditions.</b> That negligence can cause undesirable effects, as ignored <b>error</b> <b>conditions</b> often cause more severe problems later in the program. Exceptions are implemented in such a way as to separate the error handling code from the rest of the code. Separating the error handling code from the normal logic makes programs easier to write and understand, since one block of error handling code can service errors from any number of function calls. Exception handling also makes the code more readable than implementations with error codes, since exception handling does not disrupt the flow of the code with frequent checks for <b>error</b> <b>conditions.</b>|$|R
50|$|In {{the field}} of {{computer}} programming, the HRESULT is a data type used in Windows operating systems, and the earlier IBM/Microsoft OS/2 operating system, to represent <b>error</b> <b>conditions,</b> and warning conditions.|$|R
2500|$|In two's {{complement}} arithmetic, {{attempts to}} divide the smallest signed integer by [...] are attended by similar problems, and are handled with the same range of solutions, from explicit <b>error</b> <b>conditions</b> to undefined behavior.|$|R
50|$|If this {{procedure}} reaches the last certificate in the chain, with no name constraint or policy violations {{or any other}} <b>error</b> <b>condition,</b> then the certificate path validation algorithm terminates successfully.|$|E
5000|$|In {{case the}} CPort cannot {{keep up with}} the {{incoming}} data stream, one or more messages may be corrupted (due to missing data) and the receiver is notified about this <b>error</b> <b>condition.</b>|$|E
50|$|There {{is also a}} SAE J1939 standard, {{used for}} CAN data {{transmission}} in heavy road vehicles, which has four logical (boolean) values: False, True, <b>Error</b> <b>Condition,</b> and Not installed (represented by values 0-3). <b>Error</b> <b>Condition</b> means there is a technical problem obstacling data acquisition. The logics for that is for example True and Error Condition=Error Condition. Not installed is used for a feature that {{does not exist in}} this vehicle, and should be disregarded for logical calculation. On CAN, usually fixed data messages are sent containing many signal values each, so a signal representing a not-installed feature will be sent anyway.|$|E
50|$|Shinken is an {{open source}} {{computer}} system and network monitoring software application compatible with Nagios. It watches hosts and services, gathers performance data and alerts users when <b>error</b> <b>conditions</b> occur and again when the conditions clear.|$|R
50|$|This {{may require}} many {{simulations}} of different <b>error</b> <b>conditions</b> {{in order to}} determine the relative success of each tuning algorithm, and to allow recommendations for the collection of algorithms to be deployed on the real machine.|$|R
50|$|The tests {{contained}} in the JSR are supposedly derived from the statements in the JSR specification. Any given API will {{have a set of}} tests to ensure that it behaves in the intended way, including in <b>error</b> <b>conditions.</b>|$|R
5000|$|Automatic {{switchover}} of a {{redundant system}} on an <b>error</b> <b>condition,</b> without human intervention, is called failover. Manual switchover on error {{would be used}} if automatic failover is not available, possibly because the overall system is too complex.|$|E
50|$|Additionally the Harbour Error Object {{supports}} canDefault, canRetry and canSubstitute properties, {{which allows}} error handlers to perform some preparations, and then request a Retry Operation, a Resume, or return a Value {{to replace the}} expression triggering the <b>error</b> <b>condition.</b>|$|E
5000|$|MS-WEBDAVE: Web Distributed Authoring and Versioning Error Extensions Protocol Specification. This SharePoint Front-End Protocol {{describes}} extended {{error codes}} and extended error handling mechanism specified in MS-WDV to enable compliant servers to report <b>error</b> <b>condition</b> details on a server response.|$|E
5000|$|Python {{supports}} (and extensively uses) {{exception handling}} {{as a means}} of testing for <b>error</b> <b>conditions</b> and other [...] "exceptional" [...] events in a program. Indeed, it is even possible to trap the exception caused by a syntax error.|$|R
5000|$|... errno.h is a header file in the {{standard}} library of the C programming language. It defines macros for reporting and retrieving <b>error</b> <b>conditions</b> through <b>error</b> codes stored in a static memory location called [...] (short for [...] "error number").|$|R
30|$|This {{paper is}} {{organized}} as follows. Section 2 summarizes the {{previous research on}} constraint-based data cleansing. Section 3 describes our method for discovering <b>error</b> <b>conditions</b> and generating a repair. Section 4 presents our experimental evaluation. Finally, Sect. 5 concludes our paper.|$|R
