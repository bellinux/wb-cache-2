198|99|Public
25|$|The {{official}} Acorn RISC Machine project {{started in}} October 1983. They chose VLSI Technology as the silicon partner, {{as they were}} a source of ROMs and custom chips for Acorn. Wilson and Furber led the design. They implemented it with a similar efficiency ethos as the 6502. A key design goal was achieving low-latency input/output (<b>interrupt)</b> <b>handling</b> like the 6502. The 6502's memory access architecture had let developers produce fast machines without costly direct memory access (DMA) hardware.|$|E
25|$|A {{device driver}} is a {{specific}} type of computer software developed to allow interaction with hardware devices. Typically this constitutes an interface for communicating with the device, through the specific computer bus or communications subsystem that the hardware is connected to, providing commands to and/or receiving data from the device, and on the other end, the requisite interfaces to the operating system and software applications. It is a specialized hardware-dependent computer program which is also operating system specific that enables another program, typically an operating system or applications software package or computer program running under the operating system kernel, to interact transparently with a hardware device, and usually provides the requisite <b>interrupt</b> <b>handling</b> necessary for any necessary asynchronous time-dependent hardware interfacing needs.|$|E
25|$|The C64 uses a {{somewhat}} complicated memory banking scheme; the normal power-on default {{is to have}} the BASIC ROM mapped in at $A000 and the screen editor/kernal ROM at $E000. Memory underneath the system ROMs can be written to, but not read back without swapping out the ROMs. $1 contains a register with control bits for enabling/disabling the system ROMS as well as the I/O area at $D000. Most software swaps out the BASIC ROM, less often the kernal as the user must then provide his own code for I/O and <b>interrupt</b> <b>handling.</b> The $D000 page contains the I/O registers at power on, it can either be swapped with the character ROM (normally invisible to the CPU) or else simply the bare RAM underneath. If the I/O registers are swapped out, it is also necessary to disable interrupts via a SEI instruction. Theoretically, if all ROMs and the I/O area are swapped out, the entire 64k of system RAM is accessible to software aside from $0/$1 and the color RAM at $D800. If the kernel ROM is swapped out, BASIC will be removed with it and {{it is not possible to}} have BASIC active without the kernel.|$|E
5000|$|Unlike other event handlers, <b>interrupt</b> <b>handles</b> are {{expected}} to set interrupt flags to appropriate values {{as part of their}} core functionality.|$|R
50|$|Controls memory {{management}} through virtual memory technique, system <b>interrupts,</b> exception <b>handling,</b> and breakpoints.|$|R
40|$|An {{important}} part of implementing device drivers is to control the interrupt facilities of the hardware platform and to program interrupt handlers. Current methods for <b>handling</b> <b>interrupts</b> in Java use a server thread waiting for the VM to signal an interrupt occurrence. It means that the <b>interrupt</b> is <b>handled</b> at a later time, which has some disadvantages. We present constructs that allow <b>interrupts</b> to be <b>handled</b> directly and not at a later point decided by a scheduler. A desirable feature of our approach {{is that we do}} not require a native middelware layer but can <b>handle</b> <b>interrupts</b> entirely with Java code. We have implemented our approach using an interpreter and a Java processor, and give an example demonstrating its use. ...|$|R
25|$|The {{protected}} mode of the 80286 was not utilized until {{many years after}} its release, {{in part because of}} the high cost of adding extended memory to a PC, but also because of the need for software to support the large user base of 8086 PCs. For example, in 1986 the only program that made use of it was VDISK, a RAM disk driver included with PC DOS 3.0 and 3.1. A DOS could utilize the additional RAM available in {{protected mode}} (extended memory) either via a BIOS call (INT 15h, AH=87h), as a RAM disk, or as emulation of expanded memory. The difficulty lay in the incompatibility of older real-mode DOS programs with protected mode. They simply could not natively run in this new mode without significant modification. In protected mode, memory management and <b>interrupt</b> <b>handling</b> were done differently than in real mode. In addition, DOS programs typically would directly access data and code segments that did not belong to them, as real mode allowed them to do without restriction; in contrast, the design intent of protected mode was to prevent programs from accessing any segments other than their own unless special access was explicitly allowed. While it was possible to set up a protected-mode environment that allowed all programs access to all segments (by putting all segment descriptors into the GDT and assigning them all the same privilege level), this undermined nearly all of the advantages of protected mode except the extended (24-bit) address space. The choice that OS developers faced was either to start from scratch and create an OS that would not run the vast majority of the old programs, or to come up with a version of DOS that was slow and ugly (i.e., ugly from an internal technical viewpoint) but would still run a majority of the old programs. Protected mode also did not provide a significant enough performance advantage over the 8086-compatible real mode to justify supporting its capabilities; actually, except for task switches when multitasking, it actually yielded only a performance disadvantage, by slowing down many instructions through a litany of added privilege checks. In protected mode, registers were still 16-bit, and the programmer was still forced to use a memory map composed of 64kB segments, just like in real mode.|$|E
2500|$|Automated Interrupt Prologue – adds {{hardware}} {{to save and}} update system status before the <b>interrupt</b> <b>handling</b> routine ...|$|E
5000|$|Deterministic <b>interrupt</b> <b>handling</b> {{as well as}} fast non-maskable {{interrupts}} ...|$|E
50|$|<b>Interrupts</b> are <b>handled</b> by {{creating}} a new stack frame on the stack for the relevant process, <b>handling</b> the <b>interrupt</b> using this new environment, and then popping the stack {{to return to the}} interrupted process.|$|R
40|$|Abstract. The final goal of our {{research}} project {{is to establish a}} typebased method for verification of certain critical properties (such as deadlockand race-freedom) of operating system kernels. As operating system kernels make heavy use of threads and interrupts, {{it is important that the}} method can properly deal with both of the two features. As a first step towards the goal, we formalize a concurrent calculus equipped with primitives for threads and <b>interrupts</b> <b>handling.</b> We also propose a type system that guarantees deadlock-freedom in the presence of interrupts. To our knowledge, ours is the first type system for deadlock-freedom that can deal with both thread and interrupt primitives. ...|$|R
50|$|This simple, {{one-step}} process allowed non-experienced programmers {{to learn}} programming with lower cost {{in time and}} computing resources.To aid in debugging, the compiler uses an innovative approach to checking for undefined variables (an extremely common mistake by beginning programmers). It uses a diagnostic feature of the 7040 that can deliberately set areas of memory to bad parity. When a program tries to reference variables that hadn't been set, the machine takes an <b>interrupt</b> (<b>handled</b> by the Watfor runtime routines) and the error is reported to the user as an undefined variable. This has the pleasant side effect of checking for undefined variables with essentially no CPU overhead.|$|R
5000|$|An {{advanced}} {{software interrupt}} facility that allowed user processes to operate asynchronously, using complex <b>interrupt</b> <b>handling</b> mechanisms.|$|E
5000|$|Automated Interrupt Prologue - adds {{hardware}} {{to save and}} update system status before the <b>interrupt</b> <b>handling</b> routine ...|$|E
5000|$|Microcontroller Unit (MCU) Subsystem: {{includes}} an ARM926EJ-S RISC processor and its accompanying memory management and <b>interrupt</b> <b>handling</b> logics; ...|$|E
5000|$|On the PDP-8/E {{and later}} models, the Memory Extension Controller was {{enhanced}} to enable machine virtualization. A program written {{to use a}} PDP-8's entire resources could coexist with other such programs on the same PDP-8 {{under the control of}} a virtual machine manager. The manager could make all I/O instructions (including those that operated on the Memory Extension Controller) cause a trap (an <b>interrupt</b> <b>handled</b> by the manager). In this way, the manager could map memory references, map data or instruction fields, and redirect I/O to different devices. Each original program had complete access to a [...] "virtual machine" [...] provided by the manager.|$|R
5000|$|The cost of {{reaching}} a globally consistent state {{in all of}} the processors. This depends on the communication network, but also on whether there is special-purpose hardware available for synchronizing, and on the way in which <b>interrupts</b> are <b>handled</b> by processors.|$|R
50|$|NachOS Machine - Nachos simulates {{a machine}} that roughly approximates the MIPS architecture. The machine has registers, memory and a cpu. The Nachos/MIPS machine is {{implemented}} by the Machine object, an instance of which is created when Nachos starts up. It contains methods like Run, ReadRegister, WriteRegister, etc. It also defines an <b>interrupt</b> object to <b>handle</b> <b>interrupts.</b> Timer and statistics are also implemented in this.|$|R
50|$|A FLIH {{implements}} {{at minimum}} platform-specific <b>interrupt</b> <b>handling</b> similar to interrupt routines. In {{response to an}} interrupt, there is a context switch, and the code for the interrupt is loaded and executed. The job of a FLIH is to quickly service the interrupt, or to record platform-specific critical information which is only {{available at the time}} of the interrupt, and schedule the execution of a SLIH for further long-lived <b>interrupt</b> <b>handling.</b>|$|E
50|$|Concurrent <b>interrupt</b> <b>handling</b> {{essentially}} mean concurrent {{execution of}} kernel code and hence induces the additional complexity of concurrency control in accessing kernel datastructures.|$|E
50|$|Virtual Machine Manager (VMM32.VXD): Responsible for memory management, event handling, <b>interrupt</b> <b>handling,</b> {{loading and}} {{initializing}} virtual device drivers, creating new virtual machines and thread scheduling.|$|E
50|$|The {{phenomenon}} {{where the}} overall system performance is severely hindered by excessive amounts of processing time spent <b>handling</b> <b>interrupts</b> is called an interrupt storm.|$|R
50|$|The kernel {{provides}} {{these and}} other basic services: <b>interrupt</b> and trap <b>handling,</b> separation between user and system space, system calls, scheduling, timer and clock handling, file descriptor management.|$|R
40|$|Abstract—The {{purpose of}} this paper is to {{describe}} an predictable CPU architecture, based on the five stage pipeline assembly line and a hardware scheduler engine. We aim at developing a fine-grained multithreading implementation, named nMPRA-MT. The new proposed architecture uses replication and remapping techniques for the program counter, the register file, and the pipeline registers and is implemented with a FPGA device. An original implementation of a MIPS processor with thread interleaved pipeline is obtained, using dynamic scheduling of hard real-time tasks and interrupts. In terms of <b>interrupts</b> <b>handling,</b> the architecture uses a particular method consisting of assigning interrupts to tasks, which insures an efficient control for both the context switch, and the system real-time behavior. The originality of the approach resides in the predictability and spatial isolation of the hard real-time tasks, executed every two clock cycles. The nMPRA-MT architecture is enabled by an innovative scheme of predictable scheduling algorithm, without stalling the pipeline assembly line. Keywords—fine-grained multithreading; hardware scheduler; pipeline; hard real-time; predictable I...|$|R
5000|$|MIPS M5100 and MIPS M5150 cores (MIPS32 Release 5): five-stage {{pipeline}} architecture, microMIPS ISA, the MIPS DSP Module r2, fast <b>interrupt</b> <b>handling,</b> advanced debug/profiling {{capabilities and}} power management.|$|E
50|$|Registers 16 through 24 {{are only}} {{accessible}} to specialized instructions. Except {{for the first}} two (r16 = pc = program counter, r17 = sr = status register), they are dedicated to exception and <b>interrupt</b> <b>handling.</b>|$|E
5000|$|Embedded Systems Architectures Summary of {{general-purpose}} architectures (recall). Focus on the ARM architecture; The coprocessor concept; Multiprocessor fundamentals; GPU architectures: basics, programming approaches. Lab on ARM with <b>interrupt</b> <b>handling</b> {{and design}} of a device driver.|$|E
40|$|Although some devices can be {{controlled}} using nothing but their I/O regions, most real-world devices are a bit more complicated than that. Devices {{have to deal with}} the external world, which often includes things such as spinning disks, moving tape, wires to distant places, and so on. Much has to be done in a time frame that is differ ent, and slower, than that of the processor. Since it is almost always undesirable to have the processor wait on external events, there must be a way for a device to let the processor know when something has happened. That way, of course, is interrupts. An interrupt is simply a signal that the hardware can send when it wants the processor’s attention. Linux <b>handles</b> <b>interrupts</b> in much the same way that it handles signals in user space. For the most part, a driver need only register a handler for its device’s <b>interrupts,</b> and <b>handle</b> them properly when they arrive. Of course, underneath that simple picture ther e is some complexity; in particular, interrupt handlers are somewhat limited in the actions they can perfor m as a result of how they are run. It is difficult to demonstrate the use of interrupts without a real hardware device to generate them. Thus, the sample code used in this chapter works with the parallel port. We’ll be working with the short module from the previous chapter; with some small additions it can generate and <b>handle</b> <b>interrupts</b> from the parallel port. The module’s name, short, actually means short int (it is C, isn’t it?), to remind us that it <b>handles</b> <b>interrupts.</b> Overall Control of Interrupts The way that Linux <b>handles</b> <b>interrupts</b> has changed quite a bit over the years, due to changes in design and in the hardware it works with. The PC’s view of interrupts in the early days was quite simple; there wer e just 16 interrupt lines and on...|$|R
50|$|When an {{interrupt}} is received, the computer's hardware automatically suspends whatever {{program is}} currently running, saves its status, and runs computer code previously {{associated with the}} interrupt; this is analogous to placing a bookmark in a book {{in response to a}} phone call. In modern operating systems, <b>interrupts</b> are <b>handled</b> by the operating system's kernel. Interrupts may come from either the computer's hardware or the running program.|$|R
5000|$|The XGATE co-{{processor}} is a 16-bit RISC processor {{operating at}} twice the main bus clock. It offloads work from the S12X core by <b>handling</b> <b>interrupts</b> only and does not run a background loop. The first versions of the XGATE do not allow for higher priority interrupts to pre-empt a currently <b>handled</b> <b>interrupt,</b> but the [...] "XGATEV3" [...] as featured in the 9S12XEP100 (and others) does allow this. The S12X can trigger software interrupts on the XGATE core and vice versa. A semaphore system is implemented to allow the S12X and XGATE cores to synchronize access to peripherals.|$|R
50|$|User and {{supervisor}} mode had separate banks of integer registers. <b>Interrupt</b> <b>handling</b> consisted of saving the PC, PSW, and SSW on the stack, clearing the PSW, and loading the PC and SSW from a memory trap vector.|$|E
50|$|Sequent Computer Systems was a {{computer}} company that designed and manufactured multiprocessing computer systems. They {{were among the}} pioneers in high-performance symmetric multiprocessing (SMP) open systems, innovating in both hardware (e.g., cache management and <b>interrupt</b> <b>handling)</b> and software (e.g., read-copy-update).|$|E
50|$|Data {{analysis}} {{evaluates the}} description and intended usage of each data item used in {{design of the}} software component. The use of interrupts and their effect on data should receive special attention to ensure <b>interrupt</b> <b>handling</b> routines do not alter critical data used by other routines.|$|E
2500|$|When an {{interrupt}} is received, the computer's hardware automatically suspends whatever {{program is}} currently running, saves its status, and runs computer code previously {{associated with the}} interrupt; this is analogous to placing a bookmark in a book {{in response to a}} phone call. [...] In modern operating systems, <b>interrupts</b> are <b>handled</b> by the operating system's kernel. Interrupts may come from either the computer's hardware or the running program.|$|R
50|$|The LINC-8 {{contained}} one PDP-8 CPU and one LINC CPU, partially emulated by the PDP-8. At any one time, {{the computer}} was in either 'LINC mode' or 'PDP-8 mode' - both processors could not run in parallel. Instructions were provided to switch between modes. In the LINC-8, all <b>interrupts</b> were <b>handled</b> by the PDP-8 CPU, and programs that relied on the interrupt architecture of the LINC could not be run.|$|R
50|$|In the x86 architecture, <b>interrupts</b> are <b>handled</b> {{through the}} <b>Interrupt</b> Dispatch Table (IDT). When a device {{triggers}} an interrupt, the interrupt flag (IF) in the flags register is {{set and the}} processor's hardware looks for an interrupt handler in the table entry corresponding to the interrupt number, or IRQ. Interrupt handlers usually save the state of all or some registers before handling it and restore the registers when done.|$|R
