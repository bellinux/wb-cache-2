1698|78|Public
25|$|This {{work also}} {{formed the basis}} for the <b>denotational</b> <b>semantics</b> of {{programming}} languages.|$|E
25|$|In <b>denotational</b> <b>semantics</b> {{a partial}} {{function}} is considered as returning the bottom element {{when it is}} undefined.|$|E
25|$|CSP {{has been}} imbued with several {{different}} formal semantics, which define {{the meaning of}} syntactically correct CSP expressions. The theory of CSP includes mutually consistent <b>denotational</b> <b>semantics,</b> algebraic semantics, and operational semantics.|$|E
30|$|<b>Denotational</b> net <b>semantics</b> for unsafe Petri nets are rare. Besides {{the work}} by Goltz [13] {{mentioned}} above, we know also of [3], where CSP [20] {{is given a}} <b>denotational</b> net <b>semantics</b> in terms of so-called open nets, a reactive extension of ordinary Petri nets, with the limitation that parallel composition is modeled by disjoint union and arc weight can only be 1. Future work will be devoted to define compositional (i.e., denotational in style) unsafe P/T net semantics for finite-net Multi-CCS, generalizing work of Goltz [13] and Taubner [33].|$|R
50|$|The <b>denotational</b> {{compositional}} <b>semantics</b> presented {{above is}} very general {{and can be}} used for functional, imperative, concurrent, logic, etc. programs (see 2008a). For example it easily provides denotation semantics for constructs that are difficult to formalize using other approaches such as delays and futures.|$|R
40|$|AbstractThe {{contribution}} {{of this research}} is to solve two problems simultaneously. One problem is to prescribe a semantics for the cut that does not introduce unsoundness into the declarative semantics of PROLOG programs. The other problem is to provide a general methodology for eliminating wasted computation time from PROLOG programs. The prescriptive approach or active approach to formal language design is employed. Prescriptive specifications are used as guidelines for modifying six formal semantic models (3 denotational models and 3 operational models). The formal semantic models used are (1) the <b>denotational</b> and operational <b>semantics</b> (of PROLOG) by Jones and Mycroft [13]; (2) the <b>denotational</b> and operational <b>semantics</b> (of PROLOG) by Debray and Mishra [8]; and (3) the <b>denotational</b> and operational <b>semantics</b> (of PROLOG) by Arbab and Berry [2]. These models are used as a basis for showing how the “procedural semantics” of PROLOG programs can be made to conform more closely to the declarative semantics of PROLOG {{and at the same time}} showing how the cut can be used to maximum advantage in making PROLOG programs more efficient...|$|R
25|$|The {{three major}} denotational models of CSP are the traces model, the stable {{failures}} model, and the failures/divergences model. Semantic mappings from process expressions {{to each of}} these three models provide the <b>denotational</b> <b>semantics</b> for CSP.|$|E
2500|$|Domain theory – Study {{of certain}} posets giving <b>denotational</b> <b>semantics</b> for lambda {{calculus}} ...|$|E
5000|$|Haskell's <b>Denotational</b> <b>semantics</b> (Discusses {{the role}} of Bottom in the <b>denotational</b> <b>semantics</b> of {{programming}} languages) ...|$|E
40|$|In {{this paper}} an {{extension}} of SDL by real-time assertions is suggested. A <b>denotational</b> compositional <b>semantics</b> in terms of timed high level Petri nets is given. This semantics allows to reason about timed SDL-specifications by simulation of the underlying high level nets {{as well as by}} unfolding these into timed low level nets and then applying analysis methods for timed Petri nets or temporal model checking. The approach is embedded in the MOBY-tool...|$|R
40|$|STAIRS is {{a method}} for the {{compositional}} development of interactions {{in the setting of}} UML 2. 0. In addition to defining <b>denotational</b> trace <b>semantics</b> for the main aspects of interactions, STAIRS focuses on how interactions may be developed through successive refinement steps. In this tutorial paper, we concentrate on explaining the practical relevance of STAIRS. Guidelines are given on how to create interactions using the different STAIRS operators, and how these may be refined. The pragmatics is illustrated by a running example...|$|R
40|$|We {{present a}} {{formalization}} {{of the first}} 100 pages of Winskel's The Formal Semantics of Programming Languages in the theorem prover Isabelle/HOL: 2 operational, 2 <b>denotational,</b> 1 axiomatic <b>semantics,</b> a verification condition generator, and the necessary soundness, completeness and equivalence proofs, all for a simple imperative language...|$|R
50|$|It {{is often}} {{considered}} important to connect <b>denotational</b> <b>semantics</b> with operational semantics. This {{is especially important}} when the <b>denotational</b> <b>semantics</b> is rather mathematical and abstract, and the operational semantics is more concrete or closer to the computational intuitions. The following properties of a <b>denotational</b> <b>semantics</b> are often of interest.|$|E
50|$|An {{operational}} semantics for QML {{is given in}} terms of quantum circuits, while a <b>denotational</b> <b>semantics</b> is presented in terms of superoperators, and these are shown to agree. Both the operational and <b>denotational</b> <b>semantics</b> have been implemented (classically) in Haskell.|$|E
50|$|<b>Denotational</b> <b>semantics</b> {{originated}} {{in the work of}} Christopher Strachey and Dana Scott published in the early 1970s. As originally developed by Strachey and Scott, <b>denotational</b> <b>semantics</b> provided the denotation (meaning) of a computer program as a function that mapped input into output. To give denotations to recursively defined programs, Scott proposed working with continuous functions between domains, specifically complete partial orders. As described below, work has continued in investigating appropriate <b>denotational</b> <b>semantics</b> for aspects of programming languages such as sequentiality, concurrency, non-determinism and local state.|$|E
40|$|In this paper, {{we present}} a {{framework}} for defining the formal semantics of behavioral VHDL 92 descriptions. We propose a complementary application of <b>denotational</b> and operational <b>semantics.</b> The static semantics is defined by denotational means. The definition of the dynamic semantics {{is based on an}} operational model using Interval Event Structures...|$|R
40|$|Abstract. The UML is the {{de facto}} {{standard}} for system specification, but offers little specialized support for the specification and analysis of policies. This paper presents Deontic STAIRS, {{an extension of the}} UML sequence diagram notation with customized constructs for policy speci-fication. The notation is underpinned by a <b>denotational</b> trace <b>semantics.</b> We formally define what it means that a system satisfies a policy speci-fication, and introduce a notion of policy refinement. We prove that the refinement relation is transitive and compositional, thus supporting a stepwise and modular specification process. The approach is exemplified with access control policies...|$|R
40|$|AbstractRecent work in {{real-time}} concurrency {{theory has}} largely been concerned with languages based on message passing, and execution models which assume an unlimited number of synchronous processors. Practical limitations on processor resources often make such theories unrealistic. We provide a <b>denotational</b> linear-history <b>semantics</b> for a real-time concurrent language L, under realistic assumptions about the execution environment. L is a low-level language which contains shared variables and constructs for synchronization and selective mutual exclusion. Among the execution models we consider are limited parallelism, in which the number of physical processors may he less {{than the number of}} processes, and asynchronous processors, which need not run at the same conceptual speed...|$|R
5000|$|... #Subtitle level 3: <b>Denotational</b> <b>semantics</b> as source-to-source {{translation}} ...|$|E
5000|$|... #Subtitle level 3: <b>Denotational</b> <b>semantics</b> of {{non-deterministic}} programs ...|$|E
5000|$|In {{computer}} science, <b>denotational</b> <b>semantics</b> is {{contrasted with}} operational semantics.|$|E
40|$|Abstract. We {{provide a}} <b>denotational</b> trace <b>semantics</b> for {{processes}} with synchronous communication and {{a form of}} weakly fair parallelism. The semantics is fully abstract: processes have the same trace sets {{if and only if}} their communication behaviors are identical in all contexts. The model can easily be adapted for asynchronously communicating processes, or for shared-memory parallel programs. We also provide a partial-order semantics, using pomsets adapted for synchronization and our form of fairness. The pomset semantics can also be adjusted to model alternative paradigms. The traces of a process can be recovered from the pomset semantics by taking all fair interleavings consistent with the partial order. ...|$|R
40|$|In {{this paper}} {{we focus on}} the {{construction}} of a declarative mediator language. The lan- guage provides the ability to handle multiple logic theories, extended with program expres- sions. Two motivating examples are presented. The <b>denotational</b> and operational <b>semantics</b> of the language are introduced and a bottom-up e cient implementation is de ned and proved correct with respect to the given semantics...|$|R
40|$|We {{show that}} the {{technique}} to prove equivalence of operational and <b>denotational</b> cpo based <b>semantics</b> using retractions, as introduced in [BV] for a sequential backtracking language, {{can be applied to}} parallel languages as well. We prove equivalence for a uniform language in which procedure calls need not be guarded. The unguardedness is taken care of by giving a semantics in which the nondeterminism is demonic...|$|R
5000|$|... #Subtitle level 3: <b>Denotational</b> <b>semantics</b> for {{programs}} of restricted complexity ...|$|E
50|$|The Actor model {{provides}} a modern and very general way the compositionality of {{programs can be}} analyzed. Scott and Strachey 1971 proposed that the semantics of programming languages be reduced to the semantics of the lambda calculus and thus inherit the <b>denotational</b> <b>semantics</b> of the lambda calculus. However, {{it turned out that}} concurrent computation could not be implemented in the lambda calculus (see Indeterminacy in concurrent computation). Thus there arose {{the problem of how to}} provide modular <b>denotational</b> <b>semantics</b> for concurrent programming languages. One solution to this problem is to use the Actor model of computation. In Actor model, programs are Actors that are sent Eval messages with the address of an environment (explained below) so that programs inherit their <b>denotational</b> <b>semantics</b> from the <b>denotational</b> <b>semantics</b> of the Actor model (an idea published in Hewitt 2006).|$|E
5000|$|<b>Denotational</b> <b>semantics</b> — by {{translation}} of the program into another language ...|$|E
40|$|AbstractThis {{paper is}} {{concerned}} with the problems encountered in defining the semantics of nondeterministic algorithms. A nondeterministic control structure is added to a typed λ-calculus and the usual operational semantics for the deterministic language is generalized {{to take into account the}} more complex behaviour of nondeterministic algorithms. A mathematical model is then given for the language and the relationship between the <b>denotational</b> and operational <b>semantics</b> is explored...|$|R
40|$|AbstractThe main {{contribution}} {{of this paper}} is a formal characterization of recursive object specifications and their existence based on a <b>denotational</b> untyped <b>semantics</b> of the object calculus. Existence is not guaranteed but can be shown employing Pitts’ results on relational properties of domains. The semantics can be used to analyse and verify Abadi and Leino's object logic but it also suggests extensions. For example, specifications of methods may not only refer to fields but also to methods of objects in the store. This can be achieved without compromising the existence theorem. An informal logic of predomains is in use intentionally in order to avoid any commitment to a particular syntax of specification logic...|$|R
50|$|Action Semantics aims to be pragmatic. Action-Semantic Descriptions (ASDs) are {{designed}} to scale up to handle realistic programming languages. This is aided by the extensibility and modifiability of ASDs. This helps to ensure that extensions and changes do not require too many changes in the description. This {{is in contrast to}} the typical case when extending <b>denotational</b> or operational <b>semantics,</b> which may require reformulation of the entire description.|$|R
5000|$|In 1970, Dana Scott first publishes {{his work}} on <b>denotational</b> <b>semantics.</b>|$|E
5000|$|... #Subtitle level 2: Intuitionistic logic, <b>denotational</b> <b>semantics,</b> linear logic, logical {{pluralism}} ...|$|E
50|$|This {{work also}} {{formed the basis}} for the <b>denotational</b> <b>semantics</b> of {{programming}} languages.|$|E
40|$|Csp-Casl {{integrates}} {{the process}} algebra Csp [9, 20] with the algebraic specification language Casl [16, 1]. Its novel aspects include {{the combination of}} denotational se-mantics in the process part and, in particular, loose semantics for the data types covering both concepts of partiality and sub-sorting. Technically, this integration involves {{the development of a}} new so-called data-logic formulated as an institution. This data-logic serves as a link between the institution underlying Casl and the alphabet of communications necessary for the Csp semantics. Besides being generic in the various <b>denotational</b> Csp <b>semantics,</b> this construction leads also to an ap-propriate notion of refinement with clear relations to both data refinement in Casl and process refinement in Csp. Key words: Algebraic specification; institution; process algebra; Casl, Csp. ...|$|R
40|$|In {{the context}} of {{abstract}} interpretation based static analysis, we cope {{with the problem of}} correctness and optimality for logic program analysis. We propose a new framework equipped with a <b>denotational,</b> goal-dependent <b>semantics</b> which refines many goal-driven frameworks appeared in the literature. The key point is the introduction of two specialized concrete operators for forward and backward unification. We prove that our goal-dependent semantics is correct w. r. t. computed answers and we provide the best correct approximations of all the operators involved in the semantics for set-sharing analysis. We show that the precision of the overall analysis is strictly improved and that, in some cases, we gain precision w. r. t. more complex domains involving linearity and freeness information. ...|$|R
40|$|STAIRS is an {{approach}} to the compositional development of sequence diagrams supporting the specification of mandatory as well as potential behavior. In order to express the necessary distinction between black-box and glass-box refinement, {{an extension of the}} semantic framework with three event messages is introduced. A concrete syntax is also proposed. The proposed extension is especially useful when describing time constraints. The resulting approach, referred to as Timed STAIRS, is formally underpinned by <b>denotational</b> trace <b>semantics.</b> A trace is a sequence built from three kinds of events: events for transmission, reception and consumption. We argue that such traces give the necessary expressiveness to capture the standard UML interpretation of sequence diagrams as well as the black-box interpretation found in classical formal methods...|$|R
