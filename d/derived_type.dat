74|2246|Public
25|$|In a subclassing hierarchy, the {{intersection}} of a type and an ancestor type (such as its parent) is the most <b>derived</b> <b>type.</b> The intersection of sibling types is empty.|$|E
25|$|C++ also {{provides}} the dynamic_cast operator, which allows code to safely attempt conversion of an object, via a base reference/pointer, {{to a more}} derived type: downcasting. The attempt is necessary as often one does not know which <b>derived</b> <b>type</b> is referenced. (Upcasting, conversion to a more general type, can always be checked/performed at compile-time via static_cast, as ancestral classes are specified in the derived class's interface, visible to all callers.) dynamic_cast relies on run-time type information (RTTI), metadata in the program that enables differentiating types and their relationships. If a dynamic_cast to a pointer fails, {{the result is the}} nullptr constant, whereas if the destination is a reference (which cannot be null), the cast throws an exception. Objects known to be of a certain <b>derived</b> <b>type</b> can be cast to that with static_cast, bypassing RTTI and the safe runtime type-checking of dynamic_cast, so this should be used only if the programmer is very confident the cast is, and will always be, valid.|$|E
25|$|Ekiti {{country is}} {{generally}} an upland zone, with elevations being generally above 450m throughout. Around Akure, elevations drop to around 360m. It lies on an area underlain by metamorphic rock, and is generally an undulating {{country with a}} characteristic landscape that consists of old plains broken by steep-sided outcrops that may occur singularly or in groups or ridges. Such outcrops {{can be seen in}} places at Aramoko, Efon-Alaaye, Ikere-Ekiti, Igbara-odo and Okemesi-Ekiti among others. Rugged hills dot the landscape, notable among which are the Olosunta hills of Ikere-Ekiti in the south, Effon ridge which runs longitudinally around Efon Alaaye on the western boundary, and Ado Hills in the centre. The topography was perhaps the single strongest reason why the Ekitis never became a single unit politically. The area enjoys a tropical climate with two distinct seasons. These are the rainy season which lasts from (April–October) and the dry season which commences in late November and ends in March. Temperature ranges between 21° and 28°C with high humidity. In the South, the vegetation is primarily Tropical hardwood forest, while a mixed / <b>derived</b> <b>type</b> savannah can be observed in the northern peripheries.|$|E
50|$|Twenty-five <b>derived</b> <b>types</b> {{are defined}} within the {{specification}} itself, and further <b>derived</b> <b>types</b> can be defined by users in their own schemas.|$|R
5000|$|Allocatable {{components}} of <b>derived</b> <b>types</b> (data structures) (partial implementation) ...|$|R
5000|$|Allocatable {{components}} of <b>derived</b> <b>types,</b> allocatable dummy arguments, and allocatable function results ...|$|R
500|$|Although Birgus latro is a <b>derived</b> <b>type</b> of hermit crab, {{only the}} juveniles use {{salvaged}} snail shells {{to protect their}} soft abdomens, and adolescents sometimes use broken coconut shells for that purpose. Unlike other hermit crabs, the adult coconut crabs do not carry shells but instead harden their abdominal terga by depositing chitin and chalk. Not being constrained by the physical confines {{of living in a}} shell allows this species to grow much larger than other hermit crabs in the family Coenobitidae. Like most true crabs, B.latro bends its tail underneath its body for protection. The hardened abdomen protects the coconut crab and reduces water loss on land, but has to be moulted periodically. Adults moult annually, and dig a burrow up to [...] long in which to hide while vulnerable. It remains in the burrow for 3 to 16 weeks, {{depending on the size of}} the animal. After moulting, it takes 1 to 3 weeks for the exoskeleton to harden, depending on the animal's size, during which time the animal's body is soft and vulnerable, and it stays hidden for protection.|$|E
5000|$|Default {{initialization}} of <b>derived</b> <b>type</b> components, including {{pointer initialization}} ...|$|E
50|$|Atomic values may {{belong to}} any of the 19 {{primitive}} types defined in the XML Schema specification (for example, string, boolean, double, float, decimal, dateTime, QName, and so on). They may also belong to a type derived from one of these primitive types: either a built-in <b>derived</b> <b>type</b> such as integer or Name, or a user-defined <b>derived</b> <b>type</b> defined in a user-written schema.|$|E
5000|$|Recursive allocatable {{components}} - as {{an alternative}} to recursive pointers in <b>derived</b> <b>types</b> ...|$|R
40|$|Quite often, in {{conceptual}} modeling, we need {{to represent}} a concept that can only exist in function of inferences applied in other elements. More specifically, Ontological Conceptual models need to represent <b>derived</b> <b>types</b> considering ontological consistence. Hence, in this work we discuss the implementation of <b>derived</b> <b>types</b> in ontology-driven conceptual modeling language regarding {{the interaction between the}} meta-properties of the language and the various types of derivation. Moreover, we have extended the OntoUML lightweight editor providing derivation patterns to facilitate the building of ontological models...|$|R
50|$|In May 1930 Renault {{was asked}} to develop two <b>derived</b> <b>types,</b> the Char D2 and the Char D3; the {{original}} Char D now received as designation Char D1.|$|R
5000|$|<b>Derived</b> <b>type</b> enhancements: {{parameterized}} derived types, improved {{control of}} accessibility, improved structure constructors, and finalizers ...|$|E
5000|$|For {{objects of}} <b>derived</b> <b>type</b> {{we have to}} {{distinguish}} between pointer and normal assignment. In ...|$|E
5000|$|An item of <b>derived</b> <b>type</b> {{is treated}} as if the {{components}} were specifiedin the same order as in the type declaration, so ...|$|E
5000|$|A list of 23 <b>derived</b> <b>types</b> can be found, for instance, in the Abhidhamma Pitaka's Dhammasangani (e.g., Dhs. 596), which omits {{the list}} of 24 derived types' [...] "heart-basis." ...|$|R
5000|$|Directly <b>derived</b> data <b>type</b> - <b>type</b> <b>derived</b> {{from one}} of the above types to give new name and initial value as a type.|$|R
5000|$|Input/output enhancements: {{asynchronous}} transfer, stream access, user specified {{transfer operations}} for <b>derived</b> <b>types,</b> user specified control of rounding during format conversions, named constants for preconnected units, the [...] statement, regularization of keywords, {{and access to}} error messages ...|$|R
5000|$|The subtype in the {{specialization}} {{relationship is}} also known as the [...] "child", subclass, derived class, <b>derived</b> <b>type,</b> inheriting class, or inheriting type.|$|E
5000|$|... {{depending}} on the circumstances or requirements. By qualifying objects of <b>derived</b> <b>type,</b> we obtain elements or sections {{depending on}} the rule stated earlier: ...|$|E
50|$|In a subclassing hierarchy, the {{intersection}} of a type and an ancestor type (such as its parent) is the most <b>derived</b> <b>type.</b> The intersection of sibling types is empty.|$|E
40|$|Abstract. We {{review the}} {{definition}} of entity <b>types</b> <b>derived</b> by symbolgenerating rules. These types appear frequently in conceptual schemas. However, up to now they have received very little attention {{in the field of}} conceptual modeling of information systems. Most conceptual modeling languages, like the UML and ORM, do not allow their formal definition. In this paper, we propose a new method for {{the definition of}} entity <b>types</b> <b>derived</b> by symbol-generating rules. Our method is {{based on the fact that}} these types can always be expressed as the result of the reification of a <b>derived</b> relationship <b>type.</b> Many languages, like the UML and ORM, allow defining <b>derived</b> relationship <b>types</b> and, at the same time, provide support for reification. Using our method, these languages can directly deal with those <b>derived</b> entity <b>types.</b> 1...|$|R
50|$|C's {{application}} binary interface (ABI) {{is supported}} {{as well as all}} of C's fundamental and <b>derived</b> <b>types,</b> enabling direct access to existing C code and libraries. D bindings are available for many popular C libraries. Additionally, C's standard library is a part of standard D.|$|R
5000|$|For <b>derived</b> <b>types</b> {{there are}} three possibilities: the type and its {{components}} are all PUBLIC, the type is PUBLIC and its components PRIVATE (the type only is visible and one can change its details easily), or {{all of it is}} PRIVATE (for internal use in the module only): ...|$|R
50|$|The {{order of}} {{expression}} evaluation is not specified {{in order to}} allow for optimization on parallel and vector machines. Of course, any operators for arrays of <b>derived</b> <b>type</b> must be defined.|$|E
5000|$|The [...] {{statement}} can be {{used for}} scalars and also for arrays and variables of <b>derived</b> <b>type.</b> It is also the only way to initialise just parts of such objects, as well as to initialise to binary, octal or hexadecimal values: ...|$|E
50|$|In many {{programming}} languages, it {{is possible}} to check through type introspection to determine whether the type of the referenced object is indeed the one being cast to or a <b>derived</b> <b>type</b> of it, and thus issue an error if it is not the case.|$|E
5000|$|The Cawood sword, and the {{closely related}} Korsoygaden sword, are notable {{in the context}} of {{delineating}} [...] "Viking Age swords" [...] from derived high medieval types; these swords fit neatly into the [...] "Viking sword" [...] typology, but Oakeshott (1991) considers them <b>derived</b> <b>types</b> dating to the 12th century.|$|R
5000|$|Type 16 (1883) carbine (11×60mmR). <b>Derived</b> from <b>Type</b> 13, {{structurally}} identical.|$|R
5000|$|For <b>derived</b> data <b>types,</b> {{the form}} of the type must be defined first: ...|$|R
5000|$|C++ also {{provides}} the [...] operator, which allows code to safely attempt conversion of an object, via a base reference/pointer, {{to a more}} derived type: downcasting. The attempt is necessary as often one does not know which <b>derived</b> <b>type</b> is referenced. (Upcasting, conversion to a more general type, can always be checked/performed at compile-time via , as ancestral classes are specified in the derived class's interface, visible to all callers.) [...] relies on run-time type information (RTTI), metadata in the program that enables differentiating types and their relationships. If a [...] to a pointer fails, {{the result is the}} [...] constant, whereas if the destination is a reference (which cannot be null), the cast throws an exception. Objects known to be of a certain <b>derived</b> <b>type</b> can be cast to that with , bypassing RTTI and the safe runtime type-checking of , so this should be used only if the programmer is very confident the cast is, and will always be, valid.|$|E
5000|$|The Hotchkiss H35 numbers {{include the}} informally named [...] "H 38" [...] or [...] "H 39" [...] {{variants}} (at the time both informal names indicated the same <b>derived</b> <b>type).</b> The total production number of 1200 given, is the minimal proven by photographic evidence regarding the series numbers. The first vehicles {{with the original}} engine and gun numbered 400; {{about half of the}} remainder was built or refitted with the L/35 SA 38 gun. Five H 35's were exported.|$|E
50|$|Creating {{an object}} often {{requires}} complex processes not appropriate to include within a composing object. The object's creation {{may lead to}} a significant duplication of code, may require information not accessible to the composing object, may not provide a sufficient level of abstraction, or may otherwise not be part of the composing object's concerns. The factory method design pattern handles these problems by defining a separate method for creating the objects, which subclasses can then override to specify the <b>derived</b> <b>type</b> of product that will be created.|$|E
40|$|We present {{techniques}} for <b>deriving</b> <b>types</b> from existing object-oriented types using the relational algebraic projection operation and for inferring the methods that are applicable to these types. Such type derivation occurs, for example, {{as a result}} of defining algebraic views over object types. We refactor the type hierarchy and place the <b>derived</b> <b>types</b> in the type hierarchy {{in such a way that}} the state and behavior of existing types remain exactly as before. Our results have applicability to relational databases extended with object-oriented type systems and to object-oriented systems that support algebraic operations. 1 Introduction In relational database systems, it is often useful to define views over sets of related data items for purposes of abstraction or encapsulation. Views are specified by using the standard algebraic query operations: e. g., projection, selection, join. A view is considered a virtual relation and is simply added to the the list of existing relations. Views ar [...] ...|$|R
50|$|A common {{library of}} basic {{attributes}} groups and <b>derived</b> data <b>types</b> {{are defined as}} well.|$|R
50|$|Types can {{be based}} on, or derived from, the basic types {{explained}} above. In some languages, such as C, functions have a <b>type</b> <b>derived</b> from the <b>type</b> of their return value.|$|R
