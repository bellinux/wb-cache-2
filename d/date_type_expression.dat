0|4092|Public
40|$|Abstract. An {{algorithm}} {{to decide}} the emptiness of a regular <b>type</b> <b>expression</b> with set operators given a set of parameterised type definitions is presented. The algorithm {{can also be used}} {{to decide the}} equivalence of two regular <b>type</b> <b>expressions</b> and the inclusion of one regular <b>type</b> <b>expression</b> in another. The algorithm strictly generalises previous work in that tuple distributivity is not assumed and set operators are permitted in <b>type</b> <b>expressions...</b>|$|R
40|$|An {{algorithm}} {{to decide}} the emptiness of a regular <b>type</b> <b>expression</b> with set operators given a set of parameterised type definitions is presented. The algorithm {{can also be used}} {{to decide the}} equivalence of two regular <b>type</b> <b>expressions</b> and the inclusion of one regular <b>type</b> <b>expression</b> in another. The algorithm strictly generalises previous work in that tuple distributivity is not assumed and set operators are permitted in <b>type</b> <b>expressions.</b> Keywords: <b>type,</b> emptiness, prescriptive type 1 Introduction Types play an important role in programming languages [6]. They make programs easier to understand and help detect errors. Types have been introduced into logic programming in the forms of type checking and inference [5, 9, 12, 26, 32] or type analysis [25, 33, 17, 19, 13, 22, 7, 23] or typed languages [16, 21, 28, 31]. Recent logic programming systems allow the programmer to declare types for predicates and type errors are then detected either at compile time or at run time. The reader is referred to [2 [...] ...|$|R
5000|$|... branch, segment, product group, company, brand, product, <b>date,</b> <b>type</b> of media, medium, {{advertising}} expenses, design code, credits, slogans/claims, full-text ...|$|R
50|$|In melanocytic cell <b>types,</b> <b>expression</b> of the CDK2 gene is {{regulated}} by the Microphthalmia-associated transcription factor.|$|R
40|$|A {{framework}} for the validation of axiomatic structure metrics is presented. In a case study, the comprehensibility of <b>type</b> <b>expressions</b> in the functional programming language Miranda has been investigated. A structure metric for the comprehensibility of <b>type</b> <b>expressions</b> has been developed together with internal and external axioms. This structure metric has been validated experimentally. The calibrated metric function results in a good prediction of the comprehensibilit...|$|R
40|$|Main {{topic of}} this thesis is to {{describe}} differences between two programming languages. It is specifically about programming language C# developed by Microsoft Corporation and programming language Java, created by Sun Microsystems, developed in these times by Oracle Corporation. Bachelors thesis analyses their conceptions, their approach to defini-tion of generic <b>date</b> <b>types,</b> differences in <b>date</b> <b>types</b> and <b>date</b> members, operators and com-pares possibilities of C# LINQ set of features with Java Streams API with the same examples. All differences are demonstrated by samples, {{most of them are}} part of the pro-ject, attached to this thesis...|$|R
5000|$|Any type {{variable}} unifies {{with any}} <b>type</b> <b>expression,</b> and is instantiated to that expression. A specific theory might restrict this rule with an occurs check.|$|R
50|$|Thanks to the Curry-Howard correspondence, a <b>typed</b> <b>expression</b> whose <b>type</b> {{corresponds}} to a logical formula is analogous to a proof of that formula. Here are examples.|$|R
40|$|Abstract. We {{present a}} monovariant flow {{analysis}} for System F (with recursion). The flow analysis yields both control-flow information, ap-proximating the λ- and Λ-expressions {{that may be}} bound to variables, and type-flow information, approximating the <b>type</b> <b>expressions</b> that may instantiate type variables. Moreover, the two flows are mutually bene-ficial: the control flow determines which Λ-expressions may be applied to which <b>type</b> <b>expressions</b> (and, hence, which <b>type</b> <b>expressions</b> may in-stantiate which type variables), while the type flow filters the λ- and Λ-expressions that may be bound to variables (by rejecting <b>expressions</b> with static <b>types</b> that are incompatible with the static type of the vari-able under the type flow). As is typical for a monovariant control-flow analysis, control-flow information is expressed as an abstract environ-ment mapping variables to sets of (syntactic) λ- and Λ-expressions {{that occur in the}} program under analysis. Similarly, type-flow information is expressed as an abstract environment mapping type variables to sets o...|$|R
25|$|The first Newfoundland traders' tokens were Halfpenny tokens {{issued by}} {{brothers}} Robert & I.S. Rutherford in St John's in 1840–41. There are two varieties of the tokens - a <b>dated</b> <b>type</b> and an undated type.|$|R
5000|$|Object storage {{explicitly}} separates file metadata {{from data}} to support additional capabilities:As opposed to fixed metadata in file systems (filename, creation <b>date,</b> <b>type,</b> etc.), object storage provides for full function, custom, object-level metadata in order to: ...|$|R
40|$|Abstract. We {{consider}} a simplified version of Nakano’s guarded fixed-point types in {{a presentation of}} infinite <b>type</b> <b>expression,</b> defined coinductively. Small-step reduction is parametrized by a natural number “depth ” that expresses under how many guards we may step during evaluation. We prove that reduction is strongly normalizing for any depth. The proof involves a typed inductive notion of strong normalization and a Kripke model of types in two dimensions: depth and typing context. Our results have been formalized in Agda {{and serve as a}} case study of reasoning about a language with coinductive <b>type</b> <b>expressions.</b> ...|$|R
30|$|In Haskell, a {{syntactic}} condition on <b>type</b> <b>expressions</b> {{that characterizes}} overloading whose resolution cannot be further deferred (i.e., must have occurred), {{which we call}} overloading resolution condition characterizes also “type ambiguity”. It is a syntactic condition, that conflicts with the standard definition of ambiguity, based {{on the existence of}} distinct type system derivations of the same <b>type</b> for an <b>expression.</b>|$|R
40|$|International audienceWe {{introduce}} the abstract concept of rational <b>type</b> <b>expression</b> and show {{its relationship to}} rational language theory. We further present a concrete syntax, regular <b>type</b> <b>expression,</b> and a Common Lisp implementation thereof which allows the programmer to declaratively express the types of heterogeneous sequences {{in a way which}} is natural in the Common Lisp language. The implementation uses techniques well known and well founded in rational language theory, in particular the use of the Brzozowski derivative and deterministic automata to reach a solution which can match a sequence in linear time. We illustrate the concept with several motivating examples, and finally explain many details of its implementation...|$|R
40|$|LOOJ is an {{extension}} of Java obtained by adding bounded parametric polymorphism and new <b>type</b> <b>expressions</b> ThisClass and ThisType, which are similar to MyType in LOOM. Through examples we demonstrate the utility of this language even over very expressive extensions such as GJ. The LOOJ compiler generates standard JVML code and supports instanceof and casts for all types including type variables and the other new <b>type</b> <b>expressions.</b> The core of the LOOJ type system is sound, as demonstrated by a soundness proof for {{an extension}} of Featherweight GJ. This paper also highlights difficulties that arise from the use of both classes and interfaces as types in Java...|$|R
50|$|A {{potential}} prom <b>date,</b> 'preppy' <b>type.</b>|$|R
5000|$|... models {{a simple}} <b>date</b> <b>type.</b> The value [...] {{corresponds}} to 1 April 2001. Given a date , the expression [...] {{is a natural}} number representing the month. Restrictions on days per month and leap years could {{be incorporated into the}} invariant if desired. Combining these: ...|$|R
40|$|We {{consider}} relational databases with typed {{attributes and}} {{are interested in}} relational algebra expressions which always result in a relation of some fixed <b>type.</b> Such <b>expressions</b> are called "type-safe". Type-safety is undecidable. We also consider "typed" relational algebra expressions, which are syntactically guaranteed to be type-safe. We then show that every expression is equivalent to a union of <b>typed</b> <b>expressions.</b> In particular, every type-safe expression is equivalent to a typed one. The undecidability of type-safety can thus be circumvented...|$|R
5000|$|Under equi{{recursive}} rules, a {{recursive type}} [...] and its unrolling [...] are equal -- that is, those two <b>type</b> <b>expressions</b> are understood to denote the same type. In fact, most theories of equirecursive types go further and essentially stipulate that any two <b>type</b> <b>expressions</b> {{with the same}} [...] "infinite expansion" [...] are equivalent. As {{a result of these}} rules, equirecursive types contribute significantly more complexity to a type system than isorecursive types do. Algorithmic problems such as type checking and type inference are more difficult for equirecursive types as well. Since direct comparison does not make sense on an equirecursive type, they can be converted into a canonical form in O(n log n) time, which can easily be compared.|$|R
2500|$|If {{the type}} of e and {{the type of}} x are the same, and {{assignment}} is allowed for that type, then this is a valid expression. Thus, in the simplest type systems, the question of whether two types are compatible reduces to that of whether they are equal (or equivalent). Different languages, however, have different criteria for when two <b>type</b> <b>expressions</b> are understood to denote the same type. These different equational theories of types vary widely, two extreme cases being structural type systems, in which any two types that describe values with the same structure are equivalent, and nominative type systems, in which no two syntactically distinct <b>type</b> <b>expressions</b> denote the same type (i.e., types must have the same [...] "name" [...] in order to be equal).|$|R
25|$|Bur {{dates are}} easily {{distinguishable}} from other <b>date</b> <b>types</b> by their nearly black colour. The sample fruits, from Sulhah on Sherari Island (صلحة في شرري), appear well proportioned, about 4cm long and fleshy. Bur dates can be eaten both fresh and dry, {{but should be}} consumed only in small amounts.|$|R
2500|$|To <b>date</b> the <b>types</b> of {{particle}} combinations explored at RHIC are , ...|$|R
40|$|We propose regular <b>expression</b> <b>types</b> as a {{foundation}} for statically typed XML processing languages. Regular <b>expression</b> <b>types,</b> like most schema languages for XML, introduce regular expression notations such as repetition (*), alternation (|), etc., to describe XML documents. The novelty of our type system is a semantic presentation of subtyping, as inclusion between the sets of documents denoted by two types. We give several examples illustrating the usefulness of this form of subtyping in XML processing. The decision problem for the subtype relation reduces to the inclusion problem between tree automata, which is known to be EXPTIME-complete. To avoid this high complexity in typical cases, we develop a practical algorithm that, unlike classical algorithms based on determinization of tree automata, checks the inclusion relation by a top-down traversal of the original <b>type</b> <b>expressions.</b> The main advantage of this algorithm is that it can exploit the property that <b>type</b> <b>expressions</b> being compared often share portions of their representations. Our algorithm is a variant of Aiken and Murphy 2 ̆ 7 s set-inclusion constraint solver, to which are added several new implementation techniques, correctness proofs, and preliminary performance measurements on some small programs in the domain of typed XML processing...|$|R
5000|$|The {{period of}} {{composition}} of cyclic masses was from about 1430 until around 1600, although some composers, especially in conservative musical centers, wrote them after that <b>date.</b> <b>Types</b> of cyclic masses include the [...] "motto" [...] mass (or [...] "head-motif" [...] mass), cantus-firmus mass, paraphrase mass, parody mass, {{as well as}} masses based on combinations of these techniques.|$|R
5000|$|... <b>date</b> and <b>type</b> of {{fertilizer}} or other chemicals applied, {{and to which}} plants ...|$|R
40|$|We derive Painlevé [...] <b>type</b> <b>expressions</b> for the {{distribution}} of the m^th largest eigenvalue in the Gaussian Orthogonal and Symplectic Ensembles in the edge scaling limit. The work of Johnstone and Soshnikov (see [7], [10]) implies the immediate relevance of our formulas for the m^th largest eigenvalue of the appropriate Wishart distribution...|$|R
40|$|AbstractType {{expressions}} {{may be used}} {{to describe}} the functional behavior of untyped lambda terms. We present a general semantics of polymorphic <b>type</b> <b>expressions</b> over models of untyped lambda calculus and give complete rules for inferring types for terms. Some simplified typing theories are studied in more detail, and containments between types are investigated...|$|R
40|$|Abstract Regular <b>expression</b> <b>types</b> {{have been}} {{proposed}} {{as a foundation for}} statically typed processing of XML and similar forms of tree-structured data. To <b>date,</b> however, regular <b>expression</b> <b>types</b> have been explored in special-purpose languages (e. g., XDuce, CDuce, and XQuery) with type systems designed around regular <b>expression</b> <b>types</b> &quot;from the ground up. &quot; The goal of the Xtatic language is to bring regular <b>expression</b> <b>types</b> to a broad audience by offering them as a lightweight extension of a popular object-oriented language,...|$|R
5000|$|Kappa {{calculus}} {{consists of}} <b>types</b> and <b>expressions,</b> given by thegrammar below: ...|$|R
40|$|Executive summary [...] 2 Source, <b>date</b> and <b>type</b> of request [...] . 2 Background [...] . ...|$|R
40|$|Course Contents This {{course will}} {{introduce}} {{the basic elements}} of a structural and imperative programming language. The C language will be used. Topics include the concept of <b>type,</b> main <b>types,</b> <b>expressions,</b> standard functions, input/output statements, type conversion, flow of control structures, ifthenelse, loop structures, whiledo, repeat until, fortodo, case statements; procedures and functions, modularity i...|$|R
40|$|AbstractAs {{a partial}} {{solution}} to the problem of combining static and dynamic typing in a language with parametric polymorphism, this paper introduces a new form of <b>type</b> <b>expressions</b> which represent partial <b>type</b> information. These <b>expressions</b> are meant to capture the type information statically derivable from heterogeneous objects. The new ground types form a semilattice of subtypes and require type inference based on inclusion constraints. We discuss the existence and form of principal types under this extension and present a semi-decision procedure for the complete type inference problem...|$|R
40|$|Regular <b>expression</b> <b>types</b> {{have been}} {{proposed}} {{as a foundation for}} statically typed processing of XML and similar forms of tree-structured data. To <b>date,</b> however, regular <b>expression</b> <b>types</b> have been explored in special-purpose languages (e. g., XDuce, CDuce, and XQuery) with type systems designed around regular <b>expression</b> <b>types</b> "from the ground up. " The goal of the Xtatic language is to bring regular <b>expression</b> <b>types</b> to a broad audience by offering them as a lightweight extension of a popular object-oriented language, C#. We develop [...] ...|$|R
50|$|Both <b>types</b> of <b>expressions</b> {{can be used}} {{to parse}} and compare data.|$|R
40|$|Background: Gene {{expression}} profiling of diffuse large B cell lymphoma (DLBCL) revealed three disease types: germinal centre B cell-like (GC), activated B cell-like (ABC), and a “third” <b>type.</b> <b>Expression</b> of CD 44 variant isoforms (CD 44 v) {{is associated}} with an unfavourable clinical outcome in DLBCL, but previous studies did not consider the clinicopathological heterogeneity of this disease...|$|R
40|$|We study {{recursive}} types from a syntactic perspective. In particular, {{we compare}} the formulations of recursive types {{that are used}} in programming languages and formal systems. Our main tool is a new syntactic explanation of <b>type</b> <b>expressions</b> as functors. We also introduce a simple logic for programs with recursive types in which we carry out our proofs...|$|R
