6|154|Public
50|$|Instruction {{relative}} addressing in 64-bit code (RIP + displacement, where RIP is the <b>instruction</b> <b>pointer</b> <b>register)</b> simplifies {{the implementation of}} position-independent code (as used in shared libraries in some operating systems).|$|E
50|$|The {{instruction}} {{set of the}} PDP-11 computer includes an instruction for moving data, which when constructed in a particular form causes itself to be moved from higher addresses to lower addresses; the form includes an automatic decrement of the <b>instruction</b> <b>pointer</b> <b>register.</b> Hence, when this instruction includes autodecrement of the instruction pointer, it behaves as a dynamic self-relocator.|$|E
5000|$|The {{instruction}} pointer is called [...] in 16-bit mode, [...] in 32-bit mode, and [...] in 64-bit mode. The <b>instruction</b> <b>pointer</b> <b>register</b> {{points to the}} memory address which the processor will next attempt to execute; it cannot be directly accessed in 16-bit or 32-bit mode, but a sequence like the following can be written to put the address of [...] into : ...|$|E
5000|$|Instructions can now {{reference}} data {{relative to the}} <b>instruction</b> <b>pointer</b> (RIP <b>register).</b> This makes position independent code, as is often used in shared libraries and code loaded at run time, more efficient.|$|R
50|$|In 64-bit mode, {{instructions}} can {{reference data}} {{relative to the}} <b>instruction</b> <b>pointer,</b> so there is less need to copy {{the value of the}} <b>instruction</b> <b>pointer</b> to another <b>register.</b>|$|R
50|$|The 8086 {{has eight}} {{more or less}} general 16-bit {{registers}} (including the stack pointer but excluding the <b>instruction</b> <b>pointer,</b> flag <b>register</b> and segment registers). Four of them, AX, BX, CX, DX, can also be accessed as twice as many 8-bit registers (see figure) while the other four, BP, SI, DI, SP, are 16-bit only.|$|R
5000|$|In the x86 {{assembly}} language, the '''''' instruction performs an unconditional jump. Such {{an instruction}} transfers {{the flow of}} execution by changing the <b>instruction</b> <b>pointer</b> <b>register.</b> There {{are a number of}} different opcodes that perform a jump; depending on whether the processor is in real mode or protected mode, and an override instruction is used, the instructions may take 16-bit, 32-bit, or segment:offset pointers.|$|E
5000|$|This 12 bit {{processor}} was {{the only}} commercially available chip to feature all four mathematical functions (addition, subtraction, multiplication and division) at the time. The choice of 12 bits was not accidental. For accuracy, {{it was determined that}} formulas needed to be able to resolve 1 part in 1000 or about 10 bits. Another bit was required for sign. This, logically, was rounded up to 12 bits which also resulted in an address space of 16 kilo-words. There was no [...] "stack" [...] for subroutine calls and returns. Rather the <b>Instruction</b> <b>Pointer</b> <b>Register</b> was [...] "swapped" [...] with another register that had been previously filled with the address of the target subroutine. Returning was accomplished by swapping back. All code was written in assembly language.|$|E
40|$|Background Fuzz testing {{can be used}} {{to detect}} {{software}} programming flaws present in an application by submitting malformed input to the application as it executes. Some programming flaws impact upon the security of an application by undermining the performance of controls, rendering the application vulnerable to attack. Hence, the discovery of programming flaws can lead to the discovery of security vulnerabilities. Fuzz testing (like almost all run-time testing) does not require access to the source code, which makes it attractive to those who wish to assess the security of an application, but are unable to obtain access to the source code, such as end-users, corporate clients, security researchers and cyber criminals. Motivation The author wanted to explore the value of fuzz testing {{from the point of view}} of a corporate client that intends to release software including a component developed by a third party, where the component source code is not available for review. Three case studies where conducted: two practical fuzz testing methodologies ('blind' data mutation and protocol analysis-based fuzzing) were employed to discover vulnerabilities in a commercial operating system, and a purposefully vulnerable web server, respectively. A third case study involved the exploitation of a vulnerability discovered using fuzz testing, including the production of 'Proof of Concept' code. Conclusions It was found that fuzzing is a valid method for identifying programming flaws in software applications, but additional analysis is required to determine whether discovered flaws represented a security vulnerability. In order to better understand the analysis and ranking of errors discovered using fuzz testing, exploit code was developed based on a flaw discovered using fuzz testing. It was found that the level of skill required to create such an exploit depends (largely) upon the nature of the specific programming flaw. In the worst case (where user-controlled input values are passed to the <b>instruction</b> <b>pointer</b> <b>register),</b> the level of skill required to develop an exploit that permitted arbitrary code execution was minimal. Due to the scale and range of input data accepted by all but the most simple of applications, fuzzing is not a practical method for detecting all flaws present in an application. However, fuzzing should not be discounted since no current software security testing methodology is capable of discovering all present flaws, and fuzzing can offer benefits such as automation, scalability, and a low ratio of false-positives...|$|E
50|$|In the x86 {{processor}} line, {{a typical}} pre-486 CPU {{did not have}} an individual register file, as all general purpose register were directly work with its decoder, and the x87 push stack was located within the floating-point unit itself. Starting with Pentium, a typical Pentium-compatible x86 processor is integrated with one copy of the single-port architectural register file containing 8 architectural registers, 8 control registers, 8 debug registers, 8 condition code registers, 8 unnamed based <b>register,</b> one <b>instruction</b> <b>pointer,</b> one flag <b>register</b> and 6 segment registers in one file.|$|R
40|$|In this era, many miscreants {{have changed}} their game. It’s {{easier for them to}} {{impersonate}} you or steal your private data from a vulnerable Web application than {{to take control of the}} Extended <b>Instruction</b> <b>Pointer</b> (EIP) <b>register</b> of your CPU. The reason is simple. As a software industry, we have more experience writing native applications in C and C++ than writing Web applications in PHP and JavaScript. People still write bugs in their code, but they are definitely harder to find and exploit than it was 10 years ago. In this article we will investigate one type of Web application vulnerability, namely Direct Object Reference. A Direct Object Reference occurs when an identifier, used in the internal implementation of a Web application, is exposed to users. When this is done insecurely, it can lead to a lot of trouble. This vulnerability is probably one of the easiest to exploit bu...|$|R
5000|$|With {{the advent}} of the 32-bit 80386 processor, the 16-bit {{general-purpose}} registers, base <b>registers,</b> index <b>registers,</b> <b>instruction</b> <b>pointer,</b> and FLAGS <b>register,</b> but not the segment registers, were expanded to 32 bits. The nomenclature represented this by prefixing an [...] "E" [...] (for [...] "extended") to the register names in x86 assembly language. Thus, the AX register corresponds to the lowest 16 bits of the new 32-bit EAX register, SI corresponds to the lowest 16 bits of ESI, and so on. The general-purpose registers, base registers, and index registers can all be used as the base in addressing modes, and all of those registers except for the stack pointer can be used as the index in addressing modes.|$|R
50|$|The CPU has two 16-bit {{general purpose}} {{register}}s, A and X, a base <b>pointer</b> <b>register</b> B, a stack pointer SP, and an <b>instruction</b> <b>pointer</b> PC. There {{is also a}} hidden register IR that is 8-bits wide and holds the currently executing opcode. It is not normally accessible by the programmer.|$|R
5000|$|Writing to the <b>{{instruction}}</b> <b>pointer</b> {{is simple}} — a [...] instruction sets the <b>instruction</b> <b>pointer</b> {{to the target}} address, so, for example, a sequence like the following will put the contents of [...] into : ...|$|R
5000|$|In 64-bit mode, near {{branches}} with the 66H (operand size override) prefix behave differently. Intel 64 ignores this prefix: the instruction has 32-bit sign extended offset, and <b>instruction</b> <b>pointer</b> is not truncated. AMD64 uses 16-bit offset {{field in the}} instruction, and clears the top 48 bits of <b>instruction</b> <b>pointer.</b>|$|R
5000|$|The {{language}} utilises a 64K {{block of}} memory, and 2 pointers - a memory <b>pointer</b> and an <b>instruction</b> <b>pointer.</b> The l33t interpreter tokenizes {{all the words}} in the source to create a sequence of numerical opCodes, and places them in order into the memory block, starting at byte 0. The <b>instruction</b> <b>pointer</b> will keep incrementing until it encounters an END. The memory pointer starts at the first byte after the instructions. Memory [...] "wraps": incrementing the memory and the <b>instruction</b> <b>pointer</b> past 64K will cause it to run around to byte 0, and vice versa.|$|R
5000|$|IP/EIP/RIP: <b>Instruction</b> <b>pointer.</b> Holds {{the program}} counter, the current {{instruction}} address.|$|R
5000|$|Brainfuck, which {{consists}} of only eight simple commands and an <b>instruction</b> <b>pointer</b> ...|$|R
50|$|Statistical {{sampling}} is {{the periodic}} recording of a processor's program counter or <b>instruction</b> <b>pointer.</b>|$|R
50|$|Arbitrary code {{execution}} {{is commonly}} achieved through {{control over the}} <b>instruction</b> <b>pointer</b> (such as a jump or a branch) of a running process. The <b>instruction</b> <b>pointer</b> points to the next instruction in the process that will be executed. Control over {{the value of the}} <b>instruction</b> <b>pointer</b> therefore gives control over which instruction is executed next. In order to execute arbitrary code, many exploits inject code into the process (for example by sending input to it which gets stored in an input buffer in RAM) and use a vulnerability to change the <b>instruction</b> <b>pointer</b> to have it point to the injected code. The injected code will then automatically get executed. This type of attack exploits the fact that most computers do not make a general distinction between code and data, so that malicious code can be camouflaged as harmless input data. Many newer CPUs have mechanisms to make this harder, such as a no-execute bit.|$|R
50|$|A funge is an esoteric {{programming}} language which models its programs as metric spaces with coordinate systems (often, but not necessarily, Cartesian) and which execute instructions located at points {{in their program}} space by moving an <b>instruction</b> <b>pointer</b> (a position vector which indicates the currently executing instruction) through that space. Different instructions determine {{the direction in which}} the <b>instruction</b> <b>pointer</b> moves, and consequently, the sequence of instructions that is executed.|$|R
50|$|The {{language}} {{consists of}} eight commands, listed below. A brainfuck {{program is a}} sequence of these commands, possibly interspersed with other characters (which are ignored). The commands are executed sequentially, with some exceptions: an <b>instruction</b> <b>pointer</b> begins at the first command, and each command it points to is executed, after which it normally moves {{forward to the next}} command. The program terminates when the <b>instruction</b> <b>pointer</b> moves past the last command.|$|R
50|$|Detect that a stack buffer {{overflow}} has occurred and thus prevent redirection of the <b>instruction</b> <b>pointer</b> to malicious code.|$|R
5000|$|Low level multiprocessing: Instead of {{a single}} <b>instruction</b> <b>pointer</b> a Redcode {{simulator}} has a process queue for each program containing a variable number of <b>instruction</b> <b>pointers</b> which the simulator cycles through. Each program starts with only one process, but new processes may {{be added to the}} queue using the [...] instruction. A process dies when it executes a DAT instruction or performs a division by zero. A program is considered dead when it has no more processes left.|$|R
5000|$|<b>Pointer</b> <b>registers</b> X, Y, and Z have {{addressing}} {{capabilities that}} are different from each other.|$|R
50|$|CS:IP (CS is Code Segment, IP is <b>Instruction</b> <b>Pointer)</b> {{points to}} the address where the {{processor}} will fetch the next byte of code.|$|R
5000|$|Definition: The {{contents}} of the <b>pointer</b> <b>register</b> is {{the address of the}} [...] "target" [...] register.|$|R
50|$|These can {{be divided}} to the {{explicit}} part (such as values stored in variables) and the implicit part (return addresses and the <b>instruction</b> <b>pointer).</b>|$|R
5000|$|... ip or i (<b>instruction</b> <b>pointer)</b> of {{the virtual}} machine (not to be {{confused}} with the program counter of the underlying hardware implementing the VM) ...|$|R
50|$|In QEMU, {{a triple}} fault {{produces}} a dump {{of the virtual}} machine in the console, with the <b>instruction</b> <b>pointer</b> set to the instruction that triggered the first exception.|$|R
50|$|If an <b>instruction</b> <b>pointer</b> error {{occurs during}} the {{execution}} {{and a program}} points to a memory segment filled with NOP instructions, inevitably an error occurred and is recognized.|$|R
5000|$|The MOVE {{instruction}} {{writes a}} 16-bit value {{into one of}} the chipset's hardware registers and is also used to strobe a new address into the Copper's <b>instruction</b> <b>pointer.</b>|$|R
5000|$|Internal {{memory of}} 8000 8-bit words memory {{is divided into}} 32-word pages. Instruction memory could be {{accessed}} using an <b>instruction</b> <b>pointer.</b> Data could be addressed using page:word offset.|$|R
50|$|With NOP-Fills, the {{reliability}} of a system {{in case of a}} disturbed <b>instruction</b> <b>pointer</b> can be improved in some cases. The entire program memory that is not used by the program code is filled with No-Operation (NOP) instructions. In machine code a NOP instruction is often represented by 0x00 (for example, Intel 8051, ATmega16, etc.). The system is kept in a defined state. At the end of the physical program memory, an <b>instruction</b> <b>pointer</b> error handling (IPEH IP-Error-Handler) has to be implemented. In some cases this can be a simple reset.|$|R
5000|$|For {{the purpose}} of {{fetching}} constant data, program memory is addressed bytewise through the Z <b>pointer</b> <b>register,</b> prepended if necessary by RAMPZ.|$|R
5000|$|Many esoteric {{programming}} languages {{follow the}} convention that any text not {{executed by the}} <b>instruction</b> <b>pointer</b> (e.g., Befunge) or otherwise assigned a meaning (e.g., Brainfuck), is considered a [...] "comment".|$|R
