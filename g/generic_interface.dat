246|503|Public
5000|$|A <b>generic</b> <b>interface</b> and its {{corresponding}} generic module, prefix the [...] or [...] keyword with , {{and take}} as formal arguments other interfaces. Thus (like C++ templates) {{one can easily}} define and use abstract data types,but unlike C++, the granularity is at the module level.An interface is passed to the <b>generic</b> <b>interface</b> and implementation modules as actual arguments, and thecompiler will generate concrete modules.|$|E
50|$|Persistency {{provides}} abstraction at {{the storage}} level. This <b>generic</b> <b>interface</b> {{can be used}} to implement any data-saving back-end, as long as transaction mechanism is provided.|$|E
5000|$|Introspection {{support for}} core {{libraries}} allowing external applications to query, get, set and operate on all {{classes in the}} scene graph, via a <b>generic</b> <b>interface</b> ...|$|E
30|$|Composition {{could include}} {{previously}} unknown services that implement certain <b>generic</b> <b>interfaces.</b>|$|R
30|$|<b>Generic</b> <b>interfaces</b> to {{exchange}} information across the protocol stack have been defined.|$|R
40|$|Abstract: Cognitive {{wireless}} {{networks are}} envisioned {{as a solution}} for intelligent ubiquitous networks {{that are capable of}} adapting to the dynamic environment through programmable radio devices. Each functional module and protocol accomplishes such learning by observing the various environmental, networking and application related parameters and adapts its behaviour to improve the performance. While access to a variety of parameters provide a large margin to improve the performance, it hinders the practical use of the system by restricting portability. In this paper, we argue that standard <b>generic</b> <b>interfaces</b> can be effectively used to overcome the above problem and enable seamless communication between modules at different layers and radio technologies. We examine the various parts of a cognitive wireless network, categorise different types of <b>generic</b> <b>interfaces,</b> analyse the suitable abstractions, and propose architectural principles for a cognitive radio system. We discuss four such categories of <b>generic</b> <b>interfaces</b> that abstract different layers of networking, application utility and policy enforcement. Various business benefits arising from such standard <b>generic</b> <b>interfaces</b> are briefly discussed. We believe that the proposed architecture and the benefits greatly enhance a feasible realisation of cognitive wireless networks. Keywords...|$|R
50|$|A type {{variable}} is an unqualified identifier. Type variables are introduced by generic class declarations, <b>generic</b> <b>interface</b> declarations, generic method declarations, and by generic constructor declarations.|$|E
50|$|<b>Generic</b> <b>Interface</b> Definition {{is a set}} {{of common}} {{services}} used for enterprise integration in the utility industry. It is defined in IEC standard IEC 61970 Part 4.|$|E
50|$|PKCS#11 is an API {{designed}} to be platform-independent, defining a <b>generic</b> <b>interface</b> to cryptographic tokens such as smart cards. This allows applications to work without knowledge of the reader details.|$|E
5000|$|Because many {{unit testing}} tools rely on {{inheritance}} to accomplish mocking, {{the usage of}} <b>generic</b> <b>interfaces</b> between classes (not only between modules when {{it makes sense to}} use generality) became the rule.|$|R
30|$|Flexibility. A <b>generic</b> user <b>interface</b> {{should be}} based on generic data models which are {{flexible}} to deal with different building operating systems. A <b>generic</b> user <b>interface</b> is not specifically designed for a particular building operating system, but on the contrary, the architecture of the <b>generic</b> user <b>interface</b> should be loosely coupled with its underlying building operating system, so that it is flexible enough to apply to different household buildings with different kinds of devices.|$|R
5000|$|Libdmc [...] is {{a library}} {{designed}} at the LIP6 [...] laboratory. Its {{goal is to}} ease the distribution of existing model checkers. It has also been designed to provide the most <b>generic</b> <b>interfaces,</b> without sacrificing performance, thanks to the C++ language.|$|R
5000|$|The Change Management Interface (CMI): CMI {{provides}} a <b>generic</b> <b>interface</b> for associating tasks with element versions and UCM activities. CMI can be configured {{to support the}} task providers ClearQuest, Rational Team Concert, and JIRA.|$|E
50|$|NIOS neither {{required}} nor used DPMS or Cloaking directly, {{and it did}} {{not provide}} a <b>generic</b> <b>interface</b> which could be used by non-NLM modules, however, it was certainly inspired by the DPMS technology and it can coexist with both of them.|$|E
5000|$|... • Grid Handler Interface: {{this is a}} <b>generic</b> <b>interface</b> {{above the}} grid plugins. By using this generic layer, no 3G Bridge {{components}} other than the grid plugins must contain grid-specific code. The methods a grid plugin should implement is: submission and status update.|$|E
5000|$|Implementing <b>generic</b> <b>interfaces</b> {{everywhere}} {{in a project}} makes it by far harder to understand and maintain. At each step the reader will ask themself what are the other implementations of this interface and the response is generally : only mocks.|$|R
2500|$|<b>Generic</b> <b>interfaces</b> and delegates {{can have}} their type {{parameters}} marked as covariant or contravariant, using keywords [...] and , respectively. These declarations are then respected for type conversions, both implicit and explicit, and both compile-time and run-time. For example, the existing interface [...] has been redefined as follows: ...|$|R
5000|$|On Solaris it is {{possible}} to control bindings of processes and LWPs to processor using the pbind(1) [...] program. To control the affinity programmatically processor_bind(2) [...] can be used. There are more <b>generic</b> <b>interfaces</b> available such as pset_bind(2) [...] or lgrp_affinity_get(3LGRP) [...] using processor set and locality groups concepts.|$|R
50|$|The {{purpose of}} Pspell (Portable Spell Checker Interface Library) {{was to provide}} a <b>generic</b> <b>interface</b> to the system {{spelling}} checking libraries. It was, and sometimes still is, used in computer programming such as C, and is licensed under the GNU Lesser General Public License.|$|E
5000|$|Browsing is an {{important}} principle in Moose, and it is supported in multiple ways as well. A <b>generic</b> <b>interface</b> enables the analyst to browse any model. To be able to specify specific browsers, Moose offers a generic engine that eases the specification through a specific fluent interface.|$|E
5000|$|<b>GENERIC</b> <b>INTERFACE</b> GenericStack(Element); (* Here Element.T is {{the type}} to be stored in the generic stack. *) TYPE T = Public OBJECT; Public = OBJECT METHODS init (...) : TStack; format (...) : TEXT; isEmpty (...) : BOOLEAN; count (...) : INTEGER; push(elm: Element.T); pop(VAR elem: Element.T): BOOLEAN; END; END GenericStack.|$|E
40|$|<b>Generic</b> <b>interfaces</b> to robot {{hardware}} {{can improve}} the programming process by {{making it easier for}} developers to port applications between different robotic systems. The Player project provides abstract interfaces to aide porting, but until recently did not have any direct support for robotic limbs. This paper describes the design and implementation of three new <b>generic</b> <b>interfaces</b> for robotic limbs and grippers: a low-level interface for controlling limb joints, a high-level interface for controlling end-effector pose, and an interface for controlling grippers. The design of the interfaces allows robot applications to quickly be ported between different robotic limbs and different robots. The interfaces are implemented in the Player project, with support provided in the driver for Pioneer robots, allowing the interfaces to be used to control the Pioneer robot arm and gripper. Other drivers are expected to be developed in the future, providing support for other robotic limbs. ...|$|R
50|$|Covariance and contravariance is {{supported}} by both languages. Java has use-site variance that allows a single generic class to declare members using both co- and contravariance. C# has define-site variance for <b>generic</b> <b>interfaces</b> and delegates. Variance is unsupported directly on classes but {{is supported}} through their implementation of variant interfaces. C# also has use-site covariance support for methods and delegates.|$|R
50|$|Another {{benefit of}} {{modularity}} {{is the use}} of <b>generic</b> <b>interfaces</b> for plug-ins. A single interface may be developed which allows old as well as new modules to be integrated seamlessly at run-time into pre-existing applications, without any modification to the application itself. This concept of dynamic extensibility is taken to the extreme with the Component Object Model, the underpinnings of ActiveX.|$|R
50|$|The RB {{locates the}} Grid input files {{specified}} in the job description using a service called the Data Location Interface (DLI), which provides a <b>generic</b> <b>interface</b> to a file catalogue. In this way, the Resource Broker can talk to file catalogues other than LFC (provided {{that they have a}} DLI interface).|$|E
50|$|The {{procedural}} part {{defines a}} <b>generic</b> <b>interface</b> between interactive digital applications and the terminals on which those applications are executed. It enables digital content providers to address {{all types of}} terminals ranging from low-end to high-end receivers with flexibility and portability. The specification also includes a special profile for portable reception.|$|E
50|$|The {{name of the}} {{function}} will be mangled as __m_MOD_five (e.g., GNU Fortran), m_MP_five_ (e.g., Intel's ifort), m.five_ (e.g., Oracle's sun95), etc. Since Fortran does not allow overloading {{the name of a}} procedure, but uses <b>generic</b> <b>interface</b> blocks and generic type-bound procedures instead, the mangled names do not need to incorporate clues about the arguments.|$|E
5000|$|... {{is an open}} {{standard}} {{developed by}} the World Wide Web Consortium since 2005. It was published as a Recommendation of the W3C on October 25, 2012. The document is a technical report specifying a multimodal system architecture and its <b>generic</b> <b>interfaces</b> to facilitate integration and multimodal interaction management in a computer system. It has been developed by the W3C's Multimodal Interaction Working Group.|$|R
40|$|International audienceObject algebras {{are a new}} {{programming}} {{technique that}} enables a simple solution to basic extensibility and modularity issues in programming languages. While object algebras excel at deﬁning modular features, the composition mechanisms for object algebras (and features) are still cumbersome and limited in expressiveness. In this paper we leverage two well-studied type system features, intersection types and type-constructor polymorphism, to provide object algebras with expressive and practical composition mechanisms. Intersection types are used for deﬁning expressive run-time composition operators (combinators) that produce objects with multiple (feature) interfaces. Type-constructor polymorphism enables <b>generic</b> <b>interfaces</b> for the various object algebra combinators. Such <b>generic</b> <b>interfaces</b> {{can be used as}} a type-safe front end for a generic implementation of the combinators based on reﬂection. Additionally, we also provide a modular mechanism to allow diﬀerent forms of self-references in the presence of delegation-based combinators. The result is an expressive, type-safe, dynamic, delegation-based composition technique for object algebras, implemented in Scala, which eﬀectively enables a form of Feature-Oriented Programming using object algebras...|$|R
5000|$|The [...]NET Framework {{provides}} the generic [...] and [...] classes that implement the <b>generic</b> [...] <b>interface.</b>|$|R
50|$|The line {{discipline}} glues {{the low level}} device driver code with the high level <b>generic</b> <b>interface</b> routines (such as read(2), write(2) and ioctl(2)), and is responsible for implementing the semantics associated with the device. The policy is separated from the device driver so that the same serial hardware driver {{can be used by}} devices that require different data handling.|$|E
50|$|Films output on Korsakow version 3 {{or earlier}} {{could only be}} viewed online in a single <b>generic</b> <b>interface.</b> This layout {{involved}} a single primary frame, in which the selected clips would play, and up to three preview frames of other related clips. While this remained the default layout in version 5.0, filmmakers now {{have the option of}} creating different interfaces for each SNU.|$|E
50|$|An {{interface}} is generic if it declares {{one or more}} type variables. These type {{variables are}} known as the type parameters of the interface. It defines one or more type variables that act as parameters. A <b>generic</b> <b>interface</b> declaration defines a set of types, one for each possible invocation of the type parameter section. All parameterized types share the same interface at runtime.|$|E
5000|$|... a <b>generic,</b> {{extensible}} <b>interface</b> layer, used in client code, {{which can}} interact with heterogeneous types, and ...|$|R
50|$|There is an {{overlap with}} the naked objects pattern, in that both are {{concerned}} with creating <b>generic</b> <b>interfaces</b> to domain objects models. But while the latter creates some kind of user interface, Restful Objects creates an API - specifically a Restful API. The first two frameworks to implement the Restful Objects standard were both built on top of existing frameworks that implement the Naked Objects pattern.|$|R
5000|$|The Location API is {{designed}} to work with many different positioning methods. <b>Generic</b> <b>interfaces</b> lets application developers implement systems that can retrieve location data from multiple sources, based on their availability on the device. It has advantages over a single means of tracking, including fail-over, indoor/outdoor transparency, and a choice between the speed and accuracy trade-offs between GPS, cellular, or other positioning methods. The API supports: ...|$|R
