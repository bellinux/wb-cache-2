78|127|Public
25|$|The {{tests and}} {{requirements}} to be met by capacitors for use in electronic equipment for approval as standardized types are {{set out in the}} <b>generic</b> <b>specification</b> IEC/EN 60384-1 in the following sections.|$|E
2500|$|Test {{specifications}} and parameter {{requirements are}} {{specified in the}} <b>generic</b> <b>specification</b> ...|$|E
2500|$|IEC 60384-1, Fixed {{capacitors}} for use {{in electronic}} equipment - Part 1: <b>Generic</b> <b>specification</b> ...|$|E
5000|$|IPC-6011 <b>Generic</b> Performance <b>Specification</b> for Printed Boards ...|$|R
40|$|Future {{versions}} of Java will include support for parametric polymorphism, or generic classes. This will bring many benefits to Java programmers, {{not least because}} current Java practise makes heavy use of pseudo-generic classes. Such classes (for example, those in package java. util) have logically <b>generic</b> <b>specifications</b> and documentation, but the type system cannot prove their patterns of use to be safe...|$|R
40|$|This article (further {{referred}} to as Math-I), {{and the next one}} (further {{referred to}} as Math-II, see p. 359), form a mathematical companion to the article in this encyclopedia on Generic Model Management (further {{referred to as}} GenMMt, see p. 258). Articles Math-I and II present the basics of the arrow diagram machinery that provides model management with truly <b>generic</b> <b>specifications.</b> Particularly, it allows us to build a generic pattern for heterogeneous data and schema transformation, which is presented in Math-II {{for the first time in}} the literature...|$|R
2500|$|IEC/EN 62391-1—Fixed {{electric}} double-layer capacitors {{for use in}} {{electric and}} electronic equipment - Part 1: <b>Generic</b> <b>specification</b> ...|$|E
2500|$|The {{electrical}} characteristics of capacitors are harmonized {{by the international}} <b>generic</b> <b>specification</b> IEC 60384-1. In this standard, the {{electrical characteristics}} of capacitors are described by an idealized series-equivalent circuit with electrical components that model all ohmic losses, capacitive and inductive parameters of an electrolytic capacitor: ...|$|E
5000|$|Test {{specifications}} and parameter {{requirements are}} {{specified in the}} <b>generic</b> <b>specification</b> ...|$|E
50|$|The C++11 Concepts <b>generic</b> {{programming}} <b>specification</b> {{would have}} made obsolete the Barton-Nackman trick. Concepts have since {{been removed from the}} final C++11 language standard,, but are proposed for inclusion in C++20.|$|R
40|$|These high-level, <b>generic</b> <b>specifications</b> {{have been}} {{drafted by the}} UAV-OAT TF. They require that UAV {{operations}} should not increase the risk to other airspace users; that ATM procedures should mirror those applicable to manned aircraft; and that the provision of air traffic services to UAVs should be transparent to ATC controllers. Moreover, they are not constrained by limitations in current UAV capability. The specifications {{have been subjected to}} a safety assurance process and, subsequently, to endorsement by the Military Team, formal consultation via the EUROCONTROL Notice of Proposed Rule-Making process, and acceptance by the Civil/Military Interface Committee. UAV Specification...|$|R
40|$|Abstract: The {{hybrid vehicle}} control {{problem at the}} highest level is termed the Energy Management Strategy (EMS). This paper {{presents}} a new, and simple Rule-Based (RB) EMS, whereby maximum power level of the electric machine during pure electric driving is the control design variable. This maximum power level determines the overall power-, and efficiency specifications of the electric machine. A RB EMS consist of a selection of driving modes. The RB EMS is compared with the strategy based on Dynamic Programming (DP), which is inherently optimal for a given cycle. The RB method proposed in this paper requires 3000 times less computation time with the same accuracy (± 1 %) as DP. The RB strategy in this paper is a semi-empirical EMS with which the <b>generic</b> component <b>specifications</b> for the secondary power source (battery, power electronics, electric machine), primary power source (engine) and transmission technology can be obtained. Provided these <b>generic</b> <b>specifications,</b> a technology designer can quickly specify the hybrid technologies. In this way, control, optimization and component design are merged in a single framework...|$|R
5000|$|ISO/IEC 23360-1:2006 Linux Standard Base (LSB) core {{specification}} 3.1 Part 1: <b>Generic</b> <b>specification</b> ...|$|E
5000|$|IEC 60384-1, Fixed {{capacitors}} for use {{in electronic}} equipment - Part 1: <b>Generic</b> <b>specification</b> ...|$|E
5000|$|IEC/EN 62391-1—Fixed {{electric}} double-layer capacitors {{for use in}} {{electric and}} electronic equipment - Part 1: <b>Generic</b> <b>specification</b> ...|$|E
40|$|International audiencePurpose - The {{purpose of}} this paper is to present a {{methodology}} for medical robot kinematics design developed using a knowledge-management approach. Design/methodology/approach - A classification of medical robots is proposed based on their kinematic characteristics and 76 robot specifications were collected in a catalogue. Then, having drawn a <b>generic</b> <b>specifications</b> sheet, rules were proposed to choose a structure from these specifications. Findings - Findings are situated at several levels: the catalogue, the classification of robots with respect to their kinematic characteristics, a <b>generic</b> and specific <b>specifications</b> sheet, and an organigram to choose the most relevant structure from the specifications. Research limitations/implications - This structural synthesis represents a preliminary step in the design of medical robots which will be completed by an additional dimensional synthesis. Originality/value - This work offers a new methodology for medical robots design distinct from what is usually done for medical or industrial robots design using intuition, expertise and non-formal knowledge...|$|R
40|$|This report {{presents}} {{a series of}} techniques for automatic specialization of <b>generic</b> component <b>specifications.</b> These techniques allow the transformation of a <b>generic</b> component <b>specifications</b> into more compact and efficient ones. We have integrated these techniques into a code generator for Ptolemy II, a software framework for actor-oriented design in Java [15]. Combining automatic code generation with actor specialization enables efficient implementation of models without sacrificing design flexibility. We call this approach to implementing an actor oriented model cocompilation, to emphasize how it integrates compiler optimization with automatic code generation. It is conceptually similar to concepts of Aspect-Oriented Design [28], since the style of component interaction is incorporated into the specification of a componen...|$|R
40|$|We {{present a}} program-generation {{approach}} {{to address a}} software-reuse challenge {{in the area of}} scientific computing. More specifically, we describe the design of a program generator for the specification of subroutines that can be generic in the dimensions of arrays, parameter lists, and called subroutines. We describe the application of that approach to a real-world problem in scientific computing, which requires the generic description of inverse ocean modeling tools. In addition to a compiler that can transform <b>generic</b> <b>specifications</b> into efficient Fortran code for models, we have also developed a type system that can identify possible errors already in the specifications. This type system is important for the acceptance of the program generator among scientists because it prevents a large class of errors in the generated code...|$|R
50|$|The {{tests and}} {{requirements}} to be met by capacitors for use in electronic equipment for approval as standardized types are {{set out in the}} <b>generic</b> <b>specification</b> IEC/EN 60384-1 in the following sections.|$|E
50|$|RSS formats are {{specified}} using XML, a <b>generic</b> <b>specification</b> for {{the creation}} of data formats. Although RSS formats have evolved since March 1999, the RSS icon ("") first gained widespread use between 2005 and 2006.|$|E
5000|$|The {{electrical}} characteristics of capacitors are harmonized {{by the international}} <b>generic</b> <b>specification</b> IEC 60384-1. In this standard, the {{electrical characteristics}} of capacitors are described by an idealized series-equivalent circuit with electrical components that model all ohmic losses, capacitive and inductive parameters of an electrolytic capacitor: ...|$|E
40|$|AbstractA {{method for}} dynamic, {{automated}} {{analysis of the}} behaviour of real-time programs under different scheduling algorithms is presented. Each scheduling algorithm is defined by a generic timed automaton which can be instantiated with data for {{a particular set of}} tasks. The resulting network of instantiated timed automata can be analysed automatically in the model-checker Uppaal, to ensure correctness properties are satisfied. Various scheduling metrics can also be calculated. We assume that data such as worst case execution times, periods, deadlines and priorities have been pre-calculated for each task. In this paper we present <b>generic</b> <b>specifications</b> for uniprocessor scheduling using the immediate ceiling priority protocol (ICPP) and the earliest-deadline-first (EDF) algorithm and analyse the behaviour of a mine pump controller implemented in Ada 95 under each scheduling algorithm...|$|R
40|$|Recently, generic {{programming}} becomes {{of a major}} {{interest in}} several programming paradigms. A recurrent idea to achieve genericity is to abstract computations from their representative data structures. This allows these <b>generic</b> <b>specifications</b> to be instantiated onto {{a large number of}} neighboring data structures. Moreover the program can be adapted when the data structures have to evolve. Polytypic programming, adaptive programming and generic attribute grammars are generic programming methods related to this approach. Their comparison leads us to propose a common framework for generic programming: automatic generation of programs that compute morphisms between data structures, and program composition. Thanks to this compositional approach, the complete specialization of generic programs could be advantageously delegated to some powerful and general deforestation method. 1 Introduction In several programming paradigms, generic programming is being emerging. When an algorithm is specifi [...] ...|$|R
5000|$|The Linux kernel [...] {{function}} {{supports a}} number of ways to display kernel structures using the <b>generic</b> [...] <b>specification,</b> by appending additional format characters. [...] For example, [...] prints an IPV4 address in dotted-decimal form. This allows static format string checking (of the [...] portion) at the expense of full compatibility with normal printf.|$|R
30|$|In {{order to}} test H 1, we {{conform to the}} <b>generic</b> <b>specification</b> of our {{research}} model and include a broad set of control variables.|$|E
30|$|In this section, we briefly {{introduce}} notations {{and definitions}} {{followed by the}} existing weighted tree similarity algorithm [2]. The original algorithm is presented using Relfun, whereas we give a more <b>generic</b> <b>specification.</b>|$|E
30|$|In {{order to}} test H 1, {{we follow the}} <b>generic</b> <b>specification</b> of our {{research}} model and include a broad set of control variables. First, we control for a firm’s {{market value of equity}} (MV) to account for the richness of its information environment. Market value (MV) is computed as the natural logarithm of market value of total equity {{at the end of each}} calendar year.|$|E
40|$|Linguistic {{reflection}} {{allows a}} running program to generate new program fragments and to integrate these {{into its own}} execution. The advantages of the technique include attaining high levels of genericity and accommodating system evolution. Here its use to provide generic programs in Java is compared for a particular example, natural join, against alternative implementation approaches. Introduction Linguistic reflection may {{be defined as the}} ability of a running program to generate new program fragments and to integrate these into its own execution. We have described elsewhere how this style of reflection may be provided in the compiled, strongly typed language Java and used as a paradigm for program generation [KMS 98]. The motivation for this work comes from the desire for two advanced programming capabilities. The first is the ability to implement highly abstract (<b>generic)</b> <b>specifications,</b> using a meta-level description of types, within a strongly typed programming language. The seco [...] ...|$|R
40|$|This paper {{describes}} SIMOO, an object-oriented {{framework for}} discrete simulation. Simulation entities in SIMOO are mapped to autonomous elements, that are objects {{with their own}} thread. Objects {{communicate with each other}} through non-typed messages. SIMOO models are built using a graphical editor called MET. MET uses a hierarchical class diagram, enriched with specific features for simulation. For instance, it allows the specification of the simulation paradigm which is more adequate for each entity. Besides a hierarchical class diagram, instance diagrams are also described, where the <b>generic</b> <b>specifications</b> of class diagrams are particularized. From the specified diagrams and from the description of the entities behavior, MET generates an executable model which uses a class simulation library. 1. # INTRODUCTION The use of object orientation in simulation is widely discussed in the literature [ARO 93, CHA 94]. In fact, SIMULA [BIR 73], which, as the name indicates, was oriented towards si [...] ...|$|R
40|$|A Petri {{net based}} {{analysis}} and design concept for system development process are presented. They appear in two forms, as functional models and as architecture models and present the main steps of system requirements analysis and system design in system development process based on using different Petri net techniques. These are illustrated with a <b>generic</b> executable <b>specification</b> of a flexible manufacturing system...|$|R
40|$|The RAGS {{proposals}} for <b>generic</b> <b>specification</b> of NLG systems includes {{a detailed account}} of data representation, but only an outline view of processing aspects. In this paper we introduce a modular processing architecture with a concrete implementation which aims to meet the RAGS goals of transparency and reusability. We illustrate the model with the RICHES system – a generation system built from simple linguistically-motivated modules. ...|$|E
40|$|In this paper, we {{describe}} {{the application of the}} interactive theorem prover Coq to the security analysis of bytecode as used in Java. We provide a <b>generic</b> <b>specification</b> and proof of non-interference for bytecode languages using the Coq module system. We illustrate the use of this formalization by applying it to a small subset of Java bytecode. The emphasis of the paper is on modularity of a language formalization and its analysis in a machine proof...|$|E
40|$|Java {{programs}} {{often use}} pointer structures for normal computations. A verification system for Java should have good proof support for reasoning about those structures. However, the literature for pointer verification almost always uses specifications and definitions that are {{tailored to the}} problem under consideration. We propose a <b>generic</b> <b>specification</b> for Java pointer structures that allows to express many important properties, and is easy to use in proofs. The specification {{is part of the}} Java calculus [22] in the KIV [15] prover...|$|E
40|$|In {{this paper}} we report {{progress}} {{in the development of}} methods for reasoning about the equivalence of objects with memory, and the use of these methods to describe sound operations on objects in terms of formal program transformations. We also formalize three different aspects of objects: their specification, their behavior, and their canonical representation. Formal connections among these aspects provide methods for optimization and reasoning about systems of objects. To illustrate these ideas we give a formal derivation of an optimized specialized window editor from <b>generic</b> <b>specifications</b> of its components. A new result in this paper enables one to make use of symbolic evaluation (with respect to a set of constraints) to establish the equivalence of objects. This form of evaluation is not only mechanizable, it is also generalizes the conditions under which partial evaluation usually takes place. 1 Overview In [19] a general challenge for partial evaluation technology was presented [...] ...|$|R
40|$|Our aim is {{to develop}} a unified model in CSP [1] for <b>generic</b> {{workflow}} <b>specification,</b> refinement and verification Milestones • formalised van der Aalst's twenty control-flow patterns [2] • applied our formalism to model some business processes defined in BPEL • formally verified these models against abstract properties [4] • extended our CSP models to formalise workflow choreography • examined a real-life case-study (airline ticket reservation) in WSCI [3...|$|R
40|$|Abstract. Specifications are {{necessary}} in order to find software bugs using program verification tools. This paper presents a novel automatic specification mining algorithm that uses information about error handling to learn temporal safety rules. Our algorithm is based on the observation that programs often make mistakes along exceptional control-flow paths, even when they behave correctly on normal execution paths. We show that this focus improves the effectiveness of the miner for discovering specifications beneficial for bug finding. We present quantitative results comparing our technique to four existing miners. We highlight assumptions made by various miners that are not always born out in practice. Additionally, we apply our algorithm to existing Java programs and analyze its ability to learn specifications that find bugs in those programs. In our experiments, we find filtering candidate specifications to be more important than ranking them. We find 430 bugs in 1 million lines of code. Notably, we find 250 more bugs using per-program specifications learned by our algorithm than with <b>generic</b> <b>specifications</b> that apply to all programs. ...|$|R
