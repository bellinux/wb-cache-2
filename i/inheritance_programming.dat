1|92|Public
40|$|Component {{software}} {{construction has}} been a very intensively researched branch of the nowadays software engineering discipline because {{it seems to be the}} best answer to the increasing demands on complexity, reliability, maintainability and configurability of software systems which is due to its ability to integrate all these otherwise contradictory requirements. Therefore, a lot of component frameworks have emerged recently, often as results of theoretical studies in this field. SOFA/DCUP component model that has been founded and developed by the Distributed Systems Research Group at Charles University in Prague belongs to one of the most promising ones. This thesis contributes to this project by analyzing the assets of incorporating inheritance into each of three main abstractions of the SOFA's component specification language CDL, analyzing various inheritance mechanisms how they suit needs of each of those three abstractions and proposing and elaborating the particular inheritance mechanisms that suit best. Also, some other issues concerning SOFA/DCUP, <b>inheritance,</b> <b>programming</b> languages and component software have been discussed in this work...|$|E
5000|$|... {{controls}} over process initialization and <b>inheritance</b> and <b>program</b> execution ...|$|R
50|$|Flex is {{a hybrid}} expert system toolkit {{developed}} by LPA which incorporates frame-based reasoning with <b>inheritance,</b> rule-based <b>programming</b> and data-driven procedures.|$|R
50|$|Go {{deliberately}} omits certain features {{common in}} other languages, including (implementation) <b>inheritance,</b> generic <b>programming,</b> assertions, pointer arithmetic, and implicit type conversions.|$|R
40|$|Abstract. Among others, Alferes et al. (1998) {{presented}} an approach for updating logic programs with sets of rules based on dynamic logic programs. We syntactically redefine dynamic logic programs and investigate their semantical consequence relation view. Since the approach does not respect minimality of change, we refine its stable model semantics and present minimal stable models and strict stable models. We also compare the update approach to related work, {{and find that}} is equivalent to a class of <b>inheritance</b> <b>programs</b> independently defined by Buccafurri et al. (1999). ...|$|R
40|$|Abstract—We {{develop a}} basic form of {{framework}} com-prehension {{which is based}} on simple, reuse-related metrics for the as-implemented design and usage of frameworks. To this end, we provide a framework profile which incorporates potential reuse characteristics (e. g., specializability of types in a framework) as well as actual reuse characteristics (e. g., evidence of specialization of framework types in projects). We apply framework comprehension in an empirical study of the Microsoft. NET Framework. The approach is helpful in several contexts of software reverse and re-engineering. Keywords-framework,. NET, framework design, framework usage, framework profile, reuse, type specialization, late bind-ing, polymorphism, <b>inheritance,</b> <b>program</b> comprehension, soft-ware metrics, dynamic program analysis...|$|R
50|$|In {{software}} engineering, the Twin {{pattern is}} a software design pattern that allows developers to model multiple <b>inheritance</b> in <b>programming</b> languages {{that do not}} support multiple inheritance. This pattern avoids {{many of the problems}} with multiple inheritance.|$|R
50|$|A general {{example of}} a {{containment}} hierarchy is demonstrated in class <b>inheritance</b> in object-oriented <b>programming.</b>|$|R
50|$|As an {{object-oriented}} programming language, Logtalk's major features include support for both classes (with optional metaclasses) and prototypes, parametric objects, protocols (interfaces), categories (components, aspects, hot patching), multiple inheritance, public/protected/private <b>inheritance,</b> event-driven <b>programming,</b> high-level multi-threading programming, reflection, and automatic generation of documentation.|$|R
50|$|In 1989, LPA {{developed}} the Flex expert system toolkit, which incorporated frame-based reasoning with <b>inheritance,</b> rule-based <b>programming</b> and data-driven procedures. Flex {{has its own}} English-like Knowledge Specification Language (KSL) which means that knowledge and rules are defined in an easy-to-read and understand way.|$|R
50|$|IBM System Object Model runtime {{supports}} multiple <b>inheritance,</b> and any <b>programming</b> language targeting SOM can implement new SOM classes {{inherited from}} multiple bases.|$|R
40|$|Inheritance {{allows a}} class to be {{specialized}} and its attributes refined, but implementation specialization {{can only take}} place by overriding with manually implemented methods. Automatic program specialization can generate a specialized, e#cient implementation. However, specialization of programs and specialization of classes (inheritance) are considered di#erent abstractions. We present a new programming language, Lapis, that unifies <b>inheritance</b> and <b>program</b> specialization at the conceptual, syntactic, and semantic levels...|$|R
40|$|Abstract. We {{introduce}} an {{object-oriented design}} pattern called Twin {{that allows us}} to model multiple <b>inheritance</b> in <b>programming</b> languages that do not support this feature (e. g. Java, Modula- 3, Oberon- 2). The pattern avoids many of the problems of multiple inheritance while keeping most of its benefits. The structure of this paper corresponds to the form of the design pattern catalogue in [GHJV 95]. 1...|$|R
40|$|Measurement is {{fundamental}} to any engineering discipline. Cohesion metrics {{play an important role}} in empirical software engineering research as well as in industrial measurement programs. The Cohesion metrics presented in this paper measure the difference between class <b>inheritance</b> and interface <b>programming</b> [...] This paper presents a measurement to measure cohesion by Lack of Cohesion in Methods (LCOM 1), LCOM 2 in object oriented programming. A measurement is done for C # <b>inheritance</b> and interface <b>programs.</b> The metric values of class inheritance and interface prove which program is good to use and beneficial for C # developers...|$|R
40|$|A {{large numbers}} of metrics have been {{proposed}} for measuring properties of object-oriented software such as size, inheritance, cohesion and coupling. The coupling metrics {{presented in this paper}} exploring the difference between <b>inheritance</b> and interface <b>programming.</b> This paper presents a measurement to measure coupling between object (CBO), number of associations between classes (NASSocC), number of dependencies in metric (NDepIN), number of dependencies out metric (NDepOut) and Number of children (NOC) in object oriented programming. A measurement is done for C# <b>inheritance</b> and interface <b>programs.</b> The metric values of class inheritance and interface prove which program is good to use and beneficial for C# developers...|$|R
40|$|Systemic lupus {{erythematosus}} (SLE) is a multisystem autoimmune disease with complicated genetic <b>inheritance.</b> <b>Programmed</b> death 1 (PD- 1), a negative T cell regulator to maintain peripheral tolerance, induces negative signals to T cells during interaction with its ligands {{and is therefore}} a candidate gene {{in the development of}} SLE. In order to examine whether expression levels of PD- 1 contribute to the pathogenesis of SLE, 30 patients with SLE and 30 controls were recruited and their PD- 1 expression levels in peripheral blood mononuclear cells (PBMCs) were measured via flow cytometry and quantitative real-time-reverse transcription polymerase chain reaction (RT-PCR). Also, whether PD- 1 expression levels are associated with the variant of the SNP rs 36084323 and the SLE Disease Activity Index (SLEDAI) was studied in this work. The PD- 1 expression levels of SLE patients were significantly increased compared with those of the healthy controls. The upregulated PD- 1 expression levels in SLE patients were greatly associated with SLEDAI scores. No significant difference was found between PD- 1 expression levels and SNP rs 36084323. The results suggest that increased expression of PD- 1 may correlate with the pathogenesis of SLE, upregulated PD- 1 expression may be a biomarker for SLE diagnosis, and PD- 1 inhibitor may be useful to SLE treatment...|$|R
40|$|Inheritance and subtyping are key {{features}} of object-oriented languages. We {{show that there}} are corresponding (or, more precisely, dual) notions for inductive or algebraic datatypes: {{there is a natural}} notion of subtyping for these types and an associated form of code reuse (<b>inheritance)</b> for <b>programs</b> on these types. Inheritance and subtyping for inductive types not only suggest possible extensions of functional programming languages, but also provide a new perspective on inheritance as we know it from object-oriented languages, which may help in getting a better understanding of this notion...|$|R
5000|$|... "Multiple <b>Inheritance</b> (object-oriented <b>programming)</b> {{was widely}} {{supposed}} {{to be very difficult}} to implement efficiently. For example, in a summary of C++ in his book on objective CBrd.Cox actually claimed that adding Multiple inheritance to C++ was impossible. Thus, multiple inheritance seemed more of a challenge. Since I had considered multiple inheritance as early as 1982 and found a simple and efficient implementation technique in 1984. I couldn't resist the challenge. I suspect this to be the only case in which fashion affected the sequence of events." [...] Bjarne Stroustrup ...|$|R
40|$|We {{present a}} new module system for Scheme that {{supports}} {{a high degree}} of implementation reuse via module composition. The module system encourages breaking down a program into the smallest possible individually meaningful modules, and recomposing them using a powerful set of adaptation and combination mechanisms. Even hierarchical nesting is achieved via a composition operation. This module system is shown to support a stronger and more flexible notion of compositionality and reuse than traditional class-based <b>inheritance</b> in object-oriented <b>programming.</b> Finally, this module system is itself implemented by reusing a language independent OO framework. Keywords: module systems, object-oriented <b>programming,</b> <b>inheritance,</b> Scheme. 1 Introduction Modularity is a fundamental facility for controlling complexity in large systems, via decomposition and abstraction. In particular, software modules allow programmers to develop and maintain pieces of a large system relatively independent of each [...] ...|$|R
40|$|We {{present a}} novel {{inheritance}} mechanism for a specification language. This mechanism supports stepwise refinement by combining constraints {{that can be}} inherited from several sources. Inheritance in specifications differs from <b>inheritance</b> in <b>programming</b> languages. The proposed mechanism has been designed specifically to support computer-aided requirements analysis. The main design issues for the mechanism are explained, {{and the application of}} the mechanism to requirements analysis is illustrated via examples. This research {{was supported in part by}} the Army Research Office under grant number ARO- 145 - 91. This research was supported in part by the National Science Foundation under grant number CCR- 9058453...|$|R
40|$|Incremental Programming (IP) is a {{programming}} {{style in}} which new program components {{are defined as}} increments of other components. Examples of IP mechanisms include Object-oriented <b>programming</b> <b>inheritance,</b> aspect-oriented <b>programming</b> advice, and feature-oriented programming. A characteristic of IP mechanisms is that, while individual components can be independently defined, the composition of components makes those components become tightly coupled, sharing both control and data flows. This makes reasoning about IP mechanisms a notoriously hard problem: modular reasoning about a component becomes very difficult; {{and it is very}} hard to tell if two tightly coupled components interfere with each other's control and data flows. This paper presents modular reasoning about interference (MRI), a purely functional model of IP embedded in Haskell. MRI models inheritance with mixins and side effects with monads. It comes with a range of powerful reasoning techniques: equational reasoning, parametricity, and reasoning with algebraic laws about effectful operations. These techniques enable MRI in the presence of side effects. MRI formally captures harmlessness, a hard-to-formalize notion in the interference literature, in two theorems. We prove these theorems with a non-trivial combination of all three reasoning techniques. © 2012 Copyright Cambridge University Press. link_to_subscribed_fulltex...|$|R
40|$|We {{consider}} {{an approach to}} update nonmonotonic knowledge bases represented as extended logic programs under answer set semantics. New information is incorporated into the current knowledge base subject to a causal rejection principle enforcing that, in case of conflicts, more recent rules are preferred and older rules are overridden. Such a rejection principle is also exploited in other approaches to update logic programs, e. g., in dynamic logic programming by Alferes et al. We give a thorough analysis of properties of our approach, {{to get a better}} understanding of the causal rejection principle. We review postulates for update and revision operators from the area of theory change and nonmonotonic reasoning, and some new properties are considered as well. We then consider refinements of our semantics which incorporate a notion of minimality of change. As well, we investigate the relationship to other approaches, showing that our approach is semantically equivalent to <b>inheritance</b> <b>programs</b> by Buccafurri et al. and that it coincides with certain classes of dynamic logic programs, for which we provide characterizations in terms of graph conditions. Therefore, most of our results about properties of causal rejection principle apply to these approaches as well. Finally, we deal with computational complexity of our approach, and outline how the update semantics and its refinements can be implemented on top of existing logic programming engines. Comment: 59 pages, 2 figures, 3 tables, to be published in "Theory and Practice of Logic Programming...|$|R
40|$|Copyright c○ 2002 – 2005 All rights {{reserved}} This tutorial presents {{an introduction to}} ATS, a comprehensive programming language with a highly expressive type system rooted in the framework Applied Type System that supports in a typeful manner a variety of programming paradigms such as functional programming, imperative programming (with explicit pointers), object-oriented <b>programming</b> (with multiple <b>inheritance),</b> meta-programming, modular <b>programming,</b> etc...|$|R
50|$|It {{has been}} argued that {{delegation}} may in some cases be preferred to <b>inheritance</b> to make <b>program</b> code more readable and understandable. Despite explicit delegation being fairly widespread, relatively few major programming languages implement delegation as an alternative model to inheritance. The precise relationship between delegation and inheritance is complicated; some authors consider them equivalent, or one a special case of the other.|$|R
50|$|Inheritance of Hope is a {{non-profit}} organization that inspires hope in young families facing {{the loss of a}} parent. Through counseling and retreat <b>programs,</b> <b>Inheritance</b> of Hope helps families navigate the challenges of a parent's terminal illness. Inheritance of Hope was founded by Kristen and Deric Milligan and rose from their efforts to deal with raising three young children during Kristen's battle with liver cancer.|$|R
40|$|The mode of {{inheritance}} of cleft lip {{with or without}} cleft palate (CL/P) has been extensively investigated, but the results are controversial. We report results of complex segregation analysis performed in the families of 636 consecutive newborns with CL/P registered in the northeast Italy and Emilia Romagna congenital malformation registries to test hypotheses regarding CL/P <b>inheritance.</b> The <b>programs</b> POINTER and COMDS have been used. POINTER could not distinguish between alternative genetic models, and only the hypothesis of no familial transmission could be rejected. COMDS results, after inclusion of the severity parameter, rejected the hypotheses of a single major locus and {{were consistent with the}} two-locus model with a major dominant locus and at least one modifier locus...|$|R
40|$|Abstract:- In {{this paper}} we have applied various {{coupling}} metrics {{for measuring the}} comparison between object oriented class inheritance and interface. In this we have applied metrics on class design diagram and evaluate the metrics values. The coupling metrics presented identifies complexity between <b>inheritance</b> and interface <b>programming</b> In this paper {{we want to show}} which concept is good to use and beneficial for software developer. Keywords:- measurement of metrics, object oriente...|$|R
40|$|This paper {{proposes a}} code reuse {{mechanism}} called module embedding {{that enables the}} building of new modules from existing ones through inheritance, overriding of procedures, and overriding of types; the paper also describes an implementation scheme for this mechanism. Module embedding is beneficial when modules and classes are used in combination {{and need to be}} extended together, or when modules are more appropriate medium than classes. Keywords: modules, object-oriented <b>programming,</b> <b>inheritance,</b> extensibilit...|$|R
40|$|Abstract. Inheritance {{allows a}} class to be {{specialized}} and its attributes re ned, but implementation specialization {{can only take}} place by over-riding with manually implemented methods. Automatic program spe-cialization can generate a specialized, ecient implementation. However, specialization of programs and specialization of classes (inheritance) are considered dierent abstractions. We present a new programming lan-guage, Lapis, that unies <b>inheritance</b> and <b>program</b> specialization at the conceptual, syntactic, and semantic levels. This paper presents the initial development of Lapis, which uses inher-itance with covariant specialization to control the automatic applica-tion of program specialization to class members. Lapis integrates object-oriented concepts, block structure, and techniques from automatic pro-gram specialization to provide both a language where object-oriented designs can be eciently implemented and a simple yet powerful partial evaluator for an object-oriented language. ...|$|R
50|$|In {{class-based}} <b>programming,</b> <b>inheritance</b> is done {{by defining}} new classes as extensions of existing classes: the existing class is the parent class and the new class is the child class. If a child class has only one parent class, {{this is known as}} single inheritance, while if a child class can have more than one parent class, this is known as multiple inheritance. This organizes classes into a hierarchy, either a tree (if single inheritance) or lattice (if multiple inheritance).|$|R
50|$|Mama {{language}} is a pure object-oriented language, while the Alice IDE is object based. That implies that while writing textual scripts with Mama language supports all object oriented elements (<b>inheritance,</b> polymorphism, generic <b>programming,</b> Observer pattern style event handling), creating objects and methods with the drag and drop interface is object based - there is no inheritance (and thus no polymorphism). The last observation may confuse beginners - thus it is suggested to use Mama scripts only as advance topics in CS courses.|$|R
40|$|We {{present an}} {{elementary}} class-based calculus of concurrent objects {{obtained from the}} join-calculus by introducing primitive record structure. We provide inheritance as {{the combination of a}} few operators to assemble objects from partial join-calculus definitions. As usual, method definitions and private fields of a parent class can be reused, overridden, or extended. As expected with concurrent objects, inheritance admits some but not all refinements of the synchronization patterns of the parent class. 1 Concurrent objects and <b>inheritance</b> Object-oriented <b>programming</b> has long been praised as favoring abstraction, incremental development, and code reusability. In this programming style, objects interact by sending messages to one another and reacting to these messages. Such a view is adequate to concurrent programming since nothing prevents the concurrent execution of actions within objects. A large amount of literature is devoted to the design and the implementation of concurre [...] ...|$|R
40|$|We {{study the}} {{transposition}} of the inheritance mechanism of class-based languages in a forward-chaining rule-based environment. This mechanism allows to specify {{various levels of}} organization for a rule base, which represent a notion of generalization/specialization. We show that this mechanism has some interesting practical effects : a conceptual one (the vision of a rule base as a specialization of other rule bases), and in relation with control (the inheritance tree is associated to a particular control structure). We describe our implementation of the mechanism in the NOpus system, which integrates first order forward-chaining rules within Smalltalk- 80. We finally give some examples of applications. Keywords : <b>inheritance,</b> rule-based <b>programming,</b> rule bases, control strategies Rsum Nous tudions la transposition du mcanisme d'hritage des langages de classes dans un environnement de rgles d'infrences en chanage avant. Ce mcanisme permet d'ajouter un niveau supplmentaire d'organisat [...] ...|$|R
40|$|Java {{provides}} a clean object-oriented programming model {{and allows for}} inherently systemindependent programs. Unfortunately, Java has a limited concurrency model, providing only threads and remote method invocation (RMI). The JR programming language extends Java to provide a rich concurrency model, based on that of SR. JR provides dynamic remote virtual machine creation, dynamic remote object creation, remote method invocation, asynchronous communication, rendezvous, and dynamic process creation. JR’s concurrency model stems from the addition of operations (a generalization of procedures) and JR supports the redefinition of operations through <b>inheritance.</b> JR <b>programs</b> are written in an extended Java and then translated into standard Java programs. The JR run-time support system is also written in standard Java. This paper describes the JR programming language and its implementation. Some initial measurements {{of the performance of}} the implementation are also included...|$|R
40|$|Some {{limitations}} of object-oriented mechanisms {{are known to}} cause code clones (e. g., extension using <b>inheritance).</b> Novel <b>programming</b> paradigms such as feature-oriented programming (FOP) aim at alleviating these limitations. However, it is an open issue whether FOP is really able to avoid code clones or whether it even facilitates (FOP-related) clones. To address this issue, we conduct an empirical analysis on ten feature-oriented software product lines with respect to code cloning. We found {{that there is a}} considerable amount of clones in feature-oriented software product lines and that a large fraction of these clones is FOP-related (i. e., caused by {{limitations of}} feature-oriented mechanisms). Based on our results, we initiate a discussion on the reasons for FOP-related clones and on how to cope with them. We exemplary show how such clones can be removed by the application of refactoring...|$|R
40|$|This paper {{describes}} {{a way of}} modeling <b>inheritance</b> (in object-oriented <b>programming</b> languages) in higher order logic. This particular approach {{is used in the}} loop project for reasoning about java classes, with the proof tools pvs and isabelle. It relies on nested interface types to capture the superclasses, fields, methods, and constructors of classes, together with suitable casting functions incorporating the difference between hiding of fields and overriding of methods. This leads to the proper handling of late binding, as illustrated in several verification examples...|$|R
