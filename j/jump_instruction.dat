65|141|Public
25|$|David Wheeler, {{who earned}} the world's first Computer Science PhD {{working on the}} project, is {{credited}} with inventing {{the concept of a}} subroutine. Users wrote programs that called a routine by jumping {{to the start of the}} subroutine with the return address (i.e. the location-plus-one of the jump itself) in the accumulator (a Wheeler jump). By convention the subroutine expected this and the first thing it did was to modify its concluding <b>jump</b> <b>instruction</b> to that return address. Multiple and nested subroutines could be called so long as the user knew the length of each one in order to calculate the location to jump to; recursive calls were forbidden. The user then copied the code for the subroutine from a master tape onto their own tape following the end of their own program.|$|E
2500|$|There was no {{division}} instruction (but various division subroutines were supplied) {{and no way}} {{to directly}} load a number into the accumulator (a [...] "sTore and zero accumulator" [...] instruction followed by an [...] "Add" [...] instruction were necessary for this). [...] There was no unconditional <b>jump</b> <b>instruction,</b> nor was there a procedure call instruction- it {{had not yet been}} invented.|$|E
2500|$|The {{implementation}} of a single-sided 315 KB FAT12 format used in MS-DOS for the Apricot PC and F1e had a different boot sector layout, to accommodate that computer's non-IBM compatible BIOS. The <b>jump</b> <b>instruction</b> and OEM name were omitted, and the MS-DOS BPB parameters (offsets 0x00B-0x017 in the standard boot sector) were located at offset 0x050. The Portable, F1, PC duo and Xi FD supported a non-standard double-sided 720 KB FAT12 format instead. The differences in the boot sector layout and media IDs made these formats incompatible with many other operating systems. The geometry parameters for these formats are: ...|$|E
40|$|Abstract. We study {{sequential}} {{programs that}} are instruction sequences with direct and indirect <b>jump</b> <b>instructions.</b> The intuition is that indirect <b>jump</b> <b>instructions</b> are <b>jump</b> <b>instructions</b> where {{the position of the}} <b>instruction</b> to <b>jump</b> to is the content of some memory cell. We consider several kinds of indirect <b>jump</b> <b>instructions.</b> For each kind, we define the meaning of programs with indirect <b>jump</b> <b>instructions</b> of that kind by means of a translation into programs without indirect <b>jump</b> <b>instructions.</b> For each kind, the intended behaviour of a program with indirect <b>jump</b> <b>instructions</b> of that kind under execution is the behaviour of the translated program under execution on interaction with some memory device...|$|R
40|$|We study {{sequential}} {{programs that}} are instruction sequences with direct and indirect <b>jump</b> <b>instructions.</b> The intuition is that indirect <b>jump</b> <b>instructions</b> are <b>jump</b> <b>instructions</b> where {{the position of the}} <b>instruction</b> to <b>jump</b> to is the content of some memory cell. We consider several kinds of indirect <b>jump</b> <b>instructions.</b> For each kind, we define the meaning of programs with indirect <b>jump</b> <b>instructions</b> of that kind by means of a translation into programs without indirect <b>jump</b> <b>instructions.</b> For each kind, the intended behaviour of a program with indirect <b>jump</b> <b>instructions</b> of that kind under execution is the behaviour of the translated program under execution on interaction with some memory device. Comment: 23 pages; typos corrected, phrasing improved, reference replace...|$|R
5000|$|<b>Jump</b> <b>instructions</b> - 2 {{kinds of}} <b>Jump</b> <b>instructions</b> which reload ANTIC's program counter (3-byte instructions) ...|$|R
50|$|A local branch {{predictor}} has {{a separate}} history buffer for each conditional <b>jump</b> <b>instruction.</b> It may use a two-level adaptive predictor. The history buffer is separate for each conditional <b>jump</b> <b>instruction,</b> while the pattern history table may be separate {{as well or}} it may be shared between all conditional jumps.|$|E
5000|$|One entry point, meaning no code {{within it}} is the {{destination}} of a <b>jump</b> <b>instruction</b> anywhere in the program.|$|E
5000|$|If {{particular}} implementation {{stops the}} computer if it encounters an unknown opcode or it implements additional unconditional <b>jump</b> <b>instruction</b> with opcode [...] "111aaaaa", then such behaviour {{can be used}} as follows: ...|$|E
5000|$|Machine level branch {{instructions}} are sometimes called <b>jump</b> <b>instructions.</b> Machine level <b>jump</b> <b>instructions</b> typically have unconditional and conditional forms where the latter {{may be taken}} or not taken depending on some condition.|$|R
5000|$|The Programma 101 {{was able}} to {{calculate}} the basic four arithmetic functions (addition, subtraction, multiplication, and division), plus square root, absolute value, and fractional part. It was equipped with memory registers with features such as clear, transfer, and exchange, plus printing and halt for input. There were 16 <b>jump</b> <b>instructions</b> and 16 conditional <b>jump</b> <b>instructions.</b> Its features of conditional <b>jump</b> <b>instructions,</b> an alphanumeric programming language, an internal memory, and a data storage system define it as a [...] "computer". Thirty-two label statements were available as destinations for the <b>jump</b> <b>instructions</b> and/or the four start keys (V, W, Y, Z). Routines on magnetic cards could be used without knowledge of programming.|$|R
40|$|Instruction {{sequences}} {{with direct}} and indirect <b>jump</b> <b>instructions</b> are as expressive as instruction sequences with direct <b>jump</b> <b>instructions</b> only. We show that, in the case where the number of instructions is not bounded, there exist instruction sequences of the former kind from which elimination of indirect <b>jump</b> <b>instructions</b> is possible without a super-linear increase of their maximal internal delay on execution only {{at the cost of}} a super-linear increase of their length...|$|R
50|$|When {{a branch}} is taken, the CPU's program counter {{is set to}} the {{argument}} of the <b>jump</b> <b>instruction.</b> So, the next instruction becomes the instruction at that address in memory. Therefore, the flow of control changes.|$|E
5000|$|For {{this type}} of {{micromachine}} to implement a <b>JUMP</b> <b>instruction</b> with the address following the opcode, the microcode might require two clock ticks. The engineer designing it would write microassembler source code looking something like this: ...|$|E
50|$|To {{remove the}} need for self-modifying code, {{computer}} designers eventually provided an indirect <b>jump</b> <b>instruction,</b> whose operand, instead of being the return address itself, was {{the location of a}} variable or processor register containing the return address.|$|E
40|$|Instruction {{sequences}} {{with direct}} and indirect <b>jump</b> <b>instructions</b> are as expressive as instruction sequences with direct <b>jump</b> <b>instructions</b> only. We show that, in the case where the number of instructions is not bounded, {{we are faced with}} increases of the maximal internal delays of instruction sequences on execution that are not bounded by a linear function if we strive for acceptable increases of the lengths of instruction sequences on elimination of indirect <b>jump</b> <b>instructions.</b> Comment: 10 pages, definition of maximal internal delay and theorem 1 are stated more precise; presentation improve...|$|R
2500|$|... index <b>jump</b> <b>instructions</b> with no delay slot {{designed}} to support large absolute addresses.|$|R
50|$|Flow {{control is}} {{facilitated}} through {{a group of}} one unconditional and twelve conditional <b>Jump</b> <b>instructions.</b> <b>Jump</b> targets are relative to PC with an offset of -128 to +127 word addresses.|$|R
50|$|At {{least one}} {{implementation}} of nested functions cause {{a loss of}} No Execute Stacks (NX Stack). GCC's nested function implementation calls nested functions through a <b>jump</b> <b>instruction</b> put in the machine stack at runtime. This requires the stack to be executable.|$|E
5000|$|He proposes {{two kinds}} of fast memory, delay line and Iconoscope tube. Each minor cycle is to be {{addressed}} as a unit (word addressing, Sec. 12.8).Instructions are to be executed sequentially, with a special instruction {{to switch to a}} different point in memory (i.e. a <b>jump</b> <b>instruction).</b>|$|E
5000|$|... (A) Program SUBR is {{compiled}} {{to produce}} object file (B), shown as both machine code and assembler. The compiler may start the compiled code at an arbitrary location, often location zero as shown. Location 13 contains the machine code for the <b>jump</b> <b>instruction</b> to statement ST in location 5.|$|E
5000|$|This {{table lists}} the machine level branch or <b>jump</b> <b>instructions</b> found in several {{well-known}} architectures: ...|$|R
50|$|Program control (control flow) is {{achieved}} by <b>jump</b> <b>instructions</b> and function calls (subroutines with optional parameters).|$|R
50|$|In some {{instruction}} sets {{such as the}} MIPS architecture, {{a dedicated}} flag register is not used; <b>jump</b> <b>instructions</b> instead check a register for zero.|$|R
5000|$|Previously {{executed}} {{instructions were}} saved in an eight-word cache, called the [...] "stack". In-stack jumps were quicker than out-of-stack jumps because no memory fetch was required. The stack was flushed by an unconditional <b>jump</b> <b>instruction,</b> so unconditional jumps {{at the ends}} of loops were conventionally written as conditional jumps that would always succeed.|$|E
5000|$|There was no {{division}} instruction (but various division subroutines were supplied) {{and no way}} {{to directly}} load a number into the accumulator (a [...] "sTore and zero accumulator" [...] instruction followed by an [...] "Add" [...] instruction were necessary for this). There was no unconditional <b>jump</b> <b>instruction,</b> nor was there a procedure call instruction - it {{had not yet been}} invented.|$|E
5000|$|... (D) When {{the program}} is loaded into memory to run it may be loaded at some {{location}} {{other than the one}} assigned by the linker. This example shows SUBR now at location 300. The address in the <b>jump</b> <b>instruction,</b> now at 313, needs to be relocated again so that it points to the updated location of ST, 305. 49 is the MIX machine representation of 305.|$|E
50|$|Note {{that the}} test for zero and test for {{negative}} <b>jump</b> <b>instructions</b> are equally valid for floating point.All these instructions clear the auxiliary register.|$|R
5000|$|Parentheses are {{consistently}} used to indicate [...] "memory contents at" [...] (constant address or variable pointer dereferencing) {{with the exception}} of some <b>jump</b> <b>instructions.</b>|$|R
5000|$|It {{results in}} compact programs. Only two bytes are taken by every {{operating}} system access, {{in contrast to}} four or six when using regular <b>jump</b> <b>instructions.</b>|$|R
50|$|Depending on {{computer}} architecture, the assembly language mnemonic for a <b>jump</b> <b>instruction</b> is typically some shortened {{form of the}} word jump or the word branch, often along with other informative letters (or an extra parameter) representing the condition. Sometimes other details are included as well, such as {{the range of the}} jump (the offset size) or a special addressing mode that should be used to locate the actual effective offset.|$|E
5000|$|... (C) If SUBR {{is later}} linked with other code {{it may be}} stored at a {{location}} other than zero. In this example the linker places it at location 120. The address in the <b>jump</b> <b>instruction,</b> which is now at location 133, must be relocated {{to point to the}} new location of the code for statement ST, now 125. 61 shown in the instruction is the MIX machine code representation of 125.|$|E
5000|$|There {{are also}} {{machines}} (or particular instructions) where the condition may be checked by the <b>jump</b> <b>instruction</b> itself, such as [...] In simple computer designs, comparison branches execute more arithmetic and can use {{more power than}} flag register branches. In fast computer designs comparison branches can run faster than flag register branches, because comparison branches can access the registers with more parallelism, using the same CPU mechanisms as a calculation.|$|E
25|$|The control {{instructions}} {{consist of}} conditional and unconditional branches, and jumps. The conditional and unconditional branch instructions use the branch instruction format, while the <b>jump</b> <b>instructions</b> use the memory instruction format.|$|R
50|$|Since {{this new}} {{approach}} {{does not use}} a return instruction, it has negative implications for defense. When a defense program checks not only for several returns but also for several <b>jump</b> <b>instructions,</b> this attack may be detected.|$|R
40|$|We {{perceive}} {{programs as}} single-pass instruction sequences. A single-pass instruction sequence under execution {{is considered to}} produce a behaviour {{to be controlled by}} some execution environment. Threads as considered in basic thread algebra model such behaviours. We show that all regular threads, i. e. threads that can only be in a finite number of states, can be produced by single-pass <b>instruction</b> sequences without <b>jump</b> <b>instructions</b> if use can be made of Boolean registers. We also show that, in the case where goto instructions are used instead of <b>jump</b> <b>instructions,</b> a bound to the number of labels restricts the expressiveness. Comment: 14 pages; error corrected, acknowledgement added; another error corrected, another acknowledgement adde...|$|R
