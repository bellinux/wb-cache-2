7|21|Public
5000|$|The MK-52 has {{two main}} modes of operation: {{automatic}} mode and programming mode. General calculations and operations are performed in automatic mode, while programs are fed as input in programming mode. The <b>keystroke</b> <b>sequence</b> [...] ( [...] in appearance) switches the MK-52 to automatic mode, while [...] (...) switches it to programming mode.|$|E
5000|$|These TI calculators {{allowed for}} {{addressing}} up to 100 data memory locations, numbered 00 to 99 (some models {{had a lower}} limit than this). A <b>keystroke</b> <b>sequence</b> like [...] (store the currently-displayed number into memory 42) would be encoded as 42 42. In this case the first 42 is the key code for the [...] key, but the second 42 is not a key code, but a memory register number. The calculator knows to interpret it as such because that’s what has to follow the code for the [...] key.|$|E
50|$|Textonyms {{in which}} a {{disambiguation}} systems gives more than one dictionary word for a single sequence of keystrokes {{are not the only}} issue, or even the most important issue, limiting the effectiveness of predictive text implementations. More important, according to the above references, are words for which the disambiguation produces a single, incorrect response. The system may, for example, respond with Blairf upon input of 252473, when the intended word was Blaire or Claire, both of which correspond to the <b>keystroke</b> <b>sequence,</b> but are not, in this example, found by the predictive text system. When typos or misspellings occur, they are very unlikely to be recognized correctly by a disambiguation system, though error correction mechanisms may mitigate that effect.|$|E
5000|$|If the kiosk {{includes}} a keyboard, the kiosk software must also disable all problematic specialty keys and <b>keystroke</b> <b>sequences</b> such as Control-Alt-Delete.|$|R
5000|$|Although many {{of these}} <b>keystroke</b> <b>sequences</b> were far from self-evident, they tended to lend {{themselves}} to mnemonic devices (e.g., Ctrl-Print-Bold, Ctrl-blocK-Save), and regular users quickly learned them through muscle memory, enabling them to rapidly navigate documents by touch, rather than memorizing [...] "Ctrl-S = cursor left." ...|$|R
40|$|The Keystroke Biometrics Ongoing Competition (KBOC) {{presented}} an anomaly detection challenge {{with a public}} keystroke dataset containing {{a large number of}} subjects and real-world aspects. Over 300 subjects typed case-insensitive repetitions of their first and last name, and as a result, <b>keystroke</b> <b>sequences</b> could vary in length and order depending on the usage of modifier keys. To deal with this, a keystroke alignment preprocessing algorithm was developed to establish a semantic correspondence between <b>keystrokes</b> in mismatched <b>sequences.</b> The method is robust in the sense that query <b>keystroke</b> <b>sequences</b> need only approximately match a target sequence, and alignment is agnostic to the particular anomaly detector used. This paper describes the fifteen best-performing anomaly detection systems submitted to the KBOC, which ranged from auto-encoding neural networks to ensemble methods. Manhattan distance achieved the lowest equal error rate of 5. 32 %, while all fifteen systems performed better than any other submission. Performance gains are shown to be due in large part not to the particular anomaly detector, but to preprocessing and score normalization techniques...|$|R
40|$|This article {{presents}} {{a new approach}} for automatic Chinese spelling error detection and correction. Existing Chinese spelling checking systems have two problems: (1) low precision rate, and (2) lack of correction capability. The proposed Chinese spelling correction method is composed of two mechanisms (1) composite confusing character substitution, and (2) advanced word class bigram language model. The characters in the input sentence are first substituted by their corresponding composite confusing character sets one by one. A composite confusing set is the collection of similar characters to a Chinese character from multiple views of shape, pronunciation, meaning, and input <b>keystroke</b> <b>sequence.</b> The substitution step produces several sentence hypotheses for the input sentence. Then, an advanced word class bigram language model, such as inter-word character bigram (IWCB) or SA-class bigram {{can be used for}} scoring each sentence hypothesis. Finally, the best scored sentence hypothesis is c [...] ...|$|E
40|$|We {{address the}} problem of serial order in skilled typing, asking whether typists {{represent}} the identity and order of the keystrokes they type jointly by linking successive keystrokes into a chained sequence, or separately by associating keystrokes with position codes. In 4 experiments, typists prepared to type a prime word and were probed to type a target word. We varied the overlap between the identity and order of keystrokes in the prime and the target. Experiment 1 tested whether the identity of keystrokes can be primed separately from their order. Experiments 2 and 3 tested whether keystroke positions can be primed out of sequence. Experiment 4 tested whether keystrokes are primed equally across serial positions. The results were consistent with chaining theories: Keystroke identities were not primed separately from their order, keystroke positions were not primed out of sequence, and priming was graded across the <b>keystroke</b> <b>sequence</b> and depended on the number of keystrokes that were primed in sequence. We conclude by discussing the possibility that the problem of serial order may be solved differently for different sequential tasks...|$|E
40|$|In {{a series}} of nine experiments, human {{participants}} typed non-word sequences of letters on a computer keyboard. Each sequence was initiated by a spacebar press and ended by a press of the enter key, and {{was treated as a}} "revealed operant. " Each such operant contained criterial (mandated) and noncriterial (discretionary) keystrokes. Participants learned several unique operants of this type, each defined by a different criterial keystroke pattern. Experiments consisted of several learning sessions and a final “test ” session. The objective was to determine the effect of varying the number of repetitions required for each operant during the learning sessions on the relative emission frequency of those operants during the test session, and on the resurgence characteristics of their noncriterial keystroke sequences. It was found that the number of repetitions previously required for an operant did not generally affect the occurrence of that operant during the test session unless the absolute number of prior repetitions was high enough. The steepness of the ratio of the relative numbers of repetitions of various operants did not affect this result. Resurgence in the test session was measured by determining when, in the participant’s prior history, each noncriterial <b>keystroke</b> <b>sequence</b> had previously been used, a measurement of that sequence’s “antiquity”. A higher antiquity leve...|$|E
50|$|The {{most widely}} used systems of {{predictive}} text are Tegic's T9, Motorola's iTap, and the Eatoni Ergonomics' LetterWise and WordWise. T9 and iTap use dictionaries, but Eatoni Ergonomics' products uses a disambiguation process, a set of statistical rules to recreate words from <b>keystroke</b> <b>sequences.</b> All predictive text systems require a linguistic database for every supported input language.|$|R
30|$|Finally, {{there is}} a macro mode for sending {{arbitrary}} <b>keystroke</b> <b>sequences,</b> a spell check mode to check the spelling of an entered word, and a learning mode to build and update a personal user-dependent dictionary supplement. These modes are activated by the menu mode which also allows users to select word prediction candidates or to toggle between English and German at runtime (Figures 5 c and 5 d). The German dictionary {{is based on a}} source from the Institute for the German Language [41]. However, all statistical data given in our article (such as KSPC) refer to the English version only.|$|R
40|$|In most examinations, {{scientific}} calculator {{is used to}} do calculation. As compared to Casio fx- 570 MS, Casio fx- 570 ES calculator is more users friendly. The display of the n x m matrix is more natural which is exactly in their mathematical form. This natural textbook display will avoid confusion among students as Casio fx- 570 MS only shows one line expression. In this paper, a collection of <b>keystroke</b> <b>sequences</b> is illustrated to highlight its features of matrix computation. Once the students can utilize their calculator throughout matrix computation in numerical methods, they can expand their ability to any other problems involving matrix in a similar pattern for any subjects in undergraduate level...|$|R
40|$|This stuy {{was carried}} out to support the "formal analysts " in {{studying}} user keystroke behaviour. The nonnal design cycle to construct a fonDal model is a top down approach. In this study we present an automatic bottom up approach to construct a fonDal description of user behaviour. The formalism we select is the Petri- net, to analyze the users ' performance knowledge with finite place/transition-systems. 2. State of the art: There are different formalisms for constructing user models; TAG, ETAG, CLG, GOMS, CCT, {{the different kinds of}} grammars (BNF, EBNF, etc,), and state transition nets. Using any of these formalisms the analyst must always design pure (="error free") user model in a top down approach. Then he can try to prove his model with the more or less "error free " empirical data. This is difficult and insufficient, and one of the consequences {{is that most of the}} formal models exist only as paper versions and have not been implemented as computer programs. 3. Bottom up approach: If there is a possibility to construct user models in an automatic, bottom up ap- proach, then the handling with fonDal models becomes easy, A sequence of keystrokes, mouse clicks, etc. can be contemplated as a sentence derived from a defined grammar or as a process derived from a Petri-net. A state transition net, as a complete description of the software the user is interacting with, can be used to identify the equal states in the <b>keystroke</b> <b>sequence.</b> All parts of the whole keystrok...|$|E
25|$|As {{implemented}} in the MS-DOS operating system and its successor Microsoft Windows, a ç/Ç pair, not required in Spanish but needed for Catalan, Portuguese, and French, is typically added, {{and the use of}} the acute accent and dieresis with capital letters (Á, É, Í, Ó, Ú, Ü) is supported. Although not needed for Spanish, another dead key with ` (the grave accent) in lower-case position and ^ (the circumflex accent) in upper-case position was included. · (the mid-line period, required in Catalan) is also found. To make room for these characters not on the standard English keyboard, characters used primarily in programming, science, and mathematics—, {, }, /, \, |, <, and >—are removed, requiring special <b>keystroke</b> <b>sequences</b> to access.|$|R
40|$|Biometrics is an {{automated}} method of recognizing a person based on physiological or behavioral characteristics. Biometric recognition technology relies upon the physiological characteristic of an individual, offering positive identification {{that is difficult}} to counterfeit. Examples of physiological biometric features include height, weight, body odor, the shape of the hands, vein patterns, retina or iris, face, fingerprints etc. examples of behavioral biometrics are voice pattern, signature, <b>keystroke</b> <b>sequences,</b> gait etc. Biometric systems have evolved significantly over the past years from single-sample verification matchers {{to a wide range of}} multi-sample fully automated person recognition systems. Biometric technologies are becoming the foundation of an extensive array of highly secure identification and personal verification solutions. As the level of security breaches and transaction frauds increases, the need for highly secure identification and personal verification technologies is becoming apparent...|$|R
40|$|Software keyloggers are a {{fast growing}} class of malware {{often used to}} harvest {{confidential}} information. One {{of the main reasons}} for this rapid growth is the possibility for unprivileged programs running in user space to eavesdrop and record all the keystrokes of the users of the system. Such an ability to run in unprivileged mode facilitates their implementation and distribution, but, at the same time, allows to understand and model their behavior in detail. Leveraging this property, we propose a new detection technique that simulates carefully crafted <b>keystroke</b> <b>sequences</b> (the bait) in input and observes the behavior of the keylogger in output to univocally identify it among all the running processes. We have prototyped and evaluated this technique {{with some of the most}} common free keyloggers. Experimental results are encouraging and confirm the viability of our approach in practical scenarios...|$|R
50|$|In {{anticipation}} {{of what a}} given running application may accept as keyboard input, the user of the shell instructs the shell to generate a <b>sequence</b> of simulated <b>keystrokes,</b> which the application will interpret as an keyboard input from an interactive user. By sending <b>keystroke</b> <b>sequences</b> the user {{may be able to}} direct the application to perform actions that would be impossible to achieve through input redirection or would otherwise require an interactive user. For example, if an application acts on keystrokes, which cannot be redirected, distinguishes between normal and extended keys, flushes the queue before accepting new input on startup or under certain conditions, or because it does not read through standard input at all. Keystroke stacking typically also provides means to control the timing of simulated keys being sent or to delay new keys until the queue was flushed etc. It also allows to simulate keys which are not present on a keyboard (because the corresponding keys do not physically exist or because a different keyboard layout is being used) and therefore would be impossible to type by a user.|$|R
40|$|International audienceAlthough the {{precision}} {{and reliability of}} response time (RT) measurements performed via Web-based interfaces have been evaluated, <b>sequences</b> of <b>keystrokes</b> have never been investigated in detail. Keystrokes often occur in much more rapid succession than RTs, and operating systems may interpret successive or concomitant keyboard events according to both automatic and user-based settings. <b>Sequence</b> <b>keystroke</b> timing could thus be more sensitive than single RTs to noise in online measurements. Here, we quantified {{the precision}} and reliability of timing measures performed during <b>sequences</b> of <b>keystrokes.</b> We used the JavaScript jsPsych library to create an experiment involving finger-movement sequences, and ran it online with 633 participants. We manipulated the structure of three <b>keystroke</b> motor <b>sequences,</b> targeting a replication of previous findings regarding both RTs and interkeystroke intervals (IKIs). Our online data accurately reproduced the original results and allowed for a novel assessment of demographic variables such as age and gender. In parallel, we also measured the objective timing accuracy of the jsPsych interface by using specialized hardware and software, showing a constant 60 -ms delay for RTs and a 0 -ms delay for IKIs across the sequences. The distribution of IKIs revealed quantizing for amajority of participants, most likely due to the sampling frequency of their USB keyboards. Overall, these findings indicate that JsPsych provides good reliability and accuracy in <b>sequence</b> <b>keystroke</b> timings for mental chronometry purposes, through online recordings...|$|R
40|$|Software keyloggers are a {{fast growing}} class of {{invasive}} software {{often used to}} harvest confidential information. One {{of the main reasons}} for this rapid growth is the possibility for unprivileged programs running in user space to eavesdrop and record all the keystrokes typed by the users of a system. The ability to run in unprivileged mode facilitates their implementation and distribution, but, at the same time, allows one to understand and model their behavior in detail. Leveraging this characteristic, we propose a new detection technique that simulates carefully crafted <b>keystroke</b> <b>sequences</b> in input and observes the behavior of the keylogger in output to unambiguously identify it among all the running processes. We have prototyped our technique as an unprivileged application, hence matching the same ease of deployment of a keylogger executing in unprivileged mode. We have successfully evaluated the underlying technique against the most common free keyloggers. This confirms the viability of our approach in practical scenarios. We have also devised potential evasion techniques that may be adopted to circumvent our approach and proposed a heuristic to strengthen the effectiveness of our solution against more elaborated attacks. Extensive experimental results confirm that our technique is robust to both false positives and false negatives in realistic settings. © 2004 - 2012 IEEE...|$|R
40|$|Abstract- Software keyloggers {{are very}} famous tool {{which are often}} used to harvest {{confidential}} information. One {{of the main reasons}} for this rapid growth of keyloggers is the possibility for unprivileged programs running in user space to eavesdrop and monitor all the keystrokes typed by the users of a system. Implementation and Distribution of these type of keyloggers are very easy because of the ability to run in unprivileged mode. But, at the same time, allows one to understand and model their behavior in detail. Taking benefit of this characteristic, we propose a new detection technique that simulates crafted <b>keystroke</b> <b>sequences</b> in input and observes the behavior of the keylogger in output to unambiguously identify it among all the running processes. We have prototyped our technique as an unprivileged application, hence matching the same ease of deployment of a keylogger executing in unprivileged mode. We have successfully evaluated the underlying technique against the most common free keyloggers that are work in user space. This confirms the viability of our approach in practical scenarios. So we propose a window based tool that detects the availability of keylogger and report the end user that system is not safe. Tool is only detecting keylogger that are work in unprivileged mode...|$|R
40|$|In {{a series}} of five experiments, a number of similar operant classes, {{consisting}} of <b>keystroke</b> <b>sequences</b> on a computer keyboard, were learned and practiced in succession by human subjects. Each experiment consisted of learning sessions spread over several days, separated by either elapsed time or interpolated sessions in which unrelated but similar operant classes were performed. The learning ses-sions were followed by a final test session in which the subjects were required to choose and perform one from presented sets of three operant classes. The test {{was designed to be}} stressful by the imposition of time pressure and certain other contingencies. In the test session, preference was commonly shown for operant classes from the first- and/or last-learned groups—termed primacy and recency effects respectively—with minimal preference for the middle groups. Most sub-jects showed either primacy or recency effects, and relatively few showed both; the subjects that showed mainly recency effects also made the largest number of errors during initial learning of the last set of operant classes. In addition, certain noncriterial characteristics of these operants were measured. These revealed other effects, in particular the association of performance errors with both greater resur-gence of older behavior patterns and greater numbers of new behavior patterns...|$|R
40|$|Differential formal {{analysis}} {{is a new}} user interface analytic evaluation method based on stochastic user simulation. The method is particularly valuable for evaluating safety critical user interfaces, which often have subtle programming issues. The approach starts with the identification of operational design features that define the design space to be explored. Two or more analysts are required to analyse all combinations of design features by simulating <b>keystroke</b> <b>sequences</b> containing keying slip errors. Each simulation produces numerical values that rank the design combinations {{on the basis of}} their sensitivity to keying slip errors. A systematic discussion of the simulation results is performed for assessing the causes of any discrepancy, either in numerical values or rankings. The process is iterated until outcomes are agreed upon. In short, the approach combines rigorous simulation of user slip errors with diversity in modelling and analysis methods. Although the method can be applied to other types of user interface, it is demonstrated through a case study of 5 -key number entry systems, which are a common safety critical user interface style found in many medical infusion pumps and elsewhere. The results uncover critical design issues, and are an important contribution of this paper since the results provide device manufacturers guidelines to update their device firmware to make their devices safer. Number entry, stochastic simulation, medical devices, interactive systems, blocking errors. 1...|$|R
50|$|Most {{fault-tolerant}} {{computer systems}} {{are designed to}} handle several possible failures, including hardware-related faults such as hard disk failures, input or output device failures, or other temporary or permanent failures; software bugs and errors; interface errors between the hardware and software, including driver failures; operator errors, such as erroneous <b>keystrokes,</b> bad command <b>sequences</b> or installing unexpected software and physical damage or other flaws introduced to the system from an outside source.|$|R
40|$|A flight {{management}} computer (FMC) control display unit (CDU) test {{was conducted to}} compare two types of input devices: a fixed legend (dedicated) keyboard and a programmable legend (multifunction) keyboard. The task used for comparison was operation of the {{flight management}} computer for the Boeing 737 - 300. The same tasks were performed by twelve pilots on the FMC control display unit configured with a programmable legend keyboard and with the currently used B 737 - 300 dedicated keyboard. Flight simulator work activity levels and input task complexity were varied during each pilot session. Half of the points tested were previously familiar with the B 737 - 300 dedicated keyboard CDU and half had no prior experience with it. The data collected included simulator flight parameters, <b>keystroke</b> time and <b>sequences,</b> and pilot questionnaire responses. A timeline analysis was also used for evaluation of the two keyboard concepts...|$|R
40|$|Backdoors {{offer an}} avenue {{which may be}} used by an {{unauthorized}} user to intrude on a system. A characteristic {{that may be used}} to identify a backdoor is the presence of keystrokes within a connection using a non-standard port (Zhang and Paxson). A first step in intrusion detection is the development of a method for identifying these keystrokes. In order to protect network users’ privacy, a viable tool must be based only on packet header data. The approach has focused on the development of a suite of visualization tools with the objective of understanding the factors and the dependencies among these factors which influence TCP network communications. These factors include the network connection (traffic/distance/capacity), protocols (ssh/TCP), human variation (typing), and host limitations (capacities/speed/demand). The plotting tools have provided much of the insight necessary for the development of an algorithmic approach to identifying <b>keystroke</b> packet <b>sequences.</b> This {{can be seen as a}} first step in the development of an intrusion detection system. 1 Data Sources Two data sources were used in the development of the visualization tools and keystroke algorithms. The first, Leipzig-I packet header traces, were collected over five days in November 2002. Our interest was confined to those using the ssh and TCP protocols. For further details on the specifics of the data and collection devices refer to (NLA, year unknown). The second source was groundings created using tcpdump on a laptop connected via ssh over ethernet to several of the machines in the Purdue statistics department. A standard set of actions were performed on each machine, including issuing shell commands, copying and pasting text, and opening documents in applications utilizing X 11 forwarding...|$|R

