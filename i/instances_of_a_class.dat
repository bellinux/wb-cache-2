60|10000|Public
5000|$|Using {{a factory}} method to create <b>instances</b> <b>of</b> <b>a</b> <b>class</b> (factory method pattern) ...|$|E
5000|$|Subclass/Superclass : The term {{subclass}} {{captures the}} concept of grouping particular <b>instances</b> <b>of</b> <b>a</b> <b>class</b> into an even more specialized class.|$|E
50|$|<b>Instances</b> <b>of</b> <b>a</b> <b>class</b> {{data type}} {{are known as}} objects and can contain member variables, constants, member functions, and {{overloaded}} operators defined by the programmer.|$|E
5000|$|... rdf:type is a {{property}} used {{to state that}} a resource is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class.</b> <b>A</b> commonly accepted qname for this property is [...] "a".|$|R
30|$|There are {{features}} {{common to}} every <b>instance</b> <b>of</b> <b>a</b> <b>class.</b> For example, any <b>instance</b> <b>of</b> photosynthesis can produce oxygen. These are not {{properties of the}} class per se, so a special instance named a prototype instance is used to represent relations common to all members <b>of</b> <b>a</b> <b>class.</b> Any other <b>instance</b> <b>of</b> <b>a</b> <b>class</b> is assumed to have the relations involving the prototype <b>instance</b> <b>of</b> the class {{as well as the}} relations in the prototype <b>instances</b> <b>of</b> the super-classes. <b>A</b> <b>class</b> can only have one prototype instance.|$|R
50|$|More precisely, an Enterprise Object is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> that {{implements}} the com.webobjects.eocontrol.EOEnterpriseObject interface.|$|R
50|$|When {{only one}} {{instance}} or a specific number of <b>instances</b> <b>of</b> <b>a</b> <b>class</b> are allowed. Facade objects are often Singletons because only one Facade object is required.|$|E
5000|$|Similarly, {{a static}} method -- a method {{declared}} as [...] inside a class definition -- {{are meant to}} be relevant to all <b>instances</b> <b>of</b> <b>a</b> <b>class</b> rather than any specific instance.|$|E
50|$|Since all {{values are}} objects, classes {{themselves}} are also objects. Each class is {{an instance of}} the metaclass of that class. Metaclasses in turn are also objects, and are all <b>instances</b> <b>of</b> <b>a</b> <b>class</b> called Metaclass. Code blocks—Smalltalk's way of expressing anonymous functions—are also objects.|$|E
2500|$|... rdf:type – <b>an</b> <b>instance</b> <b>of</b> rdf:Property used {{to state}} that a {{resource}} is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> ...|$|R
5000|$|... '''''' - <b>an</b> <b>instance</b> <b>of</b> [...] used {{to state}} that a {{resource}} is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> ...|$|R
5000|$|Object: <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class.</b> It {{is often}} used in {{analysis}} to represent an artifact or other item.|$|R
50|$|Falcon {{supports}} {{error handling}} via the raise, try and catch statements. The raise statement can throw any Falcon item, including nil, numbers, strings, objects and so on. Library functions and external modules will usually raise instances of the Error class, or <b>instances</b> <b>of</b> <b>a</b> <b>class</b> derived from that.|$|E
5000|$|Classes {{describe}} objects. From {{a technical}} point of view, objects are runtime <b>instances</b> <b>of</b> <b>a</b> <b>class.</b> In theory, {{any number of}} objects based on a single class may be created. Each instance (object) of a class has a unique identity and {{its own set of}} values for its attributes.|$|E
5000|$|Static {{methods are}} meant to be {{relevant}} to all the <b>instances</b> <b>of</b> <b>a</b> <b>class</b> rather than to any specific instance. They are similar to static variables in that sense. An example would be a static method to sum the values of all the variables of every instance of a class. For example, if there were a [...] class it might have a static method to compute the average price of all products.|$|E
50|$|The Java {{language}} {{is designed to}} enforce type safety. Anything in Java happens inside an objectand each object is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class.</b>|$|R
50|$|Initializers are {{blocks of}} code that are {{executed}} when <b>a</b> <b>class</b> or <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> is created. There {{are two kinds}} of initializers, static initializers and instance initializers.|$|R
5000|$|In the {{class-based}} {{object-oriented programming}} paradigm, [...] "object" [...] refers to <b>a</b> particular <b>instance</b> <b>of</b> <b>a</b> <b>class</b> where the object can be <b>a</b> combination <b>of</b> variables, functions, and data structures.|$|R
5000|$|Classes {{can have}} {{multiple}} superclasses, {{a list of}} slots (member variables in C++/Java parlance) and a special meta class. Slots can be allocated by class (all <b>instances</b> <b>of</b> <b>a</b> <b>class</b> share the slot) or by instance. Each slot has a name {{and the value of}} a slot can be accessed by that name using the function [...] Additionally special generic functions can be defined to write or read values of slots. Each slot in a CLOS class must have a unique name.|$|E
5000|$|Language {{features}} that allowed <b>instances</b> <b>of</b> <b>a</b> <b>class</b> to be customised without subclassing, in two ways: first, {{through the use}} of properties, allowing instances of an object to have its own fields (such as a caption) easily changed through streaming; second, by allowing events - method pointers called at specific places ln code - to be handled by another object; that ls the method pointers were attached to an object instance. [...] In other words, this creates [...] "custom behaviours through delegation instead of inheritance".|$|E
5000|$|ScriptX was {{an object}} {{oriented}} scripting language, which used design elements from [...] "Smalltalk, Dylan, Hypertalk, Lisp, Object Logo, C++, and Pascal". With Smalltalk, it shared {{the concept of}} classes, objects, and inheritance, but also featured multiple inheritance in both classes and objects, and dynamic binding of objects at runtime. ScriptX had no primitive data types; even integers were defined as objects. All objects were <b>instances</b> <b>of</b> <b>a</b> <b>class,</b> and classes themselves were instances of a MetaClass object. As in LISP, there were no statements, and every line in a ScriptX program was an expression that returned a value.|$|E
25|$|Interfaces are data {{structures}} that contain member definitions with no actual implementation. <b>A</b> variable <b>of</b> <b>an</b> interface type is {{a reference to}} <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> which implements this interface. See Interfaces.|$|R
5000|$|Scala allows mixing in a trait (creating an {{anonymous}} type) when creating <b>a</b> new <b>instance</b> <b>of</b> <b>a</b> <b>class.</b> In the case <b>of</b> <b>a</b> Person <b>class</b> <b>instance,</b> not all instances can sing. This feature comes use then: ...|$|R
5000|$|The [...] keyword behaves like {{an object}} {{variable}} {{referring to the}} current <b>instance</b> <b>of</b> <b>a</b> <b>class</b> as originally implemented. [...] is similar to , but all method calls on it are treated as if the method were NotOverridable.|$|R
5000|$|Classes as modules have {{automatic}} {{access to}} their namespace as found in C# and C++ in {{that they do not}} require any qualification. Outside of the class, all members of the class can be accessed either by qualified identifier or by a reference. A reference is a pointer to the object that is created according to the class. Any number of <b>instances</b> <b>of</b> <b>a</b> <b>class,</b> known as [...] "objects" [...] can be created with the new (...) statement, and removed with the dispose (...) statement. Class members that have instance data associated with them, such as variables (or fields) and methods must be accessed via a reference. A reference is a type, and resembles a pointer, including the ability to have the value nil, and checking for equality with other reference types. It is not required to qualify the pointer access with [...] "^".|$|E
40|$|Some dynamic {{supply chain}} {{problems}} are <b>instances</b> <b>of</b> <b>a</b> <b>class</b> of distributed optimization problems that intelligent agents {{were made to}} address. Agents are thus a natural enabling technology for such problems. In this paper we describe the use of TÆMS agent technologies on a sterilized dynamic supply chain management problem. ...|$|E
40|$|Class – a {{template}} of a data object � Interface – a specification � Instance – an instantiation of a Class or Interface physically represented in memory � Method – a set {{sequence of instructions}} � Instance Field – variable associated with a particular instance. � Static Field – variable shared among all <b>instances</b> <b>of</b> <b>a</b> <b>Class</b> class membersData Type...|$|E
5000|$|In RDF, the rdf:type {{property}} {{is used to}} state that a resource is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class.</b> [...] This enables metaclasses to be easily created by using rdf:type in a chain-like fashion. For example, in the two triples ...|$|R
30|$|Mizoguchi (2010) {{constructed}} a top-level ontology {{based on the}} role concept theory known as “Yet Another More Advanced Top-level Ontology (YAMATO; [URL] On the basis <b>of</b> YAMATO, <b>an</b> entity {{is divided into three}} classes: physical, abstract, and semi-abstract. Although <b>instances</b> <b>of</b> <b>a</b> physical <b>class</b> require three-dimensional (3 D) space and time to exist, <b>instances</b> <b>of</b> <b>an</b> abstract <b>class</b> require neither. <b>Instances</b> <b>of</b> <b>a</b> semi-abstract <b>class</b> require only time to exist, and the class contains mind, representation, content, and a representation form.|$|R
5000|$|In {{software}} engineering, the multiton {{pattern is}} a design pattern {{similar to the}} singleton, which allows only one <b>instance</b> <b>of</b> <b>a</b> <b>class</b> to be created. The multiton pattern expands on the singleton concept to manage <b>a</b> map <b>of</b> named <b>instances</b> as key-value pairs.|$|R
30|$|A {{property}} maps from {{a domain}} of individuals (<b>instances</b> <b>of</b> <b>a</b> <b>class)</b> {{to a range}} of individuals. The domain and range may be from the same class. The property characteristics may be defined later. For example, it may be an equivalent property where “engage” and “play” mean the same thing in sentences such as “A person plays sports.” or “A person engages in sports”.|$|E
40|$|In {{this paper}} a method is {{proposed}} to compute typical objects for the {{classes in the}} scheme of a fuzzy object oriented database. Typical objects are considered as "representatives " of a fuzzy majority of the class instances. The <b>instances</b> <b>of</b> <b>a</b> <b>class</b> are represented in a topological space and the typical object is derived as "closest " to the fuzzy majority of the class instances. 1...|$|E
40|$|Some dynamic {{supply chain}} {{problems}} are <b>instances</b> <b>of</b> <b>a</b> <b>class</b> of distributed optimization problems that TAEMS and other intelligent agents {{were made to}} address. In this paper we define a sanitized version of a discrete distributed dynamic supply chain management problem and specify how TAEMS agents, equipped with new coordination mechanisms, {{are being used to}} automate and manage the supply chain. Key words: agent mediated electronic commerce, dynamic supply chain management, coordination, TÆMS agents. ...|$|E
50|$|Under certain conditions, it is {{possible}} that <b>a</b> variable <b>of</b> <b>a</b> parameterized type refers to an object that is not of that parameterized type. The variable will always refer to an object that is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> that implements the parameterized type.|$|R
5000|$|The class 's [...] method creates {{and returns}} <b>a</b> copy <b>of</b> the object, {{with the same}} class {{and with all the}} fields having the same values. However, [...] throws a [...] unless the object is <b>an</b> <b>instance</b> <b>of</b> <b>a</b> <b>class</b> that {{implements}} the marker interface [...]|$|R
50|$|Generalizations of many fully {{observable}} {{games are}} EXPTIME-complete. These games {{can be viewed}} as particular <b>instance</b> <b>of</b> <b>a</b> <b>class</b> <b>of</b> transition systems defined in terms <b>of</b> <b>a</b> set <b>of</b> state variables and actions/events that change the values of the state variables, together with the question <b>of</b> whether <b>a</b> winning strategy exists.|$|R
