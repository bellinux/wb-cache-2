63|670|Public
2500|$|In A-scan {{ultrasound}} biometry, {{a crystal}} oscillates {{to generate a}} high-frequency sound wave that penetrates into the eye. When the sound wave encounters a media <b>interface,</b> <b>part</b> of the sound wave is reflected back toward the probe. These echoes allow us to calculate {{the distance between the}} probe and various structures in the eye. Ultrasonography does not measure the distance but rather the time required for a sound pulse to travel from the cornea to the retina. The speed of sound varies {{in different parts of the}} eye. The eye is divided ultrasonographically into four components:Cornea, Anterior chamber, Lens thickness and Vitreous cavity. The velocity of sound in these compartments are 1620, 1532, 1641, 1532m/s respectively. Through normal eyes an average velocity of 1555m/s is accepted for calculation. Modern instruments use separate sound velocities for the different eye components to obtain the total axial length. [...] The measured transit time is converted to a distance using the formula d=t/v Where d is the distance, t is the time and v is the velocity.|$|E
50|$|The <b>interface</b> <b>part</b> of the {{composition}} filters object model consists of two major components - the input and output filters. In addition, it also contains two supporting components - the internals and the externals. Moreover, the methods and conditions from the implementation part can also be accessed from the <b>interface</b> <b>part.</b>|$|E
5000|$|ISO 10303-22: Standard {{data access}} <b>interface,</b> <b>part</b> of the {{implementation}} methods of STEP ...|$|E
50|$|COM objects {{can also}} be created with Microsoft Foundation Classes (MFC), but this leads to larger {{binaries}} that require support DLLs. ATL, on the other hand, is a more lightweight alternative in situations where the graphical user <b>interface</b> <b>parts</b> of MFC are not required.|$|R
40|$|A {{hydraulically}} actuated {{device is}} described for applying a test load to a bearing {{or the like}} to prove the integrity of its mounting or staking within a bore in a housing such as gear case. To accommodate limited access situations, the device is constructed in a right angle configuration in which a hydraulic cylinder applies axial pressure to a first thrust rod assemly which includes a first thrust rod through a threated spindle driving a linearly translated cam. Cam follower wheel transfers the translation to a second thrust rod assembly which includes a horizontal shaft and a spindle within a cross-arm housing portion and a tubular housing portion. The same second thrust direction applies the bearing loading in either of two directions depending upon {{the shape of the}} <b>interface</b> <b>parts.</b> The <b>interface</b> <b>parts</b> can bear on the bearing from either side with respect to the bearing mounting structural part...|$|R
5000|$|KDE Plasma 4.0, {{which is}} the default <b>interface</b> as <b>part</b> of the KDE spin.|$|R
50|$|The {{design of}} the {{composition}} filters model {{is an extension of}} the {{design of the}} kernel object model. The design consists of two major parts - the kernel or the implementation part, and the outer layer or the <b>interface</b> <b>part.</b> The extensions are made in the <b>interface</b> <b>part</b> to produce the composition filters model from the traditional kernel object model.|$|E
5000|$|Tools have a {{business}} logic implementation part and a user <b>interface</b> <b>part,</b> implemented using various Java technologies.|$|E
5000|$|... the Streaming API for XML or StAX <b>interface</b> (<b>part</b> of JDK 6; {{separate}} jar {{available for}} JDK 5) ...|$|E
40|$|Pip pins {{are used}} in many {{engineering}} applications. Of particular interest to the aerospace industry is their use in various mechanism designs. Many payloads that fly aboard our nation's Space Shuttle {{have at least one}} actuated mechanism. Often these mechanisms incorporate pip pins in their design in order to fasten <b>interfacing</b> <b>parts</b> or joints. Pip pins are most often used when an astronaut will have a direct interface with the mechanism. This interfacing can be done during Space Shuttle mission EVA's (ExtraVehicular Activity). The main reason for incorporating pip pins is convenience and their ability to provide a quick release for <b>interfacing</b> <b>parts.</b> However, there are some issues that {{must be taken into account}} when using them in a design. These issues include documented failures and quality control problems when using substandard pip pins. A history of pip pins as they relate to the aerospace industry as well as general design features is discussed...|$|R
5000|$|A {{traversable}} <b>interface</b> between <b>parts</b> of {{the station}} spinning relative to each other requires large vacuum-tight axial seals.|$|R
5000|$|ISO 13584-35, Implementation resources: Spreadsheet <b>interface</b> for <b>parts</b> library. This part {{specifies}} {{a spreadsheet}} based exchange structure of ISO 13584-25 compliant data.|$|R
5000|$|E! 2551 cost 6.1 million euros for the {{integration}} of existing CAD/CAM programs under a common user <b>interface,</b> <b>part</b> of which was paid to Vero Software.|$|E
50|$|Internals are nested objects which {{reference}} to the input filters. They are completely encapsulated in the <b>interface</b> <b>part.</b> They are automatically created during {{the creation of an}} object.|$|E
50|$|A method {{which has}} a Boolean return type and an empty {{parameter}} list is called a condition. Conditions {{can be used to}} provide information about the current state of an object. Similar to methods, conditions too can be used in the <b>interface</b> <b>part</b> and most of the usage of the conditions is outside the implementation part.|$|E
40|$|This paper {{deals with}} the {{consequences}} for product designers resulting from the replacement of traditional interfaces by responsive materials. Part 1 presents a theoretical framework regarding a new paradigm for man-machine <b>interfacing.</b> <b>Part</b> 2 provides {{an analysis of the}} opportunities offered by new materials technology for interaction styles. Part 3 discusses the consequences regarding design practice. Conclusion is that the design of product semantics based upon change of colour, form, texture, etcetera, will become an essential aspect of product development. Design EngineeringIndustrial Design Engineerin...|$|R
5000|$|ISO 13584-31, Geometric {{programming}} <b>interface.</b> This <b>part</b> {{defines a}} Fortran API {{for the creation}} of product geometry. It is derived from the German VDA API DIN 66304 ...|$|R
40|$|The fast-growing Web API {{landscape}} brings clients {{more options}} than ever before-in theory. In practice, they cannot easily switch between different providers offering similar functionality. We discuss {{an approach to}} develop Web APIs based on reuse of <b>interface</b> <b>parts</b> called features. Through the introduction of 5 design principles, we investigate the impact of feature-based reuse on Web APIs. Applying these principles enables a granular reuse of client and server code, documentation, and tools. Together, they can foster a measurable ecosystem with cross-API compatibility, {{opening the door to}} a smarter generation of Web clients...|$|R
50|$|The newest of the Devil Angels {{known as}} Djibril, Nagi {{is in fact}} a {{computer}} program called N.A.G.I., or the New Angelic Gaia <b>Interface.</b> <b>Part</b> of a new effort in Heaven to use less humans and angels in their battles, due to, effectively, demand outstripping supply, she is recruited to help with the main mission after some kind of strange spell has been cast on Rika, and Hikari was captured...|$|E
50|$|The {{behavior}} {{of an object}} is implemented through its methods. The method consists of two parts - the method body and the method declaration. The actions that an object is expected to perform on being invoked is defined in the method body. The method declaration consists of the method name, the name and type of the parameters and the return type. Methods are not completely encapsulated in the kernel {{and can be used}} in the <b>interface</b> <b>part.</b>|$|E
5000|$|... "Chess engine" [...] {{normally}} {{refers to}} the algorithmic part of a chess program or machine. The user <b>interface</b> <b>part</b> is often a separateprogram, which the chess engine plugs into as a substitutable or replaceable module. Chess engines may consist of a software chess program running on a conventional digital computer, or a software program running on a conventional computer with dedicated chess-specific microprogramming or hardware to speed esp. tree searching and position evaluation, or a hardware/software/firmware machine dedicated exclusively to playing chess. Distributed computing programs that play chess utilizing multiple processors or multiple networked machines have also been developed. Most generally available commercial chess programs are software that runs on PC-type hardware. Such programs running on even very modest hardware (as small as cellphones) are vastly stronger than most human chess players.|$|E
5000|$|PHP {{supports}} the iterator pattern via the Iterator <b>interface,</b> as <b>part</b> {{of the standard}} distribution. Objects that implement the interface can be iterated over with the [...] language construct.|$|R
40|$|Abstract. Detachable user {{interfaces}} consist of graphical user <b>interfaces</b> whose <b>parts</b> or whole can be detached at run-time from their host, migrated onto another computing platform while {{carrying out the}} task, possibly adapted to the new platform and attached to the target platform in a peer-to-peer fashion. Detaching is the property of splitting {{a part of a}} UI for transferring it onto another platform. AttAaching is the reciprocal property: a part of an existing interface can be attached to the currently being used interface so as to recompose another one on-demand, according to user’s needs, task requirements. Assembling <b>interface</b> <b>parts</b> by detaching and attaching allows dynamically composing, decomposing and re-composing new interfaces on demand. To support this interaction paradigm, a development infrastructure has been developed based on a series of primitives such as display, undisplay, copy, expose, return, transfer, delegate, and switch. We exemplify it with QTkDraw, a painting application with attaching and detaching based on the development infrastructure. ...|$|R
40|$|ATIA ??? ???????????? ??????? ??????? ???????????. ???????? ???? ?????????? ?????? ??????????? ???????? ?ATIA ??? ???????????? ??????? ??????? ??????????? ??????????? ????????????. Shown {{an example}} of the {{practical}} use of CATIA software tools for designing models of parts of structures. Given description of CATIA <b>interface</b> for <b>part</b> design of structures. ??????? ?????? ????????????? ????????????? ???????????? ??????? ???????????? ???????? ?ATIA ??? ?????????????? ??????? ??????? ???????????. ????????? ???????? ?????????? ?????? ???????????? ???????? ?ATIA ??? ???????????? ??????? ??????? ??????????? ??????????? ??????????...|$|R
50|$|In A-scan {{ultrasound}} biometry, {{a crystal}} oscillates {{to generate a}} high-frequency sound wave that penetrates into the eye. When the sound wave encounters a media <b>interface,</b> <b>part</b> of the sound wave is reflected back toward the probe. These echoes allow us to calculate {{the distance between the}} probe and various structures in the eye. Ultrasonography does not measure the distance but rather the time required for a sound pulse to travel from the cornea to the retina. The speed of sound varies {{in different parts of the}} eye. The eye is divided ultrasonographically into four components:Cornea, Anterior chamber, Lens thickness and Vitreous cavity. The velocity of sound in these compartments are 1620, 1532, 1641, 1532 m/s respectively. Through normal eyes an average velocity of 1555 m/s is accepted for calculation. Modern instruments use separate sound velocities for the different eye components to obtain the total axial length. The measured transit time is converted to a distance using the formula d=t/v Where d is the distance, t is the time and v is the velocity.|$|E
50|$|Shogidokoro (将棋所) is a Windows {{graphical}} {{user interface}} (GUI) that calls a program to play shogi and displays the moves on a board. Shogidokoro was created in 2007. Shogidokoro uses the Universal Shogi Interface (USI). The USI is an open communication protocol that shogi programs use to communicate with a user interface. USI was designed by Norwegian computer chess programmer Tord Romstad in 2007. Tord Romstad based USI on Universal Chess Interface (UCI). UCI was designed by computer chess programmer Stefan Meyer-Kahlen in 2000. Shogidokoro can automatically run a tournament between two programs. This helps programmers to write shogi programs faster because they can skip writing the user <b>interface</b> <b>part.</b> It is also useful for testing changes to a program. Shogidokoro {{can be used to}} play shogi by adding a shogi engine to Shogidokoro. Some engines that will run under Shogidokoro are Apery, BlunderXX , elmo, eloqhappa (elmo+Qhapaq), Gikou (技巧), GPS Shogi, Laramie, Lesserkai, Lightning, Ponanza Quartet, Qhapaq, relmo (elmo+rezero8),rezero,Silent Majority, Spear, Ssp, Tanuki (ナイツ・オブ・タヌキ), TJshogi, Ukamuse (浮かむ瀬; the strongest release of Apery), YaneuraOu (やねうら王), and Yomita (読み太) as well as tsumeshogi solver-only engines like SeoTsume (脊尾詰). Bonanza can also run with an adapter (u2b). The software's menus have both Japanese and English language options available.|$|E
40|$|The {{integration}} of systems from various suppliers in communication networks, requires standardization of network management protocols. The Simple Network Management Protocol (SNMP) {{was developed for}} the Internet protocol suite in 1988 and has found several implementations since. To cover the deficiencies encountered in this protocol, a new version was developed. This version, SNMPv 2, is currently in standardization phase and at the University of Twente an attempt is made to implement the protocol. This thesis covers {{the implementation of the}} partyMIB module and the SNMPv 2 MIB module which have been identified in the modular approach which is followed in the protocol implementation. The implementation process started with the identification of the interfaces for these modules. One <b>interface</b> <b>part</b> supports the SNMPv 2 protocol functioning. The other <b>interface</b> <b>part</b> supports the management operations on information available in these modules. A framework has been designed to support manageme [...] ...|$|E
5000|$|The (A)LPC <b>interface</b> is <b>part</b> of Windows NT's undocumented Native API, {{and as such}} is not {{available}} to applications for direct use. However, {{it can be used}} indirectly in the following instances: ...|$|R
50|$|Gnome-jig (gjig) {{provides}} a GNOME <b>interface</b> as <b>part</b> of the wajig package. While running gjig, hovering the mouse over the buttons {{provides a}} balloon {{with a clear}} description of the function that the button provides.|$|R
50|$|The Common Desktop Environment (CDE) is AIX's default {{graphical}} user <b>interface.</b> As <b>part</b> of Linux Affinity and {{the free}} AIX Toolbox for Linux Applications (ATLA), open-source KDE Plasma Workspaces and GNOME desktop are also available.|$|R
40|$|In {{the high}} level {{synthesis}} not only {{the implementation of the}} specified algorithm but also the implementation of the correct interface behaviour is essential for the proper work. This paper shows a methodology to specify the <b>interface</b> <b>part</b> of a VHDL process considering different abstraction levels. This specification is synthesized in accordance with the simulation semantics allowing the validation of the specification and the synthesis result...|$|E
40|$|Abstract. The goal of {{this paper}} is how to build cloud IaaS {{environment}} for op-eration, and integrate KVM and OpenNebula open sources to provide a cloud virtual environment for users. In the user <b>interface</b> <b>part,</b> this work can reduce the complexity of cloud resources accessing for the user part. This paper uses the web interface that is easy to understand, accessible for users in the opera-tions. In the experimental results, this work compares the performance of physi-cal machine and KVM virtual machine, and analyzes the results...|$|E
40|$|Software {{approach}} to developing Digital Signal Processing (DSP) applications brings some interesting features, such as exibility, re-usability {{of resources and}} easy upgrades of applications. However, it requires long tests and verication phases due to the increasing complexity of software. In this report, we present the EPspectra toolkit, an Esterel-based development verication environment targeted to develop DSP applications on general purpose computers. We illustrate the description with an example of DSP implementation: the radio <b>interface</b> <b>part</b> of a GSM base station. Such DSP applications have complex control-paths since they have to obey strict scheduling rules...|$|E
40|$|Multiple threads (program {{counters}} executing in {{the same}} address space) {{make it easier to}} write programs that deal with related asynchronous activities and that execute faster on shared-memory multiprocessors. Supporting multiple threads places new constraints on the design of operating system <b>interfaces.</b> <b>Part</b> I of this report presents guidelines for designing (or redesigning) interfaces for multithreaded clients. We show how these guidelines were used to design an interface to UNIX 1 -compatible file and process management facilities in the Topaz operating system. Two implementations of this interface are in everyday use: a native one for the Firefly multiprocessor, and a layered one running within a UNIX process. Part II is the actual programmer's manual for the <b>interface</b> discussed in <b>Part</b> I. Paul R. McJones and Garret F. Swart Capsule review Unix was designed to support client address spaces containing exactly one program counter. This assumption about a Unix process has had a r [...] ...|$|R
40|$|Abstract — This paper {{addresses}} {{the problem of}} IDE interface complexity by introducing single-window graphical user interface. This approach lies in removing additional child windows from IDE, thus allowing a user to keep only text editor window open. We describe an abstract model of IDE GUI {{that is based on}} most popular modern integrated environments and has generalized user <b>interface</b> <b>parts.</b> Then this abstract model is reorganized into single windowed interface model: access to common IDE functions is provided from the code editing window while utility windows are removed without loss of IDE functionality. After that the implementation of single-window GUI on KDevelop 4 is described. And finally tool views and usability of several wellknown IDEs are surveyed...|$|R
5000|$|Users can format tables as tabbed <b>interfaces</b> as <b>part</b> of {{form design}} (for applications) or within mail {{messages}} (or in rich-text fields in applications). This provides users {{the ability to}} provide tab-style organization to documents, similar to popular tab navigation in most web portals, etc.|$|R
