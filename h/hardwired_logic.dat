22|14|Public
5000|$|Design {{errors and}} {{mistakes}} in a CPU's <b>hardwired</b> <b>logic</b> {{may also be}} documented and described as errata. One well-publicized example is Intel's [...] "FDIV" [...] erratum in early Pentium processors, known as the Pentium FDIV bug. This gave incorrect answers to a floating-point division instruction (FDIV) for a small set of numbers, due to an incorrect lookup table inside the Pentium chip.|$|E
5000|$|The {{implementations}} differed substantially, {{using different}} native data path widths, {{presence or absence}} of microcode, yet were extremely compatible. Except where specifically documented, the models were architecturally compatible. The 91, for example, was designed for scientific computing and provided out-of-order instruction execution (and could yield [...] "imprecise interrupts" [...] if a program trap occurred while several instructions were being read), but lacked the decimal instruction set used in commercial applications. New features could be added without violating architectural definitions: the 65 had a dual-processor version (M65MP) with extensions for inter-CPU signalling; the 85 introduced cache memory. Models 44, 75, 91, 95, and 195 were implemented with <b>hardwired</b> <b>logic,</b> rather than microcoded as all other models.|$|E
50|$|Some {{microcontrollers}} provide special hardware interfaces which {{cannot be}} used to take arbitrary control of a system or directly run code, but instead they allow the insertion of boot code into bootable non-volatile memory (like flash memory) via simple protocols. Then at the manufacturing phase, such interfaces are used to inject boot code (and possibly other code) into non-volatile memory. After system reset, the microcontroller begins to execute code programmed into its non-volatile memory, just like usual processors are using ROMs for booting. Most notably this technique is used by Atmel AVR microcontrollers, and by others as well. In many cases such interfaces are implemented by <b>hardwired</b> <b>logic.</b> In other cases such interfaces could be created by software running in integrated on-chip boot ROM from GPIO pins.|$|E
5000|$|... 4,038,497, July 26, 1977 - <b>Hardwired</b> Control <b>Logic</b> and Automatic Path Finding Set Up and Release.|$|R
50|$|Most of the {{earliest}} home video game systems were dedicated consoles, most popularly Pong and its many imitators. Unlike almost all later consoles, these systems were typically not computers (in which a CPU is running a piece of software), but contained a <b>hardwired</b> game <b>logic.</b>|$|R
30|$|Many {{previous}} studies on fast implementation of CAVLD have proposed {{the use of}} <b>hardwire</b> <b>logic</b> [9]–[11]. However, hardware implementations have many drawbacks such as the long development period, the large silicon area, and the low reusability of multi-format video decoders, as previously mentioned. This paper focuses on fast entropy decoding algorithms for processor-based implementations. The simplest approach is the table lookup by sequential search (TLSS) as implemented in the joint model (JM) reference software [12]. TLSS finds symbols by comparing all possible codewords with part of the input bitstream. This approach requires {{a large number of}} comparisons and therefore cannot be used for real-time applications. Table lookup by binary search (TLBS) has also been proposed to improve the entropy decoding speed. The codewords are rearranged into a binary search tree structure, and the symbols can be extracted from the tree by using binary search. TLBS offers much better performance than TLSS; however, a more efficient implementation is needed for real-time applications.|$|R
50|$|In 1972 a {{new system}} named PLATO IV was ready for operation. The PLATO IV {{terminal}} was a major innovation. It included Bitzer's orange plasma display invention which incorporated both memory and bitmapped graphics into one display. This plasma display included fast vector line drawing capability and ran at 1260 baud, rendering 60 lines or 180 characters per second. The display was a 512×512 bitmap, with both character and vector plotting done by <b>hardwired</b> <b>logic.</b> Users could provide their own characters to support rudimentary bitmap graphics. Compressed air powered a piston-driven microfiche image selector that permitted colored images to be projected {{on the back of}} the screen under program control. The PLATO IV display also included a 16×16 grid infrared touch panel allowing students to answer questions by touching anywhere on the screen.|$|E
50|$|Some modern CPUs and {{microcontrollers}} (for example, TI OMAP) {{or sometimes}} even DSPs may have boot ROM with boot code integrated directly into their silicon, so such a processor could perform quite a sophisticated boot sequence {{on its own}} and load boot programs from various sources like NAND flash, SD or MMC card and so on. It is difficult to hardwire all the required logic for handling such devices, so an integrated boot ROM is used instead in such scenarios. Boot ROM usage enables more flexible boot sequences than <b>hardwired</b> <b>logic</b> could provide. For example, the boot ROM could try to perform boot from multiple boot sources. Also, a boot ROM is often able to load a boot loader or diagnostic program via serial interfaces like UART, SPI, USB and so on. This feature is often used for system recovery purposes when for some reasons usual boot software in non-volatile memory got erased, and {{it could also be}} used for initial non-volatile memory programming when there is clean non-volatile memory installed and hence no software available in the system yet.|$|E
5000|$|The late Admiral, mathematician, and {{computer}} pioneer, Grace Murray Hopper, frequently repeated a favorite amusing story {{in front of}} many audiences about an early computer that experienced an episode where it kept calculating incorrectly. When technicians examined the machine's <b>hardwired</b> <b>logic</b> (the wiring, in the World War II era computer), a huge moth was discovered such that its body was shorting {{out one of the}} vacuum tube and relay circuits and causing the repetitive fault, and so may have {{played a key role in}} popularizing the term which was in use in hardware engineering from at least Edison's time (see Computer bug#Etymology). Since the Admiral's speeches, both hardware faults and software errors are now routinely referred to as [...] "bugs", and getting the flaws out of a product is known as 'debugging' the system. Her team almost certainly coined the latter term. A particular type of software program designed to aid software development is known as a [...] "debugger" [...] compliments the program known as a compiler, the first of which was developed by G.M. Hopper.|$|E
40|$|Bit-slice logic blocks are {{fourth-generation}} LSI components {{which are}} natural extensions of traditional multiplexers, registers, decoders, counters, ALUs, etc. Their functionality {{is controlled by}} microprogramming, typically to implement CPUs and peripheral controllers where both speed and easy programmability are required for flexibility, ease of implementation and debugging, etc. Processors built from bit-slice logic give the designer an alternative for approaching the programmability of traditional fixed-instruction-set microprocessors with a speed closer to that of <b>hardwired</b> 'random' <b>logic.</b> (2 refs) ...|$|R
40|$|The {{purpose of}} the paper is to explore the ramifications of doing the {{multiplexing}} function in the digital domain and of using the microprocessor to replace the <b>hardwired</b> control <b>logic</b> which resides in the typical analog to digital converter. Two types of conversion (one working in parallel inputs, and one in sequential order) strategies are discussed where the microprocessor is in full control of the conversion. One advantage of using a digital multiplexor is that, contrary to an analog multiplexor, it does not degrade the fidelity of the conversion process...|$|R
3000|$|... where S {{means the}} time {{interval}} {{for the initial}} GOP size (= 8). α, ε, β, γ, δ, and ξ indicate encoding, decoding, transmission, PSI generation, RD competition, and SI generation times, respectively. Through the experiment for estimation of the delay, the encoding, decoding, transmission, PSI generation, RD competition, and SI generation time are 600, 14, 5, 14, 400, and 3, 500 ms, respectively. We found in the experiment that the proposed DVC requires 14, 233 ms for a GOP structure. Note that the proposed system was implemented on Intel i 5 (2, 53 GHz) with 4 GB over Window 7. The proposed feedback-based DVC requires the delay, and it makes the proposed algorithm applied for high frame-rate video applications. However, the proposed algorithm {{is considered to be}} a trade-off between no-feedback DVC and iterative feedback DVC algorithms. Note that RD performance of the proposed algorithm is better than the no-feedback algorithms. This evaluation and assessment would be not practical for practical scenarios and conditions. The network delay can vary depending on traffics. In addition, we employed JM reference encoding software and SIG having large computational complexity in the evaluation. <b>Hardwired</b> <b>logics</b> or fast computing platforms can be employed to implement practical applications based on the proposed DVC system. Extensive further research should be performed for practical applications and services in the future.|$|R
40|$|Includes bibliographical {{references}} (page 39) The {{objective of}} this project is to study and investigate various microprocessors (??P) and their unique hardware and software characteristics. A rapidly expanding technology on digital electronics field attracts interest to today's microprocessors. When used as replacements for <b>hardwired</b> <b>logic,</b> the microprocessors provide significant economies. The large-scale integration (LSI) chip performs the basic control processing unit (CPU) functions of a computer...|$|E
40|$|The Wave Propagation Lab. has {{completed}} {{the design and}} construction of a microprogrammable radar controller for atmospheric wind profiling. Unlike some radar controllers using state machines or <b>hardwired</b> <b>logic</b> for radar timing, this design is a high speed programmable sequencer with signal processing resources. A block diagram of the device is shown. The device is a single 8 1 / 2 inch by 10 1 / 2 inch printed circuit board and consists of three main subsections: (1) the host computer interface; (2) the microprogram sequencer; and (3) the signal processing circuitry. Each of these subsections are described in detail...|$|E
40|$|We {{propose a}} {{heterogeneous}} processor architecture and its design methodology {{to shorten the}} design period of the SoC. It enables fast implementation of a system LSI including an embedded CPU and peripheral functional blocks. Each functional block of the sys-tem under design is implemented to a customized processor, in-stead of a peripheral <b>hardwired</b> <b>logic.</b> We customize processors by deleting unneccesarry functionalities, without adding new fea-tures. This eables rapid and bug-free design. Although area, power and performance of the proposed architecture {{are a little bit}} inferior to those of hardwired logics, the design period of the processor is considerably minimized, since the ROM pattern (software) and the layout pattern (customized processor, i. e. hardware) can be inde-pendently designed in parallel. 1...|$|E
50|$|An {{analogy to}} this {{relationship}} between specific measurement hardware versus generic hardware with its function totally defined in {{software is the}} relationship between specific digital circuits and a general purpose CPU. A specific digital circuit can be designed and <b>hardwired</b> with digital <b>logic</b> parts to perform a specific calculation. Alternatively, a microprocessor (or, better yet, a gate array) could be used to perform the same calculation using appropriate software. One case is specific, the other generic, with the specificity encapsulated in software.|$|R
40|$|Self-healing systems {{require that}} repair {{mechanisms}} {{are available to}} resolve problems that arise while the system executes. Managed execution environments such as the Common Language Runtime (CLR) and Java Virtual Machine (JVM) provide a number of application services (application isolation, security sandboxing, garbage collection and structured exception handling) which are geared primarily at making managed applications more robust. However, none of these services directly enables applications to perform repairs or consistency checks of their components. From a design and implementation standpoint, the preferred way to enable repair in a self-healing system is to use an externalized repair/adaptation architecture rather than <b>hardwiring</b> adaptation <b>logic</b> inside the system where {{it is harder to}} analyze, reuse and extend. We present a framework that allows a repair engine to dynamically attach and detach to/from a managed application while it executes essentially adding repair mechanisms as another application service provided in the execution environment. ...|$|R
40|$|Modular {{inversion}} is {{an operation}} frequently {{used in many}} contemporary cryptographic applications, especially in public-key crypto-systems. In this paper, we present an efficient, scalable and generic hardware implementation of modular inversion operation optimized for a class of FPGA (Field Programmable Gate Array) devices. The long carry chains, which increase critical path delay, are avoided by utilizing generic block adder and subtractor circuits that exploit the <b>hardwired</b> carry <b>logic</b> of the FPGA devices. In our design, we utilize the Montgomery modular inversion that is chosen for compatibility with Montgomery multiplication operation. The effectiveness and efficiency of our methods are explored by realizing our design on a Xilinx Spartan- 6 FPGA, which is a recent, low-end reconfigurable logic device popular in embedded applications for its power efficiency. Timing simulation demonstrate that our design achieves maximum clock frequency of 280 MHz. The implementation performs one modular inversion operation in a considerably small {{amount of time and}} it takes a negligible amount of resources on FPGA...|$|R
40|$|MICE is a MICro-programmable Engine {{designed}} for on-line filtering applications. It efficiently emulates the PDP- 11 fixed-point instruction set. This feature facilitates {{the development of}} user software as algorithms can be coded in the standard languages (FORTRAN, PL 11, Assembler, etc.). MICE executes PDP- 11 code 3 times faster than a PDP- 11 / 70, or 10 times faster than a PDP- 11 / 34. Algorithms {{can be made to}} run faster by micro-coding the time critical part of the code (often {{a small fraction of the}} total code). Further speed increases can be achieved by attaching special-purpose <b>hardwired</b> <b>logic</b> to the CPU. The architecture of MICE has been described elsewhere (HALAT 80); in this paper we describe those features which make it a user-friendly device in the real-time experimental environment encountered at CERN...|$|E
40|$|Abstract — By {{implementing}} a control program with <b>hardwired</b> <b>logic</b> using reconfigurable devices (e. g., FPGA), a flexible and highly responsive {{system can be}} realized. This new system also contributes to securing intellectual property, while reducing implementation space and cost. This study outlines a converter that translates PLC instruction sequence into logic description. A design framework is also described, which integrates control logic and peripheral functions on an FPGA chip. A productive ladder program was examined with Mitsubishi Electric FX 2 N PLC and Altera APEX 20 KE FPGA, and the derived logic designs were shown to fit into an actual FPGA chip. A straightforward Sequential design {{was estimated to be}} 79 times faster than PLC, while a performance-oriented Flat design was estimated to be 43 times faster than Sequential design (i. e., 3397 times faster than PLC). I...|$|E
40|$|Computers {{have become}} an {{important}} part of today's everyday life, from their high profile use to manage corporate information, to personal information retrieval (web browsing), to information kiosks, to consumer electronics, and to managing our microwave oven. The spectrum of computers runs from the very large supercomputers for intensive computation to the very small to replace traditional electronic circuits. Today, there is exciting new computer science being applied to small computers. This tutorial addresses the evolving software technologies for small computers, specifically, those used in a distributed environment. These machines support multitasking continuous media environments, though their application domains are specialized for explicit purposes. 1 Introduction Today, computers range from process control computers that are an economical replacement for <b>hardwired</b> <b>logic</b> to supercomputers designed to perform massive computations in the shortest possible time. The smallest c [...] ...|$|E
40|$|Results of {{a recent}} study of data {{handling}} requirements for future operational earth observation systems are reported. Such systems in the 1980 's may have 10 - 20 meter resolution and generate. 2 tecabits of data per day, with peak rates of 0. 8 gigabits per second based on the dominant requirements of agriculture. System alternatives are considered that will handle such data. Data relayed to the facility are recorded at high rates and then processed at lower speed by computer. <b>Hardwired</b> special digital <b>logic</b> computers may be used with an appropriate classification algorithm for crop recognition. Optical mass memories now in the prototype stage will handle the 10 tecabits and 800 megabit per second read-in rate required...|$|R
40|$|Abstract—The operation-centric {{hardware}} abstraction {{is useful}} for describing systems whose behavior exhibits {{a high degree of}} concurrency. In the operation-centric style, the behavior of a system is described as a collection of operations on a set of state elements. Each operation is specified as a predicate and a set of simultaneous state-element updates, which may only take effect in case the predicate is true on the current state values. The effect of an operation’s state updates is atomic, that is, the legal behaviors of the system constitute some sequential interleaving of the operations. This atomic and sequential execution semantics permits each operation to be formulated as if the rest of the system were frozen and thus simplifies the description of concurrent systems. This paper presents an approach to synthesize an efficient synchronous digital implementation from an operation-centric hardware-design description. The resulting implementation carries out multiple operations per clock cycle and yet maintains the semantics that is consistent with the atomic and sequential execution of operations. The paper defines, and then gives algorithms to identify, conflict-free and sequentially composable operations that can be performed in the same clock cycle. The paper further gives an algorithm to generate the <b>hardwired</b> arbitration <b>logic</b> to coordinate the concurrent execution of conflict-free and sequentially composable operations. Lastly, the paper evaluates synthesis results based on the TRAC compiler for the TRSPEC operation-centric hardware-description language. The results from a pipelined processor example show that an operation-centric framework offers a significant reduction in design time, while achieving comparable implementation quality as traditional register-transfer-level design flows. Index Terms—Conflict-free, high-level synthesis, operation-centric, sequentially composable, term-rewriting systems (TRS). I...|$|R
40|$|NASA Glenn Research Center's Single-Stage Axial Compressor Facility was {{upgraded}} {{in fiscal}} year 2003 to expand and improve its research capabilities for testing high-speed fans and compressors. The old 3000 -hp drive motor and gearbox were removed and replaced with a refurbished 7000 -hp drive motor and gearbox, with a maximum output speed of 21, 240 rpm. The higher horsepower rating permits testing of fans and compressors with higher pressure ratio or higher flow. A new inline torquemeter was installed to provide an alternate measurement of fan and compressor efficiency, along with the standard pressure and temperature measurements. A refurbished compressor bearing housing was also installed with bidirectional rotation capability, so {{that a variety of}} existing hardware could be tested. Four new lubrication modules with backup capability were installed for the motor, gearbox, torquemeter, and compressor bearing housing, so that in case the primary pump fails, the backup will prevent damage to the rotating hardware. The combustion air supply line for the facility inlet air system was activated to provide dry air for repeatable inlet conditions. New flow conditioning hardware was installed in the facility inlet plenum tank, which greatly reduced the inlet turbulence. The new inlet can also be easily modified to accommodate 20 - or 22 -in. -diameter fans and compressors, so a variety of existing hardware from other facilities (such as Glenn's 9 - by 15 -Foot Low-Speed Wind Tunnel) can be tested in the Single-Stage Axial Compressor Facility. An exhaust line was also installed to provide bleed capability to remove the inlet boundary layer. To improve the operation and control of the facility, a new programmable logic controller (PLC) was installed to upgrade from <b>hardwired</b> relay <b>logic</b> to software logic. The PLC also enabled the usage of human-machine interface software to allow for easier operation of the facility and easier reconfiguration of the facility controls when necessary. Finally, a new health-monitoring system was installed to measure shaft speed, shaft movement, and machine vibration on all of the rotating equipment. The system also provides automatic alarms and shutdown of the equipment when required. An integrated systems test for checkout of the facility was completed on June 17, 2003. Research testing resumed on June 30 with data obtained in support of the Ultra-Efficient Engine Technology Project's Compressor Casing Treatment Project...|$|R
40|$|In {{the present}} world the {{computer}} {{has become an}} essential and inevitable part in any field and industry be it in administrative field, science, defense {{or in any other}} field. The Processor designed and implemented is typical RISC machines following a 4 -stage pipelining having instruction fetch (I-fetch), instruction decode, executing and storing (data memory operations and write back stages) for higher speed operation. The control signals are generated using the <b>hardwired</b> <b>logic</b> for a group of instructions or for particular cases. The processor is implemented with 5 -stage fine parallelism controlled using the multithreading concept. This work is implemented using VHDL language. The simulation and synthesis of the implemented design is carried out using XILINX ISE tool. Further route and placement and Floor planning is to be carried out using Xilinx FPGA editor and Floor Planner respectively. Key words- FGT, SMT, ILP, TLP, IPC. I...|$|E
40|$|This {{article is}} about the {{weaknesses}} of part 3 of the IEC 1131 standard and in particular {{of one of the}} languages it defines called Instruction List. It will also propose ways to improve the standard {{so that it can be}} used to create high quality software. 1 Introduction Traditionally when some control circuit was needed in for example a chemical plant, it would be implemented using <b>hardwired</b> <b>logic,</b> i. e. a hardware circuit consisting of AND and NAND gates. Unfortunately hardware circuits are inherently inflexible. The software implementation of Boolean functions, called programmed logic, is much more flexible. Programmed logic uses a processor with memory for a program, memory for data and I/O interfaces, also called a Programmable Logic Controller (PLC). Simply put a PLC reads its input, applies certain functions and finally writes the output. Figure 1 : PLC architecture Over the last twenty years, the use of PLC's has increased immensely; PLC's can nowadays be found in, among other t [...] ...|$|E
40|$|Abstract — Reconfigurable Arrays {{combine the}} benefit of spa-tial execution, typical of {{hardware}} solutions, with that of programmability, present in microprocessors. When mapping software applications (or parts of them) onto hardware, however, FPGAs often provide more flexibility than is needed, and do not implement coarser-level operations efficiently. Therefore, Coarse Grained Reconfigurable Arrays (CGRAs) have been proposed to this aim. While most CGRA designs feature an array cell {{of the order of}} an ALU, this paper proposes a new kind of coarse grained array, called EGRA (Expression-Grained Reconfigurable Array), featuring a cell composed of a cluster of ALUs with flexible interconnect. The EGRA attempts to further close the performance gap between reconfigurable and <b>hardwired</b> <b>logic</b> by implementing an arithmetic/logic expression per cell, rather than a single operation. A mapping methodology is proposed that can retargetably compile to a family of EGRAs, therefore enabling architectural exploration of the granularity of the proposed cell. Performance results on a number of embedded applications show that EGRAs {{can be used as a}} reconfigurable fabric for customizable processors, outperforming more traditional CGRA designs. I...|$|E
40|$|The {{function}} of the Automatic Telephone Dialling System is to detect any sort of alarm such as fire, equipment failure, burglary. It then has to transmit the alarm information over the switched telephone network to a Control Station, where the alarm information is displayed. The attending personnel can then take the appropriate action. The Dialling system designed and constructed in this thesis consists of two parts: the Alarm Unit and the Control Station. As soon as an alarm occurs, the Alarm Unit selects the first available telephone number of the Control Station and dials the number. Using Frequency Shift Keying method, the Alarm Unit transmits the information identifying itself and the alarm to the Control Station. Initiate and Acknowledge Signalling as well as error checking ensure correct data transmission. Data re-transmissions and rediallings take place until successful transmission is acknowledged. A micro-program rather than a <b>hardwired</b> control <b>logic</b> is used in each the Alarm Unit and the Control Station for controlling their operations. The Central Processing Unit has been designed using MSI components. A microprocessor was not used because, {{at the time of}} the commencement of the project, its cost was high. Nevertheless the design was microprocessor - oriented, so that a microprocessor can be adopted in the future. A prototype was implemented using CMOS technology. This offers the advantages of lower power dissipation and higher noise immunity when compared with existing technologies such as TTL. Automatic gain control amplifiers and filters are used in the system to compensate for transmission line losses and reduce noise influence on information reception. Provision has been made so that, if a number of alarms occur at the same time at the Alarm Unit, they will be transmitted sequentially. At the Control Station, apart from displaying current alarm, memory space is provided for queueing the received alarms. System testing can be carried out at the push of a button from either the Alarm Unit or the Control Station. The test routine involves the same sequence of operations as in the case of an alarm, thus enhancing the thoroughness of the test. The system is expandable to any desired number of Alarm Units and Control Stations. With a system of this type, if one Control Station is busy, an a Alarm Unit can be programmed to attempt communicating with another Control Station...|$|R
40|$|Increasing {{non-recurring}} engineering (NRE) and mask costs {{are making it}} harder to turn to hardwired Application Specific Integrated Circuit (ASIC) solutions for high performance applications [12]. The volume required to amortize these high costs has been increasing, making it increasingly expensive to afford ASIC solutions for medium volume products. This has led to designers seeking programmable solutions of varying sorts using these so-called programmable platforms. These programmable platforms span a large range from bit-level programmable Field Programmable Gate Arrays (FPGAs), to word-level programmable application-specific, {{and in some cases}} even general-purpose processors. The programmability comes with a power and performance overhead. Attempts to reduce this overhead typically involve making some core <b>hardwired</b> ASIC like <b>logic</b> blocks accessible to the programmable elements. This paper presents one such hybrid solution in this space – a relatively simple processor with a dynamically reconfigurable datapath acting as an accelerating co-processor. This datapath consists of hardwired function units and reconfigurable interconnect. We present a methodology for the design of these solutions and illustrate it with two complete case studies: an MPEG 2 coder, and a GSM coder, to show how significant speedups can be obtained using relatively little hardware. The co-processor {{can be viewed as a}} VLIW processor with a single instruction per kernel loop. We compare the efficiency of exploiting the operation level parallelism using classic VLIW processors and this proposed class of dynamically configurable co-processors. This work is part of the MESCAL project, which is geared towards developing design environments for the development of application specific platforms...|$|R
40|$|Cylindrical {{storage ring}} {{detectors}} using {{more than ten}} thousand channels of drift-, proportional- and liquid argon chambers have led to an enormous increase in data acquisition rates stored in hundreds of tapes. To reduce the computer time for total analysis of the selected events one has to reject the undesired events as early as possible. Therefore the trigger should be more selective, i. e. not only by {{counting the number of}} tracks in an event but to reconstruct the track coordinates {{to get to know the}} topology. Because of the short decision time of some microseconds in typical PETRA/DORIS experiments this is done in two steps: at level 1 a parallel or sequential <b>hardwired</b> <b>logic</b> is used for getting the number of tracks, together with some geometrical values; at level 2 a fast or several slower microprocessors are used running on a simple algorithm together with some hardware tricks. For future detectors with lower bunch crossing rates very fast microprocessors may be used also at the first level, at the second level more efficient algorithms are now designed and under test. (11 refs) ...|$|E
40|$|This paper {{presents}} a feasibility {{study on the}} use of an embedded multi-core system-on-a-chip (SoC) architecture to accelerate server I/O subsystem functions, as an alternative to implementation via finite state machines (FSMs) and <b>hardwired</b> <b>logic.</b> The multi-core solution is significantly more programmable than FSMs and avoids many of their shortcomings. For the purposes of this SoC we use the Cyclops scalable embedded multiprocessor architecture (CyclopsE) that comprises one or more processor clusters, one or more local memory banks for storing data and/or instructions, and a local interconnect implemented via a crossbar switch. The I/O functionality was implemented in C language and verified on an FPGA-based prototype that emulated a server I/O subsystem handling storage area network traffic. Results showed that for the higher-level protocols of interest, a modest number of processor cores are sufficient to handle traffic up to 8 Gb/s. Given the small silicon area and power requirements as well as good scalability of CyclopsE, much higher bandwidths can be accommodated with the use of larger numbers of cores...|$|E
40|$|This {{innovation}} {{is a series}} of time-tag pulses from a photomultiplier tube, featuring short time interval between pulses (e. g., 2. 5 ns). Using the previous art, dead time between pulses is too long, or too much hardware is required, including a very-high-speed demultiplexer. A faster method is needed. The goal of this work is to provide circuits to time-tag pulses that arrive at a high rate using the <b>hardwired</b> <b>logic</b> in an FPGA - specifically the carry chain - to create what is (in effect) an analog delay line. High-speed pulses travel down the chain in a "wave. " For instance, a pulse train has been demonstrated from a 1 - GHz source reliably traveling down the carry chain. The size of the carry chain is over 10 ns in the time domain. Thus, multiple pulses will travel down the carry chain in a wave simultaneously. A register clocked by a low-skew clock takes a "snapshot" of the wave. Relatively simple logic can extract the pulses from the snapshot picture by detecting the transitions between logic states. The propagation delay of CMOS (complementary metal oxide semiconductor) logic circuits will differ and/or change as a result of temperature, voltage, age, radiation, and manufacturing variances. The time-to-digital conversion circuits can be calibrated with test signals, or the changes can be nulled by a separate on-die calibration channel, in a closed loop circuit...|$|E
40|$|This paper {{presents}} steady-state and small-signal {{models for}} digital pulsewidth modulators (DPWM) employed in multiple sampling digital control schemes for dc–dc switched mode power supplies (SMPS), and identifies the triangular modulation as intrinsically superior to other modulation schemes in multisampling applications. In conventional digital control of dc–dc converters, closed-loop bandwidth limitations are mainly set by analog-to-digital conversion times, computational delays and DPWM delays originated by the sampled {{nature of the}} PWM. While the use of <b>hardwired</b> <b>logic</b> and fast A/D converters minimizes computational and A/D delays, the DPWM small-signal phase lag strictly depends on the adopted sampling strategy. Multiple sampling techniques recently proposed in literature can achieve a strong reduction of the DPWM delay by operating the control and modulation steps at a sampling frequency strictly higher than the converter switching frequency. On the other hand, multisampled pulse width modulators (MSPWMs) exhibit nonlinear behaviors which do not have analog counterparts nor are encountered in conventional digital control, the most relevant effect being the onset of sampling induced dead bands, i. e., regions of zero modulation gain in the modulator transcharacteristic which may compromise proper closed-loop operation of the converter. The models proposed in this paper fully characterize the steady-state and small-signal behavior of DPWMs operated in multiple-sampling fashion. Multisampled triangular modulators are proven to be intrinsically superior to trailing edge or leading edge modulators in terms of linearity. Simulation and experimental results validate the proposed models and confirm the properties of triangular modulations...|$|E
40|$|Implementing a {{real-time}} image-processing algorithm on {{a serial}} processor {{is difficult to}} achieve because such a processor cannot cope with the volume of data in the low-level operations. However, a parallel implementation, required to meet timing constraints for the low-level operations, results in low resource utilisation when implementing the high-level operations. These factors suggested a combination of parallel hardware, for the low-level operations, and a serial processor, for the high-level operations, for implementing a high-level image-processing algorithm. Several types of serial processors were available. A general-purpose processor requires an extensive instruction set {{to be able to}} execute any arbitrary algorithm resulting in a relatively complex instruction decoder and possibly extra FUs. An application-specific processor, which was considered in this research, implements enough FUs to execute a given algorithm and implements a simpler, and more efficient, instruction decoder. In addition, an algorithms behaviour on a processor could be represented in either hardware (i. e. <b>hardwired</b> <b>logic),</b> which limits the ability to modify the algorithm behaviour of a processor, or “software” (i. e. programmable logic), which enables external sources to specify the algorithm behaviour. This research investigated hardware- and software- controlled application-specific serial processors for the implementation of high-level image-processing algorithms and compared these against parallel hardware and general-purpose serial processors. It was found that application-specific processors are easily able to meet the timing constraints imposed by real-time high-level image processing. In addition, the software-controlled processors had additional flexibility, a performance penalty of 9. 9 % and 36. 9 % and inconclusive footprint savings (and costs) when compared to hardwarecontrolled processors...|$|E
40|$|The {{hardware}} and software for a computer controlled optical radar, or lidar, system are described. The system builds on a previously installed pulsed ruby backscatter lidar, capable of acquiring data at controlled azimuth and elevation angles through the atmosphere. The described system replaces <b>hardwired</b> <b>logic</b> with computer control. Two coupled computers are used to allow a degree of real time control while data are processed. One of these computers reads and controls mount elevation angle, reads the laser energy monitor, and senses firing of the laser. The other computer serves as a user interface, and receives the lidar return data from a digitizer and memory, and the angle and energy information from the other computer. The second computer also outputs data to a disc drive. The software provided with the system is described, and the feasibility of additional software for both control and data processing is explored. Particular attention is given to data integrity and instrument and computer operation {{in the presence of}} the high energy pulses used to drive the laser. A previously described laser energy monitor has been improved to isolate it from laser transients. Mount elevation angles are monitored with an absolute angle readout. As a troubleshooting aid, a simulator with an output that approximates the lidar receiver output was developed. Its output is digitally generated and provides a known repetitive signal. Operating procedures are described for standard data acquisition, and troubleshooting is outlined. The system can be used by a relatively inexperienced operator; English sentences are displayed on the system console CRT terminal to lead the operator through data acquisition once the system hardware is turned on. A brief synopsis of data acquired on the system is given. Those data are used as the basis of other referenced papers. It constitutes soundings for over one hundred days. One high point has been operation of the system in conjunction with a balloon borne atmospheric particulate sampling package. The system has also been used occasionally as the transmitter of a lidar system with physically separated receiver and transmitter...|$|E

