127|908|Public
25|$|This {{became the}} topic that Gödel chose for his {{doctoral}} work. In 1929, {{at the age}} of 23, he completed his doctoral dissertation under Hans Hahn's supervision. In it, he established the completeness of the <b>first-order</b> <b>predicate</b> <b>calculus</b> (Gödel's completeness theorem). He was awarded his doctorate in 1930. His thesis, along with some additional work, was published by the Vienna Academy of Science.|$|E
2500|$|First-order logic—also {{known as}} <b>first-order</b> <b>{{predicate}}</b> <b>calculus</b> and predicate logic—is {{a collection of}} formal systems used in mathematics, philosophy, linguistics, and computer science. First-order logic uses quantified variables over non-logical objects and allows the use of sentences that contain variables, so that rather than propositions such as Socrates is a man one can have expressions in the form [...] "there exists X such that X is Socrates and X is a man" [...] and there exists is a quantifier while X is a variable. This distinguishes it from propositional logic, which does not use quantifiers or relations.|$|E
2500|$|Based upon {{work of the}} German {{mathematician}} Leopold Löwenheim (1915) the Norwegian logician [...] Thoralf Skolem {{showed in}} 1922 that every consistent theory of <b>first-order</b> <b>predicate</b> <b>calculus,</b> such as set theory, has an at most countable model. However, Cantor's theorem proves that there are uncountable sets. The root of this seeming paradox is that the countability or noncountability of a set is not always absolute, but can depend on the model in which the cardinality is measured. It is possible for a set to be uncountable in one model of set theory but countable in a larger model (because the bijections that establish countability are in the larger model but not the smaller one).|$|E
50|$|In this approach, {{a formula}} in <b>first-order</b> logic (<b>predicate</b> <b>calculus)</b> is {{represented}} by a labeled graph.|$|R
40|$|We define fuzzy {{constraint}} {{networks and}} prove a theorem {{about their relationship}} to fuzzy logic. Then we introduce Khayyam, a fuzzy constraint-based programming language in which any sentence in the <b>first-order</b> fuzzy <b>predicate</b> <b>calculus</b> is a well-formed constraint statement. Finally, using Khayyam to address an equipment selection application, we illustrate the expressive power of fuzzy constraint-based languages...|$|R
40|$|Illative combinatory logic {{consists}} {{of the theory of}} combinators or lambda calculus extended by extra constants (and corresponding axioms and rules) intended to capture inference. The paper considers 4 systems of illative combinatory logic that are sound for <b>first-order</b> propositional and <b>predicate</b> <b>calculus...</b>|$|R
2500|$|The <b>first-order</b> <b>predicate</b> <b>calculus</b> avoids such {{ambiguity}} {{by using}} formulae that carry no existential import {{with respect to}} universal statements. Existential claims must be explicitly stated. Thus, natural language statements—of the forms All A is B, No A is B, Some A is B, and Some A is not B—can be represented in first order predicate calculus in which any existential import with respect to terms A and/or B is either explicit or not made at all. Consequently, the four forms AaB, AeB, AiB, and AoB can be represented in first order predicate in every combination of existential import—so it can establish which construal, if any, preserves the square of opposition and {{the validity of the}} traditionally valid syllogism. [...] Strawson claims such a construal is possible, but the results are such that, in his view, the answer to question (e) above is no.|$|E
5000|$|... #Subtitle level 3: Extension to <b>first-order</b> <b>predicate</b> <b>calculus</b> with {{equality}} ...|$|E
5000|$|The Cyc {{project has}} its own {{ontology}} language called CycL, based on <b>first-order</b> <b>predicate</b> <b>calculus</b> with some higher-order extensions.|$|E
40|$|We propose new {{temporal}} dependencies for valid-time relations. The proposed dependencies can {{be thought}} of as generalizations of the temporal database concept of time-invariant attribute. They are natural extensions of the conventional construct of functional dependency. A complete axiomatization is obtained by extending Armstrong's axioms. The new dependencies can be expressed in a <b>first-order</b> temporal <b>predicate</b> <b>calculus</b> with equality. We argue that temporal dependency preservation may constitute a valuable design guide-line during normalization. Keywords. temporal databases, relational data model, functional dependency, temporal logic 1. Reserach Assistant of the National Fund for Scientific Research (Belgium). 1193 1. Introduction Temporal database constraints, in general, can be expressed as formulas of temporal logic that must be satisfied by any "legal" database. Several temporal logics can be found in literature [1, 4, 8, 14]. Certain temporal constraints are more significan [...] ...|$|R
40|$|This thesis {{describes}} {{the design and}} implementation of the IPE, an interactive proof editor for <b>first-order</b> intuitionistic <b>predicate</b> <b>calculus,</b> developed at the University of Edinburgh during 1983 - 1986, by the author together with John Cartmell and Tatsuya Hagino. The IPE uses an attribute grammar to maintain the state of its proof tree as a context-sensitive structure. The interface allows free movement through the proof structure, and encourages a "proof-byexperimentation" approach, since no proof step is irrevocable. We describe how the IPE's proof rules can be derived from natural deduction rules for first-order intuitionistic logic, how these proof rules are encoded as an attribute grammar, and how the interface is constructed on top of the grammar. Further facilities for the manipulation of the IPE's proof structures are presented, including a notion of IPE-tactic for their automatic construction. We also describe an extension of the IPE to enable the construction and use of simply-structured collections of axioms and results, the main provision here being an interactive "theory browser" which looks for facts which match a selected problem...|$|R
40|$|The {{paper of}} J. Ketonen and R. Weyhrauch[6] defines a decidable {{fragment}} of <b>first-order</b> <b>predicate</b> logic [...] Direct <b>Predicate</b> <b>Calculus</b> [...] as the subset which is provable in Gentzen sequent calculus without the contraction rule, and gives an effective decision procedure for it. This report is a {{detailed study of}} this procedure. We extend the decidability to non-prenex formulas. We prove that the intuitionnistic fragment is still decidable, with a refinement of the same procedure. An intuitionnistic version has been implemented in the system Coq [2] using a translation into natural deduction...|$|R
50|$|Davidson's account, though brief, {{constitutes}} the first systematic presentation of truth-conditional semantics. He proposed simply translating natural languages into <b>first-order</b> <b>predicate</b> <b>calculus</b> {{in order to}} reduce meaning to a function of truth.|$|E
50|$|Lenat's quest, in the Cyc project, is {{to build}} {{the basis of a}} general {{artificial}} intelligence by manually representing knowledge in the formal language, CycL, based on extensions to <b>first-order</b> <b>predicate</b> <b>calculus.</b>|$|E
50|$|We {{work with}} <b>first-order</b> <b>predicate</b> <b>calculus.</b> Our {{languages}} allow constant, function and relation symbols. Structures consist of (non-empty) domains and {{interpretations of the}} relevant symbols as constant members, functions or relations over that domain.|$|E
5000|$|Monadic <b>predicate</b> <b>calculus</b> can be {{contrasted with}} polyadic <b>predicate</b> <b>calculus,</b> which allows {{relation}} symbols that take {{two or more}} arguments.|$|R
5000|$|In {{mathematical}} logic Frege's propositional calculus {{was the first}} axiomatization of propositional calculus. It was invented by Gottlob Frege, who also invented <b>predicate</b> <b>calculus,</b> in 1879 {{as part of his}} second-order <b>predicate</b> <b>calculus</b> (although Charles Peirce was the first to use the term [...] "second-order" [...] and developed his own version of the <b>predicate</b> <b>calculus</b> independently of Frege).|$|R
40|$|<b>FIRST-ORDER</b> <b>predicate</b> logic {{has been}} {{traditionally}} {{viewed as the}} place to formalize the mathematician's notion of a "tautologous inference"; intuitively {{it is clear that}} any trivial inference should be easily formalizable and decidable in predicate logic. While one could take issue with the question of the ease of formalization U. Ketonen, 1981), I shall concentrate now on the question of decidability. 1. THE ISSUE OF DECIDABILITY As is well known, the full system of <b>predicate</b> <b>calculus</b> is not decidable; thus one must study suitable fragments of predicate logic. For the most trivial case, namely, propositional logic, many sufficiently fast algorithms are known. We have learned to live with exponential time bounds. The FOL (First-order Logic) system at the Stanford Artificial Intelligence Laboratory, for example, has an extremely efficient procedure, developed by A. Chandra and R. Weyrauch, for checking propositional tautologies by compiling an optimized machine-language program and then executing it. The situation gets more complicated with fragments that employ quantifiers in a nontrivial way. The best known of these are monadic <b>predicate</b> <b>calculus</b> and various subclasses of formulas determined by quantifier prefixes. All of the classes mentioned so far have obvious defects {{from the point of view}} of mechanical proof-checking: Either they place artificial limitations on the type of formulas or else the associated decision procedures cannot be efficiently implemented on a computer. For example, H. Lewis (1978) has shown that any decision procedure for monadic <b>predicate</b> <b>calculus</b> will (given the present state of knowledge of the P = NP problem) run in essentially double exponential time. In practice this may cause insurmountable problems...|$|R
5000|$|... "The {{reason why}} we take up <b>first-order</b> <b>predicate</b> <b>calculus</b> with {{equality}} {{is a matter of}} convenience; by this we save the labor of defining equality and proving all its properties; this burden is now assumed by the logic." ...|$|E
5000|$|Formal {{specification}} languages: Like other Logic Visual Languages, Codecharts articulate {{sentences in}} mathematical logic. LePUS3 is axiomatized in and {{defined as a}} recursive (turing-decidable) subset of <b>first-order</b> <b>predicate</b> <b>calculus.</b> Its semantics are defined using finite structure (mathematical logic).|$|E
50|$|Fril is a {{programming}} language for <b>first-order</b> <b>predicate</b> <b>calculus.</b> It includes the semantics of Prolog as a subset, but takes its syntax from the micro-Prolog of Logic Programming Associates and adds support for fuzzy sets, support logic, and metaprogramming.|$|E
40|$|Introduction Early {{artificial}} intelligence systems relied on <b>first-order</b> <b>predicate</b> logic {{as a language}} for representing domain knowledge. While this scheme is completely general and semantically clear, {{it has been found}} to be inadequate for organizing large knowledge bases and encoding complex objects. As an alternative, various frame-based languages have been employed. These languages are designed to support the natural representation of structured objects and taxonomies. They have proved to be well-suited for representing many useful relations, although they lack the general expressive power of the <b>predicate</b> <b>calculus.</b> Knowledge-based systems may also be classified according to inference methods. Most deductive systems may be characterized as either goaldirected (backward chaining) or data-directed (forward chaining). In a goal 1 directed system, logical implications are encoded as rules that are used by the system to reduce goals to simpler subgoals. This allows knowl...|$|R
50|$|The {{absence of}} polyadic {{relation}} symbols severely restricts {{what can be}} expressed in the monadic <b>predicate</b> <b>calculus.</b> It is so weak that, unlike the full <b>predicate</b> <b>calculus,</b> it is decidable—there is a decision procedure that determines whether a given formula of monadic <b>predicate</b> <b>calculus</b> is logically valid (true for all nonempty domains). Adding a single binary relation symbol to monadic logic, however, results in an undecidable logic.|$|R
40|$|The paper focusses on {{the logical}} {{backgrounds}} of the Dijkstra-Scholten program development style for correct programs. For proving the correctness {{of a program}} (i. e. {{the fact that the}} program satisfies its specifications), one often uses a special form of <b>predicate</b> <b>calculus</b> in this style of programming. We call this the Dijkstra-Scholten (DS) <b>predicate</b> <b>calculus,</b> since [DS 90] is the first place in which it is described. DS <b>predicate</b> <b>calculus</b> can be conceived of as a logically sound and complete manipulation technique for dealing with logical formulas which also contain programming variables. We relate DS <b>predicate</b> <b>calculus</b> to the classical logical formalism, by contrasting its syntax, derivation rules and semantics to the classical framework. We also comment on two abstractions of DS predicate calculus: the set-theoretical and the algebraic approach. In doing so, we give DS <b>predicate</b> <b>calculus</b> and its abstract variants a firm basis, {{on a par with the}} foundations of the well-known first order logic. Such a comparison of DS <b>predicate</b> <b>calculus</b> and classical logic has not yet been sufficiently elaborated before. We conclude our paper with a number of examples showing that the, up to now, unsatisfactory presentation of DS <b>predicate</b> <b>calculus</b> and some of its features (such as the square brackets notation) has led to errors and fallacies in the literature...|$|R
5000|$|In <b>first-order</b> <b>predicate</b> <b>calculus,</b> All S are P can be {{represented}} as [...] It is therefore clear that the categorical converse {{is closely related to}} the implicational converse, and that S and P cannot be swapped in All S are P.|$|E
5000|$|The {{semantic}} {{foundation of}} the UTP is the <b>first-order</b> <b>predicate</b> <b>calculus,</b> augmented with fixed point constructs from second-order logic. Following the tradition of Eric Hehner, programs are predicates in the UTP, {{and there is no}} distinction between programs and specifications at the semantic level. In the words of Hoare: ...|$|E
50|$|There are {{standard}} techniques for rewriting an arbitrary formula into {{one that does}} not use function or constant symbols, at the cost of introducing additional quantifiers; we will therefore assume that all formulas are free of such symbols. Gödel's paper uses a version of <b>first-order</b> <b>predicate</b> <b>calculus</b> that has no function or constant symbols to begin with.|$|E
40|$|AbstractIt {{is shown}} that nonmodal {{classical}} linear <b>first-order</b> <b>predicate</b> logic based on multiplicative conjunction, additive disjunction, negation, the propositional constants and the existential quantifier {{is included in}} intuitionistic linear <b>first-order</b> <b>predicate</b> logic. An analogous result is obtained for BCK logic...|$|R
40|$|The Hybrid <b>Predicate</b> <b>Calculus</b> (HPC) is {{a hybrid}} logical system that {{incorporates}} a fairly conventional rst-order <b>predicate</b> <b>calculus,</b> {{but that also}} include elements of modal logic and relational algebra. A special eort {{has been made to}} produce a (syntactically and semantically) well-integrated whole, rather than just a disjoint union...|$|R
50|$|A <b>predicate</b> <b>calculus</b> {{will usually}} {{include all the}} same rules as a propositional calculus, with the {{addition}} of quantifiers such that if we take Φ to be a formula of propositional logic and α as a variable then we can take (α)Φ and (α)Φ each to be formulas of our <b>predicate</b> <b>calculus.</b>|$|R
50|$|This {{became the}} topic that Gödel chose for his {{doctoral}} work. In 1929, {{at the age}} of 23, he completed his doctoral dissertation under Hans Hahn's supervision. In it, he established the completeness of the <b>first-order</b> <b>predicate</b> <b>calculus</b> (Gödel's completeness theorem). He was awarded his doctorate in 1930. His thesis, along with some additional work, was published by the Vienna Academy of Science.|$|E
5000|$|The {{semantics}} for uniqueness quantification requires <b>first-order</b> <b>predicate</b> <b>calculus</b> with equality. This {{means there}} is given a distinguished two-placed predicate [...] "="; the semantics is also modified accordingly so that [...] "=" [...] is always interpreted as the two-place equality relation on X. The interpretation of then is the function of n-1 arguments, which is the logical and of the interpretations of ...|$|E
5000|$|Developed in 1990 by Ross Quinlan, FOIL learns function-free Horn clauses, {{a subset}} of <b>first-order</b> <b>predicate</b> <b>calculus.</b> Given {{positive}} and negative examples of some concept {{and a set of}} background-knowledge predicates, FOIL inductively generates a logical concept definition or rule for the concept. The induced rule must not involve any constants (color(X,red) becomes color(X,Y), red(Y)) or function symbols, but may allow negated predicates; recursive concepts are also learnable.|$|E
50|$|We axiomatize <b>predicate</b> <b>calculus</b> without {{equality}} (sometimes confusingly called without identity), i.e. {{there are}} no special axioms expressing the properties of (object) equality as a special relation symbol. After the basic form of the theorem has been proved, it will be easy to extend it {{to the case of}} <b>predicate</b> <b>calculus</b> with equality.|$|R
5000|$|... can be notated in the {{language}} of monadic <b>predicate</b> <b>calculus</b> as ...|$|R
40|$|The present {{paper is}} part of a large {{research}} programme investigating the nature and properties of the predicate logic inherent in natural language. The general hypothesis is that natural speakers start off with a basic-natural logic, based on natural cognitive functions, including the basic-natural way of dealing with plural objects. As culture spreads, functional pressure leads to greater generalization and mathematical correctness, yielding ever more refined systems until the apogee of standard modern predicate logic. Four systems of <b>predicate</b> <b>calculus</b> are considered: Basic-Natural <b>Predicate</b> <b>Calculus</b> (BNPC), Aritsotelian-Abelardian <b>Predicate</b> <b>Calculus</b> (AAPC), Aritsotelian-Boethian <b>Predicate</b> <b>Calculus</b> (ABPC), also known as the classic Square of Opposition, and Standard Modern <b>Predicate</b> <b>Calculus</b> (SMPC). (ABPC is logically faulty owing to its Undue Existential Import (UEI), but that fault is repaired by the addition of a presuppositional component to the logic.) All four systems are checked against seven natural logical intuitions. It appears that BNPC scores best (five out of seven), followed by ABPC (three out of seven). AAPC and SMPC finish ex aequo with two out of seven. 1. The programme This tentative and exploratory paper is about a topic that has not been broached i...|$|R
