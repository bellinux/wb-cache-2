36|146|Public
40|$|Multi-criticality {{real-time}} systems require protected-mode {{operating systems}} with bounded interrupt latencies and guaranteed isolation between components. A tight WCET analysis of such systems requires trustworthy information about loop bounds and infeasible paths. We propose sequoll, {{a framework for}} employing model checking of binary code to determine loop counts and infeasible paths, as well as validating manual <b>infeasible</b> <b>path</b> annotations which are often error-prone. We show that sequoll automatically determines many of the loop counts in the Mälardalen WCET benchmarks. We also show that sequoll computes loop bounds and validates several <b>infeasible</b> <b>path</b> annotations used to reduce the computed WCET bound of seL 4, a high-assurance protected microkernel for multicriticality systems...|$|E
40|$|Abstract: This paper investigates {{application}} of SQP optimization algorithms to nonlinear model predictive control. It considers feasible vs. <b>infeasible</b> <b>path</b> methods, sequential vs. simultaneous methods and reduced vs. full space methods. The suitable choices between these various strategies are assessed informally through a case study...|$|E
40|$|Abstract. Statically {{estimating}} {{the worst case}} execution time of a pro-gram is important for real-time embedded software. This is difficult even in the programming language level due to the inherent difficulty in de-tecting infeasible paths in a program’s control flow graph. In this paper, we study the problem of accurately bounding the execution time of a program loop. This involves <b>infeasible</b> <b>path</b> detection followed by timing analysis. We employ constraint propagation methods to detect infeasi-ble paths spanning across loop iterations. Our timing analysis is exact modulo the <b>infeasible</b> <b>path</b> information provided. Moreover, the analysis is efficient since it relies on memoization techniques to avoid exhaustive enumeration of all paths through a loop. The precision of our timing analysis is demonstrated on different benchmark programs. ...|$|E
40|$|Experimental {{evidence}} indicates that large programs exhibit significant amount of branch correlation amenable to compile-time detection. Branch correlation gives rise to <b>infeasible</b> <b>paths,</b> which in turn make data flow information overly conservative. For example, def-use pairs that always span <b>infeasible</b> <b>paths</b> cannot be tested by any program input, preventing 100 % def-use testing coverage. We present an algorithm for identifying <b>infeasible</b> program <b>paths</b> and a data flow analysis technique that improves the precision of traditional def-use pair analysis by incorporating the information about <b>infeasible</b> <b>paths</b> into the analysis. <b>Infeasible</b> <b>paths</b> are computed using branch correlation analysis, which can be performed either intra- or inter-procedurally. The efficiency of our technique is achieved through demand-driven formulation of both the <b>infeasible</b> <b>paths</b> detection and the def-use pair analysis. Our experiments indicate that even when a simple form of intraprocedural branch correlation i [...] ...|$|R
40|$|Abstract. Experimental {{evidence}} indicates that large programs exhibit significant amount of branch correlation amenable to compile-time de-tection. Branch correlation gives rise to <b>infeasible</b> <b>paths,</b> which in turn make data flow information overly conservative. For example, def-use pairs that always span <b>infeasible</b> <b>paths</b> cannot be tested by any program input, preventing 100 % defuse, testing coverage. We present an algo-rithm for identifying <b>infeasible</b> program <b>paths</b> and a data flow analysis technique that improves the precision of traditional def-use pair analysis by incorporating the information about <b>infeasible</b> <b>paths</b> into the analysis. <b>Infeasible</b> <b>paths</b> are computed using branch correlation analysis, which can be performed either intra- or inter-procedurally. The efficiency of our technique is achieved through demand-driven formulation of both the <b>infeasible</b> <b>paths</b> detection and the defuse pair analysis. Our experi-ments indicate that even when a simple form of intraprocedural branch correlation is considered, more than 2 % of defuse pairs in the SPEC 95 benchmark programs can be found infeasible. ...|$|R
40|$|This article explores {{relationships}} between imperative and functional programming by viewing a {{program as a}} set of paths. We argue, through a small case study, that the presence of <b>infeasible</b> (or unexecutable) <b>paths</b> makes programs harder to understand. We identify two main causes of <b>infeasible</b> <b>paths,</b> “unnecessary ” sequenc-ing and destructive update, hallmarks of an imperative programming style. Functional programming eschews se-quencing and destructive update, which can result in pro-grams with fewer <b>infeasible</b> <b>paths</b> that are easier to un-derstand. No proofs are included. We intend to provoke discussion regarding imperative and functional program-ming styles. Feasible and <b>Infeasible</b> <b>Paths</b> Regardless of the language they spring from, program...|$|R
40|$|International audienceRecent code-based test input {{generators}} {{based on}} dynamic symbolic execution increase path coverage by solving path condition with a constraint or an SMT solver. When the solver considers path condition produced from an <b>infeasible</b> <b>path,</b> {{it tries to}} show unsatisfiability, which is a useless timeconsuming process. In this paper, we propose a new method that takes opportunity of the detection of a single <b>infeasible</b> <b>path</b> to generalize to a (possibly infinite) family of infeasible paths, which {{will not have to}} be considered in further path conditions solving. The method exploits non-intrusive constraint-based explanations, a technique developed in Constraint Programming to explain unsatisfiability. Experimental results obtained with our prototype tool IPEG show that, whatever is the underlying constraint solving procedure (IC, Colibri and the SMT solver Z 3), this approach can save considerable computational time...|$|E
40|$|Abstract—Recent code-based test input {{generators}} {{based on}} dynamic symbolic execution increase path coverage by solving path condition with a constraint or an SMT solver. When the solver considers path condition produced from an <b>infeasible</b> <b>path,</b> {{it tries to}} show unsatisfiability, which is a useless timeconsuming process. In this paper, we propose a new method that takes opportunity of the detection of a single <b>infeasible</b> <b>path</b> to generalize to a (possibly infinite) family of infeasible paths, which {{will not have to}} be considered in further path conditions solving. The method exploits non-intrusive constraint-based explanations, a technique developed in Constraint Programming to explain unsatisfiability. Experimental results obtained with our prototype tool IPEG show that, whatever is the underlying constraint solving procedure (IC, Colibri and the SMT solver Z 3), this approach can save considerable computational time. Index Terms—Dynamic symbolic execution; constraint-based explanation; test input generation I...|$|E
40|$|Abstract—Hard {{real-time}} {{systems are}} required to meet critical deadlines. Worst case execution time (WCET) is therefore an important metric for the system level schedulability analysis of hard real-time systems. However, performance enhancing features of a processor (e. g. pipeline, caches) makes WCET analysis a very difficult problem. In this paper, we propose a novel approach to combine abstract interpretation (AI) and satisfiability (SAT) checking (hence the name AI+SAT) for different varieties of micro-architectural modeling. Our work in this paper is inspired by the research advances in program flow analysis(e. g. <b>infeasible</b> <b>path</b> analysis). We show that the accuracy of WCET estimates can be improved in a scalable fashion by using SAT checkers to integrate <b>infeasible</b> <b>path</b> analysis results into micro-architectural modeling. Our modeling is implemented {{on top of the}} Chronos WCET analysis tool and we improve the accuracy of WCET estimates for instruction cache, data cache, branch predictors and shared caches. I...|$|E
40|$|Detection of <b>infeasible</b> <b>paths</b> is {{required}} in many areas including test coverage analysis, test case generation, security vulnerability analysis, etc. Existing approaches typically use static analysis coupled with symbolic evaluation, heuristics, or path-pattern analysis. This paper is related to these approaches but with a different objective. It is to analyze code of real systems to build patterns of unsatisfiable constraints in <b>infeasible</b> <b>paths.</b> The resulting patterns {{can be used to}} detect <b>infeasible</b> <b>paths</b> without the use of constraint solver and evaluation of function calls involved, thus improving scalability. The patterns can be built gradually. Evaluation of the proposed approach shows promising results...|$|R
40|$|This thesis {{presents}} {{a technique to}} improve the precision of data-flow analyses on object-oriented programs {{in the presence of}} correlated calls. We say that two method calls are correlated if they are polymorphic (have multiple targets) and are invoked on the same object. Correlated calls are problematic because they can make existing data-flow analyses consider certain <b>infeasible</b> data-flow <b>paths</b> as valid. This leads to loss in precision of the analysis solution. We show how <b>infeasible</b> <b>paths</b> can be eliminated for Inter-procedural Finite Distributive Subset (IFDS) problems, a large class of data-flow analysis problems. We show how the precision of IFDS problems can be improved in the presence of correlated calls, by using the Inter-procedural Distributive Environment (IDE) algorithm to eliminate <b>infeasible</b> <b>paths.</b> Using IDE, we eliminate the <b>infeasible</b> <b>paths</b> and obtain a more precise result for the original IFDS problem. Our analysis is implemented in Scala, using the WALA framework for static program analysis on Java bytecode...|$|R
40|$|Real-time {{scheduling}} {{of application}} requires sound {{estimation of the}} Worst-Case Execution Time (WCET) of each task. Part of the over-approximation introduced by the WCET analysis of a task comes from not {{taking into account the}} fact that the (implicit) worst-case execution <b>path</b> may be <b>infeasible.</b> This article does not address the question of finding <b>infeasible</b> <b>paths</b> but provides a new formalism of automata to describe sets of <b>infeasible</b> <b>paths.</b> This formalism combines the possibilities to express state-based path acceptance (like in regular automata), constraints on counters (in the Implicit Path Enumeration Technique fashion) and contexts of validity (like in State charts). We show the applicability of our proposal by performing <b>infeasible</b> <b>paths</b> aware WCET analyses within the OTAWA framework. We provide algorithms that transform the control flow graph and/or the constraints system supporting the WCET analysis in order to exclude the specified paths...|$|R
40|$|The {{problem of}} testing from an SDL {{specification}} is often {{complicated by the}} pres-ence of infeasible paths. This paper introduces an approach for transforming a class of SDL specification in order to eliminate or reduce the <b>infeasible</b> <b>path</b> problem. This approach {{is divided into two}} phases in order to aid generality. First the SDL specification is rewritten to create a normal form extended finite state machine (NF-EFSM). This NF-EFSM is then expanded in order to produce a state machine in which the test criterion may be satisfied using paths that are known to be feasible. The expansion process is guaranteed to terminate. Where the expansion process may lead to an excessively large state machine, this process may be terminated early and feasible paths added. The approach is illustrated through being applied to the Initiator process of the Inres protocol. Key words: SDL, test generation, extended finite state machine, <b>infeasible</b> <b>path</b> problem 1. ...|$|E
40|$|Abstract Synchronous {{languages}} like Esterel {{have been}} widely adopted for designing reactive systems in safety-critical domains such as avionics. Specifications written in Esterel {{are based on the}} underlying “synchrony hypothesis”, which needs to be validated when Esterel specifications get compiled to real implementations (such as C code). In this work, we present a model-driven and architecture-aware timing analysis framework for C code generated from Esterel and executed on general-purpose processors. By integrating model-level information into the traditional timing analysis, we can efficiently compute accurate time estimates via systematically eliminating a large number of infeasible paths in the generated code. Experimental results show that with our proposed intermediate representation level <b>infeasible</b> <b>path</b> analysis in the model compilation, we obtain up to 16. 1 % tighter WCET estimates compared to the traditional assembly code level <b>infeasible</b> <b>path</b> detection with substantially less analysis time. Furthermore, by maintaining the traceability links between Esterel specifications and the generated C code, we are able to map the time-critical computations at the C-level back to the Esterel-level...|$|E
40|$|The {{problem of}} testing from an {{extended}} {{finite state machine}} (EFSM) {{is complicated by the}} presence of infeasible paths. This paper considers the problem of expanding an EFSM in order to bypass the <b>infeasible</b> <b>path</b> problem. The approach is developed for the specification language SDL but, in order to aid generality, the rewriting process is broken down into two phases: producing a normal form EFSM (NF-EFSM) from an SDL specification and then expanding this NF-EFSM...|$|E
40|$|Determining {{worst case}} {{execution}} {{time of a}} program by static analysis {{is important for the}} design of real-time software. WCET analysis at the programming language level requires the detection of the longest path in the program. A tighter bound on the WCET of a program can be achieved by identifying the <b>infeasible</b> <b>paths</b> in the program's control flow, which is a di#cult problem. Due to the branches in a program structure, the number of possible paths in the program can grow exponentially. In this paper we present a method to transform the code such that the number of paths in the program could be reduced and hence the search space for the <b>infeasible</b> <b>paths</b> is brought down. This could reduce the complexity of determining <b>infeasible</b> <b>paths</b> in a program and also result in tighter WCET. 1...|$|R
40|$|Abstract. We {{address the}} problem of {{estimating}} the Wost-Case Execution Time (WCET) for loop-bounded programs. It is well known that for efficiency reasons, current techniques take little or no account of <b>infeasible</b> <b>paths</b> in the symbolic execution tree, thus limiting their accuracy. To consider all <b>infeasible</b> <b>paths,</b> ie. to be path-sensitive, would generally entail an impractical full path enumeration of the tree. In this paper, we present an algorithm that is systematically path-sensitive. That is, the algorithm detects all <b>infeasible</b> <b>paths</b> within the unsurmountable limitations of (a) being able to generate a sufficient loop-invariant, and (b) having the power of the underlying theorem-prover to decide feasibitily. Thus, eg. for loopfree programs whose <b>infeasible</b> <b>paths</b> are decidable, our algorithm is perfectly accurate. There are two main features: interpolation and witness paths. The algorithm traverses the symbolic execution tree, in a post-order manner, and discovers an interpolant which generalizes the execution context of the tree. Trees satisfying the more general context contain no more paths than the original. While the interpolant potentially enables the reuse of the longest path estimate obtained from one subtree in order to cover another subtree, a complimentary problem is that <b>infeasible</b> <b>paths</b> in the subsumed subtree but feasible in the original subtree are not taken into account. We deal with this by storing in each traversed subtree a representative “witness ” path which defines the longest path estimate in the subtree. Thus covering of subtrees now depend on both the interpolant and the witness path of the traversed subtree. In summary, we provide what is essentially a dynamic programming algorithm which can avoid full enumeration. We finally present empirical data with real programs to demonstrate practicality. ...|$|R
40|$|The {{extended}} finite {{state machine}} (EFSM) is a powerful approach for modeling state-based systems. However, testing from EFSMs {{is complicated by the}} existence of <b>infeasible</b> <b>paths.</b> One important problem is the existence of a transition with a guard that references a counter variable whose value depends on previous transitions. The presence of such transitions in paths often leads to <b>infeasible</b> <b>paths.</b> This paper proposes a novel approach to bypass the counter problem. The proposed approach is evaluated by being used in a genetic algorithm to guide the search for feasible transition paths (FTPs) ...|$|R
40|$|This paper investigates {{application}} of SQP optimization algorithm to nonlinear model predictive control. It considers feasible vs. <b>infeasible</b> <b>path</b> methods, sequential vs. simultaneous methods and reduced vs full space methods. A new optimization algorithm coined rFOPT which remains feasibile {{with respect to}} inequality constraints is introduced. The suitable choices between these various strategies are assessed informally through a small CSTR case study. The case study also considers the effect various discretization methods have on the optimization problem...|$|E
40|$|Statically {{estimating}} {{the worst case}} execution time (WCET) of a program is important for real-time software. This is difficult even in the programming language level due to the inherent difficulty in detecting and exploiting infeasible paths in a program’s control flow graph. In this paper, we propose an efficient method to exploit <b>infeasible</b> <b>path</b> information for WCET estimation of a loop without resorting to exhaustive path enumeration. The efficiency of our approach is demonstrated with a real-life control-intensive program. 1...|$|E
40|$|Abstract: 2 ̆ 2 Strategies are {{presented}} for performing maximum heat integration of process streams simultaneously with flowsheet optimization in sequential process simulators. The strategies {{have been implemented}} on FLOWTRAN, using <b>infeasible</b> <b>path</b> optimization methods. Two formulations for performing the heat integration are compared in terms of reliability and computational efficiency. Results on complex process flowsheets show that this approach can produce substantial savings in raw material consumption through more efficient energy integration. Moreover, based on a simplified model, it is proved that these savings can always be achieved in recycle processes. 2 ̆...|$|E
40|$|Abstract. We {{present a}} {{technique}} for detecting semantically <b>infeasible</b> <b>paths</b> in programs using abstract interpretation. Our technique uses a interpreter to infer paths {{in the control}} flow graph that cannot be exercised in concrete executions of the program. We then present a syntactic language refinement (SLR) technique that automatically excludes semantically <b>infeasible</b> <b>paths</b> from a program during static analysis. SLR allows us to iteratively prove more properties. Specifically, our technique simulates {{the effect of a}} path-sensitive analysis by performing syntactic language refinement over an underlying pathinsensitive static analyzer. Finally, we present experimental results to quantify the impact of our technique on an abstract interpreter for C programs. ...|$|R
40|$|When {{constructing}} high-performance real-time systems, {{safe and}} tight estimations {{of the worst}} case execution time (WCET) of programs run on pipelined processors with caches are needed. To obtain tight estimations both path and timing analyses need to be done. Path analysis is responsible for eliminating <b>infeasible</b> <b>paths</b> in the program and timing analysis is responsible for accurately modeling the timing behavior of dynamically scheduled processors employing pipelining and caching. This thesis presents a new method, based on cycle-level symbolic execution, that combines path and timing analyses for programs on high-performance processors. An implementation of the method {{has been used to}} estimate the WCET for a suite of programs running on a high-performance processor. The results show that by using a combined analysis, the overestimation is significantly reduced compared to previously published methods. The method automatically eliminates <b>infeasible</b> <b>paths</b> and derive...|$|R
40|$|We {{present a}} method to find static path {{exclusions}} in a control flow graph in order to refine the WCET analysis. Using this information, some <b>infeasible</b> <b>paths</b> can be discarded during the ILP-based longest path analysis which helps to improve precision. The new analysis works at the assembly level and uses the Omega library to evaluate Presburger formulas. ...|$|R
40|$|Accurate {{estimation}} of the worst-case execution time (WCET) of a program is important for real-time embedded software. Static WCET estimation involves program path analysis and architectural modeling. Path analysis is complex due to the inherent difficulty in detecting and exploiting infeasible paths in a program’s control flow graph. In this paper, we propose an efficient method to exploit <b>infeasible</b> <b>path</b> information for WCET estimation without resorting to exhaustive path enumeration. We demonstrate the efficiency of our approach for some real-life control-intensive applications. Categories and Subject Descriptors C. 3 [Special-purpose and Application-based Systems]: Real-time and embedded systems; D. 2. 8 [Software Engineering]...|$|E
40|$|Abstract. In {{shortest}} path routing, traffic is routed along {{shortest path}}s defined by link weights. However, not all path systems are feasible {{in that they}} can be realized in this way. This is something which needs {{to be taken into account}} when searching for a set of paths that minimize capacity consumption. In this paper, we discuss a new necessary condition that can be used during search to prune <b>infeasible</b> <b>path</b> systems. The condition can be expressed using linear inequalities, or used in constraint programming, where its simple definition is convenient for the efficient implementation of propagation. Experiments on networks from the SNDLib benchmark show that this condition has strong pruning capabilities. ...|$|E
40|$|Abstract: 2 ̆ 2 We {{consider}} optimal design {{problems of}} systems governed by suitable discretizations of nonlinear partial differential equations. We present and examine a coordinate basis <b>infeasible</b> <b>path</b> method tailored to such design problems. We employ a particular null space representation which exploits {{the structure of}} the constraint Jacobian. The resulting method avoids resolution of the nonlinear behavior for each design iterate. Three variants of the method are developed which require the solution of either two or three linear systems involving the stiffness matrix of the discrete boundary value problem. The method is used to solve an aerodynamic design problem governed by nonlinear potential flow. Numerical results demonstrate a substantial performance improvement. 2 ̆...|$|E
40|$|A {{fundamental}} issue in model checking of {{software is the}} choice of a model for software. We present a model called boolean programs that is expressive enough to capture interesting properties of programs and is amenable to model checking. We present a model checking algorithm for boolean programs using context-free-language reachability. The model checking algorithm allows procedure calls with unbounded recursion, exploits locality of variable scopes, and gives short error traces. Furthermore, we give a process for incrementally re ning an initial skeletal boolean program B (representing a source program P) with respect to a particular reachability query in P. The presence of <b>infeasible</b> <b>paths</b> in P may lead to the model checker reporting false positive errors in B. We show how to re ne B by introducing boolean variables to rule out the <b>infeasible</b> <b>paths.</b> The process uses ideas from model checking and symbolic execution to automatically perform predicate abstraction...|$|R
40|$|International audience—Path-biased random {{testing is}} an {{interesting}} alternative to classical path-based approaches faced to {{the explosion of the}} number of paths, and to the weak structural coverage of random methods based on the input domain only. Given a graph representation of the system under test a probability distribution on paths of a certain length is computed and then used for drawing paths. A limitation of this approach, similarly to other methods based on symbolic execution and static analysis, is the existence of <b>infeasible</b> <b>paths</b> that often leads to a lot of unexploitable drawings. We present a prototype for pruning some <b>infeasible</b> <b>paths,</b> thus eliminating useless drawings. It is based on graph transformations that have been proved to preserve the actual behaviour of the program. It is driven by symbolic execution and heuristics that use detection of subsumptions and the abstract-check-refine paradigm. The approach is illustrated on some detailed examples...|$|R
40|$|B Reconstructs {{a control}} flow graph from the binary. B Determines invariants for the values in {{registers}} and in memory. B Determines {{constraints on the}} control flow, by B determining loop bounds, and B identifying <b>infeasible</b> <b>paths.</b> B Determines bounds on execution times of basic blocks. B Based on an abstract model of the microarchitecture, includ-ing detailed models of B the pipeline, and B the memory hierarchy. B Determines a worst-case path and an upper bound on the execution time. B Usually formulated as integer linear program. Jan Reineke Timing Analysis and Timing Predictability 2. April 2012 7 / 54 Reconstructs a control-flow graph from the binary. Determines invariants for the values in registers and in memory. Determines invariants on the control flow, by •  Determining loop bounds, •  Identifying <b>infeasible</b> <b>paths.</b> Determines bound on execution times of program fragments. Determines a worst-case path and an upper bound on the WCET...|$|R
40|$|Synchronous {{programming}} languages like Esterel {{are widely}} used in safetycritical domains like avionics. However, it is only with the recent development of mature worst-case execution time (WCET) analysis tools that {{progress is being made}} on systematically studying the WCET analysis problem for languages like Esterel. In this context, we present techniques for methodically classifying and detecting different types of infeasible paths that arise while compiling Esterel programs into executable code, via high-level languages such as C. Our experimental results with well-known benchmarks show that the infeasible paths detected using our techniques result in as much as 36. 5 % reduction in the WCET estimates, compared to when no <b>infeasible</b> <b>path</b> detection is employed. 1...|$|E
40|$|Software testing consumes half of {{the entire}} {{software}} development cost where test case generation is the most cost consuming activity in the whole process. The emergence of automatic test case generation has helped in reducing the cost eventually. Recently, model-based testing (MBT) for automatic test case generation gains interest in industry and academia due to its provision of systematic, automated, and comprehensive testing. One of the input models for MBT is state machine model which currently widely utilized to model embedded systems. Generating test cases from Unified Modeling Language (UML) state machine models has two major challenges: generating feasible paths, and generating data to satisfy the paths. The existing <b>infeasible</b> <b>path</b> detection methods are restricted to extended finite state machine (EFSM) models with integer data type only. For detecting infeasible paths that involve Object Constraints Language (OCL) constraints, new method is needed {{to cover all the}} sophisticated constructs of OCL. For test data generation, the existing search-based techniques (SBTs) have been applied to satisfy only one OCL constraint by time. In order to generate optimal data to satisfy whole constraints in the feasible path, new method with SBTs is necessary to satisfy the whole constraints at the same time of the whole path executing. This thesis presents a method for generating feasible test cases from UML state machine models with OCL constraints. One contribution of this thesis is developing an efficient technique for detecting automatically infeasible paths that contain transitions with conflicted OCL constraints. A model-driven approach was used for generating abstract test cases from the feasible paths. This model driven approach was integrated with the proposed <b>infeasible</b> <b>path</b> detection method which based on analyzing various OCL constructs and operations. The second contribution of this thesis is developing an accurate search-based test data generator for generating automatically optimal test data to satisfy the whole constraints in the path. In the proposed search-based test data generator, a whole constraints analyzer and a fitness function that evolves itself based on the error feedback were proposed. The whole constraint analyzer and the fitness function were combined with four SBTs (genetic algorithm, evolutionary algorithm, simulating annealing, and quantum genetic algorithm). Case study evaluation was conducted based on three industrial open source case studies in order to evaluate empirically the significant of the performance of the proposed method. The results were statically analyzed using t-test to show the significance of the proposed method compared to the existing methods. The results show that the proposed <b>infeasible</b> <b>path</b> detection method was efficient and detect 99 percent of the infeasible paths in the three industrial systems. The results of the proposed search-based test data generator show significant performance compared to the existing search-based test data generator...|$|E
40|$|This paper {{presents}} several {{techniques for}} improving the accuracy of static analysis of concurrent Ada programs. We determine {{the cost of building}} the program representations used to perform the analysis and examine the complexity of performing analysis on those representations. Inaccuracies in the static analysis are reflected in spurious results, which can be generated if the analysis considers paths through the program that are infeasible, or if the effects of aliasing lead to consideration of task communications that can not actually occur. We present three techniques to counter the effects of <b>infeasible</b> <b>path</b> consideration and aliasing and determine the cost of using these techniques. We present empirical results that demonstrate the improvements in accuracy and, in some cases, the reduction in the search space that result from application of our techniques. ...|$|E
40|$|Static Worst-Case Execution Time (WCET) {{analysis}} {{is a technique}} to derive upper bounds for the execution times of programs. Such bounds are crucial when designing and verifying real-time systems. A key component in static WCET {{analysis is}} to derive flow information, such as loop bounds and <b>infeasible</b> <b>paths.</b> Such flow information can be provided as either as annotations by the user, can be automatically calculated by a flow analysis, or {{by a combination of}} both. To make the analysis as simple, automatic and safe as possible, this flow information should be calculated automatically with no or very limited user interaction. In this paper we present three novel algorithms to calculate <b>infeasible</b> <b>paths.</b> The algorithms are all designed to be simple and efficient, both in terms of generated flow facts and in analysis running time. The algorithms have been implemented and tested for a set of WCET benchmarks programs. ...|$|R
40|$|When {{constructing}} real-time systems, {{safe and}} tight estimations {{of the worst}} case execution time (WCET) of programs are needed. To obtain tight estimations, a common approach is to do path and timing analyses. Path analysis is responsible for eliminating <b>infeasible</b> <b>paths</b> in the program and timing analysis is responsible for accurately modeling the timing behavior of programs. The focus of this thesis is on analysis of programs running on high-performance microprocessors employing pipelining and caching. This thesis presents a new method, referred to as cycle-level symbolic execution, that tightly integrates path and timing analysis. An implementation of the method {{has been used to}} estimate the WCET for a suite of programs running on a high-performance processor. The results show that by using an integrated analysis, the overestimation is significantly reduced compared to other methods. The method automatically eliminates <b>infeasible</b> <b>paths</b> and derives path information such as loop bounds, and performs accurate timing analysis for a multiple-issu...|$|R
40|$|We {{present a}} {{framework}} that produces path-sensitive analyses with different tradeoffs of accuracy and efficiency. The first component is a program transformation that restructures a CFG in order to encode path-sensitivity into it. The method consists of deleting <b>infeasible</b> <b>paths</b> from the CFG while performing selective node splitting based on information captured from <b>infeasible</b> <b>paths.</b> This transformation is fully independent from the analysis and can be built offline. Our initial experiments demonstrate {{that the size of}} the resulting CFG increases by a reasonable factor and its use can produce significant accuracy gains for several analyses. The second component is a generic backward algorithm that interleaves the above process with the computation of the analysis. This synergy allows using analysis information in order to decide whether a node should be joined or not. We use the concept of witness that establishes the conditions, using some knowledge from the analysis, to ensure that a node can be joined without incurring in any loss of accuracy. We demonstrate that although more expensive this concept can be implemented producing more precise results. 1...|$|R
