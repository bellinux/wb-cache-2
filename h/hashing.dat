5248|10000|Public
5|$|Another {{method of}} {{constructing}} hash functions with both high quality and practical speed is tabulation <b>hashing.</b> In this method, the hash value for a key {{is computed by}} using each byte of the key as an index into a table of random numbers (with a different table for each byte position). The numbers from those table cells are then combined by a bitwise exclusive or operation. Hash functions constructed this way are only 3-independent. Nevertheless, linear probing using these hash functions takes constant expected time per operation. Both tabulation <b>hashing</b> and standard methods for generating 5-independent hash functions are limited to keys that have a fixed number of bits. To handle strings or other types of variable-length keys, {{it is possible to}} compose a simpler universal <b>hashing</b> technique that maps the keys to intermediate values and a higher quality (5-independent or tabulation) hash function that maps the intermediate values to hash table indices.|$|E
5|$|However, random or {{pseudorandom}} hash values may be {{used when}} <b>hashing</b> objects by their identity rather than by their value. For instance, this is done using linear probing by the IdentityHashMap class of the Java collections framework.|$|E
5|$|The {{analysis}} above {{assumes that}} each key's hash is a random number {{independent of the}} hashes {{of all the other}} keys. This assumption is unrealistic for most applications of <b>hashing.</b>|$|E
5000|$|... uint32_t jenkins_one_at_a_time_hash(const uint8_t* key, size_t length) { size_t i = 0; uint32_t <b>hash</b> = 0; while (i != length) { <b>hash</b> += keyi++; <b>hash</b> += <b>hash</b> << 10; <b>hash</b> ^= <b>hash</b> >> 6; } <b>hash</b> += <b>hash</b> << 3; <b>hash</b> ^= <b>hash</b> >> 11; <b>hash</b> += <b>hash</b> << 15; return hash;} ...|$|R
5000|$|... <b>hash</b> = 0 {{for each}} octet_of_data to be <b>hashed</b> <b>hash</b> = <b>hash</b> × FNV_prime <b>hash</b> = <b>hash</b> XOR octet_of_data return <b>hash</b> ...|$|R
5000|$|... #Caption: An {{example of}} a binary <b>hash</b> tree. <b>Hashes</b> 0-0 and 0-1 are the <b>hash</b> values of data blocks L1 and L2, respectively, and <b>hash</b> 0 is the <b>hash</b> of the {{concatenation}} of <b>hashes</b> 0-0 and 0-1.|$|R
5|$|Linear probing {{can provide}} high {{performance}} {{because of its}} good locality of reference, but is {{more sensitive to the}} quality of its hash function than some other collision resolution schemes. It takes constant expected time per search, insertion, or deletion when implemented using a random hash function, a 5-independent hash function, or tabulation <b>hashing.</b> However, good results can be achieved in practice with other hash functions such as MurmurHash.|$|E
5|$|Along with {{quadratic}} probing {{and double}} <b>hashing,</b> linear probing {{is a form}} of open addressing. In these schemes, each cell of a hash table stores a single key–value pair. When the hash function causes a collision by mapping a new key to a cell of the hash table that is already occupied by another key, linear probing searches the table for the closest following free location and inserts the new key there. Lookups are performed in the same way, by searching the table sequentially starting at the position given by the hash function, until finding a cell with a matching key or an empty cell.|$|E
5|$|For {{implementing}} associative arrays, hash tables, a {{data structure}} that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records; most implementations require only amortized constant time on average. However, <b>hashing</b> is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, {{as the only}} information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. In addition, all operations possible on a sorted array can be performed—such as finding the smallest and largest key and performing range searches.|$|E
5000|$|For example, {{the class}} Employee might {{implement}} its <b>hash</b> function by composing the <b>hashes</b> of its members:public class Employee { int employeeId; String name; Department dept; // other methods {{would be in}} here @Override public int hashCode (...) { int <b>hash</b> = 1; <b>hash</b> = <b>hash</b> * 17 + employeeId; <b>hash</b> = <b>hash</b> * 31 + name.hashCode (...) <b>hash</b> = <b>hash</b> * 13 + (dept == null ? 0 : dept.hashCode (...) [...] ); return hash; }} ...|$|R
50|$|Binary <b>hash</b> {{chains are}} {{commonly}} used in association with a <b>hash</b> tree. A Binary <b>hash</b> chain takes two <b>hash</b> values as inputs, concatenates them and applies a <b>hash</b> function to the result, thereby producing a third <b>hash</b> value.|$|R
5000|$|Murmur3_32(key, len, seed) // Note: In this version, all integer {{arithmetic}} {{is performed}} with unsigned 32 bit integers. // In {{the case of}} overflow, the result is constrained by the application of modulo [...] arithmetic. [...] c1 &larr; 0xcc9e2d51 c2 &larr; 0x1b873593 r1 &larr; 15 r2 &larr; 13 m &larr; 5 n &larr; 0xe6546b64 [...] <b>hash</b> &larr; seed [...] for each fourByteChunk of key k &larr; fourByteChunk [...] k &larr; k &times; c1 k &larr; (k ROL r1) k &larr; k &times; c2 [...] <b>hash</b> &larr; <b>hash</b> XOR k <b>hash</b> &larr; (<b>hash</b> ROL r2) <b>hash</b> &larr; <b>hash</b> &times; m + n [...] with any remainingBytesInKey remainingBytes &larr; SwapToLittleEndian(remainingBytesInKey) // Note: Endian swapping is only necessary on big-endian machines. // The purpose is to place the meaningful digits towards {{the low end of}} the value, // so that these digits have the greatest potential to affect the low range digits // in the subsequent multiplication. Consider that locating the meaningful digits // in the high range would produce a greater effect upon the high digits of the // multiplication, and notably, that such high digits are likely to be discarded // by the modulo arithmetic under overflow. We don't want that. [...] remainingBytes &larr; remainingBytes &times; c1 remainingBytes &larr; (remainingBytes ROL r1) remainingBytes &larr; remainingBytes &times; c2 [...] <b>hash</b> &larr; <b>hash</b> XOR remainingBytes [...] <b>hash</b> &larr; <b>hash</b> XOR len [...] <b>hash</b> &larr; <b>hash</b> XOR (<b>hash</b> >> 16) <b>hash</b> &larr; <b>hash</b> &times; 0x85ebca6b <b>hash</b> &larr; <b>hash</b> XOR (<b>hash</b> >> 13) <b>hash</b> &larr; <b>hash</b> &times; 0xc2b2ae35 <b>hash</b> &larr; <b>hash</b> XOR (<b>hash</b> >> 16) ...|$|R
5|$|Linear probing {{provides}} good locality of reference, {{which causes}} it to require few uncached memory accesses per operation. Because of this, for low to moderate load factors, {{it can provide}} very high performance. However, compared to some other open addressing strategies, its performance degrades more quickly at high load factors because of primary clustering, a tendency for one collision to cause more nearby collisions. Additionally, achieving good performance with this method requires a higher-quality hash function than for some other collision resolution schemes. When used with low-quality hash functions that fail to eliminate nonuniformities in the input distribution, linear probing can be slower than other open-addressing strategies such as double <b>hashing,</b> which probes a sequence of cells whose separation is determined by a second hash function, or quadratic probing, where the size of each step varies depending on its position within the probe sequence.|$|E
25|$|Because of {{its high}} degree of independence, {{tabulation}} <b>hashing</b> is usable with <b>hashing</b> methods that require a high-quality hash function, including linear probing, cuckoo <b>hashing,</b> and the MinHash technique for estimating the size of set intersections.|$|E
25|$|However, {{universal}} <b>hashing</b> is {{not strong}} enough to guarantee the performance of some other <b>hashing</b> algorithms. For instance, for linear probing, 5-independent hash functions are strong enough to guarantee constant time operation, but there are 4-independent hash functions that fail. Nevertheless, despite only being 3-independent, tabulation <b>hashing</b> provides the same constant-time guarantee for linear probing.|$|E
50|$|Often, an {{additional}} <b>hash</b> of the <b>hash</b> list itself (a top <b>hash,</b> also called root <b>hash</b> or master <b>hash)</b> is used. Before downloading a file on a p2p network, {{in most cases}} the top <b>hash</b> is acquired from a trusted source, for instance a friend or a web site that is known to have good recommendations of files to download. When the top <b>hash</b> is available, the <b>hash</b> list can be received from any non-trusted source, like any peer in the p2p network. Then the received <b>hash</b> list is checked against the trusted top <b>hash,</b> and if the <b>hash</b> list is damaged or fake, another <b>hash</b> list from another source will be tried until the program finds one that matches the top <b>hash.</b>|$|R
40|$|Abstract — Sensors {{and other}} small devices that {{periodically}} transmit relatively small packets of information motivate the study of <b>hash</b> chains with small domains and ranges. <b>Hash</b> chain based protocols work using deferred disclosure and it is often assumed their <b>hash</b> functions are one-way, hence essentially unbreakable. However small domains and ranges make <b>hash</b> functions much weaker. If a deterministic <b>hash</b> function’s domain and range are the same and both are very small, then {{it may not be}} possible for the <b>hash</b> function to be one-way. In fact, <b>hash</b> chains with size-constrained domains and ranges are likely to cycle quickly. This paper proposes a solution to this challenge- the general <b>hash</b> chain construction. A general <b>hash</b> chain uses several subsequent <b>hash</b> elements at once as input to produce each output <b>hash</b> element. General <b>hash</b> chains have the following properties: (1) repeated <b>hash</b> elements do not necessarily indicate cycles in the <b>hash</b> chain, (2) subsequent elements of these <b>hash</b> chains do not have exponentially diminishing ranges. This makes general <b>hash</b> chains alluring for devices with size constraints on their domains and ranges. I...|$|R
40|$|In this paper, {{we present}} a new {{construction}} for strong separating <b>hash</b> families by using hypergraphs and obtain some optimal separating <b>hash</b> families. We also improve some previously known bounds of separating <b>hash</b> families. Comment: <b>Hash</b> family, separating <b>hash</b> family, strong separating <b>hash</b> family, hypergrap...|$|R
25|$|He {{observes that}} using one round of simple {{tabulation}} <b>hashing</b> {{to expand the}} input keys to six times their original length, and then {{a second round of}} simple tabulation <b>hashing</b> on the expanded keys, results in a <b>hashing</b> scheme whose independence number is exponential in the parameter r, the number of bits per block in the partition of the keys into blocks.|$|E
25|$|In {{computer}} science, tabulation <b>hashing</b> is {{a method}} for constructing universal families of hash functions by combining table lookup with exclusive or operations. It was first studied {{in the form of}} Zobrist <b>hashing</b> for computer games; later work by Carter and Wegman extended this method to arbitrary fixed-length keys. Generalizations of tabulation <b>hashing</b> have also been developed that can handle variable-length keys such as text strings.|$|E
25|$|Such {{applications}} {{raise the}} question of fast generation of permutations satisfying certain desirable properties. One of the methods is based on the permutation polynomials. Also as a base for optimal <b>hashing</b> in Unique Permutation <b>Hashing.</b>|$|E
50|$|In {{the top of}} a <b>hash</b> tree {{there is}} a top <b>hash</b> (or root <b>hash</b> or master <b>hash).</b> Before {{downloading}} a file on a p2p network, in most cases the top <b>hash</b> is acquired from a trusted source, for instance a friend or a web site that is known to have good recommendations of files to download. When the top <b>hash</b> is available, the <b>hash</b> tree can be received from any non-trusted source, like any peer in the p2p network. Then, the received <b>hash</b> tree is checked against the trusted top <b>hash,</b> and if the <b>hash</b> tree is damaged or fake, another <b>hash</b> tree from another source will be tried until the program finds one that matches the top <b>hash.</b>|$|R
40|$|An {{undergraduate}} thesis {{pertaining to}} the viability of fractal images as visual <b>hashes</b> in cryptographic processes. Fractal visual <b>hashes</b> {{have the potential to}} replace traditional hexadecimal <b>hashes</b> for SSH applications with the goal of increasing user recognition of identities of remote computers. Rather than rely on human users manually comparing two hexadecimal <b>hashes</b> as part of SSH's public-private key encryption process, users would compare fractal images generated from the original hexadecimal <b>hashes</b> to determine if the keys match. A visual <b>hash</b> comparison and differentiation game was developed that evaluated the ability of users to differentiate between two images visually. Users were presented with pairs of either flag <b>hashes,</b> t-flag <b>hashes,</b> identicon <b>hashes,</b> hexadecimal <b>hashes,</b> or fractal <b>hashes</b> and were asked to decide if the images were the same or different. The <b>hashes</b> generated were created in a way so that <b>hashes</b> being compared were very similar in their visual characteristics {{to increase the number of}} images that were hard to distinguish. The data collected was analyzed through Bayesian analysis wherein the user input and the <b>hash</b> details were evaluated to the find the highest probability effective entropy and user error of the system. The fractal visual <b>hash</b> achieved the highest amount of effective entropy among the tested <b>hash</b> types and provided a foundation for further research to be conducted on visual <b>hash</b> systems and the validity of fractal <b>hashes...</b>|$|R
3000|$|A <b>hash</b> {{function}}, {{also called}} a <b>hash</b> function or a <b>hash</b> function, {{is a public}} function that maps any long message to a shorter, fixed-length value as a qualifier, called a <b>hash</b> value, <b>hash</b> code, or message digest. A <b>hash</b> value {{is a function of}} all bits in a message, thus providing an error detection capability that alters the <b>hash</b> value by altering any bit or bits in the message. The definition of the <b>hash</b> function is given below: [...]...|$|R
25|$|Most DHTs {{use some}} variant of {{consistent}} <b>hashing</b> or rendezvous <b>hashing</b> to map keys to nodes. The two algorithms {{appear to have}} been devised independently and simultaneously to solve the distributed hash table problem.|$|E
25|$|Because {{tabulation}} <b>hashing</b> is {{a universal}} <b>hashing</b> scheme, {{it can be used}} in any hashing-based algorithm in which universality is sufficient. For instance, in hash chaining, the expected time per operation is proportional to the sum of collision probabilities, which is the same for any universal scheme as it would be for truly random hash functions, and is constant whenever the load factor of the hash table is constant. Therefore, tabulation <b>hashing</b> can be used to compute hash functions for hash chaining with a theoretical guarantee of constant expected time per operation.|$|E
25|$|AES encrypt/decrypt and SHA-1/SHA-2 <b>hashing</b> {{instructions}} {{also use}} these registers.|$|E
50|$|When the <b>hash</b> {{function}} {{is used to}} store values in a <b>hash</b> table that outlives {{the run of the}} program, and the <b>hash</b> table needs to be expanded or shrunk, the <b>hash</b> table is referred to as a dynamic <b>hash</b> table.|$|R
40|$|Abstract- In this paper, a new <b>hash</b> {{function}} {{based on}} RC 4 stream cipher is proposed. The proposed RC 4 -based <b>hash</b> function has several advantages over many well-known <b>hash</b> functions. Its efficiency {{is much better}} than many widely used known <b>hash</b> function (e. g., MD 5 and SHA-l). The application of the proposed <b>hash</b> function can be extended to the ultra-low devices for Ubiquitous computing, which most other <b>hash</b> functions do not apply. The structure of the proposed <b>hash</b> function is absolutely different from the broken <b>hash</b> function class (e. g., SHA family) so that people cannot use the existing attack strategies to break the proposed <b>hash</b> function. The proposed <b>hash</b> function is very simple and rules out all possible generic attacks. We proved that this <b>hash</b> function is secure and efficient...|$|R
50|$|In {{computer}} science, a <b>hash</b> list {{is typically}} {{a list of}} <b>hashes</b> of the data blocks in a file or set of files. Lists of <b>hashes</b> are used for many different purposes, such as fast table lookup (<b>hash</b> tables) and distributed databases (distributed <b>hash</b> tables). This article covers <b>hash</b> lists {{that are used to}} guarantee data integrity.|$|R
25|$|Despite its simplicity, {{tabulation}} <b>hashing</b> {{has strong}} theoretical properties that {{distinguish it from}} some other hash functions. In particular, it is 3-independent: every 3-tuple of keys is equally likely to be mapped to any 3-tuple of hash values. However, it is not 4-independent. More sophisticated but slower variants of tabulation <b>hashing</b> extend the method to higher degrees of independence.|$|E
25|$|Cuckoo <b>hashing,</b> another {{technique}} for implementing hash tables, guarantees constant time per lookup (regardless of the hash function). Insertions into a cuckoo hash table may fail, causing the entire table to be rebuilt, but such failures are sufficiently {{unlikely that the}} expected time per insertion (using either a truly random hash function or a hash function with logarithmic independence) is constant. With tabulation <b>hashing,</b> on the other hand, the best bound known on the failure probability is higher, high enough that insertions cannot be guaranteed to take constant expected time. Nevertheless, tabulation <b>hashing</b> is adequate to ensure the linear-expected-time construction of a cuckoo hash table for a static set of keys that does not change as the table is used.|$|E
25|$|However, this {{reasoning}} breaks down for four keys {{because there are}} sets of keys w, x, y, and z where none of the four has a byte value {{that it does not}} share with {{at least one of the}} other keys. For instance, if the keys have two bytes each, and w, x, y, and z are the four keys that have either zero or one as their byte values, then each byte value in each position is shared by exactly two of the four keys. For these four keys, the hash values computed by tabulation <b>hashing</b> will always satisfy the equation , whereas for a 4-independent <b>hashing</b> scheme the same equation would only be satisfied with probability 1/m. Therefore, tabulation <b>hashing</b> is not 4-independent.|$|E
5000|$|The trick can be {{exploited}} using a rolling <b>hash.</b> A rolling <b>hash</b> is a <b>hash</b> function specially designed to enable this operation. A trivial (but not very good) rolling <b>hash</b> function just adds {{the values of}} each character in the substring. This rolling <b>hash</b> formula can compute the next <b>hash</b> value from the previous value in constant time: ...|$|R
50|$|A desired {{characteristic}} of a cryptographic <b>hash</b> algorithm is that (for all practical purposes) the <b>hash</b> result (referred to as a <b>hash</b> digest or a <b>hash)</b> of any two modules will produce the same <b>hash</b> value only if the modules are identical.|$|R
5000|$|Disaster <b>Hash</b> 7 - A {{disaster}} <b>hash</b> {{is basically}} an impromptu <b>hash</b> {{that can be}} called by any <b>hash</b> member whenever a disaster occurs. The disaster can be {{anywhere in the world}} and can range from an earthquake to a flat tire. The disaster <b>hash</b> differs by two major <b>hash</b> components, the hares and <b>hash</b> names. The hare is chosen on the spot, given flour, a destination, and a one-minute head start. Whoever catches the hare, becomes the hare. They take the flour and continue along to the destination, this repeats as many times as the hare is caught. Secondly, disaster hashers are given special disaster <b>hash</b> names. All virgins get named at a disaster <b>hash,</b> usually {{having to do with the}} disaster in question and the disaster <b>hash</b> name is completely separate to a normal <b>hash.</b>|$|R
