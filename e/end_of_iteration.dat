15|10000|Public
3000|$|... [...]. Here, a {{variable}} with the superscript m denotes the value obtained at the <b>end</b> <b>of</b> <b>iteration</b> m. In the following, we first design algorithms for both stages, based {{on which the}} iterative RA algorithm will then be stated. Finally, several characteristics of the proposed RA algorithm will be discussed.|$|E
30|$|In {{order to}} make the problem tractable, we opt for a CA {{approach}} made of two stages: the MSSAP stage and the PA stage. We propose an iterative algorithm which optimizes the two stages in an alternate way, as depicted by Algorithm 1. Integer m indicates the iteration number, and a variable with the superscript m denotes the value obtained at the <b>end</b> <b>of</b> <b>iteration</b> m.|$|E
30|$|Note that, as {{both the}} MSSAP stage and the SCGP stage can be solved in {{polynomial}} time, problem (11) can be solved in polynomial time. At the <b>end</b> <b>of</b> <b>iteration</b> m, a local optimum of (11) is obtained at the SCGP stage, which is then improved at the MSSAP stage of the next iteration. After that, a better local optimum of (11) can be calculated at the SCGP stage of iteration m+ 1. Finally, a good local optimum can be obtained after convergence.|$|E
3000|$|At the {{beginning}} <b>of</b> the <b>iterations,</b> A is high, so {{the possibility of}} satisfying condition rand < A_i is high. At the <b>ending</b> <b>of</b> <b>iterations,</b> loudness A is low. So, the possibility of satisfying condition rand < [...]...|$|R
30|$|Concurrent (CON): at the <b>end</b> <b>of</b> an <b>iteration.</b>|$|R
50|$|At the <b>end</b> <b>of</b> the <b>iteration,</b> c, bracket {{the minimum}} point.|$|R
30|$|At the <b>end</b> <b>of</b> <b>iteration</b> m, a local optimum of the {{formulated}} {{problem is}} obtained at the SCGP stage, {{which is then}} improved at the MSSA stage of the next iteration. After that, a better local optimum can be calculated at the SCGP stage of iteration m+ 1. Finally, a good local optimum can be obtained after convergence. As both problems at two stages can be solved by the proposed algorithms in polynomial time, the formulated problem can be solved by Algorithm 2 in polynomial time.|$|E
30|$|Problem (21) {{is made of}} an {{objective}} function and bounding constraints which all are ratios of two posynomials, making the problem belong to the class of CGP [38]. More details about CGP {{can be found in}} Appendix Appendix. Problem (21) can not be made convex and is NP hard [37]. In order to solve it, the SCGP algorithm is now proposed. The proposed SCGP algorithm approximates the non-convex problem (21) into a series of standard GPs. Therefore, it belongs to the class of successive convex approximation methods [39]. The SCGP is described in Algorithm 2. Integer t indicates the current iteration number, and a variable with superscript m′ denotes the value obtained at the <b>end</b> <b>of</b> <b>iteration</b> m′.|$|E
40|$|There {{is a need}} to collect, measure, {{and present}} {{progress}} information in all projects, and Agile projects are no exception. In this article, the authors show how the Line of Balance, a relatively obscure indicator, can be used to gain insights into the progress of projects not provided by burn down charts or cumulative flow diagrams, two of the most common indicators used to track and report progress in agile projects. The authors also propose to replace the original plan-based control point lead-time calculations with dynamic information extracted from a version control system and introduce the concept of the ideal plan to measure progress relative to both, <b>end</b> <b>of</b> <b>iteration</b> milestones and project completion date. 2...|$|E
3000|$|..., the pdf is {{estimated}} only once, at the <b>end</b> <b>of</b> <b>iterations.</b> These {{two kinds of}} algorithm are tested on different random variables having distributions known for their difficult estimation. Finally, they are applied to genetic data {{in order to provide}} a better characterisation in the mean of neutrality of Tunisian Berber populations.|$|R
50|$|At the <b>end</b> <b>of</b> four <b>iterations,</b> the {{following}} sequence of intermediate bits is produced: 0110.|$|R
5000|$|Implementation {{and testing}} (implementation-driven tests during implementation, {{goal-driven}} tests at the <b>end</b> <b>of</b> each <b>iteration)</b> ...|$|R
30|$|We take an {{alternate}} approach, and describe {{in this section}} an algorithm that performs LTL trace validation on event traces directly using the MapReduce computing paradigm. The algorithm evaluates an LTL formula in an iterative fashion. At the first iteration, all the states where ground terms are true are evaluated. In the next iteration, these results are used to evaluate all subformulæ directly using one of those ground terms. More generally, at the <b>end</b> <b>of</b> <b>iteration</b> i of the process, the events where all subformulæ of depth i hold are computed. It follows that, in order to evaluate an LTL formula of depth n, the algorithm will require exactly n MapReduce cycles. Each MapReduce cycle effectively acts {{as a form of}} temporal tester [30] processing a trace made of the evaluation of lower-level testers.|$|E
40|$|In this paper, a {{multimodal}} firefly algorithm {{named the}} CFA (Coulomb Firefly Algorithm) {{has been presented}} based on the Coulomb’s law. The algorithm is able to find more than one optimum solution in the problem search space without requiring any additional parameter. In this proposed method, less bright fireflies would be attracted to fireflies which are not only brighter, {{but according to the}} Coulomb’s law pose the highest gravity. Approaching the <b>end</b> <b>of</b> <b>iteration,</b> fireflies' motion steps are reduced which finally results in a more accurate result. With limited number of iterations, groups of fireflies gather around global and local optimal points. After the final iteration, the firefly which has the highest fitness value, would be survived and the rest would be omitted. Experiments and comparisons on the CFA algorithm show that the proposed method has successfully reacted in solving multimodal optimization problems...|$|E
30|$|At the <b>end</b> <b>of</b> <b>iteration</b> m, a local optimum of the {{formulated}} {{problem is}} obtained at the PA stage, {{which is then}} improved at the MSSA stage of the next iteration. After that, a better local optimum can be calculated at the PA stage of iteration m+ 1. Finally, a good local optimum can be obtained after convergence. Note that each stage is carried out with analytical equations. Thus, the proposed RA algorithm has a lower-complexity compared to the centralized algorithm (CA) of [25]. As will be elaborated in ‘Section 3.2 ’ and ‘Section 3.3 ’, the proposed MSSA algorithm can be implemented distributively in each cell and the SCLD PA algorithm can be implemented semi-distributively in each cell. Thus, the proposed iterative RA algorithm can be implemented semi-distributively in each cell {{with the help of}} a central controller (CC) exchanging messages among cells.|$|E
3000|$|... {{are updated}} at the <b>end</b> <b>of</b> each <b>iteration</b> if the {{termination}} criterion, see Section 4.3. 5, is not met.|$|R
40|$|Particle Swarm Optimization {{is a type}} of nature-inspired {{heuristic}} {{which is}} based on bird flocking and fish schooling in nature. In interactive particle swarm optimization, user evaluations are used to determine the fitness of particles and the <b>end</b> <b>of</b> <b>iterations.</b> In this study, Interactive Particle Swarm Optimization approach is used as a solution to face generation problem. And “success ” of the approach is reported based on the “percentage of images correctly recognized”...|$|R
30|$|To {{remedy the}} {{sensitivity}} to a, we propose an adaptive stepping algorithm. At the <b>end</b> <b>of</b> each <b>iteration</b> k, we perform the adjustment described in Algorithm 1.|$|R
40|$|The {{job shop}} {{scheduling}} problem {{is one of}} the classical NP-Hard scheduling problem. Very simple special cases of the job-shop problem are already strongly NP-hard. An instance with ten jobs to be processed on ten machines formulated in 1963 was open for more than 25 years. In this paper we discuss a prominent approach to solve job shop scheduling problem based on Ant Colony Optimization. The ACO algorithm is developed using artificial ants. The Ant System in ACO takes its cue from the nature inspired insect that is the working scenario of ants and the quality of attractions towards the pheromone trails excreted by the ants of the previous iteration. Moreover the pheromone (hormone) excreted by the ants gets evaporated progressively by the passage of time, so the path with the highest pheromone deposition till the <b>end</b> <b>of</b> <b>iteration</b> will be the best solution for the ants to follow to reach for the target...|$|E
40|$|The {{power flow}} {{analysis}} {{in a highly}} interconnected grid {{is a big problem}} for an electrical engineer. The next big obstacle is that of Economic Dispatch at the load side. The issue with Economic Load Dispatch (ELD) is with allocating the total generation to the individual generators {{in such a way that}} the total cost of generation at any time is at a minimum. In this project, the optimal cost of generation has been analyzed with a distributed slack bus model. In ordinary load flow method, the slack bus is bound to carry the entire extra burden of the system. In the proposed technique, the burden on slack bus shall be reduced and still maintain the equal incremental cost criteria. A new term called Participation factor shall be utilized to achieve the same as the total loss of the system at the <b>end</b> <b>of</b> <b>iteration</b> shall get distributed among all the generating units. Finally practical bus network problems shall be taken as case study and results shall be analyzed and compared with the existing ELD scheme to verify the usefulness of the proposed technique...|$|E
40|$|In this paper, {{we propose}} an output {{regulation}} approach, {{which is based}} on principle of model-reality differences, to obtain the optimal output measurement of a discrete-time nonlinear stochastic optimal control problem. In our approach, a model-based optimal control problem with adding the ad- justable parameters is considered. We aim to regulate the optimal output trajectory of the model used as closely as possible to the output measurement of the original optimal control problem. In doing so, an expanded optimal control problem is introduced, where system optimization and parameter es- timation are integrated. During the computation procedure, the differences between the real plant and the model used are measured repeatedly. In such a way, the optimal solution of the model is updated. At the <b>end</b> <b>of</b> <b>iteration,</b> the converged solution approaches closely to the true optimal solution of the original optimal control problem in spite of model-reality differences. It is im- portant to notice that the resulting algorithm could give the output residual that is superior to those obtained from Kalman filtering theory. The accuracy of the output regulation is therefore highly recommended. For illustration, a continuous stirred-tank reactor problem is studied. The results obtained show the effciency of the approach proposed...|$|E
30|$|In {{the core}} of agile {{development}} is the self-organizing team, which organizes its work the best possible way. To support the self-organization, also other agile practices, many adopted from Scrum were taken into use: iterations, planning and reviewing in the beginning and <b>end</b> <b>of</b> the <b>iterations,</b> and frequent status meetings. To help the organization of work, backlogs were utilized, and to support {{the development of a}} new working method, retrospectives were arranged in the <b>end</b> <b>of</b> every <b>iteration.</b> A product owner was the main customer contact and also responsible for the backlog.|$|R
3000|$|... in {{the first}} iteration. The {{segments}} belonging to white region are marked as background and thus removed at the <b>end</b> <b>of</b> first <b>iteration,</b> depicted in Figure 7 (f). Updated [...]...|$|R
30|$|Initially, {{and at the}} <b>end</b> <b>of</b> each <b>iteration</b> step, each {{residual}} {{base station}} updates its collected CQI data, interference power margins and channel gain matrices and computes the marginal interference power level for its critical client nodes.|$|R
40|$|The {{power flow}} {{in a highly}} {{interconnected}} grid is an ancient problem for an electrical engineer. With the advent of time of course, this issue has been tackled with greater accuracy and efficiency. Now the load flow and subsequent concerns are taken care by simulations in a minute. The next big obstacle is that of Economic Load Dispatch. In ELD, the unit commitment of each generator is taken into consideration to have adequate margin for reserve at any time. The second issue with ELD is with allocating the total generation to the individual generators {{in such a way}} that the total cost of generation at any time is at a minimum. In this project, the optimum cost of generation problem has been looked into with a distributed slack bus algorithm. In ordinary line flow analysis, the slack bus is asked to carry the entire residual burden of the system. In the proposed method, the burden on slack bus shall be eliminated and still maintain the equal incremental cost criteria. A new concept called Participation factor shall be used to achieve the same as the total loss of the system at the <b>end</b> <b>of</b> <b>iteration</b> shall get divided among all the generator buses. Two distinct bus networks were used as case studies and the results are compared and analysed to verify the usefulness of the proposed technique...|$|E
40|$|In this paper, {{we propose}} a {{computational}} approach {{to solve a}} model-based optimal control problem. Our aim is to obtain the optimal so- lution of the nonlinear optimal control problem. Since the structures of both problems are different, only solving the model-based optimal control problem will not give the optimal solution of the nonlinear optimal control problem. In our approach, the adjusted parameters are added into the model used so as {{the differences between the}} real plant and the model can be measured. On this basis, an expanded optimal control problem is introduced, where sys- tem optimization and parameter estimation are integrated interactively. The Hamiltonian function, which adjoins the cost function, the state equation and the additional constraints, is defined. By applying the calculus of variation, a set of the necessary optimality conditions, which defines modified model-based optimal control problem, parameter estimation problem and computation of modifiers, is then derived. To obtain the optimal solution, the modified model- based optimal control problem is converted in a nonlinear programming prob- lem through the canonical formulation, where the gradient formulation can be made. During the iterative procedure, the control sequences are generated as the admissible control law of the model used, together with the corresponding state sequences. Consequently, the optimal solution is updated repeatedly by the adjusted parameters. At the <b>end</b> <b>of</b> <b>iteration,</b> the converged solution ap- proaches to the correct optimal solution of the original optimal control problem in spite of model-reality differences...|$|E
30|$|By {{allowing}} mutual {{exchange of}} information in the system, new critical points were observed for Random and Neighbor (3). The rate at which stationary state number increased {{was significantly higher than}} without mutual exchange in Neighbor. However, it was much slower in Random in which it rose to maximum of 65 iterations whereas it was as high as 203 without mutual exchange (3). Thus, the time needed for the crowd to converge to a concerted opinion is found to be significantly lower under this configuration for Random type of interaction. The reason for decreased stationary state numbers can be accrued to the following observation. There are 3 categories that a person can belong to during interaction: mavens (credence 6), laypeople (credence 1), or others (credence 2 - 5). Thus, there is a probability associated with a person of interacting with another person from any of these categories. Now, as opinion of maven lie closest to the key and they have highest credence, it is most beneficial to interact with the mavens. When there is mutual {{exchange of information}}, the probability of interaction with a maven increases with increasing number of steps in an iteration since the people once selected as source and target cannot interact again and initially the probability of interaction with layperson is highest. However, if there is no mutual exchange and time of update is concurrent, the probability of interaction with a maven remains constant in an iteration because the credence and opinion values of people are updated only at the <b>end</b> <b>of</b> <b>iteration.</b> On the other hand, if the time of update is sequential and there is no mutual exchange, then the proportion of maven can either increase or decrease within an iteration because the changes in opinion and credence are reflected within the iteration owing to the sequential time of update. Thus, the probability of interaction with maven is flexible in this case. In both the Random and Neighbor, the stationary state number increased until the proportion of maven became 0.05, remained similar until 0.1, and then decreased. The stationary state number became stable when proportion of maven was at least 0.4 and 0.65 in Random and Neighbor respectively. Overall, with the introduction of maven, the group was able to reach a consensus in much fewer number of iterations (compare Figs. 3, 5, and 7 under this configuration). Also, the transition period started early, when proportion of maven was 0.05, to 0.3 and 0.4 for Random and Neighbor respectively (Fig. 8). The Optimization and De-optimization in this configuration were found to be computationally unsolvable and therefore not considered.|$|E
50|$|Larger code size can {{be traded}} for higher program speed when {{applying}} loop unrolling. This technique makes the code longer for each <b>iteration</b> <b>of</b> a loop, but saves the computation {{time required for}} jumping {{back to the beginning}} of the loop at the <b>end</b> <b>of</b> each <b>iteration.</b>|$|R
3000|$|... [*]≤[*]kup[*]is {{the number}} of epochs used at the <b>end</b> <b>of</b> n th <b>iteration,</b> and ϵ[*]is a {{predefined}} threshold.|$|R
50|$|In agile development, retrospectives {{play a very}} {{important}} role in iterative and incremental development. At the <b>end</b> <b>of</b> every <b>iteration</b> a retrospective is held {{to look for ways to}} improve the process for the next iteration. Scrum call this the Sprint Retrospective.|$|R
40|$|The {{topology}} of the Generalized Transportation Problem, at the <b>end</b> <b>of</b> each <b>iteration</b> <b>of</b> the stepping-stone method, {{is characterized}} by a variable number of loops to which are attached multiple branched side chains or trees. An efficient computer representation of this structure and methods for updating it are described in this paper. ...|$|R
50|$|At {{the start}} and <b>end</b> <b>of</b> the algorithm, and {{the start and}} <b>end</b> <b>of</b> each <b>iteration,</b> this {{invariant}} is true: a b + p is the product. This is obviously true when the algorithm starts. When the algorithm terminates, a or b will be zero so p will contain the product.|$|R
40|$|The agile {{software}} development approach makes developing secure software challenging. Existing approaches for extending the agile development process, which enables incremental and iterative {{software development}}, {{fall short of}} providing a method for efficiently ensuring {{the security of the}} software increments produced at the <b>end</b> <b>of</b> each <b>iteration.</b> This article (a) proposes a method for security reassurance of software increments and demonstrates it through a simple case study, (b) integrates security engineering activities into the agile software development process and uses the security reassurance method to ensure producing acceptably secure-by the business owner-software increments at the <b>end</b> <b>of</b> each <b>iteration,</b> and (c) discusses the compliance of the proposed method with the agile values and its ability to produce secure software increments...|$|R
50|$|Most agile {{development}} methods break {{product development}} work into small increments that minimize {{the amount of}} up-front planning and design. Iterations are short time frames (timeboxes) that typically last from one to four weeks. Each iteration involves a cross-functional team working in all functions: planning, analysis, design, coding, unit testing, and acceptance testing. At the <b>end</b> <b>of</b> the <b>iteration</b> a working product is demonstrated to stakeholders. This minimizes overall risk and allows the product to adapt to changes quickly. An iteration might not add enough functionality to warrant a market release, but {{the goal is to}} have an available release (with minimal bugs) at the <b>end</b> <b>of</b> each <b>iteration.</b> Multiple iterations might be required to release a product or new features.|$|R
5000|$|The next keyword jumps {{directly}} to the <b>end</b> <b>of</b> the current <b>iteration</b> <b>of</b> the loop. This usually causes the next <b>iteration</b> <b>of</b> the loop to be started, but the continue block and loop condition are evaluated first.|$|R
50|$|At the <b>end</b> <b>of</b> {{the three}} <b>iterations,</b> most <b>of</b> the {{particles}} are {{converged on the}} actual position of the robot as desired.|$|R
