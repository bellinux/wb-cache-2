4|66|Public
40|$|Dependability is {{a central}} concern {{in the design of}} mission {{critical}} systems. A major design constraint is that the system cannot be brought down for repair during mission times. A number of alternate designs are possible for a given specification. Alternate designs necessitate evaluation. This requires capturing the system specifications and design alternates in the same formalism. In this paper, we propose an extended I/O automata to specify fault tolerant requirements of dependable mission critical systems. The properties of the behaviors of the <b>extended</b> <b>automaton</b> are capable of capturing temporal properties like deadlines. A composition operator is defined for composing the <b>extended</b> <b>automaton.</b> This framework is then used to specify the fire control system of a combat vehicle and demonstrate the usefulness of the proposed framework for capturing fault tolerance aspects in mission critical systems. 1 Introduction The development of mission critical distributed systems with fault-to [...] ...|$|E
40|$|This {{document}} presents theimplementation ofa Student Behavior Predictor Viewer(SBPV) for {{a student}} predictive model. The student predictive model {{is part of an}} intelligent tutoring system, and is built from logs of students’ behaviors in the “Virtual Laboratory of Agroforestry Biotechnology”implemented in a previous work. The SBPVis a tool for visualizing a 2 D graphical representationof the <b>extended</b> <b>automaton</b> associated with any of the clusters ofthe student predictive model. Apart from visualizing the <b>extended</b> <b>automaton,</b> the SBPV supports the navigation across the automaton by means of desktop devices. More precisely, the SBPV allows user to move through the automaton, to zoom in/out the graphic or to locate a given state. In addition, the SBPV also allows user to modify the default layout of the automaton on the screen by changing the position of the states by means of the mouse. To developthe SBPV, a web applicationwas designedand implementedrelying on HTML 5, JavaScript and C#...|$|E
40|$|International audienceDomotic systems aim {{to offer}} {{functionalities}} like energy management, security, conveniences, and much more. Many domotic networks exist {{to provide a}} subset of these applications, but these networks are not necessarily compatible due to different communication mediums or protocols. Literature presents different studies that introduce high-level systems that solve the lack of incompatibility, {{but it does not}} explore how to create a network behavior. This paper concentrates on studying how to model the unit behaviors of home devices and a global behavior of a network of these devices: the automated living area. The global behavior is set-up with rules and constraints. The behaviors are modeled with an <b>extended</b> <b>automaton</b> input-output symbolic transition systems. To finish this paper, a use case shows the interest of building global behavior with unit behaviors...|$|E
50|$|In automata theory, an {{alternating}} tree automaton is {{an extension}} of nondeterministic tree automaton as same as alternating finite <b>automaton</b> <b>extends</b> nondeterministic finite <b>automaton</b> (NFA).|$|R
40|$|ABSTRACT. We {{consider}} {{the construction of}} finite automata from their corresponding regular expressions {{by a series of}} digraph-transformations along the expression’s structure. Each intermediate graph represents an <b>extended</b> finite <b>automaton</b> accepting the same language. The character of our construction allows a fine-grained analysis of the emerging automaton’s size, eventually leading to an optimality result. ...|$|R
40|$|We {{consider}} {{the construction of}} finite automata from their corresponding regular expressions {{by a series of}} digraph-transformations along the expression 2 ̆ 7 s structure. Each intermediate graph represents an <b>extended</b> finite <b>automaton</b> accepting the same language. The character of our construction allows a fine-grained analysis of the emerging automaton 2 ̆ 7 s size, eventually leading to an optimality result...|$|R
40|$|We {{consider}} {{verification of}} safety properties for parameterized systems with linear topologies. A {{process in the}} system is an <b>extended</b> <b>automaton,</b> where the transitions are guarded by both local and global conditions. The global conditions are non-atomic, i. e., a process allows arbitrary interleavings with other transitions while checking the states of all (or some) of the other processes. We translate the problem into model checking of infinite transition systems where each configuration is a labeled finite graph. We derive an overapproximation of the induced transition system, {{which leads to a}} symbolic scheme for analyzing safety properties. We have implemented a prototype and run it on several nontrivial case studies, namely non-atomic versions of Burn’s protocol, Dijkstra’s protocol, the Bakery algorithm, Lamport’s distributed mutual exclusion protocol, and a two-phase commit protocol used for handling transactions in distributed systems. As far as we know, these protocols have not previously been verified in a fully automated framework. ...|$|E
40|$|AbstractIn {{this paper}} we <b>extend</b> the <b>automaton</b> {{synthesis}} paradigm to infinitary languages, that is, to subsets {{of the set}} Σω of all infinite sequences over some alphabet Σ. Our main result is a polynomial algorithm for learning a sub-class of the ω-regular sets from membership queries and counter-examples based on the framework suggested by Angluin (Angluin, D. (1987), Inform. and Comput. 75, 87 - 106) for learning regular subsets of Σ*...|$|R
40|$|Abstract — Some {{discrete}} event {{systems such}} as software are typically infinite state systems, and a commonly used technique for performing formal analysis such as automated verification is based on their finite abstractions. In this paper, we consider a model for reactive untimed infinite state systems called input-output <b>extended</b> finite <b>automaton</b> (I/O-EFA), which is an <b>automaton</b> <b>extended</b> with discrete variables such as inputs, outputs, and data. Using I/O-EFA as a model many valuepassing processes can be represented by finite graphs. We study the problem of finding a finite abstraction that is bisimilar to a given I/O-EFA. We present a sufficient condition under which the underlying transition system of an I/O-EFA admits a finite bisimilar quotient. This sufficient condition is existential as it relies {{on the existence of}} a suitable partition of the state space. We then identify a class of I/O-EFAs for which a partition satisfying our sufficient condition can be constructed by inspecting the structure of the given I/O-EFA...|$|R
40|$|In this paper, we {{extend the}} classic model of timed automata with {{a notion of}} real time tasks. The main idea is to {{associate}} each discrete transition in a timed automaton with a task (an executable program). Intuitively, a discrete transition in an <b>extended</b> timed <b>automaton</b> denotes an event releasing a task and the guard on the transition specifies all the possible arriving times of the event (instead of the so [...] called minimal inter-arrival time). This yields a general model for hard real-time systems in which tasks may be periodic and non-periodic...|$|R
40|$|Abstract. Recent {{studies have}} {{suggested}} the applicability of learning to automated compositional verification. However, current learning algorithms fall short {{when it comes to}} learning liveness properties. We <b>extend</b> the <b>automaton</b> synthesis paradigm for the infinitary languages by presenting an algorithm to learn an arbitrary regular set of infinite sequences (an ω-regular language) over an alphabet Σ. Our main result is an algorithm to learn a nondeterministic Büchi automaton that recognizes an unknown ω-regular language. This is done by learning a unique projection of it on Σ ∗ using the framework suggested by Angluin for learning regular subsets of Σ ∗. ...|$|R
40|$|AbstractThe {{notions of}} an <b>extended</b> pushdown <b>automaton</b> (PDA) and a pushdown {{transducer}} (PDT) are formalized in matrix notation by generalizing {{the concept of}} a pushdown transition matrix. The resulting matrices form a semiring. The equivalence to “nonextended” PDAs and PDTs is shown. The semiring structure gives a new proof that the types reset-pushdown and one-counter are real-time types. Moreover, it allows the construction of the functional composition of a pushdown transduction and a finite transducer mapping. As an important application, Nivat's theorem is generalized to rational and polynomial PDTs over arbitrary semirings. Examples include the mirror image of the input and the Dyck reduction...|$|R
50|$|The {{result of}} step 3 {{is that each}} {{organizational}} unit has for each input command a state-table of ordered production rules, each suitable for execution by an <b>extended</b> finite state <b>automaton</b> (FSA). The sequence of output subcommands required to accomplish the input command is generated by situations (i.e., branching conditions) that cause the FSA to transition from one output subcommand to the next.|$|R
5000|$|A {{continuous}} automaton can {{be described}} as a cellular <b>automaton</b> <b>extended</b> so the valid states a cell can take are not just discrete (for example, the states consist of integers between 0 and 3), but continuous, for example, the real number range 0,1. The cells however remain discretely separated from each other. One example is called computational verb cellular network (CVCN) ...|$|R
40|$|Despite of the {{simplicity}} of their construction, cellular automata are capable of very complicated behavior with very little specification. The present paper introduces an algorithmic music system incorporating a voting rule type <b>automaton</b> <b>extended</b> with energy profiles and an elaborate mapping algorithm. One core design principle is the fusion of generative, implicit behavior with explicit user designed symbolic processes, in particular, facing the mapping task. 1...|$|R
40|$|Most modern radio systems use {{digital signal}} processing. To debug {{algorithms}} of digital signal processing, most often is used simulation modelling, {{which has a}} number of significant drawbacks, since most modern programmes that generate random sequences of numbers begin to repeat previously obtained combinations of values with a large number of measurements. In addition, simulation modelling does not allow us to obtain very small probabilities of detector states. Consequently, the problem of mathematical modelling of digital devices remains relevant. Therefore, to study the operation of digital detectors when there are correlated input effects there is an article’s proposal to apply a probabilistic simulation method, using the Markov chain apparatus, based on a recurrent procedure and a concept of the <b>extended</b> digital <b>automaton.</b> The simulation modelling to debug digital detector operation is as follows: a generated correlated signal comes to the threshold device to give at the output a sequence of binary signals arriving at the counter. Since in real conditions a digital detector has to have high accuracy, an error emerges when debugging based on simulation modelling. The article shows that with a probabilistic modelling method it is necessary to use the multidimensional Markov chains and the <b>extended</b> digital <b>automaton</b> to reach the higher accuracy. The article also compares the results obtained by various types of mathematical modelling to analyse the effect of the input signal correlation on the probability of detector false response. The analysis has shown that probabilistic modelling in debugging the digital detector operation with a correlated input signal of high accuracy corresponds to the simulation model with the same specified parameters. With increasing input signal correlation there is a significantly raising probability of false response. Thus, {{it is fair to say}} that Markov chains-based probabilistic simulation can be used to study operation of radar signal processors. </p...|$|R
40|$|Abstract. This reportdeals {{with global}} {{constraints}} {{for which the}} set of solutions can be recognized by an <b>extended</b> finite <b>automaton</b> whose size is bounded by a polynomial in ¦, where ¦ {{is the number of}} variables of the corresponding global constraint. By reformulating the automaton as a conjunction of signature and transition constraints we show how to systematically obtain a filtering algorithm. Under some restrictions on the signature and transition constraints this filtering algorithm achieves arc-consistency. An implementation based on some constraints {{as well as on the}} metaprogramming facilities of SICStus Prolog is available. For a restricted class of automata we provide a filtering algorithm for the relaxed case, where the violation cost is the minimum number of variables to unassign in order to get back to a solution. Keywords: Constraint Programming...|$|R
50|$|In {{computer}} science and automata theory, a Büchi automaton {{is a type}} of ω-automaton, which <b>extends</b> a finite <b>automaton</b> to infinite inputs. It accepts an infinite input sequence if there exists a run of the automaton that visits (at least) one of the final states infinitely often. Büchi automata recognize the omega-regular languages, the infinite word version of regular languages. It is named after the Swiss mathematician Julius Richard Büchi who invented this kind of automaton in 1962.|$|R
40|$|AbstractThe {{precision}} of right-hand context covering for conflict resolution is improved over previous NDR parsers, resulting in acceptation of wider subsets of LR-regular and LR-nonregular grammars, including all LALR(k) grammars {{for a given}} k. Parser generation combines {{a new form of}} DR items and subgraph connections of bounded length, without the need to implement subgraph copies. The NDR parser, whose algorithm remains essentially unchanged, is presented as an <b>extended</b> two-stack pushdown <b>automaton.</b> The technique is illustrated with a detailed example...|$|R
50|$|In automata theory, a timed {{automaton}} is {{a finite}} <b>automaton</b> <b>extended</b> with a finite set of real-valued clocks. During {{a run of}} a timed automaton, clock values increase all with the same speed. Along the transitions of the automaton, clock values {{can be compared to}} integers. These comparisons form guards that may enable or disable transitions and by doing so constrain the possible behaviors of the automaton. Further, clocks can be reset. Timed automata are a sub-class of a type hybrid automata.|$|R
40|$|We {{present a}} new, {{on-the-fly}} algorithm that given a push-down model representing a sequential program with (recursive) procedure calls and an <b>extended</b> finite-state <b>automaton</b> representing (the negation of) a safety property, produces a succinct, symbolic representation of all counter-examples; i. e., traces of system behaviors that violate the property. The class {{of what we}} call minimumrecursion loop-free counter-examples can then be generated from this representation on an as-neededbasis and presented to the user. Our algorithm is also applicable, without modification, to finite-state system models. Simultaneous consideration of multiple counter-examples can minimize the number of model-checking runs needed to recognize common root causes of property violations. We illustrate the use of our techniques via application to a Java-Tar utility and an FTPserver program, and discuss a prototype tool implementation which offers several abstraction techniques for easy-viewing of generated counter-examples...|$|R
40|$|Models {{of areas}} of physics {{in terms of}} {{cellular}} automata have become increasingly popular. Cellular automata (CAs) support the modeling of systems with discrete state component values and enforce the comprehensive specification of the dynamic evolution of such systems. Because many areas of physics can be described by starting with a specific Lagrangian, the idea to derive a cellular automaton directly from the Lagrangian (or similar construct, such as the Hamiltonian or action) is not new. Previous work, however, indicated that the classical CA {{may not be a}} sufficient basis for the modeling of more advanced physics theories, such as quantum field theory. Specifically, the modeling of interactions in quantum field theory requires extensions and modifications of the classical CA. This paper describes a proposal for an <b>extended</b> cellular <b>automaton</b> that is suited for support of quantum field theory...|$|R
40|$|Abstract. We {{investigate}} {{the problem of}} locally monitoring contract regulated behaviours in agentbased web services. We encode contract clauses in service specifications by using extended timed automata. We propose a non intrusive local monitoring framework along with an API to monitor the fulfillment (or violation) of contractual obligations. A key feature of the framework {{is that it is}} fully symbolic thereby providing a scalable solution to monitoring. At runtime execution steps generated by the service are passed as input to the runtime monitor. Conformance of the execution against the service specification is checked using a symbolically represented <b>extended</b> timed <b>automaton.</b> This allows us to monitor service behaviours over large state spaces generated by multiple, long running contracts. We illustrate our methodology by monitoring a service composition scenario from the vehicle repair domain, and report on the experimental results. 1...|$|R
40|$|Abstract. We {{present a}} new, {{on-the-fly}} algorithm that given a push-down model representing a sequential program with (recursive) procedure calls and an <b>extended</b> finite-state <b>automaton</b> representing (the negation of) a safety property, produces a succinct, symbolic representation of all counter-examples; i. e., traces of system behaviors that violate the property. The class {{of what we}} call minimumrecursion loop-free counter-examples can then be generated from this representation on an as-needed basis and presented to the user. Our algorithm is also applicable, without modification, to finite-state system models. Simultaneous consideration of multiple counter-examples can minimize the number of model-checking runs needed to recognize common root causes of property violations. We illustrate the use of our techniques via application to a Java-Tar utility and an FTPserver program, and discuss a prototype tool implementation which offers several abstraction techniques for easy-viewing of generated counter-examples. ...|$|R
40|$|AbstractIn {{this paper}} {{the notion of}} a {{quadratic}} automaton transformation is defined and studied. The automata considered transform infinite input sequences of elements from a finite commutative ring with identity to infinite output sequences. Results <b>extending</b> the linear <b>automaton</b> transformation theory of A. Nerode are derived and two distinct approaches to machine realization arise depending upon whether 2 is invertible in the base ring or not. Such a naturally occurring quadratic map as the AND function of elementary switching theory is easily realized in this setting...|$|R
40|$|Dynamically {{reconfigurable}} {{systems have}} attracted public {{attention from the}} point of view of miniaturization and saving power consumption for embedded systems in recent years. In this study, we propose dynamic linear hybrid automata as specification language of dynamically reconfigurable systems and the verification technique of reachability analysis. A dynamic linear hybrid automaton(DLHA) is a linear hybrid <b>automaton</b> <b>extended</b> with actions of creation and destruction. This paper presents the model checker and applies it to the model of an embedded system consisting CPU and DRP. © 2013 IEEE...|$|R
40|$|Aiming {{to solve}} the {{problems}} of high memory access and big storage space and long matching time in the regular expres-sion matching of <b>extended</b> finite <b>automaton</b> (XFA), a new regular expression matching algorithm based on high-efficient finite automaton is presented in this paper. The basic idea of the new algorithm is that some extra judging instruments are added at the starting state in order to reduce any unnecessary transition paths as well as to eliminate any unnecessary state transitions. Consequently, the problems of high memory access consumption and big storage space and long match-ing time during the regular expression matching process of XFA can be efficiently improved. The simulation results con-vey that our proposed scheme can lower approximately 40 % memory access, save about 45 % storage space consumption, and reduce about 12 % matching time during the same regular expression matching process compared with XFA, but without degrading the matching quality...|$|R
40|$|Automata play {{important}} roles in wide area of computing {{and the growth of}} multicores calls for their efficient parallel implementation. Though it is known in theory that we can perform the computation of a finite automaton in parallel by simulating transitions, its implementation has a large overhead due to the simulation. In this paper we propose a new automaton called simultaneous finite automaton (SFA) for efficient parallel computation of an automaton. The key idea is to <b>extend</b> an <b>automaton</b> so that it involves the simulation of transitions. Since an SFA itself has a good property of parallelism, we can develop easily a parallel implementation without overheads. We have implemented a regular expression matcher based on SFA, and it has achieved over 10 -times speedups on an environment with dual hexa-core CPUs in a typical case. Comment: This paper has been accepted at the following conference: 2013 International Conference on Parallel Processing (ICPP- 2013), October 1 - 4, 2013 Ecole Normale Suprieure de Lyon, Lyon, Franc...|$|R
40|$|In this paper, we {{extend the}} classic model of timed automata with {{a notion of}} real time tasks. The main idea is to {{associate}} each discrete transition in a timed automaton with a task (an executable program). Intuitively, a discrete transition in an <b>extended</b> timed <b>automaton</b> denotes an event releasing a task and the guard on the transition species all the possible arriving times of the event (instead of the so{called minimal inter-arrival time). This yields a general model for hard real-time systems in which tasks are non-periodic. We show that the schedulability problem for the extended model can be transformed to a reachability problem for timed automata and thus it is decidable. This allows us to apply model-checking tools for timed automata to schedulability analysis for event-driven systems. In addition, {{based on the same}} model of a system, we may use the tools to verify other properties (e. g. safety and functionality) of the system. This unies schedulability analysis [...] ...|$|R
40|$|In {{this paper}} we <b>extend</b> the <b>automaton</b> {{synthesis}} paradigm to infinitary languages, that is, to subsets {{of the set}} Σ ! of all infinite sequences over some alphabet Σ. Our main result is a polynomial algorithm for learning a sub-class of the !-regular sets from membership queries and counter-examples based on the framework suggested by Angluin (Angluin, D., 1987, Information and Computation 75) for learning regular subsets of Σ. 1 Introduction 1. 1 Motivation The problem of sequence generalization {{is one of the}} fundamental problems in learning theory. Its automata-theoretic instance consists of the synthesis of a finite-state automaton whose behavior is compatible with a given sample of sequences over some alphabet (e. g., [Moore (1956) ], [Trakhtenbrot and Barzdin (1973) ], [Gold (1972) ], [Biermann and Feldman (1972) ], [Angluin (1987) ], [Pitt (1989) ]). Within this framework some aspects of real problems of learning from experience can be modeled quite naturally. One [...] ...|$|R
40|$|In {{order to}} develop a {{manufacturing}} automation system, {{it is necessary to}} understand the manufacturing operations and their relationship, the sequence of operations, which is the basis for control logic design. The operations have preconditions that define when they are allowed to start executing, which also defines the sequence relations among them. Requirements and demands throughout the development will add and change these conditions, which also changes the sequence of operations. This paper studies how an operation-oriented development approach better can handle the operations and manufacturing sequences from early product design to detailed control engineering. An operation is defined by an <b>extended</b> finite <b>automaton,</b> with an initial, executes and finished location. The start event is enabled by a precondition, the stop event is enabled by a postcondition and the reset event is enabled by a reset condition. This representation together with a resource and product description enables the possibility to integrate control logic in the complete development process...|$|R
40|$|This paper {{presents}} an automatic method for calculating the path condition for programs with real time constraints. We model concurrent systems using timed transition systems and translate them into extended timed automata. Then an acyclic <b>extended</b> timed <b>automaton</b> is constructed {{and the path}} condition is calculated backwards over it. This method {{can be used for}} the semiautomatic verification of a unit of code in isolation, i. e., without providing the exact values of parameters with which it is called. It can also be used for test case generation for real-time systems. Such a symbolic model checking algorithm was implemented previous in the PET system [10] for untimed systems. Our method can also be used for the automatic generation of test cases for unit testing. The current generalization of the calculation of path condition for the timed case turns out to be quite tricky, since not only the selected path contributes to the path condition, but also the timing constraints of alternative choices in the code...|$|R
40|$|The use of {{derivatives}} for efficiently deciding equivalence {{and membership}} in regular languages {{has been a}} major topic of recent research. To ensure termination, regular expressions must be considered modulo some algebraic properties such as associativity, commutativity, and idempotence of union (ACI). In this paper we describe an implemen-tation of regular expressions modulo ACI and several derivative based methods within the FAdo system. Although regular languages are trivially closed for boolean operations, the manipulation of intersection and complementation with regular expressions or non-deterministic finite automata is non trivial and leads to an exponential blow up. However, due to several applications where extended regular expressions (XRE) are used to rep-resent information, it is important the extension of derivative based methods to those operations. Continuing work of Caron et al., we present new algorithms for computing the (<b>extended)</b> equation <b>automaton</b> and deciding membership and equivalence of XRE using (partial) derivatives. 1 Extended Regular Expressions and Kleene Algebr...|$|R
40|$|In this paper, {{we propose}} a {{high-level}} state-based dependency description and structuring formalism for flexible manufacturing systems (FMS). This <b>extended</b> cellular <b>automaton</b> model (ECAM) {{is designed to}} capture the behaviour and performance of a large complex concurrent system in an easier and more concise way than is possible with other contemporary FMS models. Concurrency problems of FMS can be clearly identified by the model. The model is defined mathematically as a quintuple by adapting the cellular automaton. A set of graphical symbols is also defined to represent {{the states of the}} model. The proposed model can serve as a formal specification and documentation tool for an FMS. It can also provide a basis for modelling important characteristics of FMS which includes conflict resolution, dependencies and starvation of resources. In real applications, it can serve as a conceptual model in the FMS design process. Based on this model, a prototype system has been developed to generate a set of executable grammar rules. With appropriate extensions, the system can be used as simulation and performance analysis tools...|$|R
5000|$|Step 3 {{specifies}} {{the processing}} that is triggered within each unit upon receipt of an input command. For each input command, a state-graph (or statetable or <b>extended</b> finite state <b>automaton)</b> is defined {{that provides a}} plan (or procedure for making a plan) for accomplishing the commanded task. The input command selects (or causes to be generated) an appropriate state-table, the execution of which generates a series of output commands to units at the next lower echelon. The library of state-tables contains a set of statesensitive procedural rules that identify all the task branching conditions and specify the corresponding state transition and output command parameters.|$|R
40|$|International audienceIn this paper, we {{describe}} a methodology integrating verification and conformance testing. A specification of a system— an <b>extended</b> input-output <b>automaton,</b> {{which may be}} infinite-state—and a set of safety properties (“nothing bad ever happens”) and possibility properties (“something good may happen”) are assumed. The properties are first tentatively verified on the specification using automatic techniques based on approximated state-space exploration, which are sound, but, as {{a price to pay}} for automation, are not complete for the given class of properties. Because of this incompleteness and of state-space explosion, the verification may not succeed in proving or disproving the properties. However, even if verification did not succeed, the testing phase can proceed and provide useful information about the implementation. Test cases are automatically and symbolically generated from the specification and the properties and are executed on a black-box implementation of the system. The test execution may detect violations of conformance between implementation and specification; in addition, it may detect violation/satisfaction of the properties by the implementation and by the specification. In this sense, testing completes verification. The approach is illustrated on simple examples and on a Bounded Retransmission Protocol...|$|R
