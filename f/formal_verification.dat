4606|827|Public
25|$|Practical {{applications}} of Graph Automorphism include graph drawing and other visualization tasks, solving structured instances of Boolean Satisfiability arising {{in the context}} of <b>Formal</b> <b>verification</b> and Logistics. Molecular symmetry can predict or explain chemical properties.|$|E
25|$|The {{alternative}} is formal software verification, which uses mathematical proof techniques {{to show the}} absence of bugs. Researchers at NICTA and its spinout Open Kernel Labs have recently performed such a <b>formal</b> <b>verification</b> of , {{a member of the}} L4 microkernel family, proving functional correctness of the C implementation of the kernel.|$|E
25|$|In {{the field}} of {{verification}} and design of timed and hybrid systems, the system behaviour is called Zeno if it includes {{an infinite number of}} discrete steps in a finite amount of time. Some <b>formal</b> <b>verification</b> techniques exclude these behaviours from analysis, if they are not equivalent to non-Zeno behaviour.|$|E
50|$|<b>Formal</b> <b>verifications</b> in {{computer}} science will not play the same key role as proofs do in mathematics.|$|R
50|$|IsarMathLib, {{a library}} for the Isabelle theorem prover, has <b>formal</b> <b>verifications</b> {{of a few}} {{fundamental}} results on commutative ordered rings. The results are proved in the ring1 context.|$|R
30|$|Since EVALPSN/bf-EVALPSN {{itself is}} {{basically}} not a specific tool of <b>formal</b> safety <b>verification,</b> it includes complicated and redundant expressions to construct safety verification systems. Therefore, {{it should be}} better to develop safety verification-oriented tool or programming language based on EVALPSN/bf-EVALPSN if EVALPSN/bf-EVALPSN {{can be applied to}} <b>formal</b> safety <b>verification.</b>|$|R
25|$|Logic is {{the study}} of the {{principles}} of valid reasoning and inference, as well as of consistency, soundness, and completeness. For example, in most systems of logic (but not in intuitionistic logic) Peirce's law (((P→Q)→P)→P) is a theorem. For classical logic, it can be easily verified with a truth table. The study of mathematical proof is particularly important in logic, and has applications to automated theorem proving and <b>formal</b> <b>verification</b> of software.|$|E
25|$|Due to the {{aforementioned}} {{need to apply}} costly techniques such as <b>formal</b> <b>verification</b> or manual review, {{the size of the}} TCB has immediate consequences on the economics of the TCB assurance process, and the trustworthiness of the resulting product (in terms of the mathematical expectation of the number of bugs not found during the verification or review). In order to reduce costs and security risks, the TCB should therefore be kept as small as possible. This is a key argument in the debate preferring microkernels to monolithic kernels.|$|E
25|$|Synopsys, Inc., an American company, is {{the leading}} company by sales in the Electronic Design Automation industry. Synopsys' first and best-known product is Design Compiler, a logic-synthesis tool. Synopsys offers {{a wide range of}} other {{products}} used in the design of an application-specific integrated circuit. Products include logic synthesis, behavioral synthesis, place and route, static timing analysis, <b>formal</b> <b>verification,</b> hardware description language (SystemC, SystemVerilog/Verilog, VHDL) simulators as well as transistor-level circuit simulation. The simulators include development and debugging environments which assist {{in the design of the}} logic for chips and computer systems.|$|E
5000|$|International Symposium On Leveraging Applications of <b>Formal</b> Methods, <b>Verification</b> and Validation (ISoLA) ...|$|R
50|$|In {{functional}} programming, {{side effects}} are rarely used. The lack {{of side effects}} {{makes it easier to}} do <b>formal</b> <b>verifications</b> of a program. Functional languages such as Standard ML, Scheme and Scala do not restrict side effects, but it is customary for programmers to avoid them. The functional language Haskell expresses side effects such as I/O and other stateful computations using monadic actions.|$|R
5000|$|A {{comparison}} of tools for teaching <b>formal</b> software <b>verification.</b> Ingo Feinerer and Gernot Salzer. Springer, 2008 ...|$|R
25|$|From the 1970s, Dijkstra's chief {{interest}} was <b>formal</b> <b>verification.</b> In 1976 Dijkstra published a seminal book, A Discipline of Programming, which put forward his method of systematic development of programs {{together with their}} correctness proofs. In his exposition he used his 'Guarded Command Language'. The language, with its reliance on non-determinism, the adopted weakest precondition semantics and the proposed development method has had a considerable impact on the field to this day. The refinement calculus, originally proposed by Ralph-Johan Back and developed by Carroll Morgan, {{is an extension of}} Dijkstra's weakest precondition calculus, where program statements are modeled as predicate transformers.|$|E
25|$|The need {{to break}} German codes in World War II led to {{advances}} in cryptography and theoretical computer science, with the first programmable digital electronic computer being developed at England's Bletchley Park with the guidance of Alan Turing and his seminal work, On Computable Numbers. At the same time, military requirements motivated advances in operations research. The Cold War meant that cryptography remained important, with fundamental advances such as public-key cryptography being developed in the following decades. Operations research remained important as a tool in business and project management, with the critical path method being developed in the 1950s. The telecommunication industry has also motivated advances in discrete mathematics, particularly in graph theory and information theory. <b>Formal</b> <b>verification</b> of statements in logic has been necessary for software development of safety-critical systems, and advances in automated theorem proving have been driven by this need.|$|E
2500|$|Automated theorem provers {{are also}} used to {{implement}} <b>formal</b> <b>verification</b> in computer science. [...] In this setting, theorem provers are used to verify the correctness of programs and of hardware such as processors {{with respect to a}} formal specification. Because such analysis is time-consuming and thus expensive, it is usually reserved for projects in which a malfunction would have grave human or financial consequences.|$|E
5000|$|Automated {{correctness}} debugging {{of parallel}} and distributed programs including specification, <b>formal</b> modelling, <b>verification,</b> replay/active control, and execution visualisation techniques.|$|R
40|$|Abstract. We {{describe}} {{the structure of}} abstract domains in Astrée, their modular organization into a hierarchical network, their cooperation to over-approximate the conjunction/reduced product of different abstractions, and to ensure termination using collaborative widenings and narrowings. This separation of the abstraction into a combination of cooperative abstract domains makes Astrée extensible, an essential feature to cope with false alarms and ultimately provide sound <b>formal</b> <b>verifications</b> {{of the absence of}} runtime errors in very large software. ...|$|R
40|$|International audienceThe {{formalism}} of Hybrid Functional Petri Nets (HFPN) {{has proved}} its convenience for simulating biological systems. The drawback of the noticeable expressiveness of HFPN is the difficulty to perform <b>formal</b> <b>verifications</b> of dynamical properties. In this article, we propose a model-checking procedure for Timed Hybrid Petri Nets (THPN), a sub-class of HFPN. This procedure {{is based on}} the translation of the THPN model and of the studied property into real-time automata. It is applied to a sub-network involved in amphibian metamorphosis...|$|R
2500|$|At {{the height}} of its success, and largely {{inspired}} by the Japanese Fifth Generation Computer program, the company established the [...] "MetaLab" [...] research centre at Milton Hall near Cambridge, in order to pursue artificial intelligence, wafer-scale integration, <b>formal</b> <b>verification</b> and other advanced projects. A combination of {{the failures of the}} Sinclair QL computer and the TV80 led to financial difficulties in 1985, and a year later Sinclair sold the rights to its computer products and brand name to Amstrad. [...] Sinclair Research Ltd still exists as a one-man company, continuing to market Clive Sinclair's inventions.|$|E
2500|$|In the 1930s, while {{studying}} switching circuits, Claude Shannon observed {{that one could}} also apply the rules of Boole's algebra in this setting, and he introduced switching algebra {{as a way to}} analyze and design circuits by algebraic means in terms of logic gates. Shannon already had at his disposal the abstract mathematical apparatus, thus he cast his switching algebra as the two-element Boolean algebra. In circuit engineering settings today, there is little need to consider other Boolean algebras, thus [...] "switching algebra" [...] and [...] "Boolean algebra" [...] are often used interchangeably. Efficient implementation of Boolean functions is a fundamental problem in the design of combinational logic circuits. Modern electronic design automation tools for VLSI circuits often rely on an efficient representation of Boolean functions known as (reduced ordered) binary decision diagrams (BDD) for logic synthesis and <b>formal</b> <b>verification.</b>|$|E
5000|$|Important {{publications}} in <b>formal</b> <b>verification</b> (including {{the use of}} temporal logic in <b>formal</b> <b>verification)</b> ...|$|E
40|$|This thesis {{considers}} {{the challenge of}} fully <b>formal</b> software <b>verification</b> in the demanding and foundational context of mechanical proof assistants. While this approach offers the strongest guarantees for software correctness, it has traditionally imposed tremendous costs to manually construct proofs. In this work, I explore techniques to mitigate this proof burden through careful system design. In particular, I demonstrate how <b>formal</b> shim <b>verification</b> and extensible compiler techniques can radically reduce the proof burden for realistic implementations of critical modern infrastructur...|$|R
40|$|The {{formalism}} of Hybrid Functional Petri Nets (HFPN) {{has proved}} its convenience for simulating biological systems. The drawback of the noticeable expressiveness of HFPN is the difficulty to perform <b>formal</b> <b>verifications</b> of dynamical properties. In this article, we propose a model-checking procedure for Timed Hybrid Petri Nets (THPN), a sub-class of HFPN. This procedure {{is based on}} the translation of the THPN model and of the studied property into real-time automata. It is applied to model enzymatic competitions existing in amphibian metamorphosis...|$|R
40|$|This paper {{describes}} some formal {{tools to}} support distributed cooperative software engineering. Workers at different sites can collaborate on tasks including specification, refinement, proving and documentation. A design record database supports alternative and incomplete development activities, and is read using any web browser; remote proof execution, animation, and informal explanation are supported, and results are broadcast by a protocol that resolves inconsistencies while updating local databases. The Kumo tool generates project websites and assists with <b>formal</b> <b>verifications.</b> Some experiments with these tools are reported...|$|R
50|$|The {{growth in}} {{complexity}} of designs increases {{the importance of}} <b>formal</b> <b>verification</b> techniques in the hardware industry. At present, <b>formal</b> <b>verification</b> is used by most or all leading hardware companies, but its use in the software industry is still languishing. This {{could be attributed to}} the greater need in the hardware industry, where errors have greater commercial significance. Because of the potential subtle interactions between components, it is increasingly difficult to exercise a realistic set of possibilities by simulation. Important aspects of hardware design are amenable to automated proof methods, making <b>formal</b> <b>verification</b> easier to introduce and more productive.|$|E
5000|$|A direct {{connection}} to the Polychrony services (compilation, <b>formal</b> <b>verification,</b> etc.).|$|E
5000|$|Research {{projects}} and tools used for <b>formal</b> <b>verification</b> of security protocols: ...|$|E
5000|$|Formal specification, <b>formal</b> design, validation, <b>verification,</b> testing ...|$|R
40|$|We {{propose a}} {{two-stage}} approach {{for the design}} of a shared virtual memory. The first stage is a high-level protocol description using the Structured Gamma formalism which is amenable to <b>formal</b> <b>verifications.</b> The second is a translation of this abstraction into an automaton which can be dynamically loaded in a runtime environment that provides a concept of global directory. This translation is based on Aspect-Oriented Programming which makes it possible to specify independently different aspects of the implementation. The complete system can thus be easily ported on a new environment...|$|R
5000|$|<b>Formal</b> {{design and}} <b>verification</b> {{techniques}} including a formal top-level specification ...|$|R
5000|$|Avery Design Systems: SimCluster (for {{parallel}} logic simulation) and Insight (for <b>formal</b> <b>verification)</b> ...|$|E
5000|$|The Mizar {{system and}} Metamath use Tarski-Grothendieck set theory for <b>formal</b> <b>verification</b> of proofs.|$|E
50|$|His {{research}} interests include models for concurrent and distributed systems, <b>formal</b> <b>verification</b> and distributed algorithms.|$|E
5000|$|Validation and <b>Verification</b> <b>Formal</b> {{analysis}} for hardware & Sw validation.|$|R
50|$|Jason Baumgartner {{from the}} IBM Corporation, Austin, TX was named Fellow of the Institute of Electrical and Electronics Engineers (IEEE) in 2015 for {{contributions}} to <b>formal</b> hardware <b>verification</b> its and application.|$|R
40|$|International audienceDistributed {{systems are}} hard to design, and formal methods help to find bugs early. Yet, there may still remain a {{semantic}} gap between a formal model and the actual distributed implementation, which is generally hand-written. Automated generation of distributed implementations requires an elaborate multiway synchronization protocol. In this paper, we explore how to verify correctness of such protocols. We generate formal models, written in the LNT language, of synchronization scenarios for three protocols and we use the CADP toolbox for automated <b>formal</b> <b>verifications.</b> We expose a bug leading to a deadlock in one protocol, and we discuss protocol extensions...|$|R
