347|576|Public
2500|$|For most {{practical}} applications, {{as well as}} for applications that require non-monotonic reasoning in artificial intelligence, <b>Horn</b> <b>clause</b> logic programs need to be extended to normal logic programs, with negative conditions. A clause in a normal logic program has the form: ...|$|E
2500|$|Constraint logic {{programming}} combines <b>Horn</b> <b>clause</b> {{logic programming}} with constraint solving. It extends Horn clauses by allowing some predicates, declared as constraint predicates, to occur as literals {{in the body}} of clauses. A constraint logic program is a set of clauses of the form: ...|$|E
2500|$|Basing logic {{programming}} within linear logic {{has resulted in}} the design of {{logic programming}} languages that are considerably more expressive than those based on classical logic. [...] <b>Horn</b> <b>clause</b> programs can only represent state change by the change in arguments to predicates. [...] In linear logic programming, one can use the ambient linear logic to support state change. [...] Some early designs of logic programming languages based on linear logic include LO , Lolli, ACL, and Forum [...] [...] Forum provides a goal-directed interpretation of all of linear logic.|$|E
50|$|Propositional <b>Horn</b> <b>clauses</b> {{are also}} of {{interest}} in computational complexity. The problem of finding truth value assignments to make a conjunction of propositional <b>Horn</b> <b>clauses</b> true is a P-complete problem, solvable in linear time, and sometimes called HORNSAT. (The unrestricted Boolean satisfiability problem is an NP-complete problem however.) Satisfiability of first-order <b>Horn</b> <b>clauses</b> is undecidable.|$|R
40|$|Abstract. In {{the present}} paper we use the {{approach}} ofheight functions to de ning a semi-distance measure between <b>Horn</b> <b>clauses.</b> This appraoch is already discussed elsewhere {{in the framework of}} propositional and simple rst order languages (atoms). Hereafter we prove its applicability for <b>Horn</b> <b>clauses.</b> We use some basic results from lattice theory and introduce a family of language independent coverage-based height functions. Then we show how these results apply to <b>Horn</b> <b>clauses.</b> We also show anexample of conceptual clustering of rst order atoms, where the hypotheses are <b>Horn</b> <b>clauses.</b> ...|$|R
50|$|In formal logic, Horn-satisfiability, or HORNSAT, is {{the problem}} of {{deciding}} whether a given set of propositional <b>Horn</b> <b>clauses</b> is satisfiable or not. Horn-satisfiability and <b>Horn</b> <b>clauses</b> are named after Alfred Horn.|$|R
5000|$|A <b>Horn</b> <b>clause</b> with {{exactly one}} {{positive}} literal {{is a definite}} clause; a definite clause with no negative literals is sometimes called a fact; and a <b>Horn</b> <b>clause</b> without a positive literal is sometimes called a goal clause (note that the empty clause consisting of no literals is a goal clause). These three kinds of Horn clauses are illustrated in the following propositional example: ...|$|E
5000|$|A <b>Horn</b> <b>clause</b> is {{a clause}} (a {{disjunction}} of literals) with at most one positive, i.e. unnegated, literal.|$|E
5000|$|In logic {{programming}} a definite clause behaves as a goal-reduction procedure. For example, the <b>Horn</b> <b>clause</b> written above behaves as the procedure: ...|$|E
40|$|This paper {{presents}} two fast algorithms {{for testing}} the unsatisfiability {{of a set}} of ground <b>Horn</b> <b>clauses</b> with or without equational atomic formulae. If the length of the set H of <b>Horn</b> <b>clauses</b> (viewed as the string obtained by concatenating the clauses in H) is n, it is possible to design an algorithm running in time O(n log(n)). These algorithms are obtained by generalising the concept of congruence closure to ground <b>Horn</b> <b>clauses.</b> The basic idea behind these algorithms is that the congruence closure induced by a set of ground <b>Horn</b> <b>clauses</b> can be obtained by interleaving steps in which an equational congruence closure is computed, and steps in which an implicational type of closure is computed...|$|R
40|$|Most logic {{programming}} languages have the first-order, classical theory of <b>Horn</b> <b>clauses</b> as their logical foundation. Purely proof-theoretical considerations show that <b>Horn</b> <b>clauses</b> are not {{rich enough to}} naturally provide the abstraction mechanisms that are common in most modern, general purpose programming languages. For example, <b>Horn</b> <b>clauses</b> do not incorporate the important software abstraction mechanisms of modules, data type abstractions, and higher-order programming. As {{a result of this}} lack, implementers of {{logic programming}} languages based on <b>Horn</b> <b>clauses</b> generally add several nonlogical primitives on top of <b>Horn</b> <b>clauses</b> to provide these missing abstraction mechanisms. Although the missing features are often captured in this fashion, formal semantics of the resulting languages are often lacking or are very complex. Another approach to providing these missing features is to enrich the underlying logical foundation of logic programming. This latter approach to providing logic programs with these missing abstraction mechanisms is taken in this paper. The enrichments we will consider have simple and direct operational and proof theoretical semantics...|$|R
40|$|Abstract The Little-Hopfield {{neural network}} {{programmed}} with <b>Horn</b> <b>clauses</b> is stud-ied. We {{argue that the}} energy landscape of the system, corresponding to the incon-sistency function for logical interpretations of the sets of <b>Horn</b> <b>clauses,</b> has minimal ruggedness. This is supported by computer simulations...|$|R
5000|$|Some programmers {{call the}} cut a {{controversial}} control facility [...] {{because it was}} added for efficiency reasons only {{and is not a}} <b>Horn</b> <b>clause.</b>|$|E
5000|$|The first {{concurrent}} {{logic programming}} language was the Relational Language of Clark and Gregory, {{which was an}} offshoot of IC-Prolog. Later versions of concurrent logic programming include Shapiro's Concurrent Prolog and Ueda's Guarded <b>Horn</b> <b>Clause</b> language [...]|$|E
5000|$|For most {{practical}} applications, {{as well as}} for applications that require non-monotonic reasoning in artificial intelligence, <b>Horn</b> <b>clause</b> logic programs need to be extended to normal logic programs, with negative conditions. A clause in a normal logic program has the form: ...|$|E
40|$|Given {{a family}} of <b>Horn</b> <b>clauses,</b> what is the minimal number of <b>Horn</b> <b>clauses</b> {{implying}} all other clauses in the family? What is the maximal number of <b>Horn</b> <b>clauses</b> from the family without having resolvents of a certain kind? We consider various problems of this type, and give some sharp bounds. We also consider {{the probability that a}} random family of a given size implies all other clauses in the family, and we prove the existence of a sharp threshold. ...|$|R
40|$|AbstractThis paper {{presents}} complexity results {{about the}} satisfiability of modal <b>Horn</b> <b>clauses</b> for several modal propositional logics. Almost all {{these results are}} negative {{in the sense that}} restricting the input formula to modal <b>Horn</b> <b>clauses</b> does not decrease the inherent complexity of the satisfiability problem. We first show that, when restricted to modal <b>Horn</b> <b>clauses,</b> the satisfiability problem for any modal logic clauses as well as the satisfiability of unrestricted formulas for any of K, T, B, ans S 4 is PSPACE-complete. This result refutes the expectation (Fariñas del Cerro and Penttonen 1987) of getting a polynomial-time algorithm for the satisfiability of modal <b>Horn</b> <b>clauses</b> for these logics as long as P ≠ PSPACE. Next, we consider S 4. 3 and extensions of K 5 including K 5, KD 5, K 45, KD 45 and S 5, the satisfiability problem for each of which in general is known to be NP-complete, and show that for each extension of K 5, a polynomial-time algorithm for the satisfiability of modal <b>Horn</b> <b>clauses</b> can be obtained; but for S 4. 3, together with some linear tense logics closely related to S 4. 3 like Cl, SL and PL, the satisfiability of modal <b>Horn</b> <b>clauses</b> still remains NP-complete...|$|R
40|$|Abstract. We {{present a}} generic {{algorithm}} for solving <b>Horn</b> <b>clauses</b> through iterative specialisation. The algorithm is generic {{in the sense}} that it can be instantiated with any decidable fragment of <b>Horn</b> <b>clauses,</b> resulting in a solution scheme for general <b>Horn</b> <b>clauses</b> that guarantees soundness and termination, and furthermore, it presents sufficient criteria for completeness. We then demonstrate the use of the framework, by creating an instance of it, based on the decidable class H 1, capable of solving a non-trivial protocol analysis problem based on the Yahalom protocol. ...|$|R
50|$|A <b>Horn</b> <b>clause</b> is {{a clause}} with at most one {{positive}} literal, called {{the head of}} the clause, and any number of negative literals, forming the body of the clause. A Horn formula is a propositional formula formed by conjunction of Horn clauses.|$|E
50|$|Algebraic Logic Functional {{programming}} language, {{also known}} as ALF, is a programming language which combines functional and logic programming techniques. Its foundation is <b>Horn</b> <b>clause</b> logic with equality which consists of predicates and Horn clauses for logic programming, and functions and equations for functional programming.|$|E
5000|$|Constraint logic {{programming}} combines <b>Horn</b> <b>clause</b> {{logic programming}} with constraint solving. It extends Horn clauses by allowing some predicates, declared as constraint predicates, to occur as literals {{in the body}} of clauses. A constraint logic program is a set of clauses of the form: ...|$|E
5000|$|Declaratively, guarded <b>Horn</b> <b>clauses</b> {{are read}} as {{ordinary}} logical implications: ...|$|R
25|$|The {{fact that}} <b>Horn</b> <b>clauses</b> {{can be given}} a {{procedural}} interpretation and, vice versa, that goal-reduction procedures {{can be understood as}} <b>Horn</b> <b>clauses</b> + backward reasoning means that logic programs combine declarative and procedural representations of knowledge. The inclusion of negation as failure means that logic programming is a kind of non-monotonic logic.|$|R
40|$|Some {{recent works}} {{rely on the}} intuitionistic theory of Hereditary Harrop {{formulas}} to provide extensions for <b>Horn</b> <b>clauses</b> while preserving the logic paradigm. In particular, an intuitionistic implication is used to provide some form of scoping. However the lack of appropriate evaluation strategies, notably a strategy relying on a forward-chaining search, has limited its application. This paper investigates a resolution schema for propositional Hereditary Harrop formulas, extending the resolution for <b>Horn</b> <b>Clauses.</b> A particular restriction of this resolution schema provides a specification of bottom-up search in presence of embedded intuitionistic implications. A decidable bottom-up procedure is given by a further refinement. 1 Introduction Most logic programming languages {{can be seen as}} implementations of the classical first-order theory of <b>Horn</b> <b>clauses.</b> The Prolog interpreter, for instance, may be described as implementing SLD-resolution for <b>Horn</b> <b>clauses.</b> Although the importance of th [...] ...|$|R
5000|$|The {{resulting}} <b>Horn</b> <b>clause</b> is {{the hypothesis}} [...] {{obtained by the}} rlgg approach. Ignoring the background knowledge facts, the clause informally reads [...] " [...] is called a daughter of [...] if [...] is the parent of [...] and [...] is female", which is a commonly accepted definition.|$|E
50|$|In {{mathematical}} logic and logic programming, a <b>Horn</b> <b>clause</b> {{is a logical}} formula of a particular rule-like form which gives it useful properties for use in logic programming, formal specification, and model theory. Horn clauses are named for the logician Alfred Horn, who first pointed out their significance in 1951.|$|E
50|$|Horn clauses play a basic role in {{constructive}} {{logic and}} computational logic. They {{are important in}} automated theorem proving by first-order resolution, because the resolvent of two Horn clauses is itself a <b>Horn</b> <b>clause,</b> and the resolvent of a goal clause and a definite clause is a goal clause. These properties of Horn clauses can lead to greater efficiencies in proving a theorem (represented as the negation of a goal clause).|$|E
40|$|It is {{well-known}} that context-independent control flow analysis {{can be performed}} in cubic time for functional and object-oriented languages. Yet recent applications of control flow analysis to calculi of computation (like the #-calculus and the ambient calculus) have reported considerably higher complexities. In this paper we introduce two general techniques, the use of <b>Horn</b> <b>clauses</b> with sharing {{and the use of}} tiling of <b>Horn</b> <b>clauses,</b> for reducing the worst-case complexity of analyses. Applying these techniques to the #-calculus and the ambient calculus we reduce the complexity from O(n 5) to O(n 3) in both cases. Keywords: Program analysis, <b>Horn</b> <b>clauses</b> with sharing, tiling of <b>Horn</b> <b>clauses,</b> #-calculus, ambient calculus, 0 -CFA. 1 Introduction Program analyses often can be separated into two phases. In the first phase, the program to be analyzed is translated into a suitable constraint system describing safe information about the program, and where the unknowns represent the [...] ...|$|R
40|$|In {{the present}} paper we use the {{approach}} of height functions to defining a semi-distance measure between <b>Horn</b> <b>clauses.</b> This appraoch is already discussed elsewhere {{in the framework of}} propositional and simple first order languages (atoms). Hereafter we prove its applicability for <b>Horn</b> <b>clauses.</b> We use some basic results from lattice theory and introduce a family of language independent coverage-based height functions. Then we show how these results apply to <b>Horn</b> <b>clauses.</b> We also show an example of conceptual clustering of first order atoms, where the hypotheses are <b>Horn</b> <b>clauses.</b> 1 Introduction Almost all approaches to inductive learning are based on generalization and/or specialization hierarchies. These hierarchies represent the hypothesis space which in most cases is a partially ordered set under some generality ordering. The properties of partially ordered sets are well studied in lattice theory. One concept from this theory is mostly used in inductive learning [...] this is [...] ...|$|R
40|$|This volume {{contains}} {{the proceedings of}} HCVS 2014, the First Workshop on <b>Horn</b> <b>Clauses</b> for Verification and Synthesis which was held on July 17, 2014 in Vienna, Austria as a satellite event of the Federated Logic Conference (FLoC) {{and part of the}} Vienna Summer of Logic (VSL 2014). HCVS 2014 was affiliated to the 26 th International Conference on Computer Aided Verification (CAV 2014) and to the 30 th International Conference on Logic Programming (ICLP 2014). Most Program Verification and Synthesis problems of interest can be modeled directly using <b>Horn</b> <b>clauses</b> and many recent advances in the Constraint/Logic Programming and Program Verification communities have centered around efficiently solving problems presented as <b>Horn</b> <b>clauses.</b> Since <b>Horn</b> <b>clauses</b> for verification and synthesis have been advocated by these communities in different times and from different perspectives, the HCVS workshop was organized to stimulate interaction and a fruitful exchange and integration of experiences...|$|R
5000|$|Solving {{the problem}} amounts to {{deriving}} a contradiction, which {{is represented by}} the empty clause (or [...] "false"). The solution of the problem is a substitution of terms for the variables in the goal clause, which can be extracted from the proof of contradiction. Used in this way, goal clauses are similar to conjunctive queries in relational databases, and <b>Horn</b> <b>clause</b> logic is equivalent in computational power to a universal Turing machine.|$|E
50|$|Basing logic {{programming}} within linear logic {{has resulted in}} the design of {{logic programming}} languages that are considerably more expressive than those based on classical logic. <b>Horn</b> <b>clause</b> programs can only represent state change by the change in arguments to predicates. In linear logic programming, one can use the ambient linear logic to support state change. Some early designs of logic programming languages based on linear logic include LO & Pareschi, 1991, Lolli, ACL, and Forum 1996. Forum provides a goal-directed interpretation of all of linear logic.|$|E
50|$|Transaction Logic is an {{extension}} of predicate logic that accounts in a clean and declarative way for the phenomenon of state changes in logic programs and databases. This extension adds connectives specifically designed for combining simple actions into complex transactions and for providing control over their execution. The logic has a natural model theory and a sound and complete proof theory. Transaction Logic has a <b>Horn</b> <b>clause</b> subset, which has a procedural as well as a declarative semantics. The important features of the logic include hypothetical and committed updates, dynamic constraints on transaction execution, non-determinism, and bulk updates. In this way, Transaction Logic is able to declaratively capture a number of non-logical phenomena, including procedural knowledge in artificial intelligence, active databases, and methods with side effects in object databases.|$|E
40|$|The {{field of}} Inductive Logic Programming (ILP), which is {{concerned}} with the induction of <b>Horn</b> <b>clauses</b> from examples and background knowledge, has received increased attention over the last time. Recently, some positive results concerning the learnability of restricted logic programs have been published. In this paper we review these restrictions and prove some lower-bounds of the computational complexity of learning. In particular, we show that a learning algorithm for i 2 -determinate <b>Horn</b> <b>clauses</b> (with variable i) could be used to decide the PSPACE-complete problem of Finite State Automata Intersection, and that a learning algorithm for 12 -nondeterminate <b>Horn</b> <b>clauses</b> could be used to decide the NP-complete problem of Boolean Clause Satisfiability (SAT). This also shows, that these <b>Horn</b> <b>clauses</b> are not PAC-learnable, unless RP = NP = PSPACE. Keywords: Inductive Logic Programming, PAC-Learning. 1 Introduction Most success within the field of Machine Learning has been achiev [...] ...|$|R
2500|$|A {{concurrent}} logic {{program is}} a set of guarded <b>Horn</b> <b>clauses</b> of the form: ...|$|R
40|$|In this paper, an {{algorithm}} {{for testing}} the unsatisfiability {{of a set}} of ground order-sorted equational <b>Horn</b> <b>clauses</b> (for coherent signatures) is presented. This result follows {{from the fact that the}} concept of congruence closure extends to finite sets of ground order-sorted equational <b>Horn</b> <b>clauses.</b> We show how to compute the order-sorted congruence closure and obtain an algorithm running in O(η 2) ...|$|R
