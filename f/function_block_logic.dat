1|2847|Public
50|$|Chivilikhin D., Shalyto A., Patil S., Vyatkin V. Reconstruction of <b>Function</b> <b>Block</b> <b>Logic</b> using Metaheuristic Algorithm: Initial Explorations / Proceedings of the 13th IEEE International Conference on Industrial Informatics (INDIN'15). 2015, pp. 1239-1242.|$|E
40|$|In this paper, we {{implement}} the first realization of a reconfigurable chaotic based <b>logic</b> <b>block</b> that can morph between all two input, one output <b>logic</b> <b>functions.</b> This <b>logic</b> <b>block</b> is constructed {{based on a}} discrete time chaotic circuit known as Logistic Map and can directly emulate operation of all two input, one output combinational functions. We have derived instruction set table of this <b>logic</b> <b>block</b> {{that can be used}} as a look up table to generate different logic functions. Furthermore, we propose a method to enhance robustness of the constructed <b>logic</b> <b>block</b> with respect to environmental noise. Constructed <b>logic</b> <b>block</b> provides opportunities and possibilities to construct more efficient and higher order reconfigurable <b>logic</b> <b>blocks...</b>|$|R
40|$|IEC 61131 - 3, the world-wide {{standard}} for industrial control programming, is increasingly {{being used in}} safety-related control applications. Control loops are built from components taken from domain-specific <b>function</b> <b>block</b> libraries. Code inspection and testing are the two predominant quality assurance techniques. For highly dependable control applications, however, these techniques are not sufficient, in general. This paper suggests to augment testing with compositional, theorem-prover supported verification. The approach {{is based on a}} representation of IEC 61131 - 3 <b>function</b> <b>blocks</b> in higher-order <b>logic.</b> The verification task is separated into the a priori verification of library components and a separate proof of individual application programs. Keywords: Safety-critical control systems, dependable software, PLC programming, IEC 61131 - 3, modular verification, higher order logic theorem proving. 1. INTRODUCTION Programmable logic controllers (PLCs) form a growing market of [...] ...|$|R
40|$|AbstractIEC 61131 - 3, the world-wide {{standard}} for industrial control programming, is increasingly {{being used in}} embadded control applications. The standard supports the concept of reusable “software ICs” through the concept of <b>function</b> <b>blocks.</b> can be hierarchically grouped and horizontally “wired” to Complex control loops are typically built from elementary components taken from domain-specific libraries. Code inspection and testing are the two predominant quality assurance techniques in practice, today. For highly dependable control applications, however, these techniques are not sufficient, in general. This paper suggests to augment testing with compositional, theorem-prover supported verification. The approach {{is based on a}} representation of IEC 61131 - 3 <b>function</b> <b>blocks</b> in higher-order <b>logic.</b> The verification task is separated into the a priori verification of library components and a separate proof of individual application programs. The latter relies on proven properties of the library components used. We sketch the semantic embedding of three most used languages of the IEC standard and illustrate our verification approach with a simple example. We conclude with a wish list for a verification tool that is usable by application and licensing engineers...|$|R
40|$|Abstract. Non-Linear Feedback Shift Registers (NLFSR) are a {{generalization}} of Linear Feedback Shift Registers (LFSRs) {{in which a}} current state is a nonlinear function of the previous state. The interest in NLFSRs is motivated by their ability to generate pseudo-random sequences which are usually hard to break with existing cryptanalytic methods. However, {{it is still not}} known how to construct large n-stage NLFSRs which generate full cycles of 2 n possible states. This paper presents a method for generating full cycles by a composition of NLFSRs. First, we show that an n ∗ k-stage register with period O(2 2 n) can be constructed from k n-stage NLFSRs by adding to their feedback <b>functions</b> a <b>logic</b> <b>block</b> of size O(n ∗ k). This <b>logic</b> <b>block</b> implements Boolean <b>functions</b> representing the set of pairs of states whose successors have to be exchanged in order to join cycles. Then, we show how to join all cycles into one by using one more <b>logic</b> <b>block</b> of size O(n ∗ k 2) and an extra time step. The presented method is feasible for generating very large full cycles. ...|$|R
40|$|Abstract 123 This paper {{presents}} a many-core visual computing architecture code named Larrabee, a new software rendering pipeline, a manycore programming model, and performance analysis for several applications. Larrabee uses multiple in-order x 86 CPU cores that are augmented {{by a wide}} vector processor unit, {{as well as some}} fixed <b>function</b> <b>logic</b> <b>blocks.</b> This provides dramatically higher performance per watt and per unit of area than out-of-order CPUs on highly parallel workloads. It also greatly increases the flexibility and programmability of the architecture as compared to standard GPUs. A coherent on-die 2 nd level cache allows efficient inter-processor communication and high-bandwidth local data access by CPU cores. Task scheduling is performed entirely with software in Larrabee, rather than in fixed function logic. The customizable software graphics rendering pipeline for thi...|$|R
50|$|<b>Logic</b> <b>blocks</b> are {{the most}} common FPGA architecture, and are usually laid out within a <b>logic</b> <b>block</b> array. <b>Logic</b> <b>blocks</b> require I/O pads (to {{interface}} with external signals), and routing channels (to interconnect <b>logic</b> <b>blocks).</b>|$|R
40|$|Self-timed {{circuits}} {{present an}} attractive {{solution to the}} problem of process variation. However, implementing self-timed combinational logic is complex and expensive. This paper presents a novel method for synthesising indicating implementations of arbitrary encoded <b>function</b> <b>blocks.</b> The synthesis method reduces the cost of the implementations by distributing indication between the individual outputs of a <b>function</b> <b>block.</b> Covers are constructed by determining the minimal cost set of Prime Indicants which are required to indicate all of the input transitions of the <b>function</b> <b>block.</b> The results of the procedure are demonstrated on a wide range of combinational <b>logic</b> <b>blocks</b> and show a reduction in literal count of between 38 - 99 %. 1...|$|R
50|$|In computing, a <b>logic</b> <b>block</b> or {{configurable}} <b>logic</b> <b>block</b> (CLB) is {{a fundamental}} building block of field-programmable gate array (FPGA) technology. <b>Logic</b> <b>blocks</b> can be configured by the engineer to provide reconfigurable logic gates.|$|R
40|$|Laser-programmed gate arrays (LPGAs) {{represent}} {{a new approach}} to application specific integrated circuit prototyping and implementation. This paper proposes a new LPGA <b>logic</b> <b>block</b> architecture called a fola!able PLA-style <b>logic</b> <b>block</b> The proposed <b>logic</b> <b>block</b> architecture is similar to that found in commercially available CPLDs. The term foldable means that the granularity of the <b>logic</b> <b>block</b> can be varied. This is achieved using the LPGA laser disconnect methodology. A custom %hD tool has been developed to map circuits into the new <b>logic</b> <b>block</b> architecture. An experimental study shows that LPGAs with foldable <b>logic</b> <b>blocks</b> are more area-ejj?cient han those based on normal unfoldable <b>logic</b> <b>blocks.</b> 1...|$|R
5000|$|Composite <b>function</b> <b>block</b> - CFB: Its {{functionality}} {{is defined}} by a <b>function</b> <b>block</b> network.|$|R
40|$|Abstract — IEC 61499 {{has been}} {{endorsed}} {{as the standard}} for modelling and implementing distributed industrial-process measurement and control systems. The standard prescribes the use of <b>function</b> <b>blocks</b> for designing systems in a component-oriented approach. The execution model of a basic <b>function</b> <b>block</b> and the manner for event/data connections between blocks are described therein. Unfortunately, the standard does not provide exhaustive specifications for <b>function</b> <b>block</b> execution. Consequently, multiple standard-compliant implementations ex-hibiting different behaviours are possible. This not only defeats the purpose of having a standard, but makes verification of <b>function</b> <b>block</b> systems difficult. To overcome this, we propose synchronous semantics for <b>function</b> <b>blocks,</b> and show its feasibil-ity by translating <b>function</b> <b>blocks</b> into a subset of Esterel, a well-known synchronous language. The proposed semantics avoids causal cycles common in Esterel, and is proven to be reactive and deterministic under any composition. Moreover, verification techniques developed for synchronous systems can now be applied to <b>function</b> <b>blocks.</b> Index Terms — Compilation, Esterel, <b>function</b> <b>blocks,</b> IEC 61499, synchronous semantics...|$|R
50|$|Among other examples, IEC 61499-3 {{described}} {{the use of}} SIFBs as communication <b>function</b> <b>blocks</b> for remote access to real-time data and parameters of function blocks; the use of adapter interfaces to implement object oriented concepts; initialization algorithms in <b>function</b> <b>block</b> networks; and the implementation of ECCs for a simplified motor control of hypothetical VCRs.Additionally the impacts of the mapping concerning the communication <b>function</b> <b>blocks</b> was explained, {{as well as the}} device management by management applications and its <b>function</b> <b>blocks,</b> and the principle of the device manager <b>function</b> <b>block</b> (DEV_MGR).|$|R
50|$|The {{most common}} FPGA {{architecture}} {{consists of an}} array of <b>logic</b> <b>blocks</b> (called configurable <b>logic</b> <b>block,</b> CLB, or <b>logic</b> array <b>block,</b> LAB, depending on vendor), I/O pads, and routing channels. Generally, all the routing channels have the same width (number of wires). Multiple I/O pads may fit into the height of one row or the width of one column in the array.|$|R
25|$|Specific <b>function</b> <b>block</b> diagram are {{the classic}} Functional Flow Block Diagram, and the <b>Function</b> <b>Block</b> Diagram (FBD) {{used in the}} design of {{programmable}} logic controllers.|$|R
5000|$|... #Caption: GCN {{includes}} {{special purpose}} <b>function</b> <b>blocks</b> {{to be used}} by HSA. Support for these <b>function</b> <b>blocks</b> is available through [...] since Linux kernel 3.19.|$|R
40|$|An {{improved}} <b>function</b> <b>block</b> based redundancy {{approach is}} proposed in this paper. The structure, link organization and data synchronization of improved <b>function</b> <b>block</b> are described. Furthermore, the non-redundancy model, the corresponding device-level redundancy model and improved <b>function</b> <b>block</b> based redundancy model are analyzed in quantitatively. For 1 - 0 - 2 type system, improved <b>function</b> <b>block</b> based redundancy model can achieved significantly higher reliability than non-redundant system. IEEE Intelligent Computat Soc, IEEE Comp Soc, Res Assoc Intelligent Computat Technol & Automat, Changsha Univ Sci & Technol, Hunan Univ Sci & Techno...|$|R
5000|$|Central to the DCS {{model was}} the {{inclusion}} of control <b>function</b> <b>blocks.</b> <b>Function</b> <b>blocks</b> evolved from early, more primitive DDC concepts of [...] "Table Driven" [...] software. One of the first embodiments of object-oriented software, <b>function</b> <b>blocks</b> were self-contained [...] "blocks" [...] of code that emulated analog hardware control components and performed tasks that were essential to process control, such as execution of PID algorithms. <b>Function</b> <b>blocks</b> continue to endure as the predominant method of control for DCS suppliers, and are supported by key technologies such as Foundation Fieldbus today.|$|R
40|$|The {{buffered}} sequential execution model (BSEM) for IEC 61499 <b>function</b> <b>block</b> applications is presented. Before {{the execution}} of the application the composite <b>function</b> <b>blocks</b> are flattened. The resulting application containing the basic and service interface <b>function</b> <b>blocks</b> is executed. The basic <b>function</b> <b>blocks</b> are put in the ready queue in the same order that they receive the input events, hence the word ldquosequentialrdquo in the name. Each basic <b>function</b> <b>block</b> keeps a queue of incoming events with their associated data, hence the word ldquobufferedrdquo in the name. Scheduling policy of the blocks is in the scheduling function while the execution policy of the received events is in the <b>function</b> <b>block</b> instance. The extended finite automata models suitable for formal verification of the proposed execution modelpsilas behavior are presented. The model may be analyzed using a discrete event systems tool called Supremica. The presented execution model is implemented in the Fuber runtime environment...|$|R
50|$|In the C {{programming}} language, {{an external}} variable is a variable defined outside any <b>function</b> <b>block.</b> On the other hand, a local (automatic) variable is a variable defined inside a <b>function</b> <b>block.</b>|$|R
40|$|In {{this paper}} we {{introduce}} a new profile for <b>Function</b> <b>Block</b> Adapters (FBAs), which {{are responsible for the}} connection of Unified Modeling Language (UML) ports and <b>function</b> <b>blocks</b> of non-UML languages. FBAs provide interfaces to ports, to <b>function</b> <b>blocks,</b> and a description of the mapping between these interfaces. Both UML and <b>function</b> <b>block</b> developers can use a special easy-to-use FBA description language to express these interface mappings in a concise manner. Our FBA language offers the important advantage of highlevel descriptions during early phases of the UML development process. This paper proposes a mapping of FBA-semantics to standard UML-semantics. The application of FBAs to <b>function</b> <b>block</b> oriented languages like IEC 61131 - 3, IEC 61499, or Matlab/Simulink^TM is discussed by using the approach of the Model Driven Architecture...|$|R
40|$|The IEC 61499 <b>function</b> <b>block</b> {{architecture}} {{is a new}} standard proposed to replace the current PLC technologies. Currently the available <b>function</b> <b>block</b> development tools have major shortcoming, specifically {{the lack of a}} debug function. The OOONEIDA workbench is an open source <b>function</b> <b>block</b> development tool designed for open development. Our aim is to make the Workbench a fully functioning development tool with emphasis on developing a debug function. ...|$|R
5000|$|Like IEC 61131-3 <b>function</b> <b>blocks,</b> IEC 61499 <b>function</b> <b>block</b> types specify both an {{interface}} and an implementation. In {{contrast to}} IEC 61131-3, an IEC 61499 interface contains event {{inputs and outputs}} in addition to data inputs and outputs. Events {{can be associated with}} data inputs and outputs by WITH constraints. IEC 61499 defines several <b>function</b> <b>block</b> types, all of which can contain a behavior description in terms of service sequences: ...|$|R
40|$|The IEC 61499 <b>Function</b> <b>Block</b> {{standard}} {{describes an}} architecture {{to support the}} development and reuse of software components for distributed and embedded industrial control and automation systems. Often distributed over heterogeneous execution platforms, IEC 61499 applications are highly re-configurable; users can map individual <b>function</b> <b>blocks</b> to run on any available device. However, the standard does not allow differentiating between the capabilities of different devices in a heterogeneous platform. In this paper, we present a framework that facilitates the utilization of device-specific capabilities during the design of <b>function</b> <b>block</b> applications. Device capabilities are wrapped-up in Basic <b>function</b> <b>blocks</b> linking to low-level device drivers, allowing designers to access device features with ease during the design phase. The framework is completely compatible with the IEC 61499 standard, and remains highly flexible. As a case study, we show how <b>function</b> <b>block</b> applications utilizing low-level capabilities of Raspberry Pi devices can be written and deployed using the Holobloc FBDK development environment. This particular setting of using <b>function</b> <b>blocks</b> to program the Raspberry Pi also results in an ideal, low-cost research and teaching platform for distributed computers...|$|R
30|$|Figure  2 {{illustrates}} {{two kinds}} of early output asynchronous <b>function</b> <b>blocks</b> which permit either early reset or early set. An early set type asynchronous <b>function</b> <b>block</b> would produce all the valid primary outputs subsequent {{to the arrival of}} even a subset of the valid primary inputs without waiting for the arrival of all the valid primary inputs. The early set nature of an asynchronous <b>function</b> <b>block</b> is highlighted by the red oval in Fig.  2. On the other hand, the early reset asynchronous <b>function</b> <b>block</b> could drive all the primary outputs to spacers following the assumption of the spacer state by even a subset of the primary inputs without waiting for all the primary inputs to become spacers. The early reset nature of an asynchronous <b>function</b> <b>block</b> is highlighted by the blue oval in Fig.  2.|$|R
40|$|Testing for time-related {{behaviors}} of PLC software {{is important and}} should be performed carefully. We propose a structural testing technique on <b>Function</b> <b>Block</b> Diagram(FBD) networks including timer func-tion blocks. In order to test FBD networks including timer <b>function</b> <b>blocks,</b> we generate templates for timer <b>function</b> <b>blocks</b> and transform a unit FBD into a flow-graph using the proposed templates. We apply existing testing techniques to the generated flowgraph and de-scribe how the characteristics of timer <b>function</b> <b>blocks</b> {{are reflected in the}} testing process. By the proposed method, FBD networks including timer <b>function</b> <b>blocks</b> can be tested thoroughly without the intermediate code which was essential in the previous FBD testing. To demonstrate the effectiveness of the proposed method, we use a trip logic of bistable processor of digital plant protection systems which is being developed in Korea. 1...|$|R
40|$|INTRODUCTION In this manual it is {{explained}} how <b>function</b> <b>blocks</b> {{can be used}} in the Switch-Level Simulator SLS. Before a user can do this, he or she should be familiar with the SLS simulator. Therefore in this manual the SLS User's Manual [1] is assumed to be generally known. The simulator SLS has been extended to a Mixed Level Simulator {{that can be used for}} simulations on functional level down to switch-level. This extension has been created by allowing the use of <b>function</b> <b>blocks</b> in networks. In SLS (as Switch-Level Simulator) a network can be described hierarchically: subnetworks can be called in networks. Now in the Mixed-Level Simulator SLS, a subblock can also be a <b>function</b> <b>block,</b> instead of a network. When a network consists of only <b>function</b> <b>blocks,</b> a functional simulation can be performed. When both <b>function</b> <b>blocks</b> and transistor-level parts or switch-level subnetworks exist in a network, mixed-level simulations result. And of course the possibility still exists to use...|$|R
40|$|Abstract- This paper {{presents}} {{a new approach}} to modelling automation systems based on the combination and mutual transformation of IEC 61499 <b>Function</b> <b>Blocks</b> and MATLAB Simulink. The reason for such transformation is the natural complementarity of these two models: MATLAB Simulink/Stateflow provides a nice environment for modelling and simulation of control and embedded systems, while <b>Function</b> <b>Blocks</b> are good for designing distributed control systems. An integrated software simulation environment with this transformation ability between these two tools will lead to a solution for the validation need for <b>Function</b> <b>Blocks.</b> This paper uses a motor example to demonstrate the transformation from a Simulink model to a <b>Function</b> <b>Block</b> model in <b>Function</b> <b>Block</b> Development Kit (FBDK). We discuss important issues of model transformation, such as semantics mapping, execution priorities and some guidelines for this transformation approach. An observer approach is introduced in order to make comparison of the results. This approach can also be used as part of the software simulation environment with the transformation approach. I...|$|R
40|$|Voting {{mechanism}} based safe <b>function</b> <b>block</b> {{compatible with}} IEC 61499 is proposed. The voting safe <b>function</b> <b>block</b> can vote the discrete or continuous parameters {{and get a}} reliable value. A new safe communication approach is proposed for not only error sensing but also error correcting. The approach use a triple data field copies to address error correcting problem, and more safety is achieved in communication by this way. By using voting safe <b>function</b> <b>block,</b> a more safe system based on common control devices is designed. Furthermore, a markov model is established to describe safety and reliability of the voting safe <b>function</b> <b>block</b> based safe system. At the end, simulation under given parameters is done, which is about PFD, PFS and MTTF factors. Dalian University of Technolog...|$|R
40|$|A {{solution}} for visualising the tool path {{generated by a}} <b>function</b> <b>block</b> system is introduced in this research. It facilitates the real-time monitoring of the behaviour of <b>function</b> <b>blocks</b> running on-board a CNC controller, and provides interactivity between the <b>function</b> <b>block</b> system and the shop floor users. In order to improve computer aided process planning for milling operations, a distributed <b>function</b> <b>block</b> system is currently being developed by the project CAPP- 4 -SEMs (Collaborative and Adaptive Process Planning for Sustainable Manufacturing Environments). In this system, the <b>function</b> <b>blocks</b> are created in a Web-based Distributed Process Planning (Web-DPP) system built in a Cloud environment, and dispatched to CNC controllers to generate complex milling tool paths. This approach {{is different from the}} conventional off-line CAD-CAM-CNC approach driven by G-code. The ability of a real-time, on-board visualisation of the behaviour of <b>function</b> <b>blocks</b> is a very important feature for the evaluating and manipulating the behaviour of <b>function</b> <b>block.</b> It helps the users to understand the encapsulated process behaviour which the <b>function</b> <b>block</b> system is generating, and to acquire the confidence that the system is practical and reliable. The aim of this research is to find a suitable solution to realise the visualisation for tool paths generated by a system of <b>function</b> <b>block</b> running on a CNC controller. The existing visualisation methods are researched, compared and selected to fit the purpose. A number of aspects have been investigated such as the program language, graphical user interface layout and the practical needs of the shop floor users. By a requirements survey from industries, the challenging practical needs of industries are collected, analysed and used for steering the development. An application with a 3 D graphical user interface has been developed and tested. The developed visualizer is a light weight visualisation tool which is able to run directly on CNC controllers with Windows (or PC with Windows). It can be connected with a Cloud environment (optional) for real-time tool path visualisation...|$|R
40|$|The {{generation}} of test vectors and design-for-test {{aspects of the}} Jet Propulsion Laboratory (JPL) Very Large Scale Integration (VLSI) Viterbi decoder chip is discussed. Each processor integrated circuit (IC) contains over 20, 000 gates. To achieve {{a high degree of}} testability, a scan architecture is employed. The logic has been partitioned so that very few test vectors are required to test the entire chip. In addition, since several <b>blocks</b> of <b>logic</b> are replicated numerous times on this chip, test vectors need only be generated for each block, rather than for the entire circuit. These unique <b>blocks</b> of <b>logic</b> have been identified and test sets generated for them. The approach employed for testing was to use pseudo-exhaustive test vectors whenever feasible. That is, each cone of logid is tested exhaustively. Using this approach, no detailed logic design or fault model is required. All faults which modify the <b>function</b> of a <b>block</b> of combinational <b>logic</b> are detected, such as all irredundant single and multiple stuck-at faults...|$|R
5000|$|<b>Function</b> <b>block</b> diagrams, used in {{programmable}} logic controllers ...|$|R
40|$|ABSTRACT – This paper {{presents}} the design space exploration framework {{that consists of}} two design loops: cosynthesis loop for component selection and mapping of the <b>function</b> <b>blocks</b> to the processing components, and communication DSE loop for communication architecture optimization. Before entering into the cosynthesis loop, {{it is critical to}} estimate the performance of <b>function</b> <b>blocks.</b> In this paper, we also propose a performance estimation method of software <b>function</b> <b>blocks</b> considering the effect of architecture variation, compiler optimization, and data dependent behavior. It is to run the entire application with code augmentation on the instruction set simulator of the target processor. In the cosynthesis loop, the performance of the entire application is easily computed as a linear combination of <b>function</b> <b>block</b> performance values. Experimentation with real-life applications proves the viability of the proposed technique. I...|$|R
40|$|Abstract: <b>Function</b> <b>Block</b> Adapters (FBAs) are new {{modeling}} elements, {{responsible for}} the connection of UML capsules and <b>function</b> <b>blocks</b> of the IEC 61131 - 3 standard. FBAs contain an interface to capsules {{as well as to}} <b>function</b> <b>blocks</b> and a description of the mapping between these interfaces. In this paper we discuss implementation issues of FBAs. While the specification of FBAs is completely platform-independent, we show that different hardware solutions force highly platform-dependent implementation models. In most cases a FBA is implemented in two programming languages- an object oriented language and a language out of IEC 61131 - 3. While object oriented programs mostly implement an event-driven execution semantic, PLC programs are executed cyclically. Especially this heterogeneous implementation environment was the motivation for developing <b>Function</b> <b>Block</b> Adapters. 1...|$|R
30|$|OpenStack is {{composed}} of the <b>function</b> <b>blocks</b> which manage logical/virtual resources deployed on physical resources, the <b>function</b> <b>block</b> which provides Single Sign On authentication among other <b>function</b> <b>blocks</b> and the <b>function</b> <b>block</b> which orchestrates a set of virtual resources. Neutron controls virtual networks. OVS (Open Virtual Switch) [[8]] and other software switches {{can be used as}} a virtual switch. Nova controls virtual machines (VMs). KVM (Kernel based Virtual Machine) [[9]], Xen [[10]] and others can be used as hypervisors of VMs. Cinder manages block storages and can attach a logical volume to a VM like a local disk. Swift manages object storages. Glance manages Image files. Keystone is a base which performs Single Sign On authentications of these <b>function</b> <b>blocks.</b> Heat is an orchestration deployment function to create or update virtual resource instances using Nova, Cinder or other blocks based on a text template. Ceilometer is a metering function of virtual resource usage. The functions of OpenStack are used through REST (Representational State Transfer) APIs. There is also Web GUI called Horizon to use the functions of OpenStack.|$|R
40|$|Field Programmable Gate Arrays (FPGAs) {{are widely}} used to {{implement}} special purpose processors. FPGAs are economically cheaper for low quantity production because its function can be directly reprogrammed by end users. In this project designing a reconfigurable low power Asynchronous FPGA cells are done. FPGAs consume high dynamic and standby power. In {{order to reduce the}} standby power the autonomous fine grain power gating method is used. The autonomous fine grain power gating method has lookup table which is controlled by sleep controller and sleep transistor. In the successive <b>logic</b> <b>block</b> if the data arrives to the first <b>logic</b> <b>block,</b> the next <b>logic</b> <b>block</b> goes to active state. Suppose if the data not arrives to the first <b>logic</b> <b>block</b> than the next <b>logic</b> <b>block</b> goes to standby state and remain in this state until it reaches threshold time. After reaching threshold time the <b>logic</b> <b>block</b> goes to sleep state from standby state. In this sleep state the <b>logic</b> <b>block</b> power goes OFF. Hence the power consumption of the FPGA becomes reduced. The proposed architecture used in both fine grain as well as coarse grain structure. The circuit is simulated using Xilinx tool. Power reduction is achieved by selectively setting the functional units into a low leakage mode when they are inactive...|$|R
