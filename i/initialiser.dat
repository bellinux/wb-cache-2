6|1|Public
50|$|A {{variable}} with an <b>Initialiser</b> {{is assigned}} {{the value of}} its AssignmentExpression when the VariableStatement is executed, not when the variable is created.|$|E
40|$|The AOARD project #FA 2386 - 11 - 1 - 4070 aims at {{providing}} a provably correct <b>initialiser</b> of componentised systems. Taking as input {{a description of}} the desired components and the desired authorised communication between them, the <b>initialiser</b> sets up the system and provides a proof that the resulting concrete machine state of the system matches the desired authority state. Within the scope of this project, we provide (1) a formal specification of the <b>initialiser,</b> in terms of the steps needed to create the components and their communication channels; and (2) a formal proof that this specification is correct in that it either fails safely or produces the desired state. This document is an annual report of the project, presenting the status of the work to date. Namely, we have written the <b>initialiser</b> specification, we have set up a verification framework enabling modular reasoning and proofs, and we have progressed substantially on the proof...|$|E
40|$|Abstract. The {{safety and}} {{security}} of software systems depends on how they are initially configured. Manually writing program code that establishes such an initial configuration is a tedious and error-prone engineering process. In this paper we present an automatic and formally verified <b>initialiser</b> for component-based systems built on the general-purpose microkernel seL 4. The construction principles of this tool apply to capability systems {{in general and the}} proof ideas are not specific to seL 4. The <b>initialiser</b> takes a declarative formal description of the desired initialised state and uses seL 4 -provided services to create all necessary components, setup their communication channels, and distribute the required access rights. We provide a formal model of the <b>initialiser</b> and prove, in the theorem prover Isabelle/HOL, that the resulting state is the desired one. Our proof formally connects to the existing functional correctness proof of the seL 4 microkernel. This tool does not only provide automation, but also unprecedented assurance for reaching a desired system state. In addition to the engineering advantages, this result is a key prerequisite for reasoning about system-wide security and safety properties...|$|E
40|$|This {{proposal}} recommends extensions to C++ allowing: 1) Default <b>initialisers</b> for non-static class data {{members and}} bases 2) In-class definition of static data members with <b>initialisers</b> 3) Optional automagical allocation of static members initialised in class which together allow 1) Guarranteed initialisation of all class members, and to sensible values 2) Encapsulation of all specification {{of a class}} in the class declarative region 3) Enhanced robustness of classes to modification 4) Completion of the replacement of tentative declarations with full specifications 5) Considerable reduction of coding effort for classes with many variables and constructors while being 1) Compatible with existing code 2) Easy to implement, except for automagical allocation 3) Natural for programmers, requiring little explanation whereas automagical allocation is already required for static member of template classes and functions, which is available already in some compilers. Certain complica [...] ...|$|R
40|$|The {{safety and}} {{security}} of software systems depends on how they are initially configured. Manually writing program code that establishes such an initial configuration is a tedious and error-prone process, and yet most systems now are initialised with manually written, ad-hoc code. This thesis provides {{a solution to this}} process, presenting an automatic and formally verified system <b>initialiser</b> for component-based systems built on the general-purpose microkernel seL 4. The <b>initialiser</b> takes a declarative formal description of the desired initialised state, and uses seL 4 -provided services to create all necessary components, setup their communication channels, and distribute the required capabilities. We analyse a model for capability-based systems, namely the take-grant protection model, and extend the existing literature to develop a formal model in Isabelle/HOL that models real-world capability-based systems such as seL 4 more accurately. We use this to demonstrate how the security of a system can be conferred by capabilities. We provide a formal algorithm of system initialisation and prove, in the theorem prover Isabelle/HOL, that the resulting state conforms with the desired one, giving us an unprecedented level of assurance for the correctness of system initialisation. Our proof formally connects to the existing functional correctness proof of the seL 4 microkernel. In the process of this work, we develop a custom separation algebra, with a fine-level of granularity, for reasoning about both the API of the seL 4 microkernel and the user-level code running on seL 4...|$|E
40|$|We {{present an}} {{in-depth}} {{coverage of the}} comprehensive machine-checked formal verification of seL 4, a general-purpose operating system microkernel. We discuss the kernel design we used to make its verification tractable. We then describe the functional correctness proof of the kernelâ€™s C implementation and we cover further steps that transform this result into a comprehensive formal verification of the kernel: a formally verified IPC fastpath, a proof that the binary code of the kernel correctly implements the C semantics, a proof of correct access-control enforcement, a proof of information-flow noninterference, a sound worst-case execution time analysis of the binary, and an automatic <b>initialiser</b> for user-level systems that connects kernel-level access-control enforcement with reasoning about system behaviour. We summarise these results and show how they integrate to form a coherent overall analysis, backed by machine-checked, end-to-end theorems. The seL 4 microkernel is currently not just the only general-purpose operating system kernel that is fully formally verified to this degree. It is also the only example of formal proof of this scale that is kept current as the requirements, design {{and implementation of the}} system evolve over almost a decade. We report on our experience in maintaining this evolving formally verified code base...|$|E
40|$|Session S 6 - 03, Special Session: Evolutionary Computing in Water Resources Planning and Management IIIThis paper {{describes}} {{the formulation of}} a Multi-objective Pipe Smoothing Genetic Algorithm (MOPSGA) and its application to the least cost water distribution network design problem. Evolutionary Algorithms have been widely utilised for the optimisation of both theoretical and real-world non-linear optimisation problems, including water system design and maintenance problems. In this work we present a pipe smoothing based approach to the creation and mutation of chromosomes which utilises engineering expertise with the view to increasing {{the performance of the}} algorithm whilst promoting engineering feasibility within the population of solutions. MOPSGA is based upon the standard Non-dominated Sorting Genetic Algorithm-II (NSGA-II) and incorporates a modified population <b>initialiser</b> and mutation operator which directly targets elements of a network with the aim to increase network smoothness (in terms of progression from one diameter to the next) using network element awareness and an elementary heuristic. The pipe smoothing heuristic used in this algorithm is based upon a fundamental principle employed by water system engineers when designing water distribution pipe networks where the diameter of any pipe is never greater than the sum of the diameters of the pipes directly upstream resulting in the transition from large to small diameters from source to the extremities of the network. MOPSGA is assessed on a number of water distribution network benchmarks from the literature including some real-world based, large scale systems. The performance of MOPSGA is directly compared to that of NSGA-II with regard to solution quality, engineering feasibility (network smoothness) and computational efficiency. MOPSGA is shown to promote both engineering and hydraulic feasibility whilst attaining good infrastructure costs compared to NSGA-II...|$|E

