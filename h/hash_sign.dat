11|52|Public
2500|$|Permalinks {{are usually}} denoted by text link (i.e. [...] "Permalink" [...] or [...] "Link to this Entry"), but {{sometimes}} a symbol may be used. The most common symbol used is the <b>hash</b> <b>sign,</b> or #. However, certain websites employ their own symbol {{to represent a}} permalink such as an asterisk, a dash, a pilcrow (¶), a section sign (§), or a unique icon.|$|E
50|$|A <b>hash</b> <b>sign</b> marks a {{preprocessor}} {{statement in}} C, {{but is a}} comment in both bash and PHP.|$|E
50|$|The number sign, or <b>hash</b> <b>sign</b> (#) {{is often}} used as {{shorthand}} to denote shaft or seam, as in 4# (4 shaft or seam depending on context).|$|E
3000|$|Bob verifies the {{signature}} of the <b>hashes</b> <b>signed</b> by Alice and returns the cryptographic <b>hashes</b> <b>signed</b> by him: (h(n [...]...|$|R
5000|$|Copy {{writing and}} editing: {{technical}} writers often use three <b>hash</b> <b>signs</b> ("###") {{as a marker}} in text where more content will be added or there are errors to be corrected.|$|R
5000|$|Other attested {{names in}} Unicode are: pound <b>sign,</b> <b>hash,</b> crosshatch, octothorpe.|$|R
50|$|The string P1 {{identifies}} the file format. The <b>hash</b> <b>sign</b> introduces a comment. The next two numbers give the width and the height. Then follows the matrix with the pixel values (in the monochrome case here, only zeros and ones).|$|E
5000|$|Mining: in {{underground}} mining, the <b>hash</b> <b>sign</b> {{is sometimes}} {{used as a}} shorthand for [...] "seam" [...] or [...] "shaft". An example would be [...] "4#", which would mean [...] "four shaft" [...] or [...] "four seam" [...] depending on the context.|$|E
50|$|The {{touch-tone}} {{system uses}} audible tones {{for each of}} the digits zero through nine. Later this was expanded by two keys labeled with an asterisk (*) and the pound or <b>hash</b> <b>sign</b> (#) to represent the 11th and 12th DTMF signals. These signals accommodate various additional services and customer-controlled calling features.|$|E
40|$|Assuming {{time-stamp}} servers that we {{can trust}} exist every-where in the Internet, we propose a cheat-proof protocol for real-time gaming that has the minimum latency. The assumptions are: 1) Time-stamp servers are available near each player that issue serially numbered time stamps. 2) There is no communication break down between the player and the nearest time-stamp server. By this protocol, each player sends its own action to the other player and also sends its hash to the nearest time-stamp server. The time-stamp server sends back to the player the <b>signed</b> <b>hash</b> with time and a serial number involved. The signature is an undeni-able evidence of the action. The actions are checked if they are compatible with the <b>hashes</b> and the <b>signed</b> <b>hashes</b> are checked {{if they have the}} correct time and if the serial num...|$|R
5000|$|The symbol # is most {{commonly}} known as the number <b>sign,</b> <b>hash,</b> or pound <b>sign.</b> [...] The symbol has historically been used {{for a wide range of}} purposes, including the designation of an ordinal number and as a ligatured abbreviation for pounds avoirdupois (having been derived from the now-rare ℔). [...] Since 2007, the number sign has become the de facto standard signifier of metadata tags on social media platforms; the adoption of the symbol has been so universal that such metadata tags are now widely called hashtags.|$|R
3000|$|In the SPS (Generic Secure Provenance) scheme [10], the {{provenance}} of a node {{with respect}} to a data item D_i is encoded as P_i= 〈 n_i, hash(D_i), C_i 〉, where n_i is the node ID; hash(D_i) is a cryptographic hash of the data item D_i; C_i= {hash(n_i,hash(D_i) [...] C_i- 1)}_k_i, i.e., C_i is a <b>hash</b> value <b>signed</b> by n_i with its encryption key k_i.|$|R
5000|$|Permalinks {{are usually}} denoted by text link (i.e. [...] "Permalink" [...] or [...] "Link to this Entry"), but {{sometimes}} a symbol may be used. The most common symbol used is the <b>hash</b> <b>sign,</b> or #. However, certain websites employ their own symbol {{to represent a}} permalink such as an asterisk, a dash, a pilcrow (¶), a section sign (§), or a unique icon.|$|E
5000|$|A {{configuration}} {{is defined}} {{by a set of}} files, called templates, written in the pan language.These templates define simultaneously the configuration parameters, the configuration schema, andvalidation functions. Each template is named and is contained in a file having the same name.The syntax of a template file is simple:object | declaration | unique | structure [...] template template-name;statement … These files may contain comments that start with the <b>hash</b> <b>sign</b> ('#') and terminate with the next new lineor end of file.|$|E
5000|$|Subjects {{may take}} the form of a URI or a Blank node; predicates must be a URI; objects may be a URI, blank node or a literal. URIs are delimited with less-than and greater-than signs used as angle brackets. Blank nodes are {{represented}} by an alphanumeric string, prefixed with an underscore and colon (...) [...] Literals are represented as printable ASCII strings (with backslash escapes), delimited with double-quote characters, and optionally suffixed with a language or datatype indicator. Language indicators are an at sign followed by an RFC 3066 language tag; datatype indicators are a double-caret followed by a URI. Comments consist of a line beginning with a <b>hash</b> <b>sign.</b>|$|E
40|$|A cheat-proof {{protocol}} for real-time gaming is proposed {{under the assumption}} that time-stamp servers issue serially numbered time stamps honestly and are available near every player, i. e., they exist everywhere in the Internet. With this protocol, each player sends its action to the other player and also sends its hash to the nearest time-stamp server. The time-stamp server sends the <b>signed</b> <b>hash</b> with the time and a serial number back to the player. The actions are checked to verify that they are compatible with the <b>hashes,</b> and the <b>signed</b> <b>hashes</b> are checked to verify that they have the correct time and the serial numbers are contiguous. The only latency in this protocol is the travel time of the packet from one player to another. In comparison with other existing protocols, we confirm that the proposed protocol is as fast as and more secure than the fair synchronization protocol, the fastest existing protocol. Key words: real-time network gaming, cheat-proofing, time-stamp service 1...|$|R
40|$|State-of-the-art {{methods for}} {{large-scale}} 3 D reconstruction from RGB-D sensors usually reduce drift in camera tracking by globally optimizing the estimated camera poses in real-time without simultaneously updating the reconstructed surface on pose changes. We propose an efficient on-the-fly surface correction method for globally consistent dense 3 D reconstruction of large-scale scenes. Our approach uses a dense Visual RGB-D SLAM system that estimates the camera motion in real-time on a CPU and refines it {{in a global}} pose graph optimization. Consecutive RGB-D frames are locally fused into keyframes, which are incorporated into a sparse voxel <b>hashed</b> <b>Signed</b> Distance Field (SDF) on the GPU. On pose graph updates, the SDF volume is corrected on-the-fly using a novel keyframe re-integration strategy with reduced GPU-host streaming. We demonstrate in an extensive quantitative evaluation that our method is up to 93 % more runtime efficient compared to the state-of-the-art and requires significantly less memory, with only negligible loss of surface quality. Overall, our system requires only a single GPU and allows for real-time surface correction of large environments. Comment: British Machine Vision Conference (BMVC), London, September 201...|$|R
5000|$|Furthermore, if φ is the {{transformation}} implemented by a hashing trick with a <b>sign</b> <b>hash</b> ξ (i.e. φ(x) is the feature vector produced for a sample x), then inner {{products in the}} hashed space are unbiased: ...|$|R
30|$|Another key {{function}} of Twitter {{is the use}} of “hashtags”. Putting a “#” (<b>hash)</b> <b>sign</b> in front of a certain word is a simple way of adding context to a message. This can be a name (e.g. #obama), an event (e.g. #election 2016), a movement (#refugeeswelcome), a conference (e.g. #futuresconference 2015) or anything else. By adding a hashtag to a Tweet, the referred word receives the informal {{function of}} a topic. Thus, hashtags are helpful when sharing news, knowledge or general contributions to a certain topic, and to spread information across networks of interest. Conversely, hashtags make it easy to search and collate information, discussions or central actors regarding a specific theme [10, 37]. Also, hashtags can be especially useful when Twitter is used as a communication platform, for example during a conference to share ideas, impressions, comments and additional materials on a “#channel“[11].|$|E
40|$|Abstract. In Protégé, any {{newly created}} RDF/OWL {{knowledge}} base refers to local instances through a local URI, which is obtained through the concatenation of the ontology URI, the <b>hash</b> <b>sign</b> # {{and a local}} identifier. However, this practice makes data-level integration quite hard, and definitely prevents the straightforward application of RDF graph merging for independently developed knowledge bases, even if they share the same OWL ontology. In this paper, we present a Protégé plugin which supports the systematic reuse of global identifiers for instances in RDF/OWL knowledge base. The plugin {{is an extension of}} the Protégé “Individuals” tab. The main difference is that, when an instance is created, the user has a chance of looking for an existing URI for the corresponding individual in a publicly available service called Okkam. The match between the newly created instance and the globally registered individuals is based on a comparison of features of the new and a a simple profile stored in Okkam for all individuals. The plugin is available and tested for Protégé 3. 3. 1 and 3. 4 beta. ...|$|E
50|$|The {{signature}} schemes {{are actually}} signatures with appendix, {{which means that}} rather than signing some input datadirectly, a hash function is used first to produce an intermediary representation of the data, and then {{the result of the}} <b>hash</b> is <b>signed.</b> This technique is almost always used with RSA because the amount of data that can be directly signed is proportional {{to the size of the}} keys; which is almost always much smaller than the amount of data an application may wish to sign.|$|R
3000|$|KBytes of {{the program}} image). Deng et al. [8] also employ a <b>signed</b> <b>hash</b> scheme, but use a tree {{structure}} that allows packet verification even when packets arrive out of order. A recent extension called Seluge in [9] further enhances security in Deluge to address various DoS attacks.|$|R
40|$|Numerous {{applications}} in search, databases, machine learning, and computer vision, {{can benefit from}} efficient algorithms for near neighbor search. This paper proposes a simple framework for fast near neighbor search in high-dimensional binary data, which are common in practice (e. g., text). We develop a very simple and effective strategy for sub-linear time near neighbor search, by creating hash tables directly using the bits generated by b-bit minwise hashing. The advantages of our method are demonstrated through thorough comparisons with two strong baselines: spectral <b>hashing</b> and <b>sign</b> (1 -bit) random projections. NSF Grant # 113184...|$|R
40|$|We {{initiate}} {{the investigation of}} a new kind of e ciency for cryptographic transformations. The idea is that having once applied the transformation to some document M, the time to update the result upon modi cation of M should be &quot; to the of modi cation&quot; done to M. Thereby one obtains much faster cryptographic primitives for environments where closely related documents are undergoing the same cryptographic transformations. We provide some basic de nitions enabling treatment of the new notion. We then exemplify our approach by suggesting incremental schemes for <b>hashing</b> and <b>signing</b> which are e cient according to our new measure...|$|R
5000|$|On 4 June 2009, Ali Mahamud Embarek {{presented}} his credentials {{as the new}} Ambassador of the Sahrawi Arab Democratic Republic in Panama. [...] On 17 March 2010, Vice President of Panama Juan Carlos Varela and the Sahrawi Delegate Minister in Charge of Latin America <b>Hash</b> Ahmed <b>signed</b> a cultural and educational cooperation convention, giving Sahrawi students and professionals the opportunity of travelling to Panama to make advanced, specialized and grade studies. In September 2011, the Foreign Minister of Panama Roberto Henriquez while meeting the SADR Ambassador in Panama, {{stressed the importance of}} cooperation that both countries conducted in education and culture.|$|R
40|$|Need to {{establish}} trust in remote systems- Is this the machine I expect?- What is the machine’s integrity {{state at the}} time that I communicated with it? • Solution: Build from a hardware root of trust 1. Each component measures (hashes) the next component at load time before transferring control 2. Use measurements to create a hash chain rooted in TPM 3. Present a <b>hash</b> chain <b>signed</b> by the TPM (quote) to other hosts to prove system integrity state • Limitations of load time integrity measurement- Stale measurements for long running processes- Does not detect compromised code created after load time (Just-in-time (JIT) compiled code, interpreted script...|$|R
5000|$|... 1. Lamport One-Time Signatures. Proposed in 1979 by Leslie Lamport. Lamport {{one-time}} signatures {{are based}} on cryptographic <b>hash</b> functions. For <b>signing</b> a message, the signer just sends a list of hash values (outputs of a hash function) to a publishing server and therefore the signature process is very fast, though {{the size of the}} signature is many times larger, compared to ordinary public-key signature schemes.|$|R
5000|$|A key {{decision}} is the formatting {{of the text}} such that minimal markup language can be inserted to assist the software agent while maintaining readability. To be a Ricardian Contract, {{it has to be}} parsable both by the program and by a human reader. Further, the format has to support a canonical form hash (cryptographic hash function), that is, have a way of delivering a hash over contents that does not change due to common serialisation and transmission artifacts.LaTeX or Ini file format are suitable because they allow consistent readability by humans.Popular and standardised formats such as JSON, XML and Semantic Web might appeal to programmers but provide less readability to jurists. [...] Some formats also suffer from too much markup flexibility such as whitespace which makes <b>hashing</b> and <b>signing</b> hard.|$|R
50|$|To prevent {{spoofing}} attacks, where a cracker {{would try}} to pass off an assembly appearing as something else, the assembly is signed with a private key. The developer of the intended assembly keeps the private key secret, so a cracker cannot have access to it nor simply guess it. Thus the cracker cannot make his assembly impersonate something else, lacking the possibility to sign it correctly after the change. Signing the assembly involves taking a hash of important parts of the assembly and then encrypting the hash with the private key. The <b>signed</b> <b>hash</b> is stored in the assembly along with the public key. The public key will decrypt the <b>signed</b> <b>hash.</b> When the CLR loads a strongly named assembly it will generate a hash from the assembly and then compare this with the decrypted hash. If the comparison succeeds then {{it means that the}} public key in the file (and hence the public key token) is associated with the private key used to sign the assembly. This will mean that the public key in the assembly is the public key of the assembly publisher and hence a spoofing attack is prevented.|$|R
40|$|Abstract: We {{describe}} the design, implementation, {{and evaluation of}} Depot, a cloud storage system that minimizes trust assumptions. Depot assumes less than any prior system about the correct operation of participating hosts—Depot tolerates Byzantine failures, including malicious or buggy behavior, by any number of clients or servers—yet provides safety and availability guarantees (on consistency, staleness, durability, and recovery) that are useful. The key to safeguarding safety without sacrificing availability (and vice versa) in this environment is to join forks: participants (clients and servers) that observe inconsistent behaviors by other participants can join their forked view into a single view {{that is consistent with}} what each individually observed. Our experimental evaluation suggests that the costs of protecting the system are modest. Depot adds a few hundred bytes of metadata to each update and each stored object, and requires <b>hashing</b> and <b>signing</b> each update. ...|$|R
50|$|Then {{the digital}} {{signature}} of the TSA needs to be validated. This {{can be done by}} checking that the <b>signed</b> <b>hash</b> provided by the TSA was indeed signed with their private key by digital signature verification. The hash A is compared with the hash B inside the signed TSA message to confirm they are equal, proving that the timestamp and message is unaltered and was issued by the TSA. If not, then either the timestamp was altered or the timestamp was not issued by the TSA.|$|R
40|$|We {{initiate}} {{the investigation of}} a new kind of efficiency for cryptographic transformations. The idea is that having once applied the transformation to some document M, the time to update the result upon modification of M should be "proportional" to the "amount of modification" done to M. Thereby one obtains much faster cryptographic primitives for environments where closely related documents are undergoing the same cryptographic transformations. We provide some basic definitions enabling treatment of the new notion. We then exemplify our approach by suggesting incremental schemes for <b>hashing</b> and <b>signing</b> which are efficient according to our new measure. Advanced Networking Laboratory, IBM T. J. Watson Research Center, P. O. Box 704, Yorktown Heights, NY 10598, USA. e-mail: mihir@watson. ibm. com. y Department of Applied Mathematics and Computer Science, Weizmann Institute of Science, Rehovot, Israel. e-mail: oded@wisdom. weizmann. ac. il. Research was partially supported by grant [...] ...|$|R
40|$|We {{present a}} method to notarize a paper document. This method computes a set of {{features}} from the page, inputs these features into a <b>hash</b> function, digitally <b>signs</b> the output, and then prints the resulting signature on the page. The notarized document is self-contained: verification does not require reference to online information. Introduction. Authentication of digital data is a wellstudied problem in computer science [8], but many important, long-lived documents are still available only on paper. Paper is traditionally authenticated either through elaborate printing techniques (as in money) or through trusted signature...|$|R
50|$|The document, email, or file to be {{protected}} is used to generate a <b>signed</b> <b>hash,</b> a number generated from {{the contents of the}} document. Any change to the document, no matter how trivial, such as changing a single bit from a 1 to a 0, will cause it to have a different hash, which will make the signature invalid. To alter a document while purposely maintaining the same hash, assuming the hash function and the program implementing it are properly designed, is extremely difficult. See avalanche effect and hash collision.|$|R
5000|$|The sharp symbol (...) may be {{confused}} with the number (<b>hash</b> or pound) <b>sign</b> (#). Both signs have two sets of parallel double-lines. However, a correctly drawn sharp sign must have two slanted parallel lines which rise from left to right, to avoid being obscured by the staff lines. The number sign, in contrast, has two compulsory horizontal strokes in this place. In addition, while the sharp also always has two perfectly vertical lines, the number sign (#) may or may not contain perfectly vertical lines (according to typeface and writing style).|$|R
50|$|Ganchev and Dredze {{showed that}} in text {{classification}} applications with random hash functions and several {{tens of thousands of}} columns in the output vectors, feature hashing need not have an adverse effect on classification performance, even without the <b>signed</b> <b>hash</b> function.Weinberger et al. applied their variant of hashing to the problem of spam filtering, formulating this as a multi-task learning problem where the input features are pairs (user, feature) so that a single parameter vector captured per-user spam filters as well as a global filter for several hundred thousand users, and found that the accuracy of the filter went up.|$|R
