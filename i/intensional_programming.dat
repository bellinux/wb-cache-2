47|29|Public
40|$|Abstract. This article {{investigates the}} <b>intensional</b> <b>programming</b> {{paradigm}} for agent communication by introducing context {{as a first}} class object in the <b>intensional</b> <b>programming</b> language Lucid. For the language thus extended, a calculus of contexts and a logic of contexts are provided. The paper gives definitions, syntax, and operators for context, and introduces an operational semantics for evaluating expressions in extended Lucid. It is shown that the extended Lucid language, called Agent <b>Intensional</b> <b>Programming</b> Language(AIPL), has the generality and the expressiveness for being an Agent Communication Language(ACL) ...|$|E
40|$|<b>Intensional</b> <b>Programming</b> {{involves}} the programming of expressions {{placed in an}} inherent multidimensional context space. It is an emerging and highly dynamic domain of general application. The fast growing computer connectivity allows {{for more and more}} efficient implementation of distributed applications. The paradigm of intensionality inherently includes notions of parallelism at different levels. However, the currently available <b>intensional</b> <b>programming</b> software tools are becoming obsolete and do not enable us to further push forward practical investigations on the subject. Experience shows that the theoretical advancement of the field has come to acceptable maturity. Consequently, new powerful tools for <b>intensional</b> <b>programming</b> are required. In this paper, we present the design of a General <b>Intensional</b> <b>Programming</b> System (GIPSY). The design and implementation of the GIPSY reflect three main goals: generality, adaptability and efficiency...|$|E
40|$|<b>Intensional</b> <b>programming</b> implies {{declarative}} programming, in {{the sense}} of Lucid, based on denotational semantics where the declarations are evaluated in an inherent multi-dimensional context space. The General <b>Intensional</b> <b>Programming</b> System (GIPSY) is a hybrid multi-language programming platform and a demand-driven execution environment. GIPSY aims at the long-term investigation into the possibilities of <b>Intensional</b> <b>Programming.</b> The GIPSY's compiler, GIPC, is based on the notion of Generic <b>Intensional</b> <b>Programming</b> Language (GIPL) which solved the problem of language-independence of the runtime system by allowing a common representation for all compiled programs, the Generic Eduction Engine Resources (GEER). In this thesis, we discuss the solution to GIPSY's Runtime System. The Multi-Tier framework which consists of Demand Generator Tier (DGT), Demand Store Tier (DST) and Demand Worker Tier (DWT), offers demand-driven, distributed execution and technology independent manners by integrating the previous research on the demand migration middle-ware implemented by Jini and Java Message Service (JMS...|$|E
40|$|In {{this paper}} we {{demonstrate}} that a broad class of higher-order functional {{programs can be}} transformed into semantically equivalent multidimensional <b>intensional</b> <b>programs</b> that contain only nullary variable definitions. The proposed algorithm systematically eliminates user-defined functions from the source program, by appropriately introducing context manipulation (i. e. intensional) operators. The transformation takes place in M steps, where M is {{the order of the}} initial functional program. During each step the order of the program is reduced by one, and the final outcome of the algorithm is an M-dimensional <b>intensional</b> <b>program</b> of order zero. As the resulting intensional code can be executed in a purely tagged-dataflow way, the proposed approach o#ers a promising new technique for the implementation of higher-order functional languages. ...|$|R
40|$|AbstractIntensional Logic Programming is a {{new form}} of logic <b>programming</b> based on <b>intensional</b> logic and {{possible}} worlds semantics. Intensional logic allows us to use logic programming to specify nonterminating computations and to capture the dynamic aspects of certain problems in a natural and problem-oriented style. The meanings of formulas of an intensional first-order language are given according to intensional interpretations and to elements of a set of possible worlds. Neighborhood semantics is employed as an abstract formulation of the denotations of intensional operators. Then we investigate general properties of intensional operators such as universality, monotonicity, finitariness and conjunctivity. These properties are used as constraints on <b>intensional</b> logic <b>programming</b> systems. The model-theoretic and fixpoint semantics of <b>intensional</b> logic <b>programs</b> are developed in terms of least (minimum) intensional Herbrand models. We show in particular that our results apply to a number of <b>intensional</b> logic <b>programming</b> languages such as Chronolog proposed by Wadge and Templog by Abadi and Manna. We consider some elementary extensions to the theory and show that <b>intensional</b> logic <b>program</b> clauses can be used to define new intensional operators. <b>Intensional</b> logic <b>programs</b> with <b>intensional</b> operator definitions are regarded as metatheories...|$|R
40|$|The {{intensional}} {{transformation is}} a technique {{that can be used}} in order to eliminate higher-order functions from a functional pro- gram by introducing appropriate context manipulation operators. The transformation can be applied to a significant class of higher-order pro- grams and results in equivalent zero-order <b>intensional</b> <b>programs</b> that can be executed in a simple demand-driven way. Despite its simplicity, th...|$|R
40|$|Abstract. We {{explore the}} {{suitability}} of <b>Intensional</b> <b>Programming</b> Paradigm for providing a programming model for coordinated problem solving in a multi-agent systems. We extend our previous work on Lucx, an <b>Intensional</b> <b>Programming</b> Language extended with context as first class object, to support coordination activities in a distributed network of agents. We study coordination constructs which {{can be applied to}} sequential programs and distributed transactions. We give formal syntax and semantics for coordination constructs. The semantics for transaction expressions is given on top of the existing operational semantics in Lucx. The extended Lucx can be used for internet-based agent applications. Keywords: Multi-agent systems, coordinated transactions, <b>Intensional</b> <b>Programming</b> Language, coordination constructs...|$|E
40|$|We {{describe}} a type {{system for a}} platform called the General <b>Intensional</b> <b>Programming</b> System (GIPSY), designed to support <b>intensional</b> <b>programming</b> languages built upon intensional logic and their imperative counter-parts for the intensional execution model. In GIPSY, the type system glues the static and dynamic typing between intensional and imperative languages in its compiler and run-time environments to support the intensional evaluation of expressions written in various dialects of the <b>intensional</b> <b>programming</b> language Lucid. The intensionality makes expressions to explicitly take into the account a multidimensional context of evaluation with the context being a first-class value that serves a number of applications that need the notion of context to proceed. We {{describe a}}nd discuss the properties of such a type system and the related type theory as well as particularities of the semantics, design {{and implementation of the}} GIPSY type system. Comment: 12 pages, 1 table; 2 figure...|$|E
40|$|<b>Intensional</b> <b>Programming</b> {{involves}} the programming of expressions {{placed in an}} inherently multidimensional context space. It is an emerging and evolving domain of very general application. The General <b>Intensional</b> <b>Programming</b> System (GIPSY) aims at {{the implementation of a}} programming system that would allow very dynamic investigations on the possibilities of <b>Intensional</b> <b>Programming.</b> Intensional Value Warehouse (IVW), a part of General Eduction Engine (GEE) that is the back end of GIPSY, is built as storage of values that have already been computed. First of all, this thesis briefly introduces the GIPSY and its features and goals. Then, we describe the design methodology and principle. Afterwards, we give the detail of implementation of the IVW. In the IVW, we build a garbage collector that promotes the deleted data or writes them to file, which is different from the typical garbage collector. The use of garbage collector configured to it is of prime importance to obtain high performance. Further, we discuss the result of the IVW which approaches the main goals of generality, adaptability and efficiency. Finally, we successfully integrate IVW to GEE in overall GIPSY system...|$|E
40|$|Intensional {{communities}} {{are composed of}} <b>intensional</b> <b>programs</b> shar-ing a common context, implemented using a networked context server, called the AEPD aether process daemon. The programs are written in the ISE intensional imperative scripting language, which is illustrated through versioned assignments in undergraduate classes. Using this model of in-tensional communities, two examples are developed: a Web-based class in which a teacher leads a student through a multidimensional page, and the programming of chatrooms. ...|$|R
40|$|Abstract. The {{intensional}} {{transformation is}} a technique {{that can be used}} in order to eliminate higher-order functions from a functional program by introducing appropriate context manipulation operators. The transformation can be applied to a significant class of higher-order programs and results in equivalent zero-order <b>intensional</b> <b>programs</b> that can be executed in a simple demand-driven way. Despite its simplicity, the transformation has never been seriously evaluated with respect to its efficiency and potential. Certain simple implementations of the technique have been performed, but the questions regarding the merits of the method have remained inconclusive. In this paper we demonstrate that the transformation can be efficiently implemented by using what we call lazy activation records, namely activation records in which some entries are filled on-demand. An evaluation of our implementation demonstrates that the technique outperforms some of the most well-known functional programming systems, for the class of programs that can be transformed. ...|$|R
40|$|This paper {{presents}} an object-oriented implementation of Lucid. We implement each variable in a Lucid {{program as a}} class. An object of the class is the variable in a context. An object evaluates itself when it receives a demand for its value and stores the value. Evaluation of a program involves object self-evaluations and message passing of demands among objects. Some optimization issues are also discussed in the paper. 1 Introduction Object-oriented programming {{has become one of}} the main stream paradigms for software construction. We may consider to incorporate object-oriented technology in development of intensional languages at two levels. At the language extension level, we may add the concept of objects into intensional languages. [FB 91] and [DF 94] have addressed this issue. At the implementation level, we may use object-oriented techniques to compile <b>intensional</b> <b>programs</b> to object-oriented programs. This is addressed in this paper. Intensional languages are implemented ba [...] ...|$|R
40|$|<b>Intensional</b> <b>Programming</b> {{involves}} the programming of expressions {{placed in an}} inherent multidimensional context space. It is an emerging and highly dynamic domain of general application. The fast growing computer connectivity allows {{for more and more}} efficient implementation of distributed applications...|$|E
40|$|<b>Intensional</b> <b>programming</b> systems allow programmers to {{directly}} manipulate inten- sions, i. e. values that vary over {{a space of}} indices. Intensional operators transform their operands by combining values from different contexts. Intensional languages normally use a generalized dataflow computation model...|$|E
40|$|<b>Intensional</b> <b>Programming</b> is a {{declarative}} programming {{paradigm in}} which expressions are evaluated in an inherently multidimensional context space. The Lucid family of programming languages is, to this day, the only programming languages of true intensional nature. Lucid being a functional language, Lucid programs are inherently parallel and their parallelism can be efficiently exploited by the adjunction of a procedural language {{to increase the}} granularity of its parallelism, forming hybrid Lucid languages. That very wide array of possibilities raises {{the need for an}} extremely flexible programming language investigation platform to investigate on this plethora of possibilities for <b>Intensional</b> <b>Programming.</b> That is the purpose of the General <b>Intensional</b> <b>Programming</b> System (GIPSY), especially, the General <b>Intensional</b> <b>Programming</b> Compiler (GIPC) component. The modularity, reusability and extensibility aspects of the framework approach make it an obvious candidate {{for the development of the}} GIPC. The framework presented in this thesis provides a better solution compared to all other techniques used to this day to implement the different variants of <b>intensional</b> <b>programming.</b> Because of the functionality of hybrid programming support in the GIPC framework, a new OO-IP hybrid language is designed for further research. This new hybrid language combines the essential characteristics of IPL and Java, and introduces the notion of object streams which makes it is possible that each element in an IPL stream could be an object with embedded intensional properties. Interestingly, this hybrid language also brings to Java objects the power which can explicitly express context, creating the novel concept of intensional objects, Le. objects whose evaluation is context-dependent, which are therein demonstrated to be translatable into standard objects. By this new feature, we extend the use and meaning of the notion of object and enrich the meaning of stream in IPL and semantics of Java. At the same time, during the procedure to introduce intensional objects and this OO-IP hybrid language, many factors are considered. These factors include how to integrate the new language with the GIPC framework design and the issues related to its integration in the current GIPSY implementation. Current semantic rules show that the new language can work well with the GIPC framework and the GIPSY implementation, which is another proof of the validity of our GIPC framework design. Ultimately, the proposed design is put into implementation in the GIPSY and the implementation put to test using programs from different application domains written in this new OO-IP languag...|$|E
40|$|The {{intensional}} {{transformation is}} a technique {{that can be used}} in order to eliminate higher-order functions from a functional program by introducing appropriate context-manipulation operators. The transformation can be applied to a significant class of higher-order programs and results in equivalent zero-order <b>intensional</b> <b>programs</b> that can be executed in a simple demand-driven way. Despite its simplicity, the transformation has never been seriously evaluated with respect to its efficiency and potential. Certain simple implementations of the technique have been performed, but questions regarding the merits of the method have remained inconclusive. In this paper we demonstrate that the transformation can be efficiently implemented by using what we call lazy activation records, namely activation records in which some entries are filled on-demand. An evaluation of our implementation demonstrates that the technique outperforms some of the most well-known functional programming systems, for the class of programs that can be transformed. © 2008 Birkhäuser Verlag Basel/Switzerland...|$|R
40|$|Recently, a novel {{transformation}} {{technique for}} Datalog programs, called the branching transformation, {{was introduced by}} the authors. In this {{paper we propose a}} signicant extension of the branching transformation which we believe opens-up a promising new direction of {{research in the area of}} value-propagating Datalog optimizations. One of the novel characteristics of the proposed approach is that the target language is DatalognS extended with choice predicates, a form of non-deterministic construct that was originally introduced in the area of <b>intensional</b> logic <b>programming.</b> Keywords: Logic Program Transformations, Deductive Databases. ...|$|R
40|$|The GIPSY system {{provides}} a framework for a distributed multi-tier demand-driven evaluation of heterogeneous programs, in which certain tiers can generate de-mands, while others can respond to demands to work on them. They are connected through a virtual network that can be flexibly reconfigured at run-time. Although the demand generator components were originally designed specifically for the educ-tive (demand-driven) evaluation of Lucid <b>intensional</b> <b>programs,</b> the GIPSY’s run-time’s flexible framework design enables it to perform the execution of various kinds of programs that can be evaluated using the demand-driven computational model. Management of the GISPY networks has become a tedious (although scripted) task that took manual command-line console to do, which does not scale for large exper-iments. Therefore a new component has been designed and developed to allow users to represent, visualize, and interactively create, configure and seamlessly manage such a network as a graph. Consequently, this work presents a Graphical GMT Manager, an interactive graph-based assistant component for the GIPSY network creation and configuration management. Besides allowing {{the management of the}} nodes and tiers (mapped to hosts where store, workers, and generators reside), it lets the user to visually control the network parameters and the interconnection be-tween computational nodes at run-time. In this paper we motivate and present the key features of this newly implemented graph-based component. We give the graph representation details, mapping of the graph nodes to tiers, tier groups, and specific commands. We provide the requirements and design specification of the tool and its implementation. Then we detail and discuss some experimental results. Key...|$|R
40|$|My {{dissertation}} {{presents and}} defends {{the thesis that}} lightweight stack inspection improves the implementation of <b>intensional</b> <b>programming</b> tools and programming language extensions. <b>Intensional</b> <b>programming</b> tools, such as debuggers, need to observe and change the function call behavior of programs as they run. <b>Intensional</b> <b>programming</b> language extensions, such as aspect-oriented programming, behave similarly. Traditionally, these tools and extensions are granted privileged access to the evaluator’s implementation details, particularly the stack. This design can stall further development, particularly the extension of these tools to new platforms and new versions of the evaluator. To solve some of these problems, we propose an alternate architecture. An extension of the language, ”continuation marks, ” allows these tools to obtain runtime information without special privilege, and to operate as annotators on the source language. We claim that this language feature is a simple addition to many runtime systems. We further claim that this architecture results in tools and extensions that are more portable and well-defined. In order to support our claims, we have successfully applied it to three different problems. First, we designed and implemented a stepping debugger. Second, we showed how a security feature, stack inspection, may be expressed. Finally, we consider the implementation of aspects, and particularly those aspects that require information about control flow. iii iv A Failed Dedication No dedication could possibly {{do justice to the}} debt I owe to my wife, Anika...|$|E
40|$|We present {{advances}} in the software engineering design {{and implementation of the}} multi-tier run-time system for the General <b>Intensional</b> <b>Programming</b> System (GIPSY) by further unifying the distributed technologies used to implement the Demand Migration Framework (DMF) in order to streamline distributed execution of hybrid intensional-imperative programs using Java. Comment: 11 pages, 3 figure...|$|E
40|$|This article {{introduces}} Object-Oriented <b>Intensional</b> <b>Programming</b> (OO-IP), a new hybrid language between Object-Oriented and <b>Intensional</b> <b>Programming</b> Languages in {{the sense}} of the latest evolutions of Lucid. This new hybrid language combines the essential characteristics of Lucid and Java, and introduces the notion of object streams which makes it is possible that each element in a Lucid stream to be an object with embedded intensional properties. Interestingly, this hybrid language also brings to Java objects the power to explicitly express and manipulate the notion of context, creating the novel concept of intensional object, i. e. objects whose evaluation is context-dependent, which are here demonstrated to be translatable into standard objects. By this new approach, we extend the use and meaning of the notion of intensional objects and enrich the meaning of object streams in Lucid and semantics of intensional objects in Java. Comment: 27 pages, 8 listings, 2 tables, 5 figure...|$|E
40|$|Denotational {{semantics}} {{is usually}} extensional {{in that it}} deals only with input/output properties of programs by making {{the meaning of a}} <b>program</b> a function. <b>Intensional</b> semantics maps a program into an algorithm, thus enabling one to reason about complexity, order of evaluation, degree of parallelism, efficiency-improving program transformations, etc. I propose to develop intensional models for a number of parallel programming languages. The semantics will be implemented, resulting in a programming language of parallel algorithms, called CDSP. Applications of CDSP will be developed to determine its suitability for actual use. The thesis will hopefully make both theoretical and practical contributions: as a foundational study of parallelism by looking at the expressive power of various constructs, and with the design, implementation, and applications of an <b>intensional</b> parallel <b>programming</b> language. 1 Introduction Denotational semantics has now been around for about 25 years, which makes [...] ...|$|R
40|$|GLU is a text-based hybrid <b>intensional</b> {{language}} for <b>programming</b> conventional parallel computers whose cryptic, linear syntax often obscures static data and dimensional dependencies, thus making program functionality less apparent. We describe two different graphical models for GLU programming [...] - an intensional model based on dependency graphs and an extensional model based on spreadsheets [...] - designed to better present data and dimensional dependencies in GLU programs. We {{compare the two}} models in their respective approaches for revealing latent data and dimensional dependencies in GLU programs...|$|R
40|$|Abstract. The branching-time {{transformation}} {{is a recent}} technique for optimizing Chain Datalog programs. In this {{paper we propose a}} significant extension of the branching-time transformation which we believe opens up a promising new direction of {{research in the area of}} value-propagating Datalog optimizations. More specifically, the proposed transformation can handle more general programs that allow multiple consumptive occurrences of variables in the bodies of clauses. This extension is achieved by using as target language the temporal logic programming formalism Datalog enriched with choice predicates (a non-deterministic construct that was originally introduced in the area of <b>intensional</b> logic <b>programming).</b> We demonstrate the correctness of the transformation and propose several optimizations that can be applied to the target code. Moreover, we define a bottomup proof procedure that applies to the target programs and demonstrate that it always terminates (despite the fact that the Herbrand base of these programs is generally infinite) ...|$|R
40|$|A Forensic Lucid <b>intensional</b> <b>programming</b> {{language}} {{has been proposed}} for intensional cyberforensic analysis. In large part, the language is based on various predecessor and codecessor Lucid dialects bound by the higher-order intensional logic (HOIL) that is behind them. This work formally specifies the operational aspects of the Forensic Lucid language and compiles a theory of its constructs using Isabelle, a proof assistant system...|$|E
40|$|<b>Intensional</b> <b>programming</b> is a {{declarative}} programming paradigm that {{is suitable}} for scientific programming since it allows natural expression of equations regarding multidimensional objects or concepts evolving in a multidimensional context so that the simplicity of these equations are kept. The General <b>Intensional</b> <b>Programming</b> System (GIPSY) project aims at providing a software platform for the long-term investigation of <b>intensional</b> <b>programming.</b> The GIPSY consists of a flexible compiler and a scalable runtime system, where the compiler translates any flavor of intensional program into source-language independent runtime resources, and the runtime system uses the runtime resources to execute the program in a demand-driven and distributed manner, i. e. computation requirements are wrapped into demands and are distributed among networked computers, so that the computations can be executed distributively and concurrently to shorten their overall computation time. The multi-tier architecture adopted for the GIPSY runtime system is for research goals such as scalability. It consists of the Demand Generator Tier that generates demands, the Demand Store Tier that stores and dispatches demands, {{as well as the}} Demand Worker Tier that computes demands. All the tiers are allocated in registered computers called the GIPSY nodes, and all the GIPSY nodes and tiers are under the management of the General Manager Tier, with which new nodes can be registered and new tiers can be allocated at runtime to deal with increasing workload. This thesis covers the development of the scalable GIPSY runtime system using the multi-tier architecture, and presents the assessment of the scalability of the developed GIPSY runtime system...|$|E
40|$|<b>Intensional</b> <b>{{programming}}</b> is a {{programming language}} paradigm based {{on the notion of}} declarative programming where the declarations are evaluated in an inherent multidimensional context space. Program identifiers are evaluated in a context, where each demand is generated, propagated, computed, and stored as an identifier-context pair. General <b>Intensional</b> <b>Programming</b> System (GIPSY) is a hybrid multi-language programming system that overcame the limitation of previous <b>Intensional</b> <b>Programming</b> systems by designing a Demand Migration Framework (DMF) to provide a generic, dynamic, and technology-independent infrastructure. A DMF instance, called a Demand Migration System (DMS), is used to propagate demands from one GIPSY execution node to another. A GIPSY program is executed using three components, each of which possibly having several instances, all of which possibly being executed on different nodes: the Demand Generator (DG), that generates demands according to the compiled Lucid program, the Demand Worker (DW), that executes procedure calls embedded in the Lucid program, and the DMS, that acts as a communication/storage middleware between the latter. This thesis extends the previous investigations on the DMF by applying and extending DMF rationales and design to implement an instance of our DMS using Java Message Service (JMS-DMS). JMS-DMS is an investigation toward having the combination of two paradigms of Message-Oriented Middleware (MOM) and Event-Driven Architecture (EDA) to handle our demand-driven computation. We also investigate on the behavior of our instances in different perspectives such as latency, dispatching, availability, scalability, maintainability, and configurability, which complements our research toward having the robust Demand Migration System...|$|E
40|$|Abstract Game {{semantics}} is {{the most}} recent addition {{to the study of}} semantics of programming languages. Its claim to fame {{lies in the fact that}} it was the first to give a fully abstract model for the programming language PCF. It has been claimed that game semantics can give a more <b>intensional</b> meaning for <b>programs.</b> This paper aims to present a strong connection between game semantics and abstract machines; basically, a step in the abstract machine corresponds to a step in a game. The abstract machines we use are based on proof-nets and proof-net cut elimination...|$|R
40|$|We {{describe}} a denotational, <b>intensional</b> semantics for <b>programs</b> with polymorphic types with bounded quantification, in which phenomena such as inheritance between stateful objects may be represented and studied. Our model is developed from a game semantics for unbounded polymorphism, by establishing dinaturality properties of generic strategies, {{and using them}} to give a new construction for interpreting subtyping constraints and bounded quantification. We use this construction to give a denotational semantics for a programming language with general references and an expressive polymorphic typing system. We show that full abstraction fails in general in this model, but that it holds for all terms at a rich collection of bounded types...|$|R
40|$|In {{this paper}} we {{describe}} {{a method for}} verifying secure information flow of programs, where apart from direct and indirect flows a secret information can be leaked through covert timing channels. That is, no two computations of a program that differ only on high-security inputs can be distinguished by low-security outputs and timing differences. We attack this problem by using slot-game semantics for a quantitative analysis of programs. We show how slot-games model {{can be used for}} performing a precise security analysis of programs, that takes into account both extensional and <b>intensional</b> properties of <b>programs.</b> The practicality of this approach for automated verification is also shown. ...|$|R
40|$|Abstract. A Forensic Lucid <b>intensional</b> <b>programming</b> {{language}} {{has been proposed}} for intensional cyberforensic analysis. In large part, the language is based on various predecessor and codecessor Lucid dialects bound by the higher-order intensional logic (HOIL) that is behind them. This work formally specifies the operational aspects of the Forensic Lucid language and compiles a theory of its constructs using Isabelle, a proof assistant system. ...|$|E
40|$|We present here an {{exploratory}} and investigatory {{study of the}} requirements, design, and implementation of two opensource software systems: the Distributed Modular Audio Recognition Framework (DMARF), and the General <b>Intensional</b> <b>Programming</b> System (GIPSY). The inception, development, and evolution of the two systems have overlapped {{and in terms of}} the involved developers, as well as in their applications. DMARF is a platform independent collection of algorithms for pattern recognition, identification and signal processing in audio and natural language text samples, become a rich platform for the research community in particular to use, test, and compare various algorithms in the broad field of pattern recognition and machine learning. Intended as a platform for <b>intensional</b> <b>programming,</b> GIPSY's inception was intended to push the field of <b>intensional</b> <b>programming</b> further, overcoming limitations in the available tools two decades ago. In this study, we present background research into the two systems and elaborate on their motivations and the requirements that drove and shaped their design and implementation. We subsequently elaborate in more depth about various aspects their architectural design, including the elucidation of some use cases, domain models, and the overall class diagram of the major components. Moreover, we investigated existing design patterns in both systems and provided a detailed view of the involved components in such patterns. Furthermore, we delve deeper into the guts of both systems, identifying code smells and suggesting possible refactorings. Patchsets of implementations of selected refactorings have been collected into patchsets and could be committed into future releases of the two systems, pending a review and approval of the developers and maintainers of DMARF and GIPSY. Comment: Team 6, SOEN 6471 Summer 2014; 67 page...|$|E
40|$|In {{this paper}} {{we report on}} our {{re-engineering}} effort to refactor and unify two somewhat disjoint Java distributed middleware technologies – Jini and JMS – used in the implemen-tation of the Demand Migration System (DMS). In doing so, we refactor their parent De-mand Migration Framework (DMF), within the General <b>Intensional</b> <b>Programming</b> System (GIPSY). The complex Java-based GIPSY project is used to investigate on the intensional and hybrid programming paradigms. ...|$|E
40|$|Recently {{there has}} been an {{increasing}} interest in incorporating “intensional ” functions in answer set <b>programming.</b> <b>Intensional</b> functions are those whose values can be described by other functions and predicates, rather than being pre-defined as in the standard answer set programming. We demonstrate that the functional stable model semantics {{plays an important role in}} the framework of “Answer Set Programming Modulo Theories (ASPMT) ” —a tight integration of answer set programming and satisfiability modulo theories, under which existing integration approaches can be viewed as special cases where the role of functions is limited. We show that “tight ” ASPMT programs can be translated into SMT instances, which is similar to the known relationship between ASP and SAT. ...|$|R
40|$|GLU is {{a hybrid}} <b>intensional</b> {{language}} for <b>programming</b> conventional parallel computers in which parallel programs are constructed by composing sequential, granular C functions using Lucid, a purely intensional language. Parallelism {{implicit in the}} Lucid specification is exploited at runtime using eduction, an intensional model of computation. We describe a basic eduction-based parallel implementation of GLU consisting of a single master process and multiple stateless worker processes. Using the CM- 5, we show that this GLU implementation has limited performance scalability, especially when the granularity of parallelism is not sufficiently coarse. We show how the scalability can be improved by decentralizing some state from the master to the workers. We then propose a new eduction-based parallel implementation of GLU using multiple masters {{that is designed to}} be more scalably efficient than either of the single-master parallel implementations...|$|R
40|$|Programs that {{transform}} {{other programs}} often require {{access to the}} internal structure of the program to be transformed. This {{is at odds with}} the usual extensional view of functional programming, as embodied by the lambda calculus and SK combinator calculus. The recently-developed SF combinator calculus offers an alternative, intensional model of computation that may serve as a foundation for developing principled languages in which to express <b>intensional</b> computation, including <b>program</b> transformation. Until now there have been no static analyses for reasoning about or verifying programs written in SF-calculus. We take the first step towards remedying this by developing a formulation of the popular control flow analysis 0 CFA for SK-calculus and extending it to support SF-calculus. We prove its correctness and demonstrate that the analysis is invariant under the usual translation from SK-calculus into SF-calculus. Comment: In Proceedings VPT 2015, arXiv: 1512. 0221...|$|R
