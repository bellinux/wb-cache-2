651|10000|Public
5|$|The B-52E {{received}} an updated avionics and bombing navigational system, which was eventually <b>debugged</b> and included on following models.|$|E
5|$|The {{electronics}} {{of the new}} ENIAC ran at one-sixth the speed, {{but this}} in no way degraded the ENIAC's performance, since it was still entirely I/O bound. Complicated programs could be developed and <b>debugged</b> in days rather than the weeks required for plugboarding the old ENIAC. Some of von Neumann's early computer programs have been preserved.|$|E
5|$|According to {{developer}} Matthew Dillon, {{progress is}} being made to provide both device input/output (I/O) and virtual file system (VFS) messaging capabilities that will enable the remainder of the project goals to be met. The new infrastructure will allow many parts of the kernel to be migrated out into userspace; here they will be more easily <b>debugged</b> as they will be smaller, isolated programs, instead of being small parts entwined in a larger chunk of code. Additionally, the migration of select kernel code into userspace has the benefit of making the system more robust; if a userspace driver crashes, it will not crash the kernel.|$|E
50|$|Exclusive C++ <b>debugging</b> tools, {{including}} remote <b>debugging</b> for distributed development (COM and CORBA); multi-process and cross-process <b>debugging</b> with <b>debug</b> inspectors, dynamic watch windows, and <b>debug</b> tooltips.|$|R
50|$|To support in-circuit <b>debugging</b> and {{programming}} requirements, the HC08 Family has the monitor mode and the HCS08 and RS08 utilize a background <b>debug</b> mode (BDM). The background <b>debug</b> hardware on the HCS08 {{consists of a}} background <b>debug</b> controller (BDC) and <b>debug</b> module (DBG). The background <b>debug</b> hardware on the RS08 consists of the background <b>debug</b> controller (BDC) only.|$|R
40|$|A {{system for}} <b>debugging</b> {{applications}} at resource-constrained virtual machines may include a target device configured {{to host a}} lightweight <b>debug</b> agent to obtain <b>debug</b> information from one or more threads of execution at a virtual machine executing at the target device, and a <b>debug</b> controller. The lightweight <b>debug</b> agent may include a plurality of independently deployable modules. The <b>debug</b> controller may be configured to select {{one or more of}} the modules for deployment at the virtual machine for a <b>debug</b> session initiated to <b>debug</b> a targeted thread, to deploy the selected modules at the virtual machine for the <b>debug</b> session, and to receive <b>debug</b> information related to the targeted thread from the lightweight <b>debug</b> agent during the session...|$|R
5|$|In December 1974 Bill Gates was {{a student}} at Harvard University and Paul Allen worked for Honeywell in Boston. They saw the Altair 8800 {{computer}} in the January 1975 issue of Popular Electronics and knew it was powerful enough to support a BASIC interpreter. They wanted {{to be the first to}} offer BASIC for the Altair computer, and the software development tools they had previously created for their Intel 8008 microprocessor based Traf-O-Data computer would give them a head start. While their friend, Paul Gilbert, was building the computer, Allen wrote a program that ran on a DEC PDP-10 time-sharing computer that simulated the 8008 system. He also modified DEC's macro assembler to produce the machine code for the 8008 microprocessor. The Traf-O-Data software could be written and <b>debugged</b> before the computer hardware was complete.|$|E
5|$|After {{the success}} of Pong, Bushnell pushed his {{employees}} to create new products. In 1974, Atari engineer Harold Lee proposed a home version of Pong that would connect to a television: Home Pong. The system began development under the codename Darlene, named after an attractive female employee at Atari. Alcorn worked with Lee to develop the designs and prototype, and based them on the same digital technology used in their arcade games. The two worked in shifts to save time and money; Lee worked on the design's logic during the day, while Alcorn <b>debugged</b> the designs in the evenings. After the designs were approved, fellow Atari engineer Bob Brown assisted Alcorn and Lee in building a prototype. The prototype consisted of a device attached to a wooden pedestal containing over a hundred wires, which would eventually be replaced with a single chip designed by Alcorn and Lee; the chip {{had yet to be}} tested and built before the prototype was constructed. The chip was finished {{in the latter half of}} 1974, and was, at the time, the highest-performing chip used in a consumer product.|$|E
5|$|With {{the journal}} <b>debugged,</b> Data-Riku uncovers extra data that {{contains}} the secret to the journal's message. Mickey guides the reset Data-Sora to the extra world where he is tested by a virtual Roxas to endure the pain of having forgotten his friends {{as a result of}} being reset. Data-Sora defeats Data-Roxas and is allowed access to the deepest portion of Castle Oblivion. There he and Mickey encounter a virtual Naminé, who reveals the real Naminé as the one who left the message after discovering a set of memories relating to the people tied to the real Sora's heart—Roxas, Axel, Xion, Terra, Aqua, and Ventus—while restoring his lost memories; the bugs are also revealed to have been an unintentional side effect of her message. Before disappearing, Data-Naminé explains that it is the real Sora's duty to save these people. Mickey relays this message to Sora through the bottled letter shown at the end of Kingdom Hearts II.|$|E
40|$|<b>Debugging</b> of {{embedded}} systems is costly and time consuming,but imperative to system design. There {{are many different}} requirements on {{embedded systems}} and complying with these requirements has lead to many different kinds, and different configurations of embedded systems. The vast array of embedded systems, and the ever increasing complexity of the systems make <b>debugging</b> a growing challenge. Different domains impose different requirements on the systems and as embedded system pervade in our society, new requirement are introduced. ENEA’s products target various domains as: telecom, medical and the automotive domain. Targeting these three domains means that ENEA’s products need to comply with various, and stringent requirements. A <b>debugging</b> tool used in a tool chain like the tool chain developed in the iFEST project, as intended for ENEA’s <b>debugging</b> tool Optima, needs to support various <b>debugging</b> methods, ranging from software <b>debugging</b> methods to methods utilizing embedded hardware for <b>debugging.</b> The need for <b>debugging</b> tools in a tool chain to support various <b>debugging</b> methods lead to this master’s thesis, at and for ENEA. This thesis investigates methods to <b>debug</b> embedded systems in order to define enhancements of the <b>debugging</b> tool Optima that enables Optima to <b>debug</b> various systems and to <b>debug</b> all systems in ENEA’s target domains. The thesis {{is divided into two}} parts: a pre-study and a development part. The pre-study covers <b>debugging</b> of embedded systems by studying articles and ENEA’s operating system OSE and <b>debugging</b> tool Optima. Conclusion drawn from the study of methods to <b>debug</b> embedded systems and the study of the <b>debugging</b> support in Optima, show that Optima needs to utilize embedded hardware for <b>debugging.</b> Updates for Optima that enable utilization of embedded hardware for <b>debugging</b> are designed and implemented in the development part of the thesis. Hardware <b>debugging</b> facilities in the development platform targeted in this thesis are not fully incorporated. The lack of hardware <b>debugging</b> support in the platform makes it infeasible to <b>debug</b> the platform from software running on the processor core, and thus infeasible to improve Optima’s <b>debugging</b> capability by enhancing standard OSE <b>debugging</b> facilities to utilize embedded hardware for <b>debugging.</b> An external <b>debugging</b> tool, JTAG, is required to access the embedded <b>debugging</b> hardware in the target platform and to enable non-intrusive <b>debugging...</b>|$|R
50|$|In {{the early}} stages of product {{development}}, it is common to use development boards with dedicated and readily-accessible <b>debug</b> interfaces for connecting the <b>debug</b> tools. SoCs employed in the mobile market rely on two <b>debug</b> technologies: stop mode <b>debugging</b> via a scan chain and stop mode <b>debugging</b> via memory-mapped <b>debug</b> registers.|$|R
40|$|The IDebug <b>debugging</b> {{framework}} is an advanced <b>debugging</b> framework for Java. This framework provides the standard core <b>debugging</b> and specification constructs such as assertions, <b>debug</b> levels and categories, stack traces, and specialized exceptions. <b>Debugging</b> functionality can be fine-tuned to a per-thread and/or a per-class basis, <b>debugging</b> contexts {{can be stored}} to and recovered from persistent storage, and several aspects of the <b>debugging</b> run-time are configurable at the meta-level. Additionally, the {{framework is}} designed for extensibility. Planned improvements include support for <b>debugging</b> distributed object systems via currying call stacks across virtual machine contexts and <b>debug</b> information logging {{with a variety of}} networking media including unicast, multicast, RMI, distributed events, and JavaSpaces. Finally, we are adding support for <b>debugging</b> mobile agent systems by providing mobile <b>debug</b> logs. ...|$|R
25|$|The {{program code}} for the Sinclair Spectrum version {{was written on}} an IBM AT-compatible {{computer}} using a macro assembler, while the graphics were designed on an Atari ST, then downloaded onto the IBM AT, before being downloaded to the Spectrum and <b>debugged</b> using a specially developed monitor.|$|E
25|$|ENIAC's six primary programmers, Kay McNulty, Betty Jennings, Betty Snyder, Marlyn Wescoff, Fran Bilas and Ruth Lichterman, {{not only}} {{determined}} how to input ENIAC programs, but also developed {{an understanding of}} ENIAC's inner workings. The programmers <b>debugged</b> problems by crawling inside the massive structure to find bad joints and bad tubes.|$|E
25|$|Microsoft {{initially}} {{announced that}} applications using OpenDoc would be deemed compatible with OLE, and would receive certification for Windows 95. Microsoft later announced that applications using OpenDoc would not receive automatic certification, {{and might not}} receive certification at all. Microsoft withheld specifications and <b>debugged</b> versions of OLE until after it had released its competing applications.|$|E
40|$|This study {{demonstrates}} that {{formal training in}} <b>debugging</b> helps students develop skills in diagnosing and removing defects from computer programs. To enhance <b>debugging</b> skills in an assembly language course, students completed <b>debugging</b> exercises, <b>debugging</b> logs, development logs, reflective memos, and collaborative assignments. The <b>debugging</b> exercises were optional, but the other activities were mandatory. Students who completed the <b>debugging</b> exercises spent 37 % of their time on <b>debugging</b> programming assignments, whereas {{students who did not}} complete the <b>debugging</b> exercises spent 47 % of their time <b>debugging.</b> Students also provided qualitative data for each activity, and they responded to summative evaluation surveys. Students agreed that formal <b>debugging</b> training enhanced their <b>debugging</b> skills. This paper also proposes a model of <b>debugging</b> abilities and habits based on students' comments in their <b>debugging</b> logs, development logs, reflective memos, and evaluation surveys. Students and instructors can use the model to diagnose students' current <b>debugging</b> skills and take actions to enhance their skills. National Science Foundation under Grant SES- 0138309; College of Engineering, University of Illinois at Urbana-Champaignunpublishednot peer reviewe...|$|R
40|$|Abstract. Until {{today the}} most common {{technique}} to <b>debug</b> Java programs is trace <b>debugging.</b> In this work we present two different <b>debugging</b> approaches for Java: declarative <b>debugging,</b> which has its origins {{in the area of}} functional and logic programming, and omniscient <b>debugging,</b> which is basically an extension of trace <b>debugging.</b> To benefit from the advantages of both techniques we have integrated them into a single hybrid debugger called JHyde. We use JHyde to <b>debug</b> an erroneous merge sort algorithm and mention important aspects of its implementation. Furthermore, we show that the efficiency of the declarative <b>debugging</b> method can be significantly improved by a new <b>debugging</b> strategy. ...|$|R
50|$|On the x86 architecture, a <b>debug</b> {{register}} is {{a register}} {{used by a}} processor for program <b>debugging.</b> There are six <b>debug</b> registers, named DR0...DR7, with DR4 and DR5 as obsolete synonyms for DR6 and DR7. The <b>debug</b> registers allow programmers to selectively enable various <b>debug</b> conditions associated {{with a set of}} four <b>debug</b> addresses.Two of these registers are used to control <b>debug</b> features. These registers are accessed by variants of the MOV instruction. A <b>debug</b> register may be either the source operand or destination operand. The <b>debug</b> registers are privileged resources; the MOV instructions that access them can only be executed at privilege level zero. An attempt to read or write the <b>debug</b> registers when executing at any other privilege level causes a general protection fault.|$|R
25|$|In an {{interview}} with Nintendo Life in 2015, Cuthbert stated that he acquired {{a copy of the}} game's final ROM image during the development of the 2006 Nintendo DS game Star Fox Command, reviewed and <b>debugged</b> by Mario Club, Nintendo's quality control team. The image contains many elements missing from the leaked prototype ROM images. He was legally unable to release it.|$|E
25|$|Mass {{collaboration}} {{can help}} to reduce costs dramatically. Firms can release a specific software or product to be evaluated or <b>debugged</b> by online communities. The results will be more personal, robust and error-free products created in {{a short amount of}} time and costs. New ideas can also be generated and explored by collaboration of online communities creating opportunities for free R outside the confines of the company.|$|E
25|$|The team wished {{from the}} start to include the Japanese voice track, due to both fan demands and the celebrity statues of the {{original}} voices in Japan. Fitting both English and Japanese voice tracks onto a single disc was impossible due to space limitations, meaning that {{two versions of the}} game were created for release, with both needing to be <b>debugged</b> separately. The Japanese voice edition also had a differing text localization, as character names altered in the English dub such as Cherion—called Sagiitta in Japanese—were changed back to their original versions. Due to previous issues with missed bugs in previous NIS America localizations, the team spent twice the standard period debugging each version. The entire localization process took two years to complete, described by NIS America as being longer than the game's original development. At the time, it was called the largest localization project in the company's history.|$|E
40|$|IDebug, the Infospheres <b>debugging</b> framework, is an {{advanced}} <b>debugging</b> framework for Java. This framework provides the standard core <b>debugging</b> and specification constructs such as assertions, <b>debug</b> levels and categories, stack traces, and specialized exceptions. <b>Debugging</b> functionality can be fine-tuned to a per-thread and/or a per-class basis, <b>debugging</b> contexts {{can be stored}} to and recovered from persistent storage, and several aspects of the <b>debugging</b> run-time are configurable at the meta-level. Additionally, the framework is designed for extensibility. Planned improvements include support for <b>debugging</b> distributed object systems via currying call stacks across virtual machine contexts and <b>debug</b> information logging {{with a variety of}} networking media including unicast, multicast, RMI, distributed events, and JavaSpaces. Finally, we are adding support for <b>debugging</b> mobile agent systems by providing mobile <b>debug</b> logs. 1 Introduction Programming technologies have evolved greatly over th [...] ...|$|R
50|$|Instead of {{re-using}} the pins, <b>debugging</b> {{can also}} be done via the protocol stack of a standard interface or network. Here <b>debug</b> traffic co-exists with the traffic of other applications using the same communication link. The MIPI <b>Debug</b> Working Group named this approach GigaBit Debug.Since no <b>debug</b> protocol existed for this approach, the MIPI <b>Debug</b> Working Group specified its SneakPeak <b>debug</b> protocol.|$|R
50|$|The {{following}} non-MIPI <b>debug</b> {{standards are}} well {{established in the}} embedded market: IEEE 1149.1 (5-pin) and ARM Serial Wire <b>Debug</b> (2-pin), both using single-ended pins. Thus, {{there was no need}} for the MIPI <b>Debug</b> Working Group to specify a stop mode <b>debug</b> protocol or to specify a <b>debug</b> interface.|$|R
25|$|The {{debugger}} allows setting breakpoints (which allow execution to {{be stopped}} temporarily at a certain position) and watches (which monitor the values of variables as the execution progresses). Breakpoints can be conditional, meaning they get triggered when the condition is met. Code can be stepped over, i.e., run one line (of source code) at a time. It can either step into functions to debug inside it, or step over it, i.e., {{the execution of the}} function body isn't available for manual inspection. The debugger supports Edit and Continue, i.e., it allows code to be edited as it is being <b>debugged.</b> When debugging, if the mouse pointer hovers over any variable, its current value is displayed in a tooltip ("data tooltips"), where it can also be modified if desired. During coding, the Visual Studio debugger lets certain functions be invoked manually from the Immediate tool window. The parameters to the method are supplied at the Immediate window.|$|E
2500|$|In 1980 Bridges {{started his}} {{programming}} {{career at the}} NYU Institute for Reconstructive Plastic Surgery as a summer intern, working with sophisticated programmable vector graphics systems. [...] He wrote editing tools and also updated and <b>debugged</b> software used for early 3D x-ray scanning research.|$|E
2500|$|A {{key feature}} of Cosmos, which {{separates}} it from other operating systems of its type, is its tight integration with Microsoft Visual Studio. [...] Code can be written, compiled, <b>debugged,</b> and run entirely through Visual Studio, {{with only a}} few key presses. Cosmos no longer supports Visual Studio 2015, now it only supports Visual Studio 2017.|$|E
50|$|MIPI Alliance <b>Debug</b> Architecture {{provides}} a standardized infrastructure for <b>debugging</b> deeply embedded {{systems in the}} mobile and mobile-influenced space. The MIPI <b>Debug</b> Working Group released therefore a portfolio of specifications. Their objective is to provide standard <b>debug</b> protocols and standard interfaces from the SoC to the <b>debug</b> tool. The whitepaper Architecture Overview for <b>Debug</b> summarizes all efforts. In the last years the group focused on specifying protocols that improve the visibility of internal operations in deeply embedded systems, standardizing <b>debug</b> solutions via the functional interfaces of form factor devices and specifying the use of I3C as <b>debug</b> bus.|$|R
5000|$|Recursive <b>debugging</b> to <b>debug</b> code {{invoked in}} the context of another <b>debug</b> stack frame, to any depth ...|$|R
5000|$|Board {{developers}} and <b>debug</b> tools vendors benefit from standard <b>debug</b> connectors and standard pin mappings. The MIPI Recommendation for <b>Debug</b> and Trace Connectors recommends 10-/20-/34-pin board-level connectors (1.27 mm 050"). Seven different pin mappings are specified that address {{a wide variety}} of <b>debug</b> scenarios. They include: standard JTAG (IEEE 1149.1), cJTAG (IEEE 1149.7) and 4-bit parallel trace interface (mainly used for system traces). Supplemented by the ARM-specific standard SWD (Serial Wire <b>Debug)</b> [...] MIPI10/20/34 <b>debug</b> connector became the standard <b>debug</b> connectors for ARM-based embedded designs.|$|R
2500|$|Cosmos can be {{seamlessly}} <b>debugged</b> through Visual Studio {{when running}} over PXE or {{in a virtual}} machine. [...] Many standard debugging features are present, such as breakpoints, tracing, and logging. [...] Additionally, debugging can be done via serial cables, if running on physical hardware. [...] When running in VMWare, Cosmos supports stepping and breakpoints, even while an operating system is running.|$|E
2500|$|Robot {{simulation}} tools {{allow for}} robotics programs to be conveniently written and <b>debugged</b> off-line {{with the final}} version of the program tested on an actual robot. The ability to preview the behavior of a robotic system in a virtual world allows for a variety of mechanisms, devices, configurations and controllers to be tried and tested before being applied to a [...] "real world" [...] system. Robotics simulators have the ability to provide real-time computing of the simulated motion of an industrial robot using both geometric modeling and kinematics modeling.|$|E
2500|$|In {{the early}} 1950s, a {{computer}} could execute only one {{program at a}} time. [...] Each user had sole use of the computer for a limited {{period of time and}} would arrive at a scheduled time with program and data on punched paper cards or punched tape. The program would be loaded into the machine, and the machine would be set to work until the program completed or crashed. Programs could generally be <b>debugged</b> via a front panel using toggle switches and panel lights. It is said that Alan Turing was a master of this on the early Manchester Mark 1 machine, and he was already deriving the primitive conception of an operating system from the principles of the universal Turing machine.|$|E
50|$|The <b>debug</b> status {{register}} permits the debugger {{to determine which}} <b>debug</b> conditions have occurred.When the processor detects an enabled <b>debug</b> exception, it sets the low-order bits of this register (0,1,2,3) before entering the <b>debug</b> exception handler.|$|R
5000|$|DBX is also {{available}} on IBM z/OS systems, in the UNIX System Services component. DBX for z/OS can <b>debug</b> programs written in C and C++, and can also perform machine level <b>debugging.</b> As of z/OS V1R5, DBX is able to <b>debug</b> programs using the DWARF <b>debug</b> format. z/OS V1R6 added support for <b>debugging</b> 64-bit programs.|$|R
40|$|<b>Debugging</b> multi-agent systems, {{which are}} concurrent, distributed, and consist of complex {{components}} is difficult, yet crucial. The {{development of these}} complex systems is supported by agent-oriented software engineering methodologies which utilise agents as the central design metaphor. The systems that are developed are inherently complex since the components of these systems may interact in flexible and sophisticated ways and traditional <b>debugging</b> techniques are not appropriate. Despite this, very little effort {{has been applied to}} developing appropriate <b>debugging</b> tools and techniques. <b>Debugging</b> multi-agent systems without good <b>debugging</b> tools is highly impractical and without suitable <b>debugging</b> support developing and maintaining multi-agent systems will be more difficult than it need be. In this thesis we propose that the <b>debugging</b> process can be supported by following an agent-oriented design methodology, and then using the developed design artifacts in the <b>debugging</b> phase. We propose a domain independent <b>debugging</b> framework which comprises the developed processes and components that are necessary in using design artifacts as <b>debugging</b> artifacts. Our approach is to take a non-formal design artifact, such as an AUML protocol design, and encode it in a machine interpretable manner such that the design {{can be used as a}} model of correct system behaviour. These models are used by a run-time <b>debugging</b> system to compare observed behaviour against specified behaviour. We provide details for transforming two design artifact types into equivalent <b>debugging</b> artifacts and show how these can be used to detect bugs. During a <b>debugging</b> episode in which a bug has been identified our <b>debugging</b> approach can provide detailed information about the possible reason for the bug occurring. To determine if this information was useful in helping to <b>debug</b> programs we undertook a thorough empirical study and identified that use of the <b>debugging</b> tool translated to an improvement in <b>debugging</b> performance. We conclude that the <b>debugging</b> techniques developed in this thesis provide effective <b>debugging</b> support for multi-agent systems and by having an extensible framework new design artifacts can be explored and as translations are developed they can be added to the <b>debugging</b> system...|$|R
