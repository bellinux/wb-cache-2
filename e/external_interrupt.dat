36|59|Public
2500|$|Supports up to 256 {{interrupts}} in EIC (<b>External</b> <b>Interrupt</b> Controller) {{mode and}} eight hardware interrupt pins ...|$|E
5000|$|Direct control (with <b>external</b> <b>interrupt)</b> or <b>external</b> <b>interrupt</b> (alone) ...|$|E
50|$|An {{optional}} feature provided six <b>external</b> <b>interrupt</b> lines.|$|E
40|$|We {{describe}} {{a framework for}} verifying a pipelined microprocessor whose implementation contains precise exceptions, <b>external</b> <b>interrupts,</b> and speculative execution. We present our correctness criterion which compares the state transitions of pipelined and non-pipelined machines in presence of <b>external</b> <b>interrupts.</b> To perform the verification, we created a table-based model of pipeline execution. This model records committed and in-flight instructions as performed by the microarchitecture...|$|R
5000|$|Energy Sleep Mode 3 - Stop Mode: Energy Mode 3 (EM3) tailors {{the energy}} {{consumption}} of the EFM32 to maintain a very short wake-up time and respond to <b>external</b> <b>interrupts.</b> In EM3 the low-frequency oscillator is disabled, but the low-leakage RAM ensures full data retention and the low-power analog comparator or asynchronous <b>external</b> <b>interrupts</b> can wake-up the device. | Power consumption in EM3: 0.5 µA ...|$|R
5000|$|CR8, Control {{register}} number 8: enables x86 processors {{to prioritize}} <b>external</b> <b>interrupts</b> and {{is referred to}} as the task-priority register ...|$|R
5000|$|Interrupt control chassis {{with eight}} <b>external</b> <b>interrupt</b> levels ...|$|E
5000|$|Supports up to 256 {{interrupts}} in EIC (<b>External</b> <b>Interrupt</b> Controller) {{mode and}} eight hardware interrupt pins ...|$|E
5000|$|Extended Direct Control {{allowing}} the processors in a duplex configuration {{to present an}} <b>external</b> <b>interrupt</b> to the other processor ...|$|E
50|$|System {{software}} {{can use the}} TPR register to temporarily block low-priority interrupts from interrupting a high-priority task. This is accomplished by loading TPR with a value corresponding to the highest-priority interrupt {{that is to be}} blocked. For example, loading TPR with a value of 9 (1001b) blocks all interrupts with a priority class of 9 or less, while allowing all interrupts with a priority class of 10 or more to be recognized. Loading TPR with 0 enables all <b>external</b> <b>interrupts.</b> Loading TPR with 15 (1111b) disables all <b>external</b> <b>interrupts.</b>|$|R
50|$|CR8 {{is a new}} {{register}} accessible in 64-bit mode {{using the}} REX prefix. CR8 is used to prioritize <b>external</b> <b>interrupts</b> and {{is referred to as}} the task-priority register (TPR).|$|R
3000|$|... (iii)Interrupt {{response}} latency: {{the time}} elapsed {{from the last}} instruction of the interrupted components and the first instruction in ISRs, which indicates the rapidity of the system reaction to an <b>external</b> <b>interrupts.</b>|$|R
5000|$|General purpose timers (4), SPI/I2S (2), I2C (2), USART (2), 12-bit ADC with 10 {{channels}} (1), GPIO (20) with <b>external</b> <b>interrupt</b> capability, RTC ...|$|E
50|$|CP notifies {{a virtual}} machine of a pending message or status {{information}} by making an <b>external</b> <b>interrupt</b> code X'4000' pending to the virtual machine. When the interrupt occurs, the {{information regarding the}} pending status is made available at the address location specified by the DECLARE BUFFER method.|$|E
50|$|The Clipper had 16 integer {{registers}} (R15 {{was used}} as stack pointer), 16 floating-point registers (limited to 8 in early implementations), plus a program counter (PC), a processor status word (PSW) containing ALU and FPU status flags and trap enables, and a system status word (SSW) containing <b>external</b> <b>interrupt</b> enable, user/supervisor mode, and address translation control bits.|$|E
50|$|Significant {{functionality}} {{is available}} at the lower Stop and Shutoff energy modes. The Stop Mode includes analog comparators, watchdog timers, pulse counters, I2C links, and <b>external</b> <b>interrupts.</b> In Shutoff mode, with 20-100 nA current consumption, depending on product, applications have access to GPIO, Reset, a Real-Time Counter (RTC) and retention memory.|$|R
50|$|Local APICs (LAPICs) manage all <b>external</b> <b>interrupts</b> {{for some}} {{specific}} processor in an SMP system. In addition, {{they are able}} to accept and generate inter-processor interrupts (IPIs) between LAPICs. LAPICs may support up to 224 usable interrupt vectors from an I/O APIC. Vector numbers 0 to 31, out of 0 to 255, are reserved for exception handling by x86 processors.|$|R
2500|$|Transitions between modes {{are at the}} {{discretion}} of the executing thread when the transition is from a level of high privilege to one of low privilege (as from kernel to user modes), but transitions from lower to higher levels of privilege can take place only through secure, hardware-controlled [...] "gates" [...] that are traversed by executing special instructions or when <b>external</b> <b>interrupts</b> are received.|$|R
50|$|In the x86 {{computer}} architecture, '''''' (halt) is {{an assembly}} language instruction which halts the {{central processing unit}} (CPU) until the next <b>external</b> <b>interrupt</b> is fired. Interrupts are signals sent by hardware devices to the CPU alerting it that an event occurred to which it should react. For example, hardware timers send interrupts to the CPU at regular intervals.|$|E
50|$|Almost every {{reasonably}} modern processor {{instruction set}} includes an instruction or sleep mode which halts the processor until more work {{needs to be}} done. In interrupt-driven processors, this instruction halts the CPU until an <b>external</b> <b>interrupt</b> is received. On most architectures, executing such an instruction allows the processor to significantly reduce its power usage and heat output, {{which is why it}} is commonly used instead of busy waiting for sleeping and idling.|$|E
50|$|Due to the {{abundance}} of programmer-visible processor context which practically includes, in addition toregister file contents, also function unit pipeline register contents and/or function unit input and output ports, context saves required for <b>external</b> <b>interrupt</b> support can become complex and expensive to implement in a TTA processor. Therefore, interrupts are usually not supported by TTA processors, but their task is delegated to an external hardware (e.g., an I/O processor) or their need is avoided by using an alternative synchronization/communication mechanism such as polling.|$|E
5000|$|Energy Sleep Mode 4 - Shutoff Mode: In this deepest energy mode available, the EFM32 MCU is {{completely}} shut down, {{and the only}} way to wake up is with a reset. This energy mode enables further energy savings for applications that do not require a RTC or RAM retention. Energy Mode 4 is available in select low-energy peripherals, including power-on reset and <b>external</b> <b>interrupts</b> | Power consumption in EM4: 20 nA ...|$|R
50|$|Interrupt latency is {{constant}} at three instruction cycles. <b>External</b> <b>interrupts</b> {{have to be}} synchronized with the four-clock instruction cycle, otherwise {{there can be a}} one instruction cycle jitter. Internal interrupts are already synchronized. The constant interrupt latency allows PICs to achieve interrupt-driven low-jitter timing sequences. An example of this is a video sync pulse generator. This is no longer true in the newest PIC models, because they have a synchronous interrupt latency of three or four cycles.|$|R
40|$|We {{present a}} method for {{generating}} random bits on a computer system using <b>interrupts</b> from <b>external</b> sources (e. g., keyboard strokes, hard-disk I/O completions, network packet arrivals, etc). We show how a sequence of timestamps of <b>external</b> <b>interrupts</b> can be converted into a uniformly distributed random sequence of 0 's and 1 's. We also describe how the random sequence can later be used in blocking (/dev/random) and nonblocking (/dev/urandom) devices for providing a source of random bits in an UNIX environment...|$|R
50|$|The design {{philosophy}} of the Propeller is that a hard real-time multi-core architecture negates the need for dedicated interrupt hardware and support in assembly. In traditional CPU architecture, <b>external</b> <b>interrupt</b> lines are fed to an on-chip interrupt controller and are serviced {{by one or more}} interrupt service routines. When an interrupt occurs, the interrupt controller suspends normal CPU processing and saves internal state (typically on the stack), then vectors to the designated interrupt service routine. After handling the interrupt, the service routine executes a return from interrupt instruction which restores the internal state and resumes CPU processing.|$|E
50|$|The DAI {{was based}} on an early 8-bit microprocessor, the Intel 8080 A, (which is {{generally}} considered the first really usable microprocessor) and contained on a single printed circuit board all the needed circuitry, some 120 individual ICs. The futuristic-looking white enclosure also held a high quality keyboard, which was uncommon for the time. As a computer display, any TV could be used. The DAI could display text and high resolution color pictures and contained a memory controller that enabled it to use up to 48 kB of DRAM. This memory was divided in three 16 kB regions (memory banks) that could contain either 4K or 16K memory chips. By using memory map switching, a total of 72kB of memory was addressable. The DAI also had five programmable interval 64µ - 16ms interval timers that could generate interrupts. The built-in interrupt handler chip could also handle two <b>external</b> <b>interrupt</b> inputs and the interrupts of two serial RS232 UARTS. The DAI featured a DAI/Indata DCE parallel I/O bus for parallel high speed I/O. The DAI also had 3 sound generators and 1 noise generator, and was capable of generating stereo sound.|$|E
40|$|Abstract—Interrupt behaviors, {{particularly}} the external ones, {{are difficult to}} verify in a microprocessor. Because the <b>external</b> <b>interrupt</b> arrival time and the microprocessor response time must be precise, verification requires sophisticated hardware and soft-ware design. This paper proposes a computer-aided design tool, called processor exception verification tool (PEVT), to verify the <b>external</b> <b>interrupt</b> behaviors of microprocessors, including indi-vidual, multiple, and nested interrupts. An architecture descrip-tion language extension, called Exception Description Language (EXPDL), is developed for the designer to capture the <b>external</b> <b>interrupt</b> behaviors for the microprocessor under verification. PEVT is responsible for generating the verification cases, consist-ing of both the hardware and software modules, which are then used to trigger the expected behaviors. A monitor is also generated from the EXPDL description to verify these cases. PEVT {{has been applied to}} the verification of an academic implementation of the ARM 7 microprocessor core and a public domain scalable processor architecture (SPARC) microprocessor core. The ARM 7 has had a system-on-a-chip test chip and software porting includ-ing multimedia applications (MP 3 /JPEG / [...] .) and a real time operating system µC-OSII. PEVT successfully identified several sophisticated remaining bugs with 527 lines of EXPDL description and took only 4 204 961 cycles of register transfer language simula-tion with execution time of 4. 5 h in a SUN Blade 2000 workstation. The experiment shows that PEVT could generate highly focused verification cases, less than 98 cycles per case on the average, which identify potential bugs with much less simulation cycles at the early verification stage, compared with traditional manual-based approaches. Index Terms—Architecture description language (ADL), dy-namic assertion based, <b>external</b> <b>interrupt</b> verification, micro-processor verification, monitor, simulation based, trigger. I...|$|E
40|$|In {{this paper}} {{we present a}} {{framework}} for dynamically allocating the CPU resource to tasks whose execution times are not known a priori. Tasks are partitioned in three classes: the ones that require a uniform execution but do not impose any temporal constraint, periodic tasks that operate on Continuous Media, and event driven tasks that respond to <b>external</b> <b>interrupts.</b> For the last two classes, we show how to adjust the fraction of the CPU bandwidth assigned to each task using a feedback mechanism...|$|R
40|$|The paper {{presents}} TrueTime, aMatlab/Simulink-based simulator for real-time controlsystems. TrueTime {{makes it}} possible to simulate the temporalbehavior of multi-tasking real-time kernels containing controllertasks and to study the effects of CPU and network scheduling on controlperformance. The simulated real-time kernel is event-driven and canhandle <b>external</b> <b>interrupts</b> as well as fine-grained details such ascontext switches. Arbitrary scheduling policies may be defined, andthe control tasks may be implemented using C functions, M functions,or Simulink block diagrams. A number of examples that illustratethe use of TrueTime are presented...|$|R
40|$|A {{method is}} {{proposed}} for making asynchronous (QDI) circuits entirely tolerant to soft errors caused by radiation or other noise effects. The method has three components: (1) {{a special kind}} of duplication for random logic, (2) special circuitry for arbiter and synchronizer (as needed for example for <b>external</b> <b>interrupts),</b> and (3) error correction for memory arrays. An entire microcontroller has been designed with the method. Simulations at the digital level in the presence of random soft errors show that the system recovers from all soft errors. SPICE simulations also confirm the results...|$|R
40|$|Interrupt behaviors, {{especially}} the external ones, are diffi-cult to verify in a microprocessor design project {{in that they}} involve both interacting hardware and software. This paper proposes a CAD tool, called PEVT, to verify the <b>external</b> <b>interrupt</b> behaviors of microprocessors. An architecture de-scription language extension, called EXPDL, is developed for the designer to capture the <b>external</b> <b>interrupt</b> behaviors for the microprocessor. PEVT is responsible to generate the verification cases, consisting of both the hardware and soft-ware modules, which are then used to trigger the expected behaviors. A monitor is also generated from the EXPDL description to verify these cases. PEVT {{has been applied to}} the verification of an academic implementation of ARM 7 microprocessor core, which has had a SoC test chip and soft-ware porting including MP 3 decoder and uC-OSII. PEVT successfully identified several sophisticated remaining bugs with only less than 88, 000 cycles of RTL simulation with execution time of 424 seconds in a SUN Blade 2000 work-station. The experiment shows that PEVT could generate highly focused verification cases, less than 21 cycles per case on the average, which identify potential bugs with much less simulation cycles, compared with traditional regression tests which consume huge amount of simulation cycles...|$|E
30|$|The {{individual}} modules, {{which have}} handles information-processing tasks, e.g., voice synthesis, submergence sensor, etc, use individual microcontrollers. The central controller is a microcontroller which co-ordinates {{among the different}} modules. A system firmware is the central microprocessor responsible for controlling the system functionalities in a sequential and timely manner. Algorithm 1 illustrates the generic firmware of the system. In addition to this, an interrupt service routine (ISR) handles the tasks when an <b>external</b> <b>interrupt</b> arrives. This ISR serves the purpose of acquisition of GPS data and sends it to the control center when requested. This is enabled at the initialization phase of controller.|$|E
30|$|The {{binocular}} {{camera is}} {{converted into a}} digital signal through a special decoder chip processor for receiving and processing, and the processing results sent via the SPI bus to the Zigbee module; the Zigbee module can also be through the SPI bus to the main processor which sends control signals to control the FPGA worker process. The acceleration sensor, electromagnetic compass and video decoder chip exchange information with the main controller via I 2 C bus. The temperature and humidity sensors are read through the 8 -bit ADC interface. The heat release external sensor monitors the human body by triggering the <b>external</b> <b>interrupt</b> of the main control module.|$|E
50|$|The Atmel 8-bit AVR RISC-based {{microcontroller}} combines 32 kB ISP {{flash memory}} with read-while-write capabilities, 1 kB EEPROM, 2 kB SRAM, 23 general purpose I/O lines, 32 general purpose working registers, three flexible timer/counters with compare modes, internal and <b>external</b> <b>interrupts,</b> serial programmable USART, a byte-oriented 2-wire serial interface, SPI serial port, 6-channel 10-bit A/D converter (8-channels in TQFP and QFN/MLF packages), programmable watchdog timer with internal oscillator, and five software selectable power saving modes. The device operates between 1.8-5.5 volts.The device achieves throughput approaching 1 MIPS per MHz.|$|R
50|$|<b>External</b> <b>interrupts</b> are {{triggered}} by falling/rising edges or high/low potential at the interrupt port, {{leading to an}} interrupt request (IRQ) in the controller. Hardware interrupts are divided into maskable interrupts and non-maskable interrupts (NMI). The triggering of maskable interrupts can be stopped in some time-critical functions. If an interrupt is called, the current instruction pointer (IP) is saved on the stack, and the stack pointer (SP) is decremented. The address of the interrupt service routine (ISR) is read from the interrupt vector table and loaded to the IP register, and the ISR is executed as a consequence.|$|R
5000|$|Holtek's design {{focus is}} {{in the area of}} {{microcontroller}} development. Holtek's 32-bit series are based around an ARM Cortex-M0+ and Cortex-M3 cores, and it is producing some 8051 based cores, but the majority of its 8-bit microcontrollers are based on its own self-designed core that is very similar to the Microchip PIC16 architecture. All have common features such as timers, <b>external</b> <b>interrupts,</b> power-down functions, low-voltage reset, bi-directional I/O pins etc. The range of microcontrollers support clock speeds from 32 kHz up to 20 MHz. Device specific features include functions such as EEPROM memory, A/D converters, LCD interfaces, USB interfaces, operational amplifiers. Some of Holtek's 8-bit microcontroller devices: ...|$|R
