0|5119|Public
5000|$|In {{computer}} programming languages, [...] is a frequently used generic label used in templates to reference an unknown data type, data structure, or class. Templates {{are most frequently}} used in Java and C++. TypeParameter {{is similar to a}} metasyntactic variable (e.g., [...] and [...] ), but distinct. It is not the name of a generic variable, but the name of a <b>generic</b> <b>type</b> of <b>variable.</b>|$|R
40|$|This paper {{points out}} two {{problems}} which prevent Haskell from having principal types. For each problem, we discuss a program which exhibits it. The first problem {{has to do}} with type signatures and class constraints containing both <b>generic</b> and nongeneric <b>type</b> <b>variables.</b> The second problem is caused by the monomorphism restriction. In both cases there is an interaction between generalization and class constraints where substituting a nonvariable type for a constrained <b>type</b> <b>variable</b> makes the constraint tautological and opens up for more aggressive generalization...|$|R
40|$|<b>Generic</b> <b>types</b> in Java. This report {{discusses}} {{the lack of}} <b>generic</b> <b>types</b> in the programming language Java, which is nice to have when writing fast, generic methods {{that can be used}} in different contexts. It is possible to <b>type</b> <b>generic</b> <b>variables</b> with the class "Object" instead of using <b>generic</b> <b>types,</b> but this causes the compiler to insert a lot of run-time tests that slows down the execution speed. Different languages includes different philosophies of how to solve the <b>generic</b> <b>types.</b> This report takes a look at generic parameters in methods, which works much in the same way as templates in C++, and it also discusses some thoughts around generic packages, which originally was a suggestion for the Simula language. To test out these new enlargements of Java, I have tried to implement some design patterns and a bigger example where I combine these...|$|R
40|$|ABSTRACT This paper {{points out}} two {{problems}} which prevent Haskell from having principal types. For each problem, we discuss a program which exhibits it. The first problem {{has to do}} with type signatures and class constraints containing both <b>generic</b> and nongeneric <b>type</b> <b>variables.</b> The second problem is caused by the monomorphism restriction. In both cases there is an interaction between generalization and class constraints where substituting a nonvariable type for a constrained <b>type</b> <b>variable</b> makes the constraint tautological and opens up for more aggressive generalization. We also discuss how these problems can be solved by introducing quantified class constraints and strengthening the monomorphism restriction from prohibiting only the generalization of constrained <b>type</b> <b>variables</b> to prohibiting any generalization at all. We also give an inference algorithm producing principal types for the new system...|$|R
40|$|While Java {{continues}} to gain popularity in both industry and academia, few Java programming environments enable {{the user to}} directly interact with the code. Professional environments require developers to use a command line interface to execute Java code. In contrast, our DrJava programming environment supports a read-eval-print-loop (REPL) incorporating a Java interpreter called DynamicJava [...] -enabling developers to execute arbitrary fragments of Java code on-the-fly. DynamicJava was developed at the University of Nice, but development ceased in 2002 with DynamicJava supporting Java 1. 3. In 2004, the Java language was extended in the Java 1. 5 (renamed 5. 0) release. To support Java 5. 0 in DrJava, we were confronted {{with the task of}} extending DynamicJava to support the new language features. This dissertation describes the new features in Java 5. 0 [...] -including <b>generic</b> <b>types,</b> autoboxing, <b>variable</b> arguments, static import, foreach, enumeration types and metadata [...] -and explains how we extended the existing DynamicJava code base to support them...|$|R
40|$|Lisp {{applications}} {{need to show}} {{a reasonable}} cost-benefit relationship between the offered expressiveness and their demand for storage and run-time. Drawbacks in efficiency, apparent in Lisp as a dynamically typed programming language, can be avoided by optimizations. Statically inferred type information can be decisive {{for the success of}} these optimizations. This paper describes a practical approach to type inference realized in a module and application compiler for EuLisp. The approach is partly related to Milner-style polymorphic type inference, but differs by describing functions with <b>generic</b> <b>type</b> schemes. Dependencies between argument and result types can be expressed more precisely by using <b>generic</b> <b>type</b> schemes of several lines than by using the common one-line <b>type</b> schemes. <b>Generic</b> <b>type</b> schemes contain types of a refined complementary lattice and bounded <b>type</b> <b>variables.</b> Besides standard and defined types so-called strategic types (e. g. singleton, zero, number-list) are combine [...] ...|$|R
40|$|Abstract. Lisp {{applications}} {{need to show}} {{a reasonable}} cost-benet relationship be-tween the oered expressiveness and their demand for storage and run-time. Drawbacks in eciency, apparent in Lisp as a dynamically typed programming language, can be avoided by optimizations. Statically inferred type information can be decisive {{for the success of}} these optimizations. This paper describes a practical approach to type inference realized in a module and application compiler for EuLisp. The approach is partly related to Milner-style poly-morphic type inference, but diers by describing functions with <b>generic</b> <b>type</b> schemes. Dependencies between argument and result types can be expressed more precisely by us-ing <b>generic</b> <b>type</b> schemes of several lines than by using the common one-line <b>type</b> schemes. <b>Generic</b> <b>type</b> schemes contain types of a rened complementary lattice and bounded <b>type</b> <b>variables.</b> Besides standard and dened types so-called strategic types (e. g. singleton, zero, number-list) are combined into the type lattice. Local, global and control ow in-ference using <b>generic</b> <b>type</b> schemes with rened types generate precise typings of dened functions. Due to module compilation, inferred type schemes of exported functions can be stored in export interfaces, so they may be reused when imported elsewhere. 1...|$|R
40|$|International audienceWith the {{introduction}} of Java 5. 0 the type system has been extended by parameterized <b>types,</b> <b>type</b> <b>variables,</b> <b>type</b> terms, and wildcards. As a result very complex types can arise. The term Vector is for example a correct type in Java 5. 0. In this paper we present a type unification algorithm for Java 5. 0 type terms. The algorithm unifies type terms, which are in subtype relationship. For this we define Java 5. 0 type terms and its subtyping relation, formally. As Java 5. 0 allows wildcards as instances of <b>generic</b> <b>types,</b> the subtyping ordering contains infinite chains. We show that the type unification is still finitary. We give a type unification algorithm, which calculates the finite set of general unifiers...|$|R
5000|$|Local class These are {{classes that}} are {{declared}} {{in the body}} of a function. They can only be referred to {{in the rest of the}} function. They can use local variables and parameters of the function, but only one that are declared [...] "final". (This is because the local class instance must maintain a separate copy of the variable, as it may out-live the function; so as not to have the confusion of two modifiable variables with the same name in the same scope, the variable is forced to be non-modifiable.) Can be very helpful for creation a class with <b>generic</b> <b>type</b> fields, where the <b>type</b> <b>variables</b> are defined in the method.|$|R
50|$|A {{source of}} heap {{pollution}} in Java {{arises from the}} fact that <b>type</b> arguments and <b>variables</b> are not reified at run-time. As a result, different parameterized types are implemented by the same class or interface at run time. Indeed, all invocations of a given <b>generic</b> <b>type</b> declaration share a single run-time implementation. This results in the possibility of heap pollution.|$|R
5000|$|...NET allows six {{varieties}} of <b>generic</b> <b>type</b> constraints using the where keyword including restricting <b>generic</b> <b>types</b> to be value types, to be classes, to have constructors, and to implement interfaces. Below {{is an example}} with an interface constraint: ...|$|R
50|$|Arrays and structs can {{be viewed}} as {{predefined}} <b>generic</b> <b>types.</b> Every usage of an array or struct type instantiates a new concrete type, or reuses a previous instantiated type. Array element types and struct element types are parameterized types, which are used to instantiate the corresponding <b>generic</b> <b>type.</b> All this is usually built-in in the compiler and the syntax differs from other generic constructs. Some extensible programming languages try to unify built-in and user defined <b>generic</b> <b>types.</b>|$|R
5000|$|A {{validated}} <b>generic</b> <b>type</b> is a <b>generic</b> <b>type</b> where {{a condition}} indicates how the type can be used. Such types {{need not have}} generic parameters. For instance, one can declare that a type is [...] {{if it has a}} less-than operator as follows: ...|$|R
50|$|There are {{two main}} approaches. In {{languages}} with declaration-site variance annotations (e.g., C#), the programmer annotates {{the definition of a}} <b>generic</b> <b>type</b> with the intended variance of its type parameters. With use-site variance annotations (e.g., Java), the programmer instead annotates the places where a <b>generic</b> <b>type</b> is instantiated.|$|R
40|$|International audienceWe use {{hyperbolic}} towers {{to answer}} some model theoretic questions around the <b>generic</b> <b>type</b> {{in the theory of}} free groups. We show that all the finitely generated models of this theory realize the <b>generic</b> <b>type</b> p 0, but that there is a finitely generated model which omits p (2) 0. We exhibit a finitely generated model in which there are two maximal independent sets of realizations of the <b>generic</b> <b>type</b> which have different cardinalities. We also show that a free product of homogeneous groups is not necessarily homogeneous...|$|R
40|$|One of {{the most}} {{significant}} limitations of the Java Programming Language is its lack of support for <b>generic</b> <b>types.</b> This thesis describes an efficient compiler and run-time type system for NextGen, a compatible extension of Java that supports <b>generic</b> <b>types,</b> including type dependent operations. The NextGen compiler is implemented as an extension to the existing compiler for GJ, a limited generic extension of Java that does not support run-time <b>generic</b> <b>types.</b> Our implementation is homogeneous, with one major exception: Instantiations of generic classes are constructed on demand. This exception is necessary to support polymorphic recursion. The NextGen compiler generates templates for such instantiation classes and relies on a customized class loader to construct instantiations at run-time. A suite of benchmarks on the Java, GJ, and NextGen compilers shows that the additional code required to support run-time <b>generic</b> <b>types</b> has little or no overhead compared to ordinary Java and GJ...|$|R
5000|$|... #Subtitle level 3: Covariant and {{contravariant}} <b>generic</b> <b>type</b> parameters ...|$|R
50|$|There are two <b>generic</b> <b>types</b> of trampoline, {{competitive}} and recreational.|$|R
40|$|We {{prove that}} if K is a (infinite) stable field whose <b>generic</b> <b>type</b> has weight 1, then K is separably closed. We also obtain some partial results about stable groups and fields whose <b>generic</b> <b>type</b> has finite weight, {{as well as}} about {{strongly}} stable fields (where by definition all types have finite weight). ...|$|R
40|$|An {{efficient}} compiler and run-time {{system is}} described for NextGen, a compatible {{extension of the}} Java programming language supporting run-time <b>generic</b> <b>types</b> as described by Cartwright and Steele. The NextGen compiler is implemented as an extension to the existing compiler for GJ, a generic extension of Java that does not support run-time <b>generic</b> <b>types.</b> It relies on the homogeneous implementation strategy proposed by Cartwright and Steele with one major exception: To support polymorphic recursion {{in the definition of}} generic classes, the compiler generates templates for instantiation classes and relies on a customized class loader to construct instantiations of generic classes on demand. This thesis includes an extensive set of benchmarks, specifically developed to stress the use of <b>generic</b> <b>types.</b> The benchmarks show that the additional code required to support run-time <b>generic</b> <b>types</b> has little or no overhead compared with ordinary Java and GJ...|$|R
5000|$|The RUS {{identifies}} the following <b>generic</b> <b>types</b> of gaps and issues: ...|$|R
5000|$|<b>Generic</b> <b>type</b> {{which can}} be {{instantiated}} with any base floating point type.|$|R
50|$|SystemCollectionsGeneric: Defines <b>generic</b> <b>types</b> of the {{container}} types in the SystemCollections namespace.|$|R
40|$|We {{prove that}} the <b>generic</b> <b>type</b> of the (theory of the) free group Fn on n ≥ 2 {{generators}} has infinite weight, strengthening the well-known result that these free groups are not superstable. A preliminary result, possibly of independent interest, is that the realizations in Fn of the <b>generic</b> <b>type</b> are precisely the primitives. 1 Introduction an...|$|R
50|$|Here {{are some}} <b>generic</b> <b>types</b> of social issues, along with {{examples}} of each.|$|R
5000|$|The Royal Ordnance Factories {{were set}} up with six <b>generic</b> <b>types</b> of factories: ...|$|R
5000|$|... vulytsia, a {{most common}} and <b>generic</b> <b>type</b> of a street within a {{settlement}} ...|$|R
40|$|We use {{hyperbolic}} towers {{to answer}} some model theoretic questions around the <b>generic</b> <b>type</b> {{in the theory of}} free groups. We show that all the finitely generated models of this theory realize the <b>generic</b> <b>type</b> $p_ 0 $, but that there is a finitely generated model which omits $p_ 0 ^{(2) }$. We exhibit a finitely generated model in which there are two maximal independent sets of realizations of the <b>generic</b> <b>type</b> which have different cardinalities. We also show that a free product of homogeneous groups is not necessarily homogeneous. Comment: to appear in Proceedings of the conference "Recent developments in Model Theory", Notre Dame Journal of Formal Logi...|$|R
40|$|Java <b>generic</b> <b>types</b> allow a {{programmer}} to create parameterized data structures and methods. For instance, a <b>generic</b> Stack <b>type</b> {{may be used}} for integers in one instance and for strings in another. Java compiler guarantees in this case that integers and strings are not mixed in the same stack. We study runtime efficiency of a certain inheritance pattern related to Java generic types: narrowing of a type bound. This pattern takes place when a <b>generic</b> <b>type</b> allows a more restricted type of elements than its supertype. We examine a slowdown caused by this pattern for some method calls and study the reasons for it. Knowing cases when the slowdown takes place and the reasons for it would allow software developers to make informed choices when using <b>generic</b> <b>types</b> in their programs. ...|$|R
40|$|The {{object-oriented}} type {{theory for}} non-specialists is discussed. It is shown that how parametric polymorphism, known as templates in C++ and genericity in Ada and Eiffel, {{can be added}} to the Theory of Classification. The <b>generic</b> <b>types</b> could be created by abstracting over parts of simple <b>types.</b> A <b>generic</b> <b>type</b> is modeled as a type function expecting an actual type argument...|$|R
40|$|The Universe type {{system allows}} a {{programmer}} to control aliasing and dependencies in objectoriented programs by applying an ownership relation to structure the object store. In previous projects the Universe type system was extended by static checks for Uniqueness and ownership transfer [[5], [6]] and for <b>generic</b> <b>types</b> in the Universe Type System [[1], [2]]. The {{main part of}} this master project is to design and implement the runtime support for Uniqueness (and ownership transfer) and for <b>generic</b> <b>types.</b> From Java 5 <b>generic</b> <b>types</b> are introduced. Java does not store the runtime type of the type arguments. But the Universe type system needs this information for its runtime model. Based on GUT [[2], [3]] which defines the runtime model for <b>generic</b> <b>types</b> in the Universe type system the current runtime implementation in the multijava [11] compiler is now extended by an implementation for this runtime model. The runtime support for Uniqueness {{is an extension of}} the basic Universe runtime implementation to fulfill the requirements of Uniquenes...|$|R
40|$|We {{describe}} an efficient compiler and run-time system for NextGen, a compatible {{extension of the}} Java programming language supporting run-time <b>generic</b> <b>types</b> designed by Cartwright and Steele. The resulting system is comparable in performance with both standard Java and the GJ extension of Java, which does not support run-time <b>generic</b> <b>types.</b> Our implementation of NextGen consists of a compiler extending the GJ compiler and a special class loader that constructs type instantiation classes on demand. The compiler relies on the implementation strategy proposed by Cartwright and Steele with one major exception: to support polymorphic recursion {{in the definition of}} generic classes, the compiler generates templates for instantiation classes which are constructed on demand by the class loader. We include an extensive set of benchmarks, specifically developed to stress the use of <b>generic</b> <b>types.</b> The benchmarks show that the additional code required to support run-time <b>generic</b> <b>types</b> has little overhead compared with ordinary Java and GJ...|$|R
40|$|This thesis {{describes}} how to add first-class <b>generic</b> <b>types</b> [...] -including mixins [...] -to strongly-typed object-oriented languages with nominal subtyping such as Java and C#. A <b>generic</b> <b>type</b> system is "first-class" if <b>generic</b> <b>types</b> can appear in any context where conventional types can appear. In this context, a mixin {{is simply a}} generic class that extends one of its type parameters, e. g., a class C that extends T. Although mixins of this form are widely used in C++ (via templates), they are clumsy and error-prone because C++ treats mixins as syntactic abbreviations (macros), forcing each mixin instantiation to be separately compiled and type-checked. The abstraction embodied in a mixin is never separately analyzed...|$|R
5000|$|... #Caption: Logo {{previously}} used {{in advertising}} in Ontario; <b>generic</b> <b>type</b> for both Loblaw Superstore and Real Canadian Superstore ...|$|R
5000|$|Two <b>generic</b> <b>types</b> of wave {{turbulence}} {{should be}} distinguished: statistical wave turbulence (SWT) and discrete wave turbulence (DWT).|$|R
50|$|Generic Types: Division 4.1 self-reactive {{materials}} {{are assigned to}} a generic system consisting of seven types. A self-reactive substance identified by technical name in the Self-Reactive Materials Table in 49CFR 173.224 is assigned to a <b>generic</b> <b>type</b> in accordance with that Table. Self-reactive materials not identified in the Self-Reactive Materials Table in 49CFR 173.224 are assigned to <b>generic</b> <b>types</b> under the procedures of paragraph (a)(2)(iii) of this section.|$|R
