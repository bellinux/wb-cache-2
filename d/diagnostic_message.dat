19|60|Public
5000|$|The main <b>diagnostic</b> <b>message</b> (DM1) has {{somewhat}} different formats, {{due to the}} need in RV-C for instance identification.|$|E
50|$|This is a macro that {{implements}} a runtime assertion, {{which can}} be used to verify assumptions made by the program and print a <b>diagnostic</b> <b>message</b> if this assumption is false.|$|E
5000|$|Memory {{allocated}} {{with the}} [...] must be deallocated with the [...] operator, rather than [...] Using the inappropriate form results in undefined behavior. C++ compilers {{are not required}} to generate a <b>diagnostic</b> <b>message</b> for using the wrong form.|$|E
5000|$|... 2 IBM Selectric Typewriters, (I/O Typewriters) one {{of which}} was used for {{operational}} messages and the other for <b>diagnostic</b> <b>messages</b> and maintenance activities.|$|R
50|$|Information on RSVP flow - {{two types}} of <b>diagnostic</b> <b>messages</b> allow a network {{operator}} to request the RSVP state information on a specific flow.|$|R
5000|$|Diagnostic {{facility}} - An {{extension to}} the standard which allows a user to collect information about the RSVP state along a path. RFC2745 - RSVP <b>Diagnostic</b> <b>Messages</b> ...|$|R
50|$|However, {{there is}} very little control over {{creating}} these defaults. Making a class inherently non-copyable, for example, requires declaring a private copy constructor and copy assignment operator and not defining them. Attempting to use these functions is a violation of the One Definition Rule (ODR). While a <b>diagnostic</b> <b>message</b> is not required, violations may result in a linker error.|$|E
5000|$|Real-world file systems often contain looped {{structures}} {{created through}} the use of hard or soft links. The POSIX standard requires that The [...] utility shall detect infinite loops; that is, entering a previously visiteddirectory that is an ancestor of the last file encountered. When it detects an infiniteloop, [...] shall write a <b>diagnostic</b> <b>message</b> to standard error and shall either recoverits position in the hierarchy or terminate.|$|E
5000|$|In some {{programming}} languages {{an implicit}} declaration is provided {{the first time}} such a variable is encountered at compile time. In other languages such a usage {{is considered to be}} an error, which may resulting in a <b>diagnostic</b> <b>message.</b> Some languages have started out with the implicit declaration behavior, but as they matured they provided an option to disable it (e.g. Perl's [...] "" [...] or Visual Basic's [...] "").|$|E
50|$|The {{most common}} {{application}} for ISO-TP is {{the transfer of}} <b>diagnostic</b> <b>messages</b> with OBD-2 equipped vehicles using KWP2000 and UDS, but is used broadly in other application-specific CAN implementations.|$|R
5000|$|The {{name of the}} program, argv0, may {{be useful}} when {{printing}} <b>diagnostic</b> <b>messages</b> or for making one binary serve multiple purposes. The individual values of the parameters may be accessed with argv1, argv2, and argv3, {{as shown in the}} following program: ...|$|R
50|$|It should {{process a}} clear, easily understood, set of <b>diagnostic</b> error <b>messages.</b>|$|R
40|$|A {{conforming}} implementation shall {{produce at}} least one <b>diagnostic</b> <b>message</b> (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined. diagnostic shall produce <b>diagnostic</b> <b>message</b> Commentary This is a requirement on the implementation. The first violation may put the translator into a state where there are further, cascading violations. The {{extent to which a}} translator can recover from a violation and continue to process the source in a meaningful way is a quality-of-implementation issue. The standard says nothing about what constitutes a <b>diagnostic</b> <b>message</b> (usually simply called a diagnostic). Although each implementation is required to document how they identify such messages, playing a different tune to represent each constraint or syntax violation is one possibility. Such an implementation decision might be considered to have a low quality-of-implementation. The Rationale uses the term erroneous program {{in the context of a}} program containing a syntax error or constraint violation. Developers discussing C often use the term error and erroneous, but the standard does not define these terms...|$|E
40|$|This paper {{presents}} {{a technique to}} detect inadequate (i. e., missing or ambiguous) diagnostic messages for configuration errors issued by a configurable software system. The technique injects configuration errors into the software under test, monitors the software outcomes under the injected configu-ration errors, and uses natural language processing to analyze the output <b>diagnostic</b> <b>message</b> caused by each configuration error. The technique reports diagnostic messages that may be unhelpful in diagnosing a configuration error. We implemented the technique for Java in a tool, ConfDiagDetec-tor. In an evaluation on 4 real-world, mature configurable systems, ConfDiagDetector reported 43 distinct inadequate diagnostic mes-sages (25 missing and 18 ambiguous). 30 of the detected messages have been confirmed by their developers, and 12 more {{have been identified as}} inadequate by users in a user study. On average, Conf-DiagDetector required 5 minutes of programmer time and 3 minutes of compute time to detect each inadequate <b>diagnostic</b> <b>message...</b>|$|E
40|$|This {{document}} specifies an Internet standards track {{protocol for}} the Internet community, and requests discussion {{and suggestions for}} improvements. Please refer to the current edition of the "Internet Official Protocol Standards " (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited. Copyright Notice Copyright (C) The Internet Society (2000). All Rights Reserved. This document specifies the RSVP diagnostic facility, which allows a user to collect information about the RSVP state along a path. This specification describes the functionality, <b>diagnostic</b> <b>message</b> formats, and processing rules. 1...|$|E
40|$|The DECOS system {{architecture}} integrates timetriggered and event-triggered control for combining {{the benefits of}} both paradigms. For applications based on event-triggered control, this architecture establishes event-triggered virtual networks as overlay networks {{on top of an}} underlying time-triggered physical network. In the scope of this paper, we show that the underlying time-triggered network significantly improves the accuracy of the error detection mechanisms in comparison to eventtriggered architectures used today (e. g., based on Controller Area Network in the automotive industry). We introduce a framework with detectors for out-of-norm behavior, which are distributed across the nodes of the distributed real-time system. The detectors produce <b>diagnostic</b> <b>messages</b> augmented with information about the location and time of the detection event. Due to the fault isolation and the global time base of the underlying time-triggered network, the additional spatial and temporal information (besides the value domain) is available in the <b>diagnostic</b> <b>messages</b> and forms a meaningful input to a subsequent analysis process. The proposed framework manages the inherently imprecise temporal specifications of event-triggered application subsystems by correlating <b>diagnostic</b> <b>messages</b> along value, space and time. Thereby, a discrimination between a correct behavior of the computer system (e. g., triggered by rare conditions in the environment) and different fault classes (e. g., design faults, physical faults) becomes feasible. Also, the paper describes an implementation of the framework based on the Time-Triggered Protocol and explains the specification of the detectors and the analysis process using timed automata...|$|R
40|$|The User's {{manual for}} the NASA Structural Analysis (NASTRAN) program is presented. The manual {{contains}} all {{information needed to}} solve problems with NASTRAN. The volume is instructional and encyclopedic. The manual includes instruction in structural modeling techniques, instruction in input preparation, and information to assist {{the interpretation of the}} output. Descriptions of all input data cards, restart procedures, and <b>diagnostic</b> <b>messages</b> are developed...|$|R
40|$|Our paper {{outlines}} {{the application of}} two data mining techniques for the automatic processing of failure data. The first solutions aims at identifying those parts of a complex HW/SW system built up of COTS components whose incompatibilities or undesired interactions lead to system failures. The second approach is proposed for automatic discovery of those scenarios (involving user interaction, <b>diagnostic</b> <b>messages</b> and error detection signals) that typically result in failures. ...|$|R
40|$|National audienceGiven an LR(1) automaton, {{what are}} the states in which an error can be detected? For each such " error state ", what is a minimal input {{sentence}} that causes an error in this state? We propose an algorithm that answers these questions. Such an algorithm allows building a collection of pairs of an erroneous input sentence and a <b>diagnostic</b> <b>message,</b> ensuring that this collection covers every error state, and maintaining this property as the grammar evolves. We report on an application of this technique to the CompCert ISO C 99 parser, and discuss its strengths and limitations...|$|E
40|$|A {{preprocessing}} directive of {{the form}} # error pp-tokensopt new-line 1993 causes the implementation to produce a <b>diagnostic</b> <b>message</b> that includes the specified sequence of preprocessing tokens. Commentary Rationale The #error directive was introduced in C 89 to provide an explicit mechanism for forcing translation to fail under certain conditions. Formally, the Standard can require only that a diagnostic be issued when the #error directive is processed. It is {{the intent of the}} Committee, however, that translation cease immediately upon encountering this directive if this is feasible in the implementation. Further diagnostics on text beyond the directive are apt to be of little value. C++ 16. 5 p 1 [...] ., and renders the program ill-formed. #warning #erro...|$|E
40|$|This {{report was}} {{presented}} as a paper at the Computers in Engineering Symposium in Houston, TX, on 30 January 1995. This report outlines a formal method for merging changes in independently developed versions of software prototypes. A useful semantics-based method, which is guaranteed to detect all conflicts, is outlined. Prototype slicing is {{used to determine the}} affected parts of each variation and the preserved part of the base in both variations. The affected parts are then combined with the preserved part to complete the merge. Our slicing theorem guarantees that this method produces a prototype that correctly exhibits the significant behavior of each of the input versions, provided the changes do not conflict. Correctness is achieved by comparing the slices of the variation and the merged program with respect to the affected parts of each variation. If the slices are the same, then the result is correct, otherwise a <b>diagnostic</b> <b>message</b> results. Preliminary testing shows that this tool will enhance the ability of the prototype developer to deliver a prototype more quickly by allowing more concurrency in the development effort...|$|E
50|$|Even {{after the}} system has fully booted, the kernel may {{occasionally}} produce further <b>diagnostic</b> <b>messages.</b> Common examples of when this might happen are when I/O devices encounter errors, or USB devices are hot-plugged. dmesg provides a mechanism to review these messages at a later time. When first produced they will be directed to the system console: if the console is in use then these messages may be confused with or quickly overwritten by the output of user programs.|$|R
25|$|In this {{particular}} example, the macro {{is no more}} complex than a C-style textual substitution, but because parsing of the macro parameter occurs before the macro operates on the calling code, <b>diagnostic</b> <b>messages</b> {{would be far more}} informative. However, because the body of a macro is executed at compile time each time it is used, many techniques of optimization can be employed. It is even possible to entirely eliminate complex computations from resulting programs by performing the work at compile-time.|$|R
40|$|A limited {{capability}} form of NASTRAN level 16 {{is presented}} {{to meet the needs}} of universities and small consulting firms. The input cards, the programming language of the direct matrix abstraction program, the plotting, the problem definition, and the modules' <b>diagnostic</b> <b>messages</b> are described. Sample problems relating to the analysis of linear static, vibration, and buckling are included. This guide can serve as a handbook for instructional courses in the use of NASTRAN or for users who need only the capability provided by the condensed form...|$|R
40|$|Different {{companies}} in the same line of business can have similar computer systems with built-in diagnostic routines, {{and the ability to}} regularly send error-driven or event-driven environmental diagnostic messages in XML back to the system manufacturer. The system manufacturer typically uses these to determine faults in the system. The outcome of this troubleshooting can also assist end-users and clients in solving problems, and provide the production team valuable information {{that can be used to}} improve future versions of the product. A company merger could lead to the same team processing diagnostic messages from similar but different products, in different syntax, leading to the complexity of specifying and maintaining <b>diagnostic</b> <b>message</b> pattern specification and recognition for many different syntaxes. ^ This research reduces the above complexity by extending ISO Schematron, the industry standard language for XML semantic constraints specification and validation, with conceptual rules. Pace University Knowledge Graphs are used to describe the concepts or classes relevant to the diagnostic messages of a system, and the new conceptual Schematron rules are introduced to specify diagnostic patterns on these concepts. Such conceptual diagnostic patterns are then converted automatically into concrete Schematron rules based on the syntax of the specific diagnostic messages. A complete prototype was designed and implemented to validate this new methodology. ...|$|E
40|$|The SIVA/DIVA {{package is}} a {{collection}} of subroutines for the solution of ordinary differential equations. There are versions for single precision and double precision arithmetic. These solutions are applicable to stiff or nonstiff differential equations of first or second order. SIVA/DIVA requires fewer evaluations of derivatives than other variable order Adams predictor-corrector methods. There is an option for the direct integration of second order equations which can make integration of trajectory problems significantly more efficient. Other capabilities of SIVA/DIVA include: monitoring a user supplied function which can be separate from the derivative; dynamically controlling the step size; displaying or not displaying output at initial, final, and step size change points; saving the estimated local error; and reverse communication where subroutines return to the user for output or computation of derivatives instead of automatically performing calculations. The user must supply SIVA/DIVA with: 1) the number of equations; 2) initial values for the dependent and independent variables, integration stepsize, error tolerance, etc.; and 3) the driver program and operational parameters necessary for subroutine execution. SIVA/DIVA contains an extensive <b>diagnostic</b> <b>message</b> library should errors occur during execution. SIVA/DIVA is written in FORTRAN 77 for batch execution and is machine independent. It has a central memory requirement of approximately 120 K of 8 bit bytes. This program was developed in 1983 and last updated in 1987...|$|E
40|$|An {{implementation}} translates C source {{files and}} executes C programs in two data-processing-system environ-ments, {{which will be}} called the translation environment and the execution environment in this International Standard. environment execution diagnostic shall produce Commentary For a hosted implementation the two environments are often the same. In some cases application developers do cross-translate from one hosted environment to another hosted environment. In a freestanding environment, the two environments are very unlikely to be the same. A commonly used term for the execution environment is runtime system. In some cases this terminology refers to a more restricted set of functionality than a complete execution environment. The requirement on when a <b>diagnostic</b> <b>message</b> must be produced prevents a program from being translated from the source code, on the fly, as statements to execute are encountered. 104 Rationale Because C has seen widespread use as a cross-compiled cross-compilation language, a clear distinction must be made between translation and execution environments. The C 89 preprocessor, for instance, is permitted to evaluate the expression in a #if directive using the long integer or unsigned long integer arithmetic native to the translation environment: these integers must comprise at least 32 bits, but need not match the number of bits in the execution environment. In C 99, this arithmetic must be done in intmax_t or uintmax_t, which must comprise at least 64 bits and must match the execution environment. Other translation time arithmetic, however, such as type casting and floating point arithmetic, must more closely model the execution environment regardless of translation environment...|$|E
50|$|PLAGO, {{created at}} the Polytechnic Institute of Brooklyn, used a {{simplified}} {{subset of the}} PL/I language and focused on good <b>diagnostic</b> error <b>messages</b> and fast compilation times.|$|R
25|$|Within a {{few months}} of the Lisa's {{introduction}} in the US, fully translated versions of the software and documentation were commercially available for British, French, West German, Italian, and Spanish markets, followed by several Scandinavian versions shortly thereafter. The user interface for the OS, all seven applications, LisaGuide, and the Lisa diagnostics (in ROM) can be fully translated, without any programming required, using resource files and a translation kit. The keyboard can identify its native language layout, and the entire user experience will be in that language, including any hardware <b>diagnostic</b> <b>messages.</b>|$|R
40|$|COMUNICAR project {{develops}} two vehicle demonstrators (a {{city and}} an upper class car) integrating {{a new concept}} of multimedia HMI (Human Machine Interface) able to harmonise the messages oncoming both from the traditional on-vehicle information (e. g. tachometer, etc.) and the new functions for the driving support (e. g. ADA systems such as Adaptive Cruise Control, Lateral and Longitudinal Control, Collision Warning, etc.; Telematics services such as navigation, traffic and weather information, distance <b>diagnostic,</b> <b>messaging,</b> Internet, etc.; other information concerning Comfort and Entertainment such as CD and MP 3 player, DAB, DVD, Climate control, etc.) ...|$|R
40|$|This {{dissertation}} {{addresses the}} need for a formal method to support the merging of changes in independently developed versions of a prototype in a computer-aided rapid prototyping system. The goal is to provide the prototype developer with the ability to combine independently developed enhancements to a prototype, check for consistency, and automatically update all derived versions of a prototype with changes made to the base version. A useful semantics-based method is provided for change-merging that is guaranteed to detect all conflicts. Prototype slicing is used to capture the affected parts of each variation and the preserved part of the base in both variations. We then combine the affected parts with the preserved part using our model, which includes the first use of Brouwerian Algebras to formalize the merging of hard real time constraints. Our Slicing Theorem guarantees that this method produces a prototype that correctly exhibits the significant behavior of each of the input versions, provided the changes do not conflict the method achieves correctness by comparing the slice of the change-merged version with respect to each affected part against the same slice of the appropriate changed version. If the slices are the same, the change-merge is correct, otherwise a <b>diagnostic</b> <b>message</b> results. A preliminary conditional method for change-merging while programs is also provided that is strictly more accurate than previous methods. This dissertation contributes to computer-aided software maintenance by providing a model, algorithm and implementation for an automated change-merging tool for PSDL prototypes. Preliminary testing shows that this tool will enhance the ability of the prototype developer to deliver a prototype in less time by enabling more concurrency in the development effort. NANAU. S. Army (USA) autho...|$|E
40|$|All programmers make errors {{when writing}} program code, and for novices the {{difficulty}} of repairing errors can be frustrating and demoralising. It is widely recognised that compiler error diagnostics can be inaccurate, imprecise, or otherwise difficult for novices to comprehend, and many approaches to mitigating {{the difficulty of}} dealing with errors are centered around the production of diagnostic messages with improved accuracy and precision, and revised wording considered more suitable for novices. These efforts have shown limited success, partially due to uncertainty surrounding the types of error that students actually have the most difficulty with - which has most commonly been assessed by categorising them according to the <b>diagnostic</b> <b>message</b> already produced - and a traditional approach to the error diagnosis process which has known limitations. In this thesis we detail a systematic and thorough approach both to analysing which errors that are most problematic for students, and to automated diagnosis of errors. We detail a methodology for developing a category schema for errors and for classifying individual errors in student programs according to such a schema. We show that this classification results in a different picture {{of the distribution of}} error types when compared to a classification according to diagnostic messages. We formally define the severity of an error type as a product of its frequency and difficulty, and by using repair time as an indicator of difficulty we show that error types rank differently via severity than they do by frequency alone. Having developed a ranking of errors according to severity, we then investigate the contextual information within source code that experienced programmers can use to more accurately and precisely classify errors than compiler tools typically do. We show that, for a number of more severe errors, these techniques can be applied in an automated tool to provide better diagnostics than are provided by traditional compilers...|$|E
40|$|A {{considerable}} body {{of literature}} on consumers’ responses to information about firms’ corporate social responsibility (CSR) initiatives has been published over the past decade. To date, however, little if any of this research has looked at consumer reaction to such information communicated via the medium of advertising, despite {{the increasing use of}} such corporate societal advertising appeals. While scepticism is a common cognitive response toward advertising, how scepticism toward non-economic corporate image claims might be promoted or inhibited through message elements has not been the focus of research attention. This thesis seeks to address this knowledge gap by investigating the impact of two <b>diagnostic</b> <b>message</b> elements on scepticism toward specific CSR claims. This study examines whether consumer scepticism toward the advertising of CSR claims can be influenced by altering the diagnosticity of social topic information and CSR commitment message dimensions. Two key research questions are addressed: does the provision of more social topic information encourage consumers toward less CSR advertising claim scepticism?, and does more specific information about a firm’s CSR commitment, expressing both its history and actual achievements, and their impacts, inhibit CSR advertising claim scepticism? In order to investigate these two research questions, an experimental approach was used to allow the manipulation of message elements and the testing of cause and effect. Data received via an online panel of a cross-section of 417 Australian consumers were analysed, and the hypotheses specified in study were tested using analysis of variance and covariance techniques. Results from this research suggest that increased information about the social topic related to the domain of the firm’s CSR initiatives does not significantly influence the level of scepticism toward CSR advertising claims, but information specificity about the firm’s CSR commitment does. These results are impacted by the consumer’s level of scepticism toward advertising in general, attitude toward the notion of corporate social responsibility, and attitude toward the social topic. The findings of this thesis provide evidence that consumers have the ability to deal with larger cognitive loads, created by information about specific impacts of firms’ CSR programs, and that such diagnostic information is useful in reducing scepticism responses to CSR messages. These responses are important, as they form the foundation of subsequent attitudinal and belief structures so critical for influencing consumer behaviour. The theoretical contributions of this study include: (1) situating the role of social topic information, considered a critical element of advertising campaigns in social marketing, in CSR advertising situations; (2) implicating an organisation’s CSR history and CSR and impacts as important diagnostic elements in CSR message claims; and (3) defending the ability of consumers to adequately discriminate between cognitively demanding informational inputs when evaluating CSR advertising claims. Given increasing demand from consumers to learn about firms’ CSR efforts, and firms’ increasing willingness to respond to these information demands with CSR-based advertising campaigns, this study also offers guidance for marketing communication managers charged with developing corporate image based on CSR-based brand claims. Limitations and directions for future research are also discussed...|$|E
50|$|Within a {{few months}} of the Lisa's {{introduction}} in the US, fully translated versions of the software and documentation were commercially available for British, French, West German, Italian, and Spanish markets, followed by several Scandinavian versions shortly thereafter. The user interface for the OS, all seven applications, LisaGuide, and the Lisa diagnostics (in ROM) can be fully translated, without any programming required, using resource files and a translation kit. The keyboard can identify its native language layout, and the entire user experience will be in that language, including any hardware <b>diagnostic</b> <b>messages.</b>|$|R
40|$|Petri {{nets and}} in {{particular}} workflow nets as a process description language allow the application of formal verification methods, e. g., to prove soundness. Although tools for soundness checks do already exist, it is still difficult for the workflow designer to correct the process model according to the output of these tests – mostly because <b>diagnostic</b> <b>messages</b> are not directly linked to the graphical model and intuition of the error source is missing. In this paper we propose an idea to overcome this problem. We present concepts to visualize verification output, in particular soundness violation messages in a more userfriendly way. ...|$|R
40|$|The {{frequency}} {{of different kinds}} of error made by students learning to write computer programs has long been of interest to researchers and educators. In the past, various studies investigated this topic, usually by recording and analysing compiler error messages, and producing tables of relative frequencies of specific errors diagnostics produced by the compiler. In this paper, we improve on such prior studies by investigating actual logical errors in student code, as opposed to <b>diagnostic</b> <b>messages</b> produced by the compiler. The actual errors reported here are more precise, more detailed and more accurate than the diagnostic produced automatically...|$|R
