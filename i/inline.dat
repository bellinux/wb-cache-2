7722|623|Public
5|$|Sweatt {{began playing}} <b>inline</b> hockey {{at the age}} of eight in order to improve his skating for ice hockey. He began {{competing}} in the IIHF <b>InLine</b> Hockey World Championships with the United States national team in 2002. Playing seven straight years in the annual tournament, Sweatt won two gold (2004, 2006), one silver (2009) and two bronze medals (2003, 2005). At the 2008 IIHF <b>InLine</b> World Championships in Slovakia, Sweatt was named the tournament's Best Defenseman. He registered four goals and four assists in six games, ranking ninth among tournament defensemen in scoring, as the United States finished fourth in the competition, losing to Germany in the bronze medal game.|$|E
5|$|Sweatt {{has also}} played <b>inline</b> hockey at the {{international}} level, competing for the United States' national team at seven consecutive IIHF <b>InLine</b> Hockey World Championships from 2002 to 2009. At the 2008 tournament, he earned the Best Defenseman award. He has also played for the United States national select team on two occasions, once in 2007 and another at the 2009 Deutschland Cup.|$|E
5|$|The park hosts {{several miles}} of paved paths {{suitable}} for walking, running, biking, and <b>inline</b> skating. Skate Escape {{across from the}} park at the 12th Street entrance rents both bikes and skates. On weekend afternoons, skateboarders and <b>inline</b> skaters often share the open, paved area inside the 12th Street entrance.|$|E
40|$|Function <b>inlining</b> is a {{well known}} {{compiler}} optimization where a function call issubstituted with {{the body of the}} called function. Since function <b>inlining</b> in general increases the code size one might think that function <b>inlining</b> is a bad idea for embedded systems where a small code size is important. In this thesis we will show that function <b>inlining</b> is a necessary optimization for any industrial strength C/C++ compiler. We show that both the generated code size and execution time of the application can benefit from function <b>inlining.</b> We study and compare the <b>inlining</b> heuristics of 3 different industrial strength compilers for the ARM processor architecture. We also present a new <b>inlining</b> heuristic which makes <b>inlining</b> decisions based on several different properties. The study shows that the <b>inlining</b> heuristic proposed in this thesis is able to generate both smaller and faster code compared to the other <b>inlining</b> heuristics studied...|$|R
50|$|<b>Inlining</b> is an {{important}} optimization, but has complicated effects on performance. As a rule of thumb, some <b>inlining</b> will improve speed at very minor cost of space, but excess <b>inlining</b> will hurt speed, due to <b>inlined</b> code consuming {{too much of the}} instruction cache, and also cost significant space. A survey of the modest academic literature on <b>inlining</b> from the 1980s and 1990s is given in Jones & Marlow 1999.|$|R
40|$|In this paper, {{we present}} a {{comparative}} study of static and dynamic heuristics for <b>inlining.</b> We introduce <b>inlining</b> plans as a formal representation for nested <b>inlining</b> decisions made by an <b>inlining</b> heuristic. We use a well-known approximation algorithm for the knapsack problem as a common "metaalgorithm " for the static and dynamic <b>inlining</b> heuristics studied in this paper. We present performance results for an implementation of these <b>inlining</b> heuristics in the Jalape no dynamic optimizing compiler for Java. Our performance {{results show that the}} <b>inlining</b> heuristics studied in this paper can lead to significant speedups in execution time (up to 1. 68 Θ) even with modest limits on code size expansion (at most 10...|$|R
5|$|Except for 1980, the Pinto was {{available}} {{with a choice}} of two engines. For {{the first five years of}} production, only four-cylinder <b>inline</b> engines were offered. Ford changed the power ratings almost every year.|$|E
5|$|Arena, which predated Netscape Navigator and Microsoft's Internet Explorer, {{featured}} {{a number of}} innovations used later in commercial products. It was the first browser to support background images, tables, text flow around images, and <b>inline</b> mathematical expressions.|$|E
5|$|Because Perl is an {{interpreted}} language, it {{can give}} problems when efficiency is critical; in such situations, {{the most critical}} routines can be written in other languages (such as C), which can be connected to Perl via simple <b>Inline</b> modules or the more complex but flexible XS mechanism.|$|E
40|$|<b>Inlining</b> is an {{important}} optimization for programs that use procedural abstraction. Because <b>inlining</b> trades code size for execution speed, the effectiveness of an <b>inlining</b> algorithm is determined not only by its ability to recognize <b>inlining</b> opportunities but also by its discretion in exercising those opportunities. This paper presents a new <b>inlining</b> algorithm for higher-order languages that combines simple analysis techniques with demand-driven online transformation to achieve consistent and often dramatic performance gains in fast linear time. Benchmark results reported here demonstrate that this <b>inlining</b> algorithm is as effective as and significantly faster than offline, analysis-intensive algorithms recently described in the literature...|$|R
40|$|All modern compilers provide <b>inlining,</b> an {{optimization}} which replaces {{a function}} call by the function body. Implementations of <b>inlining</b> are usually focused on specic source languages or on specic algorithms {{to decide which}} functions should be <b>inlined.</b> We describe {{the implementation of a}} general <b>inlining</b> implementation in the program transformation language Stratego. This inliner should be usable for dierent source languages and decision algorithms. The implementation separates the analysis and transformation of the program, the traversal of the program and the decision when to do <b>inlining.</b> In addition, the implementation of several other optimizations that are enabled by <b>inlining</b> is discussed {{in the context of the}} highly optimizable Pan language. Contents...|$|R
40|$|AbstractMethod <b>inlining</b> {{is one of}} {{the most}} {{important}} optimizations in method-based just-in-time (JIT) compilers. It widens the compilation scope and therefore allows optimizing multiple methods as a whole, which increases the performance. However, if method <b>inlining</b> is used too frequently, the compilation time increases and too much machine code is generated. This has negative effects on the performance. Trace-based JIT compilers only compile frequently executed paths, so-called traces, instead of whole methods. This may result in faster compilation, less generated machine code, and better optimized machine code. In the previous work, we implemented a trace recording infrastructure and a trace-based compiler for JavaTM, by modifying the Java HotSpot VM. Based on this work, we evaluate the effect of trace <b>inlining</b> on the performance and the amount of generated machine code. Trace <b>inlining</b> has several major advantages when compared to method <b>inlining.</b> First, trace <b>inlining</b> is more selective than method <b>inlining,</b> because only frequently executed paths are <b>inlined.</b> Second, the recorded traces may capture information about virtual calls, which simplify <b>inlining.</b> A third advantage is that trace information is context sensitive so that different method parts can be <b>inlined</b> depending on the specific call site. These advantages allow more aggressive <b>inlining</b> while the amount of generated machine code is still reasonable. We evaluate several <b>inlining</b> heuristics on the benchmark suites DaCapo 9. 12 Bach, SPECjbb 2005, and SPECjvm 2008 and show that our trace-based compiler achieves an up to 51 % higher peak performance than the method-based Java HotSpot client compiler. Furthermore, we show that the large compilation scope of our trace-based compiler has a positive effect on other compiler optimizations such as constant folding or null check elimination...|$|R
5|$|Hašek and {{his former}} wife Alena have a son named Michael (born 1990) and a {{daughter}} named Dominika (born 1994). He divides much of his free time playing squash and <b>inline</b> hockey, where he plays defense. When he was younger, Hašek played competitive football as a midfielder, and was a junior tennis champion in Eastern Bohemia.|$|E
5|$|Next, {{the train}} passes through two {{consecutive}} horseshoe turns, {{first to the}} right and then to the left. As the name suggests, Horseshoe turns are highly banked horseshoe-shaped turns which feature track entering from roughly the same direction as where it exits. As the train exits the second horseshoe, it swoops down and begins a 270-degree helix to the right, which leads into the ride's second inversion, an <b>inline</b> twist. The <b>inline</b> twist sees riders perform a full rotation around the track, starting from a position where they are facing downward. After completing the twist, the train reaches the brake run and a final right-hand turn that leads back into the station.|$|E
5|$|The family {{includes}} 43 fonts, including 33 text fonts in 9 {{weights and}} 3 widths, 6 <b>inline</b> fonts in 5 weights and 2 widths (1 in condensed), 2 shadowed fonts in 2 weights and 1 width, 1 shadowed outline font, 1 deco font. Characters set support includes W1G.|$|E
5000|$|As {{functions}} evolve, {{they may}} become suitable for <b>inlining</b> {{where they were}} not before, or no longer suitable for <b>inlining</b> where they were before. While <b>inlining</b> or un-inlining a function is easier than converting to and from macros, it still requires extra maintenance which typically yields relatively little benefit.|$|R
40|$|<b>Inlining</b> and {{specialization}} {{appear in}} various forms throughout the implementation of modern programming languages. From mere compiler optimizations to sophisticated techniques in partial evaluation, they are omnipresent, yet each application is treated differently. This paper is an attempt at uncovering the relations between <b>inlining</b> (as done in production compilers) and staged computation (as done in partial evaluators) {{in the hope of}} bringing together the research advances in both fields. Using a two-level lambda calculus as the intermediate language, we show how to model <b>inlining</b> as a staged computation while avoiding unnecessary code duplication. The new framework allows us to define <b>inlining</b> annotations formally and to reason about their interactions with module code. In fact, we present a cross-module <b>inlining</b> algorithm that <b>inlines</b> all functions marked inlinable, even in the presence of ML-style parameterized modules. ...|$|R
40|$|Abstract: Function <b>inlining</b> is {{a widely}} known {{technique}} that has been adopted in compiler optimization research domain. <b>Inlining</b> functions can eliminate the overhead which is resulted from function calls, but with <b>inlining,</b> the code size also grows unpredictably; this is not suitable for embedded processors whose memory size is relatively small. In this paper, we introduce a novel function <b>inlining</b> approach using a heuristic rebate_ratio; functions to be <b>inlined</b> are selected according to their rebate_ratios in a descending way. This kind of code optimization operation works at the source code level. Compared with other algorithms, ours are easier to implement. Our target is to get an optimal result of function <b>inlining</b> which attempts to achieve the maximum performance improvement while keeping the code size within a defined limit...|$|R
5|$|When Ohno {{was very}} young, his father meticulously {{researched}} childcare providers {{to care for}} his son during his long work hours. As he grew older, his father became concerned his son would become a latchkey kid, so he got his son involved with competitive swimming and quad-speed roller skating at age 6. He later switched from the instruction of Benton Redford, a National Champion, to a team in Federal Way, WA called Pattisons Team Extreme and became a national <b>inline</b> speedskating champion and record holder himself. His father used <b>Inline</b> Speedskating to fill his spare time. Ohno's days were spent with morning swimming practices, followed by schooling, and finally skating practices in the afternoon.|$|E
5|$|Wigan Warlords are an <b>Inline</b> Hockey team, current Under-16 {{national}} champions and European Bronze medalists. The club attracts {{players from}} Wigan {{and the surrounding}} areas. Wigan's district badminton league consists of 30 teams across 3 divisions.|$|E
5|$|Arsenal's {{clock was}} moved from Highbury {{to the outer}} side of the new stadium, with a new larger version of the feature added inside the ground in August 2010. At {{the same time as}} the {{unveiling}} of the new clock, the south stands at the venue were also renamed Clock End <b>inline</b> with the same name previously used at Highbury.|$|E
40|$|Aggressive {{function}} <b>inlining</b> {{can lead}} to significant improvements in execution time. This potential is reduced by extensive instruction cache (Icache) misses caused by code expansion involved with aggressive <b>inlining.</b> It {{is very difficult to}} predict which inlinings will lead to Icache conflicts, as the exact location of code lines in the executable depends on completing the <b>inlining</b> first. In this work we propose a new method for selective <b>inlining</b> called “Icache Loop Blockings” (ILB). In ILB we allow inlinings that do not create multiple <b>inlined</b> copies of the same function in hot execution cycles. This is done to prevent any increase in the Icache footprint of hot execution cycles. This method is significantly more aggressive than previous ones, experiments show it is also better. Results on a server level processor and on an embeded CPU, running SPEC CINT 2000, show an improvement of 10 % in the execution time of the ILB in comparison to other <b>inlining</b> methods. The scheme was implemented in a post link tool (fdpr). This was achieved without bloating the size of the hot code executed at any single point of execution, which is crucial for the embedded processor domain. We have also considered the synergy between code reordering and <b>inlining</b> focusing on the way <b>inlining</b> can help code reordering. This aspect of <b>inlining</b> has not been studied in previous works. ...|$|R
40|$|Frequently invoked large {{functions}} {{are common in}} non-numeric applications. These large functions present challenges to modern compilers {{not only because they}} require more time and resources at compilation time, but also because they may prevent optimizations such as function <b>inlining.</b> However, usually it is the case that large portions of the code in a hot function fhost are executed much less frequently than fhost itself. Partial <b>inlining</b> is a natural solution to the problems caused by including cold code segments that are seldom executed into hot functions that are frequently invoked. When applying partial <b>inlining,</b> a compiler outlines cold statements from a hot function fhost. After outlining, fhost becomes smaller and thus can be easily <b>inlined.</b> This paper presents a framework for function outlining and partial <b>inlining</b> that includes several innovations: (1) an abstract-syntax-tree-based analysis and transformation to form cold regions for outlining; (2) a set of ¤exible heuristics to control the aggressiveness of function outlining; (3) several possible function outlining strategies; (4) alias agent, a new technique that overcomes negative side-effects of function outlining. With the proper strategy, partial <b>inlining</b> improves performance by up to 5. 75 %. A performance study also suggests that partial <b>inlining</b> is not effective on enabling more aggressive <b>inlining.</b> The performance improvement from partial <b>inlining</b> actually comes from better code placement and better code generation. ...|$|R
40|$|In many garbage {{collected}} systems, the mutator {{performs a}} write barrier for every pointer update. Using generational garbage collectors, we study in depth three code placement options for rememberedset write barriers: <b>inlined,</b> out-of-line, and partially <b>inlined</b> (fast path <b>inlined,</b> slow path out-of-line). The fast path determines if the collector needs {{to remember the}} pointer update. The slow path records the pointer in a list when necessary. Efficient implementations minimize the instructions on the fast path, and record few pointers (from 0. 16 to 3 % of pointer stores in our benchmarks). We find the mutator performs best with a partially <b>inlined</b> barrier, by a modest 1. 5 % on average over full <b>inlining.</b> We als...|$|R
5|$|As of 2017, {{there are}} 76 members: 54 full members, 21 {{associate}} members and one affiliate member. Indonesia, Nepal, and the Philippines are the newest members, {{all of whom}} joined on May 20, 2016. In 2017, there are 47 participated in the Men's World Championships, 37 participated in the Women's World Championships and 16 participated in the <b>Inline</b> Hockey World Championships.|$|E
5|$|As well as rugby sevens, {{baseball}} and softball, which were {{dropped from the}} Olympic programme in 2005, karate, squash, golf and roller sports (<b>inline</b> speed skating) were all seeking {{to be included in}} the 2016 games and leaders of the seven sports made formal presentations to the IOC executive board in June 2009. A new system was in place at this session in which a sport now needs only a simple majority rather than the two-thirds majority that was required before.|$|E
5|$|Designs were {{submitted}} {{in response to}} the Navy's specifications by Vought-Sikorsky and Curtiss-Wright. The Vought design, designated Model 403 by the company, was similar to the company's OS2U Kingfisher, which was then under development to replace the SOC aboard U.S. Navy battleships, but had its monoplane wing moved higher on the fuselage than that of the Kingfisher, and differed in the attachment method used by its single-float landing gear. In addition, the radial engine of the OS2U was replaced by an <b>inline</b> Ranger V-770 in a squared-off cowling.|$|E
40|$|Optimizing {{implementations}} for object-oriented languages rely on aggressive <b>inlining</b> {{to achieve}} good performance. Sometimes the compiler is over-eager in its quest for good performance, however, and <b>inlines</b> too many methods that merely increase compile time and consume extra compiled code space with little benefit in run-time performance. We have designed and implemented {{a new approach}} to <b>inlining</b> decision making in which the compiler performs <b>inlining</b> experimentally and records the results in a database that can be consulted to guide future <b>inlining</b> decisions of the same routine at call sites that have similar static information. Central to our approach is a new technique, called type group analysis, that calculates how much of the static information available at a call site was profitably used during <b>inlining.</b> The results of type group analysis enable the compiler to compute a generalization of the actual static information for a particular experiment, significantly increasing reuse [...] ...|$|R
40|$|While <b>inlining</b> {{is one of}} {{the heavily}} used {{optimizations}} for compiling Java programs, its overly aggressive usage can actually hurt the program performance. Therefore, the <b>inlining</b> heuristics used in various Java virtual machines need to be appropriately tuned in order to maximize <b>inlining</b> benefits without introducing its potential cost. However, the current tuning process is usually performed manually, which can not achieve the optimal solution. Several algorithms (e. g., the genetic algorithm) have been developed to automate the tuning process, but most of them are very time-consuming due to the large number of parameters used in an <b>inlining</b> heuristic. In this paper, we use multivariate statistical methods to find the parameters which actually impact the performance of an <b>inlining</b> heuristic. By focusing on these ”effective ” parameters, we can greatly shorten the tuning process and further simplify the original <b>inlining</b> heuristic while maintaining the similar performance. ...|$|R
50|$|The precise {{effect of}} <b>inlining</b> on cache {{performance}} is complicated. For small cache sizes (much {{smaller than the}} working set prior to expansion), the increased sequentiality dominates, and <b>inlining</b> improves cache performance. For cache sizes close to the working set, where <b>inlining</b> expands the working set so it no longer fits in cache, this dominates and cache performance decreases. For cache sizes larger than the working set, <b>inlining</b> has negligible impact on cache performance. Further, changes in cache design, such as load forwarding, can offset the increase in cache misses.|$|R
5|$|Green Lantern Coaster {{begins with}} a u-turn out of the station. It ascends a chain lift hill before going down a small dip and into an s-bend {{followed}} by a u-turn. After a slight ascent, the car enters a 120.5° drop – the steepest in the southern hemisphere. The track then returns to approximately two thirds of its original height before entering {{the first set of}} block brakes. These brakes lead into a left turn with reverse or outward banking. It then drops under the block brakes and into the first inversion – a Dive Loop. The inversion begins with half of an <b>inline</b> twist which transitions into half of a vertical loop. Upon exiting the inversion the track inclines into a second set of block brakes. The train then goes around a right u-turn and into the second inversion – a downwards <b>inline</b> twist. This leads into a cutback-style turnaround before entering the final brake run and returning to the station.|$|E
5|$|In 1983, the DPMA withdrew its {{opposition}} to the standard, citing the responsiveness of the committee to public concerns. In the same year, a National Bureau of Standards study concluded that the proposed standard would present few problems. A year later, a COBOL-80 compiler was released to DEC VAX users, who noted that conversion of COBOL-74 programs posed few problems. The new EVALUATE statement and <b>inline</b> PERFORM were particularly well received and improved productivity, thanks to simplified control flow and debugging.|$|E
5|$|In {{the late}} 1930s the United States Navy {{developed}} {{a set of}} specifications for a new scout-observation aircraft to operate from its cruisers in the reconnaissance and gunnery spotting roles. Intended to replace the Curtiss SOC biplane, the requirements included that the aircraft should have folding wings, have a superior range and speed {{to that of the}} SOC, and that the new type should be powered by the Ranger V-770 <b>inline</b> engine.|$|E
5000|$|Compilers use {{a variety}} of {{mechanisms}} to decide which function calls should be inlined; these can include manual hints from programmers for specific functions, together with overall control via command-line options. <b>Inlining</b> is done automatically by many compilers in many languages, based on judgment of whether <b>inlining</b> is beneficial, while in other cases it can be manually specified via compiler directives, typically using a keyword or compiler directive called [...] Typically this only hints that <b>inlining</b> is desired, rather than requiring <b>inlining,</b> with the force of the hint varying by language and compiler.|$|R
40|$|Adaptive {{compilation}} uses a feedback-driven {{process to}} leverage additional compilation time into improved executable performance. Previous work on adaptive compilation has demonstrated its benefit at an inter-optimization level. This dissertation investigates {{the ability of}} adaptive techniques to improve the performance of individual compiler optimizations. We first examine {{the ability to use}} adaptive compilation with current commercial compilers. We use adaptive techniques to find good blocking sizes with the MIPSpro compiler. However, we also observe that current compilers are poorly parameterized for adaptive compilation. We then construct an adaptive <b>inlining</b> system that demonstrates the potential of adaptive compilation to improve individual optimizations. We design the inliner to accept condition strings that determine which call sites are <b>inlined.</b> We develop an adaptive controller for the inliner based on a detailed understanding of the search space that the condition strings provide. Our adaptive <b>inlining</b> system consistently finds good sets of <b>inlining</b> decisions and outperforms static techniques. In addition, we demonstrate the inability of static techniques to provide a universal <b>inlining</b> solution and the necessity of adaptive <b>inlining.</b> Adaptive <b>inlining</b> demonstrates the capacity of adaptive compilation to improve the performance of a single, carefully designed optimization...|$|R
5000|$|The {{function}} is recursive and not accompanied by [...] With the pragma, recursive functions are <b>inlined</b> to a default depth of 16 calls. To reduce the <b>inlining</b> depth, use [...] pragma.|$|R
