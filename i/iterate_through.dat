116|312|Public
500|$|Python {{features}} sequence unpacking where multiple expressions, each evaluating {{to anything}} that can be assigned to (a variable, a writable property, etc), are associated in the identical manner to that forming tuple literals and, as a whole, are put on the left hand side of the equal sign in an assignment statement. The statement expects an iterable object on the right hand side of the equal sign that produces the same number of values as the provided writable expressions when iterated through, and will <b>iterate</b> <b>through</b> it, assigning each of the produced values to the corresponding expression on the left.|$|E
2500|$|You {{can also}} <b>iterate</b> <b>through</b> {{a list of}} items, similar to {{what you can do}} with arrays in other languages: ...|$|E
2500|$|First, pick a guess, {{the value}} of the guess affects only how many {{iterations}} are required to reach an approximation of a certain accuracy. Then, using that guess, <b>iterate</b> <b>through</b> the following recursive computation: ...|$|E
5000|$|<b>Iterating</b> <b>through</b> {{a mapping}} {{can be done}} using either foreach: ...|$|R
25|$|This program <b>iterates</b> <b>through</b> all {{possible}} programs (by <b>iterating</b> <b>through</b> {{all possible}} strings and only considering {{those which are}} valid programs), starting with the shortest. Each program is executed to find the result produced by that program, comparing it to the input s. If the result matches {{the length of the}} program is returned.|$|R
5000|$|Dictionary {{contents}} can be <b>iterated</b> <b>through</b> using forall, {{though not}} in any particular order: ...|$|R
5000|$|One can <b>iterate</b> <b>through</b> (key, value) pairs {{using the}} [...] function: ...|$|E
5000|$|You can <b>iterate</b> <b>through</b> {{the list}} with the {{following}} code (C++03): ...|$|E
5000|$|<b>Iterate</b> <b>through</b> {{each element}} of the data by column, then by row ...|$|E
50|$|After <b>iterating</b> <b>through</b> {{multiple}} products, Gross launched Greplin (later renamed Cue) with co-founder Robby Walker.|$|R
3000|$|... [...]) is the Kronecker’s delta {{function}} from Equation 6. The {{left side of}} the Equation 7 is a summation series that <b>iterates</b> <b>through</b> an edge list and increments for each pair of the same class. The right side of Equation 7 is the matrix formula which <b>iterates</b> <b>through</b> an adjacency matrix and increments the same way. The one-half fraction from the matrix formula is there to remove the double counting of pairs.|$|R
2500|$|For-loops {{can also}} loop through a table using ipairs (...) to <b>iterate</b> numerically <b>through</b> arrays and pairs (...) to <b>iterate</b> {{randomly}} <b>through</b> dictionaries.|$|R
5000|$|The {{placement}} {{policy is}} slow {{as it takes}} time to <b>iterate</b> <b>through</b> all the lines.|$|E
5000|$|<b>Iterate</b> <b>through</b> {{liveness}} start {{points and}} allocate a register from the available register pool to each live variable.|$|E
50|$|The {{order of}} records in fstab is {{important}} because fsck(8), mount(8), and umount(8) sequentially <b>iterate</b> <b>through</b> fstab doing their thing.|$|E
2500|$|Assuming that someNode is some node in a {{non-empty}} circular singly linked list, {{this code}} <b>iterates</b> <b>through</b> that list starting with someNode: ...|$|R
5000|$|Every {{time the}} loop {{is about to}} process another item from the list, the {{function}} grabs the current continuation, and assigns it to the variable 'control-state'. This variable initially is the closure that <b>iterates</b> <b>through</b> all elements of the list. As the computation progresses, it becomes a closure that <b>iterates</b> <b>through</b> a suffix of the given list. While the use of [...] "call/cc" [...] is unnecessary for a linear collection, such as , the code generalizes to any collection that can be traversed.|$|R
5000|$|For-loops {{can also}} loop through a table using [...] to <b>iterate</b> numerically <b>through</b> arrays and [...] to <b>iterate</b> {{randomly}} <b>through</b> dictionaries.Generic for-loop {{making use of}} closures: ...|$|R
5000|$|Be able to <b>iterate</b> <b>through</b> a text's {{contents}} {{without access}} to the text's actual structure (e.g., array, linked list, string) ...|$|E
5000|$|You {{can also}} <b>iterate</b> <b>through</b> {{a list of}} items, similar to {{what you can do}} with arrays in other languages: ...|$|E
50|$|This kind of weak linking {{forces the}} dynamic linker to resolve which library {{contains}} which symbol when the executable is run. The dynamic linker on Linux, for example, reads through the DT_NEEDED section of an ELF object and loads needed libraries; but isn't told where required symbols are. For this, it must <b>iterate</b> <b>through</b> each unresolved symbol in the object, {{and for each}} of these, <b>iterate</b> <b>through</b> each loaded library, checking until it finds a matching symbol. This can be time consuming.|$|E
5000|$|To access {{an entry}} in Python simply use the array {{indexing}} operator. For example, >>> phonebookSmart''555-9999'An example loop <b>iterating</b> <b>through</b> all the keys of the dictionary: ...|$|R
3000|$|... ψ, {{the events}} that satisfy the formula are exactly those {{immediately}} preceding an event where ψ holds. Consequently, the reducer <b>iterates</b> <b>through</b> its input tuples of 〈X [...]...|$|R
50|$|After the {{developer}} has <b>iterated</b> <b>through</b> all marked classes and identified if change is necessary, they are then able to organize their actions to most effectively complete the change request.|$|R
50|$|Some {{languages}} allow subroutines to {{be defined}} to accept a variable number of arguments. For such languages, the subroutines must <b>iterate</b> <b>through</b> the list of arguments.|$|E
50|$|More complex {{algorithms}} can {{be formed}} by mixing substitution and transposition in a product cipher; modern block ciphers such as DES <b>iterate</b> <b>through</b> several stages of substitution and transposition.|$|E
5000|$|In this way, we {{may start}} at [...] with , and <b>iterate</b> <b>through</b> each value of [...] up to [...] If at any stage the {{resultant}} summation is zero, i.e.|$|E
5000|$|A {{sequence}} of perfect powers {{can be generated}} by <b>iterating</b> <b>through</b> the possible values for m and k. The first few ascending perfect powers in numerical order (showing duplicate powers) are : ...|$|R
5000|$|... {{for value}} in iterable: print valueIn Python, an iterable is an object {{which can be}} {{converted}} to an iterator, which is then <b>iterated</b> <b>through</b> during the for loop; this is done implicitly.|$|R
5000|$|<b>Iterates</b> <b>through</b> {{all used}} indices of array {{including}} all user-defined properties of array object, if any. Thus {{it may be}} better to use a traditional for loop with a numeric index when iterating over arrays.|$|R
5000|$|For {{each image}} , <b>iterate</b> <b>through</b> all {{possible}} affine transformations [...] (rotation, x-translation, y-translation, x-scale, y-scale, x-shear, y-shear) and test if [...] decreases the joint pixelwise entropies. If so, set [...]|$|E
50|$|Instead {{of using}} an NSEnumerator object or indices to <b>iterate</b> <b>through</b> a collection, Objective-C 2.0 offers the fast {{enumeration}} syntax. In Objective-C 2.0, the following loops are functionally equivalent, but have different performance traits.|$|E
5000|$|First, pick a guess, {{the value}} of the guess affects only how many {{iterations}} are required to reach an approximation of a certain accuracy. Then, using that guess, <b>iterate</b> <b>through</b> the following recursive computation: ...|$|E
5000|$|WebbIE {{uses the}} Microsoft WebBrowser ActiveX control to fetch and parse web pages into the W3C DOM and MSHTML DOM. It then <b>iterates</b> <b>through</b> the DOM {{creating}} a text representation. The {{implications of this}} include: ...|$|R
30|$|Yamakawa-Shimada’s {{algorithm}} {{should therefore}} avoid creating the configurations illustrated on Figures 15, 16, 17 and 18 while <b>iterating</b> <b>through</b> the sorted arrays of potential hexahedra and prisms. Non-conformities can be efficiently identified by employing hashing techniques.|$|R
5000|$|So, {{what about}} the {{conditional}} probability of failure as the rounding step <b>iterates</b> <b>through</b> the sets?Since [...] in any outcome where the rounding step fails,by Markov's inequality, the conditional probability of failureis at most the conditional expectation of [...]|$|R
