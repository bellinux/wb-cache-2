8|3|Public
2500|$|Infinite loops can be {{implemented}} using other control flow constructs. Most commonly, in unstructured programming this is jump back up (goto), while in structured programming this is an <b>indefinite</b> <b>loop</b> (while loop) set to never end, either by omitting the condition or explicitly setting it to true, as while (true) .... Some languages have special constructs for infinite loops, typically by omitting the condition from an <b>indefinite</b> <b>loop.</b> Examples include Ada (loop ... end loop), Fortran (DO ... END DO), Go (for { ... }), and Ruby (loop do ... end).|$|E
5000|$|Infinite loops can be {{implemented}} using other control flow constructs. Most commonly, in unstructured programming this is jump back up (goto), while in structured programming this is an <b>indefinite</b> <b>loop</b> (while loop) set to never end, either by omitting the condition or explicitly setting it to true, as [...] Some languages have special constructs for infinite loops, typically by omitting the condition from an <b>indefinite</b> <b>loop.</b> Examples include Ada (...) , Fortran (...) , Go (...) , and Ruby (...) [...]|$|E
5000|$|Some {{languages}} {{have special}} constructs for infinite loops, typically by omitting the condition from an <b>indefinite</b> <b>loop.</b> Examples include Ada (...) , Fortran (...) , Go (...) , and Ruby (...) [...]|$|E
50|$|Two frame {{types are}} used {{in order to find}} the route to the {{destination}} network segment. Single-Route (SR) frames make up most of the network traffic and have set destinations, while All-Route (AR) frames are used to find routes. Bridges send AR frames by broadcasting on all network branches; each step of the followed route is registered by the bridge performing it. Each frame has a maximum hop count, which is determined to be greater than the diameter of the network graph, and is decremented by each bridge. to avoid <b>indefinite</b> <b>looping</b> of AR frames, frames are dropped when this hop count reaches zero. The first AR frame that reaches its destination is considered to have followed the best route, and the route can be used for subsequent SR frames; the other AR frames are discarded.|$|R
40|$|The paper {{presents}} a {{contribution of the}} Institute IRITEL {{to the development of}} telecommunications networks of Serbian and former Yugoslav electric power industry network. The contribution is primarily related to the development and production of specialized telephone exchanges, but also to the solution of specific problems of the power telecommunications networks, such as overvoltage protection, <b>indefinite</b> routing <b>loops,</b> call collisions, and others...|$|R
5000|$|Unable {{to afford}} a Mellotron, Dave Biro invented this {{instrument}} for personal use in early 1974. When Dave's manager, Ed Cohen first heard the prototype at a Blackwood club engagement, he was stunned - the mixed strings were better than {{either of the two}} Mellotrons in Connecticut at the time. Ed arranged to show it to Rick Wakeman in October 1974 after a concert performance in Connecticut. Wakeman played it backstage noting it sounded [...] "more mellow than a Mellotron", and realizing it allowed for more variety in playing styles because there was no worry about the tape running out. Wakeman was so impressed by the <b>indefinite</b> tape <b>loop</b> idea that he asked Biro if he'd like to [...] "make some money with this thing" [...] and offered to fund its manufacture. It was developed in 1975 by Birotronics, Ltd which was one of Wakeman's Complex 7 businesses. The Packhorse Road Case company was also part of Complex 7.|$|R
5000|$|The DO/UNTIL/END {{block in}} RPL {{supports}} an <b>indefinite</b> <b>loop</b> {{with the condition}} test {{at the end of}} the loop. The syntax of the DO/UNTIL/END block is: ...|$|E
5000|$|Infinite loops can be {{implemented}} using various control flow constructs. Most commonly, in unstructured programming this is jump back up (goto), while in structured programming this is an <b>indefinite</b> <b>loop</b> (while loop) set to never end, either by omitting the condition or explicitly setting it to true, as [...]|$|E
40|$|Dijkstraのgoto文有害説とそれに引き続く構造的プログラミングの提唱以降,goto文の使用に関する問題は永く議論された. goto文の使用法に関し理論的裏付けを持つ研究としては,逐次的プログラムでの任意の制御フローは順次接続・条件分岐・反復の 3 基本構追のみで表現可能であるという結果に基づくMillsらのgoto文排斥論以外は皆無である. Dijkstra本来の正しさを示しやすいプログラムを害くための構造化という立場一つまりプログラム検証論の立場-からのgoto文使用の是非は考察されていない. 本論文では検証手段としてのHoare論理に基づき有限状態機械モデルに基づくプログラミングでのgoto文の使用を検討する. その結果,状態をラベルで表し状態遷移をgoto文での飛び越しで行うプログラミングスタイルが,状態を表す変数を追加しgoto文を除いたプログラミングスタイルと比べ. Hoare論理による検証での表明が簡単で自然な形となり機械的検証の時間的コストも少ない. ゆえにプログラムの正しさの示しやすさという観点からは有限状態機械モデルに基づくプログラミングでの状態変数導入によるgoto文除去は有害でありgoto文を用いたスタイルの方が望ましいことを示す. : There {{have been}} {{a vast amount of}} debates on the issue on the use of goto {{statements}} initiated by the famous Dijkstra's Letter to the Editor of CACM and his proposal of "Structured Programming". Except for the goto-less programming style by Mills {{based on the fact that}} any control flows of sequential programs can be expressed by the sequential composition, the conditional (if-then-else) and the <b>indefinite</b> <b>loop</b> (while), there have not been, however, any scientific accounts on this issue from the Dijkstra's own viewpoint of verifiability of programs. In this work, we reconsider this issue from the viewpoint of Hoare Logic, the most standard framework for correctness-proving, and we see that the use of goto's for expressing state transitions in programs designed with the finite state machine modelling can be justified from the Hoare Logic viewpoint by showing the fact that constructing the proof-outline of a program using goto's for this purpose is easier than constructing the proof-outline of a Mills-style program without goto by introducing a new variable...|$|E
40|$|A Users Guide for the {{axial flow}} turbine {{off-design}} computer program AXOD 2 is composed in this paper. This Users Guide is supplementary {{to the original}} Users Manual of AXOD. Three notable contributions of AXOD 2 to its predecessor AXOD, both {{in the context of}} the Guide or in the functionality of the code, are described and discussed in length. These are: 1) a rational representation of the mathematical principles applied, with concise descriptions of the formulas implemented in the actual coding. Their physical implications are addressed; 2) the creation and documentation of an Addendum Listing of input namelist-parameters unique to AXOD 2, that differ from or are in addition to the original input-namelists given in the Manual of AXOD. Their usages are discussed; and 3) the institution of proper stoppages of the code execution, encoding termination messaging and error messages of the execution to AXOD 2. These measures are to safe-guard the integrity of the code execution, such that a failure mode encountered during a case-study would not plunge the code execution into <b>indefinite</b> <b>loop,</b> or cause a blow-out of the program execution. Details on these are discussed and illustrated in this paper. Moreover, this computer program has since been reconstructed substantially. Standard FORTRAN Langue was instituted, and the code was formatted in Double Precision (REAL* 8). As the result, the code is now suited for use in a local Desktop Computer Environment, is perfectly portable to any Operating System, and can be executed by any FORTRAN compiler equivalent to a FORTRAN 9095 compiler. AXOD 2 will be available through NASA Glenn Research Center (GRC) Software Repository...|$|E

