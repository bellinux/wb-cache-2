134|229|Public
25|$|In C++ and PHP, unary prefix & {{before a}} <b>formal</b> <b>parameter</b> of a {{function}} denotes pass-by-reference.|$|E
25|$|In {{computer}} programming, two {{notions of}} parameter are commonly used, and {{are referred to}} as parameters and arguments—or more formally as a <b>formal</b> <b>parameter</b> and an actual parameter.|$|E
25|$|All X# {{executive}} code {{should be}} placed in functions defined by the 'function' keyword. Unlike C, X# does not support any <b>formal</b> <b>parameter</b> declaration in the header of the functions, so the conventional parentheses after the function name are omitted. Because line-fixed patterns are specified in syntax implemented in code parser, the opening curly bracket can't {{be placed on the}} next line, unlike in many other C-style languages.|$|E
5000|$|... drop-formal removes <b>formal</b> <b>parameters,</b> {{based on}} the {{contents}} of the drop lists. Its parameters are, ...|$|R
50|$|A {{generic unit}} is a package or a {{subprogram}} that takes {{one or more}} generic <b>formal</b> <b>parameters.</b>|$|R
2500|$|Perl 6 {{introduces}} true <b>formal</b> <b>parameters</b> to the language. In Perl 6, a subroutine declaration {{looks like}} this: ...|$|R
2500|$|... x is the <b>formal</b> <b>parameter</b> (the parameter) of the defined function.|$|E
2500|$|... {{called the}} <b>formal</b> <b>parameter</b> of the abstraction, and [...] {{is the body}} ...|$|E
2500|$|... to an {{argument}}, binds the <b>formal</b> <b>parameter</b> v to {{the argument}} and then ...|$|E
5000|$|The <b>formal</b> <b>parameters</b> of {{functions}} are {{also referred to}} as variables. For instance, in this Python code segment, ...|$|R
5000|$|The {{order in}} which actual {{arguments}} for <b>formal</b> <b>parameters</b> are passed (or the parts of a large or complex argument) ...|$|R
5000|$|Notice {{that the}} <b>formal</b> <b>parameters</b> {{listed in the}} {{argument}} list to the [...] command are simply the defined names for statically allocated global variables. The semantics of parameter passing was given as being equivalent to assignment {{at the time of}} the control transfer to the destination unit, and if actual parameters were omitted, as in the second [...] command above, the effect was to leave the prior values of the corresponding <b>formal</b> <b>parameters</b> unchanged.|$|R
2500|$|... {{in place}} of the <b>formal</b> <b>parameter</b> of , and the result is a new lambda ...|$|E
2500|$|... (Using [...] "" [...] to {{indicate}} multiplication.) [...] x {{here is the}} <b>formal</b> <b>parameter</b> of the function. To evaluate the square for a particular ...|$|E
2500|$|... 3 is {{the actual}} {{parameter}} (the argument) for evaluation by the defined function; it is a given value (actual value) that is substituted for the <b>formal</b> <b>parameter</b> of the defined function. (In casual usage the terms parameter and argument might inadvertently be interchanged, and thereby used incorrectly.) ...|$|E
5000|$|It is also {{possible}} to have 'constrained' <b>formal</b> <b>parameters,</b> for which the actual parameter must inherit from a given class, the [...] "constraint". For example in ...|$|R
5000|$|Perl 6 {{introduces}} true <b>formal</b> <b>parameters</b> to the language. In Perl 6, a subroutine declaration {{looks like}} this: sub do_something(Str $thing, Int $other) { [...] [...] [...] }As in Perl 5, the <b>formal</b> <b>parameters</b> (i.e., the {{variables in the}} parameter list) are aliases to the actual parameters (the values passed in), but by default, the aliases are constant so they cannot be modified. They may be declared explicitly as read-write aliases for the original value or as copies using the [...] or [...] directives should the programmer require them to be modified locally.|$|R
5000|$|Generic {{classes are}} {{declared}} with their class {{name and a}} list of one or more <b>formal</b> generic <b>parameters.</b> In the following code, class [...] has one <b>formal</b> generic <b>parameter</b> ...|$|R
2500|$|Perl 5 defines subroutines without <b>formal</b> <b>{{parameter}}</b> lists at all (though simple parameter counting {{and some}} very loose type checking {{can be done}} using Perl 5's [...] "prototypes"). Subroutine arguments passed in are aliased into {{the elements of the}} array @_. If the elements of @_ are modified, the changes are reflected in the original data.|$|E
2500|$|A Church numeral is a higher-order {{function}}—it takes a single-argument function f, {{and returns}} another single-argument function. The Church numeral n {{is a function}} that takes a function f as argument and returns the n-th composition of f, i.e. the function f composed with itself n times. This is denoted f(n) and {{is in fact the}} n-th power of f (considered as an operator); f(0) is defined to be the identity function. Such repeated compositions (of a single function f) obey the laws of exponents, which is why these numerals can be used for arithmetic. (In Church's original lambda calculus, the <b>formal</b> <b>parameter</b> of a lambda expression was required to occur at least once in the function body, which made the above definition of 0 impossible.) ...|$|E
2500|$|In {{contrast}} to Java, languages like C# do not enforce that exceptions {{have to be}} caught. According to Hanspeter Mössenböck, not distinguishing between to-be-called (checked) exceptions and not-to-be-called (unchecked) exceptions makes the written program more convenient, but less robust, as an uncaught exception results in an abort with a stack trace. Kiniry (2006) notes however that Java's JDK (version 1.4.1) throws {{a large number of}} unchecked exceptions: one for every 140 lines of code, whereas Eiffel uses them much more sparingly, with one thrown every 4,600 lines of code. Kiniry also writes that [...] "As any Java programmer knows, the volume of try catch code in a typical Java application is sometimes larger than the comparable code necessary for explicit <b>formal</b> <b>parameter</b> and return value checking in other languages that do not have checked exceptions. In fact, the general consensus among in-the-trenches Java programmers is that dealing with checked exceptions is nearly as unpleasant a task as writing documentation. Thus, many programmers report that they “resent” checked exceptions. This leads to an abundance of checked-but-ignored exceptions". Kiniry also notes that the developers of C# apparently were influenced by this kind of user experiences, with the following quote being attributed to them (via Eric Gunnerson): [...] According to Anders Hejlsberg there was fairly broad agreement in their design group to not have checked exceptions as a language feature in C#. Hejlsberg explained in an interview that ...|$|E
50|$|The {{disadvantage}} of this fine-grained {{control is a}} complicated syntax, but, because all generic <b>formal</b> <b>parameters</b> are completely defined in the specification, the compiler can instantiate generics without looking at {{the body of the}} generic.|$|R
2500|$|Variadic functions: An {{indefinite}} {{number of}} parameters {{can be passed}} to a function. The function can access them through <b>formal</b> <b>parameters</b> and also through the local [...] object. Variadic functions can also be created by using the [...] method.|$|R
40|$|Empirical data {{concerning}} the qualitative and quantitative nature of program dependence is presented {{for a set of}} 20 programs ranging from 600 lines of code to 167, 000 lines of code. The sources of dependence considered are global variables and <b>formal</b> <b>parameters</b> and the targets considered are a program's predicate nodes. The results show that as the number of <b>formal</b> <b>parameters</b> available to a predicate increases, there is a decrease in the proportion of these <b>formal</b> <b>parameters</b> which are depended upon by the predicate. No such correlation was found for global variables. Results from theoretical and actual computation time analysis indicate that the computation of dependence information is practical, suggesting that the analysis may be beneficial to several application areas. The paper also presents results concerning correlations that provide strong evidence that the global and formal dependence sources are independent of one another and that the numbers of globals and formals are independent {{of the size of the}} procedure that contains them. Finally, two visualization techniques for displaying dependence information are introduced. Illustrations show how these visualizations and predicate dependence analysis can assist in activities such as testing, comprehension, and evolution...|$|R
50|$|The lambda {{abstraction}} operator, λ, takes a <b>formal</b> <b>parameter</b> {{variable and}} a body expression. When evaluated the <b>formal</b> <b>parameter</b> variable is identified with {{the value of the}} actual parameter.|$|E
50|$|The <b>formal</b> <b>parameter</b> {{variable}} {{is said to}} bind the variable name wherever it occurs free in the body. Variable (names) {{that have already been}} matched to <b>formal</b> <b>parameter</b> variable are said to be bound. All other variables in the expression are called free.|$|E
5000|$|... x is the <b>formal</b> <b>parameter</b> (the parameter) of the defined function.|$|E
40|$|Many {{source code}} {{analyses}} {{are closely related}} to and strongly influenced by interdependence among program components. This paper reports results from an empirical study of the interdependences involving program predicates and the <b>formal</b> <b>parameters</b> and global variables which potentially affect them. The finding...|$|R
50|$|A {{method is}} generic if it {{declares}} {{one or more}} type variables. These type variables are known as the <b>formal</b> type <b>parameters</b> of the method. The form of the <b>formal</b> type <b>parameter</b> list is identical to a type parameter list of a class or interface.|$|R
40|$|We {{recall the}} notions of Frölicher and diffeological spaces and we build regular Frölicher Lie groups and Lie algebras of formal pseudo-differential {{operators}} in one independent variable. Combining these constructions with a smooth version of the Mulase factorization of infinite dimensional groups based on formal pseudo-differential operators, we present two proofs of the well-posedness of the Cauchy problem for the Kadomtsev-Petviashvili (KP) hierarchy in a smooth category. We also generalize these results to a KP hierarchy modelled on formal pseudo-differential operators with coefficients which are series in <b>formal</b> <b>parameters,</b> describe a rigorous derivation of the Hamiltonian interpretation of the KP hierarchy, and discuss how solutions depending on <b>formal</b> <b>parameters</b> can lead to sequences of functions converging to a class of solutions of the standard KP-I equation...|$|R
50|$|In {{this example}} the actual {{parameter}} for the <b>formal</b> <b>parameter</b> o is always p. As p {{is a free}} variable in the whole expression, the parameter may be dropped. The actual parameter for the <b>formal</b> <b>parameter</b> y is always n. However n is bound in a lambda abstraction. So this parameter may not be dropped.|$|E
50|$|This is {{slightly}} oversimplified. The Tate curve {{is really a}} curve over a formal power series ring rather than a curve over C. Intuitively, it is a family of curves depending on a <b>formal</b> <b>parameter.</b> When that <b>formal</b> <b>parameter</b> is zero it degenerates to a pinched torus, {{and when it is}} nonzero it is a torus).|$|E
50|$|In C++ and PHP, unary prefix & {{before a}} <b>formal</b> <b>parameter</b> of a {{function}} denotes pass-by-reference.|$|E
30|$|Delamaro et al. [57] {{addressed}} the mutation testing of procedural {{programs at the}} integration level. The authors characterised a set of integration faults related to communication variables (i.e. variables {{that are related to}} the communication between units such as <b>formal</b> <b>parameters,</b> local and global variables and constants).|$|R
5000|$|The {{language}} syntax allows precise {{specification of}} constraints on generic <b>formal</b> <b>parameters.</b> For example, {{it is possible}} to specify that a generic formal type will only accept a modular type as the actual. It is also possible to express constraints between generic formal parameters; for example: ...|$|R
40|$|Parameterized {{programming}} is extended to higher order modules, by extending views, which fit actual <b>parameters</b> to <b>formal</b> <b>parameters</b> in a flexible way, to morphisms, with higher order module expressions to compose modules into systems. A category theoretic semantics is outlined, and examples in BOBJ show {{the power of}} morphisms...|$|R
