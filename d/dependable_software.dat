114|36|Public
40|$|Abstract: The {{construction}} of <b>dependable</b> <b>software</b> systems {{is recognized as}} a complex task: the system developer has to address the usage of fault tolerance techniques {{in addition to the}} design of the functional aspects that are specific to the system. This paper proposes a framework aimed at easing the development of dependable systems by providing software designers with a repository of <b>dependable</b> <b>software</b> architectures. A <b>dependable</b> <b>software</b> architecture shows how to integrate a fault tolerance technique with a given system so as to make the system dependable. Furthermore, the dependability behaviors of architectures are formally specified, which allows to unambiguously interpreting the various fault tolerance techniques as well as to organize the repository of corresponding architectures into a refinement-based lattice structure. ...|$|E
40|$|Ensuring {{dependability}} of {{distributed applications}} {{is a difficult}} problem since developers must carefully consider issues such as network and node failures, deadlocks, livelocks, starvation, distributed coordination, and synchronization. The creation of architectural patterns for <b>dependable</b> <b>software</b> systems can provide effective guidelines, similar to design patterns, to system architects. In this paper, we present an agent specification language, associated tools, and agent-based middleware for specifying, analyzing and implementing architectural patterns for <b>dependable</b> <b>software</b> systems. The language we present {{is an extension of}} the Secure Operations Language (SOL), which supports the behavioral specification of agents in addition to specification of agent interfaces, agent composition, and inter-agent interactions...|$|E
40|$|The seminar {{will cover}} the {{principles}} {{as well as the}} best practices of software system quality assurance (comprising inspection, verification, validation, black and white box test, measurement and assessment, and the normative quality characteristics) for procedural, object-oriented, aspectoriented and agent-based <b>dependable</b> <b>software.</b> Attendees will exercise proven techniques for goal-directed quality specification, testing, measurement, scaling and assessment for software certification. Assessment of both the software product as well as the software process will be discussed with respect to its relevance for such acceptance assessments. A standardized process model for measurement, assessment and certification of <b>dependable</b> <b>software</b> will be used to make the attendees familiar with this comprehensive assessment procedure and to learn how to embed it into today's standardized or non-standardized software processes...|$|E
5000|$|Gilles Motet, A. Marpinard, J.-C. Geffroy, Design of <b>Dependable</b> Ada <b>software,</b> Prentice Hall, 1996 ...|$|R
40|$|TAV-WEB 2008 is {{the third}} {{in a series of}} {{workshops}} that focus on testing, analysis and verification of web software. The goal of these workshops has been to bring together researchers from academic, research, and industrial communities interested in the emerging area of <b>dependable</b> Web <b>software</b> development, to present and discuss their recent research results...|$|R
40|$|Abstract: According to the component-based {{design and}} {{developing}} pattern, {{we present a}} plug-in architecture for the <b>dependable</b> component-based <b>software.</b> After that, the dependable encapsulation is put forwards, which mainly focuses on the component security and availability attributes. Finally, the developing and implementing method of security interceptor, high available load balancing and fault tolerance services have been put emphasis on in this paper...|$|R
40|$|There is a {{critical}} need for approaches to support software testing. Our research exploits the information described at Architectural Patterns to drive the definition of tests. As a result, we intend to assist developers in finding relatively shorter and cheaper paths to high <b>dependable</b> <b>software.</b> Categories and Subject Descriptor...|$|E
40|$|Abstract. Today’s {{software}} {{does not}} come with meaningful guarantees. This position paper explores why this is the case, suggests societal and technical impediments to more <b>dependable</b> <b>software,</b> and considers what realistic, meaningful guarantees for software would be like and how to achieve them. If you want a guarantee, buy a toaster...|$|E
40|$|Abstract. We {{propose a}} set of {{patterns}} for building a <b>dependable</b> <b>software</b> system. The key idea is to localize the system’s most critical requirements into small, reliable parts called trusted bases. We discuss two instances of trusted bases—the end-to-end check and the trusted kernel—and show {{how they can be}} used to achieve dependability. ...|$|E
40|$|Geometric {{computation}} software {{tends to}} be fragile and fails occasionally. This robustness problem {{is rooted in the}} difficulty of making unambiguous decisions about incidence and nonincidence, fundamentally impairing layering the geometry software reliably. Additionally, geometric operations tend to have a large number of special and singular cases, further adding to the difficulty of creating <b>dependable</b> geometric <b>software.</b> We review the problem origins and ways to address it. ...|$|R
40|$|The modern {{information}} society is entirely <b>dependable</b> on <b>software.</b> The majority {{of every day}} solutions that we use, such as mobile devices, home appliances or vehicles, require software to function. In addition, every business relies on various software systems and services. The reason for software usage is its versatility, which allows business to rapidly adapt to continuous changes, and flexibly revise their objectives and approach new opportunities. The adaptation, competitiveness and survival of organizations are <b>dependable</b> on <b>software</b> that they are using [Boehm, 2006]. Software is purely an intellectual product and considered as one of most labor-intensive, complex, error-prone and economically challenging technology in history. Software is often taken for granted and its existence is not acknowledged until it is malfunctioning [Krasner, 1998]. Without successful software projects there are no working software to serve our needs. To pursue successful software project trajectory, the ability to develop high quality solutions in a profitable velocity is essential. Hence, the factors that enable high and sustainable development productivity require adequate management...|$|R
30|$|Garcia et al. ([2001]) {{present a}} {{comparative}} study of exception handling mechanisms for building <b>dependable</b> object-oriented <b>software.</b> The authors define a taxonomy to help address main basic technical aspects for a given exception handling proposal. By means of the proposed taxonomy, the authors survey various exception mechanisms implemented in different object-oriented languages, evaluates and compares different designs. Our classification of software fault tolerance solutions is also based on a general taxonomy of design issues. However, compared to their work, we do not provide a rating of the primary studies according to a quality assessment.|$|R
40|$|At present, great {{demands are}} posed on {{software}} dependability. But how to elicit the dependability requirements {{is still a}} challenging task. This paper proposes a novel approach to address this issue. The essential idea is to model a <b>dependable</b> <b>software</b> system as a feedforward-feedback control system, and presents the use cases + control cases model to express {{the requirements of the}} <b>dependable</b> <b>software</b> systems. In this model, while the use cases are adopted to model the functional requirements, two kinds of control cases (namely the feedforward control cases and the feedback control cases) are designed to model the dependability requirements. The use cases + control cases model provides a unified framework to integrate the modeling of the functional requirements and the dependability requirements at a high abstract level. To guide the elicitation of the dependability requirements, a HAZOP based process is also designed. A case study is conducted to illustrate the feasibility of the proposed approach. © 2013 Science China Press and Springer-Verlag Berlin Heidelberg. At present, great demands are posed on software dependability. But how to elicit the dependability requirements is still a challenging task. This paper proposes a novel approach to address this issue. The essential idea is to model a <b>dependable</b> <b>software</b> system as a feedforward-feedback control system, and presents the use cases + control cases model to express the requirements of the <b>dependable</b> <b>software</b> systems. In this model, while the use cases are adopted to model the functional requirements, two kinds of control cases (namely the feedforward control cases and the feedback control cases) are designed to model the dependability requirements. The use cases + control cases model provides a unified framework to integrate the modeling of the functional requirements and the dependability requirements at a high abstract level. To guide the elicitation of the dependability requirements, a HAZOP based process is also designed. A case study is conducted to illustrate the feasibility of the proposed approach. © 2013 Science China Press and Springer-Verlag Berlin Heidelberg...|$|E
40|$|Abstract. Truly <b>dependable</b> <b>software</b> systems {{should be}} built with {{structuring}} techniques able to decompose the software complexity without hiding important hypotheses and assumptions {{such as those}} regarding their target execution environment and the expected fault- and system models. A judicious assessment {{of what can be}} made transparent and what should be translucent is necessary. This paper discusses a practical example of a structuring technique built with these principles in mind: Reflective and refractive variables. We show that our technique offers an acceptable degree of separation of the design concerns, with limited code intrusion; at the same time, by construction, it separates but does not hide the complexity required for managing fault-tolerance. In particular, our technique offers access to collected system-wide information and the knowledge extracted from that information. This can be used to devise architectures that minimize the hazard of a mismatch between <b>dependable</b> <b>software</b> and the target execution environments. ...|$|E
40|$|Mutation Testing is {{a testing}} {{technique}} {{that focuses on}} measuring the adequacy of test cases. • Mutation Testing is NOT a testing strategy like path or data-flow testing. It does not outline test data selection criteria. • Mutation Testing {{should be used in}} conjunction with traditional testing techniques, not instead of them. <b>Dependable</b> <b>Software</b> Systems (Mutation) Mutation Testing • Faults are introduced into the program by creating many versions of the program called mutants. • Each mutant contains a single fault. • Test cases are applied to the original program and to the mutant program. • The goal is to cause the mutant program to fail, thus demonstrating the effectiveness of the test case. <b>Dependable</b> <b>Software</b> Systems (Mutation) Test Case Adequacy • A test case is adequate if it is useful in detecting faults in a program. • A test case can be shown to be adequate by finding at least one mutant program that generates a different output than does the original program for that test case. • If the original program and all mutant programs generate the same output, the test case is inadequate. <b>Dependable</b> <b>Software</b> Systems (Mutation) Mutant Programs • Mutation testing involves the creation of a set of mutant programs of the program being tested. • Each mutant differs from the original program by one mutation. • A mutation is a single syntactic change that is made to a program statement...|$|E
50|$|He {{leads the}} <b>Dependable</b> Systems & <b>Software</b> Engineering (DSSE) {{group at the}} School of Electronics and Computer Science, University of Southampton. His main {{research}} is {{in the area of}} the B-Method (originated by J.-R. Abrial), especially tool support such as ProB (model checking for B), U2B (UML and B), csp2B (CSP and B), and the RODIN toolset for Event-B.|$|R
40|$|Abstract—Many {{years of}} {{research}} on <b>dependable,</b> faulttolerant <b>software</b> systems yielded a myriad of tool implementations for vulnerability analysis and experimental validation of resilience measures. Trace recording and fault injection are among the core functionalities these tools provide for hardware debuggers or system simulators, partially including some means to automate larger experiment campaigns. We argue that current fault-injection tools are too highly specialized for specific hardware devices or simulators, and are developed in poorly modularized implementations impeding evolution and maintenance. In this article, we present a novel design approach for a fault-injection infrastructure that allows experimenting researchers to switch simulator or hardware backends with little effort, fosters experiment code reuse, and retains {{a high level of}} maintainability. I...|$|R
40|$|AbstractIn {{this work}} we {{introduce}} a new formal model for software components supporting behavioral interpretability based on temporal logic, Petri nets, model checking, and an assume–guarantee strategy to specify and reason about the composition of concurrent component systems. The formal specification and verification strategies, methods, and techniques presented in this work {{contribute to the development}} of more <b>dependable</b> component-based <b>software</b> systems, in a modular way. An approach based on two complementary formalisms, Hierarchical Colored Petri Nets (HCPN) and temporal logic, is introduced. HCPN are used to visualize the structure and model the behavior of software architectures and components, and temporal logic is used to specify the required properties of software architectures and component interfaces...|$|R
40|$|A <b>dependable</b> <b>software</b> system {{contains}} two important components, namely, error detection mechanisms and error recovery mechanisms. An error detection mechanism attempts {{to detect the}} existence of an erroneous software state. If an erroneous state is detected, an error recovery mechanism will attempt to restore a correct state. This is done so that errors are not allowed to propagate throughout a software system, i. e., errors are contained. The design of these software artefacts is known to be very difficult. To detect and correct an erroneous state, the values held by some important variables must be ensured to be suitable. In this paper we develop an approach to capture the importance of variables in <b>dependable</b> <b>software</b> systems. We introduce a novel metric, called importance, which captures the impact a given variable has on the dependability of a software system. The importance metric enables the identification of critical variables whose values must be ensured to be correct...|$|E
40|$|Developing <b>dependable</b> <b>software</b> systems {{requires}} enforcing conformance between {{architecture and}} implementation during software development and evolution. We {{address this problem}} with a multi-pronged approach: (a) automated refinement of a component-and-connector (C&C) architectural view into an initial implementation, (b) enforcement of architectural structure at the programming language level, (c) automated abstraction of a C&C view from an implementation, and (d) semi-automated incremental synchronization between the architectural and the implementation C&C views...|$|E
40|$|The {{advent of}} {{computerized}} consumer products, such as for example automobiles, mobile systems, etc., {{has produced a}} large increase in the need for dependable (or robust) systems. As cost is {{a relevant issue for}} such systems, the cost of dependability has to be kept low. Furthermore, as the replication of software is virtually free compared to the replication of hardware, the trend is to implement more and more functions in software. This motivates the search for methodologies for cost efficient design and assessment of <b>dependable</b> <b>software.</b> An established approach for designing <b>dependable</b> <b>software</b> entails addition of error detection mechanisms (EDM’s) and error recovery mechanisms (ERM’s). The effectiveness of these mechanisms, however, is achieved only if their composition is matched with their placement in locations where they are actually effective. It is the development of a systematic methodology to profile software in order to compose and locate EDM’s and ERM’s, that this thesis endeavors to achieve. Presented in this thesis is a set of approaches for profiling software such that th...|$|E
40|$|Abstract. This {{technical}} report considers {{the problem of}} developing <b>dependable</b> component-based <b>software</b> systems through an architectural approach, which combines fault prevention, fault removal, and fault tolerance techniques. The architecture-centred solution comprises a rigorous approach, which systematises the verification and validation of fault tolerant systems. Using B-Method and CSP, we analyse the exception flow at the architectural level and verify important properties regarding the system dependability. Besides that, the it is adopted an architectural solution based on exception handling for transforming untrusted software components into idealised fault-tolerant architectural components, {{which can be used}} as building blocks for creating fault-tolerant software architectures. The feasibility of the proposed architectural solution was evaluated on a business critical case study...|$|R
40|$|The {{software}} industry has adopted component-based software development (CBSD) to rapidly build and deploy large and complex software systems with significant savings at minimal engineering effort, cost, and time. However, CBSD encounters issues on security trust, mainly {{with respect to}} dependability attributes. A system is considered dependable when it can produce the outputs {{for which it was}} designed with no adverse effect on its intended environment. Dependability consists of several attributes that imply availability, confidentiality, integrity, reliability, safety, and maintainability. Dependability attributes must be embedded in a CBSD model to develop <b>dependable</b> component <b>software.</b> Motivated by the importance of these attributes, this paper pursues two objectives: to design a model for developing a dependable system that mitigates the vulnerabilities of software components, and to evaluate the proposed model. The model proposed in this study is labelled as developing <b>dependable</b> component-based <b>software</b> (2 DCBS). To develop this model, the CBSD architectural phases and processes must be framed and the six dependability attributes embedded according to the best practice method. The expert opinion approach was applied to evaluate 2 DCBS framing. In addition, the 2 DCBS model was applied to the development of an information communication technology (ICT) portal through an empirical study method. Vulnerability assessment tools (VATs) were employed to verify the dependability attributes of the developed ICT portal. Results show that the 2 DCBS model can be adopted to develop web application systems and to mitigate the vulnerabilities of the developed systems. This study contributes to CBSD and facilitates the specification and evaluation of dependability attributes throughout model development. Furthermore, the reliability of the dependable model can increase confidence in the use of CBSD for industries...|$|R
40|$|Abstract—Many {{years of}} {{research}} on <b>dependable,</b> faulttolerant <b>software</b> systems yielded many tool implementations for vulnerability analysis and experimental validation of resilience measures. We identify two disjoint classes of fault-injection (FI) experiment tools in the field, and argue that both are plagued by inherent deficiencies, such as insufficient target state access, little or no means to switch to another target system, and non-reusable experiment code. In this article, we present a novel design approach for a FI infrastructure that aims at combining the strengths of both classes. Our FAIL * experiment framework provides carefullychosen abstractions simplifying both the implementation of different simulator/hardware target backends and the reuse of experiment code, while retaining the ability for deep targetstate access for specialized FI experiments. An exemplary repor...|$|R
40|$|On March 18 and 19, 1993, the Dependable Real-Time Software Project {{hosted a}} <b>Dependable</b> <b>Software</b> Technology Exchange. The exchange, {{sponsored}} by the Air Force Space and Missile Systems Center and the Office of Naval Research, brought together researchers and system developers, providing {{an opportunity for the}} researchers to learn the needs of the developers and for the developers to learn about techniques being investigated by the researchers. This report summarizes what transpired at the meeting...|$|E
40|$|Developing a <b>dependable</b> <b>software</b> is a {{challenging}} problem. Dependability requirements are {{emphasized in the}} world of embedded systems that may be safety critical. This report summarizes state of the art of technique s suitable for dependable embedded software development: static type analysis, testing, simulation, formal methods. Software engineering techniques such as aspect oriented programming and generative programming are also discussed. Finally we propose a technique based on high level dynamic languages and code generation...|$|E
40|$|Abstract Dependable {{architectures}} demonstrably possessproperties such as safety, {{security and}} fault tolerance. We {{are interested in}} developing methodsallowing formal demonstrations through proof that an architecture does indeed possess the de-sired dependability properties. We focus on architecture hierarchies {{as a means of}} enablingsuch demonstrations. Integrated avionics offer unprecedented generality and on-board comput-ing utilization which are adaptability enabling technologies. We pose integrated avionics as achallenge problem for <b>dependable</b> <b>software</b> architectures and we propose a research agendafor solving it...|$|E
40|$|Computing {{systems in}} which the {{consequences}} of failure are very serious are termed safety-critical. Many such systems exist in application areas such as aerospace, defense, transportation, power-generation, and medicine. The software in these systems is typically large and complex, critical to system safety, and difficult to implement and verify. Even when great effort is expended to develop the software, there is no assurance that the software will operate with the required level of dependability. We have investigated a safety kernel architecture that addresses {{part of the problem}} of building and verifying <b>dependable</b> safety-critical <b>software.</b> An analogous construct, the security kernel, has been used successfully to enforce security policies in classified-information systems. Similar requirements known as safety policies must be enforced in safetycritical systems. Other researchers have developed some basic safety kernel concepts and have proposed safety kernel designs. However, man [...] ...|$|R
40|$|In this paper, {{we present}} an {{integrated}} system concept {{for the living}} assistance domain based on ambient intelligence technology and discuss the resulting challenges for the software engineering discipline. Automated living assistance systems represent a promising approach for the prolongation of an independent and self-conducted life of handicapped and elderly people thereby, enhancing {{their quality of life}} and minimizing the need for manual social/medical care. It is demonstrated that living assistance systems must realize flexibility and adaptability at the algorithmic, architectural and human interface level to an extent unknown in present systems. The construction of robust, trustworthy living assistance systems is an extremely challenging task and requires novel approaches for <b>dependable</b> self-adapting <b>software</b> architectures, resource efficiency, and self-adapting multi-modal human-computer interfaces. The resulting consequences and challenges for the discipline of software engineering are outlined in this paper...|$|R
40|$|Software {{testing is}} a {{critical}} and important stage of the application software development life-cycle. Testing is a verification activity that affects the overall software quality. The verification of critical and <b>dependable</b> computer <b>software</b> such as real-time safety-critical software systems consumes about 50 % of the project time. In this work, we consider testing compilers. Since a compiler is a highly usable software, an increased emphasis on reliability requires a careful testing before releasing the compiler. In compiler testing, the compiler implementation is verified {{to conform to the}} specified language syntax and semantic available in the standard language documentation. In this work, an algorithm is designed and a tool is developed to automate the generation of test cases to check the language syntax. In addition, we propose a heuristic approach to cover language semantics. Since Java is a relatively new programming language, we concentrate on testing th...|$|R
40|$|A program slice is {{a subset}} of a program. • Program slicing enables programmers to view subsets of a program by {{filtering}} out code that is not relevant to the computation of interest. • E. g., if a program computes many things, including the average {{of a set of}} numbers, slicing can be used to isolate the code that computes the average. <b>Dependable</b> <b>Software</b> Systems (Slicing) Why is Program Slicing Useful? • Program slices are more manageable for testing and debugging. • When testing, debugging, or understanding a program, most of the code in the program is irrelevant to what you are interested in. • Program slicing provides a convenient way of filtering out “irrelevant ” code. • Program slices can be computed automatically by statically analyzing the data and control flow of the program. <b>Dependable</b> <b>Software</b> Systems (Slicing) Definition of Program Slice • Assume that: – P is a program. – V is the set of variables at a program location (line number) n. • A slice S(V,n) produces the portions of the program that contribute to the value of V just before the statement at location n is executed. • S(V,n) is called the slicing criteria...|$|E
40|$|Dependable {{architectures}} demonstrably possess properties such as safety, {{security and}} fault tolerance. We {{are interested in}} developing methods allowing formal demonstrations through proof that an architecture does indeed possess the desired dependability properties. We focus on architecture hierarchies {{as a means of}} enabling such demonstrations. Integrated avionics o er unprecedented generality and on-board computing utilization which are adaptability enabling technologies. We pose integrated avionics as a challenge problem for <b>dependable</b> <b>software</b> architectures and we propose a research agenda for solving it. 1 What are <b>dependable</b> <b>software</b> architectures? Software architectures describing software products that are used to implement critical functions need to be trustworthy. Dependability is the property of a computing system which allows reliance to be justi ably placed on the service it delivers. The service delivered by a system is its behavior as it is perceived by its users. Dependability has qualitative and quantitative attributes and is an overall judgement about a system. The software architecture community has made great strides towards characterizing and capturing system descriptions appropriately and towards providing linguistic support for de ning families of software products, but current ADLs and their associated methodologies do not adequately address dependability...|$|E
40|$|Abstract. Up to now Service Oriented Architectures and Event Driven Architectures {{have been}} {{considered}} as competing parties striving to conquer the crown of the standard paradigm {{for the implementation of}} complex distributed applications. Todays we are witnesses of large efforts to merge both paradigms and give birth to a new generation of middleware platforms that will inherit the best of both worlds. In this paper we describe how this marriage could be leveraged in order to design new <b>dependable</b> <b>software</b> systems...|$|E
40|$|A general {{trend towards}} more complex {{technical}} {{systems can be}} observed which results in an increasing demand for methods and tools to develop <b>dependable,</b> high quality <b>software</b> for embedded systems. The UML in principle provides the essential concepts which are required to model such complex, safety-critical software systems. In this paper, we describe a component template plugin for the Fujaba Real-Time Tool Suite which has been especially tailored to support faulttolerance templates such as triple modular redundancy. We report about the underlying concepts {{and the application of}} the plugin by means of an example. 1...|$|R
40|$|International audienceSoftware {{systems are}} {{increasingly}} becoming distributed, open and ubiquitous assets. While open system components are often autonomous, they behave unpredictably when unforeseen situations arise. Taming this uncertainty {{is a key}} issue for <b>dependable</b> open <b>software</b> development. This work proposes law enforcement approach that uses fault tolerant strategies to develop dependable open systems. Despite all the research {{done in the last}} years on the development of fault-tolerant applications and of approaches to enforce secure interaction protocols in multi-agent systems, there is no mechanism which uses the law elements of interaction’s control which improves the agent criticality analysis. As we will see, this mechanism would increase dependability of those systems. Thus it is proposed a solution to achieve it through the integration of the DimaX framework, which is a framework for dynamic replication, and the XMLaw, which is composed by a declarative language for specifying the norms of the systems and a framework for implementing the law enforcement approach for regulating agents’ interaction...|$|R
40|$|International audienceDependable {{systems are}} {{characterized}} {{by a number of}} attributes including: reliability, availability, safety and security. For some attributes (namely for reliability, availability, safety), there exist probability- based theoretic foundations, enabling the application of dependability analysis techniques. The goal of dependability analysis is to forecast the values of dependability attributes, based on certain properties (e. g. failure rate, MTBF, etc.) that characterize the system's constituent elements. Nowadays, architects, designers and developers build systems based on an architecture-driven approach. They specify the system's software architecture using Architecture Description Languages or other standard modeling notations like UML. Given the previous, we examine what we need to specify at the architectural level to enable the automated generation of models for dependability analysis. In this paper, we further present a prototype implementation of the proposed approach, which relies on UML specifications of <b>dependable</b> systems' <b>software</b> architectures. Moreover, we exemplify our approach using a case study system...|$|R
