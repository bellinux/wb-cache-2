15|700|Public
30|$|There {{is a need}} to {{organize}} for (real-time) continuous software <b>evolution</b> (<b>architecture,</b> organization).|$|E
40|$|A decade ago, seminal {{perspectives}} and papers set a strong {{vision for the}} field of systems biology, {{and a number of}} these themes have flourished. Here, we describe key technologies and insights that have elucidated the <b>evolution,</b> <b>architecture,</b> and function of cellular networks, ultimately leading to the first predictive genome-scale regulatory and metabolic models of organisms. Can systems approaches bridge the gap between correlative analysis and mechanistic insights...|$|E
40|$|Abstract: An {{easy and}} {{efficient}} evolution method from a time-division multiplexing passive optical networks (TDM-PONs) to next-generation PONs is proposed and demonstrated. A single-type wavelength band combiner/splitter (WC) enables {{a simple and}} efficient evolution of TDM-PON maintaining the current PON infrastructure and wavelength plan. The feasibility of the proposed <b>evolution</b> <b>architecture</b> is shown by investigating the crosstalk effect between the legacy PON and a wavelength division multiplexing (WDM) -PON based on wavelength-locked Fabry-Perot laser diode (F-P LD) as a next-generation PON. Then, the crosstalk is negligibly small. I...|$|E
5000|$|<b>Evolution</b> and <b>Architecture</b> {{between science}} and design, Prospettive, Roma 2008.|$|R
40|$|As {{software}} <b>architecture</b> <b>evolution</b> {{has become}} an integral part of the automated software engineering lifecycle, reuse, modularization and composition of evolution rules becomes more important. This paper aims to generalize the <b>architecture</b> <b>evolution</b> model by defining evolution rules and propagation strategies on graph s describing software architectures. We aim to define a user-definable means to manage software <b>architecture</b> <b>evolution</b> model...|$|R
40|$|Enterprise {{architectures}} {{are exposed}} to fast emerging business and information technology capabilities. A prominent example is the paradigm of service-orientation, which leads to its own architectural requirements and impacts the design and ongoing <b>evolution</b> of Enterprise <b>Architectures.</b> This thesis develops the first theoretical model describing enterprise <b>architecture</b> <b>evolution</b> and outcomes in light of a changing IT landscape such as service-oriented architectures. The developed theoretical model explains enterprise <b>architecture</b> <b>evolution,</b> its main stages and related capabilities. This model {{can be used to}} derive theoretical, sound guidelines to manage enterprise architectures in a changing environment...|$|R
40|$|AbstractThe LTE/SAE (Long Term Evolution/System Architecture <b>Evolution)</b> <b>architecture</b> {{design is}} greatly {{different}} from the existing network (3 G) which brings with it a need to adapt and improve the security functions. In fact, the security issues in telecommunications networks will be surely a big discussion subject {{in the next few}} years whither the delay remains very important and should be minimized. Thus, the Handover Keying Working Group (HOKEY) tries to reduce the delay caused by the authentication once the mobile user changes its location. Therefore, the focus of this paper is to make a brief discussion of the IETF HOKEY solution to fast authenticate the subscribers during the handover in the LTE/SAE network...|$|E
40|$|Abstract. Nowadays, one of {{the most}} {{important}} problems of software engineering continues to be the maintenance of both databases and ap-plications. It is clear that any method that can reduce the impact that database modifications produce on application programs is valuable for software engineering processes. We have proposed such a method, by means of a database <b>evolution</b> <b>architecture</b> (MeDEA) that makes use of database views. By using views, changes in the structure of the database schema can be delayed until absolutely necessary. However, some condi-tions oblige modifications to be made. In the present paper we present an approach to detect when the restructuring process must be realized and how to carry out this restructuring process. ...|$|E
40|$|XML is arising {{as a new}} {{format to}} {{represent}} the enterprises ' business processes, since it is a exible and interchangeable language. In the work ow area, {{one of the most}} discussed questions is the evolution of the work ow representations, in order to meet new requirements. Despite the number of existing proposals, none of them deals with evolution of work ows that use the XML syntax. In this paper, we present a proposal for work ow evolution in which the work ow schema is represented in XML. The proposal is based on versioning concepts, that allow the storage and use of di erent versions of the same work ow schema. An <b>evolution</b> <b>architecture</b> is proposed, in order to separate the involved concepts in a set of managers. Two of these managers are discussed in depth in this paper { Version Manager and Modi cation Manager. The Version Manager handles (schema) versions and the Modi cation Manager controls the changes that can be applied over them. ...|$|E
40|$|Software systems {{continuously}} evolve as {{a consequence}} of frequent changes in their functional requirements and the environment surrounding them. Architecture-centric software evolution (ACSE) enables changes in software structure and behaviour while abstracting the complex implementation-specific details. However, due to recurring evolution {{there is a need for}} solutions that enable a systematic reuse of frequent changes in software architectures. In recent years, architecture change patterns and evolution styles proved successful in promoting reuse expertise to tackle <b>architecture</b> <b>evolution.</b> However, there do not exist any solutions that enable a continuous acquisition and application of <b>architecture</b> <b>evolution</b> knowledge to systematically address frequent changes in software architectures. In this paper, we propose a framework PatEvol that aims to unify the concepts of i) software repository mining and ii) software evolution to enable acquisition and application of <b>architecture</b> <b>evolution</b> knowledge. In the proposed PatEvol framework, we present knowledge acquisition (<b>architecture</b> <b>evolution</b> mining) to enable post-mortem analysis of evolution histories to empirically discover evolution-centric knowledge. Furthermore, we support reuse of discovered knowledge to enable knowledge application (<b>architecture</b> <b>evolution</b> execution) that enables evolution-off-the-shelf in software architectures. Tool support facilitates the knowledge acquisition and knowledge application processes in the PatEvol framework. Software systems continuously evolve {{as a consequence}} of frequent changes in their functional requirements and the environment surrounding them. Architecture-centric software evolution (ACSE) enables changes in software structure and behaviour while abstracting the complex implementation-specific details. However, due to recurring evolution there is a need for solutions that enable a systematic reuse of frequent changes in software architectures. In recent years, architecture change patterns and evolution styles proved successful in promoting reuse expertise to tackle <b>architecture</b> <b>evolution.</b> However, there do not exist any solutions that enable a continuous acquisition and application of <b>architecture</b> <b>evolution</b> knowledge to systematically address frequent changes in software architectures. In this paper, we propose a framework PatEvol that aims to unify the concepts of i) software repository mining and ii) software evolution to enable acquisition and application of <b>architecture</b> <b>evolution</b> knowledge. In the proposed PatEvol framework, we present knowledge acquisition (<b>architecture</b> <b>evolution</b> mining) to enable post-mortem analysis of evolution histories to empirically discover evolution-centric knowledge. Furthermore, we support reuse of discovered knowledge to enable knowledge application (<b>architecture</b> <b>evolution</b> execution) that enables evolution-off-the-shelf in software architectures. Tool support facilitates the knowledge acquisition and knowledge application processes in the PatEvol framework...|$|R
5000|$|Various {{approaches}} {{have been proposed}} to address erosion. [...] "These approaches, which include tools, techniques and processes, are primarily classified into three generic categories that attempt to minimise, prevent and repair architecture erosion. Within these broad categories, each approach is further broken down reflecting the high-level strategies adopted to tackle erosion. These are: process-oriented <b>architecture</b> conformance, <b>architecture</b> <b>evolution</b> management, <b>architecture</b> design enforcement, architecture to implementation linkage, self-adaptation and architecture restoration techniques consisting of recovery, discovery and reconciliation." ...|$|R
50|$|<b>Architecture</b> <b>Evolution</b> is {{the process}} of {{maintaining}} and adapting an existing software architecture to meet requirement and environmental changes. As software architecture provides a fundamental structure of a software system, its evolution and maintenance would necessarily impact its fundamental structure. As such, <b>architecture</b> <b>evolution</b> is concerned with adding new functionality as well as maintaining existing functionality and system behaviour.|$|R
40|$|I {{assert that}} it is {{feasible}} to design and implement programming-level support layers that can assist a group of software engineers in changing the behaviour of a large, long-lived, distributed application system at run-time. It is argued that support {{for the evolution of}} large systems needs to be considered from the very start of their design and that the support layer should be targeted to the system that will be evolved. It is further argued that an evolution model and its realisation in an <b>evolution</b> <b>architecture</b> are required to support the software engineer in their design and implementation of an evolvable system. In addition, such a model and architecture are required because the software hierarchy fails to support the software engineer at an important level of programming abstraction. This claim is demonstrated through the design and implementation of two run-time support layers which address the task identified above. The degree of success in providing such run-time support layers will be demonstrated through argument, by criticising and contrasting both systems. 2 Some modern distributed applications need to have their behaviour changed in order to perform correctiv...|$|E
40|$|Software systems endure many {{noteworthy}} changes {{throughout their}} life-cycle {{in order to}} follow {{the evolution of the}} problem domains. Generally, the software system architecture cannot follow the rapid evolution of a problem domain which results in the discrepancies between the implemented and designed architecture. Software architecture illustrates a system's structure and global properties and consequently determines not only how the system should be constructed but also leads its <b>evolution.</b> <b>Architecture</b> plays an important role to ensure that a system satisfies its business and mission goals during implementation and evolution. However, the capabilities of the designed architecture may possibly be lost when the implementation does not conform to the designed architecture. Such a loss of consistency causes the risk of architectural decay. The architectural decay can be avoided if architectural changes are made as early as possible. The paper presents the Process Model for Architecture-Centric Evolution which improves the quality of software systems through maintaining consistency between designed architecture and implementation. It also increases architecture awareness of developers which assists in minimizing the risk of architectural decay. In the proposed approach consistency checks are performed before and after the change implementation. Comment: 12 Pages 8 Figures Journal Paper; International Journal of Computer Science, Engineering and Applications (IJCSEA) Vol. 1, No. 5, October 201...|$|E
40|$|Windowing Toolkit (AWT) [...] . 30 Java Database Connectivity (JDBC) [...] 30 JavaMail [...] 31 Java Management Extensions (JMX) [...] . 31 5 Java and Architecture-Based Software Development [...] . 32 Concepts of Software Architectures [...] 32 Support for Architecture in JavaBeans and Related Technologies 33 6 Summary and Conclusions [...] 35 GLOSSARY Architecture-based {{software}} development: An {{approach to}} software development where {{the architecture of}} the software system forms the blueprint for its development and <b>evolution</b> <b>Architecture</b> style: A set of rules that describe or constrain the organization of components and connectors {{and the manner in which}} components interact Asynchronous: A mode of interaction where the initiator continues with its processing while the target of interaction is processing the interaction request Container: A software program or runtime environment that provides necessary infrastructure facilities and services such as communication, multi-threading, security and transactional isolation to other software systems Deployment: The process whereby software is installed into an operational environment Design-time: The state and behavior of a software component while it is being composed in a system Enterprise application: An application that comprises an enterprise's systems for handling company-wide infor- mation Event: An occurrence of an incident of interest to a software system Listener: A software component that receives and processes events Middleware: Middleware is software used to provide standard interface to low-level operating system and network services, and a runti [...] ...|$|E
30|$|Finally, in {{the last}} phase of <b>architecture</b> <b>evolution,</b> the fixed-mobile {{convergence}} will happen.|$|R
50|$|System <b>Architecture</b> <b>Evolution</b> (SAE) is {{the core}} network {{architecture}} of 3GPP's LTE wireless communication standard.|$|R
40|$|Abstract—Service-based {{architectures}} {{have now}} become commonplace, creating the need to address their system-atic maintenance and evolution. We propose to enable transformation-driven <b>evolution</b> for service <b>architectures</b> in a semi-automated fashion. In contrast to the existing solutions like service wrapping, migration or run-time adaptation etc., the proposal supports primitive and customisable architectural transformations to support an incremental <b>evolution</b> for service <b>architectures.</b> An empirical approach is adopted to investigate {{the extent to which}} the <b>architecture</b> <b>evolution</b> tasks (i. e. mod-eling, transformation and refinement) can be automated and validated in context to the central hypothesis for architecture-centric software evolution. Based on the initial results, we plan to proceed toward modeling and automating the architectural evolution in a formal way...|$|R
40|$|Smart Grids are {{becoming}} a reality all over the world. Nowadays, the research efforts for the introduction and deployment of these grids are mainly focused {{on the development of}} the field of Smart Metering. This emerging application requires the use of technologies to access the significant number of points of supply (PoS) existing in the grid, covering the Low Voltage (LV) segment with the lowest possible costs. Power Line Communications (PLC) have been extensively used in electricity grids for a variety of purposes and, of late, have been the focus of renewed interest. PLC are really well suited for quick and inexpensive pervasive deployments. However, no LV grid is the same in any electricity company (utility), and the particularities of each grid <b>evolution,</b> <b>architecture,</b> circumstances and materials, makes it a challenge to deploy Smart Metering networks with PLC technologies, with the Smart Grid as an ultimate goal. This paper covers the evolution of Smart Metering networks, together with the evolution of PLC technologies until both worlds have converged to project PLC-enabled Smart Metering networks towards Smart Grid. This paper develops guidelines over a set of strategic aspects of PLC Smart Metering network deployment based on the knowledge gathered on real field; and introduces the future challenges of these networks in their evolution towards the Smart Grid...|$|E
40|$|Capturing {{architectural}} {{knowledge is}} very important for the evolution of software products. There is increasing awareness that an essential part of this knowledge is in fact the very process of architectural reasoning and decision making, and not just its end results. Therefore, a conceptual framework is needed that provides support for the process of architectural reasoning and making decisions. In this paper we introduce diagrams that advance existing achievements, address observed problems, and capture known insights in order to facilitate the process of architectural reasoning and its documentation, and in that way provide support for processes such as e. g. product <b>evolution,</b> <b>architecture</b> evaluation, and change impact analysis. An approach to architectural knowledge management is proposed in which a software architecture is modeled by a set of architectural reasoning diagrams, where each diagram is composed of several layers and addresses certain aspects of the system. These diagrams supplement existing ways to capture architecture descriptions, they share a set of common elements, and capture design decisions, their motivations and dependencies. A metamodel is given that defines those common elements and also defines the dependencies that exist between these elements both within and between layers. The proposed concepts and diagrams are illustrated on a software architecture for a component-based framework that needs to satisfy a given set of requirements and to address concerns of particular stakeholders...|$|E
40|$|A decade ago, seminal {{perspectives}} and papers set a strong {{vision for the}} field of systems biology, {{and a number of}} these themes have flourished. Here, we describe key technologies and insights that have elucidated the <b>evolution,</b> <b>architecture,</b> and function of cellular networks, ultimately leading to the first predictive genome-scale regulatory and metabolic models of organisms. Can systems approaches bridge the gap between correlative analysis and mechanistic insights? System biology aims to understand how individual elements of the cell interact to generate behaviors that allow survival in changeable environments and collective cellular organization into structured communities. Ultimately, these cellular networks assemble into larger population networks to form large-scale ecologies and thinking machines, such as humans. Given this central focus on codifying the organizational principles and algorithms of life, we argue that systems biology is not a newly emerging field, but rather a mature synthesis of thought about the implications of biological structure and its dynamic organization, ideas that have been brewing for more than a century. To many scientists, the beginning of the last decade marked the definition and rise of the field of systems biology. However, systems biology’s conceptual origins date back almost 100 years. In 1917, D’Arcy Thompson formalized the first link between development, evolution, and physics in his treatise On Growth and Form, when he observed that shapes and function of biological systems were fundamentally determined by physical requirements and mechanical laws. I...|$|E
40|$|This paper {{depicts the}} <b>evolution</b> of {{enterprise}} <b>architectures</b> to their today often used service-oriented form and presents a state-of-the-art development process {{for this kind}} of architecture. The development process covers both the development of business architecture as well as the appropriate software architecture. While showing up a possible form of further <b>evolution</b> of enterprise <b>architectures,</b> we identify the major challenges for future development methods of enterprise architectures. 1...|$|R
5000|$|On September 14, 2007, {{the aging}} mainframe-based Ground Segment Control System was {{transferred}} to the new <b>Architecture</b> <b>Evolution</b> Plan.|$|R
50|$|Myendetta (1910) is {{important}} in illustrating the contribution of notable architect, Robert Smith (Robin) Dods, to the <b>evolution</b> of Queensland <b>architecture.</b>|$|R
40|$|Causal {{reasoning}} is a ubiquitous feature of human cognition. We continuously seek to understand, at least implicitly and often explicitly, the causal scenarios {{in which we}} live, {{so that we may}} anticipate what will come next, plan a potential response and envision its outcome, decide among possible courses of action in light of their probable outcomes, make midstream adjustments in our goal-related activities as our situation changes, and so on. A considerable body of research shows that the lateral PFC is crucial for causal reasoning, but also that there are significant differences {{in the manner in which}} ventrolateral PFC, dorsolateral PFC, and anterolateral PFC support causal reasoning. We propose, on the basis of research on the <b>evolution,</b> <b>architecture,</b> and functional organization of the lateral PFC, a general framework for understanding its roles in the many and varied sorts of causal reasoning carried out by human beings. Specifically, the ventrolateral PFC supports the generation of basic causal explanations and inferences; dorsolateral PFC supports the evaluation of these scenarios in light of some given normative standard (e. g., of plausibility or correctness in light of real or imagined causal interventions); and anterolateral PFC supports explanation and inference at an even higher level of complexity, coordinating the processes of generation and evaluation with further cognitive processes, and especially with computations of hedonic value and emotional implications of possible behavioral scenarios – considerations that are often critical both for understanding situations causally and for deciding about our own courses of action...|$|E
40|$|There {{have been}} {{suggestions}} that heat caused by cerebral metabolic activity may constrain mammalian brain <b>evolution,</b> <b>architecture,</b> and function [1 - 4]. This study [5] investigates physical limits on brain wiring and corresponding changes in brain temperature that are imposed by thermodynamics of heat balance determined mainly by Na/KATPase, cerebral blood flow, and heat conduction. It is {{found that even}} moderate firing rates cause significant intracellular Na build-up, and the ATP consumption rate associated with pumping out these ions grows nonlinearly with frequency. Surprisingly, the power dissipated by the Na/K pump depends biphasically on frequency, {{which can lead to}} the biphasic dependence of brain temperature on frequency as well. Both the total power of sodium pumps and brain temperature diverge for very small fiber diameters, indicating that too thin fibers are not beneficial for thermal balance. For very small brains blood flow is not a sufficient cooling mechanism deep in the brain. The theoretical lower bound on fiber diameter above which brain temperature is in the operational regime is strongly frequency dependent but finite due to synaptic depression. For normal neurophysiological conditions this bound is at least an order of magnitude smaller than average values of empirical fiber diameters, suggesting that mammalian brains operate in the thermodynamically safe regime. Analytical formulas presented can be used to estimate average firing rates in mammals, and relate their changes to changes in brain temperature, which can have important practical applications. In general, activity in larger brains is found to be slower than in smaller brains...|$|E
40|$|The {{development}} of new GNSS constellations, and the modernization of existing ones, has increased the availability {{and the number of}} satellites-in-view, paving the way for new navigation algorithms and techniques. These offer the opportunity to improve the navigation performance {{while at the same time}} potentially reducing the support which has to be provided by Ground and Satellite Based Augmented Systems (GBAS and SBAS). These enhanced future capabilities can enable GNSS receivers to serve as a primary means of navigation, worldwide, and have provided the motivation for the Federal Aviation Administration (FAA) to form the GNSS <b>Evolution</b> <b>Architecture</b> Study (GEAS). This panel, formed in 2008, investigates the new GNSS-based architectures, with a focus on precision approach down to LPV- 200 operations. GEAS identified ARAIM as the most promising system. The literature, produced through a series of studies, has analysed the performance of this new technique and has clearly shown that the potential of ARAIM architectures to provide the Required Navigation Performance for LPV 200. Almost all of the analysis was performed by simply studying a constellation’s configuration with respect to fixed points on a grid on the Earth’s surface, with full view of the sky, evaluating ARAIM performance from a geometrical point of view and using nominal performance in simulated scenarios lasting several days In this paper, we will evaluate the ARAIM performance in simulated operational configurations. Aircraft flights can last for hours and on-board receivers don’t always have a full view of the sky. Attitude changes from manoeuvers, obscuration by the aircraft body and shadowing from the surrounding environment could all affect the incoming signal from the GNSS constellations, leading to configurations that could adversely affect the real performance. For this reason, the main objective of the algorithm developed in this research project is to analyse these shadowing effects and compute the performance of the ARAIM technique when integrated with a predicted flight path using different combinations of three constellations (GPS, GLONASS and Galileo), considered as fully operational...|$|E
5000|$|... eNB {{interfaces}} {{with the}} System <b>Architecture</b> <b>Evolution</b> (SAE) core (also known as Evolved Packet Core (EPC)) and other eNB as follows: ...|$|R
40|$|As {{new market}} opportunities, technologies, platforms, and {{frameworks}} become available, systems require large-scale and systematic architectural restructuring to accommodate them. Today’s architects have few techniques {{to help them}} plan this <b>architecture</b> <b>evolution.</b> In particular, they have little assistance in planning alternative evolution paths, trading off {{various aspects of the}} different paths, or knowing best practices for particular domains. In this paper, we describe an approach for planning and reasoning about <b>architecture</b> <b>evolution.</b> Our approach focuses on providing architects with the means to model prospective evolution paths and supporting analysis to select among these candidate paths. To demonstrate the usefulness of our approach, we show how it can be applied to an actual <b>architecture</b> <b>evolution.</b> In addition, we present some theoretical results about our evolution path constraint specification language...|$|R
40|$|This paper {{presents}} a graph transformation approach to software <b>architecture</b> <b>evolution.</b> Evolution is inevitable {{over the course}} of the complete life of complex software intensive systems and more importantly of entire product families. However, not only instance models, but also type models and entire modelling languages are subject to change. Obviously software architecture is the centerpiece of software systems and acts as reference point for many development activities, and few of today's software systems are built to accommodate evolution. Evolution is primarily reflected in and facilitated through the software architecture. In this paper we focus on the different dimensions of <b>architecture</b> <b>evolution</b> with an automated evolution process of software architecture using graph transformation. The rules for the potential <b>architecture</b> <b>evolutions</b> operators are defined using AToM 3 graph transformation tool...|$|R
40|$|Although {{there exist}} methods and tools to support <b>architecture</b> <b>evolution,</b> the {{derivation}} {{and evaluation of}} alternative evolution paths are realized manually. In this paper, we introduce an approach, where architecture specification is converted to a graph representation. Based on this representation, we automatically generate possible evolution paths, evaluate quality attributes for different architectural configurations, and optimize {{the selection of a}} particular path accordingly. We illustrate our approach by modeling the software <b>architecture</b> <b>evolution</b> of a crisis management system...|$|R
50|$|Although UMTS, with HSDPA and HSUPA {{and their}} evolution, deliver high data {{transfer}} rates, wireless data usage {{is expected to}} continue increasing significantly {{over the next few years}} due to the increased offering and demand of services and content on-the-move and the continued reduction of costs for the final user. This increase is expected to require not only faster networks and radio interfaces but also higher cost-efficiency than what is possible by the evolution of the current standards. Thus the 3GPP consortium set the requirements for a new radio interface (EUTRAN) and core network <b>evolution</b> (System <b>Architecture</b> <b>Evolution</b> SAE) that would fulfill this need.|$|R
40|$|Abstract As {{new market}} opportunities, technologies, plat-forms, and {{frameworks}} become available, systems require large-scale and systematic architectural restructuring to ac-commodate them. Today’s architects have few tools and techniques {{to help them}} plan this <b>architecture</b> <b>evolution.</b> In particular, they have little assistance in planning alternative evolution paths, trading off {{various aspects of the}} different paths, or knowing best practices for particular domains. In this paper we describe an approach for planning and rea-soning about <b>architecture</b> <b>evolution.</b> Our approach focuses on providing architects with the means to model prospec-tive evolution paths and supporting analysis to select among these candidate paths. To demonstrate the usefulness of our approach in practice, we show how it can be applied to an actual <b>architecture</b> <b>evolution.</b> In addition, we present some theoretical results about the expressiveness and tractability of our evolution path specification language. ...|$|R
40|$|Abstract. Everything {{changes in}} our {{everyday}} lives: New discoveries, paradigms, styles, and technologies. Frequently, software systems success depends on how they can quickly adapt to requirement or environment <b>evolution.</b> Software <b>architectures</b> are abstract models at the highest level. As such, they should assume conceptual guidance on what parts of the system changed. However, many software architectures often evolve from an uncoordinated build-and-fix attitude. The result is opaque and not analyzable. We present in this paper a practical experience of using aspect oriented programming principles for managing software <b>architecture</b> specification <b>evolution.</b> Our approach aims at clarifying software <b>architecture</b> <b>evolution</b> steps. It extends software architecture abstract models for the specification and the analysis of new concern integration. ...|$|R
25|$|Also {{influencing}} the New Indies Style were {{new generation of}} Dutch architects, trained in the Netherlands, {{and went to the}} Indies to introduce Modernism. In the 1910s, Dutch architects began experimenting with new material on traditional Dutch forms while developing a tropical-friendly <b>architecture,</b> bridging the <b>evolution</b> of <b>architecture</b> between the Traditionalists and Modernists in the Dutch East Indies.|$|R
40|$|Many {{software}} systems eventually undergo {{changes to}} their basic architectural structure. Such changes may be prompted by new feature requests, new quality attribute requirements, changing technology, or other reasons. Whatever the causes, <b>architecture</b> <b>evolution</b> is commonplace in real-world software projects. Today’s software architects, however, have few techniques {{to help them}} plan such evolution. In particular, they have little assistance in planning alternatives, making trade-offs among these different alternatives, or applying best practices for particular domains. To address this, we have developed an approach for assisting architects in planning and reasoning about software <b>architecture</b> <b>evolution.</b> Our approach is based on modeling and analyzing potential evolution paths that represent different ways of evolving the system. We represent an evolution path as a sequence of transitional architectural states leading from the initial architecture to the target <b>architecture,</b> along with <b>evolution</b> operators that characterize the transitions among these states. We support analysis of evolution paths through the definition and application of constraints that express rules governing {{the evolution of the}} systemand evaluation functions that assess path quality. Finally, a set of these modeling elements may be grouped together into an evolution style that encapsulates a body of knowledge relevant to a particular domain of <b>architecture</b> <b>evolution.</b> We evaluate this approach in three ways. First, we evaluate its applicability to real-world <b>architecture</b> <b>evolution</b> projects. This is accomplished through case studies of two very different software organizations. Second, we undertake a formal evaluation of the computational complexity of verifying evolution constraints. Finally, we evaluate the implementability of the approach based on our experiences developing prototype tools for software <b>architecture</b> <b>evolution...</b>|$|R
