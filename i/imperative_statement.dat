4|37|Public
40|$|The debate {{concerning}} {{the proper way}} of understanding, and hence solving, the “is-ought problem” produced two mutually exclusive positions. One position claims that it is entirely impossible to deduce an <b>imperative</b> <b>statement</b> from a set of factual statements. The other position holds a contrary view {{to the effect that}} one can naturally derive an <b>imperative</b> <b>statement</b> from a set of factual statements under certain conditions. Although these two positions have opposing views {{concerning the}} problem, it should be evident that they both accept that the “is-ought problem” is concerned with the deducibility of imperative statements from factual statements. Later I will argue that this should not be our concern when we try {{to make sense of the}} way we reason about morality...|$|E
40|$|Sixty children, 20 {{from each}} of grades 1, 3, and 5 served as {{subjects}} in a study that examined how elementary school age children realize the intent of directives embedded within written and picture book narratives. Directives were defined as the range of language forms used to direct actions (<b>imperative</b> <b>statement,</b> need/want statement, permission request, explicit question, nonexplicit question, and hint). The children read the written stories {{and listened to the}} picture book stories prior to answering questions concerning pragmatic relations expressed in the texts. The findings indicated that alternative directive processing strategies evolved as the children gained experience in varying language choice in different social settings. these strategies [...] reciprocity, reflexivity, and reasoning [...] reflected a gradual shift in the children's thinking from reliance on situational context t...|$|E
40|$|The {{purpose of}} this {{research}} is to identify the use of shuujoshi ze and zo inHakkenden comic so that the readers understand its use, especially in Japanesecomic. The data of the research is a Japanese comic by Miyuki Abe entitled"Hakkenden" volume 1 - 8. The method used in this research are descriptive method and deletion technique. Descriptive method and deletion technique are applied to identify the degree ofsignificance of the unit being deleted. The results of the research related to the application of shuujoshi ze is applied inmaking statement or used in changing statement into interjection and specifyingparticular unit of the statement to attract listeners. Shuujoshi ze also showing offthe speaker 2 ̆ 7 s wants, shuujoshi ze strengthens the speaker 2 ̆ 7 s suggestion towardslisteners. Shuujoshi zo is applied in showing <b>imperative</b> <b>statement</b> or threat. It isalso found that it strengthens the function mentioned and adding strength to theword to emerge the speaker 2 ̆ 7 s bravery or urging the speaker himself. The result ofdeletion technique analysis shows the insignificance of the shuujoshi ze and zo. Itmeans without shuujoshi ze and zo a sentence is still grammatical...|$|E
40|$|Traditional formal {{methods and}} modern agile methods are {{separated}} more by limitations of current technology than by fundamental intellectual differences. A mixed interpreter that executes mixed programs, comprising both declarative specification <b>statements</b> and regular <b>imperative</b> <b>statements,</b> might bridge the gap. This paper explores how such an interpreter might be used, showing by example {{how it might}} support a variety of development activities. National Science Foundation (U. S.) (Grant No. 0541183...|$|R
40|$|In {{this paper}} a method is {{proposed}} {{for carrying out}} analysis of imperative programs. Weachieve this by writing down the language semantics as a declarative program #a constraint logic program, in the approach shown here#. We propose an e#ectivestyle of writing operational semantics suitable for analysis whichwe call one-state small-step semantics. Through controlled partial evaluation {{we are able to}} generate residual programs where the relationship between <b>imperative</b> <b>statements</b> and predicates is straightforward. Then w...|$|R
2500|$|According to Jewish tradition, [...] {{constitutes}} God's first recitation and inscription of the {{ten commandments}} on the two tablets, which Moses broke in anger with his rebellious nation, and were later rewritten on replacement stones {{and placed in the}} ark of the covenant; and [...] consists of God's re-telling of the Ten Commandments to the younger generation who were to enter the Promised Land. The passages in Exodus 20 and Deuteronomy 5 contain more than ten <b>imperative</b> <b>statements,</b> totalling 14 or 15 in all.|$|R
40|$|The {{shift in}} warfare and in {{geopolitics}} since the Cold War {{has made it}} difficult for Americans to identify the “good guys ” and the “bad guys ” in international affairs. The “Evil Empire ” is no longer reflexively the Soviet Union or its proxies, for example. Without a clear sense of who needs protection, the media and other political actors have tried to identify who is innocent. In many cases, children have been portrayed as the only “pure ” victims. For many conflicts and crises, children, seen generically, have filled up the American empathy vacuum—that void that used to be taken up by the Natan Sharanskys, the Alexander Solzhenitsyns, the Jacobo Timmermans, the Nelson Mandelas:men,typically,who stood for the values of democracy,equality,and freedom. Now,often, conflicts are depicted in the media less as political confrontations than as brutal and ideologically senseless battles,and how better to communicate that than to show a damaged child? Starving children are the famine icon. An emaciated child is not yet associated with the stereotypes attached to its color, its culture, or its political environ-ment. Skeletal children personify innocence abused. They bring moral clarity to the complex story of a famine. Their images cut through the social, economic, and political context to create an <b>imperative</b> <b>statement.</b> Time (1992) magazine’s cover story on the stands the week that the U. S. Marines landed in Mogadishu in December 1992 included a four-page photo essay titled “Landscape of Death. ” It was prefaced by this short column of text: The harrowing faces of starvation, in inert shapes of death. These are the images that have finally brought the world to Somalia’s rescue. Why did it take so long, when some reporters have been telling the story for months? Such is the power o...|$|E
40|$|Researchers and {{practitioners}} alike {{are in need}} of an operationally useful, and theoretically sound, model of sustainable enterprise. This paper synthesizes insights from systems theory and value theory to construct such a model, which allows for the formulation of descriptive and <b>imperative</b> <b>statements.</b> This value-based model provides a method of conceptualizing sustainable enterprise that incorporates spatial and temporal scales, social and ecological well-being, and conflict and concord among choices and perspectives. Results from this analysis provide useful insights both for future directions in sustainable enterprise research, and for those entrepreneurs dedicated to making the sustainable enterprise a reality...|$|R
40|$|In {{this work}} we propose {{a set of}} term-rewriting {{techniques}} for modelling object-oriented computation. Based on symbolic variants of explicit substitutions calculi, we show {{how to deal with}} <b>imperative</b> <b>statements</b> like assignment and sequence in specifications in a pure declarative style. Under our model, computation with classes and objects becomes simply normal form calculation, exactly as it is the case in term-rewriting based languages (for instance the functional languages). We believe this kind of unification between functions and objects is important because it provides plausible alternatives for using the term-rewriting theory as an engine for supporting the formal and mechanical reasoning about object-oriented specifications...|$|R
40|$|We present general {{principles}} of modern programming languages and discuss requirements which {{have to be}} observed during the development of integrated object-oriented query/programming languages and their theories. The requirements stem mostly from aesthetic criteria, but we argue they have the fundamental meaning for pragmatic aspects of such languages. We propose a basis for building systems satisfying these requirements. In this basis {{the role of an}} environment stack and naming-scoping-binding issues is central. Object-oriented database query/programming languages require modifications of the construction of the classical programming languages' stack. In particular, they need the separation of the stack from an object store, as well as macroscopic binding. This makes it possible to define query operators directly by operations on the stack. Such a query language can be easily integrated with macroscopic <b>imperative</b> <b>statements,</b> programming abstractions (procedures, views, modules), and [...] ...|$|R
40|$|Precise {{modelling}} of behaviour is an {{area where}} programming meets modelling, and textual syntax competes with a visual one. By developing a UML based platform-independent framework, we aimed to find a visual syntax aid to make the language more approachable to stakeholders, while taking advantage of existing UML syntax intuitions and offering a truly higher level of abstraction. Our solution consists of seamlessly integrated UML Actions and the Object Constraint Language (OCL) as a database query language, featuring both a textual and a visual syntax. In this paper we describe a declarative, Query by Example (QBE) -based approach to visualizing OCL expressions over a UML object-oriented model instance, to be used inside of textual or visual <b>imperative</b> <b>statements.</b> Such visual OCL expressions can also be used as ad-hoc queries. The paper presents a choice of visual syntax and describes its underlying semantics...|$|R
40|$|This paper {{addresses}} {{the issue of}} giving a formal semantics to an object-oriented programming and specification language. Object-oriented constructs considered are objects with attributes and methods, encapsulation of attributes, subtyping, bounded type parameters, classes, and inheritance. Classes are distinguished from object types. Besides usual <b>imperative</b> <b>statements,</b> specification statements are included. Specification statements allow changes of variables to be described by a predicate. They are abstract {{in the sense that}} they are non-executable. Specification statements may appear in method bodies of classes, leading to abstract classes. The motivation for this approach is that abstract classes can be used for problem -oriented specification in early stages and later refined to efficient implementations. Various refinement calculi provide laws for procedural and data refinement, which can be used here for class refinement. This paper, however, focuses on the semantics of object-o [...] ...|$|R
40|$|In {{this paper}} a method is {{proposed}} {{for carrying out}} analysis of imperative programs. We achieve this by writing down the language semantics as a declarative program (a constraint logic program, in the approach shown here). We propose an effective style of writing operational semantics suitable for analysis which we call one-state small-step semantics. Through controlled partial evaluation {{we are able to}} generate residual programs where the relationship between <b>imperative</b> <b>statements</b> and predicates is straightforward. Then we use a static analyser for constraint logic programs on the residual program. The analysis results are interpreted through program points associating predicates in the partially evaluated interpreter to statements in its corresponding imperative program. We used an analyser that allows us to determine linear equality, inequality and disequality relations among the variables of a program without user-provided inductive assertions or human interaction. The proposed m [...] ...|$|R
40|$|The {{involvement}} of politeness in directive speech especially at school environment {{is an interesting}} phenomenon to be studied. This study aims to assess the perception of politeness in directive speech by students of SMAN 1 Surakarta. This research involves the combination of descriptive quantitative and qualitative method. The data is collected through questionnaires and is analyzed by descriptive statistical techniques. The results show the orders of politeness from the most polite to the least polite as follows: (1) directive speech {{in the form of}} advice, (2) directive speech in the forms of question, (3) directive speech in the forms of a strong signal, (4) directive speech in the forms of subtle cues, (5) the form of directive speech in the form of mitigated statements, (6) directive speech in the form of <b>imperative</b> <b>statements,</b> (7) directive speech the form of expression of interest, (8) directive speech with explicit statements, and (9) directive speech with the imperative modes...|$|R
30|$|Chef is a {{configuration}} management framework written in Ruby [70]. Chef uses an internal Domain Specific Language or DSL to express configurations. Configuration definitions (i.e. ruby-scripts) and supporting resources (e.g. installation files) in Chef are called recipes. These recipes are basically scripts written in DSL {{to express the}} target state of a system [71]. Chef manages so called nodes. A node {{is an element of}} enterprise infrastructure, such as a server which can be physical, virtual, in the cloud, or even a container instance running a Chef client [72]. Chef provides APIs to manage resources on a machine in a declarative fashion. Chef recipes are typically declarative (resources which define a desired state) but can include <b>imperative</b> <b>statements</b> as well. Combining a Chef system together with cloud infrastructure automation framework makes it easy to deploy servers and applications to any physical, virtual, or cloud location. Using Chef, an organization can configure IT from the operating system up; applying system updates, modifying configuration files, restarting any necessary system services, applying and configuring middleware and applications.|$|R
5000|$|Surigaonon {{has similar}} {{consonant}} and vowel sounds, stress, intonation patterns to the Cebuano language and Boholano dialect. Surigaonon underwent certain morphophonemic processes, such as assimilation, deletion, alternation and metathesis (Dumanig, 2005). In the {{study conducted by}} Dumanig (2005) on Descriptive Analysis of Surigaonon language {{it was found that}} there are 18 consonants (b,d,g,h,j,k,l,m,n,ng,p,r,s,t,w,y,o,?) with 18 sounds and 3 vowels (a,i,u) with 5 sounds. It has also 25 consonant clusters (br, bl, bw, by, dr, dy, dw, gr, gw, kr, kl, kw, mw, my, nw, pr, pl, pw, py, sw, sy, tr, tw, ty, hw) and 4 diphthongs (aw, ay, iw, uy), which are similar to the Cebuano language (Rubrico, 1999). There are Surigaonon words that are spelled similarly but they differ in meaning depending on how each syllable is stressed (Dumanig, 2005). Surigaonon language follows two intonation patterns like the rising and falling intonation. The rising intonation is common in asking yes or no questions and the falling intonation occurs in ending declarative and <b>imperative</b> <b>statements</b> (Dumanig, 2005)http://lingweb.eva.mpg.de/jakarta/seals/Dumanig_SEALS_XVI_Abstract.pdf ...|$|R
50|$|Twenty years later, Crank and Felleisen {{showed how}} to scale Plotkin's work to {{languages}} with <b>imperative</b> assignment <b>statements.</b> They define calculi for a language with variables, functions, function application and assignment statement that capture the conventional notions of parameter passing and evaluation strategies {{of a wide}} array of programming languages. They show that each calculus satisfies Plotkin's criteria, including traditional Church-Rosser and Curry-Feys theorems respectively. In addition, they introduce a calculus that reifies ML's notion of reference cell.|$|R
40|$|We propose an {{abstract}} machine for LDL that maintains a high-level {{view of an}} LDL program while incorporating aspects of its execution that make a performance difference. A canonical AND/OR graph corresponding to the LDL program provides the skeleton of its execution. The nodes in the AND/OR graph are annotated to specify relevant details of the execution, such as access methods, join methods, execution strategies, intelligent backtracking, etc. We formalize four execution methods (top-down, bottom-up, {{as well as two}} hybrid methods that incorporate memoing) and two recursive computations (fixpoint and stack-based). The two computations and four execution methods are combined to cater to a rich variety of recursive techniques. This annotated AND/OR graph represents a declarative program for the abstract machine. The set of all possible annotated AND/OR graphs constitutes the execution space that defines the abstract machine. To prove the feasibility of this declarative abstract machine, we demonstrate an actual realization by presenting a code generation algorithm that proceeds by translating each node in the annotated AND/OR graph into a sequence of <b>imperative</b> <b>statements</b> that include calls to a tuple-level interface of an underlying DBMS. The LDL compiler — which supports Datalog, sets, updates, negation, non-deterministic choic...|$|R
40|$|The {{present study}} {{assessed}} {{the construct validity}} of self- and peer ratings of influence, friendliness, and productivity. Contrary to earlier work, we focused on the congruence between these ratings and group members’ actual behavior on these traits. Participants were 68 Dutch secondary school students (Mage = 15. 9 years) divided over 24 groups working on a collaborative, computer-mediated writing task. Halfway through the task and after completing the task, group members rated themselves and their peers in an electronic peer feedback and reflection tool. Multilevel regression analyses revealed that self-ratings of friendliness were based on responsive statements at the first time-point, but no longer after exposure to and participation in the reflection tool. At the second time point, self-ratings of productivity were predicted by one’s overall chat participation, self-ratings of influence by informative and <b>imperative</b> <b>statements,</b> as well as by chat participation, and peer ratings of influence by informatives, elicitative statements, and chat participation. Social relations analyses showed significant target effects for ratings of influence and productivity, and significant perceiver effects for ratings of friendliness. These findings suggest that self- and peer ratings of influence, friendliness, and productivity are only construct valid to a limited degree, but that reflection on one’s functioning within the group may {{have a positive effect on}} this validity...|$|R
40|$|Among dialects of Brazilian Portuguese (henceforth BP), {{the variety}} spoken in the Northeast region of Brazil is {{considered}} to display a distinctive use of intonation. In attempt to understand this characterization, this thesis presents {{an analysis of the}} intonational phonology of five main phrase types in Northeastern BP (henceforth NEBP) : declarative statements, absolute questions, wh- questions, echo questions, and <b>imperative</b> <b>statements.</b> Contrastive focus, enumeration, and disjunction were also investigated. Participants were 5 female natives of the region currently residing in Pittsburgh, PA. Utterances were elicited using an intonation questionnaire designed to evoke everyday situations (Prieto and Roseano, 2010), which was adapted to BP by the author. This descriptive analysis is couched within Autosegmental Metrical theory, which posits a separate level of linear organization for the pitch track of an utterance, autonomous from the text, or segmental information, but associated with it via tonal alignment with metrically strong syllables and phrase edges. Within this model, the Tone and Break Index (ToBI) system is used to transcribe intonational features. Given that there are no existing transcriptions of the intonation of NEBP within the ToBI system, this study aims to fill that gap by providing a description of various modal and pragmatic uses of intonation. Findings that differentiate this dialect from European and southeastern Brazilian dialects include the consistent use of upstep in marking contrastive focus and two opposing variants for both yes-no questions, and wh-questions. It is hoped that the present findings will add to the body of work on dialectal variation in intonation, and will contribute to our general understanding of intonational patterning across languages. ...|$|R
40|$|Directive forms used by {{teachers}} in classrooms. They {{are used by}} the teachers to control, to manage the classrooms in the teaching learning activity. What are the directive forms used by the teachers to run the teaching learning activity? How do the students comply the directive intent? The {{answer to the question}} was done by exploring four conversations of speaking class teachers. Using the classification of adults' directive forms by Ervin-Tripp (1976 a) as parameter: need <b>statement,</b> <b>imperative,</b> imbedded imperative, permission directive, question directive, and hints, the writer analyzed the data and found out that there are five directive forms used by the teachers: need <b>statement,</b> <b>imperative,</b> imbedded imperative, question directive, and hints to run the teaching learning activity in the classroom. The directive forms are used to assign task, to structure lesson, and to manage the teaching learning activity. The students have two kind of response. They comply and sometimes they don't comply. The writer suggests that there would be another research on directive forms in other classes, like reading class, writing class, etc. Because there might be different directive forms in different setting...|$|R
40|$|State Machines, {{algebraic}} specifications, implicit state. 1. Introduction Evolving algebras {{proposed by}} Gurevich [1] have been intensively used for formal definition of various algorithms and programming language semantics [2, 3, 4, 5, 6, 7, 8, 9]. The {{success of the}} approach {{can be attributed to}} two reasons: (1) sound mathematical background and (2) imperative specification style. In contrast to conventional algebraic specification languages providing the specification technique resembling functional programming, evolving algebras provide several transition rules resembling <b>imperative</b> programming <b>statements.</b> As a result, a specification looks like an imperative program, it is easier to understand, and it is executable. This imperative nature of evolving algebras has led to the introduction of a new term for them, Gurevich Machines (the terms Abstract State Machines and Gurevich Abstract State Machines are also in use). Unfortunately, Gurevich Machines in their present form are quite [...] ...|$|R
40|$|I {{would like}} to {{acknowledge}} certain people that made a contribution to the process of conducting this research and writing this thesis. First and foremost I {{would like to}} thank Professor Dellaert for his support, feedback and, last but not least, patience during my research process. Furthermore, I would like to thank Tim van Vliet, Bas de Knegt and the Expand Online B. V. management for their flexibility and providing me the time to write this thesis while doing my job. Last, but certainly not least, I would like to thank my parents, Goran Brkić and Elizabeta Brkić, for giving me this opportunity of education and their moral support along the way. 2 This research had the purpose to study the effect of call to action use on text ad effectiveness within search engine advertising. The aim was to get an insight in the effect of an advertisement containing a call to action on the ad’s CTR and conversion rate. Therefore, the following research question has been formulated; “What is the effect of call to actions on text advertisement effectiveness within SEA?”. A brief review of existing literature learns what Search Engine Advertising is and that it’s mechanism works on two main subjects. The submitted maximum price per click and the submitted keywords by the advertiser. Together these determine if the ads are displayed when a user conducts a search query. Furthermore the literature explains what the purpose of advertising is based on the AIDA model. With regard to this model call to actions are explained as <b>imperative</b> <b>statements</b> within text advertising which have the purpose to draw the customer into clicking on the displayed ad’s and buy the promoted products. Based upon this one could argue that call to actions have an positive effect on the effectiveness an ad has. In line with the call to action purpose, advertisement effectiveness measure within SEA has been determined by the ad’s click-through-rate (CTR) and conversion rate...|$|R
40|$|Abstract. XML views {{can be used}} in Web {{applications}} to resolve incompatibilities among heterogeneous XML sources. They allow {{to reduce the amount of}} data that a user has to deal with and to customize an XML source. We consider virtual updatable views for a query language addressing an XML native database. The novelty of the presented mechanism is inclusion of information about intents of updates into view definitions. This information takes the form of procedures that overload generic view updating operations. The mechanism requires integration of queries with <b>imperative</b> (procedural) <b>statements</b> and with procedures. This integration is possible within the Stack-Based Approach to query languages, which is based on the classical concepts of programming languages such as the environment stack and the paradigm of naming/scoping/binding. In the paper, we present the view mechanism describing its syntax, semantics and discussing examples illustrating its possible applications. ...|$|R
40|$|We present {{our work}} in {{progress}} concerning the verification of imperative programs in the Theorema system. Given an imperative program P and its specification (input condition formula IP and output condition formula OP), {{we are interested in}} finding the answer to the question: Is the program P correct with respect to its specification? To answer this question we use a method which is based on forward reasoning [4, 3], symbolic execution [2, 5] and functional semantics [7]. The program P is represented as a term at meta-level; it contains formulae and terms from the theory Υ in predicate logic and constructs corresponding to the <b>imperative</b> language <b>statements.</b> For writing <b>imperative</b> programs in Theorema system, we use some commands for the user interface role [6] (Program, Pre, Post, FwdVCG), which allow the definition of programs together with their specification, and imperative language constructs: � abrupt termination statements (return) � assignments- besides simple constant and variable assignment, function (including recursive call) call is also handled � conditionals: If with one and two branches Example Program[&quot;MyFactorial&quot;, Fact[↓ n], Module[{fact}]...|$|R
40|$|This thesis {{attempts}} to unite and consolidate two large and often culturally disjoint programming paradigms: declarative (focusing on specifying what a program {{is supposed to}} do, e. g., shuffle an array so that its elements are ordered) and imperative (detailing how the program intention is to be implemented, e. g., by applying the QuickSort algorithm). The ultimate result of such an effort would be a unified programming environment in which both paradigms are seamlessly integrated, specifications are fully and efficiently executable, and programs are written by freely mixing <b>imperative</b> <b>statements</b> and declarative specifications. With the advent of automated constraint solving, executing declarative specifications as standalone programs has become feasible. A number of challenges still remain. To achieve full automation, constraint solvers often impose restrictions on specification languages and their expressiveness; compromises are also made when integrating a (typically logic-based) specification language with a traditional procedural programming language; and finally, applicability is usually limited to specialized algorithmic domains (for which constraint solving is particularly suitable) and programmers comfortable with writing formal logic. This thesis proposes several advances to address these issues. First, a novel constraint solving framework is presented, Alloy*, {{the first of its}} kind capable of automatically and reliably solving arbitrary higher-order formulas (written in standard predicate logic) over bounded domains. Second, a new approach to integrating a specification and an implementation language is proposed, where Alloy, a relational logic-based modeling and specification language, is deeply embedded in Ruby. The resulting platform, called [alpha]Rby, uses Alloy* as its back end, and serves both as an Alloy modeling environment with added Ruby scripting layer around it, and as a Ruby programming environment with added executable specifications. Third, the general idea of declarative programming (focusing on what instead of how) is applied to web programming, producing SUNNY, a model-based reactive web framework with a clear separation between data, events (business logic), and security policies. SUNNY is (1) policy-agnostic-allows security policies to be specified individually and independently from the rest of the code, (2) reactive-automatically propagates data updates to all connected clients while enforcing the security policies, (3) mostly declarative-offers a unified sequential view of the entire distributed web system, allowing events to be implemented only in terms of simple modifications to the data model. by Aleksandar Milicevic. Thesis: Ph. D., Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, 2015. Cataloged from PDF version of thesis. Includes bibliographical references (pages 141 - 153) ...|$|R
40|$|Child's {{learning}} {{language is}} a fascinating matter to be observed all the time. The way a child constructs a sentence always makes anybody around him/her curious. There are so many observations deal with this matter that create child language acquisition theories. However, the writer notices there are such still a few linguists observing/studying Indonesian children. Nevertheless, linguistic theories are universal in which any observers are able to apply them to any children {{although there are some}} differences. Based on that reason, the writer carried out an Indonesian child observation in acquiring her language. This study concerns with the production of utterances as uttered by a two year- old Indonesian child and the language functions which are reflected in the utterances. The data of this study which was collected with a tape recorder and a diary were transcribed and analyzed under the parameters of kinds of sentences, the syntactic patterns, and language functions in the subject's one-word utterances, two-word utterances, three-word utterances, and more-than-three-word utterances. This study is a case study since the writer only analyzed one Indonesian child to find out the kinds of sentences, the syntactic patterns, and the language functions that were produced in the subject's one-word utterances, two-word utterances, three-word utterances, and more-than-three-word utterances. After analyzing the data, the writer found that the subject only produced the headword in her one-word utterances. Meanwhile, in two-word utterances, the subject practised the pivotal structure in which her pattern was Pivot + Open. In this case her pivot words was the function words and her open words were the content words. Apart from that, the subject had been able to produce sentences which consists of subject, predicate, and object in her three-word utterances. She had already produced more-than-three-word utterances which came to resemble adult language. Generally, the produced sentences were various. They are simple affirmative statements, negative statements, interrogative <b>statements,</b> and <b>imperative</b> <b>statements.</b> Even in the production of three-word utterances, the subject of the study began to produce passive statements although the form was not perfect. The produced utterances reflect language functions. In the subject's one word utterances, they imply only three kinds of language functions, i. e. informational, expressive, and directive. Starting from two-word utterances until the subject was able to produce more-than-three-word utterances, the language she produced began to reflect a phatic function. What is interesting to notice is that her utterances may also reflect two functions at the same time. Finally, this study is intended to give a contribution to Psycholinguistics and further observation dealing with Indonesian child's language development...|$|R
40|$|Abstract Effective feedback, as an {{integral}} part of formative assessment, has been identified as a powerful tool that enhances learning. However, “Effectiveness” has been perceived differently by students due to at least four factors: 1. Quantity, 2. Quality, 3. Timing, and 4. Language used in feedback provided. Much research has been conducted on the first three factors, but language needs to be thoroughly investigated. This research in the sector of Education attempts to rectify certain important omissions in the literature of formative assessment in the area of language by using “register theory” in Systemic Functional Linguistics. With ‘register’ simply defined as field, tenor, and mode of discourse (e. g. Halliday, McIntosh, & Strevens, 1964), the not adequately captured relationship between language structure and language function, is to be re-visited (Halliday, 1985) in connection with educative feedback. In this study, field expressed through ideational meanings, tenor expressed through interpersonal meanings, and mode expressed through textual meanings are investigated in connection to how linguistic style affects the perceived effectiveness of written feedback provided to students. A small sample of graduate students from a Faculty of Education is examined. The systemic coder (O’Donnell, 2002) is employed on collected assignments from participants. Results show that the linguistic style of a professor is found to affect the perceived effectiveness of written feedback provided to students on their assignments. The use of the ideational meanings of material process, non-human participants, passive voice, and nominalization; the interpersonal meanings of declarative statements, interrogative statements, and modality; in addition to the textual meanings of lexical density, cohesion, textual adjuncts, and emphasis are all found to help students perceive feedback as effective. Therefore; professors are requested to increase the use of these language aspects when providing feedback because of the hidden positive meanings these aspects can add to the feedback provided. However, the use of the ideational meanings of behavioral process, relational process, and active voice; the interpersonal meanings of <b>imperative</b> <b>statements,</b> personal pronouns, and evaluative words; and the textual meanings of grammatical intricacy are found to result in students perceiving feedback as ineffective. As a result, professors are requested to decrease the use of these language aspects when providing feedback because of the hidden negative and unwanted meanings these aspects can add to the feedback provided. Results also illustrate that students perceive feedback as effective when this feedback leads to at least one of the following scenarios: improving student grades, protecting student self-esteem, having a good relation with feedback provider, and/or enhancing student learning. Ineffective feedback is found to have negative consequences on students. Decision-makers are requested to reduce the number of students as well as the tasks required in each class. They are also advised to professionally develop professors with training workshops on how to provide feedback...|$|R
40|$|The aim of {{the article}} is to give an {{overview}} of directive speech acts in Estonian child-directed speech. Two school-age children from the same family and their dialogues with both parents individually are under observation. A longitudinal study {{has been used as}} the method (one child has been regularly recorded from ages 7 to 10, the other from ages 10 to 14), including 16 hours of audio material. All directive speech acts have been singled out from the parents’ speech and classified into <b>imperatives,</b> hints, prohibitions, <b>statements</b> of an addressee’s desired actions, permissions, speaker’s wishes, suggestions, hortatives, warnings and statements of social rules. Based on the analysis, comparisons are made between the mother’s and father’s speech with regard to the usage of different types of directives, and the dynamics of using directives when the child is growing as well as in situations of communication have been examined...|$|R
40|$|AbstractThis paper {{presents}} the language Lutin and its operational semantics. This language specifically targets {{the domain of}} reactive systems, where an execution is a (virtually) infinite sequence of input/output reactions. More precisely, it {{is dedicated to the}} description and the execution of constrained random scenarios. Its first use is for test sequence specification and generation. It can also be useful for early simulation of huge systems, where Lutin programs can be used to describe and simulate modules that are not yet fully developed. The programming style mixes relational and <b>imperative</b> features. Basic <b>statements</b> are input/output relations, expressing constraints on a single reaction. Those constraints are then combined to describe non deterministic sequences of reactions. The language constructs are inspired by regular expressions, and process algebra (sequence, choice, loop, concurrency). Moreover, the set of statements can be enriched with user defined operators. A notion of stochastic directive is also provided, in order to finely influence the selection of a particular class of scenarios...|$|R
40|$|Given {{a program}} {{written in a}} simple <b>imperative</b> {{language}} (assignment <b>statements,</b> for loops, affine indices and loop limits), this paper presents an algorithm for analyzing the patterns along which values flow as the execution proceeds. For each array or scalar reference, {{the result is the}} name and iteration vector of the source statement {{as a function of the}} iteration vector of the referencing statement. The paper discusses several applications of the method: conversion of a program to a set of recurrence equations, array and scalar expansion, program verification and parallel program construction. Keywords dataflow analysis, semantics analysis, array expansion. 1 Introduction It is a well known fact that scientific programs spend most of their running time in executing loops operating on arrays. Hence if a restructuring or optimizing compiler is to do a good job, it must be able to do a thorough analysis of the addressing patterns in such loops. If taken in full generality, [...] ...|$|R
40|$|This paper {{presents}} Lutin, {{a language}} for describing and generating random reactive behaviours. This language specifically targets {{the domain of}} reactive systems, where an execution is a (virtually) infinite sequence of input/output reactions. More precisely, it {{is dedicated to the}} description and the execution of constrained random scenarios. Its first use is for test sequence specification and generation. It can also be useful for early simulation of huge systems, where Lutin programs can be used to describe and simulate modules that are not yet fully developed. The programming style mixes relational and <b>imperative</b> features. Basic <b>statements</b> are input/output relations, expressing constraints on a single reaction. Those constraints are then combined to describe non deterministic sequences of reactions. The language constructs are inspired by regular expressions, and process algebra (sequence, choice, loop, concurrency). Moreover, the set of statements can be enriched with user defined operators. A notion of stochastic directive is also provided, in order to finely influence the selection of a particular class of scenarios. Keywords: Reactive systems, synchronous programming, language design, test, simulation...|$|R
40|$|This article {{compares the}} {{application}} of conditional clauses in English and Persian. Based on two classical literary works, East of Eden by John Steinbeck (1952) and Missing Solooch (In Persian Ja-ye Khali-ye Solooch) by Mahmood Dolatabadi (1979), conditional clauses were retrieved and analysed. The findings indicated that Persian and English have some similarities and differences {{in terms of the}} type of conditionals and conjunctions. English seems to employ more conditionals than Persian does. Among the different types of conditionals, type one shows to be more frequent in both languages, while Persian type 2 is mostly representative of type 3 concept. Persian appears to freely employ the subject-fronting strategy to place emphasis on the subject by assigning the subject to an initial position before ‘if’. In both languages, the if-clause is mainly initial in <b>imperative</b> and declarative <b>statements.</b> Reverse conditionals and the deletion of ‘if’ in certain types suggesting high formality do not exist in Persian. Unlike English, Persian does not combine ‘if’ with adjectives and past participles and hence contracted conditionals and the courtesy-bearing structure of English are not common in Persian conditionals. Compared to Persian, the high frequency of English conditionals is also supported by the corpus of Hamshari, an Iranian newspaper, the Time Magazine corpus and Corpus of Contemporary American English...|$|R
40|$|In {{this paper}} I {{argue that in}} Grounding for the Metaphysics of Morals Kant {{suggests}} that while I can never know when I am acting from duty, I can know when I am not acting from duty. In this paper I neither reconcile Kant’s <b>imperatives</b> with his <b>statement</b> that {{we will never know}} if we are definitely acting on his maxims, nor do I mount an argument against his perfectionist ideal theory. Instead I propose a negative formulation of his perfectionist ideal theory that argues Kant implicitly suggests I can only know when I am not acting from duty. First, I describe how the conditions of moral worth which Kant outlines make it so that I can never definitely know if I am acting from duty. I then take these conditions and show that Kant indirectly suggests that I can, however, know when I am not acting from duty. Specifically I examine the conditions Kant places on moral actions viz. the relationship inclinations and duty have with the moral worth of an action. Next, I provide a non-exhaustive refutation of potential arguments against my negative formulation proposition. Finally I discuss the implications of my negative formulation proposition on Kant’s perfectionist ideal theory as a whole. I begin by outlining Kant’s conditions of moral worth, and showing how these conditions makes it impossible to know I am acting from duty. Kant defines an actio...|$|R
40|$|The {{contemporary}} {{approaches to}} moral philosophy have experienced diverging directions regarding the possibility and justification of reasoning. Hare claims {{that in spite}} of the fact that intuitivists like Moore, Ross, and Prichard block the use of reasoning by accepting the intuitiveness of knowledge of good and bad, emotivism takes the same rout by focusing on emotions and emphasizing the freedom of choice. While descriptivism and also naturalism accept the possibility of reasoning through admitting the indicative nature of ethical speech, they reject or limit the freedom of choice. He tries to justify both the freedom of choice and the possibility of rational reasoning in moral. In so doing, Hare takes refuge in the non-self-contradiction and compatibility principles to insist on the universalizability of rules of moral reasoning. To make judgments of relevance is the prerequisite in morals which subsequently encompasses universalizability and the possibility of reasoning. Using the linguistic analysis, Hare tries to show that as language in which predicate-logic governs <b>statements,</b> <b>imperatives</b> and moral sentences are governed by rational relationships and principles of compatibility. From this point of view, an individual’s judgments are justifiable, provided that it is not in contradiction with his previous judgments. The aim of this study is to state, analyze, and criticize Hare’s views regarding the provision of rational reasoning and its possibility in terms of the challenges he faces with regard to competing schools of thought...|$|R
40|$|Eiffel is an imperative, {{object-oriented}} programming language. In an <b>imperative</b> programming language <b>statement</b> after statement is executed and variables may be assigned values. The so specified program has states {{it can be}} in and which may change. In contrast with the paradigm of imperative programming is the paradigm of functional programming where patterns are matched rather than statements executed. A functional program is stateless {{which means that the}} program does not have states it can be in. Also, variables cannot be assigned values. The aim of this thesis is the implementation of a library that provides features of functional programming to Eiffel. This means {{that there will be a}} “switch ” which can be switched on if functional programming style is wanted. This functional programming style will include (among other features) a different syntax, i. e. e. g. list comprehensions. Another feature will be a “state of state-lessness “ meaning that the statements will not be executed sequentially as in imperative programming mode. The outcome is intended to strongly resemble a functional language. Scope of the work The scope of this work will include the library mentioned above. This library’s main features will be the following:- pattern matching- list comprehensions- lazy evaluation- lambda calculus- prohibition of side effects- statelessness- favor of recursion (instead of iteration) The keywords listed are just a few keywords that will constitute the core of this project. In addition to them other features will be considered and may be implemented such as currying, the issue of performance and further aspects resulting from the above mentioned. Intended results The result of this project will include a library that provides functional functionality to Eiffel as well as a deeper insight into how to combine functional and imperative programming...|$|R
