18|38|Public
5000|$|<b>Instruction</b> <b>counter</b> - one (address 9999 - standard; 99999 - {{extended}} 7074) ...|$|E
5000|$|Control panel {{facilitates}} {{power on}} and off, memory data entry and readout, <b>instruction</b> <b>counter</b> entry and selection of either program execution mode or control panel mode.|$|E
5000|$|Their RASP's {{registers}} are unbounded in {{capacity and}} unbounded in number; likewise their accumulator AC and <b>instruction</b> <b>counter</b> IC are unbounded. The instruction set is the following: ...|$|E
40|$|Many {{systems have}} {{implemented}} replay of parallel or sequential processes, but none {{have provided a}} robust set of debugger tools that {{take advantage of this}} power. This paper develops new ideas about how software <b>instruction</b> <b>counters</b> can be used by programmers to facilitate debugging applications under replay. This paper is the discussion of the author's project for Honors in the degree of Bachelor of Science under the direction of Professor Robert H. B. Netzer. ...|$|R
40|$|AbstractThis paper {{presents}} a novel profiling approach, which is entirely based on program transformation techniques {{in order to}} enable exact profiling, preserving complete call stacks, method invocation <b>counters,</b> and bytecode <b>instruction</b> <b>counters.</b> We exploit the number of executed bytecode instructions as profiling metric, which has several advantages, such as making the instrumentation entirely portable and generating reproducible profiles. These ideas have been implemented as the JP tool. It provides a small and flexible API to write portable profiling agents in pure Java, which are periodically activated to process the collected profiling information. Performance measurements point out that JP causes significantly less overhead than a prevailing tool for the exact profiling of Java code...|$|R
40|$|Abstract—In {{order to}} check the {{fulfilment}} of non-functional requirements at an early system design and development stage, we provide a framework that facilitates the combination of platformindependent and platform-specific information in a query-based manner to calculate estimates for the resource consumption of the software under investigation at fine grained levels of code. Based on an already optimised intermediate representation of the source code, using a testing infrastructure for C code, we count the occurrence of instructions during program executions in a platform-independent manner. These <b>instruction</b> <b>counters</b> can be determined at program or function level. By combining these counters with cost information of a hardware platform we can provide resource consumption estimates. This allows the software developer to tailor the code steadily towards the non-functional characteristics of the software...|$|R
5000|$|... #Caption: Front {{panel of}} an IBM 701 {{computer}} introduced in 1952. Lights {{in the middle}} display the contents of various registers. The <b>instruction</b> <b>counter</b> is at the lower left.|$|E
5000|$|Example: [...] "IR [...] + 1 → IR [...] " [...] is read in prose: [...] "The {{contents}} of the finite-state machine's Instruction Register plus 1 is 'replaces the (previous) {{contents of}}' the <b>Instruction</b> <b>Counter</b> Register (ICR) [...] ".|$|E
50|$|A Change Sequence Mode (CSM) {{instruction}} stored {{the next}} instruction address in a memory location and loaded the <b>instruction</b> <b>counter</b> from another memory location. This provided a simple switch between threads within a program, {{similar to the}} sequence/cosequence behaviour of the Honeywell 800 series.|$|E
5000|$|A 9-bit {{counter and}} a 15-bit {{modifier}} (address) field. A loop <b>instruction</b> decremented the <b>counter</b> and incremented the address either by 1 or 2.|$|R
40|$|Many {{systems have}} {{implemented}} replay of parallel or sequential processes, but none {{have provided a}} robust set of debugger tools that {{take advantage of this}} power. This paper develops new ideas about how software <b>instruction</b> <b>counters</b> can be used by programmers to facilitate debugging applications under replay. This paper is the discussion of the author's project for Honors in the degree of Bachelor of Science under the direction of Professor Robert H. B. Netzer. 1 Introduction Future generations of programmers will rely on deterministic execution replay to facilitate debugging applications. While work has been done towards implementing replay debugging eciently and reliably, new tools and techniques are needed to provide the programmer with a compelling debugging experience. This paper attempts to address these concerns by discussing additions we have made to the rdb replay debugging environment to export powerful new tools to debuggers. In traditional debugging, programmers repea [...] ...|$|R
40|$|This report {{describes}} a technique for using <b>instruction</b> <b>counters</b> to track nondeterminism in {{the execution of}} operating system kernels and user programs. The operating system records the number of instructions between consecutive nondeterministic events and information about their nature during normal operation. During an analysis phase, the execution is repeated {{under the control of}} a monitor, and the nondeterministic events are applied at the same instructions as during the monitored execution. We describe the application of this technique to four areas: Performance monitoring: The technique can be used to instrument an operating system to capture long traces of memory references. Unlike current techniques, it performs the gathering in a postmortem phase and therefore has negligible effect on the computation itself during the monitoring phase. We expect trace periods that are longer than what existing techniques can capture by orders of magnitude with little or no noticeable perturba [...] ...|$|R
50|$|The {{program counter}} (PC), {{commonly}} called the instruction pointer (IP) in Intel x86 and Itanium microprocessors, and {{sometimes called the}} instruction address register (IAR), the <b>instruction</b> <b>counter,</b> or {{just part of the}} instruction sequencer,is a processor register that indicates where a computer is in its program sequence.|$|E
5000|$|Many {{academics}} question industry-backed studies linking improved {{test scores}} to their products. And some go further. They {{argue that the}} most ubiquitous device-of-the-future, the interactive whiteboard - essentially a giant interactive computer screen that is usurping blackboards in classrooms across America - locks teachers into a 19th-century lecture style of <b>instruction</b> <b>counter</b> to the more collaborative small-group models that many reformers favor.|$|E
50|$|The CPU {{operated}} on 36-bit words, and addresses were 18 bits. The Accumulator Register (AQ) was 72 bits, {{or could be}} accessed separately as two 36-bit reqisters (A and Q) or four 18-bit registers (AU,AL,QU,QL). An eight-bit Exponent Register contained the exponent for floating point operations (the mantissa was in AQ). There were eight eighteen-bit index registers X0 through X7. The 18-bit Base Address Register (BAR) contained the base address and number of 1024-word blocks assigned to the program (the 6180 used segmentation rather than the BAR). The system also included several special-purpose registers: an 18-bit <b>Instruction</b> <b>Counter</b> (IC) and a 27-bit Timer Register (TR) with a resolution of 2 μs. Sets of special registers were used for fault detection and debugging.|$|E
2500|$|Except {{there is}} a problem: If based on the counter machine chassis this computer-like, von Neumann machine will not be Turing equivalent. It cannot compute {{everything}} that is computable. Intrinsically the model is bounded {{by the size of}} its (very-) finite state machine's <b>instructions.</b> The <b>counter</b> machine based RASP can compute any primitive recursive function (e.g. multiplication) but not all mu recursive functions (e.g. the Ackermann function [...] ).|$|R
25|$|On her {{voyage to}} Hobart Hibernias surgeon was Charles Carter, {{who had a}} {{deep-seated}} antipathy towards clergymen. Unfortunately for Carter, Hibernia carried Rev. Richard Hill. Hill complained that Carter had prohibited Hill from visiting prisoners in the hospital quarters, and had ridiculed Hill's efforts at moral <b>instruction.</b> Carter <b>countered</b> that visits from clergymen depressed the sick. Eventually, Carter's inability to exercise tact when dealing with the clergy led to his dismissal from the convict service.|$|R
5000|$|Two-bit {{character}} offset, seven-bit {{counter and}} 15-bit modifier (word address). The BCHX (branch on character indexing) <b>instruction</b> decremented the <b>counter</b> and incremented the character offset, incrementing the word address if the character offset overflowed, branching if the count had not reached zero.|$|R
50|$|The {{idea of a}} {{subroutine}} was {{worked out}} after computing machines had already existed for some time.The arithmetic and conditional jump instructions were planned {{ahead of time and}} have changed relatively little; but the special instructions used for procedure calls have changed greatly over the years.The earliest computers and microprocessors, such as the Small-Scale Experimental Machine and the RCA 1802, did not have a single subroutine call instruction.Subroutines could be implemented, but they required programmers to use the call sequence—a series of instructions—at each call site.Some very early computers and microprocessors, such as the IBM 1620, the Intel 8008, and the PIC microcontrollers, have a single-instruction subroutine call that uses dedicated hardware stack to store return addresses—such hardware supports only a few levels of subroutine nesting, but can support recursive subroutines.Machines before the mid 1960s—such as the UNIVAC I, the PDP-1, and the IBM 1130—typically use a calling convention which saved the <b>instruction</b> <b>counter</b> in the first memory location of the called subroutine. This allows arbitrarily deep levels of subroutine nesting, but does not support recursive subroutines.The PDP-11 (1970) {{is one of the first}} computers with a stack-pushing subroutine call instruction; this feature supports both arbitrarily deep subroutine nesting and also supports recursive subroutines.|$|E
40|$|Although {{several recent}} papers have {{proposed}} archi-tectural support for program debugging and profil-ing, most processors {{do not yet}} provide even basic facilities, such as an <b>instruction</b> <b>counter.</b> As a result, system developers {{have been forced to}} invent soft-ware solutions. This paper describes our implemen-tation of a software <b>instruction</b> <b>counter</b> for program debugging. We show that an <b>instruction</b> <b>counter</b> can be reasonably implemented in software, often with less than 10 % execution overhead. Our experience suggests that a hardware <b>instruction</b> <b>counter</b> is not necessary for a practical implementation of watch-points and reverse execution, however it will make program instrumentation much easier for the system developer. ...|$|E
40|$|Race {{condition}} is a timing sensitive problem. A {{significant source of}} timing variation comes from nondeterministic hardware interactions such as cache misses. While data race detectors and model checkers can check races, the enormous state space of complex software {{makes it difficult to}} identify all of the races and those residual implementation errors still remain a big challenge. In this paper, we propose deterministic real-time scheduling methods to address scheduling nondeterminism in uniprocessor systems. The main idea is to use timing insensitive deterministic events, e. g, an <b>instruction</b> <b>counter,</b> in conjunction with a real-time clock to schedule threads. By introducing the concept of Worst Case Executable Instructions (WCEI), we guarantee both determinism and real-time performance. Comment: RTAS 11 Work-In-Progres...|$|E
40|$|When {{trying to}} track down bugs using cyclic debugging, the ability to {{correctly}} reproduce executions is imperative. In sequential, deterministic, non-real-time software, this re-producibility is inherent. However, when the execution is affected by preemptive interrupts, this will have severe ef-fects on the ability to reproduce program behaviors deter-ministically, since a reproduction requires the interrupts to hit the program at the exact same instructions. In previ-ous methods, this problem has been solved using different kinds of <b>instruction</b> <b>counters,</b> that induce large execution time perturbations, demand for specialized hardware, or provide inexact results. This makes them highly unfit for resource-constrained embedded real-time systems. In this paper, we propose an alternative method for pin-pointing interrupts in embedded real-time systems using context checksums, which is not dependent on specific hard-ware features or special compilers- but which rather can be applied to any system. Although context checksums in some cases also prove inexact or ambiguous, we will show that they serve as a practical method for pinpointing and reproducing interrupts in embedded real-time systems. Fur-thermore, our method performs perfectly well with standard development tools and operating systems, requires no addi-tional hardware support and, according to preliminary re-sults, consumes merely a tenth of the execution time of ex-isting software-based methods for pinpointing interrupts. ...|$|R
40|$|When {{we looked}} at the concept of the process, we {{considered}} the distinction between a program and process. A process was a program in memory along with dynamically-allocated storage (the heap), the stack, and the execution context, which comprises the state of the processor’s registers and <b>instruction</b> pointer (program <b>counter)</b> ...|$|R
50|$|Usually the {{addresses}} {{are generated}} by {{some combination of}} a counter, a field from a microinstruction, and some subset of the <b>instruction</b> register. A <b>counter</b> {{is used for the}} typical case, that the next microinstruction is the one to execute. A field from the microinstruction is used for jumps, or other logic.|$|R
40|$|Modern {{processors}} used in {{embedded systems}} {{are becoming increasingly}} powerful, having features like caches and pipelines to speedup execution. While execution speed of embedded software is generally increasing, it {{becomes more and more}} complex to verify the correct temporal behavior of software, running on this high-end embedded computer systems. To achieve time-predictability the authors introduced a very rigid software execution model with distribution being realized based on the time-triggered communication model. In this paper we analyze the timepredictability of a preempting task-activation, running on a hardware with direct-mapped instruction caches. As one result we analyze why a task-preemption driven by a clock interrupt is not suitable to guarantee timepredictability. As a second result, we present a timepredictable task-preemption driven by an <b>instruction</b> <b>counter.</b> ...|$|E
40|$|Abstract — With {{increasing}} power densities, raising {{operating temperatures}} in chips threaten system reliability. Thermal control therefore {{has emerged as}} an important issue in system design and management. For dynamic thermal control to be effective, predictive thermal models of the system are needed. Such models typically use power as input, which renders them difficult to use in practical systems, where power monitoring is not available at processor or chip level. In this paper, we describe a methodology to infer the thermal model based on the monitoring of existing temperature sensors and of <b>instruction</b> <b>counter</b> registers. This allows the thermal model to be easily established, calibrated, and recalibrated at runtime to account for different thermal behavior due to either variations in fabrication or to varying environmental parameters. We validate the proposed methodology {{through a series of}} experiments. We also propose and validate an extension of the model and associated methodology for multicore processors. I...|$|E
40|$|This {{paper is}} based on a {{previous}} work of the first author [15] in which a mathematical model of the computer has been presented. The model deals with random access memory, such as RASP of C. C. Elgot and A. Robinson [13], however, it allows for a more realistic modeling of real computers. This new model of computers has been named by the author (Y. Nakamura, [15]) Architecture Model for Instructions (AMI). It is more developed than previous models, both in the description of hardware (e. g., the concept of the program counter, the structure of memory) {{as well as in the}} description of instructions (instruction codes, addresses). The structure of AMI over an arbitrary collection of mathematical domains N consists of: - a non-empty set of objects, - the <b>instruction</b> <b>counter,</b> - a non-empty set of objects called instruction locations, - a non-empty set of instruction codes, - an instruction code for halting, - a set of instructions that are ordered pairs with the first element being an instruction code and the second a finite sequence in which members are either objects of the AMI or elements of one of the domains included in N, - a function that assigns to every object of AMI its kind that is either an instructio...|$|E
40|$|International Telemetering Conference Proceedings / September 15 - 17, 1969 / Sheraton Park Hotel, Washington, D. C. A Flexible Format Generator is {{described}} {{for use in}} a Manned Spacecraft Data Management System. The design uses a memory for storing and controlling a wide variety of sampling formats. Design techniques and their benefits are discussed. Particular emphasis is placed upon functional organization. Techniques are described for combining truncated relative addresses with Mode Codes and Programming <b>Instructions.</b> Software <b>counters</b> are stressed and close attention is given to Power Strobing. These techniques should find application {{in a wide variety of}} data management systems...|$|R
50|$|The cardstock tile set {{included}} in this accessory fits together like dominoes to map out a dungeon, with cardboard furniture <b>counters.</b> <b>Instructions</b> are included, and the set is also suitable for use with AD&D. The set includes both the cutouts needed to accurately layout the small tower, the enemies the group encounters, and the pre-generated characters for the players.|$|R
40|$|SIAM J. on Computing, 14 (1985), 34 - 40]. This is a {{companion}} paper to "P. M. B. Vitanyi, An optimal simulation of counter machines, SIAM Journal on Computing, 14 (1985), 1 - 33, and the later "J. Seiferas and P. M. B. Vitanyi, Counting is easy, J. Assoc. Comp. Mach. 35 (1988), pp. 985 - 1000 "]. An Augmented Counter Machine (ACM) is a multicounter machine, with initially nonzero counters allowed, and the additional one-step <b>instruction</b> "set <b>counter</b> i {{to the value}} of counter j", for any pair of counters i and j. Each ACM can be real-time simulated by an oblivious one-head tape unit using the information- theoretical storage optimum...|$|R
40|$|Summary. We {{continue}} {{the work on}} mathematical modeling of hardware and software started in [17]. The main objective {{of this paper is}} the definition of a program. We start with the concept of partial product, i. e. the set of all partial functions f from I to � Ai, fulfilling i∈I the condition f. i ∈ Ai for i ∈ domf. The computation and the result of a computation are defined in usual way. A finite partial state is called autonomic if the result of a computation starting with it does not depend on the remaining memory and an AMI is called programmable if it has a non empty autonomic partial finite state. We prove the consistency of the following set of properties of an AMI: data-oriented, halting, steadyprogrammed, realistic and programmable. For this purpose we define a trivial AMI. It has only the <b>instruction</b> <b>counter</b> and one instruction location. The only instruction of it is the halt instruction. A preprogram is a finite partial state that halts. We conclude with the definition of a program of a partial function F mapping the set of the finite partial states into itself. It is a finite partial state s such that for every finite partial state s ′ ∈ domF the result of any computation starting with s+s ′ includes F. s ′...|$|E
40|$|This {{material}} {{is presented to}} ensure timely dissemination of scholarly and technical work. Copyright and all rights therein are retained by authors or by other copyright holders. All persons copying this information are expected {{to adhere to the}} terms and constraints invoked by each author's copyright. In most cases, these works may not be reposted without the explicit permission of the copyright holder. " ???Copyright IEEE. Personal use of this {{material is}} permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. ???Modern processors used in embedded systems are becoming increasingly powerful, having features like caches and pipelines to speedup execution. While execution speed of embedded software is generally increasing, it becomes more and more complex to verify the correct temporal behavior of software, running on this high-end embedded computer systems. To achieve time-predictability the authors introduced a very rigid software execution model with distribution being realized based on the time-triggered communication model. In this paper we analyze the time-predictability of a preempting task-activation, running on a hardware with direct-mapped instruction caches. As one result we analyze why a task-preemption driven by a clock interrupt is not suitable to guarantee time-predictability. As a second result, we present a time-predictable task-preemption driven by an <b>instruction</b> <b>counter...</b>|$|E
40|$|The multicluster {{architecture}} that we introduce offers a decentralized, dynamically-scheduled architecture, {{in which the}} register files, dispatch queue, and functional units of the architecture are distributed across multiple clusters, and each cluster is assigned {{a subset of the}} architectural registers. The motivation for the multicluster architecture is to reduce the clock cycle time, relative to a single-cluster architecture with the same number of hardware resources, by reducing the size and complexity of components on critical timing paths. Resource partitioning, however, introduces instruction-execution overhead and may reduce the number of concurrently executing <b>instructions.</b> To <b>counter</b> these two negative by-products of partitioning, we developed a static instruction scheduling algorithm. We describe this algorithm, and using tracedriven simulations of SPEC 92 benchmarks, evaluate its effectiveness. This evaluation indicates that for the configurations considered, the multicluste [...] ...|$|R
50|$|The POWER5 is {{a further}} {{development}} of the POWER4. The addition of two-way multithreading required the duplication of the return stack, program <b>counter,</b> <b>instruction</b> buffer, group completion unit and store queue so that each thread may have its own. Most resources, such as the register files and execution units, are shared, although each thread sees {{its own set of}} registers. The POWER5 implements simultaneous multithreading (SMT), where two threads are executed simultaneously. The POWER5 can disable SMT to optimize for the current workload.|$|R
5|$|Each 32-bit word of RAM could contain {{either a}} program {{instruction}} or data. In a program instruction, bits 0–12 represented the memory {{address of the}} operand to be used, and bits 13–15 specified the operation to be executed, such as storing a number in memory; the remaining 16bits were unused. The SSEM's single operand architecture meant that the second operand of any operation was implicit: the accumulator or the program <b>counter</b> (<b>instruction</b> address); program instructions specified only {{the address of the}} data in memory.|$|R
5000|$|Two special {{board games}} {{based on the}} {{franchise}} were released in the 1980s, but as so-called [...] "Coterie" [...] games, which are preordered editions and only go on limited sale at Japan's Game Market trade show. With mechanics based off the GDW board game Imperium, the Area 88 in Desert War and Peace in the Aslan Kingdom have the game <b>counters,</b> <b>instructions</b> and battle map (a fictional representation of the Sinai Peninsula) printed in standard bond paper, with players left to cut up the counters and attach them and the map in cardstock.|$|R
