4|2|Public
40|$|Computing {{models for}} {{functional}} language programs not only facilitate automatic exploitation of inherent parallelism, {{but they also}} provide for implicit tolerance to hardware faults through temporal and spatial redundancy. In this paper, we argue that faulttolerance can be achieved more efficiently by using intensional computing models (eduction) rather than extensional computing models (reduction). While intensional computing models can be implemented by using either data-driven execution or <b>demand-driven</b> <b>execution,</b> we show that the latter is naturally suited...|$|E
40|$|Intensional {{programming}} implies declarative programming, in {{the sense}} of Lucid, based on denotational semantics where the declarations are evaluated in an inherent multi-dimensional context space. The General Intensional Programming System (GIPSY) is a hybrid multi-language programming platform and a <b>demand-driven</b> <b>execution</b> environment. GIPSY aims at the long-term investigation into the possibilities of Intensional Programming. The GIPSY's compiler, GIPC, is based on the notion of Generic Intensional Programming Language (GIPL) which solved the problem of language-independence of the runtime system by allowing a common representation for all compiled programs, the Generic Eduction Engine Resources (GEER). In this thesis, we discuss the solution to GIPSY's Runtime System. The Multi-Tier framework which consists of Demand Generator Tier (DGT), Demand Store Tier (DST) and Demand Worker Tier (DWT), offers demand-driven, distributed execution and technology independent manners by integrating the previous research on the demand migration middle-ware implemented by Jini and Java Message Service (JMS...|$|E
40|$|Concurrent logic {{languages}} {{have been}} traditionally executed in a "greedy" fashion, such that computations are goal-driven. In contrast, non-strict functional {{programs have been}} traditionally executed in a "dataflow" fashion, such that computations are demand-driven. The latter method can be superior when allocation of resources such as memory is critical, which is usually the case for large, complex, and/or reactive programs. Specifically, <b>demand-driven</b> <b>execution</b> results in more efficient scheduling and improved termination properties. This paper describes a novel technique for demanddriven execution of concurrent logic language programs. This paper was submitted to International Conference on Parallel Architectures and Compilation Techniques, Montreal, August 1994. Department of Computer and Information Science University of Oregon Contents 1 Introduction 1 2 Demand-Driven Evaluation 3 3 Implementation Model 6 3. 1 Objects Required by the Model : : : : : : : : : : : : : : : : : : [...] ...|$|E
40|$|Abstract. We {{discuss how}} to perform {{symbolic}} execution of large programs {{in a manner that}} is both compositional (hence more scalable) and <b>demand-driven.</b> Compositional symbolic <b>execution</b> means finding feasible interprocedural program paths by composing symbolic executions of feasible intraprocedural paths. By demand-driven, we mean that as few intraprocedural paths as possible are symbolically executed in order to form an interprocedural path leading to a specific target branch or statement of interest (like an assertion). A key originality of this work is that our demand-driven compositional interprocedural symbolic execution is performed entirely using first-order logic formulas solved with an off-the-shelf SMT (Satisfiability-Modulo-Theories) solver â€“ no procedure in-lining or custom algorithm is required for the interprocedural part. This allows a uniform and elegant way of summarizing procedures at various levels of detail and of composing those using logic formulas. This novel symbolic execution technique has been implemented for automatic test input generation in conjunction with Pex, a general automatic testing framework for. NET applications. Preliminary experimental results are enouraging. For instance, our tool was able to generate tests triggering assertion violations in programs with large numbers of program paths that were beyond the scope of non-compositional test generation. ...|$|R
40|$|Based on {{a simple}} non-procedural {{language}} with temporal logic operators, Lucid underlies a family of multi-dimensional programming languages based on intensional logic. Intension is a concept rooted in an aspect of natural language called "intensional context", in which {{the meaning of a}} statement (extension) depends on the context in which it is uttered (intension). The implicit temporal feature of Lucid makes it suitable for use as a means of describing dynamic systems. In the past, experiments have been performed and real applications have been developed with programs written in Lucid. However, these systems focused mainly on improving the execution performance of one dialect of Lucid and not address the problem of interpreting variants of Lucid. The GIPSY system is designed to not only process current Lucid variants efficiently but also to be modified easily to accept new dialects of Lucid. In the thesis, we discuss the essence of executing intensional programming languages using the eduction (also called <b>demand-driven</b> or lazy) <b>execution</b> model; describe experiments with different approaches to interpreting programs written in Lucid; and focuses on execution over a network of processors. We describe the implementation of a prototype for executing Lucid programs in a distributed environment. We also explore the advantages of applying the object concept to distributed systems and describe experiments with these methods. In addition, the thesis includes estimates of the impact of integrating computation functions into the Lucid code and proposes an advanced execution model consisting of self-contained and intelligent clients associated with a meta-level resource management...|$|R
40|$|Eduction often {{unnecessarily}} constrains evaluation {{speed to}} avoid any superfluous evaluation. We describe two simple {{ways in which the}} eduction model can be speeded up, through anticipatory and speculative evaluation, both of which avoid unbounded superfluous evaluation. We consider the effects of these extensions on a shared-memory multiprocessor implementation of GLU using idealized programs. 1 Introduction Eduction is a lazy intensional computing model for evaluating Lucid programs [1, 2]. It is lazy because output values are only produced when they are needed and it is intensional because the individual output values can be produced over time and not necessarily in order. Eduction has been the basis of all known implementations of various incarnations of Lucid (such as pLucid, fLucid, and indexical Lucid) as well as GLU, a hybrid of the latest Lucid and C[3, 2]. Eduction is usually implemented using tagged <b>demand-driven</b> <b>execution</b> and the two are used interchangeably. Demand f [...] ...|$|E

