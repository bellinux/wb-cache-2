76|764|Public
5000|$|... #Caption: The <b>game</b> <b>graph</b> {{of level}} 7 shows the {{relatedness}} to the Sierpiński triangle.|$|E
5000|$|Graphical {{games are}} {{games in which}} the {{utilities}} of each player depends on the actions of very few other players. If [...] is {{the greatest number of}} players by whose actions any single player is affected (that is, it is the indegree of the <b>game</b> <b>graph),</b> the number of utility values needed to describe the game is , which, for a small [...] is a considerable improvement.|$|E
5000|$|Below is a {{table of}} some known {{complexity}} results for finding certain classes of equilibria in several game representations. [...] "NE" [...] stands for [...] "Nash equilibrium", and [...] "CE" [...] for [...] "correlated equilibrium". n {{is the number of}} players and s is the number of strategies each player faces (we're assuming all players face the same number of strategies). In graphical games, d is the maximum indegree of the <b>game</b> <b>graph.</b> For references, see main article text.|$|E
40|$|Winning Strategies of graph-interpretable games can be {{obtained}} by using 2 ̆ 2 Kernels 2 ̆ 2 of underlying graphs. S. A. Dunning has considered canonical forms of given <b>game</b> <b>graphs</b> which are full subgraphs of the 2 ̆ 2 universal game 2 ̆ 2. This gives light to the theoretical approach to games. This paper presents a common algorithm for <b>game</b> <b>graphs...</b>|$|R
40|$|We {{study the}} logical definablity {{of the winning}} regions of parity games. For games with a bounded number of priorities, it is wellknown that the winning regions are definable in the modal µ-calculus. Here we {{investigate}} {{the case of an}} unbounded number of priorities, both for finite <b>game</b> <b>graphs</b> and for arbitrary ones. In the general case, winning regions are definable in guarded second-order logic (GSO), but not in least-fixed point logic (LFP). On finite <b>game</b> <b>graphs,</b> winning regions are LFP-definable if, and only if, they are computable in polynomial time, and this result extends to any class of finite games that is closed under taking bisimulation quotients...|$|R
40|$|The {{computation}} of {{the winning}} set for parity objectives and for Streett objectives in graphs {{as well as in}} <b>game</b> <b>graphs</b> are central problems in computer-aided verification, with application to the verification of closed systems with strong fairness conditions, the verification of open systems, checking interface compatibility, well-formedness of specifications, and the synthesis of reactive systems. We show how to compute the winning set on n vertices for (1) parity- 3 (aka one-pair Streett) objectives in <b>game</b> <b>graphs</b> in time O(n^ 5 / 2) and for (2) k-pair Streett objectives in graphs in time O(n^ 2 + nk n). For both problems this gives faster algorithms for dense graphs and represents the first improvement in asymptotic running time in 15 years...|$|R
40|$|Abstract. Dao {{appears to}} be an {{attractive}} game to play, although it is solvable in a few seconds on a computer. The game is small enough to keep the complete <b>game</b> <b>graph</b> in internal memory. At the same time, the number of nodes in the <b>game</b> <b>graph</b> of Dao is large enough to allow interesting analyses. In the game spectrum of solved games, as given in Jaap’s seminal overview [5], Dao resides between on the one hand trivial games such as Tic-Tac-Toe {{and on the other hand}} solved games such as Connect-Four and Awari of which the <b>game</b> <b>graph</b> cannot be kept completely in memory. The availability of the Dao <b>game</b> <b>graph</b> allows for new research opportunities. Earlier [2] we used Dao to investigate the use of transposition tables in search. In the current paper we attempt to learn from the <b>game</b> <b>graph</b> why this relatively simple game is an entertaining game for human players — conforming the intuition of its designers [3]. ...|$|E
40|$|Abstract. We {{deal with}} the problem of {{reducing}} the memory necessary for implementing winning strategies in infinite games. We present an algorithm that is based on the notion of game reduction. The key idea of a game reduction is to reduce the problem of computing a solution for a given game to the problem of computing a solution for a new game which has an extended <b>game</b> <b>graph</b> but a simpler winning condition. The new <b>game</b> <b>graph</b> contains the memory to solve the original game. Our algorithm computes an equivalence relation on the vertices of the extended <b>game</b> <b>graph</b> and from that deduces equivalent memory contents. We apply our algorithm to Request-Response and Staiger-Wagner games where in both cases we obtain a running time polynomial {{in the size of the}} extended <b>game</b> <b>graph.</b> We compare our method to the technique of minimising strategy automata and present an example for which our approach yields a substantially better result. ...|$|E
40|$|We {{present an}} O(mn 2 ^n log Z) {{deterministic}} algorithm for solving the mean payoff game problem, m and n being respectively {{the number of}} arcs and vertices in the <b>game</b> <b>graph</b> and Z being the maximum weight (we assume that the weights are integer numbers). The theoretical basis for the algorithm is the potential theory for mean payoff games. This theory allows to restate the problem in terms of solving systems of algebraic equations with minima and maxima. Also we use arc reweighting technique to solve the mean payoff game problem by applying simple modifications to the <b>game</b> <b>graph</b> that do not change the set of winning strategies, obtaining at the end a trivial instance of the problem. We show that any <b>game</b> <b>graph</b> can be simplified by n reweightings...|$|E
25|$|A {{large form}} of digital art, pixel art is created {{through the use}} of raster {{graphics}} software, where images are edited on the pixel level. Graphics in most old (or relatively limited) computer and video <b>games,</b> <b>graphing</b> calculator <b>games,</b> and many mobile phone games are mostly pixel art.|$|R
40|$|We {{describe}} a parallel model-checking algorithm for the fragment of the µ-calculus that allows one alternation of minimal and maximal fixed-point operators. This fragment {{is also known}} as L 2 µ. Since LTL and CTL ∗ can be encoded in this fragment, we obtain parallel model checking algorithms for practically important temporal logics. Our solution is based on a characterization of this problem in terms of twoplayer games. We exhibit the structure of their <b>game</b> <b>graphs</b> and show that we can iteratively work with <b>game</b> <b>graphs</b> that have the same special structure as the ones obtained for L 1 µ-formulae. Since good parallel algorithms for colouring game-graphs for L 1 µ-formulae exist, it is straightforward to implement this algorithm in parallel and good run-time results can be expected. ...|$|R
40|$|We {{study the}} {{descriptive}} complexity of parity games by {{taking into account}} the coloring of their <b>game</b> <b>graphs</b> whilst ignoring their ownership structure. Colored <b>game</b> <b>graphs</b> are identified if they determine the same winning regions and strategies, for *all* ownership structures of nodes. The Rabin index of a parity game is the minimum of the maximal color taken over all equivalent coloring functions. We show that deciding whether the Rabin index is at least k is in PTIME for k= 1 but NP-hard for all *fixed* k > 1. We present an EXPTIME algorithm that computes the Rabin index by simplifying its input coloring function. When replacing simple cycle with cycle detection in that algorithm, its output over-approximates the Rabin index in polynomial time. Experimental results show that this approximation yields good values in practice...|$|R
40|$|We {{discuss the}} {{computational}} complexity of solving parity {{games in the}} special case when the underlying <b>game</b> <b>graph</b> is undirected. For strictly alternating games, that is, when the <b>game</b> <b>graph</b> is bipartite between the nodes of the two players, we show that the games can be solved in linear time. However, when strict alternation is not imposed, we show that computing a solution is as hard in the undirected case {{as it is in}} the general, directed, case...|$|E
40|$|International audienceWe {{examine the}} {{complexity}} of solving parity games in the special case when the underlying <b>game</b> <b>graph</b> is undirected. For strictly alternating games, that is, when the <b>game</b> <b>graph</b> is bipartite between the nodes of the two players, we observe that the solution can be computed in linear time. In contrast, when the assumption of strict alternation is dropped, we show {{that the problem is}} as hard in the undirected case {{as it is in the}} general, directed, case...|$|E
40|$|In {{the formal}} {{approach}} to reactive controller synthesis, a symbolic controller for a possibly hybrid system is obtained by algorithmically computing a winning strategy in a two-player game. Such game-solving algorithms scale poorly as {{the size of}} the <b>game</b> <b>graph</b> increases. However, in many applications, the <b>game</b> <b>graph</b> has a natural hierarchical structure. In this paper, we propose a modeling formalism and a synthesis algorithm that exploits this hierarchical structure for more scalable synthesis. We define local games on hierarchical graphs as a modeling formalism which decomposes a large-scale reactive synthesis problem in two dimensions. First, the construction of a hierarchical <b>game</b> <b>graph</b> introduces abstraction layers, where each layer is again a two-player <b>game</b> <b>graph.</b> Second, every such layer is decomposed into multiple local game graphs, each corresponding to a node in the higher level <b>game</b> <b>graph.</b> While local games have the potential to reduce the state space for controller synthesis, they lead to more complex synthesis problems where strategies computed for one local game can impose additional requirements on lower-level local games. Our second contribution is a procedure to construct a dynamic controller for local game graphs over hierarchies. The controller computes assume-admissible winning strategies that satisfy local specifications in the presence of environment assumptions, and dynamically updates specifications and strategies due to interactions between games at different abstraction layers at each step of the play. We show that our synthesis procedure is sound: the controller constructs a play which satisfies all local specifications. We illustrate our results through an example controlling an autonomous robot in a known, multistory building...|$|E
40|$|Herings et al. (2008) {{proposed}} a solution concept called the average tree solution for cycle-free <b>graph</b> <b>games.</b> We provide a {{characterization of the}} average tree solution for cycle-free <b>graph</b> <b>games.</b> The characteration underlines an important difference, in terms of symmetric treatment of agents, between the average tree solution and the Myerson value (Myerson, 1977) for cycle-free <b>graph</b> <b>games.</b> ...|$|R
40|$|In Proceedings GandALF 2013, arXiv: 1307. 4162 We {{study the}} {{descriptive}} complexity of parity games by {{taking into account}} the coloring of their <b>game</b> <b>graphs</b> whilst ignoring their ownership structure. Colored <b>game</b> <b>graphs</b> are identified if they determine the same winning regions and strategies, for all ownership structures of nodes. The Rabin index of a parity game is the minimum of the maximal color taken over all equivalent coloring functions. We show that deciding whether the Rabin index is at least k is in PTIME for k= 1 but NP-hard for all fixed k > 1. We present an EXPTIME algorithm that computes the Rabin index by simplifying its input coloring function. When replacing simple cycle with cycle detection in that algorithm, its output over-approximates the Rabin index in polynomial time. Experimental results show that this approximation yields good values in practice. Peer-reviewedPublisher Versio...|$|R
40|$|This paper {{considers}} cooperative transferable utility <b>games</b> with <b>graph</b> structure,called <b>graph</b> <b>games.</b> A <b>graph</b> structure {{restricts the}} set of possible coalitions of players, so thatplayers are able to cooperate {{only if they are}} connected in the graph. Recently the average treesolution has been proposed for arbitrary <b>graph</b> <b>games</b> by Herings et al. The average tree solutionis the average of some specific marginal contribution vectors, and was shown to belong to the coreif the game exhibits link-convexity. In this paper the main focus is placed on the relationshipbetween the core and the average tree solution, and the following results were obtained. Firstly,it was shown that some marginal contribution vectors do not belong to the core even though thegame is link-convex. Secondly, an alternative condition to link-convexity was given. Thirdly, itwas proven that for cycle-complete <b>graph</b> <b>games</b> the average tree solution is an element of thecore if the game is link-convex...|$|R
40|$|The {{solution}} of games {{is a key}} decision problem {{in the context of}} verification of open systems and program synthesis. Given a <b>game</b> <b>graph</b> and a specification, we wish to determine if there exists a strategy of the protagonist that allows to select only behaviors fulfilling the specification. In this paper, we consider timed games, where the <b>game</b> <b>graph</b> is a timed automaton and the specification is given by formulas of the temporal logics Ltl and Ctl. We present an automata-theoretic approach to solve the addressed games, extending to the timed framework a successful approach to solve discrete games. The main idea of this approach is to translate the timed automaton A, modeling the <b>game</b> <b>graph,</b> into a tree automaton AT accepting all trees that correspond to a strategy of the protagonist. Then, given an automaton corresponding to the specification, we intersect it with the tree automaton AT and check for the nonemptiness of the resulting automaton. Our approach yields a decision algorithm running in exponential time for Ctl and in double exponential time for Ltl. The obtained algorithms are optimal in the sense that their computational complexity matches the known lower bounds...|$|E
40|$|Communicated by (xxxxxxxxxx) The {{problem of}} solving a parity game {{is at the}} core of many {{problems}} in model checking, satisfiability checking and programsynthesis. Some ofthe bestalgorithms forsolving parity game are strategy iteration algorithms. These are global in nature since they require the entire parity game to be present at the beginning. This is a distinct disadvantage because in many applications one only needs to know which winning region a particular node belongs to, and a witnessing winning strategy may cover only a fractional part of the entire <b>game</b> <b>graph.</b> We present two local strategy iteration algorithms which explore the <b>game</b> <b>graph</b> onthe-fly whilstperforming the improvement steps. We also compare them empirically with existing global strategy iteration algorithms and the currently only other local algorithm for solving parity games. It turns out that local strategy iteration can outperform these others significantly...|$|E
40|$|The {{problem of}} solving a parity game {{is at the}} core of many {{problems}} in model checking, satisfiability checking and program synthesis. Some of the best algorithms for solving parity game are strategy improvement algorithms. These are global in nature since they require the entire parity game to be present at the beginning. This is a distinct disadvantage because in many applications one only needs to know which winning region a particular node belongs to, and a witnessing winning strategy may cover only a fractional part of the entire <b>game</b> <b>graph.</b> We present a local strategy improvement algorithm which explores the <b>game</b> <b>graph</b> on-the-fly whilst performing the improvement steps. We also compare it empirically with existing global strategy improvement algorithms and the currently only other local algorithm for solving parity games. It turns out that local strategy improvement can outperform these others by several orders of magnitude. ...|$|E
3000|$|According to coalitional <b>graph</b> <b>game</b> {{theory and}} the concept of local Nash {{equilibrium}} for the coalitional <b>graph</b> <b>game,</b> the stability of the final strategy vector x [...]...|$|R
30|$|Saad et al. in a {{tutorial}} paper [5] classify coalitional {{games into}} three categories: canonical (coalitional) games, coalition formation <b>games,</b> and coalitional <b>graph</b> <b>games.</b> In canonical games, no group of players can do worse by joining a coalition than by acting non-cooperatively. In coalition formation games, forming a coalition brings advantage to its members, but the gains {{are limited by}} a cost for forming the coalition. In coalitional <b>graph</b> <b>games,</b> the coalitional <b>game</b> is in <b>graph</b> form, and the interconnection between the players strongly affects the characteristics {{as well as the}} outcome of the game.|$|R
40|$|We study two-player {{games of}} {{infinite}} duration that are played on finite or infinite <b>game</b> <b>graphs.</b> A winning strategy {{for such a}} game is positional if it only depends on the current position, {{and not on the}} history of the play. A game is positionally determined if, from each position, one of the two players has a positional winning strategy. The theor...|$|R
40|$|In {{this paper}} we provide ecient {{algorithms}} for {{two classes of}} MC games. For tree-like MC games, where a <b>game</b> <b>graph</b> doesn't have any other cycles than self-loops, we can use a dfs-based algorithm to nd the winner in O(E) time. For cycle-connected MC games, where all cycles in each strongly connected component of the <b>game</b> <b>graph</b> {{have at least one}} common vertex, we can nd the winner in polynomial time. The class of tree-like MC games is a subclass of cycle-connected MC games. The class of cycle-connected MC games are equivalent to a subclass of model checking games G(E;), where E is nite state process and is an alternation free formula. It is known in the literature that model checking for alternation-free mu-calculus can be done in linear time. It follows that cycle-connected MC games are solvable in polynomial time, but no explicit algorithms are given in the literature for MC games. Our treatment is based on standard graph-theoretical concepts, rather than the conce [...] ...|$|E
40|$|Abstract. We {{show that}} an optimal counterstrategy against a fixed {{positional}} strategy in a generalized discounted payoff game, where edges have individual discounts, can be computed in O(mn 2 log m) strongly polynomial time, where n and m are {{the number of}} vertices and edges in the <b>game</b> <b>graph.</b> This results in the best known strongly subexponential time bound for solving two-player generalized discounted payoff games. ...|$|E
40|$|We {{extend the}} {{definition}} of the score of a game tree using the minimax rule to game graphs containing cycles. This is accomplished by taking the limit of a sequence of scores of game trees that in some sense approximate the <b>game</b> <b>graph.</b> We show that this score is well-defined for all game graphs, and give algorithms for its evaluation, including one that uses memoization...|$|E
40|$|AbstractWe {{study the}} {{descriptive}} complexity of parity games by {{taking into account}} the coloring of their <b>game</b> <b>graphs</b> whilst ignoring their ownership structure. Colorings of <b>game</b> <b>graphs</b> are identified if they determine the same winning regions and strategies, for all ownership structures of nodes. The Rabin index of a parity game is the minimum of the maximal color taken over all equivalent coloring functions. We show that deciding whether the Rabin index is at least k is in P for k= 1 but NP-hard for all fixed k≥ 2. We present an EXPTIME algorithm that computes the Rabin index by simplifying its input coloring function. When replacing simple cycle with cycle detection in that algorithm, its output over-approximates the Rabin index in polynomial time. We evaluate this efficient algorithm as a preprocessor of solvers in detailed experiments: for Zielonka's solver on random and structured parity games and for our partial solver psolB on random games...|$|R
40|$|In this paper, we give a {{complete}} description of strongly regular graphs with parameters ((n^ 2 + 3 n- 1) ^ 2,n^ 2 (n+ 3), 1,n(n+ 1)). All possible such graphs are: the lattice graph $L_{ 3, 3 }$ with parameters (9, 4, 1, 2), the Brouwer-Haemers graph with parameters (81, 20, 1, 6), and the <b>Games</b> <b>graph</b> with parameters (729, 112, 1, 20). Comment: 17 page...|$|R
40|$|There {{are many}} {{interesting}} <b>games</b> on <b>graphs</b> [?]. This paper describes a new game which incorporates a new idea. In traditional <b>games</b> on <b>graphs,</b> the two players alternately choose edges {{such that the}} rst player wants to attain a property and the second player wants to attain a similar property. For example in Sim [?], the two players alternately color an edge (in a complet...|$|R
40|$|We {{present a}} method for mending {{strategies}} for GR(1) specifications. Given the addition or removal of edges from the <b>game</b> <b>graph</b> describing a problem (essentially transition rules in a GR(1) specification), we apply a µ-calculus formula to a neighborhood of states to obtain a “local strategy” that navigates around the invalidated parts of an original synthesized strategy. Our method may thus avoid global resynthesis while recovering correctness {{with respect to the}} new specification. We illustrate the results both in simulation and on physical hardware for a planar robot surveillance task...|$|E
40|$|Abstract. In {{this paper}} {{we present a}} new {{symbolic}} algorithm for the classification, i. e. the calculation of the rewards for both players in case of optimal play, of two-player games with general rewards according to the Game Description Language. We will show that it classifies all states using a linear number of images concerning {{the depth of the}} <b>game</b> <b>graph.</b> We also present an extension that uses this algorithm to create symbolic endgame databases and then performs UCT to find an estimate for the classification of the game. ...|$|E
40|$|The {{values of}} a two-player zero-sum binary {{discounted}} game are characterized by a P-matrix linear complementarity problem (LCP). Simple formulas are given to describe the data of the LCP {{in terms of the}} <b>game</b> <b>graph,</b> discount factor, and rewards. Hence it is shown that the unique sink orientation (USO) associated with this LCP coincides with the strategy valuation USO associated with the discounted game. As an application of this fact, it is shown that Murty's least-index method for P-matrix LCPs corresponds to both known and new variants of strategy improvement algorithms for discounted games. ...|$|E
40|$|In {{evolutionary}} game theory, the Prisoner’s Dilemma is a well-studied {{model for}} a diverse range of real-life situations. The Hawk-Dove game {{is closely related to}} the Prisoner’s Dilemma, but has received much less attention. In this thesis the Hawk-Dove <b>game</b> on <b>graphs</b> is explored, as based on a study by Hauert & Doebeli (2004). The experimental part of this thesis consists of a program written in c++ for modeling the Hawk- Dove <b>game</b> on <b>graphs,</b> reproducing Hauert & Doebeli’s results, as well as extending the scope of research to different graphs, update rules, and payoffs. This part is preceded by the necessary theoretical background in game theory, evolutionary <b>game</b> theory, <b>graph</b> theory and the Prisoner’s Dilemma and Hawk-Dove game...|$|R
40|$|Abstract. Reasoning on the {{properties}} of computer systems can often be reduced to deciding the winner of a game played on a finite graph. In this paper, we introduce GAVS, an open-source tool for the visualization {{of some of the}} most fundamental <b>games</b> on finite <b>graphs</b> used in theo-retical computer science, including, e. g., reachability games and parity games. The main purpose of GAVS is educational, a fact which is em-phasized by the graphical editor for both defining <b>game</b> <b>graphs</b> and also visualizing the computation of the winning sets. Nevertheless, the un-derlying solvers are implemented with scalability in mind using symbolic techniques where applicable. ...|$|R
40|$|We {{consider}} both finite-state <b>game</b> <b>graphs</b> and recursive <b>game</b> <b>graphs</b> (or pushdown <b>game</b> <b>graphs),</b> {{that can}} model the control flow of sequential programs with recursion, with multi-dimensional mean-payoff objectives. In pushdown games {{two types of}} strategies are relevant: global strategies, that depend on the entire global history; and modular strategies, that have only local memory and thus do {{not depend on the}} context of invocation. We present solutions to several fundamental algorithmic questions and our main contributions are as follows: (1) We show that finite-state multi-dimensional mean-payoff games can be solved in polynomial time if the number of dimensions and the maximal absolute value of the weight is fixed; whereas if the number of dimensions is arbitrary, then problem is already known to be coNP-complete. (2) We show that pushdown graphs with multi-dimensional mean-payoff objectives can be solved in polynomial time. (3) For pushdown games under global strategies both single and multi-dimensional mean-payoff objectives problems are known to be undecidable, and we show that under modular strategies the multi-dimensional problem is also undecidable (whereas under modular strategies the single dimensional problem is NP-complete). We show that if the number of modules, the number of exits, and the maximal absolute value of the weight is fixed, then pushdown games under modular strategies with single dimensional mean-payoff objectives can be solved in polynomial time, and if either of the number of exits or the number of modules is not bounded, then the problem is NP-hard. (4) Finally we show that a fixed parameter tractable algorithm for finite-state multi-dimensional mean-payoff games or pushdown games under modular strategies with single-dimensional mean-payoff objectives would imply the solution of the long-standing open problem of fixed parameter tractability of parity games. Comment: arXiv admin note: text overlap with arXiv: 1201. 282...|$|R
