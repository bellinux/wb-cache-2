8|64|Public
40|$|Real-time {{collaborative}} editing {{systems are}} distributed groupware systems that allow multiple users to edit the same document {{at the same}} t ime from multiple sites. A specific type of collaborative editing system is the object-based collaborative graphics editing system. f i a-ditionally, locking has been used as the major concur-rency control techniques in this type of system. This paper examines locking i n a supporting role to the con-currency control technique of multi-versioning. Two types of locks are examined: object and region. Two optional and responsive locking schemes, instant lock-ing and instant <b>exclusive</b> <b>locking,</b> are presented. Their advantages and disadvantages are discussed. ...|$|E
40|$|Abstract: Since the {{convergence}} of transactional Web Services and workflow management, human interaction can be a determining factor {{for the length of}} a distributed business-to-business transaction. Such transactions of unknown duration (e. g. due to human interaction) can be modeled properly neither as a short-running WS-AtomicTransaction nor as a long-running WS-BusinessActivity. Our proposal is to add the concept of ready-to-commit timeouts to the <b>exclusive</b> <b>locking</b> model of the WS-AtomicTransaction protocol by making a few minor extensions. The result is a simple and straightforward implementation strategy for transactions with unknown duration based on the Web Services Transaction Framework. ...|$|E
40|$|We give a clear yet {{rigorous}} correctness proof for Moss's algorithm {{for managing}} {{data in a}} nested transaction system. The algorithm, which {{is the basis of}} concurrency control and recovery in the Argus system, uses read- and write-locks and a stack of versions of each object to ensure the serializability and recoverability of transactions accessing the data. Our proof extends earlier work on <b>exclusive</b> <b>locking</b> to prove that Moss's algorithm generates serially correct executions in the presence of concurrency and transaction aborts. The key contribution is the identification of a simple property of cead operations, called transparency, that permits shared locks to be used for read operations...|$|E
50|$|Lock {{upgrades}} and downgrades {{release the}} old lock before applying the new lock. If an application downgrades an <b>exclusive</b> <b>lock</b> to a shared lock while another application is blocked {{waiting for an}} <b>exclusive</b> <b>lock,</b> the latter application may get the <b>exclusive</b> <b>lock</b> and lock the first application out. This means that lock downgrades can block, which may be counterintuitive.|$|R
5000|$|Two {{kinds of}} locks are offered: shared <b>locks</b> and <b>exclusive</b> <b>locks.</b> In {{the case of}} , {{different}} kinds of locks may be applied to different sections (byte ranges) of a file, or else to the whole file. Shared locks can be held by multiple processes at the same time, but an <b>exclusive</b> <b>lock</b> can only be held by one process, and cannot coexist with a shared lock. To acquire a shared lock, a process must wait until no processes hold any <b>exclusive</b> <b>locks.</b> To acquire an <b>exclusive</b> <b>lock,</b> a process must wait until no processes hold either kind of lock. Unlike locks created by , those created by [...] are preserved across s, making them useful in forking servers. It is therefore possible {{for more than one}} process to hold an <b>exclusive</b> <b>lock</b> on the same file, provided these processes share a filial relationship and the <b>exclusive</b> <b>lock</b> was initially created in a single process before being duplicated across a [...]|$|R
50|$|If lock {{requests}} {{for the same}} entity are queued, then once a shared lock is granted, any queued shared locks may also be granted. If an <b>exclusive</b> <b>lock</b> is found next on the queue, it must wait until all shared locks have been released. As with <b>exclusive</b> <b>locks,</b> these shared locks should be held for the least time possible.|$|R
40|$|Concurrency control {{algorithms}} {{that are}} used in a real-time database must satisfy the timing requirements of the transactions as well as maintain the consistency of the data. Concurrency control techniques vary in the amount of concurrency they allow in a system. As more concurrency is allowed, {{it is more likely that}} transactions will meet their timing constraints. In lock-based concurrency control techniques, the problem of deadlock must be addressed. Additionally, if these techniques are used in a real-time system, the problem of priority inversion must be addressed. The priority ceiling protocols prevent deadlock and bound priority inversion in a realtime system. The original protocol was designed to be used with <b>exclusive</b> <b>locking.</b> The read/write priority ceiling protocol was developed later to allow more concurrency in realtime databases that use read/write locking. Since neither protocol uses the semantics of objects, they are not appropriate for use with semantic concurrency con [...] ...|$|E
40|$|Networked {{computer}} systems offer much to support collaborative editing of shared documents among users. Increasing concurrent access to shared documents by allowing multiple users {{to contribute to}} and/or track changes to these shared documents {{is the goal of}} real-time collaborative editing systems (RTCES); yet concurrent access is either limited in existing systems that employ <b>exclusive</b> <b>locking</b> or concurrency control algorithms such as operational transformation (OT) may be employed to enable concurrent access. Unfortunately, such OT based schemes are costly with respect to communication and computation. Further, existing systems are often specialized in their functionality and require users to adopt new, unfamiliar software to enable collaboration. This research discusses our work in improving consistency management in RTCES. We have developed a set of deadlock-free multi-granular dynamic locking algorithms and data structures that maximize concurrent access to shared documents while minimizing communication cost. These algorithms provide a high level of service for concurrent access to the shared document and integrate merge-based or OT-base...|$|E
40|$|Search {{trees with}} relaxed balance were {{introduced}} {{with the aim}} of facilitating fast updating on shared-memory asynchronous parallel architectures. To obtain this, rebalancing has been uncoupled from the updating, so extensive locking in connection with updates is avoided. Rebalancing is taken care of by background processes, which do only a constant amount of work at a time before they release locks. Thus, the rebalancing and the associated locks are very localized in time as well as in space. In particular, there is no <b>exclusive</b> <b>locking</b> of whole paths. This means that the amount of parallelism possible is not limited by the height of the tree. Search trees with relaxed balance have been obtained by adapting standard sequential search trees to this new paradigm; clearly using similar techniques in each case, but no general result has been obtained. Recent developments in the area, however, have prepared the way for the present paper, where we demonstrate that any search tree with local [...] ...|$|E
50|$|In {{addition}} to shared (S) <b>locks</b> and <b>exclusive</b> (X) <b>locks</b> from other locking schemes, like strict two-phase locking, MGL also uses intention shared and intention <b>exclusive</b> <b>locks.</b> IS locks conflict with X locks, while IX locks conflict with S and X locks. The null lock (NL) {{is compatible with}} everything.|$|R
5000|$|... put {{a lock on}} a resource. WebDAV {{supports}} both {{shared and}} <b>exclusive</b> <b>locks.</b>|$|R
50|$|Shared <b>locks</b> {{differ from}} <b>exclusive</b> <b>locks</b> {{in that the}} holder list can contain {{multiple}} entries. Shared locks allow all holders to read {{the contents of the}} record knowing that the record cannot be changed until after the lock has been released by all holders. <b>Exclusive</b> <b>locks</b> cannot be obtained when a record is already locked (exclusively or shared) by another entity.|$|R
40|$|Networked {{computer}} systems offer much to support collaborative editing of shared documents among users. Increasing concurrent access to shared documents by allowing multiple users {{to contribute to}} and/or track changes to these shared documents {{is the goal of}} real-time collaborative editing systems (RTCES); yet concurrent access is either limited in existing systems that employ <b>exclusive</b> <b>locking</b> or concurrency control algorithms such as operational transformation (OT) may be employed to enable concurrent access. Unfortunately, such OT based schemes are costly with respect to communication and computation. Further, existing systems are often specialized in their functionality and require users to adopt new, unfamiliar software to enable collaboration. This research discusses our work in improving consistency management in RTCES. We have developed a set of deadlock-free multi-granular dynamic locking algorithms and data structures that maximize concurrent access to shared documents while minimizing communication cost. These algorithms provide a high level of service for concurrent access to the shared document and integrate merge-based or OT-based consistency maintenance policies locally among a subset of the users within a subsection of the document – thus reducing the communication costs in maintaining consistency. Additionally, we have developed client-server and P 2 P implementations of our hierarchical document management algorithms. Simulations results indicate that our approach achieves significant communication and computation cost savings. We have also developed a hierarchical reduction algorithm that can minimize the space required of RTCES, and this algorithm may be pipelined through our document tree. Further, we have developed an architecture that allows for a heterogeneous set of client editing software to connect with a heterogeneous set of server document repositories via Web services. This architecture supports our algorithms and does not require client or server technologies to be modified – thus it is able to accommodate existing, favored editing and repository tools. Finally, we have developed a prototype benchmark system of our architecture that is responsive to users’ actions and minimizes communication costs...|$|E
40|$|This thesis {{develops}} a mathematical framework for specifying the consistency guarantees of high performance distributed shared memory multiprocessors. This framework {{is based on}} computations, which specify the operations requested and constraints on how these operations may be applied; we call the framework computation-centric. This framework is expressive enough to specify high level synchronization mechanisms such as locks. We use the computation-centric framework to specify and compare several memory models, to characterize programming disciplines, and to prove that weakly consistent systems provide strong consistency guarantees when certain programming disciplines are obeyed. Specifically, we define computation-centric versions of several memory models from the literature, including sequential consistency, weak ordering and release consistency, and we give a computation-centric characterization of data-race-free programs. We prove that when running data-race-free programs, weakly ordered systems appear sequentially consistent. We also define memory models that have higher level guarantees such as locks and transactions. (cont.) The strongly consistent versions of these models make guarantees that are stronger than sequential consistency, and thus are easier for programmers to use. We introduce a new model called weak sequential locking, which has very weak guarantees, and prove that it guarantees sequential consistency and mutually <b>exclusive</b> <b>locking</b> for programs that protect memory accesses using locks. We also show that by using two-phase locking, programmers can implement serializable transactions on any memory system with weak sequential locking. The framework is intended primarily to help programmers of such systems reason about their programs. It supports {{a high level of}} abstraction, insulating programmers from system details and enhancing the portability of their programs. The framework is also useful for implementors of such systems, in determining what guarantees their implementations provide and in assessing the advantages of providing one memory model rather than another. by Victor Luchangco. Thesis (Sc. D.) [...] Massachusetts Institute of Technology, Dept. of Mechanical Engineering, 2001. Includes bibliographical references (p. 195 - 205) and index...|$|E
50|$|A simple {{example is}} when Process 1 has {{obtained}} an <b>exclusive</b> <b>lock</b> on Resource A, and Process 2 has obtained an <b>exclusive</b> <b>lock</b> on Resource B. If Process 1 then tries to lock Resource B, {{it will have}} to wait for Process 2 to release it. But if Process 2 then tries to lock Resource A, both processes will wait forever for each other.|$|R
50|$|Java and Ada {{only have}} <b>exclusive</b> <b>locks</b> {{because they are}} thread based and rely on the compare-and-swap {{processor}} instruction.|$|R
5000|$|Exclusive (EX). This is the {{traditional}} <b>exclusive</b> <b>lock</b> which allows read and update access to the resource, and prevents others from having any access to it.|$|R
5000|$|Write-lock (<b>exclusive</b> <b>lock)</b> is {{associated}} with a database object by a transaction (Terminology: [...] "the transaction locks the object," [...] or [...] "acquires lock for it") before writing (inserting/modifying/deleting) this object.|$|R
50|$|A {{nickname}} or server jupe {{takes advantage}} of the fact that certain identifiers are unique; by using an identifier, one acquires an <b>exclusive</b> <b>lock</b> that prevents other users from making use of it.|$|R
5000|$|In MGL, locks are set on {{objects that}} contain other objects. MGL {{exploits}} the hierarchical {{nature of the}} contains relationship. For example, a database may have files, which contain pages, which further contain records. This {{can be thought of}} as a tree of objects, where each node contains its children. A lock on such as a shared or <b>exclusive</b> <b>lock</b> locks the targeted node as well as all of its descendants.|$|R
5000|$|A {{transaction}} Ti that inserts, updates or deletes a tuple ti in {{a relation}} r must update all indices to r {{and it must}} obtain <b>exclusive</b> <b>locks</b> on all index leaf nodes affected by the insert/update/delete ...|$|R
50|$|Byte-range locking type is {{determined}} by the dwFlags parameter in the LockFileEx function used to lock a region of a file. The Windows API function LockFile can also be used and acquires an <b>exclusive</b> <b>lock</b> on the region of the file.|$|R
5000|$|More {{than one}} process can hold an {{exclusive}} [...] {{on a given}} file if the <b>exclusive</b> <b>lock</b> was duplicated across a later [...] This simplifies coding for network servers and helps prevent race conditions, but can be confusing to the unaware.|$|R
50|$|A lock value {{block is}} {{associated}} with each resource. This can be read by any process that has obtained a lock on the resource (other than a null lock) and can be updated by a process that has obtained a protected update or <b>exclusive</b> <b>lock</b> on it.|$|R
50|$|Two {{types of}} locks are {{utilized}} by the basic protocol: Shared and <b>Exclusive</b> <b>locks.</b> Refinements {{of the basic}} protocol may utilize more lock types. Using locks that block processes, 2PL {{may be subject to}} deadlocks that result from the mutual blocking of two or more transactions.|$|R
25|$|SQL Server allows {{multiple}} {{clients to}} use the same database concurrently. As such, it needs to control concurrent access to shared data, to ensure data integrity—when multiple clients update the same data, or clients attempt to read data that {{is in the process of}} being changed by another client. SQL Server provides two modes of concurrency control: pessimistic concurrency and optimistic concurrency. When pessimistic concurrency control is being used, SQL Server controls concurrent access by using locks. Locks can be either shared or <b>exclusive.</b> <b>Exclusive</b> <b>lock</b> grants the user exclusive access to the data—no other user can access the data as long as the lock is held. Shared locks are used when some data is being read—multiple users can read from data locked with a shared lock, but not acquire an <b>exclusive</b> <b>lock.</b> The latter would have to wait for all shared locks to be released.|$|R
5000|$|<b>Exclusive</b> <b>locks</b> are, as {{the name}} implies, {{exclusively}} held by a single entity, usually {{for the purpose of}} writing to the record. If the locking schema was represented by a list, the holder list would contain only one entry. Since this type of lock effectively blocks any other entity that requires the lock from processing, care must be used to: ...|$|R
5000|$|To {{comply with}} the S2PL protocol, a {{transaction}} needs to comply with 2PL, and release its write (<b>exclusive)</b> <b>locks</b> only after it has ended, i.e., being either committed or aborted. On the other hand, read (shared) locks are released regularly during phase 2. This protocol is not appropriate in B-trees because it causes Bottleneck (while B-trees always starts searching from the parent root).|$|R
40|$|Data {{replications}} and transaction deadlocks can severely {{affect the}} performance of distributed database systems. Many current evaluation techniques ignore these aspects, because {{it is difficult to}} evaluate through analysis and time consuming to evaluate through simulation. Here, a technique is discussed that combines simulation and analysis to closely illustrate the impact of deadlock and evaluate performance of replicated distributed databases with both shared and <b>exclusive</b> <b>locks...</b>|$|R
5000|$|Pessimistic locking: a user {{who reads}} a record with the {{intention}} of updating it places an <b>exclusive</b> <b>lock</b> on the record to prevent other users from manipulating it. This means no one else can manipulate that record until the user releases the lock. The downside is that users can be locked out for a very long time, thereby slowing the overall system response and causing frustration.|$|R
5000|$|Shared locks are {{sometimes}} called [...] "read locks" [...] and <b>exclusive</b> <b>locks</b> {{are sometimes}} called [...] "write locks". However, because locks on Unix are advisory, this isn't enforced. Thus {{it is possible}} for a database to have a concept of [...] "shared writes" [...] vs. [...] "exclusive writes"; for example, changing a field in place may be permitted under shared access, whereas garbage-collecting and rewriting the database may require exclusive access.|$|R
5000|$|Microsoft Windows XP and Server 2003 editions have {{introduced}} volume snapshot (VSS) capability to NTFS, allowing open files to be accessed by backup software despite any <b>exclusive</b> <b>locks.</b> However, unless software is rewritten to specifically support this feature, the snapshot will be crash consistent only, while properly supported applications can assist {{the operating system}} in creating [...] "transactionally consistent" [...] snapshots. Other commercial software for accessing locked files under Windows include File Access Manager and Open File Manager. These work by installing their own drivers to access the files in kernel mode.|$|R
40|$|A {{number of}} {{algorithms}} {{have been proposed}} for accessing B-trees concurrently, but the performance of these algorithms is not yet well understood. In this paper, we study the performance of various concurrency control algorithms using a detailed simulation model of B-tree operations in a centralized DBMS. Our study considers {{a wide range of}} data contention situations and resource conditions. Results from our experiments indicate that algorithms in which updaters lock-couple using <b>exclusive</b> <b>locks</b> perform poorly as compared to those that permit more optimistic index descents. In particular, the B-link algorithms provide the most concurrency and the best overall performance...|$|R
50|$|Concurrency model {{describes}} how {{changes to the}} working copy are managed to prevent simultaneous edits from causing nonsensical data in the repository. In a lock model, changes are disallowed until the user requests and receives an <b>exclusive</b> <b>lock</b> on the file from the master repository. In a merge model, users may freely edit files, but are informed of possible conflicts upon checking their changes into the repository, whereupon the version control system may merge changes on both sides, or let the user decide when conflicts arise. Note that distributed version control almost always implies a merge concurrency model.|$|R
40|$|For twenty years, the {{transaction}} has been acknowledged {{as the central}} abstraction in preventing concurrent applications from corrupting {{the contents of a}} database, through errors such as lost update, dirty read or unrepeatable read. The original concurrency control algorithm, strict two-phase locking with shared and <b>exclusive</b> <b>locks,</b> is still widely used in practice, since it is simple to implement and guarantees serializability. Many alternative algorithms have been proposed and, in commercial systems these include variants of keyrange locking to avoid phantoms, and escrow reads to improve throughput on hotspot data. New algorithms continue to appear. These algorithms are usually evaluated by simulation rather than being implemented...|$|R
40|$|This paper {{presents}} the Reliable Multicast Protocol (RMP). RMP provides a totally ordered, reliable, atomic multicast service {{on top of}} an unreliable multicast datagram service such as IP Multicasting. RMP is fully and symmetrically distributed so that no site bears an undue portion of the communication load. RMP provides a wide range of guarantees, from unreliable delivery to totally ordered delivery, to K-resilient, majority resilient, and totally resilient atomic delivery. These QoS guarantees are selectable on a per packet basis. RMP provides many communication options, including virtual synchrony, a publisher/subscriber model of message delivery, a client/server model of delivery, an implicit naming service, mutually exclusive handlers for messages, and mutually <b>exclusive</b> <b>locks...</b>|$|R
