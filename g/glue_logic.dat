104|15|Public
25|$|Very-large-scale {{integration}} (VLSI) is {{the process}} of creating an integrated circuit (IC) by combining thousands of transistors into a single chip. VLSI began in the 1970s when complex semiconductor and communication technologies were being developed. The microprocessor is a VLSI device. Before the introduction of VLSI technology most ICs had a limited set of functions they could perform. An electronic circuit might consist of a CPU, ROM, RAM and other <b>glue</b> <b>logic.</b> VLSI allows IC makers to add all of these circuits into one chip.|$|E
2500|$|Nishi's {{standard}} was {{built around the}} Spectravideo SV-328 computer. The standard consisted primarily of several off-the-shelf parts; the main CPU was a 3.58MHz Zilog Z80, the Texas Instruments TMS9918 graphics chip with 16KB of dedicated VRAM, the sound and partial I/O support {{was provided by the}} AY-3-8910 chip manufactured by General Instrument (GI), and an Intel 8255 Programmable Peripheral Interface chip was used for the parallel I/O such as the keyboard. This was a choice of components that was shared by many other home computers and games consoles of the period, such as the ColecoVision home computer (an emulator was later available with which MSX systems could run some of its software), and the Sega SG-1000 video game system. To reduce overall system cost, many MSX models used a custom IC known as [...] "MSX-Engine", which integrated <b>glue</b> <b>logic,</b> 8255 PPI, YM2149 compatible soundchip and more, sometimes even the Z80 CPU. However, almost all MSX systems used a professional keyboard instead of a chiclet keyboard, driving the price up compared to the original SV-328. Consequently, these components alongside Microsoft's MSX BASIC made the MSX a competitive, though somewhat expensive, home computer package.|$|E
50|$|The {{software}} {{equivalent of}} <b>glue</b> <b>logic</b> is called glue code.|$|E
40|$|Tea is a {{high level}} {{scripting}} language for the Java environment. It has builtin support for all major programming paradigms, namely procedural, object oriented and functional. Its major strengths reside in its consistency, simplicity, easy extensibility and easy integration into any Java environment. These advantages are {{in addition to the}} intrinsic advantages of being a scripting language, these being rapid development turnaround, fast prototyping, <b>glueing</b> <b>logic</b> for components. ...|$|R
40|$|In {{this paper}} we propose a new {{communication}} synthesis approach targeting systems with sequential communication media (SCM). Since SCMs require that the reading sequence and writing sequence must have the same order, different transmission orders may have a dramatic impact on the final performance. However, the problem of determining the best possible communication order for SCMs is not adequately addressed by prior work. The goal of our work is to consider behaviors in communication synthesis for SCM, detect appropriate transmission order to optimize latency, automatically transform the behavior descriptions, and automatically generate driver routines and <b>glue</b> <b>logics</b> to access physical channels. Our algorithm, named SCOOP, successfully achieves these goals by behavior and communication cooptimization. Compared to the results without optimization, we can achieve an average 20 % improvement in total latency on a set of real-life benchmarks...|$|R
40|$|Keywords: Process {{variation}} Thread-level redundancy Chip Multiprocessor an ch t act {{be first}} formulate the above scheduling problem as a 0 – 1 programming problem {{to maximize the}} system rrors, ture In rticles cell o through parallel execution is generally regarded as the most prom-ising architecture for future high performance computing, which typically couples two adjacent cores statically with <b>glue</b> <b>logics</b> in between in the literature. As depicted in Fig. 1, communication channels and buffer queues are used to bind two adjacent cores to support thread redundant execution. We call it CMP with Static Core Coupling (CMP-SCC) architecture in this paper. CMP-SCC is much similar to Paceline structure as introduced in [4]. Process variation [2, 17, 18] is another important issue that can-not be ignored during system and architecture design phases, as precise control of manufacturing process becomes extremely difficult, if not impossible. For CMPs, within-die variation causes individual core frequency or leakage characteristics to diffe...|$|R
5000|$|Typical {{functions}} of <b>glue</b> <b>logic</b> may include (but {{are not limited}} to): ...|$|E
5000|$|ZK - a Java Ajax {{framework}} that allows <b>glue</b> <b>logic</b> written in Jython ...|$|E
5000|$|Knowledge of a {{scripting}} language {{to write the}} <b>glue</b> <b>logic</b> (running on the server): ...|$|E
40|$|This paper {{presents}} a new methodology of automatic RTL code generation from coarse-grain dataflow specification for fast HW/SW cosynthesis. A node in a coarse-grain dataflow specification re{{presents a}} functional block such as FIR and DCT and an arc may deliver multiple data samples per block invocation, which complicates {{the problem and}} distinguishes it from behavioral synthesis problem. Given optimized HW library blocks for dataflow nodes, we aim to generate the RTL codes for the entire hardware system including <b>glue</b> <b>logics</b> such as buffer and MUX, and the central controller. In the proposed design methodology, a dataflow graph can be mapped to various hardware structures by changing the resource allocation and schedule information. It simplifies {{the management of the}} area/performance tradeoff in hardware design and widens the design space of hardware implementation of a dataflow graph. We also support Fractional Rate Dataflow (FRDF) specification for more efficient hardware implementation. To overcome the additional hardware area overhead in the synthesized architecture, we propose two techniques reducing buffer overhead. Through experiments with some real examples, the usefulness of the proposed technique is demonstrated...|$|R
40|$|Separation of {{concerns}} or aspects is nowadays {{recognized as an}} important issue in software engineering, both at the programming and at the design/specication level. The goal of mixed specication languages (e. g. SDL, value-passing process algebras such as extensions of CSP or full-LOTOS, Korrigan) is {{to take into account}} all- or at least several- aspects of systems. We found out from our experience that a lot of mixed specication languages do share most of their features. However, specic theories, such as the symbolic transition systems one, still have to be studied for several families of mixed specication languages. In this paper we propose a logic with an expressive temporal <b>gluing</b> mechanism. This <b>logic</b> aims at providing an ab-stract denotational semantics for mixed specication languages. This logic enables one to reason about mixed specications at a high level, without targeting a specic model or language. We show how our logic can be seen as an institution, which has the benets of enabling a common renement theory for mixed specication languages. Key words: mixed formal specications, temporal <b>logic</b> <b>glue,</b> denotational semantics, <b>logic,</b> institution, renement. ...|$|R
40|$|Abstract. The {{strength}} of answer set programming (ASP) lies in solving computationally challenging problems declaratively, and hopefully efficiently. A similar goal {{is shared by}} two other approaches, SAT and Constraint Programming (CP). As future applications of ASP hinge on its underlying solving techniques, in this note, I will briefly comment on the related techniques, and argue for the need of ASP systems to integrate with state-of-the-art techniques for constraint solving, and in general {{to serve as the}} core reasoning engine to <b>glue</b> other <b>logics</b> and reasoning mechanisms together. 1 Constraint Solving Paradigms Started in the field of Operations Research, an optimization/search problem can be specified in forms of mathematical expressions, and an implemented system is responsible for efficient computation of solutions. A similar goal is shared by SAT and CP. In this note, by CP, I mean the systems that implement the Constraint Satisfaction Problem (CSP). This includes various CSP packages and CP languages developed by the CSP/CP community, and Constraint Logi...|$|R
50|$|In electronics, <b>glue</b> <b>logic</b> is {{the custom}} logic {{circuitry}} used to interface {{a number of}} off-the-shelf integrated circuits.|$|E
50|$|RPD-1 - {{floppy disk}} controller, {{due to its}} {{complexity}} (discrete <b>glue</b> <b>logic)</b> was built on two boards connected by cable. This came very late.|$|E
50|$|The AdLib used Yamaha's YM3812 sound chip which {{produces}} sound via FM synthesis. The AdLib card {{consisted of a}} YM3812 chip with off-the-shelf external <b>glue</b> <b>logic</b> to plug into a standard PC-compatible ISA 8-bit slot.|$|E
40|$|Recent {{work on the}} syntax-semantics in- terface (see e. g. (Dalrymple et al., 1994)) uses a {{fragment}} of linear logic as a 'glue language' for assembling meanings compositionally. This paper presents a glue language account of how negative polarity items (e. g. ever, any) get licensed {{within the scope of}} negative or downward-entailing contexts (Ladusaw, 1979), e. g. Nobody ever left. This treatment of licensing operates precisely at the syntax-semantics interface, since it is car- ried out entirely within the interface <b>glue</b> language (linear <b>logic).</b> In addition to the' account of negative polarity licensing, we show in detail how linear-logic proof nets (Girard, 1987; Galllet, 1992) can be used for efficient meaning deduction within this 'glue language' framework...|$|R
40|$|Improving {{efficiency}} of city services and facilitating a more sustainable development of cities {{are the main}} drivers of the smart city concept. Information and Communication Technologies (ICT) {{play a crucial role}} in making cities smarter, more accessible and more open. In this paper we present a novel architecture exploiting major concepts from the Future Internet (FI) paradigm addressing the challenges that need to be overcome when creating smarter cities. This architecture takes advantage of both the critical communications infrastructures already in place and owned by the utilities as well as of the infrastructure belonging to the city municipalities to accelerate efficient provision of existing and new city services. The paper highlights how FI technologies create the necessary <b>glue</b> and <b>logic</b> that allows the integration of current vertical and isolated city services into a holistic solution, which enables a huge forward leap for the efficiency and sustainability of our cities. Moreover, the paper describes a real-world prototype, that instantiates the aforementioned architecture, deployed in one of the parks of the city of Santander providing an autonomous public street lighting adaptation service. This prototype is a showcase on how added-value services can be seamlessly created on top of the proposed architecture...|$|R
40|$|International audienceComponent Based Software Engineering has now {{emerged as}} a {{discipline}} for system development. After years of battle between component platforms, the need for means to abstract away from specific implementation details is now recognized. This paves the way for model driven approaches (such as MDE) {{but also for the}} more older Architectural Description Language (ADL) paradigm. In this paper we present KADL, an ADL based on the Korrigan formal language which supports the following features: integration of fully formal behaviours and data types, expressive component composition mechanisms through the use of modal logic, specification readability through graphical notations, and dedicated architectural analysis techniques. Key Words: Architectural Description Language, Component Based Software Engineering, Mixed Formal Specifications, Symbolic Transition Systems, Abstract Data Types, Modal <b>Logic</b> <b>Glue,</b> Graphical Notations, Verification...|$|R
5000|$|TTL {{became the}} {{foundation}} of computers and other digital electronics. Even after much larger scale integrated circuits made multiple-circuit-board processors obsolete, TTL devices still found extensive use as the <b>glue</b> <b>logic</b> interfacing more densely integrated components.|$|E
50|$|Many new TTL and CMOS <b>glue</b> <b>logic</b> designs {{continued}} {{appearing on}} the market for several more years. Names like Meziere, Terminator, K&R, ATI, Digital Delay (Ike Hamma), Biondo, Davis, D&D (Danny Duberry) and others figure prominently in the history of drag racing delay boxes. Some of the <b>glue</b> <b>logic</b> type designs had large LED (light emitting diode) readouts to display the timer setting, others featured attractive backlighted LCDs (liquid crystal displays), still others used thumbwheels of varying size and quality. All delay boxes on the market were quartz crystal accurate by the year 1990. Several years elapsed before other delay box designs appeared with embedded microprocessors.|$|E
50|$|The SIM (System Integration Module), which {{eliminates}} much <b>glue</b> <b>logic</b> {{by providing}} chip selects and address decoding. The SIM {{also provides a}} clock generator, watchdogs for various system operations, configuration of processor pins, a periodic timer, and an interrupt controller.|$|E
40|$|Gupta and Lamping, 1998] {{show how}} linear logic based meaning constructors in the glue {{language}} semantics of [Dalrymple et al., 1996] {{can be converted}} to "almost Horn clause" form using the compilation method of [Hepple, 1996]. Efficient linear logic deductions deliver skeleton and modifier resources resembling Underspecified Discourse Representation Structures (UDRSs [Reyle, 1993]). In this paper we present an alternative method: we directly encode UDRT-based semantic representations in linear logic based meaning constructors. The meaning constructors thus obtained are in Horn clause form and deductions are linear in the size of semantic contributions. As an example we show how this encoding can be used advantageously in an ambiguity preserving transfer based machine translation scenario where it avoids the head-switching problem encountered by the otherwise related approach of [van Genabith et al., 1998]. Keywords: linear <b>logic,</b> <b>glue</b> languages, underspecificat [...] ...|$|R
40|$|In {{this paper}} we replace the static meaning {{representation}} {{language in the}} LFG linear <b>logic</b> based <b>glue</b> language semantics approach [Dalrymple et al., 1993 b; Dalrymple et al., 1993 a; Dalrymple et al., 1995 b; Dalrymple et al., 1996] with a dynamic meaning language [Muskens, 1994 b; Muskens, 1994 a]. This move extends the original approach to discourse phenomena and can be combined with the approach to underspecification developed in [Crouch and Genabith, 1996]. On the other hand it provides linear logic based approaches to quantifier scope and underspecification for dynamic semantics. We briefly compare the results with some alternative approaches discussed in the literature and sketch a QLF [Alshawi and Crouch, 1992] and a UDRS [Reyle, 1995] style interpretation {{for a set of}} linear logic premises thus obtained. Keywords: linear <b>logic</b> <b>glue</b> language semantics, dynamic interpretation, underspecification 1 Introduction In the present paper we port a dynamic meaning rep [...] ...|$|R
30|$|Furthermore, {{several studies}} (e.g. [42 – 48]) have {{addressed}} middleware technologies associated with pervasive computing environments and distributed applications. Middleware {{plays a key}} role in the functionality of distributed context-aware applications, as it represents the <b>logic</b> <b>glue</b> in a distributed computing system by connecting and coordinating many components constituting distributed applications. Among the key topics addressed in the literature include architectures for pervasive context-aware services in smart spaces in terms of middleware components and prototype applications, middleware for context representation and management in pervasive computing, middleware-based development of context-aware applications with reusable components, middleware for real-time systems, and so forth. There is a need for further research in the area of middleware with regard to the use of large-scale context-aware applications as part of the informational landscape of smart sustainable cities, as well as to the modeling and management of context information in distributed pervasive applications and in open and dynamic pervasive environments.|$|R
50|$|The system {{interface}} {{was similar to}} that of the Alpha 21364. There were integrated memory controllers that provided ten RDRAM channels. Multiprocessing was facilitated by a router that provided links to other 21464s, and it architecturally supported 512-way multiprocessing without <b>glue</b> <b>logic.</b>|$|E
50|$|The latest {{revision}} {{is entirely}} solid-state, {{consisting of a}} single large FPGA chip as the board's <b>glue</b> <b>logic,</b> an SPROM (Serial Programmable Read-Only Memory) chip, containing the FPGA's operating code, a few SRAM chips for buffering and a solid-state or 'Flash' drive.|$|E
50|$|Gary, {{short for}} Gate Array, {{has been used}} in the Amiga 500, 2000(B) and CDTV. Gary {{provides}} <b>glue</b> <b>logic</b> for bus control and houses supporting functions for the floppy disk drive. It integrates many functions built discretely in the earlier Amiga 1000 in order to reduce costs.|$|E
40|$|AbstractThe paper {{attempts}} {{to integrate the}} Quality Function Deployment (QFD) method in the New Product Development (NPD) cycle. We propose a methodology to evaluate {{the voice of the}} customers in designing innovative products. The results presented after applying the methodology focus on the first stage of requirements capture for both the design phase and {{for the development of the}} actual product phase. There was considered as case study an innovative, newly patented product, a biometric identification system for emergency cases. The research methodology is inter, multi, trans- disciplinary approach for the development of innovative products. In the context of our study NPD was the pathway for the research steps to follow, and QFD the <b>logic</b> <b>glue</b> among the specialists from different fields, like quality management, electronics, computer programming and medicine. The methodology follows the general steps of the QFD formalism and consists in developing a mathematical model that quantifies by an overall index, that we call offset, the level of customer requirements achievement by the technical characteristics of the designed or developed innovative product...|$|R
40|$|AbstractSeparation of {{concerns}} or aspects is nowadays {{recognized as an}} important issue in software engineering, both at the programming and at the design/specification level. The goal of mixed specification languages (e. g. SDL, value-passing process algebras such as extensions of CSP or full-LOTOS, Korrigan) is {{to take into account}} all - or at least several - aspects of systems. We found out from our experience that a lot of mixed specification languages do share most of their features. However, specific theories, such as the symbolic transition systems one, still have to be studied for several families of mixed specification languages. In this paper we propose a logic with an expressive temporal <b>gluing</b> mechanism. This <b>logic</b> aims at providing an abstract denotational semantics for mixed specification languages. This logic enables one to reason about mixed specifications at a high level, without targeting a specific model or language. We show how our logic can be seen as an institution, which has the benefits of enabling a common refinement theory for mixed specification languages...|$|R
30|$|Middleware {{infrastructure}} {{represents the}} <b>logic</b> <b>glue</b> in a distributed computing system, as it connects and coordinates many components constituting distributed applications. This occurs, more specifically, ‘in {{the midst of}} a variety of heterogeneous hardware systems and software applications needed for realizing smart environments and their proper functioning. To put it differently, in order for the massively embedded, distributed, networked devices and systems, which are invisibly integrated into the environment, to coordinate require middleware components, architectures, and services. Middleware allows multiple processes running on various sensors, devices, computers, and networks to link up and interact to support (and maintain the operation of context-aware applications needed by citizens and urban entities to cope with and perform their) activities wherever and whenever needed.’ ([19], p. 50). Indeed, it is the ability of multiple, heterogenous hardware and software systems to cooperate, interconnect, and communicate seamlessly across disparate networks that create smart environments rather than just their ubiquitous presence and massive use. In the context of smart sustainable cities, such systems in their various forms (e.g. sensors, smartphones, computers, databases, data warehouses, application integration methods, application servers, web servers, context management systems, and messaging systems) are highly distributed, interoperable, and dynamic, involving a myriad of embedded devices and information processing units ‘whose numbers are set to increase by orders of magnitude and which are to be exploited in their full range to transparently provide services on a hard-to-imagine scale, regardless of time and place’ [19]. This in turn allows for the functioning of context-aware applications across the diverse domains of smart sustainable cities.|$|R
5000|$|Low-power Schottky TTL (LS) - {{used the}} higher {{resistance}} values of low-power TTL and the Schottky diodes {{to provide a}} good combination of speed (9.5ns) and reduced power consumption (2 mW), and PDP of about 20 pJ. Probably {{the most common type}} of TTL, these were used as <b>glue</b> <b>logic</b> in microcomputers, essentially replacing the former H, L, and S sub-families.|$|E
50|$|Inside the {{coprocessor}} unit {{a proprietary}} chip (the Tube ULA, manufactured initially by Ferranti) interfaced and logically isolated the host and coprocessor buses. This allowed the Tube {{to work with}} a completely different bus architecture in the coprocessor unit. The only other active components needed were a microprocessor, some RAM, a small ROM containing processor specific client code, <b>glue</b> <b>logic</b> such as an address decoder and a power supply.|$|E
50|$|Today, surface-mounted CMOS {{versions}} of the 7400 series are used in various applications in electronics and for <b>glue</b> <b>logic</b> in computers and industrial electronics. The original through-hole devices in dual in-line packages (DIP/DIL) were the mainstay of the industry for many decades. They are useful for rapid breadboard-prototyping and for education and remain available from most manufacturers. The fastest types and very low voltage versions are typically surface-mount only, however.|$|E
50|$|FPGAs {{originally}} {{began as}} competitors to CPLDs and competed {{in a similar}} space, that of <b>glue</b> <b>logic</b> for PCBs. As their size, capabilities, and speed increased, they began to take over larger and larger functions {{to the point where}} some are now marketed as full systems on chips (SoC). Particularly with the introduction of dedicated multipliers into FPGA architectures in the late 1990s, applications which had traditionally been the sole reserve of DSPs began to incorporate FPGAs instead.|$|E
50|$|Very-large-scale {{integration}} (VLSI) is {{the process}} of creating an integrated circuit (IC) by combining thousands of transistors into a single chip. VLSI began in the 1970s when complex semiconductor and communication technologies were being developed. The microprocessor is a VLSI device. Before the introduction of VLSI technology most ICs had a limited set of functions they could perform. An electronic circuit might consist of a CPU, ROM, RAM and other <b>glue</b> <b>logic.</b> VLSI lets IC designers add all of these into one chip.|$|E
50|$|Akiko is the CD32's {{all-purpose}} 'glue' {{chip and}} forms {{part of the}} AGA chipset used in that system. Akiko is responsible for implementing system <b>glue</b> <b>logic</b> that in previous Amiga models {{were found in the}} discrete chips Budgie, Gayle and the two CIAs. In detail, it includes control logic for the CD32's CD-ROM controller, system timers, the two game ports and the serial ('AUX') port and the chip memory soldered onto the motherboard. It controls a one kilobyte EEPROM for saving data such as highscores etc.|$|E
