0|10000|Public
40|$|We {{propose a}} text {{indexing}} technique for approximate pattern matching, which is practical and especially aimed at Information Retrieval (IR). Unlike other indices of this kind, it {{is able to}} retrieve any string that approximately matches a given search pattern. Every sequence of a fixed length appearing in the text is stored in the <b>index,</b> together <b>with</b> <b>pointers</b> to all the positions where it appears. The search pattern is cut into pieces so that at least one must match exactly. All the pieces are searched in the index and the union of candidate positions is verified. To reduce space requirements, pointers to blocks instead of exact positions can be used, which increases querying costs. We design an algorithm to optimize the pattern partition into pieces so that the total number of verifications is minimized. This also allows to know in advance the expected cost of the search and the expected relevance of the query to the user. We show experimentally the build time, space requirements an [...] ...|$|R
40|$|We propose an {{indexing}} technique for approximate text searching, which is practical and powerful, and especially optimized for natural language text. Unlike other indices of this kind, it {{is able to}} retrieve any string that approximately matches the search pattern, not only words. Every text substring of a fixed length q is stored in the <b>index,</b> together <b>with</b> <b>pointers</b> to all the text positions where it appears. The search pattern is partitioned into pieces which are searched in the index, and all their occurrences in the text are verified for a complete match. To reduce space requirements, pointers to blocks instead of exact positions can be used, which increases querying costs. We design an algorithm to optimize the pattern partition into pieces so that the total number of verifications is minimized. This is especially well suited for natural language texts, and allows to know in advance the expected cost of the search and the expected relevance of the query to the user. We show experi [...] ...|$|R
5000|$|... int array5; /* Declares 5 {{contiguous}} integers */int *ptr = array; /* Arrays {{can be used}} as pointers */ptr0 = 1; /* <b>Pointers</b> can be <b>indexed</b> <b>with</b> array syntax */*(array + 1) = 2; /* Arrays can be dereferenced <b>with</b> <b>pointer</b> syntax */*(1 + array) = 2; /* Pointer addition is commutative */2array = 4; /* Subscript operator is commutative */ ...|$|R
40|$|Abstract:- Textual {{substitution}} methods, {{often called}} dictionary methods or Lempel-Ziv methods, after the important work of Lempel and Ziv, are one-dimensional compression methods that maintain a constantly changing dictionary of strings to adaptively compress {{a stream of}} characters by replacing common substrings <b>with</b> <b>indices</b> (<b>pointers)</b> into a dictionary. Lempel and Ziv proved that the proposed schemes were practical as well as asymptotically optimal for a general source model. Two-dimensional (i. e. images) applications of textual substitution methods have been widely studied in the past. Those applications involve first {{the application of a}} linearization strategy to the input data, and then the encoding of the resulting mono-dimensional vector using LZ type one-dimensional methods. More recent strategies blend textual substitution methods with Vector Quantization. In this paper we discuss the textual substitution methods for image compression, with particular attention to the AVQ class of algorithms, and review recent advances in the field...|$|R
40|$|Large {{inverted}} {{indices are}} by now {{common in the}} construction of web-scale search engines. For faster access, inverted indices are indexed internally so {{that it is possible to}} skip quickly over unnecessary documents. The classical approach to skipping dictates that a skip should be positioned every âˆš f document pointers, where f is the overall number of documents where the term appears. We argue that due to the growing size of the web more refined techniques are necessary, and describe how to embed a compressed perfect skip list in an inverted list. We provide statistical models that explain the empirical distribution of the skip data we observe in our experiments, and use them to devise good compression techniques that allow us to limit the waste in space, so that the resulting data structure increases the overall index size by just a few percents, still making it possible to <b>index</b> <b>pointers</b> <b>with</b> a rather fine granularity. ...|$|R
5000|$|Map <b>with</b> <b>pointers</b> to parishes and {{institutions}} https://maps.google.com/maps/ms?msid=212380245879407230294.0004af07d32a7476355cb&msa=0 ...|$|R
5000|$|The {{matching}} {{and replacement}} of duplicate strings <b>with</b> <b>pointers.</b>|$|R
5000|$|... (the only type <b>with</b> <b>pointer</b> {{arithmetic}} allowed, [...] "fat" [...] pointers).|$|R
5000|$|A similar {{version of}} [...] {{can be written}} <b>with</b> <b>pointers</b> instead of references: ...|$|R
5000|$|... #Caption: Carl Barks (standing <b>with</b> <b>pointer)</b> and Harry Reeves (clowning) {{present the}} {{storyboard}} for Good Scouts in 1937 ...|$|R
5000|$|If {{the symbols}} are sorted by probability, {{there is a}} linear-time (O(n)) method to create a Huffman tree using two queues, the first one {{containing}} the initial weights (along <b>with</b> <b>pointers</b> to the associated leaves), and combined weights (along <b>with</b> <b>pointers</b> to the trees) being put {{in the back of}} the second queue. This assures that the lowest weight is always kept at the front of one of the two queues: ...|$|R
50|$|An {{extended}} binary GCD, {{analogous to}} the extended Euclidean algorithm, is given by Knuth along <b>with</b> <b>pointers</b> to other versions.|$|R
5000|$|Once a {{reference}} is created, it cannot be later made to reference another object; it cannot be reseated. This is often done <b>with</b> <b>pointers.</b>|$|R
5000|$|Unallocated {{memory is}} grouped into [...] "bins" [...] of similar sizes, {{implemented}} {{by using a}} double-linked list of chunks (<b>with</b> <b>pointers</b> stored in the unallocated space inside the chunk).|$|R
50|$|Several Exeter city {{services}} have been upgraded, including service F splitting into two, the F1 & F2; and service A having the first Dennis Darts <b>with</b> <b>Pointer</b> 2 bodywork vehicles in Exeter.|$|R
40|$|We aim at {{checking}} safety properties on systems <b>with</b> <b>pointers</b> {{which are}} naturally infinite state systems. In this paper, we introduce Symbolic Memory States, a new symbolic representation {{well suited to}} the verification of systems <b>with</b> <b>pointers.</b> We show SMS enjoys all the good properties needed to check safety properties, such as closure under union, canonicity of the representation and decidable inclusion. We also introduce pointer automata, a model for programs using dynamic allocation of memory. We define the properties we want to check in this model and we give undecidability results. The verification part is still work in progress...|$|R
50|$|A sparse index in {{databases}} is a {{file with}} pairs of keys and pointers for every {{block in the}} data file. Every key in this file is associated <b>with</b> a particular <b>pointer</b> to the block in the sorted data file. In clustered <b>indices</b> <b>with</b> duplicate keys, the sparse index points to the lowest search key in each block.|$|R
5000|$|Born in 1984, Pointer {{grew up in}} New York City and Los Angeles, California. <b>Pointer</b> {{currently}} sings <b>with</b> [...] "The <b>Pointer</b> Sisters" [...] and {{has been}} performing <b>with</b> Ruth <b>Pointer</b> and Anita Pointer, original Pointer Sisters members. Sadako is the granddaughter of Ruth and the great-niece of Anita. Sadako is currently touring <b>with</b> The <b>Pointer</b> Sisters and appeared in the 2014 film, [...] "Proxy".|$|R
50|$|It is {{not common}} {{to access the}} TIB fields by an offset from FS:0, but rather first getting a linear self-referencing pointer to it stored at FS:0x18. That pointer can be used <b>with</b> <b>pointer</b> arithmetics or be cast to a struct pointer.|$|R
40|$|International audienceThe aim of {{this talk}} is to present a {{framework}} for data-structure rewriting, including cyclic data-structures <b>with</b> <b>pointers</b> such as circular lists, doubly-linked lists, etc. Our framework follows the categorical approach of the DPO (double pushout) method, but with non-classical assumptions on rules and matchings. It allows local pointer redirection, for redirecting some specific pointers, and global pointer redirection, for redirecting all <b>pointers</b> <b>with</b> some specific target to another target...|$|R
40|$|This lecture {{concerns}} weakest liberal {{precondition for}} a language <b>with</b> <b>pointers.</b> It discusses two {{approaches to the}} issue: (i) one based on an enhanced rule of substitution (of programminglanguage elements into formulas), and (ii) one based on an encoding of the programming language semantics into logic. ...|$|R
50|$|There {{are many}} {{different}} ways to represent trees; common representations represent the nodes as dynamically allocated records <b>with</b> <b>pointers</b> to their children, their parents, or both, or as items in an array, with relationships between them determined by their positions in the array (e.g., binary heap).|$|R
40|$|Worked on {{verification}} of concurrent programs <b>with</b> <b>pointers,</b> using separation logic, and model checking with counter automata. Developed model-checking tools for the {{verification of}} list programs (L 2 CA) and array programs (A 2 CA) using counter automata. Also worked on shared-memory semantics and compilation for component-based parallel systems...|$|R
40|$|A {{sample of}} 35 {{published}} pedigrees of Gilles de la Tourette syndrome is studied using complex segregation analysis <b>with</b> <b>pointers.</b> Results {{indicate the presence}} of a rare, semidominant, incompletely penetrant allele leading to affection. This result is consistent with that previously reported by Comings et al. on a larger, independent sample...|$|R
40|$|ABSTRACT Denotational {{semantics}} {{is given}} for a Java-like language <b>with</b> <b>pointers,</b> subclassing and dynamic dispatch, class oriented visibility control, recursive types and methods, and privilegebased access control. Representation independence (relational parametricity) is proved, using a semantic notion of confinement similar to ones for which static disciplines have been recently proposed. 1...|$|R
40|$|If {{we build}} it, will they come? Whether {{intended}} for faculty papers, original journals, dissertations, or special collections, {{one of the}} challenges of building an institutional repository is recruiting appropriate content. This presentation addresses experiences at Thomas Jefferson University, along <b>with</b> <b>pointers</b> and strategies for successfully populating an institutional repository...|$|R
30|$|Based on our threshold, we {{identified}} six positive and six negative pointer years and compared these <b>with</b> <b>pointer</b> years of {{young and old}} birch trees (Gradel et al. 2017). Consistent pointer years throughout all chronologies included 1986 and 2008 as positive pointer years and 1987 as a negative pointer year Fig.Â  4.|$|R
40|$|This text {{demonstrates}} that symbolic representation, and related problem-solving methods, offer significant opportunities to clarify and articulate concepts of design {{to give a}} better framework for design research and education. This edition includes recent work on design reasoning, computational design, AI in design, and design cognition, <b>with</b> <b>pointers</b> to the current literature. [URL]...|$|R
50|$|In {{languages}} <b>with</b> <b>pointers</b> or references, {{one solution}} is to return a pointer to a value, rather than the value itself. This return pointer can then be set to null to indicate an error. This approach may cause some overhead, and it is typically suited to functions that return a pointer anyway.|$|R
40|$|International audienceIn {{this paper}} we {{introduce}} a new symbolic semantics for a class of recursive programs which feature dynamic creation and unbounded allocation of objects. We use a symbolic representation of the program state in terms of equations to model the semantics of a program as a pushdown system with a finite set of control states and a finite stack alphabet. Our main technical result is a rigorous proof of the equivalence between the concrete and the symbolic semantics. Adding pointer fields {{gives rise to a}} Turing complete language. However, assuming the number of reachable objects in the visible heap is bounded in all the computations of a program <b>with</b> <b>pointers,</b> we show how to construct a program without pointers that simulates it. Consequently, in the context of bounded visible heaps, programs <b>with</b> <b>pointers</b> are no more expressive than programs without them...|$|R
40|$|Program slicing, a {{technique}} to compute the subset of program statements that can affect {{the value of a}} program variable at a specific program point, is widely used in tools to support maintenance activities. To be useful for supporting these activities, a slicing technique must be sufficiently precise and efficient. Harrold and Ci propose a method for improving the efficiency of slicing by reusing slicing information for subsequent slicing. This paper presents an interprocedural slicing algorithm that improves the efficiency and precision of Harrold and Ci's algorithm for programs <b>with</b> <b>pointer</b> variables and recursion. Our empirical results show that our improvements can effectively achieve more reuse in slice computation, for programs <b>with</b> <b>pointers,</b> and can significantly reduce the sizes of slices, for programs with recursion. Keywords: Slicing, demand-driven, equivalence. 1 Introduction Maintenance activities, such as program understanding, regression testing, and reverse engineer [...] ...|$|R
40|$|Proving {{termination}} automatically {{for programs}} <b>with</b> explicit <b>pointer</b> arithmetic {{is still an}} open problem. To close this gap, we introduce a novel abstract domain that can track allocated memory in detail. We use it to automatically construct a symbolic execution graph that represents all possible runs {{of the program and}} {{that can be used to}} prove memory safety. This graph is then transformed into an integer transition system, whose termination can be proved by standard techniques. We implemented this approach in the automated termination prover AProVE and demonstrate its capability of analyzing C programs <b>with</b> <b>pointer</b> arithmetic that existing tools cannot handle. ...|$|R
5000|$|... #Caption: Dunn as Antaeus <b>with</b> Priscilla <b>Pointer</b> in The Inner Journey.|$|R
5000|$|Webcast animation: PowerPoint-like {{animations}} <b>with</b> laser <b>pointer</b> {{movements of}} the speaker; ...|$|R
40|$|Object-oriented {{programs}} organize data in objects {{linked together}} <b>with</b> <b>pointers.</b> While this enhances modularity, making programs {{easier to understand}} and maintain, it has a run-time cost due to the pointers that must be dereferenced to access the data. The purpose of object inlining is to nd sets of objects which can be eÃ†ciently fused int...|$|R
40|$|We {{consider}} a sequential object-oriented language <b>with</b> <b>pointers</b> and mutable state, private fields and classbased visibility, dynamic binding and inheritance, recursive classes, casts and type tests, and recursive methods. Programs are annotated with security levels, constrained by security typing rules. A noninterference theorem {{shows how the}} rules ensure pointer confinement and secure information flow...|$|R
