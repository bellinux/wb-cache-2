49|680|Public
50|$|In telecommunication, a {{burst error}} or <b>error</b> <b>burst</b> is a {{contiguous}} sequence of symbols, received over a data transmission channel, {{such that the}} first and last symbols are in error and there exists no contiguous subsequence of m correctly received symbols within the <b>error</b> <b>burst.</b>|$|E
50|$|The integer {{parameter}} m {{is referred}} to as the guard band of the <b>error</b> <b>burst.</b> The last symbol in a burst and the first symbol in the following burst are accordingly separated by m correct bits or more. The parameter m should be specified when describing an <b>error</b> <b>burst.</b>|$|E
50|$|In the Hagelbarger code, {{inserted}} {{parity check}} bits are {{spread out in}} time so that an <b>error</b> <b>burst</b> {{is not likely to}} affect more than one of the groups in which parity is checked.|$|E
5000|$|In telecommunication, a Hagelbarger code is a {{convolutional}} code that enables <b>error</b> <b>bursts</b> {{to be corrected}} provided that there are relatively long error-free intervals between the <b>error</b> <b>bursts.</b>|$|R
50|$|Reed-Solomon {{codes are}} {{specifically}} useful in combating mixtures of random and <b>burst</b> <b>errors.</b> CIRC corrects <b>error</b> <b>bursts</b> up to 3,500 bits in sequence (2.4 mm in length as seen on CD surface) and compensates for <b>error</b> <b>bursts</b> up to 12,000 bits (8.5 mm) {{that may be}} caused by minor scratches.|$|R
25|$|The {{process is}} subject to both <b>burst</b> <b>errors</b> and random <b>errors.</b> <b>Burst</b> <b>errors</b> include those due to disc {{material}} (defects of aluminum reflecting film, poor reflective index of transparent disc material), disc production (faults during disc forming and disc cutting etc.), disc handling (scratches – generally thin, radial and orthogonal to direction of recording) and variations in play-back mechanism. Random errors include those due to jitter of reconstructed signal wave and interference in signal. CIRC (Cross-Interleaved Reed–Solomon code) {{is the basis for}} error detection and correction in the CD process. It corrects <b>error</b> <b>bursts</b> up to 3,500 bits in sequence (2.4nbsp&mm in length as seen on CD surface) and compensates for <b>error</b> <b>bursts</b> up to 12,000 bits (8.5nbsp&mm) that may be caused by minor scratches.|$|R
50|$|For {{many modern}} packet-switched {{communication}} systems, {{even a single}} uncorrected bit error is enough to cause {{the loss of a}} data packet by causing its CRC check to fail; whether that packet loss was caused by a single bit error or a hundred-bit-long <b>error</b> <b>burst</b> is irrelevant.|$|E
5000|$|If {{the data}} is destined for serial communication, {{it is best to}} use the bit {{ordering}} the data will ultimately be sent in. This is because a CRC's ability to detect burst errors is based on proximity in the message polynomial if adjacent polynomial terms are not transmitted sequentially, a physical <b>error</b> <b>burst</b> of one length may be seen as a longer burst due to the rearrangement of bits.|$|E
5000|$|In the Malicious Classification Model {{an adversary}} generates errors to foil the {{learning}} algorithm. This setting describes situations of <b>error</b> <b>burst,</b> which may occur when {{for a limited}} time transmission equipment malfunctions repeatedly. Formally, algorithm [...] calls an oracle [...] that returns a correctly labeled example [...] drawn, as usual, from distribution [...] over the input space with probability , but it returns with probability [...] an example drawn from a distribution that {{is not related to}} [...] Moreover, this maliciously chosen example may strategically selected by an adversary who has knowledge of , , , or the current progress of the learning algorithm.|$|E
50|$|The {{result is}} a CIRC that can {{completely}} correct <b>error</b> <b>bursts</b> up to 4000 bits, or about 2.5 mm on the disc surface. This code {{is so strong that}} most CD playback errors are almost certainly caused by tracking errors that cause the laser to jump track, not by uncorrectable <b>error</b> <b>bursts.</b>|$|R
5000|$|From Hamming {{distance}} concept, a code {{with minimum}} distance [...] can correct any [...] errors. But in many channels error pattern {{is not very}} arbitrary, it occurs within very short segment of the message. Such kind of <b>errors</b> are called <b>burst</b> <b>errors.</b> So, for correcting such errors we will get a more efficient code of higher rate because of the less constraints. Cyclic codes are used for correcting <b>burst</b> <b>error.</b> In fact, cyclic codes can also correct cyclic <b>burst</b> <b>errors</b> along with <b>burst</b> <b>errors.</b> Cyclic <b>burst</b> <b>errors</b> are defined as ...|$|R
50|$|Time Diversity is used {{in digital}} {{communication}} systems to combat that the transmissions channel may suffer from <b>error</b> <b>bursts</b> due to time-varying channel conditions. The <b>error</b> <b>bursts</b> {{may be caused by}} fading in combination with a moving receiver, transmitter or obstacle, or by intermittent electromagnetic interference, for example from crosstalk in a cable, or co-channel interference from radio transmitters.|$|R
50|$|CRCs {{are based}} on the theory of cyclic error-correcting codes. The use of {{systematic}} cyclic codes, which encode messages by adding a fixed-length check value, for the purpose of error detection in communication networks, was first proposed by W. Wesley Peterson in 1961.Cyclic codes are not only simple to implement but have the benefit of being particularly well suited for the detection of burst errors: contiguous sequences of erroneous data symbols in messages. This is important because burst errors are common transmission errors in many communication channels, including magnetic and optical storage devices. Typically an n-bit CRC applied to a data block of arbitrary length will detect any single <b>error</b> <b>burst</b> not longer than n bits and will detect a fraction 1/(1 − 2−n) of all longer error bursts.|$|E
3000|$|... is an {{interleaved}} code {{of degree}} b, capable of correcting a single <b>error</b> <b>burst</b> of length b or less (see [21], Theorem 11.1).|$|E
40|$|We propose an {{interleaving}} {{scheme for}} multidimensional (M-D) interleaving. To achieved {{by using a}} novel concept of basis interleaving array. A general method of obtaining a variety of basis interleaving arrays is presented. Based on the basis interleaving array, we then propose an interleaving technique, called successive packing, to generate the interleaved array of arbitrary size. It is shown that the proposed technique can spread any <b>error</b> <b>burst</b> of m 1 within m 1 array (1 n- 1) e#ectively so that the <b>error</b> <b>burst</b> can be corrected with simple random error correcting-code (provided the error correcting-code is available). It is further shown that the technique is optimal for combating a set of arbitrarily-shaped error bursts. Since this algorithm needs to be implemented only once for a given M-D array, the computational cost is is low. Key words: Basis interleaving array, Multidimensional interleaving, <b>error</b> <b>burst,</b> randomerror -correction codes...|$|E
30|$|In this section, {{we provide}} {{analytical}} results for delay guarantees. We assume that flows suffer from short <b>error</b> <b>bursts.</b>|$|R
3000|$|In {{order to}} gain {{resilience}} against <b>error</b> <b>bursts,</b> the resulting sequence is interleaved using an S-random interleaver π 2 with [...]...|$|R
40|$|Recently, CT <b>burst</b> <b>errors</b> {{originally}} dened for block codes havebeen {{generalized to}} CT <b>burst</b> <b>errors</b> for array codes [6]. In {{order to establish}} aRieger's type bound for array codes with respect to CT <b>burst</b> <b>errors.</b> Here, weintroduce a CT <b>burst</b> <b>error</b> weight enumerator whose coecients represent thenumber of CT <b>burst</b> <b>errors</b> of a particular weight. The method of obtainingthe CT <b>burst</b> <b>error</b> weight enumerator is obtained by generating function likeapproach {{and it does not}} involve solving equations as presented in [6]...|$|R
40|$|AbstractWe {{present an}} {{elementary}} theory of optimal interleaving schemes for correcting cluster errors in two-dimensional digital data. It {{is assumed that}} each data page contains a fixed number of, say n, codewords with each codeword consisting of m code symbols and capable of correcting a single random error (or erasure). The goal is to interleave the codewords in the m×n array such that different symbols from each codeword are separated as much as possible, and consequently, an arbitrary <b>error</b> <b>burst</b> with size up to t can be corrected for the largest possible value of t. We show that, for any given m, n, the maximum possible interleaving distance, or equivalently, the largest size of correctable error bursts in an m×n array, is given by t=⌊ 2 n⌋ if n⩽⌈m 2 / 2 ⌉, and t=m+⌊(n-⌈m 2 / 2 ⌉) /m⌋ if n⩾⌈m 2 / 2 ⌉. Furthermore, we develop a simple cyclic shifting algorithm that can provide a systematic construction of an m×n optimal interleaving array for arbitrary m and n. This extends important earlier work on the complementary problem of constructing interleaving arrays that, given the burst size t, minimize the interleaving degree, that is, the number of different codewords in a 2 -D (or 3 -D) array such that any <b>error</b> <b>burst</b> with given size t can be corrected. Our interleaving scheme thus provides the maximum burst error correcting power without requiring prior knowledge of the size or shape of an <b>error</b> <b>burst...</b>|$|E
30|$|Which generates (45, 33),(45, 29),(45, 23),(45, 11), (45, 7),(45, 5) and (45, 1) {{codes and}} corrects up to 1, 2, 3, 4, 7, 10, and 22 errors having code rate 0.733, 0.644, 0.511, 0.244, 0.155, 0.11, 0.022, respectively. Where the code (45, 33) is also capable of {{correcting}} any single <b>error</b> <b>burst</b> of length 3 or less by Remark 4.|$|E
30|$|In {{case of the}} 11 [*]Mbps channel, PLO has {{actually}} a degraded performance and Simple Positive-ACK is better than PLO in this particular case. SRVF, for the same data-rate, has improved the efficiency by 21 %. This has happened because PLO optimizes packet sized based on number of retransmissions in the current history. Simple BER statistics are not enough to analyze this factor and packet level statistics are required. It {{has been shown in}} [21] that mean packet <b>error</b> <b>burst</b> length for 11 [*]Mbps traces is 4.16 packets. For traces other than 11 [*]Mbps, mean packet <b>error</b> <b>burst</b> length is less than 2 packets. This explains the reason of failure of PLO because PLO adjusts the packet size based on the packet retransmission history. Given that 802.11 channels encounter large number of packet drops as compared to other traces, it is highly probable that most of the time PLO will transmit packets smaller than the optimal size and will degrade its energy efficiency.|$|E
50|$|Typically, {{the inner}} code {{is not a}} block code but a soft-decision {{convolutional}} Viterbi-decoded code with a short constraint length.For the outer code, a longer hard-decision block code, frequently a Reed-Solomon code with eight-bit symbols, is used.The larger symbol size makes the outer code more robust to <b>error</b> <b>bursts</b> that can occur due to channel impairments, and also because erroneous output of the convolutional code itself is bursty. An interleaving layer is usually added between the two codes to spread <b>error</b> <b>bursts</b> across a wider range.|$|R
30|$|Nature of the error: If the {{prediction}} algorithm mispredicts occupancy for short time intervals (say {{for a minute}} or so), we term {{the prediction}} errors as point errors, otherwise we call them <b>burst</b> <b>errors.</b> For a particular error percentage, an erroneous occupancy string can have point <b>errors,</b> <b>burst</b> <b>errors,</b> or a mix of both; resulting in different values of energy consumption and occupants’ discomfort for the same error percentage.|$|R
40|$|Abstract—Generative models {{hold the}} promise of {{reducing}} the computational load and cost caused by directly simulating a real system. They are vital to the design and performance evaluation of error control schemes and high layer wireless communication protocols. Therefore, designing an efficient and accurate generative model is highly desirable. Moreover, the errors encountered in digital wireless channels exhibit correlation among them. This stimulates us to construct a Markovian based generative model with two embedded processes. The first process is dedicated to assembling <b>error</b> <b>bursts</b> with error-free bursts, whereas the second one is devoted to creating individual <b>error</b> <b>bursts</b> employing the maximum gap norm within <b>error</b> <b>bursts.</b> This premise is utilized in this paper {{to show that the}} resulting generative model can generate error sequences with desired bit correlations and is capable of statistically matching a descriptive model, derived from an enhanced general packet radio service (EGPRS) transmission system, regardless of the configuration of its error sequences. I...|$|R
40|$|Abstract- The {{distribution}} of the output <b>error</b> <b>burst</b> lengths from a Vi te rb i decoder {{is of particular interest}} in connection wi th concatenated coding sys-tems, where the inner code is convolutional. From the expurgated, random, and sphere-packing exponents for block codes an upper bound on this distribution for the ensemble of periodically time-varying convo-lutional codes is obtained. Finally, the distribution obtained from simulating time-invariant convolutional codes is presented. I...|$|E
40|$|HELLO {{messages}} {{are widely used}} for neighbor discovery in routing protocols for wireless multihop networks. In this paper, we provide mathematical and experimental proofs that the current strategy of declaring a link down based on observations that a specific number of HELLO {{messages are}} lost, is 110 t a correct strategy. In our mathematical analysis, we characterized the error bursts over wireless links by extending the Gilbert bit error model, and validate our model using HELLO loss data from our wireless mesh testbed. Our analysis shows that <b>error</b> <b>burst</b> lengths follow a geometric distribution, i. e. the probability of additional losses in the burst {{does not depend on}} the observed losses. We propose an alternative link break detection strategy where a link break is declared when the observed mean <b>error</b> <b>burst</b> length for the link is longer than the mean route recovery time. Our testbed results show that running the AODV routing protocol with our proposed strategy yields better throughput and lower control message overhead, compared to the case where AODV relies on its default settings of declaring link breaks when two consecutive HELLO messages are lost...|$|E
40|$|Describes {{the design}} and {{realization}} of an error-correcting codec. For error protection of TV lines the realized codec utilizes a shortened (2196, 2136) BCH-code with 60 bits (2. 7 %) redundancy. The codec provides correction of 4 random errors or correction of one <b>error</b> <b>burst</b> up to 26 bits alternatively; 5 or 6 random errors can be detected. In the case of random errors the residual error rate after error correction is less than 10 - 8 even at 10 - 4 channel error rate...|$|E
5000|$|Time {{diversity}} {{implies that}} the same data is transmitted multiple times, or a redundant error correcting code is added. By means of bit-interleaving, the <b>error</b> <b>bursts</b> may be spread in time.|$|R
40|$|A {{system to}} combat <b>burst</b> <b>errors</b> due to {{scintillation}} fading on UHF satellite services has been developed, {{based on the}} principles of interleaving and forward error correction. The system provides a cost-effective alternative to maintaining high link margins. It is capable of correcting long <b>error</b> <b>bursts</b> during scintillation activity. In addition, it will provide considerable link performance enhancement during periods of no scintillation...|$|R
30|$|Other works {{address the}} {{application}} of LDPC to bursty channels, focusing on alternative more complex decoding algorithms, like those in [25, 26], or encoding algorithms, {{like the one in}} [27], as a mean to recover from <b>error</b> <b>bursts.</b>|$|R
40|$|Dependability {{is a vital}} system requirement, {{particularly}} in safety critical and mission critical real-time systems, due to the potentially catastrophic consequences of failures. In most critical applications different fault tolerance mecha-nisms using redundancy are employed to prevent possible failures. In the case of real-time systems the system de-signer must ensure that the task set is feasible even under faults, which we refer to as ’fault tolerance feasibility’. Due to cost considerations, often temporal redundancy has been prevalently used to meet this objective. In this paper we focus on guaranteeing fault-tolerance fea-sibility under error bursts on uni-processor systems by the usage of resource augmentation, specifically through proces-sor speed-up. Firstly, we derive a processor demand bound based sufficient condition {{for a set of}} real-time tasks to be fault tolerance feasible under an assumption that no more than one <b>error</b> <b>burst</b> occurs during the hyper-period of the task set. Subsequently, we derive the necessary resource augmentation bounds (i. e., the processor speed-up), that guarantees the fault tolerance feasibility, if the sufficient test fails. Finally, we prove that, if the <b>error</b> <b>burst</b> length is no more than half the shortest relative deadline of the task set, the minimum processor speed-up required to guarantee fault tolerance feasibility is upper-bounded by 6...|$|E
40|$|The {{application}} of a bit interlacing or time-spread coding to a class of convolutional codes is considered. Investigation is made into the bit spread distances required to facilitate the decoding of various maximum burst length errors. Results of a simulation, obtained using an I. B. M. 7040 digital computer, are presented. The channel model used in the simulation is one derived from the binary symmetric channel, but which provides for the generation of bursts of errors. The <b>error</b> <b>burst</b> lengths are uniformly distributed from one to a variable maximum burst length...|$|E
40|$|The {{study of}} {{statistical}} distribution of errors {{is a prerequisite}} {{in the design of}} appropriate coding techniques to effectively control errors. An architecture, V-BLAST, that promises very high spectral efficiency is analyzed and compared for two transmitter-receiver arrangements. We analyzed the system performance over Rayleigh and Nakagami channels along with statistical analysis of errors. Average <b>error</b> <b>burst</b> lengths, average error tree lengths and BER are determined. We also evaluate the effects of different interleaver depths. It is shown that increasing the number of transmitters and receivers, and uncorrelated channel paths give improved performance...|$|E
2500|$|Theorem (<b>Burst</b> <b>error</b> {{correction}} ability). The <b>burst</b> <b>error</b> correction {{ability of}} any [...] code satisfies ...|$|R
5000|$|Theorem (<b>Burst</b> <b>error</b> {{correction}} ability). The <b>burst</b> <b>error</b> correction {{ability of}} any [...] code satisfies ...|$|R
30|$|The {{proposed}} {{mechanism is}} indeed very simple but assures high probability of successful packet reception while reduces complexity avoiding retransmissions. However, {{in order to}} increase resistance for <b>error</b> <b>bursts,</b> replicated data packets should be transmitted in a scrambled order.|$|R
