62|56|Public
25|$|Assembly {{language}} is still taught in most computer science and electronic engineering programs. Although few programmers today regularly work with assembly {{language as a}} tool, the underlying concepts remain very important. Such fundamental topics as binary arithmetic, memory allocation, stack processing, character set encoding, <b>interrupt</b> <b>processing,</b> and compiler design {{would be hard to}} study in detail without a grasp of how a computer operates at the hardware level. Since a computer's behavior is fundamentally defined by its instruction set, the logical way to learn such concepts is to study an assembly language. Most modern computers have similar instruction sets. Therefore, studying a single assembly {{language is}} sufficient to learn: I) the basic concepts; II) to recognize situations where the use of assembly language might be appropriate; and III) to see how efficient executable code can be created from high-level languages. This is analogous to children needing to learn the basic arithmetic operations (e.g., long division), although calculators are widely used for all except the most trivial calculations.|$|E
5000|$|Two new {{instructions}} {{to save and}} restore the lower status register {{in order to simplify}} <b>interrupt</b> <b>processing.</b>|$|E
50|$|Instructions for device 0 {{affected}} the processor as a whole. For example, ION (6001) enabled <b>interrupt</b> <b>processing,</b> and IOFF (6002) disabled it.|$|E
40|$|A method aud system utilize a processor's digital timer and two {{interrupts}} to form {{a frequency}} multiplier. The first internipt's processing time window is definable by a first uumber of counts C(sub 1), of the digital timer while the second <b>interrupt's</b> <b>processing</b> time window is definable by a second number of counts C(sub 2) of the digital timer. A count value CV utilized by the systedmethod {{is based on a}} desired frequency multiplier N(sub 1), the timer clock rate, and the tiole required for one cycle of an input signal. The first interrupt is triggered upon completion of one cycle ofthe input sigual at which point the processing time window associated therewith begins. The second interrupt is triggered each time the timer's overflow signal is generated at which point the processing time window associated with the second interrupt begins. During the occurrence of the second <b>interrupt's</b> <b>processing.</b> the count value CV is modified to maintain the first <b>interrupt's</b> <b>processing</b> time window approximately centered between two of the second internipt's processing time windows...|$|R
40|$|There {{is offered}} theoretic and {{numerical}} approach to simulation of process of hardware <b>interrupts</b> <b>processing</b> i n microcontroller systems. By results of simulation the guidelines on optimization of a loading multitask microcontroller systems are given. ????????? ?????????-????????? ?????? ? ????????????? ???????? ????????? ?????????? ?????????? ? ?????????????????? ????????, ???????????? ? ???????? ?????????????? ????????????. ?? ??????????? ????????????? ???? ???????????? ?? ??????????? ???????? ????????????? ?????????????????? ??????...|$|R
40|$|Ultrathin {{epitaxial}} film of AIAs deposited on GaAs substrate {{to serve as}} Schottky barrier and/or as barrier to diffusion. Deposited without <b>interrupting</b> <b>processing</b> vacuum in which substrate deposited and in which any subsequent layers deposited. In new technique, {{epitaxial film}} of AIAs deposited directly on GaAs substrate to depth of only two atomic layers - less than 1 nanometer thick. Film thin enough so it does not constitute electronic barrier, but thick enough to act as barrier to interdiffusion of gold and GaAs. Film also used as barrier to interdiffusion of dopants at heterojunctions...|$|R
50|$|The DPDK {{implements}} a low overhead run-to-completion {{model for}} fast data plane performance and accesses devices via polling {{to eliminate the}} performance overhead of <b>interrupt</b> <b>processing.</b>|$|E
5000|$|On stack machines, {{temporary}} values {{often get}} spilled into memory, whereas on machines with many registers these temps usually remain in registers. (However, these values often {{need to be}} spilled into [...] "activation frames" [...] {{at the end of}} a procedure's definition, basic block, or at the very least, into a memory buffer during <b>interrupt</b> <b>processing).</b> Values spilled to memory add more cache cycles. This spilling effect depends on the number of hidden registers used to buffer top-of-stack values, upon the frequency of nested procedure calls, and upon host computer <b>interrupt</b> <b>processing</b> rates.|$|E
50|$|CLOAKING {{integrates}} into {{and works with}} existing virtual memory control programs, without switching descriptor tables or resetting the control registers. This allows for faster <b>interrupt</b> <b>processing,</b> according to Helix's documentation.|$|E
5000|$|Subliminal stimuli ( [...] ; {{literally}} [...] "below threshold"), {{contrary to}} [...] stimuli or [...] "above threshold", are any sensory stimuli below an individual's threshold for conscious perception. A recent review of functional {{magnetic resonance imaging}} (fMRI) studies shows that subliminal stimuli activate specific regions of the brain despite participants being unaware. Visual stimuli may be quickly flashed before an individual can process them, or flashed and then masked, thereby <b>interrupting</b> the <b>processing.</b> Audio stimuli may be played below audible volumes or masked by other stimuli.|$|R
40|$|Microprogram scheme enables {{computer}} {{to recover from}} failure {{in one of its}} two central processing units during time duration of instruction in which failure occurs. Microprogram advantages include - / 1 / built-in interpretive capability, / 2 / selection of <b>processing</b> <b>interrupts</b> by priority, and / 3 / economical use of bootstrap sequence...|$|R
5|$|A {{radiocarbon}} dating {{analysis of the}} papyrus by the Arizona Accelerator Mass Spectrometry Laboratory in 2013 dated the papyrus to between 404 and 209 BC. However, the cleaning protocol had to be <b>interrupted</b> during <b>processing</b> to preserve the fragment. A second analysis was performed by Harvard University and the Woods Hole Oceanographic Institution found a mean date of AD 741. A Raman spectroscopy analysis at Columbia University found that the ink was consistent with those in manuscripts from 400 BC to AD 700â€“800. These analyses suggest that the fragment as a material artifact is probably medieval and not modern.|$|R
50|$|An End Of Interrupt (EOI) is {{a signal}} {{sent to a}} Programmable Interrupt Controller (PIC) to {{indicate}} the completion of <b>interrupt</b> <b>processing</b> for a given interrupt. An EOI is used to cause a PIC to clear the corresponding bit in the In-Service Register (ISR), and thus allow more interrupt requests of equal or lower priority to be generated by the PIC.|$|E
50|$|To improve normal {{processing}} speed, 7502 {{used two}} sets of 16 bit registers. Each set had 16 registers, with 15 being used for general purpose operations, {{and the last one}} used as an instruction pointer. All writes went to both register sets, but reads were taken from one set with a simultaneous read of a different register being possible from the second set. When an interrupt occurred, one register set was frozen, and the second set was diverted to process the interrupt. After the interrupt was completed, the frozen set was copied back to the second set to resume normal operation. During <b>interrupt</b> <b>processing,</b> special functions allowed the frozen registers to be backed up to memory and different contents to be loaded to switch to a different process. The block manipulating functions described above were able to accept an interrupt part way through their execution so that manipulating very large blocks did not adversely affect <b>interrupt</b> <b>processing.</b>|$|E
50|$|A SLIH completes long <b>interrupt</b> <b>processing</b> tasks {{similarly}} to a process. SLIHs either have a dedicated kernel thread for each handler, or are executed by {{a pool of}} kernel worker threads. These threads sit on a run queue in the operating system until processor time is available for them to perform processing for the interrupt. SLIHs may have a long-lived execution time, and thus are typically scheduled {{similarly to}} threads and processes.|$|E
50|$|In {{computer}} science, a vectored <b>interrupt</b> is a <b>processing</b> {{technique in}} which the interrupting device directs the processor to the appropriate interrupt service routine. This {{is in contrast to}} a polled interrupt system, in which a single interrupt service routine must determine the source of the interrupt by checking all potential interrupt sources, a slow and relatively laborious process.|$|R
50|$|In the RTC model, {{the system}} {{processes}} events in discrete, indivisible RTC steps. New incoming events cannot <b>interrupt</b> the <b>processing</b> {{of the current}} event and must be stored (typically in an event queue) until the state machine becomes idle again. These semantics completely avoid any internal concurrency issues within a single state machine. The RTC model also gets around the conceptual problem of processing actions associated with transitions, where the state machine {{is not in a}} well-defined state (is between two states) {{for the duration of the}} action. During event processing, the system is unresponsive (unobservable), so the ill-defined state during that time has no practical significance.|$|R
40|$|Over {{the last}} years, many replica control {{protocols}} {{have been developed}} that {{take advantage of the}} ordering and reliability semantics of group communication primitives to simplify database system design and to improve performance. Although current solutions are able to mask site failures effectively, many of them are unable to cope with recovery of failed sites, merging of partitions, or joining of new sites. This paper addresses this important issue. It proposes efficient solutions for online system reconfiguration providing new sites with a current state of the database without <b>interrupting</b> transaction <b>processing</b> {{in the rest of the}} system. Furthermore, the paper analyzes the impact of cascading reconfigurations, and argues that they can be handled in an elegant way by extended forms of group communication. 1...|$|R
50|$|EOIs may {{indicate}} the interrupt vector implicitly, or explicitly. An explicit EOI vector is indicated with the EOI, whereas an implicit EOI vector will typically use a vector {{as indicated by}} the PICs priority schema. For example, the highest vector in the ISR. Also, EOIs may be sent at the end of <b>interrupt</b> <b>processing</b> by an interrupt handler, or the operation of a PIC may be set to auto-EOI {{at the start of the}} interrupt handler.|$|E
50|$|The NVMe device {{interface}} {{has been designed}} from the ground up, capitalizing on the low latency and parallelism of PCI Express SSDs, and complementing the parallelism of contemporary CPUs, platforms and applications. At a high level, the basic advantages of NVMe over AHCI relate to its ability to exploit parallelism in host hardware and software, manifested by the differences in command queue depths, efficiency of <b>interrupt</b> <b>processing,</b> the number of uncacheable register accesses, etc., resulting in various performance improvements.|$|E
5000|$|The virus code itself hooks into <b>interrupt</b> <b>processing</b> {{and other}} low level DOS services. For example, code in the virus {{suppresses}} the printing of console messages if, for example, {{the virus is}} not able to infect a file on a read-only device such as a floppy disk. One of the clues that a computer is infected is the mis-capitalization of the well-known message [...] "Bad command or file name" [...] as [...] "Bad Command or file name".|$|E
40|$|The two-process {{theory of}} detection, search, and {{attention}} presented by Schneider and Shiffrin is tested and extended {{in a series}} of experiments. The studies demonstrate the qualitative difference between two modes of information processing: automatic detection and controlled search. They trace the course of the learning of automatic detection, of categories, and of automaticattention responses. They show the dependence of automatic detection on attending responses and demonstrate how such responses <b>interrupt</b> controlled <b>processing</b> and interfere with the focusing of attention. The learning of categories is shown to improve controlled search performance. A general framework for human information processing is proposed; the framework emphasizes the roles of automatic and controlled processing. The theory is compared to and contrasted with extant models of search and attention...|$|R
40|$|Delirium, or acute confusional syndrome, {{is a set}} of {{symptoms}} whose care involves not only psychiatry, but also many other medical specialties. Being as how the syndrome is caused by multiple factors, {{it is important to recognize}} each risk factor affecting the patient in order to anticipate and prevent it. In case of diagnosis, identifying and treating the root cause that triggered is important, given that it has a high rate of comorbidity and an elevated cost of medical care. We describe a case where a patient with hypothyroidism began suffering from delirium due to an abrupt discontinuation of levothyroxine treatment. Previously, the patient was seemingly healthy. After the medical treatment was <b>interrupted,</b> sensory <b>processing</b> and behavior were altered, and symptoms fluctuated, for a short period of time, showing disorientation and memory and language impairment...|$|R
50|$|Interrupts provide low {{overhead}} and good latency at low load, but degrade significantly at high interrupt rate unless care {{is taken to}} prevent several pathologies. These are various forms of livelocks, when the system spends all of its time <b>processing</b> <b>interrupts</b> {{to the exclusion of}} other required tasks. Under extreme conditions, a large number of interrupts (like very high network traffic) may completely stall the system. To avoid such problems, an operating system must schedule network interrupt handling as carefully as it schedules process execution.|$|R
5000|$|Note {{that the}} {{processor}} does not push the accumulator and index registers {{on to the}} stack - code in the interrupt handler must perform that task, as well as restore the registers at the termination of <b>interrupt</b> <b>processing,</b> as necessary. Also note that the vector for [...] {{is the same as}} that for [...] in all eight bit 65xx processors, {{as well as in the}} 65C802/65C816 when operating in emulation mode. When operating in native mode, the 65C802/65C816 provide separate vectors for [...] and [...]|$|E
50|$|Polling is an {{alternative}} to interrupt-based processing. The kernel can periodically check {{for the arrival of}} incoming network packets without being interrupted, which eliminates the overhead of <b>interrupt</b> <b>processing.</b> Establishing an optimal polling frequency is important, however. Too frequent polling wastes CPU resources by repeatedly checking for incoming packets that have not yet arrived. On the other hand, polling too infrequently introduces latency by reducing system reactivity to incoming packets, and it may result in the loss of packets if the incoming packet buffer fills up before being processed.|$|E
50|$|Because <b>interrupt</b> <b>processing</b> is {{typically}} a non-preemptible task in time-sharing operating systems, an interrupt storm will cause sluggish response to user input, or even appear {{to freeze the}} system completely. This state {{is commonly known as}} live lock. In such a state, the system is spending most of its resources processing interrupts instead of completing other work. To the end-user, it {{does not appear to be}} processing anything at all as there is often no output. An interrupt storm is sometimes mistaken for thrashing, since they both have similar symptoms (unresponsive or sluggish response to user input, little or no output).|$|E
40|$|Abstract: The {{endoplasmic}} reticulum (ER) {{is responsible for}} processing of proteins that are destined to be secreted, enclosed in a vesicle, or incorporated in the plasma membrane. Nascent peptides that enter the ER undergo a series of highly regulated processing steps to reach maturation as they transit the ER. Alterations in the intracellular environment that induce ER stress are thought to <b>interrupt</b> these <b>processing</b> steps, and result in unfolding of proteins in the ER. Accumulation of unfolded proteins concurrently activates three transmembrane stress sensors, IRE 1, ATF 6 and PERK, and {{is referred to as}} the Unfolded Protein Response (UPR). Our understanding of the mechanisms of UPR induction has been assembled primarily from experiments inducing ER stress with chemical and genetic manipulations. However, physiological stress often induces activation of ER stress sensors in a distinct manner from the canonical UPR. The unique activation profiles in vivo have prompte...|$|R
40|$|In {{the study}} of solar-terrestrial physics there is {{frequently}} a requirement to combine and compare data from different instruments, of either the same type or of different types. This paper presents a Multi-Instrument Analysis (MIA) toolbox for Matlab. By using object-oriented programming techniques it is shown that the same tools {{can be applied to}} data from different instruments, or even instruments of different types. A coherent structure enables MIA to display image plots, keograms and movies for all imaging instruments, regardless of type. Data files are joined automatically so that file boundaries do not <b>interrupt</b> data <b>processing.</b> Although a graphical user interface is available all operations can be performed by scripts, thereby permitting automated data processing. By simplifying data processing MIA aids the creation of new data products such as energy maps and event databases. MIA currently supports riometers and imaging riometers, magnetometers and all-sky cameras...|$|R
2500|$|Early {{computers}} were built {{to perform a}} series of single tasks, like a calculator. Basic operating system features were developed in the 1950s, such as resident monitor functions that could automatically run different programs in succession to speed up processing. Operating systems {{did not exist in}} their modern and more complex forms until the early 1960s. [...] Hardware features were added, that enabled use of runtime libraries, <b>interrupts,</b> and parallel <b>processing.</b> When personal computers became popular in the 1980s, operating systems were made for them similar in concept to those used on larger computers.|$|R
5000|$|PCI Express SSDs can be {{interfaced}} {{through the}} NVMe driver. NVMe is a high-performance and scalable host controller interface designed and optimized especially for interfacing with PCI Express SSDs. NVMe {{has been designed}} from the ground up, capitalizing on the low latency and parallelism of PCI Express SSDs, and complementing the parallelism of contemporary CPUs, platforms and applications. At a high level, primary advantages of NVMe over AHCI relate to NVMe's ability to exploit parallelism in host hardware and software, based on its design advantages that include data transfers with fewer stages, greater depth of command queues, and more efficient <b>interrupt</b> <b>processing.</b>|$|E
5000|$|Used for PCI Express SSDs and {{interfaced}} {{through the}} NVMe driver and provided PCI Express lanes, as a high-performance and scalable host controller interface designed and optimized especially for interfacing with PCI Express SSDs. NVMe {{has been designed}} from the ground up, capitalizing on the low latency and parallelism of PCI Express SSDs, and complementing the parallelism of contemporary CPUs, platforms and applications. At a high level, primary advantages of NVMe over AHCI relate to NVMe's ability to exploit parallelism in host hardware and software, based on its design advantages that include data transfers with fewer stages, greater depth of command queues, and more efficient <b>interrupt</b> <b>processing.</b>|$|E
50|$|Type 1 and Type 4 Channel Adapters were {{designed}} for 270x emulation. They recognized up to 256 channel addresses and transferred data in small bursts (four bytes for the Type 1; 32 bytes maximum for the Type 4). The hardware could accept {{almost all of the}} 240 possible channel command codes. Software had to analyse the command from the channel and either reject the command or process it according to specific rules. <b>Interrupt</b> <b>processing</b> required about fifty storage cycles to process a four byte transfer. The 3705 could only have a single Type 1 Adapter but two Type 4 Adapters were permitted. An Amdahl 4705 could have four Type 4 channel adapters (Type 1 channel adapters were not offered).|$|E
40|$|Device {{drivers are}} a very {{critical}} part of every operating system. They often contain code that is executed in interrupt handlers. During the execution of <b>interrupt</b> handlers, the <b>processing</b> of some other interrupts is usually disabled. Thus errors in that code can compromise the whole system. This paper describes an approach to ensure that an interrupt handler {{is not allowed to}} use more than a specified amount of time. Our approach is based on a Java operating system and consists of a combination of verification at com-pilation time and run-time checks. ...|$|R
5000|$|Early {{computers}} were built {{to perform a}} series of single tasks, like a calculator. Basic operating system features were developed in the 1950s, such as resident monitor functions that could automatically run different programs in succession to speed up processing. Operating systems {{did not exist in}} their modern and more complex forms until the early 1960s. [...] Hardware features were added, that enabled use of runtime libraries, <b>interrupts,</b> and parallel <b>processing.</b> When personal computers became popular in the 1980s, operating systems were made for them similar in concept to those used on larger computers.|$|R
40|$|The {{endoplasmic}} reticulum (ER) {{is responsible for}} processing of proteins that are destined to be secreted, enclosed in a vesicle, or incorporated in the plasma membrane. Nascent peptides that enter the ER undergo a series of highly regulated processing steps to reach maturation as they transit the ER. Alterations in the intracellular environment that induce ER stress are thought to <b>interrupt</b> these <b>processing</b> steps, and result in unfolding of proteins in the ER. Accumulation of unfolded proteins concurrently activates three transmembrane stress sensors, IRE 1, ATF 6 and PERK, and {{is referred to as}} the Unfolded Protein Response (UPR). Our understanding of the mechanisms of UPR induction has been assembled primarily from experiments inducing ER stress with chemical and genetic manipulations. However, physiological stress often induces activation of ER stress sensors in a distinct manner from the canonical UPR. The unique activation profiles in vivo have prompted us to examine the mechanism of UPR activation in neurons following cerebral ischemia...|$|R
