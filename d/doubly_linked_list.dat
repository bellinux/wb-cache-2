93|1669|Public
25|$|A {{technique}} {{known as}} XOR-linking allows a <b>doubly</b> <b>linked</b> <b>list</b> {{to be implemented}} using a single link field in each node. However, this technique requires {{the ability to do}} bit operations on addresses, and therefore may not be available in some high-level languages.|$|E
25|$|Double-linked lists {{require more}} space per node (unless one uses XOR-linking), and their {{elementary}} operations are more expensive; {{but they are}} often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a <b>doubly</b> <b>linked</b> <b>list,</b> one can insert or delete a node in a constant number of operations given only that node's address. To {{do the same in}} a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures.|$|E
2500|$|A <b>doubly</b> <b>linked</b> <b>list</b> whose nodes contain three fields: {{an integer}} value, the link {{forward to the}} next node, and the link {{backward}} to the previous node ...|$|E
5000|$|An XOR <b>linked</b> <b>list</b> is a data {{structure}} used in computer programming. It {{takes advantage of}} the bitwise XOR operation to decrease storage requirements for <b>doubly</b> <b>linked</b> <b>lists.</b>|$|R
25|$|The {{alternatives}} {{listed above}} may be arbitrarily combined {{in almost every}} way, so one may have circular <b>doubly</b> <b>linked</b> <b>lists</b> without sentinels, circular singly <b>linked</b> <b>lists</b> with sentinels, etc.|$|R
5000|$|As in <b>doubly</b> <b>linked</b> <b>lists,</b> [...] "removeAfter" [...] and [...] "removeBefore" [...] can be {{implemented}} with [...] "remove(list, node.prev)" [...] and [...] "remove(list, node.next)".|$|R
2500|$|In {{the case}} of a {{circular}} <b>doubly</b> <b>linked</b> <b>list,</b> the only change that occurs is that the end, or [...] "tail", of the said list is linked back to the front, or [...] "head", of the list and vice versa.|$|E
2500|$|The same trick {{can be used}} {{to simplify}} the {{handling}} of a doubly linked linear list, by turning it into a circular <b>doubly</b> <b>linked</b> <b>list</b> with a single sentinel node. [...] However, in this case, the handle should be a single pointer to the dummy node itself.|$|E
5000|$|An {{asymmetric}} <b>doubly</b> <b>linked</b> <b>list</b> {{is somewhere}} between the singly linked list and the regular <b>doubly</b> <b>linked</b> <b>list.</b> It shares some features with the singly linked list (single-direction traversal) and others from the <b>doubly</b> <b>linked</b> <b>list</b> (ease of modification) ...|$|E
2500|$|Merge sort can {{be adapted}} to operate on singly <b>linked</b> <b>lists</b> with [...] extra space. Heapsort {{can be adapted}} to operate on <b>doubly</b> <b>linked</b> <b>lists</b> with only [...] extra space overhead.|$|R
50|$|Recalls {{his first}} {{instance}} of learning functional programming when taking a course by Arthur Norman who showed {{how to build}} <b>doubly</b> <b>linked</b> <b>lists</b> without any side effects at all.|$|R
25|$|Difficulties {{arise in}} <b>linked</b> <b>lists</b> {{when it comes}} to reverse traversing. For instance, singly <b>linked</b> <b>lists</b> are {{cumbersome}} to navigate backwards and while <b>doubly</b> <b>linked</b> <b>lists</b> are somewhat easier to read, memory is consumed in allocating space for a back-pointer.|$|R
5000|$|Initialize {{an empty}} <b>doubly</b> <b>linked</b> <b>list</b> L and 2-4 tree T. Set k and n to zero.|$|E
50|$|XOR linked lists {{leverage}} XOR {{properties in}} order to save space to represent <b>doubly</b> <b>linked</b> <b>list</b> data structures.|$|E
5000|$|The idea of DLX {{is based}} on the {{observation}} that in a circular <b>doubly</b> <b>linked</b> <b>list</b> of nodes, ...|$|E
25|$|Many modern {{operating}} systems use <b>doubly</b> <b>linked</b> <b>lists</b> to maintain references to active processes, threads, and other dynamic objects. A common strategy for rootkits to evade detection is to unlink themselves from these lists.|$|R
5000|$|In a nutshell, SLIP {{consisted}} {{of a set of}} FORTRAN [...] "accessor" [...] functions which operated on circular <b>doubly</b> <b>linked</b> <b>lists</b> with fixed-size data fields. The [...] "accessor" [...] functions had direct and indirect addressing variants.|$|R
50|$|In <b>doubly</b> <b>linked</b> <b>lists</b> or tree structures, a {{back pointer}} held on an element 'points back' to the item {{referring}} to the current element. These are useful for navigation and manipulation, {{at the expense of}} greater memory use.|$|R
50|$|A <b>doubly</b> <b>linked</b> <b>list</b> has O(1) {{insertion}} and deletion at both ends, so is {{a natural}} choice for queues.|$|E
5000|$|XOR linked list, a <b>doubly</b> <b>linked</b> <b>list</b> {{that uses}} one XORed pointer per node {{instead of two}} {{ordinary}} pointers.|$|E
5000|$|An {{ordinary}} <b>doubly</b> <b>linked</b> <b>list</b> stores {{addresses of}} the previous and next list items in each list node, requiring two address fields: ...|$|E
5000|$|XOR <b>linked</b> <b>lists</b> do {{not provide}} some of the {{important}} advantages of <b>doubly</b> <b>linked</b> <b>lists,</b> {{such as the ability}} to delete a node from the list knowing only its address or the ability to insert a new node before or after an existing node when knowing only the address of the existing node.|$|R
5000|$|Corecursion, {{referred}} to as circular programming, dates at least to , who credits John Hughes and Philip Wadler; more general forms were developed in [...] The original motivations included producing more efficient algorithms (allowing 1 pass over data in some cases, instead of requiring multiple passes) and implementing classical data structures, such as <b>doubly</b> <b>linked</b> <b>lists</b> and queues, in functional languages.|$|R
50|$|One of the {{advantages}} of DCAS is the ability to implement atomic deques (i.e. <b>doubly</b> <b>linked</b> <b>lists)</b> with relative ease.More recently, however, {{it has been shown that}} an STM can be implemented with comparable properties using only CAS. In general however, DCAS is not a silver bullet: implementing lock-free and wait-free algorithms using it is typically just as complex and error-prone as for CAS.|$|R
5000|$|Python 2.4 {{introduced}} the [...] module with support for deque objects. It is implemented using a <b>doubly</b> <b>linked</b> <b>list</b> of fixed-length subarrays.|$|E
50|$|The data {{structure}} {{consists of a}} <b>doubly</b> <b>linked</b> <b>list</b> and a 2-4 tree {{data structure}}, each modified {{to keep track of}} its minimum-priority element.The basic operation of the structure is to keep newly inserted elements in the <b>doubly</b> <b>linked</b> <b>list,</b> until a deletion would remove one of the list items, at which point they are all moved into the 2-4 tree. The 2-4 tree stores its elements in insertion order, rather than the more conventional priority-sorted order.|$|E
50|$|There are {{at least}} two common ways to {{efficiently}} implement a deque: with a modified dynamic array or with a <b>doubly</b> <b>linked</b> <b>list.</b>|$|E
5000|$|This simple {{function}} inserts a node into a <b>doubly</b> <b>linked</b> circularly <b>linked</b> <b>list</b> after a given element: ...|$|R
40|$|We present TVLA (Three-Valued-Logic Analysis engine). TVLA is a "YACC"-like {{framework}} for automatically constructing static-analysis algorithms from an operational semantics, where the operational semantics is specified using logical formulae. TVLA was implemented in Java and was successfully used to perform shape analysis on programs manipulating linked data structures (singly and <b>doubly</b> <b>linked</b> <b>lists),</b> to prove safety properties of Mobile Ambients, and {{to verify the}} partial correctness of several sorting programs...|$|R
25|$|In a 'multiply linked list', each node {{contains}} {{two or more}} link fields, each field being used to connect {{the same set of}} data records in a different order (e.g., by name, by department, by date of birth, etc.). While <b>doubly</b> <b>linked</b> <b>lists</b> can be seen as special cases of multiply <b>linked</b> <b>list,</b> the fact that the two orders are opposite to each other leads to simpler and more efficient algorithms, so they are usually treated as a separate case.|$|R
5000|$|... // Insert a node into a <b>doubly</b> <b>linked</b> <b>list</b> atomically atomic { newNode->prev = node; newNode->next = node->next; node->next->prev = newNode; node->next = newNode; } ...|$|E
5000|$|... #Caption: A <b>doubly</b> <b>linked</b> <b>list</b> whose nodes contain three fields: {{an integer}} value, {{the link to}} the next node, and the link to the {{previous}} node.|$|E
50|$|In the 1980s, EINE was {{developed}} into ZWEI. Innovations included programmability in Lisp Machine Lisp, {{and a new}} and more flexible <b>doubly</b> <b>linked</b> <b>list</b> method of internally representing buffers.|$|E
25|$|Linear singly <b>linked</b> <b>lists</b> {{also allow}} tail-sharing, {{the use of}} a common final portion of {{sub-list}} as the terminal portion of two different lists. In particular, if a new node is added {{at the beginning of a}} list, the former list remains available as the tail of the new one— a simple example of a persistent data structure. Again, this is not true with the other variants: a node may never belong to two different circular or <b>doubly</b> <b>linked</b> <b>lists.</b>|$|R
50|$|In a 'multiply linked list', each node {{contains}} {{two or more}} link fields, each field being used to connect {{the same set of}} data records in a different order (e.g., by name, by department, by date of birth, etc.). While <b>doubly</b> <b>linked</b> <b>lists</b> can be seen as special cases of multiply <b>linked</b> <b>list,</b> the fact that the two orders are opposite to each other leads to simpler and more efficient algorithms, so they are usually treated as a separate case.|$|R
50|$|Linear singly <b>linked</b> <b>lists</b> {{also allow}} tail-sharing, {{the use of}} a common final portion of {{sub-list}} as the terminal portion of two different lists. In particular, if a new node is added {{at the beginning of a}} list, the former list remains available as the tail of the new one — a simple example of a persistent data structure. Again, this is not true with the other variants: a node may never belong to two different circular or <b>doubly</b> <b>linked</b> <b>lists.</b>|$|R
