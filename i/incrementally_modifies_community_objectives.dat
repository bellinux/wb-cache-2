0|1618|Public
50|$|The {{date of the}} {{production}} of the written texts does not define the date of origin of the Puranas. They existed in an oral form before being written down, and were <b>incrementally</b> <b>modified</b> well into the 16th century.|$|R
40|$|With the {{decreasing}} feature sizes during VLSI fabrication and {{the dominance}} of interconnect delay over that of gates, control logic and wiring {{no longer have a}} negligible impact on delay and area. The need thus arises for developing techniques and tools to redesign incrementally to eliminate performance bottlenecks. Such a redesign effort corresponds to <b>incrementally</b> <b>modifying</b> an existing schedule obtained via high-level synthesis. In this paper we demonstrate that applying architectural retiming, a technique for pipelining latency-constrained circuits, results in <b>incrementally</b> <b>modifying</b> an existing schedule. Architectural retiming reschedules fine grain operations (ones that have a delay equal to or less than one clock cycle) to occur in earlier time steps, while modifying the design to preserve its correctness...|$|R
40|$|Consider a rooted {{tree with}} its leaves aligned on a {{horizontal}} line. The tree and its mirror image {{below the line}} give us a reflected tree. This is a natural structure for protection and sharing with nodes corresponding to protection groups, partially ordered by the subgroup relation. Reflected trees have an efficient representation which can be <b>incrementally</b> <b>modified</b> as the tree is changed...|$|R
50|$|While {{there are}} many ways that {{software}} can automatically generate code, Roo operates by generating AspectJ inter-type declarations (otherwise known as mixins or introductions). This achieves separation of concerns, as the code maintained by Roo is in a different compilation unit from the code a user writes. This means Roo can <b>incrementally</b> <b>modify</b> the AspectJ inter-type declarations that it needs to and leave all other files intact.|$|R
25|$|The Umnumzaan blade pivot is {{implemented}} with a pivot screw and pin, and {{is supported by}} perforated phosphor bronze thrust washers. The functions of the perforations are to reduce friction due {{to a reduction in}} surface area relative to that of a solid washer, and to increase the duration of use between cleanings by housing lubricant in the perforations. Over the life of the Umnumzaan, the pivot and washers have been <b>incrementally</b> <b>modified.</b>|$|R
50|$|In {{contemporary}} memory M-10000 {{has long}} since been eclipsed by the Pioneer Zephyr, but the M-10000 was the first streamliner on the rails and the first streamliner media sensation. Diesel-powered trainsets built for Union Pacific in 1935 and 1936 were evolved from the M-10000 design. The paint scheme devised for the M-10000 became the trademark color scheme for Union Pacific streamliners, <b>incrementally</b> <b>modified</b> to Union Pacific's current scheme with Harbor Mist Gray.|$|R
40|$|AspectJ, {{is the use}} {{of advice}} to <b>incrementally</b> <b>modify</b> the {{behavior}} of a program. An advice declaration specifies an action to be taken whenever some condition arises during the execution of the program. The condition is specified by a formula called a pointcut designator or pcd. The events during execution at which advice may be triggered are called join points. In this model of aspectoriented programming, join points are dynamic in that they refer to events during the execution of the program...|$|R
40|$|Abstract. Inheritance is a {{mechanism}} for <b>incrementally</b> <b>modifying</b> recursive definitions. While inheritance is typically used in object-oriented languages, inheritance also has something to offer to functional programming. In this paper we illustrate the use of inheritance in a pure functional language by developing a small library for memoization. We define monadic memoization mixins that compose—via inheritance—with an ordinary monadic function to create a memoized version of the function. A comparison {{of the performance of}} different approaches shows that memoization mixins are efficient for a small example. 1...|$|R
40|$|We propose {{algorithms}} to <b>incrementally</b> <b>modify</b> a mesh of a planar domain by interactively inserting {{and removing}} elements (points, segments, polygonal lines, etc.) into {{or from the}} planar domain, keeping {{the quality of the}} mesh during the process. Our algorithms, that combine mesh improvement techniques, achieve quality by deleting, moving or inserting Steiner points from or into the mesh. The changes applied to the mesh are local and the number of Steiner points added during the process remains low. Moreover, our approach can also be applied to the directly generation of refined Delaunay quality meshes...|$|R
40|$|Truth {{maintenance}} {{systems have}} been used in recently developed problem solving systems. A truth maintenance system (TMS) is designed to be used by deductive systems to maintain the logical relations among the beliefs which those systems manipulate. These relations are used to <b>incrementally</b> <b>modify</b> the belief structure when premises are changed, giving a more flexible context mechanism than has been present in earlier artificial intelligence systems. The relations among beliefs {{can also be used to}} directly trace the source of contradictions or failures, resulting in far more efficient backtracking...|$|R
40|$|A {{visually}} interactive {{approach to}} the design of 3 D computer- animated legged animal motion {{in the context of the}} PODA computer animation system is presented. The design process entails the interactive specification of parameters that drive a computational model for animal movement. The animator <b>incrementally</b> <b>modifies</b> a framework for establishing desired limb and body motion as well as the constraints imposed by physical dynamics (Newtonian mechanical properties) and temporal restrictions. PODA uses the desired motion and constraints specified by the animator to produce motion through an idealized model of the animal's adaptive dynamic control strategie...|$|R
40|$|Previous {{forms of}} LFSR {{reseeding}} have been static (i. e., test application is stopped while each seed is loaded) and have required full reseeding (i. e., {{the length of}} the seed is equal to {{the length of the}} LFSR). A new form of LFSR reseeding is described here that is dynamic (i. e., the seed is <b>incrementally</b> <b>modified</b> while test application proceeds) and allows partial reseeding (i. e. length of the seed is less than that of the LFSR). In addition to providing better encoding efficiency, partial dynamic LFSR reseeding has a simpler hardware implementation than previous schemes based on multiple-polynomial LFSRs...|$|R
40|$|Abstract—Task-centric {{wireless}} {{sensor network}} environments are often characterized by the simultaneous operation of multiple tasks. Individual tasks compete for constrained resources and thus need resource mediation algorithms at two levels. First, different sensors must be allocated to different tasks based on the combination of sensor attributes and task requirements. Subsequently, sensor data rates on various data routes must be dynamically adapted to share the available wireless bandwidth, especially when links experience traffic congestion. In this paper we investigate heuristics for <b>incrementally</b> <b>modifying</b> the sensor-task matching process to incorporate changes in the transport capacity constraints or feasible task utility values. I...|$|R
5000|$|... 4. Provide {{accurate}} {{information to the}} <b>community,</b> <b>objective</b> and scientific rigor on the specialty.|$|R
25|$|The Tampa Bay Rowdies {{became the}} primary tenant in 2011, and Al Lang Stadium was <b>incrementally</b> <b>modified</b> {{for use as}} a soccer venue for the next several off-seasons. Since October 2014, an {{agreement}} between the club and the city of St. Petersburg has made the stadium a soccer-only facility, and the Rowdies' ownership conducted an extensive renovation in early 2015. In 2016, Rowdies' majority owner Bill Edwards proposed greatly expanding the stadium's capacity to 18,000 seats as part of a bid to move his club into Major League Soccer. In May 2017, a local referendum passed authorizing the city of St. Petersburg to negotiate a long-term lease with the team to help make the project possible.|$|R
40|$|Over {{the past}} three decades, the role of ‘institutions’ on {{dynamics}} of regional development has attracted increasing attention and controversy across regional economic studies. However, the useful and characteristic regional institutional approach, as an independent academic discipline, has been rarely shown, and little is known what kind of institutions can be learnt for regional economic policy. The aim in this paper, therefore, is, first, to survey several institutional approaches to regional economic study, and, second, to discuss their policy implications by studying the regional economic policy in contemporary Japan. Finally, I argue {{that it will be}} productive for regional studies to explore ‘regional institutions’ which experimentally enlarge multi-level institutional conditions and <b>incrementally</b> <b>modify</b> the path dependency...|$|R
50|$|The Tampa Bay Rowdies {{became the}} primary tenant in 2011, and Al Lang Stadium was <b>incrementally</b> <b>modified</b> {{for use as}} a soccer venue for the next several off-seasons. Since October 2014, an {{agreement}} between the club and the city of St. Petersburg has made the stadium a soccer-only facility, and the Rowdies' ownership conducted an extensive renovation in early 2015. In 2016, Rowdies' majority owner Bill Edwards proposed greatly expanding the stadium's capacity to 18,000 seats as part of a bid to move his club into Major League Soccer. In May 2017, a local referendum passed authorizing the city of St. Petersburg to negotiate a long-term lease with the team to help make the project possible.|$|R
5000|$|One of the {{features}} that distinguishes HeuristicLab from many other metaheuristic software frameworks is the algorithm designer. HeuristicLab allows to model algorithms in a graphical way without having to write any source code. Algorithms in HeuristicLab are a composition of operators which are chained together. This sequence of operators is called the operator graph and can be viewed and edited for any algorithm in HeuristicLab. HeuristicLab also offers a so called Programmable Operator that can include source code which can be written from within HeuristicLab. Seeing how other algorithms work allows to try out new ideas by starting from an existing algorithm and <b>incrementally</b> <b>modifying</b> it. Of course new algorithms can also be created by writing code.|$|R
5000|$|Adjusted (<b>modified)</b> <b>community</b> rating — allows {{insurers}} to also vary rates based on demographic characteristics (e.g. age and gender) and lifestyle factors (e.g. tobacco use) ...|$|R
5000|$|Initiate {{or develop}} {{proposals}} for consideration and {{decision by the}} relevant Organs {{in order to achieve}} <b>Community</b> <b>objectives</b> ...|$|R
5000|$|... {{initiating}} or developing {{proposals for}} consideration and {{decision by the}} competent Organs {{in order to achieve}} <b>Community</b> <b>objectives</b> ...|$|R
40|$|A {{collection}} of algorithms and data structures are presented which provide incremental dispatch table modification. <b>Incrementally</b> <b>modified</b> dispatch tables allow table-based dispatch techniques {{to be used}} in reflective, dynamically typed, single-receiver languages with type/implementation-paired multiple inheritance. By storing a small amount of information, the algorithms can incrementally maintain the entire dispatch environment during the four fundamental environment modification requests: adding/removing selectors to/from classes and adding/removing class hierarchy links. The algorithms combine method dispatch calculation, inheritance management, and inheritance conflict detection into a single process, making the algorithms highly efficient. The algorithms also incrementally compute hierarchy information to establish which method addresses can be uniquely identified during compilation. 1 : Introduction Polymorphism and inheritance necessitate run-time method dispatch in object ori [...] ...|$|R
40|$|Automated bot/botnet {{detection}} is {{a difficult}} problem given {{the high level of}} attacker power. We propose a systematic approach for evaluating the evadability of detection methods. An evasion tactic has two associated costs: implementation complexity and effect on botnet utility. An evasion tactic’s implementation complexity is based on the ease with which bot writers can <b>incrementally</b> <b>modify</b> current bots to evade detection. Modifying a bot in order to evade a detection method may result in a less useful botnet; to explore this, we identify aspects of botnets that impact their revenue-generating capability. For concreteness, we survey some leading automated bot/botnet detection methods, identify evasion tactics for each, and assess the costs of these tactics. We also reconsider assumptions about botnet control that underly many botnet detection methods. ...|$|R
40|$|Truth {{maintenance}} {{systems have}} been used in several recent problem solving systems to record justifications for deduced assertions, to track down the assumptions which underlie contradictions when they arise, and to <b>incrementally</b> <b>modify</b> assertional data structures when assumptions are retracted. A TMS algorithm is described here that is substantially different from previous systems. This algorithm performs deduction in traditional propositional logic {{in such a way that}} the premise set from which deduction is being done can be easily manipulated. A novel approach is also taken to the role of a TMS in larger deductive systems. In this approach the TMS performs all propositional deduction in a uniform manner while the larger system is responsible for controlling the instantiation of universally quantified formulae and axiom schemas...|$|R
40|$|The {{past few}} years have seen a {{significant}} increase in the importance of group based distributed applications such as media dissemination, computer supported collaborative work or fault tolerance through replication. However, most distributed object based middleware platforms, which are increasingly being used as an implementation environment for such applications, fail to provide suitable support for group applications in their full generality. In this paper we describe a component based approach to the provision of group services in a middleware environment in which application tailored group services can be built by defining particular configurations of components or by <b>incrementally</b> <b>modifying</b> existing configurations. In addition, our approach uses reflective capabilities of the middleware platform to support the run-time reconfiguration of existing and running group applications...|$|R
40|$|This paper {{proposes that}} {{software}} architectures that support autonomic service-oriented computing {{need to have}} an exogenous management structure. Exogenous management regards autonomicity as a property of relationships between elements, rather than a property of the elements themselves. We explain the concept of exogenous management, and show how a number of desirable attributes that support autonomicity flow from this approach. These attributes include selfmanagement; separability; recursive composition; and grounding through the monitoring of interactions. We will show how these attributes help enhance the adaptability and control the complexity of contextaware compositions of services. We then discuss how this exogenous approach to management has been implemented in the ROAD (Role-oriented Adaptive Design) programming framework. This framework is extended by software developers to create service compositions whose level of autonomicity can be <b>incrementally</b> <b>modified</b> at runtime. 1...|$|R
40|$|This paper {{addresses}} {{the problem of}} learning evolving concepts, that is, concepts whose meaning gradually evolves in time. Solving this problem is important to many applications, for example, building intelligent agents for helping users in Internet search, active vision, automatically updating knowledge-bases, or acquiring profiles of users of telecommunication networks. Requirements for a learning architecture supporting such applications include the ability to <b>incrementally</b> <b>modify</b> concept definitions to accommodate new information, fast learning and recognition rates, low memory needs, and the understandability of computer-created concept descriptions. To address these requirements, we propose a learning architecture based on Variable-Valued Logic, the Star Methodology, and the AQ algorithm. The method uses a partial-memory approach, which means that in each step of learning, the system remembers the current concept descriptions and specially selected representative examples from th [...] ...|$|R
40|$|This article {{describes}} {{how to use}} level sets to represent and compute deformable surfaces. A deformable surface is a sequence of surface models obtained by taking an initial model and <b>incrementally</b> <b>modifying</b> its shape. Typically, we can parameterize the deformation over time, and thus we can imagine that a surface moves or flows {{under the influence of}} a vector field. The surface flow, v, can be determined as a function of spatial position (and time), or it can depend on the shape of the surface itself. The latter is called a geometric flow. Deformable surfaces have been used to solve a variety of problems in image processing, computer vision, visualization, and graphics. In graphics, for instance, deformable surface models have been used to form sequences of shapes that animate the morphin...|$|R
50|$|Pure {{community}} rating prohibits insurance rate variations {{based on}} demographic {{characteristics such as}} age or gender, whereas adjusted or <b>modified</b> <b>community</b> rating allows insurance rate variations based on demographic characteristics such as age or gender.|$|R
5000|$|The Vegreville Cultural Association organizes the festival, {{with the}} help of many {{community}} volunteers. The current <b>Community</b> <b>objectives</b> of the Association in relation to the festival are: ...|$|R
50|$|The City of Shafter reopened the Shafter <b>Modified</b> <b>Community</b> Correctional Facility in 2013 after {{a two-year}} closure. Profits from the {{facility}} directly benefit public safety initiatives and the Shafter Education Partnership, focused on early literacy and college readiness.|$|R
40|$|A {{characteristic}} of aspect-oriented programming, as embodied in AspectJ, {{is the use}} of advice to <b>incrementally</b> <b>modify</b> the behavior of a program. An advice declaration specifies an action to be taken whenever some condition arises during the execution of the program. The condition is specified by a formula called a pointcut designator or pcd. The events during execution at which advice may be triggered are called join points. In this model of aspectoriented programming, join points are dynamic in that they refer to events during the execution of the program. We give a denotational semantics for a minilanguage that embodies the key features of dynamic join points, pointcut designators, and advice. This is the first semantics for aspect-oriented programming that handles dynamic join points and recursive procedures. It is intended as a baseline semantics against which future correctness results may be measured. 1...|$|R
40|$|A class {{extension}} {{is a method}} that is defined in a module, but whose class is defined elsewhere. Class extensions offer a convenient way to <b>incrementally</b> <b>modify</b> existing classes when subclassing is inappropriate. Unfortunately existing approaches suffer from various limitations. Either {{class extension}}s have a global impact, with possibly negative effects for unexpected clients, or they have a purely local impact, with negative results for collaborating clients. Furthermore, conflicting class extensions are either disallowed, or resolved by linearization, with consequent negative effects. To solve these problems we present classboxes, a module system for object-oriented languages that provides for method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model we have implemented it in the Squeak Smalltalk environment, and performed benchmarks...|$|R
40|$|Software {{specification}} {{and implementation}} techniques based on state machines simplify design, coding, and validation. However, large systems require complex state machines. Incremental construction techniques can control this complexity. In this paper, {{we present a}} construction technique that permits derivation of complex state machines from simpler state machines. The technique uses subclassing, composition, delegation, and genericity to <b>incrementally</b> <b>modify</b> and combine simpler machines. In addition, we present a novel implementation technique that uses exactly one table-lookup and one addition to dispatch events on derived state machines, no matter {{the depth of the}} derivation. As an example, we describe the derivation of a complicated distributed virtual memory scheme from a simple paging virtual memory scheme. 1 Introduction Many designers advocate the use of state machines to specify and implement software systems. For example, reactive system designs [10] and object-oriented anal [...] ...|$|R
40|$|Abstract: The {{execution}} of robotic tasks in dynamic, unstructured en-vironments requires {{the generation of}} motion plans that respect global constraints imposed by the task while avoiding collisions with stationary, moving, and unforeseen obstacles. This paper presents the elastic strip framework, which addresses this problem by integrating global motion plan-ning methods with a reactive motion execution approach. To maintain a collision-free trajectory, a given motion plan is <b>incrementally</b> <b>modified</b> to reflect changes in the environment. This modification can be performed without suspending task behavior. The elastic strip framework is computa-tionally efficient and {{can be applied to}} robots with many degrees of freedom. The paper also presents experimental results obtained by the implementa-tion of this framework on the the Stanford Mobile Manipulator. 1. In t roduct ion The automated {{execution of}} tasks by robots in dynamic, unstructured, and potentially populated environments requires ophisticated motion capabilities...|$|R
40|$|Abstract—In a multi-parameter {{learning}} problem, besides {{choosing the}} architecture of the learner, there is the problem of finding the optimal parameters to get maximum performance. When the number of parameters to be tuned increases, it becomes infeasible to try all the parameter sets, hence we need an automatic mechanism to find the optimum parameter setting using computationally feasible algorithms. In this paper, we define the problem of optimizing {{the architecture of}} a Hidden Markov Model (HMM) as a state space search and propose the MSUMO (Model Selection Using Multiple Operators) framework that <b>incrementally</b> <b>modifies</b> the structure and checks for improvement using cross-validation. There are five variants that use forward/backward search, single/multiple operators, and depth-first/breadth-first search. On four hand gesture data sets, we compare the performance of MSUMO with the optimal parameter set found by exhaustive search in terms of expected error and computational complexity. Keywords-Hidden Markov model; model selection; crossvalidation I...|$|R
