155|130|Public
25|$|A <b>file</b> <b>descriptor</b> opened when an exec call is made {{will remain}} {{open in the}} new process image, unless it was fcntled with FD_CLOEXEC or opened with O_CLOEXEC (the latter was {{introduced}} in POSIX.1-2001). This aspect is used to specify the standard streams (stdin, stdout and stderr) of the new program.|$|E
5000|$|The {{variable}} [...] now {{contains the}} index of a <b>file</b> <b>descriptor</b> in the process's <b>file</b> <b>descriptor</b> table. This <b>file</b> <b>descriptor</b> is a capability. Its existence in the process's <b>file</b> <b>descriptor</b> table is sufficient {{to know that the}} process does indeed have legitimate access to the object. A key feature of this arrangement is that the <b>file</b> <b>descriptor</b> table is in kernel memory and cannot be directly manipulated by the user program.|$|E
5000|$|... (duplicates an {{existing}} <b>file</b> <b>descriptor</b> guaranteeing {{to be the}} lowest number available <b>file</b> <b>descriptor)</b> ...|$|E
5000|$|... #Caption: <b>File</b> <b>descriptors,</b> <b>file</b> {{table and}} inode table in Unix ...|$|R
40|$|UNIX {{applications}} not {{wishing to}} block when doing I/O often use the select() system call, to wait for events on multiple <b>file</b> <b>descriptors.</b> The select() mechanism works well for small-scale applications, but scales poorly {{as the number of}} <b>file</b> <b>descriptors</b> increases. Many modern applications, such as Internet servers, use hundreds or thousands of <b>file</b> <b>descriptors,</b> and suffer greatly from the poor scalability of select(). Previous work has shown that while the traditional implementation of select () can be improved, the poor scalability is inherent in the design. We present a new event-delivery mechanism, which allows the application to register interest in one or more sources of events, and to efficiently dequeue new events. We show that this mechanism, which requires only minor changes to applications, performs independently of the number of <b>file</b> <b>descriptors.</b> 1 Introduction An application must often manage large numbers of <b>file</b> <b>descriptors,</b> representing network connections, disk files [...] ...|$|R
5000|$|... {{controls}} over file systems, directories, files, {{and open}} <b>file</b> <b>descriptors</b> ...|$|R
50|$|The <b>file</b> <b>descriptor</b> {{table in}} Unix {{is an example}} of a C-list. Unix {{processes}} do not manipulate file descriptors directly, but refer to them via <b>file</b> <b>descriptor</b> numbers, which are C-list indexes.|$|E
5000|$|The [...] {{function}} {{is used to}} perform various operations on a <b>file</b> <b>descriptor,</b> depending on the command argument passed to it. There are commands to get and set attributes associated with a <b>file</b> <b>descriptor,</b> including [...] and [...]|$|E
5000|$|Application {{software}} opens a CAN {{device descriptor}} and gets back a <b>file</b> <b>descriptor.</b> Using this <b>file</b> <b>descriptor</b> standard operating system functions like [...] and [...] {{are used to}} exchange CAN frames with other CAN nodes on a CAN bus.|$|E
5000|$|Pipelines can {{be created}} under program control. The Unix [...] system call asks the {{operating}} system to construct a new anonymous pipe object. This results in two new, opened <b>file</b> <b>descriptors</b> in the process: the read-only end of the pipe, and the write-only end. The pipe ends appear to be normal, anonymous <b>file</b> <b>descriptors,</b> except {{that they have no}} ability to seek.|$|R
5000|$|... (BSD and Solaris only; deletes all <b>file</b> <b>descriptors</b> {{greater than}} or equal to {{specified}} number) ...|$|R
5000|$|Number {{of active}} clients is {{unlimited}} {{it depends on}} number of <b>file</b> <b>descriptors</b> in the system ...|$|R
5000|$|... a {{directory}} containing a symbolic link for each open <b>file</b> <b>descriptor.</b>|$|E
5000|$|... an open object handle (the Win32 {{equivalent}} of a <b>file</b> <b>descriptor)</b> ...|$|E
50|$|A Unix process' <b>file</b> <b>descriptor</b> {{table is}} an example of a C-list.|$|E
5000|$|In Unix-like systems, <b>file</b> <b>descriptors</b> {{can refer}} to any Unix file type named in a file system. As well as regular files, this {{includes}} directories, block and character devices (also called [...] "special files"), Unix domain sockets, and named pipes. <b>File</b> <b>descriptors</b> can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets.|$|R
50|$|Since this impossibility result, {{libraries}} {{for tracking}} <b>file</b> <b>descriptors</b> and ensuring correctness {{have been proposed}} by researchers.|$|R
50|$|In July 2014, the DDX driver gained {{support for}} server managed <b>file</b> <b>descriptors,</b> {{requiring}} X.Org Server version 1.16 and above.|$|R
5000|$|... (sets the process's current working {{directory}} {{based on}} a directory <b>file</b> <b>descriptor)</b> ...|$|E
5000|$|... (the new <b>file</b> <b>descriptor</b> {{will have}} the value passed as an argument) ...|$|E
5000|$|<b>File</b> <b>descriptor</b> - how {{it works}} and other {{functions}} related to open ...|$|E
50|$|Preservation of {{the lock}} status on open <b>file</b> <b>descriptors</b> passed to another process using a Unix domain socket is {{implementation}} dependent.|$|R
5000|$|Each Unix process (except {{perhaps a}} daemon) {{should expect to}} have three {{standard}} POSIX <b>file</b> <b>descriptors,</b> corresponding to the three standard streams: ...|$|R
25|$|In Bash, the {{ampersand}} {{can separate}} words, control the command history, duplicate <b>file</b> <b>descriptors,</b> perform logical operations, control jobs, {{and participate in}} regular expressions.|$|R
5000|$|... platform-specific {{identifier}} of {{the associated}} I/O device, such as a <b>file</b> <b>descriptor</b> ...|$|E
5000|$|... a {{directory}} containing entries which describe {{the position and}} flags for each open <b>file</b> <b>descriptor.</b>|$|E
5000|$|... (a large {{collection}} of miscellaneous operations {{on a single}} <b>file</b> <b>descriptor,</b> often associated with a device) ...|$|E
25|$|Some Unix shells, {{like the}} POSIX {{standard}} sh shell, use the ampersand {{to execute a}} process {{in the background and}} to duplicate <b>file</b> <b>descriptors.</b>|$|R
50|$|In Bash, the {{ampersand}} {{can separate}} words, control the command history, duplicate <b>file</b> <b>descriptors,</b> perform logical operations, control jobs, {{and participate in}} regular expressions.|$|R
50|$|On Linux, {{the set of}} <b>file</b> <b>descriptors</b> open in {{a process}} can be {{accessed}} under the path /proc/PID/fd/, where PID is the process identifier.|$|R
50|$|Common {{resource}} handles are file descriptors, network sockets, database connections, process identifiers (PIDs), and job IDs. Process IDs and job IDs are explicitly visible integers, while file descriptors and sockets (which {{are often}} implemented {{as a form}} of <b>file</b> <b>descriptor)</b> are represented as integers, but are typically considered opaque. In traditional implementations, file descriptors are indices into a (per-process) <b>file</b> <b>descriptor</b> table, thence a (system-wide) file table.|$|E
5000|$|... : (platform) floppy disks, {{though this}} same {{abbreviation}} is also {{commonly used to}} refer to <b>file</b> <b>descriptor</b> ...|$|E
50|$|CodeAnalyst {{also uses}} other {{open-source}} components, including the Qt framework, libdwarf, libelf, and the Binary <b>File</b> <b>Descriptor</b> library.|$|E
5000|$|Some Unix shells, {{like the}} POSIX {{standard}} [...] shell, use the ampersand {{to execute a}} process {{in the background and}} to duplicate <b>file</b> <b>descriptors.</b>|$|R
5000|$|Operating system {{descriptors}} {{of resources}} that are allocated to the process, such as <b>file</b> <b>descriptors</b> (Unix terminology) or handles (Windows), and data sources and sinks.|$|R
5000|$|... '''''' is a Linux kernel {{system call}} for a {{scalable}} I/O event notification mechanism, first introduced in version 2.5.44 of the Linux kernel mainline. Its function is to monitor multiple <b>file</b> <b>descriptors</b> to see if I/O is possible on any of them. It is meant to replace the older POSIX [...] and [...] system calls, to achieve better performance in more demanding applications, where the number of watched <b>file</b> <b>descriptors</b> is large (unlike the older system calls, which operate in O(n) time, [...] operates in O(1) time).|$|R
