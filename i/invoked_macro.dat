0|14|Public
5000|$|In {{assembly}} language, directives, {{also referred}} to as pseudo-operations or [...] "pseudo-ops", generally specify such information as the target machine, mark separations between code sections, <b>invoke</b> <b>macros,</b> define reserved memory areas, and so on. Assemblers use a specific syntax to differentiate pseudo-ops from instruction mnemonics, such as prefacing the pseudo-op with a period, such as the pseudo-op , which might direct the assembler to stop assembling code.|$|R
40|$|Although the %SYSMACEXIST {{function}} can do macro existence checking, it {{is limited}} to pre-compiled macros. This paper describes the %macro_exists macro, which will verify that a specified macro will be found if <b>invoked.</b> The <b>macro</b> will search for pre-compiled macros and will search all autocall libraries to verify the existence...|$|R
40|$|Lisp {{has shown}} that a {{programmable}} syntax macro system acts {{as an adjunct to}} the compiler that gives the programmer important and powerful abstraction facilities not provided by the language. Unlike simple token substitution macros, such as are provided by CPP #the C preprocessor#, syntax macros operate on Abstract Syntax Trees #ASTs#. Programmable syntax macro systems have not yet been developed for syntactically rich languages such as C because rich concrete syntax requires the manual construction of syntactically valid program fragments, which is a tedious, di#cult, and error prone process. Also, using two languages, one for writing the program, and one for writing macros, is another source of complexity. This research solves these problems byhaving the macro language be a minimal extension of the programming language, byintroducing explicit code template operators into the macro language, and by using a type system to guarantee, at macro de#nition time, that all macros and macro functions only produce syntactically valid program fragments. The code template operators make the language context sensitive, which requires changes to the parser. The parser must perform type analysis in order to parse macro de#nitions, or to parse user code that <b>invokes</b> <b>macros.</b> ...|$|R
5|$|JMP is {{a desktop}} {{application}} with a wizard-based user interface, while SAS {{can be installed}} on servers. It runs in-memory, instead of on disk storage. According to a review in Pharmaceutical Statistics, JMP is often used as a graphical front-end for a SAS system, which performs the statistical analysis and tabulations. JMP Genomics, used for analyzing and visualizing genomics data, requires a SAS component to operate and can access SAS/Genetics and SAS/STAT procedures or <b>invoke</b> SAS <b>macros.</b> JMP Clinical, used for analyzing clinical trial data, can package SAS code within the JSL scripting language and convert SAS code to JMP.|$|R
40|$|The {{first step}} in {{providing}} SYSIN-like functionality, Grandpa Ted realized, was {{to make it easy}} for both the SAS and non-SAS data to coexist with the SAS code. So what {{was the best way to}} go about this? A reusable macro might do the trick, he thought, and so the first incarnation of the MakeFile macro was born: %macro MakeFile(filename); options nocardimage; data _null_; input; file "&filename " lrecl= 255; put _infile_; %mend; MAKEFILE MACRO – VERSION 1. 0 – EXAMPLES And using the MAKEFILE macro to create a file was quite simple–just <b>invoke</b> the <b>macro</b> and follow it with a CARDS statement and your instream data...|$|R
40|$|A {{combined}} University / Industry {{team has}} developed a prototype system for handling protein crystals aboard the space station. The system used a miniature direct drive robot, CCD television cameras, and a client-server computing system using internet protocols to support the capture of protein crystals from aqueous growth solutions. The system was demonstrated between Huntsville AL. and Seattle WA. An operator in Huntsville controlled the mini robot by invoking pre-defined relative and absolute macros. The movement macros (a predefined sequence of multi-device movement commands) were developed to support precision motion between task locations in the glovebox. The operator <b>invoked</b> the <b>macros</b> by clicking icons in the remote control interface. The system is a promising start {{for the development of}} a space-station based remote protein crystal analysis facility...|$|R
40|$|Abstract. The boom {{is one of}} {{main load}} bearing parts for the {{excavator}} operation; accordingly, {{it is very important}} to make the strength calculation. Considering the excavator boom is of complicated working condition and difficult stress analysis, based on the expression of parts of the excavator working device concerning length parameters of the cylinder, establish the full parameterization model in the MSC. adams, so as to make the secondary development process, automatically achieve the force analysis and calculation of all-poses, and process and save hinged forces under all-poses. In addition to the above, by establishing the finite element parameterization model, <b>invoke</b> the <b>macro</b> command to modify all hinged forces, so as to calculate the max. equivalent stress of the boom under all-poses. The calculation result shows that, the boom can meet the strength requirements under all-poses...|$|R
50|$|During the replication, a macro {{can create}} do-nothing macros. But this idea can be {{combined}} with polymorphic macros, so macros are not necessarily do-nothing, each <b>macro</b> <b>invokes</b> the next one {{so they can be}} arranged in a chain. In that case, if they are not all removed during a disinfection, some destructive payload is activated. Such attack can crash the word processor with an internal error. Since WinWord 6.0, the number of macros per template is limited to 150, so the attack is limited too but can still be very annoying.|$|R
40|$|Includes bibliographical {{references}} (pages 47 - 48) This formatting program {{enables a}} user {{to describe the}} form of a document and to automate many formatting tasks. Input is a stream of characters which are the text of the document interspersed with formatting commands. One input source may be interrupted to insert characters from another source. The program is flexible enough to support experimentation with different types of formatting commands. Several primitive commands are provided to control the formatting process. Users may define macro commands tailored for a specific type of document. Traps may be defined which will automatically <b>invoke</b> a <b>macro</b> each time a specified line is reached on each output page. Text is formatted for -output on a line printer. Optional line justification is accomplished by inserting extra blanks between words and over-printing is used to bold face characters. Extra blanks between words on the input file may be eliminated by the program. Selected variables may be manipulated by the user and their values inserted into the text. The program is written in Fortran and every effort has been made to make it portable. It is currently running on a Control Data 3170 computer...|$|R
5000|$|PGF/TikZ is a tandem of {{languages}} for producing vector graphics from a geometric/algebraic description. PGF is a lower-level language, while TikZ {{is a set}} of higher-level macros that use PGF. The top-level PGF and TikZ commands are <b>invoked</b> as TeX <b>macros,</b> but in contrast with PSTricks, the PGF/TikZ graphics themselves are described in a language that resembles MetaPost. Till Tantau is the designer of these languages, and he is also the main developer of the only known interpreter for PGF and TikZ, which is written in TeX. PGF is an acronym for [...] "Portable Graphics Format". TikZ was introduced in version 0.95 of PGF, and it is a recursive acronym for [...] "TikZ ist kein Zeichenprogramm" [...] (German for [...] "TikZ is not a drawing program").|$|R
40|$|FKT is a Fast Kernel Tracing {{facility}} that allows kernel developers {{to obtain a}} precise, time-stamped trace of the dynamic activities of kernel-level code on multiprocessor platforms. This is done by inserting special software " macros into the kernel code, typically one probe at the entrance and exit from each function of interest. Sets of these probes can be enabled and disabled under program control to selectively trace the dynamic execution ow through {{any part of the}} kernel. These <b>macros</b> <b>invoke</b> a highly optimized kernel function to record information into a large kernel buer. This buer can later be written to a le and analyzed o-line. Although probes do add execution overhead to the kernel, every attempt has been made to minimize it. The rst version of FKT has been implemented on Linux. Keywords: dynamic tracing, software monitoring, performance analysis, operating system, kernel. ...|$|R
40|$|APST is {{an acronym}} for the four highest of the seven layers of the LINCS {{hierarchy}} of communication protocols: (from high to low) Application, Presentation, Session, and Transport. Routines in each but the lowest of these APST layers can utilize the facilities of any lower APST layer (normally, but not necessarily, the immediately next lower layer) by <b>invoking</b> various primitives (<b>macros</b> that in most cases are subroutine calls) defining the upper interface of the lower layer. So there are three APST interfaces: Presentation layer, used by the Application layer; Session layer, normally used by the Presentation layer; and Transport layer, normally used by the Session layer. Logically, each end of a stream (unidirectional sequence of transmitted information) is handled by three modules, one module each for the Presentation, Session, and Transport layers, and each of these modules deals with only that one end of that one stream. The internal workings of the layers, particularly the Transport layer, do not necessarily exhibit this same modularization; for example, the two oppositely directed streams between the same two ends (constituting an association) may interact within a layer. However, such interaction is an implementational detail of no direct interest to those utilizing the layer. The present document does not describe implementation, nor does it discuss in any detail how the modules employ packet headings and data formats to communicate with their partner modules {{at the other end}} of a stream. There being one logical module per end of stream is a characteristic only of the Presentation, Session, and Transport layers. An Application layer module usually manages several streams, orchestrating them to achieve some desired purpose. The modules of the layers (Network, Link, and Physical) below the APST layers each handle many streams, multiplexing them through the nodes and channels of the network to transmit them from their origins to their destinations...|$|R
40|$|The aim of {{this paper}} is to {{describe}} the set of Multi-Edit macros created for easily processing of TEX files. Note that the standard version of Multi-Edit has some tools to work with TEX files, but these tools are not very convenient. Therefore we have created our own set of macros, which allows us to process the whole file or to compile and view any selected block of text, such as complicated formulas, for example. Also, there are additional tools for handling some standard situations. On-Screen Compile Menu The Compile menu is activated by pressing the corresponding key. This menu includes: 1. Compiling for formats: Plain-TEX, AMS-TEX, LATEX orAMS-LATEX. One can also use various compilers, for example, 286 -compiler and bigcompiler. These menu items are realized by calls of corresponding batch-files. Automatic processing can be used to find compile errors; 2. Variants of a view. In particular, one can use a view with manual input of options; 3. Variants of printing, similar to the view ones. Various output devices can be used, such as dot matrix and laser printers; 4. Additional menu items; for example, one can include a call of Russian spell-checker. It is easily to add, to modify or to delete menu items by using standard Multi-Edit tools. Automatic error handling Errors identified during compiling are handled in the following way: – The cursor is positioned at the location of the first error found; – The corresponding error message appears in the upper line of the window; – The log-file displayed in the OUTPUT window points to the corresponding error message, which shows only the first two lines. If this is insufficient, then the cursor in the OUTPUT window can be moved by pressing 〈F 11 〉 or 〈Alt+Esc〉. In this case the OUTPUT window will increase up to seven lines. To move the cursor in the text window, press 〈F 11 〉 or 〈Alt+Esc 〉 again and the OUTPUT window will decrease up to two lines. To find the next compile error, simply press the 〈NxtErr 〉 key. Block Compile To compile and view a portion of a text (for example, a complicated formula), select the fragment and use a special <b>macro,</b> <b>invoked</b> by pressing the corresponding combination of keys. Various TE...|$|R

