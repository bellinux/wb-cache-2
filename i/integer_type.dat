95|268|Public
25|$|As JavaScript has unusual {{limitations}} – such as no explicit <b>integer</b> <b>type,</b> only double-precision binary {{floating point}} – languages that compile to JavaScript {{and do not}} take care to use the integer-converting shift and bitwise logical operators may have slightly different behavior than in other environments.|$|E
25|$|Documentation – In more {{expressive}} type systems, types {{can serve}} as a form of documentation clarifying the intent of the programmer. For example, if a programmer declares a function as returning a timestamp type, this documents the function when the timestamp type can be explicitly declared deeper in the code to be an <b>integer</b> <b>type.</b>|$|E
25|$|Although it is {{possible}} to partially circumvent this problem with conversion code and using larger data types, it makes using Java cumbersome for handling the unsigned data. While a 32-bit signed integer may be used to hold a 16-bit unsigned value with relative ease, a 32-bit unsigned value would require a 64-bit signed integer. Additionally, a 64-bit unsigned value cannot be stored using any <b>integer</b> <b>type</b> in Java because no type larger than 64 bits exists in the Java language. If abstracted using functions, function calls become necessary for many operations which are native to some other languages. Alternatively, it {{is possible}} to use Java's signed integers to emulate unsigned integers of the same size, but this requires detailed knowledge of complex bitwise operations.|$|E
5000|$|In {{addition}} to the standard <b>integer</b> <b>types,</b> {{there may be other}} [...] "extended" [...] <b>integer</b> <b>types,</b> which can be used for typedefs in standard headers. For more precise specification of width, programmers can and should use typedefs from the standard header stdint.h.|$|R
40|$|We {{present an}} {{approach}} to integrating the refinement relation between infinite <b>integer</b> <b>types</b> (used in specification languages) and finite <b>integer</b> <b>types</b> (used in programming languages) into software verification calculi. Since <b>integer</b> <b>types</b> in programming languages have finite ranges, in general {{they are not a}} correct data refinement of the mathematical integers usually used in specification languages. Ensuring the correctness of such a refinement requires generating and verifying additional proof obligations. We tackle this problem considering Java and UML/OCL as example. We present a sequent calculus for Java integer arithmetic with integrated generation of refinement proof obligations. Thus, there is no explicit [...] ...|$|R
5000|$|C's <b>integer</b> <b>types</b> come in {{different}} fixed sizes, capable of representing various ranges of numbers. The type char occupies exactly one byte (the smallest addressable storage unit), which is typically 8 bits wide. (Although char can represent any of C's [...] "basic" [...] characters, a wider type {{may be required}} for international character sets.) Most <b>integer</b> <b>types</b> have both signed and unsigned varieties, designated by the signed and unsigned keywords. Signed <b>integer</b> <b>types</b> may use a two's complement, ones' complement, or sign-and-magnitude representation. In many cases, there are multiple equivalent ways to designate the type; for example, signed short int and short are synonymous.|$|R
25|$|A common {{identifier}} {{naming convention}} {{is for the}} loop counter to use the variable names i, j, and k (and so on if needed), where {{i would be the}} most outer loop, j the next inner loop, etc. The reverse order is also used by some programmers. This style is generally agreed to have originated from the early programming of FORTRAN, where these variable names beginning with these letters were implicitly declared as having an <b>integer</b> <b>type,</b> and so were obvious choices for loop counters that were only temporarily required. The practice dates back further to mathematical notation where indices for sums and multiplications are often i, j, etc. A variant convention is the use of reduplicated letters for the index, ii, jj, and kk, as this allows easier searching and search-replacing than using a single letter.|$|E
5000|$|Increases by 1 (+1) or {{decrements}} by 1 (-1) {{a variable}} of <b>integer</b> <b>type</b> ...|$|E
50|$|In {{computer}} programming many functions return values of <b>integer</b> <b>type</b> due to simplicity of implementation.|$|E
5000|$|Integer is 64-bit. Unlike Java and C#, Fantom {{does not}} have Long or Short <b>integer</b> <b>types.</b>|$|R
40|$|This paper {{suggests}} a simple {{adjustment to the}} existing rules governing conversion from the underlying type of a scoped enumeration to said enumeration, if the latter is defined with no associated enumerator. This effectively supports programming styles that rely on defining of new distinct integral types based out of existing <b>integer</b> <b>types,</b> without the complexity of anarchic integer conversions, while retaining all the ABI characteristics and benefits of the <b>integer</b> <b>types,</b> especially for system programming. ...|$|R
5000|$|Pointer <b>integer</b> <b>types</b> {{which are}} {{guaranteed}} {{to be able to}} hold a pointer. Included only if it is available in the implementation.|$|R
5000|$|Maximum-width integer types {{which are}} {{guaranteed}} {{to be the largest}} <b>integer</b> <b>type</b> in the implementation.|$|E
5000|$|... an {{unsigned}} <b>integer</b> <b>type</b> {{which is}} the type of the result of the [...] operator.|$|E
5000|$|... defines an {{immutable}} entity [...] (the <b>integer</b> <b>type</b> is inferred at compile-time) and a mutable entity named [...]|$|E
40|$|Abstract. We {{present an}} {{approach}} to integrating the refinement relation between infinite <b>integer</b> <b>types</b> (used in specification languages) and finite <b>integer</b> <b>types</b> (used in programming languages) into software verification calculi. Since <b>integer</b> <b>types</b> in programming languages have finite ranges, in general {{they are not a}} correct data refinement of the mathematical integers usually used in specification languages. Ensuring the correctness of such a refinement requires generating and verifying additional proof obligations. We tackle this problem considering Java and UML/OCL as example. We present a sequent calculus for Java integer arithmetic with integrated generation of refinement proof obligations. Thus, there is no explicit refinement relation, such that the arising complications remain (as far as possible) hidden from the user. Our approach has been implemented as part of the KeY system. Keywords: software verification, specification, UML/OCL, data refinement, Java, integer arithmetic...|$|R
5000|$|Exact-width <b>integer</b> <b>types</b> {{which are}} {{guaranteed}} {{to have the same}} number N of bits across all implementations. Included only if it is available in the implementation.|$|R
5000|$|The {{actual size}} of <b>integer</b> <b>types</b> varies by implementation. The {{standard}} only requires size {{relations between the}} data types and minimum sizes for each data type: ...|$|R
5000|$|Using variant {{data types}} as loop {{counters}} in Microsoft Visual Basic where an <b>integer</b> <b>type</b> is also available.|$|E
5000|$|Type punning {{the number}} to an <b>integer</b> <b>type,</b> so as {{to look at the}} sign bit in the bit pattern; ...|$|E
5000|$|For example, since sizeof (char) {{is defined}} to be 1 and {{assuming}} the <b>integer</b> <b>type</b> is four bytes long, the following code prints : ...|$|E
5000|$|Least-width <b>integer</b> <b>types</b> {{which are}} {{guaranteed}} to be the smallest type available in the implementation, that has at least specified number N of bits. Guaranteed to be specified for at least N=8,16,32,64.|$|R
5000|$|... a single-reader single-writer {{ring buffer}} FIFO, {{with a size}} which evenly divides the {{overflow}} {{of one of the}} available unsigned <b>integer</b> <b>types,</b> can unconditionally be implemented safely using only a memory barrier ...|$|R
50|$|Java {{does not}} feature {{unsigned}} <b>integer</b> <b>types.</b> In particular, Java lacks a primitive type for an unsigned byte. Instead, Java's byte type is sign extended, {{which is a}} common source of bugs and confusion.|$|R
5000|$|In C++03, {{the largest}} <b>integer</b> <b>type</b> is [...] It is {{guaranteed}} {{to have at least}} as many usable bits as [...] This resulted in [...] having size of 64 bits on some popular implementations and 32 bits on others. C++11 adds a new <b>integer</b> <b>type</b> [...] to address this issue. It {{is guaranteed to}} be at least as large as a , and have no fewer than 64 bits. The type was originally introduced by C99 to the standard C, and most C++ compilers supported it as an extension already.|$|E
5000|$|Constant folding {{can even}} use {{arithmetic}} identities. When [...] is an <b>integer</b> <b>type,</b> {{the value of}} [...] is zero even if the compiler does not know the value of [...]|$|E
50|$|The {{maximum value}} of a fixed-point type is simply the largest value that can be {{represented}} in the underlying <b>integer</b> <b>type</b> multiplied by the scaling factor; and similarly for the minimum value.|$|E
50|$|Parts of the C99 {{standard}} {{are included}} in the current version of the C++ standard, including <b>integer</b> <b>types,</b> headers, and library functions. Variable-length arrays are not among these included parts because C++'s Standard Template Library already includes similar functionality.|$|R
5000|$|Enumeration {{constants}} ( [...] values) {{are always}} of type [...] in C, whereas they are distinct types in C++ {{and may have}} a size {{different from that of}} [...] C++11 allows the programmer to use custom <b>integer</b> <b>types</b> for the values of an enum.|$|R
5000|$|The {{representation}} of some types may include unused [...] "padding" [...] bits, which occupy storage {{but are not}} included in the width. The following table provides a complete list of the standard <b>integer</b> <b>types</b> and their minimum allowed widths (including any sign bit).|$|R
5000|$|Fastest integer types {{which are}} {{guaranteed}} to be the fastest <b>integer</b> <b>type</b> available in the implementation, that has at least specified number N of bits. Guaranteed to be specified for at least N=8,16,32,64.|$|E
5000|$|HINT is {{intended}} to be [...] "scalable" [...] to run on any size computer, from small serial systems to highly parallel supercomputers.The person using the HINT benchmark can use any floating point or <b>integer</b> <b>type.</b>|$|E
5000|$|Example:int foo = 42; // Primitive typeInteger bar = foo; /* foo is boxed to bar, bar is of <b>Integer</b> <b>type,</b> {{which serves}} as a wrapper for int */int foo2 = bar; // Unboxed back to {{primitive}} type ...|$|E
40|$|We {{present a}} model {{checking}} tool based on game semantics and CSP for verifying safety properties of software, such as assertion violations or array-out-of-bounds errors. The tool implements a data-abstraction refinement procedure applicable to open programs with infinite <b>integer</b> <b>types.</b> The procedure {{is guaranteed to}} terminate for unsafe inputs...|$|R
5000|$|Support for {{unsigned}} <b>integer</b> data <b>types</b> {{commonly used}} in other languages ...|$|R
5000|$|... create <b>type</b> age as <b>integer</b> FINAL;create <b>type</b> salary as <b>integer</b> FINAL; ...|$|R
