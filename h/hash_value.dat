642|461|Public
5|$|It is also {{possible}} to remove a key–value pair from the dictionary. However, it {{is not sufficient to}} do so by simply emptying its cell. This would affect searches for other keys that have a <b>hash</b> <b>value</b> earlier than the emptied cell, but that are stored in a position later than the emptied cell. The emptied cell would cause those searches to incorrectly report that the key is not present.|$|E
5|$|The <b>hash</b> <b>value</b> {{that this}} class {{associates}} with each object, its identityHashCode, {{is guaranteed to}} remain fixed for the lifetime of an object but is otherwise arbitrary. Because the identityHashCode is constructed only once per object, and {{is not required to}} be related to the object's address or value, its construction may involve slower computations such as the call to a random or pseudorandom number generator. For instance, Java 8 uses an Xorshift pseudorandom number generator to construct these values.|$|E
5|$|Another {{method of}} {{constructing}} hash functions with both high quality and practical speed is tabulation hashing. In this method, the <b>hash</b> <b>value</b> for a key {{is computed by}} using each byte of the key as an index into a table of random numbers (with a different table for each byte position). The numbers from those table cells are then combined by a bitwise exclusive or operation. Hash functions constructed this way are only 3-independent. Nevertheless, linear probing using these hash functions takes constant expected time per operation. Both tabulation hashing and standard methods for generating 5-independent hash functions are limited to keys that have a fixed number of bits. To handle strings or other types of variable-length keys, {{it is possible to}} compose a simpler universal hashing technique that maps the keys to intermediate values and a higher quality (5-independent or tabulation) hash function that maps the intermediate values to hash table indices.|$|E
40|$|Standards and Technology {{has shown}} that mobile device {{internal}} memory <b>hash</b> <b>values</b> are variable when performing back-to-back acquisitions. <b>Hash</b> <b>values</b> are beneficial in providing examiners {{with the ability to}} filter known data files, match data objects across platforms and prove that data integrity remains intact. The research conducted at Purdue University compared known <b>hash</b> <b>values</b> with reported values for data objects populated onto mobile devices using various data transmission methods. While the results for the majority of tests were uniform, the <b>hash</b> <b>values</b> reported for data objects transferred via Multimedia Messaging Service (MMS) were variable...|$|R
5000|$|Created by the National Drug Intelligence Center (NDIC)—a {{component}} of the United States Department of Justice—in 1996, {{it was the first}} large scale source for <b>hash</b> <b>values</b> of [...] "known to be good" [...] and [...] "known to be bad" [...] files. HashKeeper was, and still is, the only community effort based upon the belief that members of state, national, and international law enforcement agencies can be trusted to submit properly categorized <b>hash</b> <b>values.</b> One of the first community sources of [...] "known to be good" [...] <b>hash</b> <b>values</b> was the United States Internal Revenue Service. The first source of [...] "known to be bad" [...] <b>hash</b> <b>values</b> was the Luxembourg Police who contributed <b>hash</b> <b>values</b> of recognized child pornography.|$|R
40|$|Introduction Rivest and Shamir's Micromint can be {{enhanced}} while retaining most of the desirable properties. The approach {{is to use a}} sequence of <b>hashed</b> <b>values</b> for a transaction. A forger has to generate <b>hashed</b> <b>values</b> to a comparable density and so perform a similar amount of work to the legitimate generator. The work ratios are similar to or better than Micromint. Basic ideas. We consider the same model as Rivest and Shamir [] with three components. bank (broker), vendor, purse (user). The bank generates a large number of <b>hashed</b> <b>values</b> so the values are uniformly possible across the value field. The chance of each point having a value is identical. The values could be h(x) + 2 x where x is a t bit integer, or just the quantised h(x). We now take some sequential <b>hashed</b> <b>values</b> which are necessary for a transaction and test the density of <b>hashed</b> <b>values.</b> If the number of samples is large t...|$|R
25|$|Message {{authentication}} codes (MACs) {{are much}} like cryptographic hash functions, except that a secret key {{can be used}} to authenticate the <b>hash</b> <b>value</b> upon receipt; this additional complication blocks an attack scheme against bare digest algorithms, and so has been thought worth the effort.|$|E
25|$|Systems {{that use}} {{passwords}} for authentication {{must have some}} way to check any password entered to gain access. If the valid passwords are simply stored in a system file or database, an attacker who gains sufficient access to the system will obtain all user passwords, giving the attacker access to all accounts on the attacked system, and possibly other systems where users employ the same or similar passwords. One way to reduce this risk is to store only a cryptographic hash of each password instead of the password itself. Standard cryptographic hashes, such as the Secure Hash Algorithm (SHA) series, are very hard to reverse, so an attacker who gets hold of the <b>hash</b> <b>value</b> cannot directly recover the password. However, knowledge of the <b>hash</b> <b>value</b> lets the attacker quickly test guesses offline. Password cracking programs are widely available that will test {{a large number of}} trial passwords against a purloined cryptographic hash.|$|E
25|$|The {{key idea}} of {{tabulation}} hashing is {{to view a}} key as a vector of t r-bit numbers, use a lookup table filled with random values to compute a <b>hash</b> <b>value</b> {{for each of the}} r-bit numbers representing a given key, and combine these values with the bitwise binary exclusive or operation. The choice of r should be made {{in such a way that}} this table is not too large; e.g., so that it fits into the computer's cache memory.|$|E
5000|$|Hash {{chains are}} a {{technique}} for decreasing this space requirement. The {{idea is to}} define a reduction function R that maps <b>hash</b> <b>values</b> back into values in P. Note, however, that the reduction function is not actually an inverse of the hash function. By alternating the hash function with the reduction function, chains of alternating passwords and <b>hash</b> <b>values</b> are formed. For example, if P were the set of lowercase alphabetic 6-character passwords, and <b>hash</b> <b>values</b> were 32 bits long, a chain might look like this: ...|$|R
5000|$|With these <b>hash</b> <b>values</b> [...] a <b>hash</b> tree is built, {{by placing}} these [...] <b>hash</b> <b>values</b> as leaves and recursively hashing {{to form a}} binary tree. Let [...] denote the node in the tree with height [...] and {{left-right}} position [...] Then, the <b>hash</b> <b>values</b> [...] are the leaves. The value for each inner node of the tree is the hash of the concatenation of its two children. For example, [...] and [...] In this way, a tree with [...] leaves and [...] nodes is built.|$|R
5000|$|... 6.3.1: (2007) Corrected {{standard}} <b>hash</b> <b>values</b> for SHA-256/384/512.|$|R
25|$|The {{initialization}} {{phase of}} the algorithm creates a two-dimensional array T of dimensions 2r by t, and fills the array with random q-bit numbers. Once the array T is initialized, {{it can be used}} to compute the <b>hash</b> <b>value</b> h(x) of any given keyx. To do so, partition x into r-bit values, where x0 consists of the low order r bits of x, x1 consists of the next r bits, etc. For example, with the choice r=8, x'i is just the ith byte of x.|$|E
25|$|The first {{instance}} of tabulation hashing is Zobrist hashing, {{a method for}} hashing positions in abstract board games such as chess named after Albert Lindsey Zobrist, who published it in 1970. In this method, a random bitstring is generated for each game feature such as {{a combination of a}} chess piece and a square of the chessboard. Then, to hash any game position, the bitstrings for the features of that position are combined by a bitwise exclusive or. The resulting <b>hash</b> <b>value</b> can then be used as an index into a transposition table. Because each move typically changes {{only a small number of}} game features, the Zobrist value of the position after a move can be updated quickly from the value of the position before the move, without needing to loop over all of the features of the position.|$|E
500|$|Instead, when a cell [...] is emptied, it is {{necessary}} to search forward through the following cells of the table until finding either another empty cell or a key that can be moved to cell [...] (that is, a key whose <b>hash</b> <b>value</b> is equal to or earlier than [...] ). When an empty cell is found, then emptying cell [...] is safe and the deletion process terminates. But, when the search finds a key that can be moved to cell , it performs this move. This has the effect of speeding up later searches for the moved key, but it also empties out another cell, later in the same block of occupied cells. The search for a movable key continues for the new emptied cell, in the same way, until it terminates by reaching a cell that was already empty. In this process of moving keys to earlier cells, each key is examined only once. Therefore, the time to complete the whole process is proportional to the length of the block of occupied cells containing the deleted key, matching the running time of the other hash table operations.|$|E
50|$|Shareaza {{can connect}} to gnutella, G2, eDonkey and BitTorrent. Shareaza hashes its files for all networks, and then {{distributes}} those <b>hash</b> <b>values</b> on G2. This allows Shareaza to download one file from several networks at once. When another client connected to G2 finds such a file, it {{is given the}} <b>hash</b> <b>values</b> for all networks and can search on the other networks with their respective <b>hash</b> <b>values,</b> which increases the number of sources and the download speed of the file. Shareaza also uses its G2 network to find more sources for torrents.|$|R
5000|$|... #Subtitle level 2: Jaccard {{similarity}} and minimum <b>hash</b> <b>values</b> ...|$|R
40|$|Abstract — In this paper, a novel {{multimedia}} {{identification system}} based on quantum hashing is considered. Many traditional systems are based on binary hash which is obtained by encoding intermediate hash extracted from multimedia content. In the system considered, the intermediate <b>hash</b> <b>values</b> extracted from a query are encoded into quantum <b>hash</b> <b>values</b> by incorporating uncertainty in the binary <b>hash</b> <b>values.</b> For this, the intermediate hash difference between the query and its true-underlying content is considered as a random process. Then, the uncertainty {{is represented by the}} probability density estimate of the intermediate hash difference. The quantum hashing system is evaluated using both audio and video databases, and with marginal increment in computational cost, the quantum hashing system is shown to be more robust against various distortions than the binary hashing system using the same intermediate <b>hash</b> <b>values...</b>|$|R
2500|$|As [...] observe, {{tabulation}} hashing is 3-independent but not 4-independent. [...] For {{any single}} key x, T is equally {{likely to take}} on any <b>hash</b> <b>value,</b> and the exclusive or of T with the remaining table values does not change this property. For any two keys x and y, x is equally likely to be mapped to any <b>hash</b> <b>value</b> as before, and {{there is at least}} one position i where xi≠yi; the table value T is used in the calculation of h(y) but not in the calculation of h(x), so even after the value of h(x) has been determined, h(y) is equally likely to be any valid <b>hash</b> <b>value.</b> Similarly, for any three keys x, y, and z, at least one of the three keys has a position i where its value z'i differs from the other two, so that even after the values of h(x) and h(y) are determined, h(z) is equally likely to be any valid <b>hash</b> <b>value.</b>|$|E
2500|$|The Magnet URI scheme {{defines the}} format of magnet links, a de facto {{standard}} for identifying files by their content, via cryptographic <b>hash</b> <b>value</b> rather than by their location.|$|E
2500|$|... {{uses the}} same idea of using {{exclusive}} or operations to combine random values from a table, with a more complicated algorithm based on expander graphs for transforming the key bits into table indices, to define hashing schemes that are k-independent for any constant or even logarithmic value of k. However, the number of table lookups needed to compute each <b>hash</b> <b>value</b> using Siegel's variation of tabulation hashing, while constant, is still too large to be practical, {{and the use of}} expanders in Siegel's technique also makes it not fully constructive.|$|E
50|$|GOST {{algorithm}} with CryptoPro S-Box generates {{different set}} of <b>hash</b> <b>values.</b>|$|R
5000|$|... {{the initial}} <b>hash</b> <b>values</b> and round {{constants}} are extended to 64 bits, ...|$|R
50|$|In many applications, {{the range}} of <b>hash</b> <b>values</b> may be {{different}} for each run of the program, or may change along the same run (for instance, when a hash table needs to be expanded). In those situations, one needs a hash function which takes two parameters—the input data z, and the number n of allowed <b>hash</b> <b>values.</b>|$|R
2500|$|... {{define a}} {{randomized}} scheme for generating hash functions to be universal if, for any two keys, {{the probability that}} they collide (that is, they are mapped to the same value as each other) is 1/m, where m {{is the number of}} values that the keys can take on. They defined a stronger property in the subsequent paper : a randomized scheme for generating hash functions is k-independent if, for every k-tuple of keys, and each possible k-tuple of values, the probability that those keys are mapped to those values is 1/m'k. 2-independent hashing schemes are automatically universal, and any universal hashing scheme can be converted into a 2-independent scheme by storing a random number x as part of the initialization phase of the algorithm and adding x to each <b>hash</b> <b>value.</b> Thus, universality is essentially the same as 2-independence. However, k-independence for larger values of k is a stronger property, held by fewer hashing algorithms.|$|E
5000|$|... a {{small change}} to a message should change the <b>hash</b> <b>value</b> so {{extensively}} that the new <b>hash</b> <b>value</b> appears uncorrelated with the old <b>hash</b> <b>value</b> ...|$|E
5000|$|The Davies-Meyer single-block-length {{compression}} function feeds each {{block of}} the message (mi) {{as the key to}} a block cipher. It feeds the previous <b>hash</b> <b>value</b> (Hi-1) as the plaintext to be encrypted. The output ciphertext is then also XORed (...) with the previous <b>hash</b> <b>value</b> (Hi-1) to produce the next <b>hash</b> <b>value</b> (Hi). In the first round when there is no previous <b>hash</b> <b>value</b> it uses a constant pre-specified initial value (H0).|$|E
40|$|WO 2004034635 A UPAB: 20040511 NOVELTY - The method {{involves}} producing several <b>hash</b> <b>values</b> (h 1 -h 4) from {{a document}} (m) {{to be signed}} using mutually different hash functions and producing at least one signature (S) from the <b>hash</b> <b>values</b> using a private key. The <b>hash</b> <b>values</b> for signature computation are combined in a data object that is encoded using an asymmetric technique so that the <b>hash</b> <b>values</b> can be recovered by decoding the data object with a public key DETAILED DESCRIPTION - AN INDEPENDENT CLAIM is also included for the following: (a) a method of verifying a signature produced {{in accordance with the}} inventive method (b) a method of verifying a signal made up of sub-signatures (c) and a method of checking a signature. USE - For digitally signing documents. ADVANTAGE - The validity of the method is maintained over a long period...|$|R
5000|$|<b>Hash</b> <b>values</b> {{of empty}} string. Kupyna-256("") 0x cd5101d1ccdf0d1d1f4ada56e888cd724ca1a0838a3521e7131d4fb78d0f5eb6 Kupyna-512("") 0x 656b2f4cd71462388b64a37043ea55dbe445d452aecd46c3298343314ef04019 \ bcfa3f04265a9857f91be91fce197096187ceda78c9c1c021c294a0689198538 ...|$|R
5000|$|<b>Hash</b> <b>values</b> {{of empty}} string. Streebog-256("") 0x 3f539a213e97c802cc229d474c6aa32a825a360b2a933a949fd925208d9ce1bb Streebog-512("") 0x 8e945da209aa869f0455928529bcae4679e9873ab707b55315f56ceb98bef0a7 \ 362f715528356ee83cda5f2aac4c6ad2ba3a715c1bcd81cb8e9f90bf4c1c1a8a ...|$|R
5000|$|It feeds each {{block of}} the message (mi) as the {{plaintext}} to be encrypted. The output ciphertext is then XORed (...) with the same message block (mi) and then also XORed with the previous <b>hash</b> <b>value</b> (Hi-1) to produce the next <b>hash</b> <b>value</b> (Hi). The previous <b>hash</b> <b>value</b> (Hi-1) is fed {{as the key to}} the block cipher. In the first round when there is no previous <b>hash</b> <b>value</b> it uses a constant pre-specified initial value (H0).|$|E
50|$|The {{output of}} a {{cryptographic}} hash function, {{also known as}} a message digest, can provide strong assurances about data integrity, whether changes of the data are accidental (e.g., due to transmission errors) or maliciously introduced. Any modification to the data will likely be detected through a mismatching <b>hash</b> <b>value.</b> Furthermore, given some <b>hash</b> <b>value,</b> it is infeasible to find some input data (other than the one given) that will yield the same <b>hash</b> <b>value.</b> If an attacker can change not only the message but also the <b>hash</b> <b>value,</b> then a keyed hash or message authentication code (MAC) can be used for additional security. Without knowing the key, it is infeasible for the attacker to calculate the correct keyed <b>hash</b> <b>value</b> for a modified message.|$|E
5000|$|It feeds each {{block of}} the message (mi) as the {{plaintext}} to be encrypted. The output ciphertext is then also XORed (...) with the same message block (mi) to produce the next <b>hash</b> <b>value</b> (Hi). The previous <b>hash</b> <b>value</b> (Hi-1) is fed {{as the key to}} the block cipher. In the first round when there is no previous <b>hash</b> <b>value</b> it uses a constant pre-specified initial value (H0).|$|E
5000|$|Hash tree (persistent data structure), a trie used to map <b>hash</b> <b>values</b> to keys ...|$|R
5000|$|<b>Hash</b> <b>values</b> {{of empty}} string. Skein-256-256("") 0x c8877087da56e072870daa843f176e9453115929094c3a40c463a196c29bf7ba Skein-512-256("") 0x 39ccc4554a8b31853b9de7a1fe638a24cce6b35a55f2431009e18780335d2621 Skein-512-512("") 0x bc5b4c50925519c290cc634277ae3d6257212395cba733bbad37a4af0fa06af41fca7903d06564fea7a2d3730dbdb80c1f85562dfcc070334ea4d1d9e72cba7a ...|$|R
5000|$|UIMID (hardware identifier). Will be a pseudo (<b>hashed)</b> <b>value</b> if EUIMID is in use.|$|R
