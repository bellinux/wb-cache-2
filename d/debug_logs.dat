5|45|Public
50|$|ESBs include native service-level {{support for}} {{run-time}} monitoring, tracing, and logging. All services can be monitored instantly, using visual tools within the SOAIF. Trace levels can be dynamically changed within existing services {{running across the}} network and <b>debug</b> <b>logs</b> can be routed to software tools on any node. These features greatly simplify the development, deployment, and debugging of distributed applications running across the SOAIF.|$|E
40|$|The IDebug {{debugging}} {{framework is}} an advanced debugging framework for Java. This framework provides the standard core debugging and specification constructs such as assertions, debug levels and categories, stack traces, and specialized exceptions. Debugging functionality can be fine-tuned to a per-thread and/or a per-class basis, debugging contexts {{can be stored}} to and recovered from persistent storage, and several aspects of the debugging run-time are configurable at the meta-level. Additionally, the framework is designed for extensibility. Planned improvements include support for debugging distributed object systems via currying call stacks across virtual machine contexts and debug information logging {{with a variety of}} networking media including unicast, multicast, RMI, distributed events, and JavaSpaces. Finally, we are adding support for debugging mobile agent systems by providing mobile <b>debug</b> <b>logs.</b> ...|$|E
40|$|IDebug, the Infospheres {{debugging}} framework, is {{an advanced}} debugging framework for Java. This framework provides the standard core debugging and specification constructs such as assertions, debug levels and categories, stack traces, and specialized exceptions. Debugging functionality can be fine-tuned to a per-thread and/or a per-class basis, debugging contexts {{can be stored}} to and recovered from persistent storage, and several aspects of the debugging run-time are configurable at the meta-level. Additionally, the framework is designed for extensibility. Planned improvements include support for debugging distributed object systems via currying call stacks across virtual machine contexts and debug information logging {{with a variety of}} networking media including unicast, multicast, RMI, distributed events, and JavaSpaces. Finally, we are adding support for debugging mobile agent systems by providing mobile <b>debug</b> <b>logs.</b> 1 Introduction Programming technologies have evolved greatly over th [...] ...|$|E
5000|$|Development Mode View: inspect your <b>debugging</b> <b>logs</b> {{and manage}} the GWT code server from Eclipse ...|$|R
5000|$|The {{following}} [...] "monad-logger" [...] {{calls are}} also available from [...] "yesod-core":$(logDebug) [...] "This is a <b>debug</b> <b>log</b> message"$(logInfo), $(logWarn), $(logError) and $(logOther) {{are also available}}You can set per case log default by overriding the shouldLog method of the Yesod class instance for the site.|$|R
5000|$|Enduro/X {{introduced}} {{new set of}} API function named tplog. This allows user to use {{the same}} C based high-performance <b>debug</b> <b>logging</b> facilities which Enduro/X uses internally. It is possible to redirect all logging by thread bases files. Also there are APIs for [...] "request logging", which means that user and Enduro/X can do logging in separate files for each request (e.g. log by session id, log by username, etc.) ...|$|R
40|$|This thesis {{contains}} {{details and}} challenges which {{emerged during the}} development of aproof of concept tool for analysis of <b>debug</b> <b>logs</b> and its language to describe log les usinga state machine approach. It also brings up theory {{in a couple of}} areas related to testingin general and issues concerning testing with log data. The method is general and is not limited to any specic systems, but mobile systemswas the base for the work. The tool, written in C++, is able to point out the location inthe analysed le where that le does not match the described behaviour. An evaluationof the tool shows that it has good potential and that it can be useful in practice. To provide a way to model state machines, such as patterns or sequences in log data,a new language has been developed. It is possible to describe, both simple and complex,behaviours of systems. This might include conditions on variables and jumps betweenthe states. The syntax of the language was created to be intuitive and intuitivity isachieved mainly by only describing the transitions of the machines without the need ofdening all of its possible states. Validerat; 20130827 (global_studentproject_submitter...|$|E
30|$|As such, {{the product}} {{manufacturing}} process produces a large variety and {{volume of data}} from complex process operations. Typically, the flow of data follows the hierarchy (shown in Fig. 3) from the automation and field layers, to the control layer, and finally the enterprise layer. In contrast, control data flows in the reverse direction, as demonstrated in Fig. 5. Since the platform is focused on process data analysis, it is logical to assume that it will predominantly consume structured automation and field level data. However, quality control data may also be required from both the control and enterprise layers. These {{may be used to}} isolate component faults or to supplement analysis with information that is only available from these layers. For example, this may include controller <b>debug</b> <b>logs,</b> material properties, and customer feedback forms. The heterogeneous nature of the data will need to be ingested to formalize its structure and to filter, de-duplicate, and synchronize the different records. While it is typical for ingested data to be then directly sent for long term storage and analysis, it may also be returned to elements of the manufacturing infrastructure to be used or displayed in its pre-processed form. Next, the analysis of ingested data may include mining for knowledge in real time streams, processing for predictive analytics, and searching for historical patterns. It is typical for the analysis results to be stored while also being delivered through reporting and visualisation tools for real-time monitoring, alerting, and decision-making purposes. Hence, five basic components are expected of process data analysis platforms. These are data ingestion, communication, storage, analysis, and visualization [4, 31, 32].|$|E
40|$|This study {{demonstrates}} that {{formal training in}} debugging helps students develop skills in diagnosing and removing defects from computer programs. To enhance debugging skills in an assembly language course, students completed <b>debugging</b> exercises, <b>debugging</b> <b>logs,</b> development logs, reflective memos, and collaborative assignments. The debugging exercises were optional, but the other activities were mandatory. Students who completed the debugging exercises spent 37 % of their time on debugging programming assignments, whereas {{students who did not}} complete the debugging exercises spent 47 % of their time debugging. Students also provided qualitative data for each activity, and they responded to summative evaluation surveys. Students agreed that formal debugging training enhanced their debugging skills. This paper also proposes a model of debugging abilities and habits based on students' comments in their <b>debugging</b> <b>logs,</b> development logs, reflective memos, and evaluation surveys. Students and instructors can use the model to diagnose students' current debugging skills and take actions to enhance their skills. National Science Foundation under Grant SES- 0138309; College of Engineering, University of Illinois at Urbana-Champaignunpublishednot peer reviewe...|$|R
50|$|Aspects help {{software}} engineers {{deal with}} quality attributes by providing tools to add or remove boilerplate code from many {{areas in the}} source code. Aspects describe how all objects or functions should behave in particular circumstances. For example, aspects can add <b>debugging,</b> <b>logging,</b> or locking control into all objects of particular types. Researchers are currently working {{to understand how to}} use aspects to design general-purpose code. Related concepts include generative programming and templates.|$|R
40|$|We {{conducted}} a study to demonstrate that formal training in debugging helps students develop skills in diagnosing and removing defects from computer programs. To accomplish that goal in an assembly language course, we designed multiple activities to enhance students' debugging skills. The activities included <b>debugging</b> exercises, <b>debugging</b> <b>logs,</b> development logs, reflective memos, and collaborative assignments. The debugging exercises were optional, but the other activities were mandatory. Students who also completed the debugging exercises spent 37 % of their time on debugging programming assignments, whereas {{students who did not}} complete the debugging exercises spent 47 % of their time debugging. We also collected qualitative data for each activity through summative evaluation surveys. Students agreed that formal debugging abilities and habits based on students' comments in their <b>debugging</b> <b>logs,</b> development logs, reflective memos, and evaluation surveys. Students and instructors could use the model to diagnose students' current debugging skills and take actions to enhance their skills. This poster was also presented at Proceedings of the Thirty-Third ASEE/IEEE Frontiers in Education Conference, Westminster, CO, 2003 and Proceedings of the Thirty-Fifth ACM Technical Symposium on Computer Science Education, Norfolk, VA, 2004. published or submitted for publicatio...|$|R
40|$|In today's well-connected environments of the Internet, intranets, and extranets, {{protecting}} the Microsoft Windows network {{can be a}} daunting task for the security engineer. Intrusion Detection Systems are a must-have for most companies, but few have either the financial resources or the people resources to implement and maintain full-scale intrusion detection systems for their networks and hosts. Many will at least invest in intrusion detection for their Internet presence, but others have not yet {{stepped up to the}} plate with regard to internal intrusion detection. Unfortunately, most attacks will come from within. Microsoft Windows server operating systems are widely used across both large and small enterprises. Unfortunately, there is no intrusion detection built-in to the Windows server operating system. The security logs are valuable but can be difficult to manage even in a small to medium sized environment. So the question arises, can one effectively detect and identify an in side intruder using the native tools that come with Microsoft Windows Server operating systems? One such method is to use Net Logon Service <b>debug</b> <b>logging</b> to identify and track malicious user activity. This paper discusses how to use Net Logon <b>debug</b> <b>logging</b> to identify and track malicious user activity both in real-time and for forensic analysis...|$|R
40|$|Abstract — The {{purpose of}} this study was to {{demonstrate}} that formal training in debugging helps students learn to diagnose and remove defects in computer programs. To accomplish this goal, students completed sets of debugging exercises before coding the programming assignments in an assembly language course. Each set of exercises focused on the major topics covered in the corresponding assignment. Students also kept <b>debugging</b> <b>logs</b> as they worked on the assignments. In these logs, students recorded the source of each defect and how the defect was corrected. Student re-sponse to these exercises, in the form of surveys, has been positive and constructive...|$|R
40|$|Debugging {{pervasive}} applications {{is difficult}} {{due to their}} distributed, asynchronous, and dynamic nature. To help ease the debugging process, we propose PerViz, a developer-targeted tool that enhances system visibility through real-time visualizations of system state, semi-automates application restarts and positioning, and enables both real-time and asynchronous collaboration in debugging between developers. Developers interact with PerViz through a web browser, which provides a convenient, centralized location to study and filter aggregated application <b>debugging</b> <b>logs</b> and state. In our experience with using PerViz, we have found its log aggregation and real-time visualizations to be key facilitators for effective debugging. T-Party Projec...|$|R
5000|$|External <b>debugging</b> using <b>logging</b> or {{serial port}} output to trace {{operation}} using either a monitor in flash or using a debug server like the Remedy Debugger which even works for heterogeneous multicore systems.|$|R
5000|$|Extensive <b>logging</b> & <b>debugging.</b> Enduro/X <b>logging</b> can be {{configured}} per binary {{with different}} log levels. As ATMI servers can be started outside of appserver, {{it is possible}} to debug them from programming IDE or with tools like valgrind.|$|R
5000|$|Autoconf-generated scripts {{are usually}} large and rather complex. Although they produce {{extensive}} <b>logging,</b> <b>debugging</b> them {{can still be}} difficult.|$|R
50|$|Event Viewer {{consists}} of a rewritten event tracing and logging architecture on Windows Vista. It has been rewritten around a structured XML log-format and a designated log type to allow applications to more precisely log events and to help {{make it easier for}} support technicians and developers to interpret the events. The XML representation of the event can be viewed on the Details tab in an event's properties. It is also possible to view all potential events, their structures, registered event publishers and their configuration using the wevtutil utility, even before the events are fired. There are a large number of different types of event logs including Administrative, Operational, Analytic, and <b>Debug</b> <b>log</b> types. Selecting the Application Logs node in the Scope pane reveals numerous new subcategorized event logs, including many labeled as diagnostic <b>logs.</b> Analytic and <b>Debug</b> events which are high frequency are directly saved into a trace file while Admin and Operational events are infrequent enough to allow additional processing without affecting system performance, so they are delivered to the Event Log service. Events are published asynchronously to reduce the performance impact on the event publishing application. Event attributes are also much more detailed and show EventID, Level, Task, Opcode, and Keywords properties.|$|R
50|$|Windows Vista {{includes}} {{a number of}} self-diagnostic features which help identify various problems and, if possible, suggest corrective actions. The event logging subsystem in Windows Vista also has been completely overhauled and rewritten around XML to allow applications to more precisely log events. Event Viewer has also been rewritten {{to take advantage of}} these new features. There are a large number of different types of event logs that can be monitored including Administrative, Operational, Analytic, and <b>Debug</b> <b>log</b> types. For instance, selecting the Application Logs node in the Scope pane reveals numerous new subcategorized event logs, including many labeled as diagnostic logs. Event logs can now be configured to be automatically forwarded to other systems running Windows Vista or Windows Server 2008. Event logs can also be remotely viewed from other computers or multiple event logs can be centrally logged and managed from a single computer. Event logs can be filtered by one or more criteria, and custom views can be created for one or more events. Such categorizing and advanced filtering allows viewing logs related only to a certain subsystem or an issue with only a certain component. Events can also be directly associated with tasks, via the redesigned Event Viewer.|$|R
40|$|Developing Web Applications with Oracle ADF Essentials {{covers the}} basics of Oracle ADF and then works through more complex topics such as <b>debugging</b> and <b>logging</b> {{features}} and JAAS Security in JDeveloper as the reader gains more skills. This book will follow a tutorial approach, using a practical example, with the content and tasks getting harder throughout. ""Developing Web Applications with Oracle ADF Essentials"" is {{for you if you}} want to build modern, user-friendly web applications for all kinds of data gathering, analysis, and presentations. You do not need to know any advanced HTML or JavaS...|$|R
40|$|Some concerns, such as <b>debugging</b> or <b>logging</b> functionality, {{can not be}} {{captured}} cleanly, and must be tangled and scattered throughout the code base. These concerns are called crosscutting concerns. Aspect-Oriented Programming (AOP) is a paradigm that enables developers to capture crosscutting concerns in separate aspect modules. The use of aspects {{has been shown to}} improve understandability and maintainability of systems. It has been shown that real-time concerns, such as memory management and thread scheduling,It has been shown that real-time concerns, such as memory management and thread scheduling, are crosscutting concerns [4, 5, 7, 10]...|$|R
30|$|Tracing is an {{efficient}} method to gather valuable {{information on a}} system, based on source-code instrumentation. The instrumentation will yield events when tracepoints are encountered, during the application’s workflow. Each event holds a payload and {{is associated with a}} finely-grained timestamp. Tracing is not to be mistaken with logging or profiling [6] as they serve different purposes. Logging is usually restricted to unusual or high-priority events such as system failures or abnormal behaviors. Profiling can be used to analyze the performances of separate parts of a system, giving an overview of useful metrics, without any need for events ordering. On the other hand, tracing can be used to monitor, <b>debug,</b> profile, or <b>log</b> systems behaviors [7] and is often the favored solution to debug and monitor concurrent programs [8]. However, please note that <b>logging,</b> <b>debugging,</b> profiling, and tracing can all be used at different phases during the development cycle, and thus the use of one does not preclude the utilization of the others.|$|R
5000|$|Error: An {{error is}} a {{discrepancy}} between the intended behaviour of a system and its actual behaviour inside the system boundary. Errors occur at runtime when {{some part of the}} system enters an unexpected state due to the activation of a fault. Since errors are generated from invalid states they are hard to observe without special mechanisms, such as debuggers or <b>debug</b> output to <b>logs.</b>|$|R
40|$|International audienceLogging is {{a common}} and {{important}} programming practice, but choosing how to log is challenging, especially in a large, evolving software code base that provides many logging alternatives. Insufficient <b>logging</b> may complicate <b>debugging,</b> while <b>logging</b> incorrectly may result in excessive performance overhead and an overload of trivial logs. The Linux kernel has over 13 million lines of code, over 1100 different logging functions, and the strategies for {{when and how to}} log have evolved over time. To help developers log correctly we propose a framework that will learn existing logging practices from the software development history, and that will be capable of identifying new logging strategies, even when the new strategies just start to be adopted...|$|R
50|$|ASObjC Explorer 4, from Shane Stanley: A {{discontinued}} third-party commercial IDE for AppleScript, {{especially for}} AppleScriptObjC. The main feature is Cocoa-object/event <b>logging,</b> <b>debugging</b> and code-completion. Users can read Cocoa events and objects like other scriptable applications. This tool was originally built for AppleScript Libraries (available in OS X Mavericks). AppleScript Libraries aims for re-usable AppleScript components and supports built-in AppleScript dictionary (sdef). ASObjC Explorer 4 {{can be an}} external Xcode script editor, too.|$|R
40|$|Machine level debuggers {{considered}} harmful. ◮ Optimizers scramble {{code and}} much be disabled to preserve mapping between source and machine code. ◮ Not clear what a simple compilation of SML would look like. ◮ Can we still use CPS? ◮ Closure conversion? ◮ What does a free variable look like? ◮ How should we represent a partially applied function so gdb can understand? ◮ Machine level debuggers are highly platform dependent. Interpretation is effective but very slow. ◮ Integrating a debugger and interpreter gives users tremendous flexibility for debugging. ◮ Interpreters can be machine independent. ◮ Unfortunately, interpretation in {{one to two}} orders slower than running compiled code. ◮ Maintaining a separate interpreter for debugging wastes effort. ◮ Interlisp and Saber-C use interpreter based <b>debugging.</b> <b>Logging</b> is portable, but limited ◮ <b>Logging</b> (or printf <b>debugging</b> or tracing) is feasible {{in the presence of}} debugging. ◮ However, traces are not interactive. ◮ The user can’t evaluate expressions in an arbitrary context. ◮ The user can’t fiddle with mutable state and continue execution. ◮ Examining logs ex post facto obscures the relation between current computation and external effects. We can instrument source code to provide interactive debugging. ◮ Instrumentation is an old idea. ◮ BUGTRAN, a FORTRAN debugger, used special punch cards. ◮ Dybvig, Friedman and Haynes implemented some debugging features with LISP macros. ◮ Source level instrumentation does not require runtime support. ◮ As all debugging operations are expressed in source, optimizations may be safely applied. ◮ Instrumentation is completely portable. ◮ This is Tolmach and Appel’s approach. The Debugging Model and Events Dynamic execution points are represented as events. Events occur at a place in time. The SML debugger allows the user to move forward and backwards with a combination of checkpointing and computation. |...|$|R
40|$|The thesis {{project is}} aimed to {{automate}} ultrasonic Time-of-Flight (ToF) technique for saw log classification using signal processing. The ToF technique works {{in such a}} way that ultrasonic tone-burst pulses are sent into a saw log, and then the ToF that the pulses take for the propagation is measured and used to calculate the sound speed and further, the Modulus of Elasticity (MoE). Based on the MoE, the quality of the logs is predicted and presorted before sawing. Development of matched filters is the central task for automating the ToF technique.   The whole project was carried out in two different parts: 1) Fundamentals and MATLAB implementation, and 2) Real-time implementation based on digital signal processor.      In the first part, fundamentals on the ToF technique and matched filters have been studied, and then MATLAB simulations of matched filters for automating the technique have been made. After this, test measurements have been conducted. The test results are shown to be consistent with the simulation: matched filtering works well for automating the ToF technique. In the second part of the report, an embedded algorithm has been developed and implemented on a Digital Signal Processor. The algorithm is the first step in the automation of measurements. Eventually, two test measurements have been performed with the DSP. The results were obtained using both oscilloscope to visualize and MATLAB to plot the obtained <b>debug</b> <b>log,</b> and they have shown that the algorithm works, and can automatically measure the ToF, which is in turn used to calculate the sound speed and MoE. The further work on the project that needs to be done, is to applying the developed system to the real situations in sawmills, and improving it according to their requirements...|$|R
40|$|Some concerns, such as <b>debugging</b> or <b>logging</b> functionality, {{can not be}} {{captured}} cleanly,and must be tangled and scattered throughout the code base. These concerns are calledcrosscutting concerns. Aspect-Oriented Programming (AOP) is a paradigm that enablesdevelopers to capture crosscutting concerns in separate aspect modules. The use ofaspects {{has been shown to}} improve understandability and maintainability of systems. It has been shown that real-time concerns, such as memory management and threadscheduling, are crosscutting concerns [4, 5, 7, 10]. However it is unclear whetherencapsulating these concerns provides benefits. We were interested in determiningwhether using AOP to encapsulate real-time crosscutting concerns afforded benefits insystem properties such as understandability and maintainability. This paper presentsresearch comparing the system properties of two systems: a real-time sentient trafficsimulator and its Aspect-Oriented equivalent. An evaluation of AOP is presentedindicating both benefits and drawbacks with this approach...|$|R
40|$|Some concerns, such as <b>debugging</b> or <b>logging</b> functionality, {{can not be}} {{captured}} cleanly, and must be tangled and scattered throughout the code base. These concerns are called crosscutting concerns. Aspect-Oriented Programming (AOP) is a paradigm that enables developers to capture crosscutting concerns in separate aspect modules. The use of aspects {{has been shown to}} improve understandability and maintainability of systems. It has been shown that real-time concerns, such as memory management and thread scheduling, are crosscutting concerns [4, 5, 7, 10]. However it is unclear whether encapsulating these concerns provides benefits. We were interested in determining whether using AOP to encapsulate real-time crosscutting concerns afforded benefits in system properties such as understandability and maintainability. This paper presents research comparing the system properties of two systems: a real-time sentient traffic simulator and its Aspect-Oriented equivalent. An evaluation of AOP is presented indicating both benefits and drawbacks with this approach. 1...|$|R
40|$|Default DATETIME columns to NULL in ClientJobsDAO for {{compatibility}} across mysql versions. As of mysql 5. 7. 8, {{values of}} 0 {{are not allowed}} for DATETIME columns, and CURRENT_TIMESTAMP is semantically inappropriate for those columns. Suppress this optional dependency on matplotlib without logging, because python logging implicitly adds the StreamHandler to root logger when calling <b>logging.</b> <b>debug,</b> etc., which may undermine an application's logging configuration Bugfix: Write the 'actualValues' to the output, don't reassign the output Fixed Username Regex in ClientJobsDAO cleaned up region a bit to make it compliant with numenta's coding guidelines...|$|R
40|$|USE LEO EMAILMany {{applications}} exhibit {{behavior that}} does not fit naturally into a single program module. Examples of typical concerns {{that are difficult to}} encapsulate using object oriented techniques are <b>logging,</b> <b>debugging,</b> and speech interaction. Aspect oriented programming enables developers to address behaviors that cut across typical module divisions, thus programmers of program modules need not be aware of the concerns from logically separate modules. This paper shows the process of speech-enabling the open source email application ICEMail using AOP techniques, resulting in increased modularity, significantly less effort and fewer lines of code...|$|R
40|$|Technology {{trends are}} {{extending}} the flexibility and convenience of today's sensor networks through {{the introduction of}} new capabilities such as multi-frequency radio transceivers, GPS, and innovative system management tools. This paper expands upon these motivations to present an integrated general-purpose MultimodAl system for NeTworks of In-situ wireless Sensors (MANTIS). The MANTIS system promotes multimodal flexibility and ease of use through its support for multimodal sensing including GPS-enabled location and time, multi-frequency communication, multitasking sensor nodes, and a new multi-platform operating system called MANTIS OS (MOS). For the novice, MANTIS provides convenient tools such as a simple cross-platform API, a remote shell for <b>debugging</b> and <b>logging</b> into MOS nodes, fine-grained dynamic reprogramming via the radio, and in-board sensor placement. For the expert, MANTIS supports true networked emulation of MOS sensor nodes as X 86 processes, as well as seamless bridging between an X 86 -based network of MOS virtual sensors and an actual sensor network of active physical MOS nodes, called nymphs...|$|R
40|$|Every large program {{contains}} {{a small fraction}} of functionality that resists proper encapsulation. Code for <b>debugging,</b> <b>logging,</b> or locking is hard to conceal using object-oriented mechanisms alone. As a result, this code ends up scattered across many classes, which makes it a maintenance problem. At the same time, this code is largely orthogonal to surrounding (or mainline) code as it rarely impacts control or data flow. This observation gave rise to aspect-oriented programming (AOP) as a solution: Functionality is encapsulated in so-called aspects that are woven into mainline code during compilation. For existing projects to benefit from AOP, the cross-cutting concerns must be identified first; this task is called aspect mining. In this paper we address it based on the hypothesis that a typical cross-cutting concerns is added to a project within a short amount of development time: We mine CVS archives for sets of methods that got added together in various unrelated locations. To compute these efficiently, we apply formal concept analysis [3]—an algebraic theory. In this paper, we describe the basic idea and report on results from an initial evaluation of our technique. 2 Mining Cross-Cutting Concerns In our approach we first collect the data that represents the history of a project, namely all transactions to the CVS archive of the project. In a second step, we use formal concept analysis to mine aspect candidates from each transaction. 2. 1 Version Archives and Transactions The history of a project is characterised by a sequence of CVS transaction. Each transaction represents the changes, i. e. addition and deletions, between the previous and the current version. Motivated by our previous dynamic aspect mining approaches that analysed program traces [1, 2], we are only interested in changes that insert (or delete) calls to methods. As we are interested in the introduction of cross-cutting concerns (due to our hypothesis that aspects emerge over time) we omit deletions of method calls and concentrate exclusively on additions of method calls. A method call is characterised by two components: a location l ∈ L where the call originates (in the body of a method) and the method m ∈ M being called...|$|R
40|$|Model checking, <b>logging,</b> <b>debugging,</b> and checkpointing/recovery {{are great}} tools to {{identify}} bugs in small sequential programs. The direct {{application of these}} techniques to the domain of distributed applications, however, has been less effective (mostly owing to {{the high degree of}} concurrency in this context). This paper presents the design of a hybrid tool, FixD, that attempts to address the deficiencies of these tools with respect to their application to distributed systems by using a novel composition of several of these existing techniques. The authors first identify and describe the four abstract components that comprise the FixD tool, then conclude with a proposal for how existing tools can be used to implement these components. 1...|$|R
40|$|Debugging {{embedded}} wireless {{systems can}} be cumbersome due to low visibility. To ease the task of debugging this paper present TinyDebug which is a multi-purpose passive debugging framework for developing embedded wireless sys-tems. TinyDebug {{is designed to be}} used throughout the entire system development process, ranging from simulation to actual deployment. TinyDebug provides out-of-the-box message oriented <b>debugging</b> and event <b>logging</b> mechanism while enabling more advanced debugging techniques to pro-cess the same debug events. We present the TinyDebug framework with all its features from event logging to extraction and show how the frame-work improves upon existing message based and event log-ging debugging techniques while enabling distributed event processing. We also present a number of optional event anal-ysis tools demonstrating the generality of the TinyDebug debug messages. 1...|$|R
40|$|Abstract—In this paper, {{we propose}} a novel {{architecture}} for {{wireless sensor network}} testbeds, called MOTEL. The main novelty compared to existing architectures is the possibility to include mobile sensor nodes. To support mobility, we deal with two main challenges: controlled mobility of sensor nodes, {{and the need to}} operate sensor nodes {{in the absence of a}} backchannel. We address these challenges together with traditional testbed requirements such as experiment repeatability, on-node <b>logging,</b> <b>debugging</b> and re-programming. MOTEL consists of two main components: MuRobA, a coordinated multi-robot architecture for enabling controlled mobility of the sensor nodes, and FLEXOR, a flexible sensor network architecture for enabling backchannel-free WSN experiments. MOTEL is work in progress and here we present the general architecture design of both MuRobA and FLEXOR, along with our first implementation and evaluation. I...|$|R
