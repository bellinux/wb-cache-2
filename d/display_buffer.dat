21|44|Public
5000|$|... #Caption: Exile is {{an example}} of a game where the {{developers}} left non-graphical data visible in the <b>display</b> <b>buffer</b> to gain additional memory space.|$|E
50|$|Like the BBC Micro, the Electron was {{constrained}} by limited memory resources. Of the 32 kB RAM, 3½ kB was {{allocated to the}} OS at startup and at least 10 kB was {{taken up by the}} <b>display</b> <b>buffer</b> in contiguous display modes.|$|E
50|$|TLI was {{responsible}} for many breakthroughs in graphics common in today’s mainstream including extended register sets, packed pixel 8, 15, 16, and 24-bit color modes, the first local bus graphics designs, the first integrated local bus controller, and Image Memory Access (IMA)- a high-speed asynchronous input for video or graphics into the <b>display</b> <b>buffer.</b>|$|E
25|$|Computer {{graphics}} and image processing, however, often use a coordinate {{system with the}} y-axis oriented downwards on the computer display. This convention developed in the 1960s (or earlier) from the way that images were originally stored in <b>display</b> <b>buffers.</b>|$|R
50|$|Wayland {{protocol}} {{follows a}} client-server {{model in which}} clients are the graphical applications requesting the <b>display</b> of pixel <b>buffers</b> on the screen, and the server (compositor) is the service provider controlling the <b>display</b> of these <b>buffers.</b>|$|R
50|$|Creating a 3D {{image for}} display {{consists}} {{of a series of}} steps. First, the objects to be displayed are loaded up into memory from individual models. The display system then applies mathematical functions to transform the models into a common coordinate system, the world view. From this world view, a series of polygons (typically triangles) is created that approximates the original models as seen from a particular viewpoint, the camera. Next, a compositing system produces an image by rendering the triangles and applying textures to the outside. Textures are small images that are painted onto the triangles to produce realism. The resulting image is then combined with various special effects, and moved into the <b>display</b> <b>buffers.</b> This basic conceptual layout is known as the display pipeline.|$|R
50|$|The Desktop Window Manager is a {{compositing}} window manager. This {{means that}} each program has a buffer that it writes data to; DWM then composites each program's buffer into a final image. By comparison, the stacking window manager in Windows XP and earlier (and also Windows Vista and Windows 7 with Windows Aero disabled) comprises a single <b>display</b> <b>buffer</b> {{to which all}} programs write.|$|E
50|$|At {{about the}} same time, another {{version of the same}} basic parts was built as the UV-1. In this case the machine was built as an {{all-in-one}} box, including the small amount of additional hardware needed to support the high-resolution mode of the Nutting chipset, which supplied 320 x 204 resolution with up to 8 colors per line. This mode required 16kB for the <b>display</b> <b>buffer</b> alone, so the machine included 32kB RAM and a larger 16kB ROM with additional Zgrass commands in it. To this basic system the Habitat added high quality video output circuitry and a floppy disk interface.|$|E
50|$|Additionally, the Akiko chip is able {{to perform}} simple 'chunky' to 'planar' {{graphics}} conversion in hardware. The Amiga's native display is a planar display which is simple and efficient to manipulate for routines like scrolling. However, chunky displays are faster and more efficient for 3D graphics manipulation. Akiko allows this conversion to be performed in hardware instead of relying on software conversion which would cause more overhead. The conversion works by writing 32 8-bit chunky pixels to Akiko's registers and reading back eight 32-bit words of converted planar data which can then be copied to the <b>display</b> <b>buffer.</b>|$|E
50|$|Cubes may be {{of various}} sizes and bit depths. Often 17×17×17 cubes are used as 3D LUTs. The most common {{practice}} is to use RGB 10-bit/component log images as the input to the 3D LUT. Output is usually RGB values {{that are to be}} placed unchanged into a <b>display</b> device's <b>buffer.</b>|$|R
25|$|More {{sophisticated}} receivers use {{a buffer}} memory to store {{some or all}} of the teletext pages as they are broadcast, allowing instant <b>display</b> from the <b>buffer.</b>|$|R
50|$|Emacs {{provides}} a {{command line interface}} {{in the form of}} its minibuffer. Commands and arguments can be entered using Emacs standard text editing support, and output is <b>displayed</b> in another <b>buffer.</b>|$|R
5000|$|Emacs Web Wowser (a backronym of [...] "eww") is a {{web browser}} written entirely in Emacs Lisp. It became part of GNU Emacs {{starting}} with version 24.4. If Emacs is compiled with the suitable image libraries, and is used in a graphical environment (such as under the X Window System), it can render images inline directly into Emacs's <b>display</b> <b>buffer.</b> It requires an Emacs built with libxml2 support. Written by Lars Magne Ingebrigtsen, it was originally developed {{as part of the}} Emacs mail reader Gnus, to display HTML-formatted email, but with the addition of HTTP support from Emacs' url.el package it became a fully-fledged browser.|$|E
5000|$|The Atari {{machines}} {{consist of}} a 6502 as the main processor, a combination of ANTIC and GTIA chips to provide graphics, and the POKEY chip to handle sound and serial input/output. These [...] "support" [...] chips are controlled via a series of registers that can be user-controlled via memory load/store instructions running on the 6502. For example, the GTIA uses a series of registers to select colors for the screen; these colors can be changed by inserting the correct values into its registers, which are mapped into [...] "memory" [...] that is visible to the 6502. Some parts of the system also {{use some of the}} machine's RAM as a buffer, notably the ANTIC's <b>display</b> <b>buffer</b> and its Display List (essentially a small program written in the chip's simple machine language that tells ANTIC how to interpret that data {{and turn it into a}} display), as well as GTIA's Player/Missile (sprite) information.|$|E
50|$|The Amstrad PCW family {{contains}} a Display List function called the 'Roller RAM'. This is a 512-byte RAM area consisting of 256 16-bit vectors into RAM, {{one for each}} line of the 720 × 256 pixel display. Each vector identifies the location of 90 bytes of monochrome pixels that hold the line's 720 pixel states. The 90 bytes of 8 pixel states are actually spaced at 8-byte intervals, so there are 7 unused bytes between each byte of pixel data. This suits how the text-orientated PCW constructs a typical screen buffer in RAM, where the first character's 8 rows are stored in the first 8 bytes, the second character's rows in the next 8 bytes and so on. The Roller RAM was implemented to speed up display scrolling {{as it would have}} been unacceptably slow for its 3.4 MHz Z80 to move up the 23 KB <b>display</b> <b>buffer</b> 'by hand' i.e. in software. The Roller RAM starting entry used {{at the beginning of a}} screen refresh is controlled by a Z80-writable I/O register. Therefore, the screen can be scrolled simply by changing this I/O register.|$|E
50|$|<b>Buffers</b> are <b>displayed</b> in windows, {{which are}} tiled {{portions}} of the terminal screen or the GUI window (called a frame in Emacs terms; multiple frames are possible). Unless configured otherwise, windows include scroll bars, line numbers, a header line at the top (usually <b>displaying</b> the <b>buffer</b> title or filename) and a mode line at the bottom (usually listing the active modes and point position of the buffer).|$|R
50|$|Edwin is the {{built-in}} Emacs-like editor {{that comes with}} MIT/GNU Scheme. Edwin normally <b>displays</b> the `*scheme*' <b>buffer,</b> the mode line, and the mini-buffer when it starts up. As in Emacs, the mode line gives information like {{the name of the}} buffer above it and whether that buffer is read-only, modified or unmodified.|$|R
40|$|The NOVA/IOPS (Input-Output Processor Simulator) is used {{to control}} all {{interface}} testing of the MDM (Multiplexer Demultiplexer) Breadboard S 10 10 M (serial input-output-input module) and the Matra Space Lab Inerface Unit (SL/BIU). The software handles bookkeeping such as word error rates, types of errors, <b>display</b> of error <b>buffers,</b> data <b>display</b> and test identification...|$|R
5000|$|The {{graphics}} mode of the Hercules card {{used the same}} raster format and timing as the MDA text mode, as stated above, but unlike the text mode, it made all pixels addressable. To support this mode, the MDA had a full 64 KB of video RAM - 16 times the RAM of an MDA (4 KB) and four times the RAM of a CGA card (16 KB). The Hercules {{graphics mode}} had {{a lot in common}} with the CGA high-resolution (640x200) two-color mode: the video buffer contained a packed-pixel bitmap (eight pixels per byte, one bit per pixel) with the same byte format, including the pixel-to-bit mapping and byte order, as the CGA two-color graphics mode, and the video buffer was split into interleaved banks, each 8 KB in size, as in the CGA graphics modes. However, because in the Hercules graphics mode there were more than 256 scanlines and the <b>display</b> <b>buffer</b> size was nearly 32 KB (instead of 16,000 bytes as in all CGA graphics modes), four interleaved banks were used in the Hercules mode instead of two as in the CGA modes. [...] Also, to represent 720 pixels per line instead of 640 as on the CGA, each scanline had 90 bytes of pixel data instead of 80.|$|E
5000|$|From a {{software}} perspective, the PCjr video hardware is an upward-compatible {{extension of the}} CGA, but differences in the hardware that affect mode and color selection make it incompatible from a strict hardware perspective. In general, the PCjr video hardware can do anything that a CGA can, but the design of hardware-control registers and the programming rules and techniques are different. The functions of the CGA Mode Register and Color Select Register are implemented in the VGA using different registers. The Status Register has been also moved into the VGA and has significant differences. Programs written for the CGA (using any mode or modes) work correctly and produce equivalent displays on the PCjr if they set modes only through the BIOS and control the image either through the BIOS or by directly accessing the <b>display</b> <b>buffer</b> (based at address 0xB8000) without attempting to write to or read from any video hardware registers, except certain registers of the 6845 CRTC. Those are the cursor-related registers, the light pen registers, and the start address registers. Alteration of other CRTC registers cannot be assumed to produce the same results from the PCjr video system as from the CGA (and might damage the monitor). (Programs for the CGA that manipulate the CRTC start address and that rely on address wrap-around above address 0xBC000 may not work correctly on the PCjr, because it always has a 32 KB contiguous block of RAM in the video area from address 0xB8000 through 0xBFFFF.) ...|$|E
5000|$|The {{character}} address increases linearly. When {{the chip}} signals horizontal sync {{it increases the}} row address. If the row address does not equal the programmatically set number of rows per character, then the character address is reset to the value it had {{at the beginning of}} the scanline that was just completed. Otherwise the row address is reset to zero and the memory address is continues increasing linearly. This causes the same sequence of character values to be re-read from the memory for each raster line of each character row, before the 6845 advances the memory address to the next character row and repeats the same pattern. Therefore, if a character occupies one [...] "word" [...] in the video buffer, a display of l lines and c columns of characters with s scan lines per character requires l × c words of memory to represent a full screen of characters but takes s times that many memory accesses to complete one refresh cycle (as each line of character words is repeatedly read s times before the next one is read). This means that character displays using the 6845, compared to all-points-addressable graphics displays of the same resolution, require much less memory but still require high memory bandwidth on the order of the bandwidth required for graphics. (A different video display controller that buffers one whole line of character data internally can avoid this repeated reading of each line of characters from the <b>display</b> <b>buffer</b> RAM, reducing the required memory bandwidth and allowing either slower, less expensive memory chips to be used, more time for a system CPU to access the memory, or a combination of both.) ...|$|E
50|$|Likewise, framebuffers {{differ from}} the {{technology}} used in early text <b>displays,</b> where a <b>buffer</b> holds codes for characters, not individual pixels. The video display device drives the electron beam in a raster pattern the same as with a framebuffer, but generates the pixels of each character in the buffer as it directs the beam.|$|R
5000|$|Random access memory became cheap {{enough to}} afford {{dedicating}} approximately 1-2 kilobytes of memory to a video <b>display</b> controller frame <b>buffer,</b> for a 40x25 or 80x25 text display or blocky color graphics {{on a common}} household television. This replaced the slow, complex, and expensive teletypewriter that was previously common as an interface to minicomputers and mainframes.|$|R
5000|$|Deinterlacing {{requires}} the <b>display</b> to <b>buffer</b> {{one or more}} fields and recombine them into full frames. In theory this would {{be as simple as}} capturing one field and combining it with the next field to be received, producing a single frame. However, the originally recorded signal was produced as a series of fields, and any motion of the subjects during the short period between the fields is encoded into the display. When combined into a single frame, the slight differences between the two fields due to this motion results in a [...] "combing" [...] effect where alternate lines are slightly displaced from each other.|$|R
5000|$|Users {{learned to}} use the offline key to take the {{terminal}} offline, edit {{a line in the}} <b>display</b> <b>buffer,</b> and then retransmit it. This gave the effect of command line recall and editing even if the operating system did not support it. For example, when working at an operating system's command prompt, an erroneous command could quickly be corrected and re-sent without having to retype the entire line. This was possible in many terminals of the day, but the HP 2640 was smart enough to only retransmit the line from the first character typed by the user, omitting, for example, the operating system's command prompt. This was later implemented as [...] "line mode". Another method was to paint a formatted with protected fields within a screen in character mode and place it into local edit mode similar to the above but the user did not know. This meant that the characters entered by the user would not be transmitted to the host until a 'special' key, typically the enter key, but other keys were also deemed special (i.e. immediate interrupt of the host) such as control y and function keys. Only the data within the unprotected areas would be transferred in this way, using a semi block mode mechanism, a sort of half way house between block mode and normal character mode, Formatted fields also meant forms could be stored in memory ( [...] tested for and recalled locally or repainted from the host if not present), just the unprotected data areas need be sent, thereby removing the need to repaint or issue direct cursor placements in order to update the screen (TIM/3000 Air Call Computer Systems). The PCL language was PCL level 3 in an HP645/7, which was later implemented to drive Hewlett Packards' first Laserjet printer.|$|E
30|$|Yang et al. [14] {{presented}} the SDHC card video player based on SoPC technology. The IP core and two <b>display</b> <b>buffer</b> SRAMs were alternately utilized for their proposed design. They have accessed the SDHC card in SD mode for bulk data transfer. The proposed design has been implemented using high-level language.|$|E
40|$|Pixel Data Access is an interprocess {{communication}} technique that enables users of {{graphical user interfaces}} to automate certain tasks. By accessing {{the contents of the}} <b>display</b> <b>buffer,</b> users can search for pixel representations of interface elements, and then initiate actions such as mouse clicks and keyboard entries. While this technique has limitations it offers users of current systems some unusually powerful features that are especially appealing in the area of end-user programming...|$|E
50|$|In computing, {{a screen}} buffer {{is a part}} of {{computer}} memory used by a computer application for the representation of the content to be shown on the computer <b>display.</b> The screen <b>buffer</b> may also be called the video buffer, the regeneration buffer, or regen buffer for short. Screen buffers should be distinguished from video memory. To this end, the term off-screen buffer is also used.|$|R
50|$|For printing, sixels {{are sent}} to the printer, decoded back into binary, and sent {{directly}} to the six pins of the print head. The only complexity involved expanding the RLEs into the internal print <b>buffer.</b> <b>Display</b> on a terminal is somewhat more difficult. On terminals supporting graphics, the ReGIS graphics system was used to directly draw the sixel pattern into the screen's bitmap. This was done at high speed by storing the bitmap patterns as a glyph and then bitting them.|$|R
50|$|Auburn was {{designed}} specifically {{to take advantage of}} (and promote) the use of AGP interface, during the time when many competing 3D accelerators (notably, 3dfx Voodoo Graphics) still used the PCI connection. A unique characteristic, which set the AGP version of the card apart from other similar devices on the market, was the use of on-board memory exclusively for the <b>display</b> frame <b>buffer,</b> with all textures being kept in the computer system's main RAM. At the time, most accelerators used the CPU for triangle setup and geometry calculations, then handed the data off to the card to apply texture mapping and bilinear filtering. By leaving this data in main memory, and giving the graphics card a high-speed channel to the data, performance could be improved while also reducing the total amount of memory in the system.|$|R
40|$|Pixel Data Access is an interprocess {{communication}} technique that enables users of {{graphical user interfaces}} to automate certain tasks. By accessing {{the contents of the}} <b>display</b> <b>buffer,</b> users can search for pixel representations of interface elements, and then initiate actions such as mouse clicks and keyboard entries. While this technique has limitations it offers users of current systems some unusually powerful features that are especially appealing in the area of end-user programming. Also cross-referenced as UMIACS-TR- 99 - 2...|$|E
40|$|Abstract. In {{the paper}} a no-reference system for quality {{assessment}} of video streaming over RTP is proposed for monitoring {{the quality of}} networked video. The proposed system is composed of four modules, where the quality assessment module utilizes information extracted from the bit-stream by the modules of RTP header analysis, frame header analysis and <b>display</b> <b>buffer</b> simulation. Taking MPEG- 4 encoded video stream over RTP as an example, the process of video quality assessment using the proposed system is described in this paper. The proposed system is featured by its high efficiency without sorting to the original video or video decoding, and therefore well suited for real-time networked video applications...|$|E
40|$|Presented is a {{progress}} report for the Regional Planetary Image Facilities (RPIF) prototype image data management and reduction system being jointly implemented by Washington University and the USGS, Flagstaff. The system will consist of a MicroVAX with a high capacity (approx 300 megabyte) disk drive, a compact disk player, an image <b>display</b> <b>buffer,</b> a videodisk player, USGS image processing software, and SYSTEM 1032 - a commercial relational database management package. The USGS, Flagstaff, will transfer their image processing software including radiometric and geometric calibration routines, to the MicroVAX environment. Washington University will have primary responsibility for developing the database management aspects {{of the system and}} for integrating the various aspects into a working system...|$|E
40|$|Our {{vision is}} an {{environment}} that allows (ordinary) PC-clients to profit from a rich collection of multimedia programs such as selected TV channels, video on demand, teleported lectures etc. In this article, we present the design and implementation of a corresponding local infrastructure both from a hard- and software perspective. Innovation highlights are (a) a switch-based network with guaranteed transmission bandwidth for audio/video streams, built-in multicast support and globally accessible <b>display</b> frame <b>buffers,</b> (b) a system for the integrated display of remotely generated video streams at the client site and (c) a central server {{for the management of}} the available multimedia programs. Keywords: client/server multimedia system, quality of service, networked peripherals, Oberon. 1. Introduction Thanks to the power, versatility and low cost of today's personal computers multimedia has become an attractive and widespread field of application. The unique combination of high-quali [...] ...|$|R
50|$|DirectX Graphics Infrastructure (DXGI) is a user-mode {{component}} of Windows Vista and above {{which provides a}} mapping between particular graphics APIs such as Direct3D 10.0 and above (known in DXGI parlance as producers) and the graphics kernel, which in turn interfaces with the user-mode Windows Display Driver Model driver. DXGI provides objects to handle tasks such as enumerating graphics adapters and monitors, enumerating <b>display</b> modes, choosing <b>buffer</b> formats, sharing resources between processes (such as between applications and the Desktop Window Manager), and presenting rendered frames to a window or monitor for display.|$|R
5000|$|Teletext is {{broadcast}} in numbered [...] "pages." [...] For example, {{a list of}} news headlines might appear on page 110; a teletext user would type [...] "110" [...] into the TV's remote control to view this page.The broadcaster constantly sends out pages in sequence. There will typically be a delay of a few seconds from requesting the page and it being broadcast and displayed, the time being entirely dependent {{in the number of}} pages being broadcast.More sophisticated receivers use a buffer memory to store {{some or all of the}} teletext pages as they are broadcast, allowing instant <b>display</b> from the <b>buffer.</b>|$|R
