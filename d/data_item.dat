1112|3668|Public
5|$|Type {{safety is}} {{variable}} in COBOL. Numeric data is converted between different representations and sizes silently and alphanumeric {{data can be}} placed in any <b>data</b> <b>item</b> that can be stored as a string, including numeric and group data. In contrast, object references and pointers may only be assigned from items of the same type and their values may be restricted to a certain type.|$|E
500|$|An 88 level-number {{declares}} a [...] (a so-called 88-level) {{which is}} true when its parent <b>data</b> <b>item</b> contains one of the values specified in its [...] clause. For example, the following code defines two 88-level condition-name items that are true or false depending on the current character data value of the [...] <b>data</b> <b>item.</b> When the <b>data</b> <b>item</b> contains a value of , the condition-name [...] is true, whereas when it contains a value of [...] or , the condition-name [...] is true. If the <b>data</b> <b>item</b> contains some other value, both of the condition-names are false.|$|E
500|$|The names , , and [...] are {{ambiguous}} by themselves, since {{more than}} one <b>data</b> <b>item</b> is defined with those names. To specify a particular <b>data</b> <b>item,</b> for instance one of the items contained within the [...] group, the programmer would use [...] (or the equivalent [...] ). (This syntax {{is similar to the}} [...] "dot notation" [...] supported by most contemporary languages.) ...|$|E
40|$|The {{rapid growth}} of data is inevitable, and {{retrieving}} the best results that meet the user’s preferences is essential. To achieve this, skylines were introduced in which <b>data</b> <b>items</b> that are not dominated by the other <b>data</b> <b>items</b> in the database are retrieved as results (skylines). In most of the existing skyline approaches, the databases {{are assumed to be}} static and complete. However, in real world scenario, databases are not complete especially in multidimensional databases in which some dimensions may have missing values. The databases might also be dynamic in which new <b>data</b> <b>items</b> are inserted while existing <b>data</b> <b>items</b> are deleted or updated. Blindly performing pairwise comparisons on the whole <b>data</b> <b>items</b> after the changes are made is inappropriate as not all <b>data</b> <b>items</b> need to be compared in identifying the skylines. Thus, a novel skyline algorithm, DInSkyline, is proposed in this study which finds the most relevant <b>data</b> <b>items</b> in dynamic and incomplete databases. Several experiments have been conducted and the results show that DInSkyline outperforms the previous works by reducing the number of pairwise comparisons in the range of 52...|$|R
50|$|DataBlitz also {{provides}} higher-layer interfaces for grouping related <b>data</b> <b>items,</b> and performing scans {{as well as}} associative access (via indices) on <b>data</b> <b>items</b> in a group...|$|R
30|$|An {{alternative}} {{data dissemination}} mechanism is the broadcast disks scheme, which permits <b>data</b> <b>items</b> to be broadcast with different frequencies [5]. This algorithm first divides <b>data</b> <b>items</b> {{into a few}} groups (i.e., disks) such that <b>data</b> <b>items</b> with similar popularity are assigned to the same disks. Afterwards, it determines the rotation speed of each disk according to the popularity of <b>data</b> <b>items.</b> In this way, one can construct a broadcast program that adjusts the trade-off between the access time of hot data and that of cold data.|$|R
500|$|COBOL code {{could only}} be modularized through procedures, which {{were found to be}} {{inadequate}} for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify [...] <b>data</b> <b>item.</b> Furthermore, {{there was no way to}} pass parameters to a procedure, an omission Jean Sammet regarded as the committee's biggest mistake.|$|E
500|$|Data {{items in}} COBOL are {{declared}} hierarchically {{through the use}} of level-numbers which indicate if a <b>data</b> <b>item</b> is part of another. An item with a higher level-number is subordinate to an item with a lower one. Top-level data items, with a level-number of 1, are called [...] Items that have subordinate aggregate data are called those that do not are called [...] Level-numbers used to describe standard data items are between 1 and 49.|$|E
500|$|The [...] {{statement}} {{is used to}} define loops which are executed [...] a condition is true (not [...] true, which {{is more common in}} other languages). It is also used to call procedures or ranges of procedures (see the procedures section for more details). [...] and [...] call subprograms and methods, respectively. The name of the subprogram/method is contained in a string which may be a literal or a <b>data</b> <b>item.</b> Parameters can be passed by reference, by content (where a copy is passed by reference) or by value (but only if a prototype is available).|$|E
5000|$|This model {{description}} is sourced from. The HDP {{is a model}} for grouped data. What {{this means is that}} the <b>data</b> <b>items</b> come in multiple distinct groups. For example, in a topic model words are organized into documents, with each document formed by a bag (group) of words (<b>data</b> <b>items).</b> Indexing groups by , suppose each group consist of <b>data</b> <b>items</b> [...]|$|R
40|$|The {{retention}} of communication data has recently attracted much public interest, {{mostly because of}} the possibility of its misuse. In this paper, we present protocols that address the privacy concerns of the communication partners. Our data retention protocols store streams of encrypted <b>data</b> <b>items,</b> some of which may be flagged as critical (representing misbehavior). The frequent occurrence of critical <b>data</b> <b>items</b> justifies the self-decryption of all recently stored <b>data</b> <b>items,</b> critical or not. Our first protocol allows the party gathering the retained data to decrypt all <b>data</b> <b>items</b> collected within, say, the last half year whenever the number of critical <b>data</b> <b>items</b> reaches some threshold within, say, the last month. The protocol ensures that the senders of data remain anonymous but may reveal that different critical <b>data</b> <b>items</b> came from the same sender. We call this the affiliation of critical data. Our second, computationally more complex scheme obscures the affiliation of critical data with high probability. ...|$|R
40|$|In the {{pervasive}} computing environment using smart devices equipped with various sensors, a wireless data broadcasting system for spatial <b>data</b> <b>items</b> {{is a natural}} way to efficiently provide a location dependent information service, regardless {{of the number of}} clients. A non-flat wireless broadcast system can support the clients in accessing quickly their preferred <b>data</b> <b>items</b> by disseminating the preferred <b>data</b> <b>items</b> more frequently than regular data on the wireless channel. To efficiently support the processing of spatial window queries in a non-flat wireless data broadcasting system, we propose a distributed air index based on a maximum boundary rectangle (MaxBR) over grid-cells (abbreviated DAIM), which uses MaxBRs for filtering out hot <b>data</b> <b>items</b> on the wireless channel. Unlike the existing index that repeats regular <b>data</b> <b>items</b> in close proximity to hot items at same frequency as hot <b>data</b> <b>items</b> in a broadcast cycle, DAIM makes it possible to repeat only hot <b>data</b> <b>items</b> in a cycle and reduces the length of the broadcast cycle. Consequently, DAIM helps the clients access the desired items quickly, improves the access time, and reduces energy consumption. In addition, a MaxBR helps the clients decide whether they have to access regular <b>data</b> <b>items</b> or not. Simulation studies show the proposed DAIM outperforms existing schemes with respect to the access time and energy consumption...|$|R
500|$|A [...] (or [...] ) clause is {{a string}} of characters, each of which {{represents}} {{a portion of the}} <b>data</b> <b>item</b> and what it may contain. Some picture characters specify the type of the item and how many characters or digits it occupies in memory. For example, a [...] indicates a decimal digit, and an [...] indicates that the item is signed. Other picture characters (called [...] and [...] characters) specify how an item should be formatted. For example, a series of [...] characters define character positions as well as how a leading sign character is to be positioned within the final character data; the rightmost non-numeric character will contain the item's sign, while other character positions corresponding to a [...] to the left of this position will contain a space. Repeated characters can be specified more concisely by specifying a number in parentheses after a picture character; for example, [...] is equivalent to [...] Picture specifications containing only digit (...) and sign (...) characters define purely [...] data items, while picture specifications containing alphabetic (...) or alphanumeric (...) characters define [...] data items. The presence of other formatting characters define [...] or [...] data items.|$|E
2500|$|Let A and B be {{two types}} of <b>data</b> <b>item.</b> Then the index of dissimilarity is ...|$|E
2500|$|In the {{original}} LISP {{there were two}} fundamental data types: atoms and lists. A list was a finite ordered sequence of elements, where each element is either an atom or a list, and an atom was a number or a symbol. A symbol was essentially a unique named item, written as an alphanumeric string in source code, and used either as a variable name or as a <b>data</b> <b>item</b> in symbolic processing. For example, the list [...] contains three elements: the symbol , the list , and the number 2.|$|E
30|$|In [5], {{this scheme}} assumes that <b>data</b> <b>items</b> are of equal sizes. In terms of practicality, {{it is not}} {{efficient}} to apply the broadcast disks to the varied-size <b>data</b> <b>items.</b> Moreover, {{it is hard for}} system developers to define the similarity of data popularity so as to partition <b>data</b> <b>items</b> into disks. The determination of the relative broadcast frequency for each disk is also imprecise. In this paper, we propose a ERB algorithm for varied-size <b>data</b> <b>items</b> to tackle the above drawbacks. The ERB algorithm grows a broadcast tree to determine the broadcast frequency of each data record. After that, we split the broadcast tree into some broadcast wood with similar sizes so as to place those <b>data</b> <b>items</b> in the broadcast cycle. The details are described clearly in section 3.|$|R
40|$|This paper {{studies the}} problem of {{identification}} and extraction of structured <b>data</b> <b>items</b> from the nested and flat records of given web pages. Each of such pages may contain several groups of structured records. Most of the existing methods still have certain limitations. In this paper, we propose a more novel and effective technique for the extraction of <b>data</b> <b>items.</b> Given a page, the proposed technique first identifies the data region based on the visual clue information. It then extracts each record from the data region and identifies it {{whether it is a}} flat or nested records based on visual information – the area covered and the number of <b>data</b> <b>items</b> present in each record. The next step is <b>data</b> <b>items</b> extraction from these records and transferring them into the database. Once the <b>data</b> <b>items</b> are present in the database knowledge discovery can be carried out. This technique extracts <b>data</b> <b>items</b> fro the both nested and flat records. Our experimental results show that the proposed technique is effective and better than existing techniques...|$|R
50|$|All <b>data</b> <b>items</b> are {{identified}} with a sequence number, which is used both {{to make sure that}} the data are delivered to the entity at the other end in the correct order, and to check for lost <b>data</b> <b>items.</b> The receiver sends back acknowledgements for <b>data</b> <b>items</b> which have been successfully received; a timer at the sender will cause a timeout if an acknowledgement is not received within a reasonable round trip time, and the (presumably lost) data will then be re-transmitted. To check that no <b>data</b> <b>items</b> are damaged, a checksum is used; one is computed at the sender for each block of data before it is sent, and checked at the receiver. Erroneous or missing data are reported to the sender, in order that it may retransmit the same. Any duplicated <b>data</b> <b>items</b> are discarded.|$|R
50|$|In COBOL, union {{data items}} are defined in two ways. The first uses the RENAMES (66 level) keyword, which {{effectively}} maps a second alphanumeric <b>data</b> <b>item</b> {{on top of}} the same memory location as a preceding <b>data</b> <b>item.</b> In the example code below, <b>data</b> <b>item</b> PERSON-REC is defined as a group containing another group and a numeric <b>data</b> <b>item.</b> PERSON-DATA is defined as an alphanumeric <b>data</b> <b>item</b> that renames PERSON-REC, treating the data bytes continued within it as character data.|$|E
5000|$|With read caches, a <b>data</b> <b>item</b> {{must have}} been fetched from its {{residing}} location {{at least once in}} order for subsequent reads of the <b>data</b> <b>item</b> to realize a performance increase by virtue of being able to be fetched from the cache's (faster) intermediate storage rather than the data's residing location. With write caches, a performance increase of writing a <b>data</b> <b>item</b> may be realized upon the first write of the <b>data</b> <b>item</b> by virtue of the <b>data</b> <b>item</b> immediately being stored in the cache's intermediate storage, deferring the transfer of the <b>data</b> <b>item</b> to its residing storage at a later stage or else occurring as a background process. Contrary to strict buffering, a caching process must adhere to a (potentially distributed) cache coherency protocol in order to maintain consistency between the cache's intermediate storage and the location where the data resides. Buffering, on the other hand, ...|$|E
5000|$|An 88 level-number {{declares}} a [...] (a so-called 88-level) {{which is}} true when its parent <b>data</b> <b>item</b> contains one of the values specified in its [...] clause. For example, the following code defines two 88-level condition-name items that are true or false depending on the current character data value of the [...] <b>data</b> <b>item.</b> When the <b>data</b> <b>item</b> contains a value of , the condition-name [...] is true, whereas when it contains a value of [...] or , the condition-name [...] is true. If the <b>data</b> <b>item</b> contains some other value, both of the condition-names are false.|$|E
40|$|Many {{approaches}} {{have been proposed}} to schedule <b>data</b> <b>items</b> for broadcasting in a mobile environment. However, the issues of accessing multiple <b>data</b> <b>items</b> on the broadcast channel are less discussed. In this paper, an efficient strategy for accessing multiple <b>data</b> <b>items</b> in mobile environments is proposed. Two issues are investigated in this paper, that is, deciding {{the content of the}} broadcast channel based on the queries from the clients, and scheduling the <b>data</b> <b>items</b> to be broadcast. Experiments are performed to compare our proposed methods for deciding the content and to show that our data scheduling methods can reduce the average access time without considerable increase on processing time...|$|R
40|$|Abstract. This work proposes LEASE, a novel Mobile-P 2 P lease-based {{economic}} incentive model, in which data requestors {{need to pay}} the price (in virtual currency) of their requested <b>data</b> <b>items</b> to data-providers. In LEASE, dataproviding mobile peers lease <b>data</b> <b>items</b> to free-riders, who do not have any <b>data</b> <b>items</b> to provide, in lieu of a lease payment. Thus, LEASE not only combats free-riding, but also entices free-riders to host <b>data</b> <b>items,</b> thereby improving network connectivity due to higher peer participation. In essence, LEASE facilitates the collaborative harnessing of limited mobile peer resources for improving data availability. Our performance study shows that LEASE indeed improves query response times and data availability in Mobile-P 2 P networks. ...|$|R
50|$|In a graph, <b>data</b> <b>items</b> have {{associations}} {{with one or}} more other <b>data</b> <b>items</b> in the collection and are somewhat like trees without the concept of a root or a parent-child relationship so that all <b>data</b> <b>items</b> are peers. Examples of operations on graphs are traversals and searches which explore the associations of <b>data</b> <b>items</b> looking for some specific property. Graphs are frequently used to model real-world situations and to solve related problems. An example is the Spanning tree protocol, which creates a graph (or mesh) representation of a data network and figures out which associations between switching nodes need to be broken {{to turn it into a}} tree and thus prevent data going around in loops.|$|R
50|$|A value {{written by}} a process on a <b>data</b> <b>item</b> X will be always {{available}} to a successive read operation performed by the same process on <b>data</b> <b>item</b> X.|$|E
50|$|Monotonic read {{consistency}} {{guarantees that}} after a process reads a value of <b>data</b> <b>item</b> x at time t, it will never see the older value of that <b>data</b> <b>item.</b>|$|E
5000|$|Each <b>data</b> <b>item</b> {{behaviour}} {{is defined}} by the Major Type and Additional Type. The major type is used for selecting the main behaviour or type of each <b>data</b> <b>item.</b>|$|E
40|$|In {{this article}} we study the data {{dissemination}} problem in which <b>data</b> <b>items</b> are flooded to all the moving objects in a mobile ad hoc network by peer-to-peer transfer. We show that if memory and bandwidth are bounded at moving objects, then the problem of determining whether a set of <b>data</b> <b>items</b> can be disseminated to all the moving objects is NP-complete. For a heuristic solution we postulate that a moving object should save and transmit the <b>data</b> <b>items</b> that {{are most likely to}} be new (i. e., previously unknown) to future encountered moving objects. We propose a method to be used by each moving object to prioritize <b>data</b> <b>items</b> based on their probabilities of being new to future receivers. The method employs a machine learning system for estimation of the novelty probability and the machine learning system is progressively trained by received <b>data</b> <b>items.</b> Through simulations based on real mobility traces, we show the superiority of the method against some natural alternatives...|$|R
3000|$|... {{because the}} {{proposed}} ERB algorithm broadcasts duplicates for those <b>data</b> <b>items</b> with high-access probability. Furthermore, {{the positions of}} the replicated <b>data</b> <b>items</b> in the broadcast cycle also determine the data items' waiting time. Therefore, in this paper, we introduce a specific L [...]...|$|R
40|$|Abstract:- Clustering of <b>data</b> <b>items</b> {{is one of}} the {{important}} applications of graph partitioning using a graph model. The pairwise similarities between all <b>data</b> <b>items</b> form the adjacency matrix of a weighted graph that contains all the necessary information for clustering. In this paper we propose a novel hybrid-evolutionary al-gorithm based on graph partitioning approach for data clustering. The algorithm is currently tested on synthetic datasets to allow controlled experiments and the results show that our method can effectively cluster <b>data</b> <b>items...</b>|$|R
5000|$|The quorum-based {{voting for}} replica control {{is due to}} 1979.Each copy of a {{replicated}} <b>data</b> <b>item</b> is assigned a vote. Each operation then has to obtain a read quorum (Vr) or a write quorum (Vw) to read or write a <b>data</b> <b>item,</b> respectively. If a given <b>data</b> <b>item</b> has a total of V votes, the quorums have to obey the following rules: ...|$|E
50|$|The {{first rule}} ensures that a <b>data</b> <b>item</b> is not read and written by two {{transactions}} concurrently. Additionally, it ensures that a read quorum contains {{at least one}} site with the newest version of the <b>data</b> <b>item.</b> The second rule ensures that two write operations from two transactions cannot occur concurrently on the same <b>data</b> <b>item.</b> The two rules ensure that one-copy serializability is maintained.|$|E
5000|$|In COBOL, a fully {{qualified}} <b>data</b> <b>item</b> name can {{be created}} by suffixing a potentially ambiguous identifier with an [...] (or [...] ) phrase. For example, multiple <b>data</b> <b>item</b> records might contain a member item named , so specifying [...] serves to disambiguate a specific [...] <b>data</b> <b>item,</b> specifically, {{the one that is}} a member of the parent [...] <b>data</b> <b>item.</b> Multiple clauses may be necessary to fully disambiguate a given identifier, for example, [...] This syntax is equivalent to the [...] "dotted" [...] notation employed in many object-oriented programming languages, but with the identifiers specified in reverse order.|$|E
5000|$|Sequencer - a {{tool for}} {{analyzing}} the quality of randomness {{in a sample of}} <b>data</b> <b>items.</b> It can be used to test an application's session tokens or other important <b>data</b> <b>items</b> that are intended to be unpredictable, such as anti-CSRF tokens, password reset tokens, etc.|$|R
40|$|Mobile Ad hoc {{networks}} formed between mobile nodes are networks {{without the}} need of any fixed substructure. Mobile Ad hoc networks are temporary networks which are constituted with mobile nodes such as laptop, personal digital assistant, Tablets, mobile phones etc. In Mobile Adhoc Networks accessibility of <b>data</b> <b>items</b> is a problem. So to enhance the accessibility of <b>data</b> <b>items</b> in the network we can do caching of <b>data</b> <b>items.</b> Caching of <b>data</b> <b>items</b> is known as Cache Management. In this paper, an intelligent caching scheme called Dynamic Group Caching is used which allows grouping of mobile hosts at one hop distance. Group formed will be managed by the Group Master and the Head of the group. This Cache Management can improve the performance of MANETs...|$|R
40|$|Recently, {{application-level}} isolation {{was introduced}} {{as an effective}} means of containing the damage that a suspicious user could inflict on data. In most cases, only a subset of the <b>data</b> <b>items</b> needs to be protected from damage due to the criticality level or integrity requirements of the <b>data</b> <b>items.</b> In such a case, complete isolation of a suspicious user can consume more resources than necessary. This paper proposes partitioning the <b>data</b> <b>items</b> into categories based on their criticality levels and integrity requirements; these categories determine the allowable data flows between trustworthy and suspicious users. An algorithm, that achieves good performance when the number of <b>data</b> <b>items</b> is small, is also provided to detect inconsistencies between suspicious versions of the data and the main version. ...|$|R
