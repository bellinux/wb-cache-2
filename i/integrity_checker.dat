18|0|Public
50|$|Samhain is an <b>integrity</b> <b>checker</b> {{and host}} {{intrusion}} detection system {{that can be used}} on single hosts as well as large, UNIX-based networks. It supports central monitoring as well as powerful (and new) stealth features to run undetected in memory, using steganography.|$|E
5000|$|HoneyClient [...] is a {{web browser}} based (IE/FireFox) high {{interaction}} client honeypot designed by Kathy Wang in 2004 and subsequently developed at MITRE. It was the first open source client honeypot and {{is a mix of}} Perl, C++, and Ruby. HoneyClient is state-based and detects attacks on Windows clients by monitoring files, process events, and registry entries. It has integrated the Capture-HPC real-time <b>integrity</b> <b>checker</b> to perform this detection. HoneyClient also contains a crawler, so it can be seeded with a list of initial URLs from which to start and can then continue to traverse web sites in search of client-side malware.|$|E
40|$|This thesis {{looks at}} file {{execution}} {{as an attack}} vector {{that leads to the}} execution of unauthorized code. File integrity checking is examined as a means of removing this attack vector, and the design, implementation, and evaluation of a best-of-breed file <b>integrity</b> <b>checker</b> for the Linux operating system is undertaken. We conclude that the resultant file <b>integrity</b> <b>checker</b> does succeed in removing file execution as an attack vector, does so at a computational cost that is negligible, and displays innovative and useful features that are not currently found in any other Linux file <b>integrity</b> <b>checker...</b>|$|E
40|$|The project’s {{objective}} is to build mechanisms that detect the faults expected in the Library 2000 (L 2000) system. The mechanisms include a local <b>integrity</b> <b>checker</b> and a remote <b>integrity</b> <b>checker.</b> The main accomplishments of the project are: • Design of the detection mechanisms • Analysis of the design {{in relation to the}} fault model...|$|E
30|$|CodeDog can {{be applied}} to any {{programming}} language and platforms, but, for evaluations, we choose C programming language and x 86 platform. We implemented CodeDog in two parts. First, we employ CIL [6] for the source code inspection and slot injection. And then, our binary rewriter module in python sets the marker values. In the slot injection, we define a new visitor in OCaml for CIL’s control statements, such as Goto, If, and Loop. 3 The visitor adds slots to the visited control statements. Second, we implement the <b>integrity</b> <b>checker</b> in python. Both the binary rewriter and the <b>integrity</b> <b>checker</b> use ndisasm and binutils to get the disassembled code from the binary code fragments.|$|E
40|$|Assuring {{that system}} files {{have not been}} {{tampered}} with over time is a vital, but oftoverlooked, aspect of system security. File integrity checkers provide ways to assure the validity of files on a system. This paper concerns itself with a review of file integrity checkers. It pays particular attention to what the minimum requirements for an <b>integrity</b> <b>checker</b> are, the different approaches taken to integrity checking, {{the strengths and weaknesses}} of each approach, major divisions in checker design, innovative or unusual features of certain checkers, and appropriate situations under which each type of checker should be used. The design of an <b>integrity</b> <b>checker</b> which combines the best features of various checkers is described and discussed...|$|E
40|$|In this paper, {{we present}} a {{processor}} that detects security-attacks at the instruction level by checking the integrity of instructions in real time. To confirm {{the integrity of the}} instructions, we generate a parity chain of instructions and check them at run time. The parity chain is generated using an error correction code used in a digital communication system, and the <b>integrity</b> <b>checker</b> has the same function as the error-detector module of the error correction code. This architecture can readily be applied to a general processor, because the checker is located between the processor core and the instruction memory. Compared with other cipher modules with the same key space, our instruction <b>integrity</b> <b>checker</b> achieves a faster check speed and occupies a smaller area...|$|E
40|$|Problem statement: As these {{detection}} methods were developed and implemented, the virus developers {{adapted to the}} new detectors in ways intended to defeat them. Approach: This study introduced new multilevel virus detection (MDS). Results: This system model depended on an advance behavior blocking technology. It detected virus-code by a behavior approach monitors and determined a virus activity at several protection system levels. Conclusion: This system simultaneously provided smart memory resident monitor, <b>integrity</b> <b>checker</b> and activity virus file (. BAT) checker...|$|E
40|$|Abstract: Problem statement: As these {{detection}} methods were developed and implemented, the virus developers {{adapted to the}} new detectors in ways intended to defeat them. Approach: This study introduced a new Multilevel virus detection (MDS). Results: This system model depends on an advance behavior blocking technology. It detects virus-code by a behavior approach monitors and determined a virus activity at several protection system levels. Conclusion: This system simultaneously provides smart memory resident monitor, <b>integrity</b> <b>checker</b> and activity virus file (. BAT) checker. Key words: Computer security, system security, computer viru...|$|E
40|$|This paper {{presents}} an <b>integrity</b> <b>checker</b> of JAVA P 2 P distributed system with auto source code composition. JAVA distributed system must guarantee {{the integrity of}} program itself and the system components of JAVA virtual machine against attackers, hackers, spies, cheaters, conspirators, etc. There are lots of trusted computing methods to guarantee {{the integrity of the}} system. We here present a novel method using just-in-time auto source code composition to generate autocheck class for integrity measure and encrypt of integrity reporting. By companies' effort, we have implemented and use it in DSCloud platform. Comment: 8 pages, 3 figures, ICNDC 2016 Conferenc...|$|E
40|$|Any {{protection}} mechanism opens {{an unexpected}} channel of communication, the so-called covert channel. The <b>Integrity</b> <b>Checker</b> of a database is a protection mechanism, against data inconsistencies. As such, it opens a covert channel {{which can be}} used to thwart the mechanism which ensures confidentiality. Therefore, confidential data can be unveiled leading to a the more semantic, the less secure » contradiction. The paper studies this contradiction in strictly defined situations : confidentiality is of discretionary type, consistency is ensured by binary integrity constraints and data of the database are the only knowledge used. The approach is relational. The expressive power of the relational model makes it possible to express both the formal properties on which unveilings are grounded and their computation. Keywords - Integrity Constraints, Discretionary Models of Confidentiality, Covert Channel, Relational Model. Introduction Integrity constraints are the means of ensuring that the d [...] ...|$|E
40|$|Abstract. We {{introduce}} a new cryptographic tool: multiset hash functions. Unlike standard hash functions which take strings as input, multiset hash functions operate on multisets (or sets). They map multisets of arbitrary finite size to strings (hashes) of fixed length. They are incremental in that, when new members {{are added to the}} multiset, the hash can be updated in time proportional to the change. The functions may be multiset-collision resistant in {{that it is difficult to}} find two multisets which produce the same hash, or just set-collision resistant in that it is difficult to find a set and a multiset which produce the same hash. We demonstrate how set-collision resistant multiset hash functions make an existing offline memory <b>integrity</b> <b>checker</b> secure against active adversaries. We improve on this checker such that it can use smaller time stamps without increasing the frequency of checks. The improved checker uses multiset-collision resistant multiset hash functions...|$|E
40|$|Anomaly {{detection}} is {{a commonly}} used approach for constructing intrusion detection systems. A key requirement {{is that the}} data used for building the resource profile are indeed attack-free, but this issue is often skipped or taken for granted. In this work we consider the problem of corruption in the learning data, {{with respect to a}} specific detection system, i. e., a web site <b>integrity</b> <b>checker.</b> We used corrupted learning sets and observed their impact on performance (in terms of false positives and false negatives). This analysis enabled us to gain important insights into this rather unexplored issue. Based on this analysis we also present a procedure for detecting whether a learning set is corrupted. We evaluated the performance of our proposal and obtained very good results up to a corruption rate close to 50 %. Our experiments are based on collections of real data and consider three different flavors of anomaly detection...|$|E
40|$|Tripwire is an {{integrity}} checking program {{written for the}} UNIX environment that gives system administrators the ability to monitor file systems for added, deleted, and modified files. Intended to aid intrusion detection, Tripwire was officially released on November 2, 1992, and is being actively used at thousands of sites around the world. Published in volume 26 of comp. sources. unix and archived at numerous FTP sites around the world, Tripwire is widely available and widely distributed. It is recommended by various response teams, including the CERT and CIAC. This paper begins by motivating {{the use of an}} <b>integrity</b> <b>checker</b> by presenting a hypothetical situation that any system administrator could face. An overview of Tripwire is described, emphasizing the salient aspects of Tripwire configuration that allows its use in modern UNIX sites. For example, how a system administrator would configure Tripwire for use in a large, heterogeneous site is presented. Experiences on how Trip [...] ...|$|E
40|$|We propose PowerAlert, an {{efficient}} external <b>integrity</b> <b>checker</b> for untrusted hosts. Current attestation systems suffer from shortcomings in requiring complete checksum {{of the code}} segment, being static, use of timing information sourced from the untrusted machine, or use of timing information with high error (network round trip time). We address those shortcomings by (1) using power measurements from the host {{to ensure that the}} checking code is executed and (2) checking a subset of the kernel space {{over a long period of}} time. We compare the power measurement against a learned power model of the execution of the machine and validate that the execution was not tampered. Finally, power diversifies the integrity checking program to prevent the attacker from adapting. We implement a prototype of PowerAlert using Raspberry pi and evaluate the performance of the integrity checking program generation. We model the interaction between PowerAlert and an attacker as a game. We study the effectiveness of the random initiation strategy in deterring the attacker. The study shows that forces the attacker to trade-off stealthiness for the risk of detection, while still maintaining an acceptable probability of detection given the long lifespan of stealthy attacks...|$|E
40|$|Attackers who {{are able}} to {{compromise}} a single node in a high performance computing cluster can use that node as a launch point for a number of malicious actions. In many cases, the password used to log into a single node can be used to access a large number of nodes in the system, allowing the attacker to utilize the vast computing and storage capabilities of the compromised cluster to sni# network tra#c, carry out bruteforce password cracking, launch distributed denial of service attacks, or serve illegal digital content. Often, these types of attackers modify important system files to collect passwords to other accounts, disable certain logging facilities, or create back-doors into the system. In this paper, we present Forseti, a distributed file <b>integrity</b> <b>checker</b> designed specifically for the high performance computing cluster environment. Forseti was designed to address the shortcomings exhibited by existing host-based intrusion detection systems when used in the cluster environment and to provide a means of detecting changes to critical system files made by rootlevel adversaries. We discuss the design and implementation of the Forseti system, present a security analysis of Forseti, examine the performance of the system, and explore how Forseti can be used in concert with other security monitoring techniques to enhance the security of the HPC cluster environment...|$|E
40|$|There {{are three}} phases of {{checking}} in flowHDL: dynamic checking, static checking, and pre-translation checking. Dynamic checking is initiated by flowHDL during the editing process. Static checking is {{initiated by the}} user after the design has been completed. Pre-translation checking is initiated by flowHDL just prior to translation to certain target HDLs. Once you have completed your design description, you can compile it. As the design is compiling, it is run through flowHDL’s model <b>integrity</b> <b>checker.</b> Once a model is built and passes the checker, {{you can use the}} flowHDL cycle-based simulator to functionally and behaviorally verify the design, and the flowHDL translator to generate HDL code. The dynamic checking function catches violations of object constraints that are commonly made during flowdiagram construction. If these errors were left undetected, the resultant design would not be correct when translated into code. These mistakes are very time consuming to check manually, and are usually based on editing and data entry errors rather than on flaws in the logic of your design. Many of these errors would be difficult to detect once entered into a block diagram, but would be critical during the design analysis stage. flowHDL does not allow you to perform operations that violate the constraints of flowdiagram methodology. These constraints are built into the flowHDL system. When you try to perform an operation that violates any of these constraints, an error message appears on-screen. The error message box gives you the name, number, and a brie...|$|E

