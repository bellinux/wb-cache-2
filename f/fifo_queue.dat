226|300|Public
5000|$|All {{recently}} accessed {{pages are}} placed in a <b>FIFO</b> <b>queue</b> called the LIRS stack (stack S in the graph), and all resident HIR pages are also placed in another <b>FIFO</b> <b>queue</b> (stack Q in the graph).|$|E
5000|$|... #Caption: Representation of a <b>FIFO</b> (<b>queue)</b> with enqueue and dequeue operations.|$|E
5000|$|HelpServ bots, which manage support {{requests}} {{in certain}} channels via a <b>FIFO</b> <b>queue.</b>|$|E
5000|$|Multiple <b>FIFO</b> <b>queues</b> {{are used}} and the {{operation}} is as follows: ...|$|R
40|$|In this paper, {{we study}} the timeout {{probability}} of TCP Reno under the bursty packet loss model, which {{is widely used}} to represent the loss characteristics of TCP under drop-tail <b>FIFO</b> <b>queues.</b> With a detailed analysis on the three timeout reasons for TCP Reno, we show {{that the impact of}} timeout has been underestimated in the existing literature. Surprisingly, we find that this more precise representation of timeout probability does not match the actual performance of TCP under drop-tail <b>FIFO</b> <b>queues.</b> Therefore we conclude that the bursty loss model is incapable of capturing the behavior of drop-tail <b>FIFO</b> <b>queues,</b> and using bursty loss model to analyze TCP performance is flawed. © 2005 IEEE. published_or_final_versio...|$|R
3000|$|Based on Figure 1, {{the four}} queues with four {{thresholds}} and weight-based scheduler are proposed; in addition, four individual <b>FIFO</b> <b>queues,</b> [...]...|$|R
50|$|A {{new process}} is {{inserted}} {{at the end}} (tail) of the top-level <b>FIFO</b> <b>queue.</b>|$|E
5000|$|Each node {{maintains}} a <b>FIFO</b> <b>queue</b> of requests each {{time that it}} sees the token; ...|$|E
5000|$|If node j <b>FIFO</b> <b>queue</b> is not empty, {{it simply}} shifts i into the queue ...|$|E
50|$|There {{are several}} {{efficient}} implementations of <b>FIFO</b> <b>queues.</b> An efficient implementation {{is one that}} can perform the operations—enqueuing and dequeuing—in O(1) time.|$|R
40|$|We {{investigate}} {{the performance of}} First-In, First-Out (<b>FIFO)</b> <b>queues</b> over wireless networks. We characterize the stability region of a general scenario where an arbitrary number of <b>FIFO</b> <b>queues,</b> which are served by a wireless medium, are shared by an arbitrary number of flows. In general, the stability region of this system is non-convex. Thus, we develop a convex inner-bound on the stability region, which is provably tight in certain cases. The convexity of the inner bound allows us to develop a resource allocation scheme; dFC. Based {{on the structure of}} dFC, we develop a stochastic flow control and scheduling algorithm; qFC. We show that qFC achieves optimal operating point in the convex inner bound. Simulation results show that our algorithms significantly improve the throughput of wireless networks with <b>FIFO</b> <b>queues,</b> as compared to the well-known queue-based flow control and max-weight scheduling...|$|R
40|$|Controller Area Network (CAN) {{is widely}} used in {{automotive}} applications. Existing schedulability analysis for CAN {{is based on the}} assumption that the highest priority message ready for transmission at each node on the network will be entered into arbitration on the bus. However, in practice, some CAN device drivers implement FIFO rather than priority-based queues invalidating this assumption. In this paper, we introduce response time analysis and optimal priority assignment policies for CAN messages in networks where some nodes use <b>FIFO</b> <b>queues</b> while other nodes use priority queues. We show, via a case study and experimental evaluation, the detrimental impact that <b>FIFO</b> <b>queues</b> have on the real-time performance of CAN. Further, we show that in gateway applications, if it is not possible to implement a priority queue, then it is preferable to use multiple <b>FIFO</b> <b>queues</b> each allocated a small number of messages with similar transmission deadlines. Extended version This paper forms an extended version of the paper...|$|R
50|$|Read {{and write}} {{addresses}} are initially {{both at the}} first memory location and the <b>FIFO</b> <b>queue</b> is Empty.|$|E
5000|$|Write {{atomicity}}: Write atomicity defines {{that memory}} requests are serviced {{based on the}} order of a single <b>FIFO</b> <b>queue.</b>|$|E
5000|$|The {{ends of a}} <b>FIFO</b> <b>queue</b> {{are often}} {{referred}} to as head and tail. Unfortunately, a controversy exists regarding those terms: ...|$|E
40|$|SRI International (SRI) has {{developed}} an improved queueing algorithm, known as Stochastic Fairness Queueing (SFQ), for best-effort traffic (i. e., traffic that does not require any guaranteed service). SFQ is a probablistic variant of strict fair queueing where instead of a single queue being allocated per flow, a fixed number of queues are used and a hash function maps the IP source and destination to a particular queue. A seed to the hash function is also perturbed occasionally to help distribute the flows amongst different queues when more than one flow maps to the same queue during the lifetime of the flow. SFQ provides 'fair' access by trying to ensure that each flow from source to destination host obtains equal access to the available bandwidth. This report covers a series of experiments performed on DARTnet evaluating the behavior and performance of SFQ against a <b>FIFO</b> <b>queueing</b> discipline. These experiments were designed to show SFQ's advantages and performance, and include tests demonstrating: Fair utilization of available resources; Starvation prevention; Graceful degradation under overload conditions; and Resource usage. In general, the experiments do show that SFQ is better than <b>FIFO</b> <b>queueing</b> at allocating bandwidth equally among a set of flows. SFQ also prevents a stream from dominating the available bandwidth, {{which seems to be}} a tendency with <b>FIFO</b> <b>queueing</b> (i. e., if a flow demands {{more than its share of}} the available bandwidth, with <b>FIFO</b> <b>queueing</b> that stream receives a disproportionate amount when compared to flows demanding less than their share). Furthermore, SFQ seems to reward 'nice' users of the network by providing a lower variance in delay and more throughput when their resource demand is less than their available share. Both SFQ and <b>FIFO</b> <b>queueing</b> seem to degrade fairly well as the network becomes saturated and to recover well as the network becomes less congested. Not unexpectedly, <b>FIFO</b> <b>queueing</b> is a little more efficient than SFQ-the delays are less and the throughput slightly higher because SFQ requires more processing. However, the performance difference between the two queueing disciplines is relatively small. However, the experiments do point out some interesting behavior. <b>FIFO</b> <b>queueing</b> can behave better than SFQ with seed perturbation. We recommend further evaluation of the hash function and the seed perturbation technique. There are probably weaknesses in their current selection that cause this unexpected behavior. SFQ also seems to possess good scaling properties. To verify this, more experiments with a larger number of streams from more hosts need to be executed and examined, including the staggered introduction of streams. Staggering the streams may prove important, because graphs in the degradation experiment revealed some unexpected increases and decreases in throughput, which should be examined. This may again be due to the interaction of the hash function with the seed perturbation but it may also be related to some other unknown problem...|$|R
40|$|Abstract—Active Queue Management (AQM) and Explicit Congestion Notification (ECN) are {{two methods}} {{that attempt to}} {{alleviate}} the problems of <b>FIFO</b> <b>queues</b> and of packet drops for congestion indication respectively. Random Early Detection (RED) {{is the most popular}} AQM method. The Domain Naming System (DNS) protocol is a core Internet protocol with very high impact on user experience and overall network functionality. This paper presents experimental results that show an inefficiency of RED that results in degraded performance of the DNS protocol when compared with <b>FIFO</b> <b>queues.</b> The results that are presented show 8 to 50 percentage points drop of DNS efficiency depending on network conditions...|$|R
5000|$|If {{the number}} of rankings is limited, it can be {{characterized}} as a collection of <b>FIFO</b> <b>queues,</b> one for each priority ranking. Processes in lower-priority queues are selected only when all of the higher-priority queues are empty.|$|R
50|$|Breadth-first search can {{be viewed}} as a special-case of Dijkstra's {{algorithm}} on unweighted graphs, where the priority queue degenerates into a <b>FIFO</b> <b>queue.</b>|$|E
50|$|Using this {{algorithm}} {{the cache}} behaves {{in the same}} way as a <b>FIFO</b> <b>queue.</b> The cache evicts the first block accessed first without any regard to how often or how many times it was accessed before.........|$|E
5000|$|Robotics: A robot {{subscribes to}} a remote sensor topic, {{but there is a}} notable lapse/delay (e.g. by <b>FIFO</b> <b>queue</b> processing) and the robot's logic decides to process the {{information}} differently depending on the time lapse. ROS Message Age ...|$|E
3000|$|... {{and for two}} {{different}} wireless channel models. This analysis suits well to the OFDM-based air interfaces which became viable for PTP wireless links [39, 40] while also being applicable to the downlink of a cellular system with <b>FIFO</b> <b>queuing.</b>|$|R
30|$|The Packet Memory module stores the packets {{used by the}} {{services}} {{to communicate with each}} other. The packets are organized in <b>FIFO</b> <b>queues,</b> from which services can allocate packets before sending them. This data space is shared among {{the services}}.|$|R
40|$|Abstract—Many of today’s {{computing}} {{and communication}} systems {{are based on}} <b>FIFO</b> <b>queues</b> whose performance, e. g., in terms of throughput and fairness, is highly impacted by load fluctuations, {{especially in the case}} of short-term overload. This paper analytically proves that overloaded <b>FIFO</b> <b>queues</b> are fair in the sense that each flow or aggregate of flows receives a proportional fair share of the service rate. The convergence rate is evaluated with respect to flow sizes and intensity of overutilization for two broad and distinctive arrival classes: Markovian and heavy-tailed/self-similar. For the former class the paper shows smaller convergence times at higher utilizations, which is exactly the opposite behavior characteristic to underloaded queueing systems. I...|$|R
50|$|In contrast, {{register}} machines hold temporary {{values in}} a small, fast array of registers. Accumulator machines {{have only one}} general-purpose register. Belt machines use a <b>FIFO</b> <b>queue</b> to hold temporary values. Memory-to-memory machines that have no temporary registers usable by a programmer.|$|E
50|$|ABQL also {{guarantees}} {{fairness in}} lock acquisition by using first in, first out (<b>FIFO)</b> <b>queue</b> based mechanism. Additionally, {{the number of}} invalidation is reduced significantly as opposed to ticket based lock implementation since only one processor incurs a cache miss on a lock release.|$|E
50|$|French and Spanish {{speakers}} sometimes use {{instead the}} term Ariadne's thread (in French fil d'Ariane) {{in relation to}} the thread left by Ariadne to Theseus so he can find the exit of the labyrinth after killing the Minotaur, on a LIFO (stack) instead of <b>FIFO</b> (<b>queue)</b> way.|$|E
40|$|Bounded single-producer single-consumer <b>FIFO</b> <b>queues</b> {{are one of}} the {{simplest}} concurrent data-structure, and they do not require more than sequential consistency for correct operation. Still, sequential consistency is an unrealistic hypothesis on shared-memory multiprocessors, and enforcing it through memory barriers induces signi cant performance and energy overhead. This paper revisits the optimization and correctness proof of bounded <b>FIFO</b> <b>queues</b> in the context of weak memory consistency, building upon the recent axiomatic formalization of the C 11 memory model. We validate the portability and performance of our proven implementation over 3 processor architectures with diverse hardware memory models, including ARM and PowerPC. Comparison with state-of-the-art implementations demonstrate consistent improvements {{for a wide range of}} bu er and batch sizes...|$|R
30|$|Services {{have a set}} {{of input}} ports, from which they read data, process it, and deliver it to a set of output ports. Connections deliver data from a service output port to a service input port and store the data as packets in <b>FIFO</b> <b>queues.</b>|$|R
40|$|Abstract — Controller Area Network (CAN) {{is widely}} used in {{automotive}} applications. Existing schedulability analysis for CAN {{is based on the}} assumption that the highest priority message ready for transmission at each node on the network will be entered into arbitration on the bus. However, in practice, some CAN device drivers implement FIFO rather than priority-based queues invalidating this assumption. In this paper, we introduce response time analysis and optimal priority assignment policies for CAN messages in networks where some nodes use <b>FIFO</b> <b>queues</b> while other nodes use priority queues. We show, via a case study and experimental evaluation, the detrimental impact that <b>FIFO</b> <b>queues</b> have on the real-time performance of CAN. Keywords-Controller Area Network (CAN); real-time scheduling; FIFO; fixed priority; priority assignment; priority order. I...|$|R
50|$|The Elastic.io {{platform}} is microservices-based, with Apache Mesos and Docker underlying the software. This means that each integration flow, each integration components, and the platform itself {{are composed of}} Docker containers connected to each other via persistent messaging <b>FIFO</b> <b>queue.</b> Each container is limited with its own resources.|$|E
50|$|In {{computer}} engineering and in programming language implementations, a belt machine {{is a real}} or emulated computer that uses a first in, first out (<b>FIFO)</b> <b>queue</b> rather than individual machine processor registers to evaluate each sub-expression in the program. A belt computer is programmed with an instruction set that specifies arguments explicitly but results implicitly.|$|E
50|$|The NOOP {{scheduler}} inserts all incoming I/O requests into {{a simple}} <b>FIFO</b> <b>queue</b> and implements request merging. This scheduler is useful {{when it has}} been determined that the host should not attempt to re-order requests based on the sector numbers contained therein. In other words, the scheduler assumes that the host is unaware of how to productively re-order requests.|$|E
40|$|Most multiprocessors are multiprogrammed {{in order}} to achieve {{acceptable}} response time and to increase utilization. Unfortunately, inopportune preemption may significantly degrade the performance of synchronized parallel applications. To address this problem, researchers have developed two principal strategies for concurrent, atomic update of shared data structures: preemption-safe locking and non-blocking (lock-free) algorithms. Preemption-safe locking requires kernel support. Non-blocking algorithms generally require a universal atomic primitive such as compare and swap or load linked/store conditional. We focus in our study on four simple but important concurrent data structures [...] -stacks, <b>FIFO</b> <b>queues,</b> priority queues and counters [...] -in synthetic kernels and real applications on a 12 -processor SGI Challenge multiprocessor. Our results indicate that efficient, data-structure-specific non-blocking algorithms, which exist for stacks, <b>FIFO</b> <b>queues</b> and counters, outperform both preemption-s [...] ...|$|R
40|$|In this {{contribution}} {{we present}} analysis and simulation results on controlling TCP rates by buffer allocation. When segment loss is low, TCP throughput depends {{primarily on the}} TCP window size, and the round trip time of the connection. As a result, {{it is possible to}} control TCP rates with <b>FIFO</b> <b>queuing...</b>|$|R
40|$|Process {{networks}} is {{a widely}} used model to describe highly concurrent applications. We present here a distributed implementation of a slightly restricted process network model realized using the CORBA middleware. This implementation allows the non computer science specialist to easily program heterogeneous meta-applications based on an assembly of components communicating through <b>FIFO</b> <b>queues.</b> ...|$|R
