0|10000|Public
5000|$|Hands-on athentication: The {{object is}} fully under <b>the</b> control <b>of</b> <b>the</b> <b>verifier.</b> <b>The</b> <b>verifier</b> can see if <b>the</b> object is <b>of</b> <b>the</b> correct type, size, weight etc.. E.g. {{he can see}} the {{difference}} between a real tooth and a hologram representing the tooth.|$|R
50|$|From {{its third}} series, she has {{appeared}} on Duck Quacks Don't Echo as one <b>of</b> <b>the</b> <b>verifiers.</b>|$|R
40|$|Abstract. <b>The</b> {{revocation}} <b>of</b> delegated {{rights and}} anonymity of proxy signer are essential issues <b>of</b> <b>the</b> proxy signature schemes. Based on the bilinear pairings, an anonymity-revoking proxy signature scheme was proposed. In this scheme, when an original signer {{found that a}} proxy signer was malicious or the delegation period was expired, he/she could revoke the malicious proxy signer’s signing capability efficiently through a trusted authority. On the other hand, only the signature from delegation <b>of</b> <b>the</b> original signer could be confirmed by <b>the</b> <b>verifier</b> and <b>the</b> <b>identity</b> <b>of</b> <b>the</b> proxy signer could not be known to <b>the</b> <b>verifier.</b> In appearing <b>of</b> disputation, <b>the</b> <b>verifier</b> could reveal <b>the</b> real <b>identity</b> <b>of</b> <b>the</b> proxy signer with <b>the</b> help <b>of</b> <b>the</b> original signer. This scheme can protect not only the original signer’s benefit but also the proxy signer s privacy...|$|R
5000|$|The above {{definition}} {{uses the}} somewhat arbitrary soundness error 2&minus;80.As {{long as the}} soundness error is bounded by a polynomial fraction <b>of</b> <b>the</b> potential running time <b>of</b> <b>the</b> <b>verifier</b> (i.e. [...] ), it is always possible to amplify soundness until the soundness error becomes negligible relative to <b>the</b> running time <b>of</b> <b>the</b> <b>verifier.</b> This is achieved by repeating the proof and accepting only if all proofs verify. After [...] repetitions, a soundness error [...] will be reduced to [...]|$|R
50|$|The {{randomness}} complexity r(n) <b>of</b> <b>the</b> <b>verifier</b> is <b>the</b> {{maximum number}} <b>of</b> random bits that V uses over all x of length n.|$|R
50|$|The query {{complexity}} q(n) <b>of</b> <b>the</b> <b>verifier</b> is <b>the</b> {{maximum number}} <b>of</b> queries that V makes to π over all x of length n.|$|R
3000|$|... threshold. Hence, {{there is}} some {{correlation}} between knowledge <b>of</b> <b>the</b> <b>verifier</b> and <b>the</b> ability <b>of</b> an imposter to match <b>the</b> reference signature <b>of</b> another user.|$|R
3000|$|... (x)). A {{table entry}} then {{consists}} <b>of</b> <b>the</b> <b>verifier,</b> it’s identifier (which is <b>the</b> index <b>of</b> <b>the</b> hash function), {{and the associated}} value v. Hence, E(x)←(V(h [...]...|$|R
5000|$|The {{definition}} given is that {{of perfect}} zero-knowledge. Computational zero-knowledge is obtained by requiring that <b>the</b> views <b>of</b> <b>the</b> <b>verifier</b> [...] and <b>the</b> simulator are only computationally indistinguishable, given the auxiliary string.|$|R
50|$|A unique game can {{be viewed}} as a special kind of nonadaptive {{probabilistically}} checkable proof with query complexity 2, where for each pair of possible queries <b>of</b> <b>the</b> <b>verifier</b> and each possible answer to the first query, there is exactly one possible answer to the second query that makes <b>the</b> <b>verifier</b> accept, and vice versa.|$|R
40|$|Abstract. <b>The</b> concept <b>of</b> {{zero-knowledge}} proofs {{has been}} around for about 25 years. It has been redefined over and over to suit the special security requirements of protocols and systems. Common among all definitions is <b>the</b> requirement <b>of</b> <b>the</b> existence <b>of</b> some efficient “device ” simulating <b>the</b> view <b>of</b> <b>the</b> <b>verifier</b> (or <b>the</b> transcript <b>of</b> <b>the</b> protocol), such that the simulation is indistinguishable from the reality. The definitions differ in many respects, including the type and power <b>of</b> <b>the</b> devices, <b>the</b> order <b>of</b> quantifiers, <b>the</b> type <b>of</b> indistinguishability, and so on. In this paper, we will scrutinize <b>the</b> definition <b>of</b> “black-box computational ” zero-knowledge, in which there exists one simulator for all <b>verifiers,</b> <b>the</b> simulator has black-box access to <b>the</b> <b>verifier,</b> and <b>the</b> quality <b>of</b> simulation is such that the real and simulated views cannot be distinguished by polynomial tests (computational indistinguisha-bility). Working in a theoretical model (the Random-Oracle Model), we show that the indistinguishability requirement is stated in a conceptually inappropriate way: Present definitions allow <b>the</b> knowledge <b>of</b> <b>the</b> <b>verifier</b> and distin-guisher to be independent, while the two entities are essentially coupled. Therefore, our main take on the problem will be conceptual and semantic, rather than literal. We formalize the concept by introducing a “knowledge ex-tractor ” into the model, which tries to extract the extra knowledge hard-coded into the distinguisher (if any), and then helps the simulator to construct <b>the</b> view <b>of</b> <b>the</b> <b>verifier.</b> <b>The</b> new paradigm is termed Simulation-Extractio...|$|R
5000|$|On {{the central}} leg <b>the</b> code <b>of</b> <b>the</b> {{producer}} company is shown along with <b>the</b> signature <b>of</b> <b>the</b> <b>verifier</b> and <b>the</b> name <b>of</b> <b>the</b> railway company that installed <b>the</b> <b>verifier.</b> If <b>the</b> EUR-pallet has been repaired already, then a round verification nail {{is put in}} the central chunk. The last numbers designate the production year and possibly <b>the</b> type <b>of</b> wood.|$|R
40|$|The Java {{virtual machine}} embodies a {{verifier}} that performs {{a set of}} checks on Java bytecode programs before their execution. <b>The</b> <b>verifier</b> carries out an efficient data-flow analysis applied to a type-level abstract interpretation <b>of</b> <b>the</b> code. <b>The</b> implementations <b>of</b> <b>the</b> bytecode <b>verifier</b> presented a significant problem with programs compiled with the Sun Java compiler (until version 1. 4. 1) : there were legal Java programs which were correctly compiled into a bytecode that was rejected by <b>the</b> <b>verifier.</b> <b>The</b> problem was fixed by removing, in version 1. 4. 2 and following, some interesting features in <b>the</b> compilation <b>of</b> <b>the</b> try-finally Java construct. Because removing such features has a cost in terms of memory space, {{in this paper we}} propose to enhance <b>the</b> bytecode <b>verifier</b> to accept such programs, maintaining <b>the</b> space efficiency <b>of</b> <b>the</b> previous versions <b>of</b> <b>the</b> compiler. We define an abstract interpretation framework in which we model <b>the</b> enhanced version <b>of</b> <b>the</b> <b>verifier.</b> <b>The</b> defined abstract interpretation framework can be considered a good basis for other static analyses of bytecode programs...|$|R
40|$|AbstractWe {{consider}} approximate PCPs for multidimensional bin-packing problems. In particular, we {{show how}} a verifier {{can be quickly}} convinced that a set of multidimensional blocks can be packed into a small number <b>of</b> bins. <b>The</b> running time <b>of</b> <b>the</b> <b>verifier</b> is bounded by O(logdn) where n is <b>the</b> number <b>of</b> blocks and d is the dimension...|$|R
40|$|SPIN is an {{efficient}} verification system for models of distributed software systems. It {{has been used}} to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview <b>of</b> <b>the</b> design and structure <b>of</b> <b>the</b> <b>verifier,</b> reviews its theoretical foundation, and gives an overview of significant practical applications...|$|R
50|$|Undeniable {{signature}} is {{a digital}} signature scheme and implementation {{which allows the}} signer to be selective to whom they verify signatures. The scheme adds explicit signature repudiation, preventing a signer later refusing the verify a signature by omission; a situation that would devalue the signature in <b>the</b> eyes <b>of</b> <b>the</b> <b>verifier.</b> It was invented by David Chaum and Hans van Antwerpen in 1989.|$|R
40|$|Abstract: Let C be a (fan-in 2) Boolean {{circuit of}} size s and depth d, and let x be an input for C. Assume that a verifier, that knows C {{but does not}} know x, can access <b>the</b> low-degree {{extension}} <b>of</b> x at one random point. Two competing provers try to convince <b>the</b> <b>verifier</b> that C(x) = 0 and C(x) = 1, respectively, and {{it is assumed that}} one <b>of</b> <b>the</b> provers is honest. For any r ≥ 1, we construct 1 an r-round protocol with communication complexity d 1 /r poly log(s) that convinces <b>the</b> <b>verifier</b> <b>of</b> <b>the</b> correct value <b>of</b> C(x) (with small probability of error). In particular, when we allow only one round, the protocol exchanges d ·poly log(s) bits, and when we allow r = O(log(d) /log log(s)) rounds, the protocol exchanges only poly log(s) bits. Moreover, <b>the</b> complexity <b>of</b> <b>the</b> <b>verifier</b> and <b>the</b> honest prover in this protocol is poly(s), and if in addition the circuit is log(s) -space uniform, <b>the</b> complexity <b>of</b> <b>the</b> <b>verifier</b> is d 1 /r poly log(s). The protocol is obtained by combining <b>the</b> delegation protocol <b>of</b> Goldwasser, Kalai, and Rothblum (STOC 2008), <b>the</b> competing-provers protocols <b>of</b> Feige and Kilian (STOC 1997), and some new techniques. We suggest two applications of these results...|$|R
40|$|We {{introduce}} pseudo-deterministic interactive proofs (psdAM) : interactive proof {{systems for}} search problems where <b>the</b> <b>verifier</b> is guaranteed with high probability to output the same output on different executions. As {{in the case}} with classical interactive proofs, <b>the</b> <b>verifier</b> is a probabilistic polynomial time algorithm interacting with an untrusted powerful prover. We view pseudo-deterministic interactive proofs as an extension <b>of</b> <b>the</b> study <b>of</b> pseudo-deterministic randomized polynomial time algorithms: <b>the</b> goal <b>of</b> <b>the</b> latter is to find canonical solutions to search problems whereas <b>the</b> goal <b>of</b> <b>the</b> former is to prove that a solution to a search problem is canonical to a probabilistic polynomial time verifier. Alternatively, one may think <b>of</b> <b>the</b> powerful prover as aiding the probabilistic polynomial time verifier to find canonical solutions to search problems, with high probability over <b>the</b> randomness <b>of</b> <b>the</b> <b>verifier.</b> <b>The</b> challenge is that pseudo-determinism should hold not only {{with respect to the}} randomness, but also with respect to the prover: a malicious prover should not be able to cause <b>the</b> <b>verifier</b> to output a solution other than the unique canonical one...|$|R
40|$|We {{propose a}} {{framework}} called configurable proofcarrying code, which allows <b>the</b> untrusted producer <b>of</b> mobile code to provide <b>the</b> bulk <b>of</b> <b>the</b> code <b>verifier</b> {{used by a}} code receiver to check <b>the</b> safety <b>of</b> <b>the</b> received code. The resulting system is both more flexible and also more trustworthy than a standard proof-carrying code system, because {{only a small part}} <b>of</b> <b>the</b> <b>verifier</b> needs to be trusted, while the remaining part can be configured freely to suit the safety policy on one hand, and <b>the</b> structure <b>of</b> <b>the</b> mobile code on the other hand. In this paper we describe formally the protocol that <b>the</b> untrusted <b>verifier</b> must follow in the interaction with the trusted infrastructure. We present a proof <b>of</b> <b>the</b> soundness <b>of</b> <b>the</b> system, and we give preliminary evidence that the architecture is expressive enough to delegate to <b>the</b> untrusted <b>verifier</b> even <b>the</b> handling <b>of</b> loop invariants, indirect jumps and calling conventions. 1...|$|R
40|$|Abstract—SPIN is an {{efficient}} verification system for models of distributed software systems. It {{has been used}} to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview <b>of</b> <b>the</b> design and structure <b>of</b> <b>the</b> <b>verifier,</b> reviews its theoretical foundation, and gives an overview of significant practical applications. Index Terms—Formal methods, program verification, design verification, model checking, distributed systems, concurrency...|$|R
3000|$|Given C̃^' j_i, its {{plaintext}} (which is r̃_i^j⊕ B^j_enroll_i) and <b>the</b> share <b>of</b> {{private key}} sk_i^ 2 <b>of</b> <b>the</b> <b>verifier</b> V <b>the</b> decryption share T̃_i^ 1,j {{can also be}} simulated as follows: The simulator computes b̃_ 0 = [...] [C̃^' j_i]^(N -p_ 0 -q_ 0 + 1)/ 4 N from the public information and computes b̃_ 2 = [...] [C̃^' j_i]^(-p_ 2 -q_ 2)/ 4 N since it knows sk_i^ 2 (i.e., p [...]...|$|R
40|$|In {{this article}} we {{introduce}} a new complexity class called PQMA_log(2). Informally, this is <b>the</b> class <b>of</b> languages for which membership has a logarithmic-size quantum proof with perfect completeness and soundness which is polynomially close to 1 in a context where <b>the</b> <b>verifier</b> is provided a proof with two unentangled parts. We then show that PQMA_log(2) = NP. For this to be possible, it is important, when defining the class, not to give too much power to <b>the</b> <b>verifier.</b> This result, {{when compared to the}} fact that QMA_log = BQP, gives us new insight on <b>the</b> power <b>of</b> quantum information and <b>the</b> impact <b>of</b> entanglement. Comment: <b>The</b> class QMA_Log(2) have been replace by PQMA_log(2) where <b>the</b> power <b>of</b> <b>the</b> <b>verifier</b> is slightly weake...|$|R
40|$|AbstractIn the {{standard}} Java implementation, a Java language program is compiled to Java bytecode and this bytecode is then {{interpreted by the}} Java Virtual Machine. Since bytecode may be written by hand, or corrupted during network transmission, the Java Virtual Machine contains a bytecode verifier that performs a number of consistency checks before code is interpreted. As one-step towards a formal specification <b>of</b> <b>the</b> <b>verifier,</b> we describe a precise specification of a subset <b>of</b> <b>the</b> bytecode language dealing with object creation and initialization...|$|R
40|$|We {{present a}} {{solution}} to <b>the</b> verification problem <b>of</b> high-level synthesis. <b>The</b> high-level synthesis system CALLAS takes as input an algorithmic specification, in VHDL, and produces as output an EDIF netlist. Both, the specification and the generated netlist {{can be interpreted as}} finite state machine descriptions. Then, in this context, the verification problem is reduced to proving <b>the</b> behavioral equivalence <b>of</b> both machines. For this equivalence proof we use <b>the</b> symbolic <b>verifier</b> <b>of</b> <b>the</b> CVE System (CVE = Circuit Verification Environment). Recent improvements <b>of</b> <b>the</b> <b>verifier</b> allowed equivalence proofs of machines with up to 260 binary state variables...|$|R
50|$|Rugg used an {{informal}} version <b>of</b> <b>the</b> <b>Verifier</b> method to re-assess previous {{work on the}} Voynich Manuscript, a manuscript widely {{believed to be a}} ciphertext based on a code which had resisted decipherment since the manuscript’s rediscovery by Wilfrid Voynich in 1912. Previous research had concluded that the manuscript contained linguistic features too complex to be readily explicable as a hoax, and too strange to be explicable as a transliteration of an unidentified language, leaving an uncracked cipher as the only realistic explanation.|$|R
40|$|Abstract. In 2010, M. Meziani and P. -L. Cayrel {{presented}} two post-quantum multi-signature schemes {{based on}} the syndrome decoding hard problem and error correcting codes. In this paper, we propose the insider forgery cryptanalysis of M. Meziani et al. ’s post-quantum multi-signature schemes. In M. Meziani et al. ’s schemes, <b>the</b> <b>verifier</b> only verifies <b>the</b> final multi-signature and does not check <b>the</b> validity <b>of</b> <b>the</b> partial signatures generated by other signers. Thus the malicious last signer can forge a valid multi-signature by himself/herself on behalf <b>of</b> <b>the</b> group <b>of</b> signers, which can pass <b>the</b> verification <b>of</b> <b>the</b> <b>verifier.</b> Therefore, M. Meziani et al. ’s post-quantum multi-signature schemes do not meet <b>the</b> security requirements <b>of</b> multi-signature schemes...|$|R
50|$|Because <b>the</b> purpose <b>of</b> {{proof of}} space {{is similar to}} proof <b>of</b> work, <b>the</b> <b>verifier's</b> time {{complexity}} must be very small. While such property may be useful for proof of secure erasure as well, it is not fundamental to its usefulness.|$|R
40|$|We {{construct}} a 1 -round delegation scheme for every language computable in time t = t(n) and space s = s(n), where <b>the</b> running time <b>of</b> <b>the</b> prover is poly(t) and <b>the</b> running time <b>of</b> <b>the</b> <b>verifier</b> is Õ(n + poly(s)) (where Õ hides polylog(t) factors). The proof exploits a curious connection between <b>the</b> problem <b>of</b> computation delegation and <b>the</b> model <b>of</b> multi-prover interactive proofs that are sound against no-signaling (cheating) strategies, {{a model that}} was studied in <b>the</b> context <b>of</b> multi-prover interactive proofs with provers that share quantum entanglement, and is motivated by the physical principle that information cannot travel faster than light. For any language computable in time t = t(n) and space s = s(n), we construct MIPs that are sound against no-signaling strategies, where <b>the</b> running time <b>of</b> <b>the</b> provers is poly(t), <b>the</b> number <b>of</b> provers is Õ(s), and <b>the</b> running time <b>of</b> <b>the</b> <b>verifier</b> is Õ(s + n). We then show {{how to use the}} method suggested by Aiello et al. (ICALP, 2000) to convert our MIP into a 1 -round delegation scheme, by using a computational private information retrieval (PIR) scheme. Thus, assuming <b>the</b> existence <b>of</b> a sub-exponentially secure PIR scheme, we get our 1 -round delegation scheme. 1...|$|R
40|$|Let C be a (fan-in 2) Boolean {{circuit of}} size s and depth d, and let x be an input for C. Assume that a {{verifier}} that knows C but doesn’t know x can access the low degree extension of x at one random point. Two competing provers {{try to convince}} <b>the</b> <b>verifier</b> that C(x) = 0 and C(x) = 1, respectively, and assume that one <b>of</b> <b>the</b> provers is honest. For any r ≥ 1, we give an r rounds protocol with communication complexity d 1 r polylog (s) that convinces <b>the</b> <b>verifier</b> in <b>the</b> correct value <b>of</b> C(x) (with small probability of error). In particular, when we allow only one round, the protocol exchanges d · polylog (s) bits, and when we allow r = O rounds, the protocol exchanges only log(d) loglog(s) polylog (s) bits. Moreover, <b>the</b> complexity <b>of</b> <b>the</b> <b>verifier</b> and honest provers in this protocol is poly(s), and if in addition the circuit is log(s) -space uniform, <b>the</b> complexity <b>of</b> <b>the</b> <b>verifier</b> is d 1 r polylog (s). 1 The protocol is obtained by combining <b>the</b> delegation protocol <b>of</b> Goldwasser, Kalai and Rothblum [5] and the competing provers protocols of Feige and Kilian [3] and some new techniques. We suggest two applications of these results: Delegating computation to competing clouds: The main motivation behind <b>the</b> protocol <b>of</b> [5] was delegating computation to a cloud. Using our new protocol, a verifier can delegate computation to two (or more) competing clouds. If at least one <b>of</b> <b>the</b> clouds is reliable <b>the</b> <b>verifier</b> can trust that the computation is correct (with high probability). The advantage over <b>the</b> protocol <b>of</b> [5] is that the communication complexity and <b>the</b> number <b>of</b> rounds in our protocol are significantly lower. Communication complexity with competin...|$|R
40|$|Abstract. In {{the bare}} public-key model, {{introduced}} by Canetti et al. [STOC 2000], {{it is only}} assumed that each verifier deposits during a setup phase a public key in a file accessible by all users at all times. As pointed out by Micali and Reyzin [Crypto 2001], <b>the</b> notion <b>of</b> soundness in this model is more subtle and complex than in the classical model. Indeed Micali and Reyzin have introduced four different notions which are called (from weaker to stronger) : one-time, sequential, concurrent and resettable soundness. In this paper we introduce the counter public-key model (the cPK model for short), an augmentation <b>of</b> <b>the</b> bare public-key model in which each verifier {{is equipped with a}} counter and, like in the original bare public-key model, <b>the</b> key <b>of</b> <b>the</b> <b>verifier</b> can be used for any polynomial number of interactions with provers. In the cPK model, we give a three-round concurrently-sound resettable zero-knowledge argument of membership for NP. Previously similar results were obtained by Micali and Reyzin [EuroCrypt 2001] and then improved by Zhao et al. [EuroCrypt 2003] in models in which, roughly speaking, each verifier is still equipped with a counter, but <b>the</b> key <b>of</b> <b>the</b> <b>verifier</b> could only be used for a fixed number of interactions. ...|$|R
40|$|We discuss quantum {{position}} verification (QPV) protocols {{in which}} <b>the</b> <b>verifiers</b> create and send single-qubit {{states to the}} prover. QPV protocols using single-qubit states {{are known to be}} insecure against adversaries that share a small number of entangled qubits. We introduce QPV protocols that are practically secure: they only require single-qubit states from each <b>of</b> <b>the</b> <b>verifiers,</b> yet their security is broken if the adversaries share an impractically large number of shared entangled qubits. These protocols are a modification of known QPV protocols in which we include a classical random oracle without altering <b>the</b> amount <b>of</b> quantum resources needed by <b>the</b> <b>verifiers.</b> We present a cheating strategy that requires a number of entangled qubits shared among the adversaries that grows exponentially with <b>the</b> size <b>of</b> <b>the</b> classical input <b>of</b> <b>the</b> random oracle. Comment: 7 pages, 1 figur...|$|R
40|$|In this poster, we generalize <b>the</b> problem <b>of</b> secure loca-tion {{verification}} {{to that of}} path verification and {{propose a}} scheme to securely verify <b>the</b> claims <b>of</b> a mobile node that moves along a path. Although <b>the</b> secure verification <b>of</b> lo-cation claims has been studied extensively in the literature, current solutions require very strict time synchronization <b>of</b> <b>the</b> <b>verifiers,</b> or extra communication and special-purpose hardware. However, we propose a lightweight verification scheme exploiting <b>the</b> mobility <b>of</b> <b>the</b> claimer in path veri-fication without need for time synchronization and commu-nication overhead. 1...|$|R
5000|$|The class MA in {{particular}} is a simple generalization <b>of</b> <b>the</b> NP interaction above in which <b>the</b> <b>verifier</b> is probabilistic instead of deterministic. Also, instead <b>of</b> requiring that <b>the</b> <b>verifier</b> always accept valid certificates and reject invalid certificates, it is more lenient: ...|$|R
40|$|This paper gives a {{mathematical}} specification the Java Virtual Machine (JVM) bytecode <b>verifier.</b> <b>The</b> specification is an axiomatic description <b>of</b> <b>the</b> <b>verifier</b> that makes precise subtle aspects <b>of</b> <b>the</b> JVM semantics and <b>the</b> <b>verifier.</b> We focus on <b>the</b> use <b>of</b> data flow analysis to verify type-correctness and <b>the</b> use <b>of</b> typing contexts to insure global type consistency in <b>the</b> context <b>of</b> an arbitrary strategy for dynamic class loading. The specification types interfaces with sufficient accuracy to eliminate run-time type checks. Our {{approach is to}} specify a generic dataflow architecture and formalize <b>the</b> JVM <b>verifier</b> as an instance <b>of</b> this architecture. <b>The</b> emphasis in this paper is on readability <b>of</b> <b>the</b> specification and mathematical clarity. The specification given {{is consistent with the}} descriptions in the Lindholm's and Yellin's The Java^TM Virtual Machine Specification. It less committed to certain implementation choices than Sun's version 1. 1 implementation. In particular, the specific [...] ...|$|R
40|$|In this paper, {{we propose}} a new society {{oriented}} scheme, {{based on the}} Guillou-Quisquater signature scheme. The scheme is identity-based and the signatures are verified with respect to only one identity. That is, <b>the</b> <b>verifier</b> {{does not have to}} know <b>the</b> <b>identity</b> <b>of</b> <b>the</b> co-signers, but just that <b>of</b> <b>the</b> organization they represent. © 2002 Elsevier Science B. V. All rights reserved. SCOPUS: ar. jinfo:eu-repo/semantics/publishe...|$|R
40|$|In {{networks}} and entity groupings that have sensitive resources, user identification {{is a crucial}} requirement for secure access, communication and transactions involving those resources. However, there are {{networks and}} entity groupings that require entity authentication while preserving <b>the</b> privacy <b>of</b> <b>the</b> entity being authenticated. There are several zero-knowledge protocols (ZKP) including the Fiege-Fiat-Shamir that authenticate an entity anonymously. We present a revised Feige-Fiat-Shamir ZKP scheme for the Airborne Networks (ANs) that reduces the ping-pong effect in the scheme and speeds up <b>the</b> growth <b>of</b> <b>the</b> <b>Verifier</b> trust <b>of</b> <b>the</b> Prover, thus making the authentication process faster and more efficient...|$|R
