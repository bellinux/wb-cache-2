10|30|Public
50|$|Initially, Novell {{published}} a development toolkit for NLM programming including kernel API documentation and a C compiler (Watcom), but third-party {{support for the}} NLM <b>executable</b> <b>function</b> was very limited.|$|E
50|$|C#, unlike Java, {{allows the}} use of lambda {{functions}} {{as a way to}} define special data structures called expression trees. Whether they are seen as an <b>executable</b> <b>function</b> or as a data structure depends on compiler type inference and what type of variable or parameter they are assigned or cast to. Lambdas and expression trees play key roles in Language Integrated Query (LINQ).|$|E
40|$|We {{present a}} complete, certificate-based {{decision}} procedure for first-order univariate polynomial problems in Isabelle. It {{is built around}} an <b>executable</b> <b>function</b> to decide {{the sign of a}} univariate polynomial at a real algebraic point. The procedure relies on no trusted code except for Isabelle's kernel and code generation. This work is the first step towards integrating the MetiTarski theorem prover into Isabelle. Comment: 15 page...|$|E
40|$|We give a {{formalization}} of affine forms [1, 2] as abstract representa-tions of zonotopes. We provide affine {{operations as}} well as overapproxi-mations of some non-affine operations like multiplication and division. Expressions involving those operations can automatically be turned into (<b>executable)</b> <b>functions</b> approximating the original expression i...|$|R
5000|$|VDM-SL also {{supports}} {{the definition of}} <b>executable</b> <b>functions</b> {{in the manner of}} a functional programming language. In an explicit function definition, the result is defined by means of an expression over the inputs. For example, a function that produces a list of the squares of a list of numbers might be defined as follows: ...|$|R
50|$|When {{employed}} for client-side web development in Microsoft Internet Explorer, VBScript {{is similar in}} function to JavaScript. It is used to write <b>executable</b> <b>functions</b> that are embedded in or included from HTML pages and interact with the Document Object Model (DOM) of the page, to perform tasks not possible in HTML alone. However, other web browsers such as Firefox and Opera do not have built-in support for VBScript. This means that where client-side scripting and cross-browser compatibility are required, developers usually choose JavaScript over VBScript.|$|R
40|$|Abstract- This paper {{suggests}} a comprehensive engineering framework for software design for component-based distributed industrial automation {{based on the}} combination of UML with the function block concept of the newly emerging international standard IEC 61499. Four UML diagram types have been used, namely: class, sequence, cooperation and state-chart diagrams. The UML design is transformed then to the <b>executable</b> <b>function</b> block specification following the IEC 61499. I...|$|E
40|$|Abstract. We {{address the}} problem of {{maintaining}} information flow security un-der refinement and transformation. To this end we define a schema for the specifi-cation of secure information flow properties and show that all security properties defined in the schema are preserved by a notion of refinement. Refinement is a process that requires human guidance and is in general not subject for automation. A transformation on the other hand, is an <b>executable</b> <b>function</b> mapping specifica-tions to specifications. We define an interpretation of transformations and propose a condition under which transformations maintain security. ...|$|E
40|$|The Model-Driven Architecture (MDA) {{approach}} for constructing software systems advocates a stepwise refinement and transformation process starting from high-level models to concrete program code. In contrast to numerous research e#orts {{that try to}} generate <b>executable</b> <b>function</b> code from models, we propose a novel approach termed model-driven monitoring. On the model level the behavior of an operation is specified {{with a pair of}} UML composite structure diagrams (visual contract), a visual notation for pre- and post-conditions. The specified behavior is implemented by a programmer manually. An automatic translation from our visual contracts to JML assertions allows for monitoring the hand-coded programs during their execution. In this pape...|$|E
40|$|We {{provide the}} {{operations}} of matrix addition, multiplication, transposition, and matrix comparisons as <b>executable</b> <b>functions</b> over ordered semirings. Moreover, it is proven that strongly normalizing (monotone) orders can be lifted to strongly normalizing (monotone) orders over matrices. We further show that the standard semirings over the naturals, integers, and rationals, {{as well as the}} arctic semirings satisfy the axioms that are required by our matrix theory. Our formalization was performed as part of the IsaFoR/CeTA-system [3] 1 which contains several termination techniques. The provided theories have been essential to formalize matrix-interpretations [1] and arctic interpretations [2]. A short description of this formalization can be found in [4]...|$|R
40|$|Abstract. We {{present a}} {{practical}} tool for defining and proving properties of recursive {{functions in the}} Coq proof assistant. The tool generates from pseudo-code the graph of the intended function as an inductive relation. Then it proves that the relation actually represents a function, which is by construction the function that {{we are trying to}} define. Then, we generate induction and inversion principles, and a fixpoint equation for proving other properties of the function. Our tool builds upon stateof-the-art techniques for defining recursive functions, and {{can also be used to}} generate <b>executable</b> <b>functions</b> from inductive descriptions of their graph. We illustrate the benefits of our tool on two case studies. ...|$|R
5000|$|PaX is {{supposed}} to guarantee that no RAM is both writable and <b>executable.</b> One <b>function,</b> the mprotect (...) function, changes the permissions on a memory area. The Single UNIX Specification defines mprotect (...) with the following note in its description: ...|$|R
40|$|The model-driven {{development}} (MDD) {{approach for}} constructing software systems advocates a stepwise refinement and transformation process starting from high-level models to concrete program code. In contrast to numerous research efforts {{that try to}} generate <b>executable</b> <b>function</b> code from models, we propose a novel approach termed model-driven monitoring. Here, models are used to specify minimal requirements and are transformed into assertions on the code level for monitoring hand-coded programs during execution. We show how well-understood results from the graph transformation community can be deployed to support this model-driven monitoring approach. In particular, models {{in the form of}} visual contracts are defined by graph transitions with loose semantics, while the automatic transformation from models to JML assertions on the code level is defined by strict graph transformation rules. Both aspects are supported and realized by a dedicated Eclipse plug-in...|$|E
40|$|In his {{proof of}} the Kepler conjecture, Thomas Hales {{introduced}} the notion of tame graphs and provided a Java program for enumerating all tame plane graphs. We have translated his Java program into an <b>executable</b> <b>function</b> in HOL ("the generator"), have formalized the notions of tameness and planarity in HOL, and have partially proved that the generator returns all tame plane graphs. Running the generator in ML has shows that the list of plane tame graphs ("the archive") that Thomas Hales also provides is complete. Once we have finished the completeness proof for the generator. In addition we checked the redundancy of the archive by formalising an executable notion of isomorphism between plane graphs, and checking if the archive contains only graphs produced by the generator. It turned out that 2257 of the 5128 graphs in the archive are either not tame or isomorphic to another graph in the archive...|$|E
40|$|The Global Precipitation Mission (GPM) {{software}} provides graphic visualization {{tools that}} enable easy comparison of ground- and space-based radar observations. It was initially designed to compare ground radar reflectivity from operational, ground-based, S- and C-band meteorological radars with comparable measurements from the Tropical Rainfall Measuring Mission (TRMM) satellite's precipitation radar instrument. This design is also applicable to other groundbased and space-based radars, and allows both ground- and space-based radar {{data to be}} compared for validation purposes. The tool creates an operational system that routinely performs several steps. It ingests satellite radar data (precipitation radar data from TRMM) and groundbased meteorological radar data {{from a number of}} sources. Principally, the ground radar data comes from national networks of weather radars (see figure). The data ingested by the visualization tool must conform to the data formats used in GPM Validation Network Geometry-matched data product generation. The software also performs match-ups of the radar volume data for the ground- and space-based data, as well as statistical and graphical analysis (including two-dimensional graphical displays) on the match-up data. The visualization tool software is written in IDL, and can be operated either in the IDL development environment or as a stand-alone <b>executable</b> <b>function...</b>|$|E
40|$|International audienceWe {{present a}} {{practical}} tool for defining and proving properties of recursive {{functions in the}} Coq proof assistant. The tool proceeds by generating from pseudo-code (Coq functions that need not be total nor terminating) the graph of the intended function as an inductive relation, and then proves that the relation actually represents a function, which is by construction the function that {{we are trying to}} define. Then, we generate induction and inversion principles, and a fixpoint equation for proving other properties of the function. Our tool builds upon state-of-the-art techniques for defining recursive functions, and {{can also be used to}} generate <b>executable</b> <b>functions</b> from inductive descriptions of their graph. We illustrate the benefits of our tool on two case studies...|$|R
40|$|Investigates {{techniques}} {{designed to}} allow genetic programming to evolve significantly more complex, modular, and functionally expressive code. Rather then developing a system from scratch, the research in this document builds upon the PushGP system developed by Spector (2001). PushGP uses a stack-based language with multiple stacks for operating on different data types. One stack stores program code and allows for interactive construction and modification of <b>executable</b> <b>functions,</b> modules, and control structures as the main program executes. The primary question addressed is what sort of modularity and structure evolve when their very composition arises from the evolutionary modifications of program code, rather than from external parsing {{on the part of}} genetic programming systems. The secondary question is how the computational effort of this system varies in comparison to more traditional genetic programming systems, (like Koza 9 ̆ 2 s GP system with automatically defined functions) ...|$|R
40|$|Abstract. Bounded {{increase}} is a termination technique {{where it is}} tried to find an argument x of a recursive function that is increased repeatedly until it reaches a bound b, which might be ensured by a condition x < b. Since the predicates like < may be arbitrary user-defined recursive functions, an induction calculus is utilized to prove conditional constraints. In this paper, we present a full formalization of bounded increase in the theorem prover Isabelle/HOL. It fills one large gap in the pen-andpaper proof, and it includes generalized inference rules for the induction calculus as well as variants of the Babylonian algorithm to compute square roots. These algorithms were required to write <b>executable</b> <b>functions</b> which can certify untrusted termination proofs from termination tools that make use of bounded increase. And indeed, the resulting certifier was already useful: it detected an implementation error that remained undetected since 2007. ...|$|R
40|$|An ideal network {{troubleshooting}} {{system would be}} an almost fully automated system, monitoring the whole network at once, feeding the results to a knowledge-based decision making system that suggests actions to the operator or corrects the failure automatically. Reality is quite the contrary: operators separated in their offices try to track down complex networking failures in their own way, which is generally a long sequence of manually edited parallel shell commands (mostly ping, traceroute, route, iperf, ofctl etc.). This process requires operators to be "masters of complexity" (which they often are) and continuous interaction. In this paper we aim at narrowing this huge gap between vision and reality by introducing a modular framework capable of (i) formalizing troubleshooting processes as the concatenation of <b>executable</b> <b>functions</b> [called Troubleshooting Graphs (TSGs) ], (ii) executing these graphs via an interpreter, (iii) evaluating and navigating between the outputs of the functions and (iv) sharing troubleshooting know-hows in a formalized manner. Comment: 18 pages, 9 figure...|$|R
40|$|In this paper, {{we take a}} {{concrete}} step towards materializing our long-term goal of providing a fully automatic end-to-end tuning infrastructure for arbitrary program components and full applications. We describe a general-purpose offline auto-tuning framework {{and apply it to}} an application benchmark, SMG 2000, a semi-coarsening multigrid on structured grids. We show that the proposed system first extracts computationally-intensive loop nests into separate <b>executable</b> <b>functions,</b> a code transformation called outlining. The outlined loop nests are then tuned by the framework and subsequently integrated back into the application. Each loop nest is optimized through a series of composable code transformations, with the transformations parameterized by unbound optimization parameters that are bound during the tuning process. The values for these parameters are selected using a search-based auto-tuner, which performs a parallel heuristic search for the best-performing optimized variants of the outlined loop nests. We show that our system pinpoints a code variant that performs 2. 37 times faster than the original loop nest. When the full application is run using the code variant found by the system, the application’s performance improves by 27 %...|$|R
40|$|We are {{interested}} in the general question of how formal metalogics and higher-order resolution {{can be used as a}} framework for deductive program development. This question includes how can useful calculi for program development bederived in conservative extensions of standard logics and how can derived rules be applied to build programs during their correctness proofs. We are also interested in howsuchaframework can be used to simplify and improve previously proposed approaches and paradigms to program development. Our starting point hereisthedeductive tableau of Manna and Waldinger [1] which is proposed as a special kind of rst-order proof system suited for the synthesis of functional programs. We have taken this calculus and shown how it can be recast as a conservative extension of higher-order logic. In particular, deductive tableau proofs construct witnessing functions for proofs of 8 = 9 formulae and we showhow these proofs can be faithfully simulated where higher-order metavariables stand-in for the witnessing functions and are lled out into concrete <b>executable</b> <b>functions</b> during the proof. Our Isabelle theor...|$|R
5000|$|The [...] "heart" [...] of the <b>executable</b> is <b>function</b> INTEG {{which can}} solve {{differential}} equations {{using one of}} several numerical methods. First it reads necessary values (e.g. values of parameters, initial conditions) from files then it calls the function DERIV where the model is actually described as series of functions of its derivatives. The returned values are used at the selected numerical method. Requested calculated results are written into the file and the whole procedure is repeated until the termination condition is satisfied.|$|R
40|$|The 369 -residue {{glycoprotein}} D (gD) is the entry, receptor-binding protein of {{herpes simplex}} virus 1. The common receptors for viral entry are nectin- 1, HveA, and a specific O-linked sulfated proteoglycan. The major receptor-binding sites of gD are at the N terminus, whereas the domain required for fusion of viral envelope with the plasma membrane is at the C terminus of the ectodomain (residues 260 – 310). In the course of retargeting gD to the urokinase plasminogen activator (uPA) receptor for potential therapeutic applications, we obtained a genetically engineered infectious virus in which the receptor-binding domain consisting of the N-terminal domain of uPA fused to residues 33 – 60 of gD was separated from an independently expressed C-terminal domain of gD containing residues 219 – 369. The intervening sequences (residues 62 – 218) were replaced by a stop codon and a promoter for the C-terminal domain of gD. The physical interaction of the two components was reconstructed by coimmunoprecipitation of the N-terminal domain of uPA with the C-terminal domain of gD. These results indicate that codons 61 – 218 of gD do not encode <b>executable</b> <b>functions</b> required for viral entry into cells and suggest that the receptor-binding ligand must interact with but need not alter {{the structure of the}} residual portion of gD to effect virus entry. This finding opens the way {{for the development of a}} family of recombinant viruses in which the profusion domain of gD and independently furnished, interacting receptor-binding domains effect entry of the virus via a range of receptors...|$|R
50|$|The MBR {{holds the}} {{information}} on how the logical partitions, containing file systems, are organized on that medium. The MBR also contains <b>executable</b> code to <b>function</b> as a loader for the installed operating system—usually by passing control over to the loader's second stage, or in conjunction with each partition's volume boot record (VBR). This MBR code is usually {{referred to as a}} boot loader.|$|R
40|$|A {{strategy}} is described that utilizes a novel {{application of a}} potential-force function that includes the tuning of coefficients to control mobile robots orchestrated as a distributed multiagent system. Control system parameters are manipulated methodically via simulation and hardware experimentation {{to gain a better}} understanding of their impact upon mission performance of the multi-agent system as applied to a predetermined task of area exploration and mapping. Also included are descriptions of experiment infrastructure components that afford convenient solutions to research challenges. These consist of a surrogate localization (position and orientation) function utilizing a novel MATLAB <b>executable</b> (MEX) <b>function</b> and a user datagram protocol (UDP) -based communications protocol that facilitates communication among network-based control computers...|$|R
40|$|Abstract. In {{this paper}} we present our {{formalization}} of two important termination techniques for term rewrite systems: the subterm criterion and the reduction pair processor {{in combination with}} usable rules. For both techniques we developed <b>executable</b> check <b>functions</b> using the theorem prover Isabelle/HOL. These functions are able to certify the correct application of the formalized techniques in a given termination proof. As there are several variants of usable rules, we designed our check function {{in such a way}} that it accepts all known variants, even those which are not explicitly spelled out in previous papers. We integrated our formalization in the publicly available IsaFoR-library. This led to a significant increase in the power of CeTA, a certified termination proof checker that is extracted from IsaFoR. 1...|$|R
40|$|In {{this paper}} we present our {{formalization}} of two important termination techniques for term rewrite systems: the subterm criterion and the reduction pair processor {{in combination with}} usable rules. For both techniques we developed <b>executable</b> check <b>functions</b> in the theorem prover Isabelle/HOL which can certify the correct application of these techniques in some given termination proof. As there are several variants of usable rules we designed our check function {{in such a way}} that it accepts all known variants, even those which are not explicitly spelled out in previous papers. We integrated our formalization in the publicly available IsaFoR-library. This led to a significant increase in the power of CeTA, the corresponding certified termination proof checker that is extracted from IsaFoR...|$|R
40|$|Abstract. The {{widespread}} use of embedded systems mandates the development of industrial software design methods, i. e. computer-aided design and engineering of embedded applications using formal models (frameworks) and standardized prefabricated components, much {{in the same way}} as in other mature areas of engineering such as mechanical engineering and electronics. These guidelines have been used to develop Component-based Design of Software for Embedded Systems (COMDES). The paper gives an overview of the COMDES framework, followed by a presentation of a generic component types, such as function blocks, activities and function units. The execution of function units is discussed in the context of a newly developed execution model, i. e. timed-multitasking, which has been extended to distributed embedded systems. Key Words. Distributed embedded systems, component-based design, reusable <b>executable</b> components, <b>function</b> blocks, reconfigurable state machines, timed multitaskin...|$|R
40|$|Functions in Stata {{take two}} main forms, {{built-in}} functions {{that are part}} of the <b>executable</b> and egen <b>functions</b> written in Stata's own language. These are surveyed, giving a variety of tips and tricks, and noting the large number of user-written egen functions available for download from the Internet. Two substantial examples, the calculation of percentile ranks and plotting positions, and the calculation of measures summarizing properties of the other members of a group,provide detailed illustrations of egen in action. Copyright 2002 by Stata Corporation. functions, egen, strings, percentile ranks, plotting positions, family data...|$|R
40|$|Abstract. Based on the {{analyzing}} of {{the characteristics}} of a Body-In-White pressing production process a pressing workshop production management system has been given {{in order to make the}} ERP production scheduling more <b>executable.</b> The detailed <b>function</b> model of it such as task assignment, quality control, mold maintenance and production scheduling has been thoroughly discussed. In order to make the production line capability balance the task dispatching algorithm has been given and the dynamic dispatching and controlling process has been explained. This system can be integrated with the upper ERP/CAPP/PDM system which can improve the information level of a company...|$|R
5000|$|BusyBox is {{software}} that provides several stripped-down Unix tools {{in a single}} executable file. It runs {{in a variety of}} POSIX environments such as Linux, Android, and FreeBSD, although many of the tools it provides are designed to work with interfaces provided by the Linux kernel. It was specifically created for embedded operating systems with very limited resources. The authors dubbed it [...] "The Swiss Army knife of Embedded Linux", as the single <b>executable</b> replaces basic <b>functions</b> of more than 300 common commands. It is released as free software {{under the terms of the}} GNU General Public License v2.|$|R
40|$|Abstract—The paper {{presents}} COMDES-II- {{a software}} framework for distributed control systems. The framework provides for systematic top-down specification of distributed applications: {{a system is}} conceived as a composition of embedded actors that communicate transparently by exchanging labeled messages (signals), and actors are composed from reusable <b>executable</b> components (<b>function</b> blocks). The framework and its software components have been validated {{in a number of}} real-time control experiments, including the Production Cell Case Study. The paper presents the software design models of the Production Cell control system, based on COMDES-II, focusing on the system engineering aspects of the software design. The latter has been formally verified using the Uppaal verification tool. To that end, a method has been developed to transform the COMDES-II interaction diagram into an Uppaal model, using networks of automata representing system actors, as well as controlled objects from the Production Cell environment. The developed control system design has been tested via hardware-in-the-loop simulation involving a real-time control network and an animated computer model of the plant. Index Terms—component-based design, software framework, actors, function blocks, hardware-in-the-loop simulatio...|$|R
40|$|AbstractTo {{successfully}} {{identify the}} metamorphic viruses oriented {{from the same}} base, anti-virus software has adopted the code normalization technique to transform the variations to a more uniform signature representation. Current code normal-ization technique focuses on the simplication of the arithmetical or logical operators. In this paper, we introduce a new technique of generating metamorphic viruses by embedding complicated manipulation functions that cannot be normalized into the malicious <b>executables.</b> Using encryption/decryption <b>functions</b> as an example, we present this evasion strategy that malware writers could employ in the future. We demonstrate the strategy’s effec-tiveness in evading detection by current anti-virus technologies. We also discuss the potential mitigation mechanisms. I...|$|R
40|$|The {{reference}} {{process for}} the development of automotive product lines formulated in the project VEIA introduces different kinds of models for the representation of architectural views of the system family under development. The purpose of this report is to present methods and guidelines on how such models can be developed {{in the course of the}} process. Thereby mainly early models are considered, which in this case means the derivation of a function interface model and an <b>executable</b> hierarchical <b>function</b> model from an overall goal and constraints. These function models define the logical information flow but abstract from its realisation in software and hardware. The executable model is written in SystemC, the structural part of which closely corresponds to the AUTOSAR notation for software components. The methods are developed along with the case study "Condition Based Service" (CBS) of the project VEIA. CBS is a function family that recommends service dates for a vehicle based on different kinds of monitorings of its state. The other models of the reference process - feature models that define the scope and the structure of the function family and models of the technical infrastructure - are presented for the case study, too, but their systematic derivation is not investigated...|$|R
40|$|International audienceThis paper {{presents}} a safe design method for control-command embedded systems. It investigates {{the problem of}} building control-command systems out of Commercial off the shelf (COTS) components. The design method proposed uses in synergy the formal verification (FV) and the Discrete Controller Synthesis (DCS) techniques. COTS are formally specified using temporal logic and/or <b>executable</b> observers. New <b>functions</b> are built by assembling COTS together. As the COTS assembly operation is seldom error-free, behavioral incompatibilities may persist between COTS. For these reasons, COTS assemblies need to be formally verified and if errors are found, an automatic correction is attempted using DCS. The control-command code generated by DCS needs hardware specific post-processing: a structural decomposition, followed by a controllability assessment, followed by a dedicated formal verification step, ensuring that no spurious behavior is added by DCS. The resulting system is ready for hardware (e. g. FPGA) implementation...|$|R
40|$|Bond is a message-oriented {{middleware}} for network computing on {{a grid of}} autonomous nodes. It consists of a distributed object communication fabric, servers, and agents. Core servers are permanent objects providing services such as directory service, dispatching, authentication, monitoring, and others. The Bond system monitor is responsible for starting up core servers, keeping them running, and balancing the load among them. In this paper, we discuss the remote server start-up and the <b>executables</b> failure detection <b>functions</b> of the monitor and present the backup monitor. Contents: 1. Abbreviations and terms 2. Introduction 3. System monitor Remote server start-up Failure detection Backup monitor 4. Future work 5. Conclusions 1. Abbreviations and terms Backup system monitor: core server; it takes control of the system when the primary system monitor fails. Shadow of a Bond object: abstraction supporting communication with a remote object. A shadow is a local object acting as a prox [...] ...|$|R
