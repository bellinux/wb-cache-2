43|0|Public
25|$|While working (starting in 1975) as a {{research}} assistant at MIT under Gerry Sussman, Stallman published a paper (with Sussman) in 1977 on an AI truth maintenance system, called <b>dependency-directed</b> <b>backtracking.</b> This paper was an early work {{on the problem of}} intelligent backtracking in constraint satisfaction problems. , the technique Stallman and Sussman introduced is still the most general and powerful form of intelligent backtracking. The technique of constraint recording, wherein partial results of a search are recorded for later reuse, was also introduced in this paper.|$|E
50|$|Each {{statement}} {{having at}} least one valid justification is made {{a part of the}} current belief set. When a contradiction is found, the statement(s) responsible for the contradiction are identified and the records are appropriately updated. This process is called <b>dependency-directed</b> <b>backtracking.</b>|$|E
50|$|While working (starting in 1975) as a {{research}} assistant at MIT under Gerry Sussman, Stallman published a paper (with Sussman) in 1977 on an AI truth maintenance system, called <b>dependency-directed</b> <b>backtracking.</b> This paper was an early work {{on the problem of}} intelligent backtracking in constraint satisfaction problems. , the technique Stallman and Sussman introduced is still the most general and powerful form of intelligent backtracking. The technique of constraint recording, wherein partial results of a search are recorded for later reuse, was also introduced in this paper.|$|E
40|$|Extending {{functional}} Lisp with McCarthy’s non-deterministic operator AHFJ {{yields a}} language which can concisely express search problems. Dependencydirected backtracking {{is a powerful}} search strategy. We describe a non-deterministic Lisp dialect called SCHEMER and show that it can provide automatic <b>dependency-directed</b> <b>backtracking.</b> The resulting language provides a convenient interface to this ef-ficient backtracking strategy. Many problems in Artificial Intelligence involve search. SCHEMER is a Lisp-like language with nondeterminism which provides a natural way to express sea. rch problems. <b>Dependency-directed</b> <b>backtracking</b> is a powerful strategy for solving search problems. We describe how to use <b>dependency-directed</b> <b>backtracking</b> to interpret SCHEMER. This provides SCHEMER programs with the benefits of <b>dependency-directed</b> <b>backtracking</b> automatically. We begin by describing the SCHEMER language. We next {{provide an overview of}} <b>dependency-directed</b> <b>backtracking</b> and list its requirements. We then show how to meet these requirements in interpreting SCHEMER. Finally, we argue that SCHEMER with automatic <b>dependency-directed</b> <b>backtracking</b> would be a useful tool for Artificial Intelligence by comparing it with current methods for obtaining <b>dependency-directed</b> <b>backtracking.</b> I. SCHEMER is Scheme with AMB SCHEMER consists of functional Scheme [Rees e-t al. 19861 plus McCarthy’s ambiguous operator AMB [McCarthy 19631 and the special form (FAIL). AMB takes two arguments and non-deterministically returns the value of one of them. Selecting the arguments of the AMB's in an expression determines a possible execution. Each SCHEMER ex-t Author's current address: Computer Science Department...|$|E
40|$|Extending {{functional}} Lisp with McCarthy's nondeterministic operator AMB {{yields a}} language which can concisely express search problems. <b>Dependency-directed</b> <b>backtracking</b> {{is a powerful}} search strategy. We describe a non-deterministic Lisp dialect called SCHEMER and show that it can provide automatic <b>dependency-directed</b> <b>backtracking.</b> The resulting language provides a convenient interface to this efficient backtracking strategy...|$|E
40|$|Non-deterministic LISP {{can be used}} to {{describe}} a search problem without specifying the method used to solve the problem. We show that SCHEMER, a non-deterministic dialect of SCHEME, can support <b>dependency-directed</b> <b>backtracking</b> as well as chronological backtracking. Full code for a working SCHEMER interpreter that provides <b>dependency-directed</b> <b>backtracking</b> is included. This is a greatly revised version of a thesis submitted to the Massachusetts Institute of Technology Department of Electrical Engineering and Computer Science on January 2, 1987, in partial fulfillment of the requirements for the degree of Master of Science. MIT Artificial Intelligence Laborator...|$|E
40|$|A Truth Maintenance -System (TMS) {{maintains}} a consistent state of belief given a set J of justifications, i. e. arguments for belief. To resolve contradictions <b>dependency-directed</b> <b>backtracking</b> is performed. In this paper we introduce {{a method that}} can, be used to track all <b>dependency-directed</b> <b>backtracking</b> methods simultaneously. This has been, previously done, by adding the contrapositions of justifications to J. We will show that contrapositions are not mandatory, namely that the same result {{can be reached by}} adding one disjunctive justification (the consequent is not one atom, but can be a disjunction of atoms). Simplifying the added disjunctive justification leads to more informative models [Ross 89 b]. Furthermore, we will give an alternative proof for the correctness of Witteveen's method [Witteveen 90 a] for computing the Well-Founded mode...|$|E
40|$|I {{highlight}} some inefficiencies of Graphplan's {{backward search}} algorithm, and describe how {{these can be}} eliminated by adding explanation-based learning and <b>dependency-directed</b> <b>backtracking</b> ca-pabilities to Graphplan. I will then demonstrate {{the effectiveness of these}} augmentations by de-scribing results of empirical studies that show dra-matic improvements in run-time (w lOOx speedups) as well as solvability-horizons on benchmark prob-lems across seven different domains. ...|$|E
40|$|In {{this paper}} we {{describe}} {{a framework for}} defining and operationalizing conceptual models of distributed knowledge-based systems which extends published approaches by the notion of,agents" and multiple task decompositions. The main part deals with techniques underlying our distributed interpreter. We show how a client-server-architecture can be implemented which allows prototyping distributed knowledge-based systems. Further we describe our mechanism which manages task interactions and supports <b>dependency-directed</b> <b>backtracking</b> efficiently...|$|E
40|$|The {{tests were}} {{performed}} using HAM-ALC version 1. 1. HAM-ALC [2] is a description logic classier {{which has been}} constructed for providing a basis for an optimized ALCRP(D) [1] implementation. Based on a sound and complete tableau algorithm HAM-ALC currently imple-ments a true ABox reasoner for the logic ALC. HAM-ALC employs a few optimizations inspired by FaCT [3], in particular semantic branching and a form of <b>dependency-directed</b> <b>backtracking</b> called backjumpin...|$|E
40|$|Because {{of their}} {{occasional}} {{need to return}} to shallow points in a search tree, existing backtracking methods can sometimes erase meaningful progress toward solving a search problem. In this paper, we present a method by which backtrack points can be moved deeper in the search space, thereby avoiding this di culty. The technique developed is avariant of <b>dependency-directed</b> <b>backtracking</b> that uses only polynomial space while still providing useful control information and retaining the completeness guarantees provided by earlier approaches. 1...|$|E
40|$|Standard Functional Unification Grammars (FUGs) {{provide a}} {{structurally}} guided top-down control regime for text generation {{that is not}} appropriate for handling non-structural and dynamic constraints. We introduce two control tools that we have implemented for FUGs to address these limitations: bk-class, a tool to limit search by using a form of <b>dependency-directed</b> <b>backtracking</b> and external, a co-routine mechanism allowing a FUG to cooperate with dynamic constraint sources. We show how these tools complement the top-down regime of FUGs to enhance lexical choice...|$|E
40|$|This paper {{illustrates}} how a Prolog program, using chronological backtracking {{to find a}} solution in some search space, can be enhanced to perform intelligent backtracking. The enhancement crucially relies on the impurity of Prolog that allows a program to store information when a dead end is reached. To illustrate the technique, a simple search program is enhanced. To appear in Theory and Practice of Logic Programming. Keywords: intelligent backtracking, <b>dependency-directed</b> <b>backtracking,</b> backjumping, conflict-directed backjumping, nogood sets, look-back. Comment: To appear in Theory and Practice of Logic Programmin...|$|E
40|$|Because {{of their}} {{occasional}} {{need to return}} to shallow points in a search tree, existing backtracking methods can sometimes erase meaningful progress toward solving a search problem. In this paper, we present a method by which backtrack points can be moved deeper in the search space, thereby avoiding this difficulty. The technique developed is a variant of <b>dependency-directed</b> <b>backtracking</b> that uses only polynomial space while still providing useful control information and retaining the completeness guarantees provided by earlier approaches. Comment: See [URL] for an online appendix and other files accompanying this articl...|$|E
40|$|Many procedurally-oriented {{problem solving}} {{systems can be}} viewed as {{performing}} a mixture of computation and deduction, with much of the computation serving to decide what deductions should be made. This results in bits and pieces of deductions being strewn throughout the program text and execution. This paper describes a problem solver subsystem called a truth maintenance system which collects and maintains these bits of deductions. Automatic functions of the truth maintenance system then use these pieces of "proofs" to consistently update a data base of program beliefs and to perform a powerful form of backtracking called <b>dependency-directed</b> <b>backtracking...</b>|$|E
40|$|Gaschnig's backjumping {{algorithm}} {{has become}} one of the standard methods for constraint satisfaction, performing <b>dependency-directed</b> <b>backtracking</b> (`backjumping') from nodes which cannot be further expanded during tree search. In this paper, we show how this algorithm can be extended to also permit backjumping from nodes which were expanded, but whose subtrees eventually failed. We experimentally compare Gaschnig's backjumping and our extended algorithm (`generalised backjumping') on two standard constraint satisfaction problems (8 -queens and zebras). We show that generalised backjumping can substantially reduce the search performed by the original algorithm, thus demonstrating a significant development of this established search technique. ...|$|E
40|$|We {{argue that}} Abduction {{is useful for}} the problem of Knowledge Assimilation {{and use it to}} study the {{problems}} of Belief Revision and Truth Maintenance (TM) associated with the task of assimilating a series of observations Q 1, [...] . Q(n). The close connection between Abduction and TM shown in [Reiter&de Kleer 87] is explored further to provide a non-monotonic extension of ATMS that incorporates a <b>dependency-directed</b> <b>backtracking</b> mechanism thus combining the capabilities of ATMS and Doyle's TMS. This TM system has a well-defined semantics inherited from the semantics for abduction which is defined through a generalization of stable models based on autoepistemic logic...|$|E
40|$|To {{choose their}} actions, {{reasoning}} programs {{must be able}} to draw conclusions from limited information and subsequently revise their beliefs when discoveries invalidate previous assumptions. A truth maintenance system is a problem solver subsystem for performing these functions by recording and maintaining the reasons for program beliefs. These recorded reasons are useful in constructing explanations of program actions in "responsible" programs, and in guiding the course of action of a problem solver. This paper describes the structure of a truth maintenance system, methods for encoding control structures in patterns of reasons for beliefs, and the method of <b>dependency-directed</b> <b>backtracking...</b>|$|E
40|$|Our {{research}} has been motivated by the task of forming a solution subgraph which satisfies given constraints. The problem is represented by an A/O graph. Our approach is to apply a suitably modied technique of <b>dependency-directed</b> <b>backtracking.</b> We present our formulation of the standard chronological backtracking algorithm in Prolog. Based on it, we have developed an enhanced algorithm which makes use of special heuristic knowledge. It involves also the technique of node marking. We have gathered experience with the prototype Prolog implementation of the algorithm in applying it to (one step of) the problem of building a software conguration. Our experience shows that Prolog programming techniques offer a considerable flexibility in implementing the above outlined tasks...|$|E
40|$|In {{this paper}} we present {{the notion of}} concurrent, {{controllable}} constraint systems. We argue that purely declarative search formalisms, whether {{they are based on}} <b>dependency-directed</b> <b>backtracking</b> (as in Steele [Steele, 19801 or Bruynooghe [Bruynooghe and Pereira, 19851) or bottom-up breadth-fist (albeit incremental) definite clause theorem provers (as in deKleer’s ATM approach [deKleer, 19861) or built-in general purpose heuristics (as in Laurier’s work [Lau-riere, 19781) are unlikely to be efficient enough to serve as the basis of a general purpose programming formalism which supports the notion of constraint-based computation. To that end we propose the programming language CP[J, 1, &], based on the concurrent interpretation of definite clauses, which al-lows the user to express domain-specific heuristics and con...|$|E
40|$|A Justification -based Truth Maintenance System (JTMS) is classically {{represented}} by a network of nodes together {{with a set of}} links (justifications) that represent dependencies between nodes. In this representation, the relations between the justifications are not explicit. We propose a dual representation of a JTMS based on the dependencies between justifications. This representation allows us to separate the monotonic and non-monotonic parts of the network of dependencies. Based on this representation, we develop an incremental backtracking algorithm to compute an admissible labeling of a JTMS. This algorithm allows us to go from an admissible labeling to another, and so it always finds an admissible labeling when one exists, and <b>dependency-directed</b> <b>backtracking</b> must be called uniquely when all the admissible labelings are inconsistent. SCOPUS: cp. kinfo:eu-repo/semantics/publishe...|$|E
40|$|A {{solution}} to the Yale shooting problem has been previously proposed that uses so-called non-normal defaults. This approach produces a single extension. One disadvantage, however, is. that new conflicting information causes the extension to collapse. In this {{paper we propose a}} new formal counterpart to the intuitive notion of a reasonable set of beliefs. The new formalization reduces to the previous one when there are no conflicts. However, when fresh conflicting information is added, instead of collapsing it produces a revised interpretation similar to that obtained by <b>dependency-directed</b> <b>backtracking</b> in a truth maintenance system. Consideration of the relationship to relevance logic motivates {{the development of a new}} formalism for default reasoning, called Defeasible Logic, which behaves like Autoepistemic Logic, but may be more intuitive. 1...|$|E
40|$|Many design {{problems}} can be formulated {{as a process of}} searching a “well-defined ” space of artifacts with similar functionality. The dimensions of such spaces are largely known and are constrained by relations obtained from the implicit functionality of the designed artifact. After identifying the kinds of knowledge that mediate the search for acceptable designs, a computational framework is presented that organizes the required knowledge as design plans. A problem solver is described that executes these plans. The problem solver extends the notion of <b>dependency-directed</b> <b>backtracking</b> with an advice mechanism. This mechanism allows information from a constraint failure to be used as advice in modifying a partial design. An expert system for designing paper transports inside copiers has been successfully built based on this framework. 1...|$|E
40|$|Pareto {{optimality}} is a domain-independent {{property that}} can be used to coordinate distributed engineering agents. Within a model of design called Redux, some aspects of <b>dependency-directed</b> <b>backtracking</b> can be interpreted as tracking Pareto optimality. These concepts are implemented in a framework, called Next-Link, that coordinates legacy engineering systems. This framework allows existing software tools to communicate with each other and a Redux agent over the Internet. The functionality is illustrated with examples from the domain of electrical cable harness design. Keywords:[Design Coordination], [Pareto Optimality], [Change Management], [Distributed Engineering], [Network Agents] 1 Introduction Coordination of distributed engineering agents frequently involves globally conflicting solutions to multiple local objectives. While much computer research on support of collaborative engineering concerns global metrics for optimization, decision support, and negotiation, a basic coor [...] ...|$|E
40|$|The thesis {{developed}} {{here is that}} reasoning {{programs which}} take care to record the logical justifications for program beliefs can apply several powerful, but simple, domain-independent algorithms to (1) maintain the consistency of program beliefs, (2) realize substantial search efficiencies, and (3) automatically summarize explanations of program beliefs. These algorithms are the recorded justifications to maintain the consistency and well founded basis of the set of beliefs. The set of beliefs can be efficiently updated in an incremental manner when hypotheses are retracted and when new information is discovered. The recorded justifications also enable the pinpointing of exactly whose assumptions which support any particular belief. The ability to pinpoint the underlying assumptions {{is the basis for}} an extremely powerful domain-independent backtracking method. This method, called <b>Dependency-Directed</b> <b>Backtracking,</b> offers vastly improved performance over traditional backtracking algorithms...|$|E
40|$|Current {{algorithms}} for <b>Dependency-Directed</b> <b>Backtracking</b> (DDB) {{suffer from}} several limitations. The added justifications produced by Doyle's DDB are sufficient but are neither safe nor complete. Petrie's DDB solves this problem, {{but it can}} lead to cases where odd loops are introduced later into JTMS network by new justifications, and so can sometimes miss legitimate admissible labelings. Moreover, Petrie's DDB cannot resolve an inconsistency if all possible added justifications produce an odd loop, although a solution may exist. We propose a revised method based on elective sets and premise sets of contradiction foundations that allows to use the premises as added justifications. Our revised DDB allows to resolve more inconsistencies than Petrie's DDB. Moreover, a preference ordering over the assumption justifications can be integrated; this order gives the problem solver some control over the choice of electives. SCOPUS: cp. kinfo:eu-repo/semantics/publishe...|$|E
40|$|In {{this paper}} {{we present a}} model of {{decentralized}} problem solving, called Distributed Constrained Heuristic Search (DCHS) that provides both structure and focus in individual agent search spaces so as to optimize decisions in the global space. The model achieves this by integrating decentralized constraint satisfaction and heuristic search. It is a formalism suitable for describing a large set of DAI problems. We introduce the notion of textures that allow agents to operate in an asynchronous concurrent manner. The employment of textures coupled with distributed asynchronous backjumping (DAB), a type of distributed <b>dependency-directed</b> <b>backtracking</b> that we have developed, enables agents to instantiate variables {{in such a way}} as to substantially reduce backtracking. We have experimentally tested our approach in the domain of decentralized job-shop scheduling. A formulation of distributed job-shop scheduling as a DCHS is presented as well as experimental results...|$|E
40|$|In {{this paper}} we {{describe}} {{a framework for}} defining and operationalizing conceptual models of distributed knowledge-based systems which extends published approaches by the notion of "agents" and multiple task decompositions. The main part deals with techniques underlying our distributed interpreter. We show how a client-server-architecture can be implemented which allows prototyping distributed knowledge-based systems. Further we describe our mechanism which manages task interactions and supports <b>dependency-directed</b> <b>backtracking</b> efficiently. 1 INTRODUCTION AND OVERVIEW Model-based development of knowledge-based systems {{is the state of}} the art in knowledge engineering. A well-known approach in Europe is KADS [14] which allows to model knowledge-based systems on a very high level of abstraction. For this methodology, several formal and/or operational languages were developed [5]. These do not support the distribution of tasks among several agents. Our goal is the development of a frame [...] ...|$|E
40|$|The Constraint Satisfaction Problem {{is a type}} of {{combinatorial}} search {{problem of}} much interest in Artificial Intelligence and Operations Research. The simplest algorithm for solving such a problem is chronological backtracking, but this method suffers from a malady known as "thrashing," in which essentially the same subproblems end up being solved repeatedly. Intelligent backtracking algorithms, such as backjumping and <b>dependency-directed</b> <b>backtracking,</b> were designed to address this difficulty, but the exact utility and range of applicability of these techniques have not been fully explored. This dissertation describes an experimental and theoretical investigation into the power of these intelligent backtracking algorithms. We compare the empirical performance of several such algorithms on a range of problem distributions. We show that the more sophisticated algorithms are especially useful on those problems with a small number of constraints that happen to be difficult for chronologica [...] ...|$|E
40|$|Standard Functional Unification Grammars (FUGs) {{provide a}} {{structurally}} guided top-down control regime for sentence generation. When using FUGs to perform content realization as a whole, including lexical choice, this regime {{is no longer}} appropriate for two reasons: (1) the unification of non-lexicalized semantic input with an integrated lexico-grammar requires mapping "floating" semantic elements which can trigger extensive backtracking and (2) lexical choice requires accessing external constraint sources on demand to preserve the modularity between conceptual and linguistic knowledge. We introduce two control tools that we have implemented for FUGs to address these limitations: bk-class, a form of <b>dependency-directed</b> <b>backtracking</b> to efficiently process "floating" constraints and external, a co-routine mechanism allowing a FUG to cooperate with external constraint sources during unification. We show how these tools complement the top-down regime of FUGs to control the whole content realization process...|$|E
40|$|AI {{automated}} plan synthesis programs ("planners") typically represent {{plans as}} a partially ordered network whose nodes are instants {{in time and}} whose arcs are precedence constraints. Such representations are essentially PERT charts. This paper provides an introduction to AI planners and illustrates {{the fact that many}} such PERT chart representations are created by a planner as it attempts to find a suitable plan. A planner's search must be guided if it is to produce suitable plans in realistic problem domains. One form of guidance is the imposition of constraints which must be satisfied by a valid plan. This paper concentrates on representing and reasoning about such constraints. Successful planning in some domains, e. g. job-shop scheduling, requires the recognition and satisfaction of constraints which prevent the simultaneous use of a shared resource by multiple agents. Such requirements can be expressed as disjunctive precedence constraints. In addition, the search for a valid plan is often structured so that rough plans are successively refined into plans with increased detail. In this refinement process, new constraints are often discovered. It should therefore be easy to add such new constraints. Finally, it is helpful to be able to express upper bound constraints on the elapsed time between two nodes in a PERT chart representation of a plan. Thus, this paper reports on knowledge representation and reasoning processes which facilitate: (1) disjunctive constraints, (2) the introduction of new constraints, and (3) upper bound constraints. A planner must backtrack when it is evident that further refinement of its current skeletal plan would be fruitless. Such an inconsistent state can be recognized when a plan's PERT chart representation contains an illegal cycle of positive overall length. When backtracking is required, <b>dependency-directed</b> <b>backtracking</b> is facilitated by recording "Nogood sets" of arcs whose simultaneous presence would result in such an illegal cycle. By using <b>dependency-directed</b> <b>backtracking,</b> chronological backtracking can be avoided. artificial intelligence, project planning, disjunctive constraints, temporal logic...|$|E
40|$|A {{number of}} {{researchers}} have presented evidence that the hardest constraint satisfaction problems tend to arise near the "crossover" point, where around half the problems have solutions. Two recent papers, however, argue that while {{this is true of}} the median search cost, the mean search cost has an entirely different behavior. The mean search cost appears to be dominated by {{a relatively small number of}} extremely difficult problems, and these problems typically have constraint graphs that are much sparser than those of the problems near the crossover point. In this paper, we show that these outliers in the sparse region are not fundamentally difficult problems. They are hard for chronological backtracking only because of thrashing, and they are easily handled by more sophisticated search strategies such as backjumping and <b>dependency-directed</b> <b>backtracking.</b> Thus, they are quite different in character from the crossover-point problems, which appear to be difficult for all kn [...] ...|$|E
40|$|Real world {{planning}} tasks like {{manufacturing process}} planning often don't allow to formalize {{all of the}} relevant knowledge. Especially, preferences between alternatives are hard to acquire but have high influence on {{the efficiency of the}} planning process {{and the quality of the}} solution. We describe the essential features of the CAPlan planning architecture that supports cooperative problem solving to narrow the gap caused by absent preference and control knowledge. The architecture combines an SNLP-like base planner with mechanisms for explict representation and maintenance of dependencies between planning decisions. The flexible control interface of CAPlan allows a combination of autonomous and interactive planning in which a user can participate in the problem solving process. Especially, the rejection of arbitrary decisions by a user or <b>dependency-directed</b> <b>backtracking</b> mechanisms are supported by CAPlan. 1 Introduction In real world planning tasks, the performance of a system often [...] ...|$|E
40|$|In text generation, {{various kinds}} of choices need to be decided. In {{conventional}} frameworks, which we call one-path generation frameworks, those decisions are made in an order carefully designed in advance. In general, however, since choices depend on one another, {{it is difficult to}} make optimal decisions in such frameworks. Our approach to this issue is to introduce the revision process into the overall generation process. In our framework, revision of output texts is realized as <b>dependency-directed</b> <b>backtracking</b> (DDB). As well as Justification-based Truth Maintenance System (JTMS), we maintain dependencies among choices in a dependency network. In this paper, we propose an efficient implementation of DDB for text generation using functional unication grammar (FUG). We use bindings of logical variables in Prolog and destructive argument substitutions to decrease the overhead of handling a dependency network. This paper describes the algorithm in detail and shows the results of preliminary [...] ...|$|E
40|$|Standard Functional Unification Grammars (FUGs) {{provide a}} {{structurally}} guided top-down control regime for text generation {{that is not}} appropriate for handling non-structural and dynamic constraints. We introduce two control tools that we have implemented for FUGs to address these limitations: bk-class, a tool to limit search by using a form of <b>dependency-directed</b> <b>backtracking</b> and external, a co-routine mechanism allowing a FUG to cooperate with dynamic constraint sources. We show how these tools complement the top-down regime of FUGs to enhance lexical choice. presses disjunction in FUG. The value of the alt 1 INTRODUCTION keyword {{is a list of}} FDs, each one called a branch. Text generation is the process of choosing linguisWhen unifying an input FD with such a disjunction, tic devices to satisfy various constraints. One of these the unifier non-deterministically selects one branch constraints is the semantic structure representing the that is compatible with the input. Disjunctions [...] ...|$|E
40|$|We {{present a}} {{rule-based}} system for computer-aided circuit analysis. The set of rules, called EL, {{is written in}} a rule language called ARS. Rules are implemented by ARS as pattern-directed invocation demons monitoring an associative data base. Deductions are performed in an antecedent manner, giving EL's analysis a catch-as-catch-can flavor suggestive {{of the behavior of}} expert circuit analyzers. We call this style of circuit analysis propagation of constraints. The system threads deduced facts with justifications which mention the antecedent facts and the rule used. These justifications may be examined by the user to gain insight into the operation of the set of rules as they apply to a problem. The same justifications are used by the system to determine the currently active data-base context for reasoning in hypothetical situations. They are also used by the system in the analysis failures to reduce the search space. This leads to effective control of cominatorial search which we call <b>dependency-directed</b> <b>backtracking...</b>|$|E
