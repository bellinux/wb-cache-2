1054|7|Public
5|$|The new <b>key–value</b> pair is {{then placed}} into that cell.|$|E
5|$|Alternatively, it is {{possible}} to use a lazy deletion strategy in which a <b>key–value</b> pair is removed by replacing the value by a special flag value indicating a deleted key. However, these flag values will contribute to the load factor of the hash table. With this strategy, it may become necessary to clean the flag values out of the array and rehash all the remaining <b>key–value</b> pairs once too large a fraction of the array becomes occupied by deleted keys.|$|E
5|$|It is also {{possible}} to remove a <b>key–value</b> pair from the dictionary. However, it {{is not sufficient to}} do so by simply emptying its cell. This would affect searches for other keys that have a hash value earlier than the emptied cell, but that are stored in a position later than the emptied cell. The emptied cell would cause those searches to incorrectly report that the key is not present.|$|E
5|$|Linear probing is a {{component}} of open addressing schemes for using a hash table to solve the dictionary problem. In the dictionary problem, a data structure should maintain a collection of <b>key–value</b> pairs subject to operations that insert or delete pairs from the collection or that search for the value associated with a given key.|$|E
5|$|Along with {{quadratic}} probing {{and double}} hashing, linear probing {{is a form}} of open addressing. In these schemes, each cell of a hash table stores a single <b>key–value</b> pair. When the hash function causes a collision by mapping a new key to a cell of the hash table that is already occupied by another key, linear probing searches the table for the closest following free location and inserts the new key there. Lookups are performed in the same way, by searching the table sequentially starting at the position given by the hash function, until finding a cell with a matching key or an empty cell.|$|E
25|$|Maps: Maps {{contain a}} {{variable}} number of <b>key-value</b> associations. The syntax is#{Key1=>Value1,...,KeyN=>ValueN}.|$|E
25|$|In Mac OS X 10.3, Apple {{introduced}} the NSController family of classes, which provide predefined behavior for the controller layer. These classes are {{considered part of}} the Cocoa Bindings system, which also makes extensive use of protocols such as <b>Key-Value</b> Observing and <b>Key-Value</b> Binding. The term 'binding' refers to a relationship between two objects, often between a view and a controller. Bindings allow the developer to focus more on declarative relationships rather than orchestrating fine-grained behavior.|$|E
25|$|By {{a similar}} token, Cocoa {{provides}} a pervasive data manipulation method called <b>key-value</b> coding (KVC). This allows {{a piece of}} data or property of an object to be looked up or changed at runtime by name. The property name acts {{as a key to}} the value. In traditional languages, this late binding is impossible. KVC leads to great design flexibility. An object's type need not be known, yet any property of that object can be discovered using KVC. Also, by extending this system using something Cocoa terms <b>key-value</b> observing (KVO), automatic support for undo-redo is provided.|$|E
25|$|JSON, or JavaScript Object Notation, is a {{general-purpose}} data {{interchange format}} that {{is defined as}} a subset of JavaScript's object literal syntax. Like much of JavaScript (regexps and anonymous functions as 1st class elements, closures, flexible classes, 'use strict'), JSON, except for replacing Perl's <b>key-value</b> operator '=>' by an RFC 822 inspired ':', is syntactically pure Perl.|$|E
25|$|LMDB {{may also}} be used {{concurrently}} in a multi-threaded or multi-processing environment, with read performance scaling linearly by design. LMDB databases may have only one writer at a time, however unlike many similar <b>key-value</b> databases, write transactions do not block readers, nor do readers block writers. LMDB is also unusual in that multiple applications on the same system may simultaneously open and use the same LMDB store, {{as a means to}} scale up performance. Also, LMDB does not require a transaction log (thereby increasing write performance by not needing to write data twice) because it maintains data integrity inherently by design.|$|E
500|$|To {{insert a}} <b>key–value</b> pair [...] into the table (possibly {{replacing}} any existing pair {{with the same}} key), the insertion algorithm follows the same sequence of cells that would be followed for a search, until finding either an empty cell or a cell whose stored key is [...]|$|E
500|$|Linear probing [...] is {{a scheme}} in {{computer}} programming for resolving collisions in hash tables, data structures for maintaining {{a collection of}} <b>key–value</b> pairs and looking up the value associated with a given key. It was invented in 1954 by Gene Amdahl, Elaine M. McGraw, and Arthur Samuel and first analyzed in 1963 by Donald Knuth.|$|E
500|$|In open {{addressing}} solutions to this problem, the data structure is an array [...] (the hash table) whose cells [...] (when nonempty) each store a single <b>key–value</b> pair. A hash function {{is used to}} map each key into the cell of [...] where that key should be stored, typically scrambling the keys so that keys with similar values are not placed near {{each other in the}} table. A hash collision occurs when the hash function maps a key into a cell that is already occupied by a different key. Linear probing is a strategy for resolving collisions, by placing the new key into the closest following empty cell.|$|E
500|$|A random {{bipartite graph}} with n {{vertices}} {{on each side}} of its bipartition, and with cn edges chosen independently at random from each of the n2 possible pairs of vertices, is a pseudoforest with high probability whenever c is a constant strictly less than one. This fact {{plays a key role in}} the analysis of cuckoo hashing, a data structure for looking up <b>key-value</b> pairs by looking in one of two hash tables at locations determined from the key: one can form a graph, the [...] "cuckoo graph", whose vertices correspond to hash table locations and whose edges link the two locations at which one of the keys might be found, and the cuckoo hashing algorithm succeeds in finding locations for all of its keys if and only if the cuckoo graph is a pseudoforest.|$|E
2500|$|Oracle NoSQL Database, a scalable, {{distributed}} <b>key-value</b> NoSQL database ...|$|E
2500|$|Lightning Memory-Mapped Database (LMDB) is a {{software}} library {{that provides a}} high-performance embedded transactional database {{in the form of}} a <b>key-value</b> store. [...] LMDB is written in C with API bindings for several programming languages. LMDB stores arbitrary key/data pairs as byte arrays, has a range-based search capability, supports multiple data items for a single key and has a special mode for appending records at the end of the database (MDB_APPEND) which gives a dramatic write performance increase over other similar stores. LMDB is not a relational database, it is strictly a <b>key-value</b> store like Berkeley DB and dbm.|$|E
2500|$|... tEXt {{can store}} text {{that can be}} {{represented}} in ISO/IEC 8859-1, with one <b>key-value</b> pair for each chunk. The [...] "key" [...] must be between 1 and 79 characters long. Separator is a null character. The [...] "value" [...] can be any length, including zero up to the maximum permissible chunk size minus {{the length of the}} keyword and separator. Neither [...] "key" [...] nor [...] "value" [...] can contain null character. Leading or trailing spaces are also disallowed.|$|E
2500|$|LMDB makes unusual (novel) use of {{well-known}} computer science {{techniques such as}} copy-on-write semantics and B+ trees to provide atomicity and reliability guarantees as well as performance that {{can be hard to}} accept, given the library's relative simplicity and that no other similar <b>key-value</b> store database offers the same guarantees or overall performance, even though the authors explicitly state in presentations that LMDB is read-optimised not write-optimised. [...] Additionally, as LMDB was primarily developed for use in OpenLDAP its developers are focussed mainly on development and maintenance of OpenLDAP, not on LMDB per se. [...] The developers limited time spent presenting the first benchmark results was therefore criticized as not stating limitations, and for giving a [...] "silver bullet impression" [...] not adequate to address an engineers attitude (it has to be pointed out that the concerns raised however were later adequately addressed to the reviewer's satisfaction by the key developer behind LMDB.) ...|$|E
50|$|Another {{example of}} <b>key-value</b> {{database}} is Oracle NoSQL Database. Oracle NoSQL Database provides a <b>key-value</b> paradigm {{to the application}} developer. Every entity (record) {{is a set of}} <b>key-value</b> pairs. A key has multiple components, specified as an ordered list. The major key identifies the entity and consists of the leading components of the key. The subsequent components are called minor keys. This organization is similar to a directory path specification in a file system (e.g., /Major/minor1/minor2/). The “value” part of the <b>key-value</b> pair is simply an uninterpreted string of bytes of arbitrary length.|$|E
50|$|Search {{trees are}} often used to {{implement}} an associative array. The search tree algorithm uses the key from the <b>key-value</b> pair to find a location, and then the application stores the entire <b>key-value</b> pair at that location.|$|E
5000|$|OrderPreservingPartitioner (OPP): This {{partitioner}} distributes the <b>key-value</b> pairs in {{a natural}} way so that similar keys are not far apart. The advantage is that fewer nodes have to be accessed. The drawback is the uneven distribution of the <b>key-value</b> pairs.|$|E
50|$|<b>Key-value</b> (KV) stores use the {{associative}} array (also {{known as}} a map or dictionary) as their fundamental data model. In this model, data is represented {{as a collection of}} <b>key-value</b> pairs, such that each possible key appears at most once in the collection.|$|E
5000|$|A hash {{variable}} {{is marked by}} a [...] sigil, to distinguish it from scalar, array and other data types. A hash literal is a <b>key-value</b> list, with the preferred form using Perl's [...] token, which is mostly semantically identical to the comma and makes the <b>key-value</b> association clearer: ...|$|E
50|$|A document-oriented {{database}} is {{a specialized}} <b>key-value</b> store, which itself is another NoSQL database category. In a simple <b>key-value</b> store, the document content is opaque. A document-oriented database provides APIs or a query/update language that exposes {{the ability to}} query or update based on the internal structure in the document. This difference may be moot for users that do not need richer query, retrieval, or editing APIs that are typically provided by document databases. Modern <b>key-value</b> stores often include features for working with metadata, blurring the lines between document stores.|$|E
5000|$|IndexedDB - an indexed {{hierarchical}} <b>key-value</b> store (formerly WebSimpleDB); ...|$|E
5000|$|Oracle NoSQL Database, a scalable, {{distributed}} <b>key-value</b> NoSQL database ...|$|E
5000|$|... #Subtitle level 2: Differences between <b>Key-Value</b> and Object Stores ...|$|E
5000|$|The above {{query string}} {{consists}} of the following <b>key-value</b> pairs: ...|$|E
50|$|Riak is a {{distributed}} NoSQL <b>key-value</b> {{data store}} based on CRDTs.|$|E
5000|$|<b>Key-value</b> {{database}} files {{into the}} terabyte range (unlimited aggregate database sizes) ...|$|E
5000|$|OrientDB - {{document}} (JSON), graph, <b>key-value,</b> text, geospatial, binary, reactive, SQL ...|$|E
50|$|The <b>key-value</b> {{model is}} one of the {{simplest}} non-trivial data models, and richer data models are often implemented as an extension of it. The <b>key-value</b> model can be extended to a discretely ordered model that maintains keys in lexicographic order. This extension is computationally powerful, in that it can efficiently retrieve selective key ranges.|$|E
50|$|A <b>key-value</b> store, or <b>key-value</b> database, is a {{data storage}} {{paradigm}} designed for storing, retrieving, and managing associative arrays, a data structure more commonly {{known today as}} a dictionary or hash. Dictionaries contain a collection of objects, or records, which in turn have many different fields within them, each containing data. These records are stored and retrieved using a key that uniquely identifies the record, and is used to quickly find the data within the database. <b>Key-value</b> stores work {{in a very different}} fashion from the better known relational databases (RDB). RDBs pre-define the data structure in the database as a series of tables containing fields with well defined data types. Exposing the data types to the database program allows it to apply a number of optimizations. In contrast, <b>key-value</b> systems treat the data as a single opaque collection which may have different fields for every record. This offers considerable flexibility and more closely follows modern concepts like object-oriented programming. Because optional values are not represented by placeholders as in most RDBs, <b>key-value</b> stores often use far less memory to store the same database, which can lead to large performance gains in certain workloads.|$|E
50|$|Maps: Maps {{contain a}} {{variable}} number of <b>key-value</b> associations. The syntax is.|$|E
50|$|The {{database}} may {{consist of}} a <b>key-value</b> pair, like an association list.|$|E
5000|$|The <b>key-value</b> syntax in the [...] {{section is}} as follows:filename_on_source = disk_id,subdir,upgrade_code,new_install_code,spare,spare,new_filename ...|$|E
