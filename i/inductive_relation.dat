13|32|Public
6000|$|... 1483. But {{previous}} to {{the description}} of further experiments, I will mention two words, for which with many others I am indebted to a friend, and which I {{think it would be}} expedient to introduce and use. It is important in ordinary inductive action, to distinguish at which charged surface the induction originates and is sustained: i.e. if two or more metallic balls, or other masses of matter, are in <b>inductive</b> <b>relation,</b> to express which are charged originally, and which are brought by them into the opposite electrical condition. I propose to call those bodies which are originally charged, inductric bodies; and those which assume the opposite state, in consequence of the induction, inducteous bodies. This distinction is not needful because there is any difference between the sums of the inductric and the inducteous forces; but principally because, when a ball A is inductric, it not merely brings a ball B, which is opposite to it, into an inducteous state, but also many other surrounding conductors, though some of them may be a considerable distance off, and the consequence is, that the balls do not bear the same precise relation to each other when, first one, and then the other, is made the inductric ball; though, in each case, the same ball be made to assume the same state.|$|E
6000|$|Machine, electric, {{evolution}} of electricity by, 1748. ------, magneto-electric, 135, 154, 158, 1118. Magnelectric induction, 58. ----, collectors or conductors, 86. Magnesia, sulphate, decomposed against water, 494, 533. ----, transference of, 495. Magnet, {{a measure of}} conducting power, 216. ---- and current, their relation remembered, 38, note. ---- ---- plate revolved together, 218. ---- ---- cylinder revolved together, 219. ---- revolved alone, 220, 223. ---- and moving conductors, their general relation, 256. ---- made by induced current, 13, 14. ----, electricity from, 36, 220, 223. Magnetic bodies, but few, 255. ----, curves, their <b>inductive</b> <b>relation,</b> 217, 232. ---- effects of voltaic electricity, 277. ---- ---- common electricity, 288, 367. ---- ---- magneto-electricity, 27, 83, 345. ---- ---- thermo-electricity, 349. ---- ---- animal electricity, 354. ---- and electric forces, their relation, 118, 1411, 1653, 1658, 1709, [...] 1731. ---- forces active through intermediate particles, 1663, 1710, 1729, 1735. ---- forces of the current, 1653. ---- ---- very constant, 1654. ---- deflection by common electricity, 289, 296. ---- phenomena of Arago explained, 81. ---- induction. See Induction, magnetic. ---- induction through quiescent bodies, 1712, 1719, 1720, 1735. ---- ---- moving bodies, 1715, 1719. ---- and magneto-electric action distinguished, 138, 215, 243, 253. Magnetism, electricity evolved by, 27. ----, its relation to the lines of inductive force, 1411, 1658, 1709. ---- bodies classed in relation to, 255. Magneto-electric currents, their intensity, 183, 193, 211, 213. ----, their direction, 114, 110. ---- traverse fluids, 33. ---- momentary, 30. ---- permanent, 89. ---- in all conductors, 193, 213. Magneto-electric induction, 27, 58. ----, terrestrial, 110, 181. ----, law of, 114. ----. See Arago's magnetic phenomena. Magneto-electric machines, 135, 154, 158. ----, inductive effects in their wires, 1118, Magneto-electricity, its general characters considered, 343, &c. ---- identical with other electricities, 360. ----, its tension, 343. ----, {{evolution of}} heat, 344. ----, magnetic force, 345. ----, chemical force, 346. ----, spark, 348. ----, physiological effects, 347. ----. See Induction, magnetic. Matter, atoms of, 869, 1703. ----, new condition of, 60, 231, 242, 1114, 1661, 1729. ----, quantity of electricity in, 852, 861, 873, 1652. ----, absolute charge of, 1169. Measures of electricity, galvanometer, 367, note. ----, voltameter, 704, 736, 739. ----, metal precipitated, 740, 842. Measure of specific inductive capacity, 1307, 1600. Measurement of common and voltaic electricities, 361, 860, 1652. ---- electricity, degree, 736, 738. ---- ---- by voltameter, 704, 736, 739. ---- ---- by galvanometer, 367, note. ---- ---- by metal precipitated, 740, 842. Mechanical forces affect chemical affinity, 656. Mercurial terminations for convection, 1581. Mercury, periodide of, {{an exception to the}} law of conduction? 691, 1341. ----, perchloride of, 692, 1341. Metallic contact not necessary for electrolyzation, 879. ---- not essential to the voltaic current, 879, 887, 915. ---- its use in the pile, 893, 896. Metallic poles, 557. Metal and electrolyte, their state, 946. Metals, adhesion of fluids to, 1038. ----, their power of inducing combination 564, 608. ----, ---- interfered with, 638. ----, static induction in, 1329, 1332. ----, different, currents induced in, 193, 211. ----, generally secondary results of electrolysis, 746. ---- transfer chemical force, 918. ----, transference of, 539, 545. ---- insulate in a certain degree, 1328. ----, convective currents in, 1603. ----, but few magnetic, 255. Model of relation of magnetism and electricity, 116. Molecular inductive action, 1164, 1669. Motion essential to magneto-electric induction, 39, 217, 256. ---- across magnetic curves, 217. ---- of conductor and magnet, relative, 114. ---- ---- not necessary, 218. Moving magnet is electric, 220. Muriatic acid gas, its high insulating power, 1395. ----, brush in, 1462. ----, dark discharge in, 1554. ----, glow in, 1534. ----, positive and negative brush in, 1476. ----, spark in, 1422, 1463. ----, ----, has no dark interval, 1463, 1555. Muriatic acid decomposed by common electricity, 314. ----, its electrolysis (primary), 758, 786.|$|E
5000|$|The {{history of}} the {{capacitor}} discharge ignition system {{can be traced back}} to the 1890s when it is believed that Nikola Tesla was the first to propose such an ignition system. In U.S. patent #609250 first filed February 17, 1897, Tesla writes 'Any suitable moving portion of the apparatus is caused to mechanically control the charging of a condenser and its discharge through a circuit in <b>inductive</b> <b>relation</b> to a secondary circuit leading to the terminals between which the discharge is to occur, so that at the desired intervals the condenser may be discharged through its circuit and induce in the other circuit a current of high potential which produces the desired discharge.' The patent also describes very generally with a drawing, a mechanical means to accomplish ...|$|E
5000|$|... where x, y, and z are {{the three}} generators, and p0=x. One then shows, using the <b>inductive</b> <b>relations</b> of the word problem, that pn+1 is {{strictly}} greaterthan pn, and therefore all infinitely many words pn evaluate to different values in the free lattice FX.|$|R
40|$|Structures" [Mos 74], {{where they}} are called <b>inductive</b> <b>relations.</b> It should also {{be pointed out that}} in Immerman's book on "Descriptive Complexity" LFP is denoted by FO(LFP) (the closure of FO under least fixed-points) and LFP 1 is denoted by LFP(FO) (least fixed-points of first-order formulas) ...|$|R
40|$|Conventional {{approach}} {{to describe the}} semantics of programming language usually rely on <b>relations,</b> in particular <b>inductive</b> <b>relations.</b> Simulating program execution then relies on proof search tools. We describe a functional {{approach to}} automate proofs about programming language semantics. Reflection is used to take facts from the context into account. The main contribution of this work is that we developed a systematic approach to describe and manipulate unknown expressions in the symbolic computation of programs for formal proof development. The tool we obtain is faster and {{more powerful than the}} conventional proof tools...|$|R
40|$|Abstract. We {{present a}} {{practical}} tool for defining and proving properties of recursive {{functions in the}} Coq proof assistant. The tool generates from pseudo-code the graph of the intended function as an <b>inductive</b> <b>relation.</b> Then it proves that the relation actually represents a function, which is by construction the function that {{we are trying to}} define. Then, we generate induction and inversion principles, and a fixpoint equation for proving other properties of the function. Our tool builds upon stateof-the-art techniques for defining recursive functions, and {{can also be used to}} generate executable functions from inductive descriptions of their graph. We illustrate the benefits of our tool on two case studies. ...|$|E
40|$|International audienceWe {{present a}} {{practical}} tool for defining and proving properties of recursive {{functions in the}} Coq proof assistant. The tool proceeds by generating from pseudo-code (Coq functions that need not be total nor terminating) the graph of the intended function as an <b>inductive</b> <b>relation,</b> and then proves that the relation actually represents a function, which is by construction the function that {{we are trying to}} define. Then, we generate induction and inversion principles, and a fixpoint equation for proving other properties of the function. Our tool builds upon state-of-the-art techniques for defining recursive functions, and {{can also be used to}} generate executable functions from inductive descriptions of their graph. We illustrate the benefits of our tool on two case studies...|$|E
40|$|In a {{specific}} process of business intelligence, i. e. investi-gation on organized crime, empirical language processing technologies {{can play a}} crucial role. In the data used on investigative activities, such as police interrogatory or elec-tronic eavesdropping and wiretap, it is customary to find out expressions in non conventional languages as dialects, slangs or coded words. The recognition and storage of complex re-lations among subjects mentioned in these sources {{is a very difficult}} and time consuming task, ultimately based on pools of experts. We discuss here an <b>inductive</b> <b>relation</b> extraction platform that opens the way to much cheaper and consis-tent workflows. SVMs here are employed to produce a set of possible interpretations for domain relevant concepts. An ontology population process is here realized, where furthe...|$|E
40|$|Constructive type {{theories}} generally treat only total functions; partial functions present serious difficulties. In this paper, {{a theory}} of partial objects is given which puts partial functions in a general context. Semantic foundations for the theory are given in terms of {{a theory of}} <b>inductive</b> <b>relations.</b> The domain of convergence of a partial function is exactly characterized by a predicate within the theory, allowing for abstract reasoning about termination. Induction principles are given for reasoning about these functions, and comparisons are made to the domain theoretic account of LCF. Finally, an undecidability result is presented to suggest connections to a subset of recursive function theory...|$|R
40|$|Vassiliev invariants up {{to order}} six for {{arbitrary}} torus knots {n, m}, with n and m coprime integers, are computed. These invariants are polynomials in n and m whose degree coincide with their order. Furthermore, {{they turn out}} to be integer-valued in a normalization previously proposed by the authors. Vassiliev invariants [1, 2, 3] seem to be a very promising set of knot invariants to classify knot types. Since the discovery of their formulation in terms of <b>inductive</b> <b>relations</b> for singular knots [4, 5], and of their relation to knot invariants based on quantum groups or in Chern-Simons gauge theory [6, 7, 4, 8, 5], several works hav...|$|R
40|$|Verifying type {{soundness}} in HOL for OCaml: {{the core}} language Despite the recent interest in using computerized theorem provers to verify theorems in programming languages research, little {{progress has been}} made toward verification for real-world languages. Such undertakings encounter two difficulties: not only are the proofs larger and more complicated than in a corresponding research calculus, but the language itself typically lacks a formal specification. We attack both of these problems for OCaml, formalizing a sizable fragment of the language using Ott [5] and verifying its type soundness in HOL [4]. We take a straightforward approach and formalize the syntax of OCaml as a collection of (sometimes mutually) inductive datatypes, and OCaml’s type system and operational semantics as a collection of (sometimes mutually) <b>inductive</b> <b>relations</b> and recursive functions. Nipkow and van Oheimb[3] apply a similar methodolog...|$|R
40|$|Abstract. In a {{specific}} process of business intelligence, i. e. investiga-tion on organised crime, empirical language processing technologies {{can play a}} crucial role. The analysis of transcriptions on investigative ac-tivities, such as police interrogatory, for the recognition and storage of complex relations among people and locations {{is a very difficult}} and time consuming task, ultimately based on pools of experts. We discuss here an <b>inductive</b> <b>relation</b> extraction platform that opens the way to much cheaper and consistent workflows. SVMs here are employed to produce a set of possible interpretations for domain relevant concepts. An on-tology population process is here realised, where further reasoning can be applied to proof the overall consistency of the extracted information. The empirical investigation presented here shows that accurate results, comparable to the expert teams, can be achieved, and parametrization allows to fine tune the system behaviour for fitting the specific domain requirements...|$|E
40|$|Motivated by {{a recent}} use of Glauber {{dynamics}} for Monte-Carlo simulations of path integral representation of quantum spin models [4], we analyse a natural Glauber dynamics for the quantum Ising model with a transverse field on a finite graph G. We establish strict mono- tonicity properties of the equilibrium distribution and we extend (and improve) the censoring inequality of Peres and Winkler to the quantum setting. Then we consider the case when G is a regular b-ary tree and prove the same fast mixing results established in [7] for the classical Ising model. Our main tool is an <b>inductive</b> <b>relation</b> between conditional marginals (known as the “cavity equation”) together with sharp bounds on the operator norm of the derivative at the stable fixed point. It is here that {{the main difference between}} the quantum and the classical case appear, as the cavity equation is formulated here in an infinite dimensional vector space, whereas in the classical case marginals belong to a one-dimensional space...|$|E
40|$|Inductively defined {{relations}} {{are among the}} basic mathematical tools of computer science. Examples include evaluation and computation relations in structural operational semantics, labelled transition relations in process algebra semantics, inductively-defined typing judgements, and proof systems in general. This paper describes a set of HOL theorem-proving tools for reasoning about such inductively defined relations. We also describe a suite of worked examples using these tools. First printed: August 1992 Parts of this report have previously appeared as: T. Melham, `A Package for <b>Inductive</b> <b>Relation</b> Definitions in HOL', in Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and its Applications, Davis, August 1991, edited by M. Archer, J. J. Joyce, K. N. Levitt, and P. J. Windley (IEEE Computer Society Press, 1992), pp. 350 [...] 357. Contents Introduction 4 1 Inductive definitions 5 1. 1 Rule induction : : : : : : : : : : : : : : : : : : : : : : : : : [...] ...|$|E
40|$|Equivalent Transformation (ET) rules {{can be used}} to {{construct}} correct se- quential and parallel programs, as they are inherently correct. One important method for making ET rules uses logical formulas. Among logical formulas, unsatis able con- junctions of nite atoms, each of which is represented by an atom set in this paper, are especially useful for making many ET rules that are used for constructing efficient pro- grams. This paper proposes a method of proving unsatis ability of an atom set based on computation by ET rules. The proposed method is recursive, in the sense that, during proving the given atom set, it may nd a new atom set based on subset relation or in- ductive structure. Since our proposed method incorporates search based on subset and <b>inductive</b> <b>relations,</b> it {{can be used to}} prove unsatis ability of various atom sets that can- not be proven by conventional methods...|$|R
40|$|Binding is a {{fundamental}} part of language specification, yet it is both difficult and tedious to get right. In previous work, we argued that an approach based on locally nameless representation and a particular style for defining <b>inductive</b> <b>relations</b> can provide a portable, transparent, lightweight methodology to define the semantics of binding. Although the binding infrastructure required by this approach is straightforward to develop, it leads to duplicated effort and code {{as the number of}} binding forms in a language increases. In this paper, we critically compare a spectrum of approaches that attempt to ameliorate this tedium by unifying the treatment of variables and binding. In particular, we compare our original methodology with two alternative ideas: First, we define variable binding in the object language via variable binding in a reusable library. Second, we present a novel approach that collapses the syntactic categories of the object language together, permitting variables to be shared between them. Our main contribution is a careful characterization of the benefits and drawbacks of each approach. In particular, we use multiple solutions to the POPLMARK challenge in the Coq proof assistant to point out specic consequences with respect {{to the size of the}} binding infrastructure, transparency of the definitions, impact to the metatheory of the object language, and adequacy of the object language encoding...|$|R
40|$|The {{central focus}} {{of this paper is}} conditionalization, but we also address related {{principles}} such as that of reflection. It is argued that dutch book theorems do not show what they are intended to show in the ordinary (static) case, and that they are even less persuasive in the dynamic case to which conuitionalization applies. The first point is that to be forced to post odds and meet the bets of all comers reveals something about one's rationality, bu t nothing about one's degrees of belief. Adding conditional bets to the requirements of posting adds nothing to the rational constraints. We consider the argument of Paul Teller, which does address the genuinely dynamic consideration of changes of belief in the face of evidence. We argue that Teller's principle P is not a principle of rationality. This claim is relevant to the controversy concerning scientific change and its relation to anomalies in scientific theory. The principle of reflection introduced by van Fraassen fares no better. Finally, it is shown that suggestions of Carnap himself lead to the violation of conditionalization. Carnap may not have been infallible, but his intuitions concerning <b>inductive</b> <b>relations</b> were surely good enough to take into account. Overall, we find no compelling argument in favor of conditionalization as a genera. l principle, however important it may be in special circumstances...|$|R
40|$|Purpose: To {{describe}} the Relationship Marketing and Guanxi practices {{of a western}} company in China, and to create an understanding regarding the interconnection of Guanxi and Relationship Marketing {{as the foundation of}} such practices. Method: The research is qualitative with an <b>inductive</b> <b>relation</b> between theory and the empirical findings. With the research design of a case study of the western business-to-business service company ChinaNetCloud. The empirical material was collected through five semi-structured interviews done in China, with influencing persons of the case study organization ChinaNetCloud. Conclusion: Guanxi should be used to facilitate things and should not be established with anyone. To establish relationships are taking more time and will require many activities to maintain them. Relationship Marketing should be used to target other targets than the bases for Guanxi. The relationship are in China based on already existing connections and {{it is important that the}} western company is aware of that the relationship are in some cases of more importance than the product or service.  Face-to-face meeting should be used in order to establish relationships in the best way. Trust and commitment are also important dimensions in the relationships. A western company should use Guanxi and Relationship Marketing since it is important for both survival and success in China...|$|E
40|$|Abstract. We {{describe}} the operational and denotational semantics {{of a small}} imperative language in type theory with inductive and recursive definitions. The operational semantics is given by natural inference rules, implemented as an <b>inductive</b> <b>relation.</b> The realization of the denotational semantics is more delicate: The nature of the language imposes a few difficulties on us. First, the language is Turing-complete, and therefore the interpretation function we consider is necessarily partial. Second, the language contains strict sequential operators, and therefore the function necessarily exhibits nested recursion. Our solution combines and extends recent work by the authors {{and others on the}} treatment of general recursive functions and partial and nested recursive functions. The first new result is a technique to encode the approach of Bove and Capretta for partial and nested recursive functions in type theories that do not provide simultaneous induction-recursion. A second result is a clear understanding of the characterization of the definition domain for general recursive functions, a key aspect in the approach by iteration of Balaa and Bertot. In this respect, the work on operational semantics is a meaningful example, but the applicability of the technique should extend to other circumstances where complex recursive functions need to be described formally. ...|$|E
40|$|Assume that we {{may prove}} in Classical Functional Analysis that a {{primitive}} recursive relation R is well-founded, using the inductive definition of well-founded. In this paper we prove that such a proof of well-foundation may be made intuitionistic. We conclude {{that if we are}} able to formulate any mathematical problem as the inductive well-foundation of some primitive recursive relation, then intuitionistic and classical provability coincide, and for such a statement of well-foundation we may always find an intuitionistic proof if we may find a proof at all. The core of intuitionism are the methods for computing out data with given properties from input data with given properties: these are the results we are looking for when we do constructive mathematics. Proving that a primitive recursive relation R is inductively well-founded is a more abstract kind of result, but it is crucial as well, because once we proved that R is inductively well-founded, then we may write programs by induction over R. This is the way <b>inductive</b> <b>relation</b> are currently used in intuitionism and in proof assistants based on intuitionism, like Coq. In the paper we introduce the comprehension axiom for Functional Analysis in the form of introduction and elimination rules for predicates of types Prop, Nat->Prop, [...] ., in order to use Girard 2 ̆ 7 s method of candidates for impredicative arithmetic...|$|E
40|$|Fixed point {{calculus}} {{is about}} the solution of recursive equations dened by a monotonic endofunction on a partially ordered set. This tutorial discusses applications of xed point calculus {{in the construction of}} computer programs, beginning with standard applications and progressing to recent research. The basic properties of least and greatest xed points are presented. Wellfoundedness and <b>inductive</b> properties of <b>relations</b> are expressed in terms of xed points. A class of xed point equations, called " equations, is introduced. A methodology of recursive program design based on the use of hylo equations is presented. Current research on generalisations of well-foundedness and <b>inductive</b> properties of <b>relations,</b> making these properties relative to a datatype, is introduced. School of Computer Science and Information Technology, University of Nottingham, Nottingham NG 8 1 BB, England 1 1. Introduction 2 1 Introduction 1. 1 Fixed Point Equations Formulating and solving equations [...] ...|$|R
3000|$|The {{study of}} these lines has, at {{different}} times, been greatly influential in leading me to various results, which I think prove their utility {{as well as}} fertility. Thus, the law of magneto-electric induction; the earth’s <b>inductive</b> action; the <b>relation</b> of magnetism and light; diamagnetic action and its law, and magnetocrystallic action, are the cases of this kind… (Faraday 1852 a, p. 55 (3174)) [...]...|$|R
40|$|Abstract. This paper gives a reduction-preserving {{translation}} from Coquand’s dependent {{pattern matching}} [4] into a traditional type theory [11] with universes, <b>inductive</b> types and <b>relations</b> and the axiom K [22]. This translation {{serves as a}} proof of termination for structurally recursive pattern matching programs, provides an implementable compilation technique {{in the style of}} functional programming languages, and demonstrates the equivalence with a more easily understood type theory. ...|$|R
40|$|This paper {{presents}} {{a study of}} the metaphorism pattern of relational specification, showing how it can be refined into recursive programs. Metaphorisms express input-output relationships which preserve relevant information {{while at the same time}} some intended optimization takes place. Text processing, sorting, representation changers, etc., are examples of metaphorisms. The kind of metaphorism refinement studied in this paper is a strategy known as change of virtual data structure. By framing metaphorisms in the class of (<b>inductive)</b> regular <b>relations,</b> sufficient conditions are given for such implementations to be calculated using relation algebra. The strategy is illustrated with examples including the derivation of the quicksort and mergesort algorithms, showing what they have in common and what makes them different from the very start of development...|$|R
40|$|This paper {{presents}} a logical analysis of induction. Contrary to common approaches to inductive logic that treat inductive validity as a real-valued generalisation of deductive validity, {{we argue that}} the only logical step in induction lies in hypothesis formation rather than evaluation. Inspired by the seminal paper of Kraus, Lehmann & Magidor [18] we analyse the logic of inductive hypothesis formation on the metalevel of consequence relations. Two main forms of induction are considered: explanatory induction, aimed at inducing a general theory explaining given observations, and confirmatory induction, aimed at characterising completely or partly observed models. Several sets of meta-theoretical properties of <b>inductive</b> consequence <b>relations</b> are considered, each of them characterised by a suitable semantics. The approach followed in this paper is extensively motivated by referring to recent and older work in philosophy, logic, and Machine Learning...|$|R
40|$|This chapter {{concerns}} <b>inductive</b> {{logic in}} <b>relation</b> to mathematical statistics. I start by introducing a general notion of probabilistic induc- tive inference. Then I introduce Carnapian inductive logic, and I {{show that it}} can be related to Bayesian statistical inference via de Finetti's representation theorem. This in turn suggests how Carnapian induc- tive logic can be extended to include inferences over statistical hy- potheses. With this extension inductive logic becomes more easily applicable to statistics. I consider two classical statistical procedures, maximum likelihood estimation and Neyman-Pearson hypothesis test- ing, and I discuss how they can be accommodated in an inductive logic with hypotheses. ...|$|R
40|$|We {{prove that}} {{first order logic}} is {{strictly}} weaker than fixed point logic over every infinite classes of finite ordered structures with unary relations: Over these classes there is always an <b>inductive</b> unary <b>relation</b> which cannot be defined by a first-order formula, even when every inductive sentence (i. e., closed formula) can be expressed in first-order over this particular class. Our proof first establishes a property valid for every unary relation definable by first-order logic over these classes which is peculiar to classes of ordered structures with unary relations. In a second step we show that this property itself can be expressed in fixed point logic {{and can be used}} to construct a non-elementary unary relation. 1 Introduction In this paper we are concerned with a questions about finite structures for a signature Σ = f; R 1; : : :; R l g, where has to be realized as a total order and the predicate symbols R j are all unary. Partly supported by NSF grant CCR- 9113196. [...] ...|$|R
40|$|We {{present a}} {{bijective}} algorithm with which an arbitrary permutation decomposes canonically into elementary blocks {{which we call}} families, which are sets with a specified number of ascents and descents. We show that families, arranged in an arbitrary order in a sequence, are in bijection with permutations. The permutation decomposes canonically, by inserting parentheses, into a tree having as nodes a class of permutations which we call primitive. Primitive permutations can be assembled from very simple data. The data for the trees into which a permutation decomposes can be written in a form similar to the decimal classification of a library. We axiomatize that data. It has a structure {{very different from the}} permutation which it encodes, with shuffles and pair-ings instead of reorderings. These structures are similar to the fundamental processes in quantum field theory. Our main bijective structure algorithm gives explicit, additive multinomial formulae for the number of permutations with given sets of elements under and over the diagonal, or with given ascent and descent values. The multinomial expressions obtained this way give a new class of bicolored set statis-tics, between set partitions and set compositions, called shifted multinomials. These provide for the first time additive multinomial expressions for Eulerian numbers and de-rangements, as part of a sequence of new combinatorial objects. These multinomial expressions satisfy <b>inductive</b> <b>relations</b> involving only immediate neighbors, similar to the relations satisfied by the Eulerian numbers. 1 Preintroduction Much of this paper is based on the structure of a family. There are different equivalent ways to look at it. First, a family S is a set, together with a specified number k ascent values, or reds, and l descent values, or blues, with k, l ≥ 1, and k+ 1 = |S|. The information in the bicoloring of S can equivalently be given by making S into a sequence (r 1, r 2 [...] ., rk, bl, bl− 1, [...] ., b 1), where b 1 < b 2 < [...] . bl < r 1 < r 2 < [...] . < rk, and {r 1, [...] ., rk} are the reds, the elements colored red in the set S, and {b 1, [...] ., bl} are the blues, the elements colored blue. We put both kinds of information together by viewing S as a colored sequence. 1 a...|$|R
40|$|International audienceFor λ-terms {{constructed}} freely from a type signature in a type theory such as LF, {{there is}} a simple <b>inductive</b> subordination <b>relation</b> {{that is used to}} control type-formation. There is a related—but not precisely complementary—notion of independence that asserts that the inhabitants of the function space τ 1 → τ 2 depend vacuously on their arguments. Independence has many practical reasoning applications in logical frameworks, such as pruning variable dependencies or transporting theorems and proofs between type signatures. However, independence is usually not given a formal interpretation. Instead, it is generally implemented in an ad hoc and uncertified fashion. We propose a formal definition of independence and give a proof-theoretic characterization of it by: (1) representing the inference rules of a given type theory and a closed type signature as a theory of intuitionistic predicate logic, (2) showing that typing derivations in this signature are adequately represented by a focused sequent calculus for this logic, and (3) defining independence in terms of strengthening for intuitionistic sequents. This scheme is then formalized in a meta-logic, called G, that can represent the sequent calculus as an inductive definition, so the relevant strengthening lemmas can be given explicit inductive proofs. We present an algorithm for automatically deriving the strengthening lemmas and their proofs in G...|$|R
40|$|This report {{describes}} DECLARE, {{a prototype}} {{implementation of a}} declarative proof system for simple higher order logic. The purpose of DECLARE is to explore mechanisms of speci cation and proof that may be incorporated into other theorem provers. It has been developed to aid with reasoning about operational descriptions of systems and languages. Proofs in DECLARE are expressed as proof outlines, in a language that approximates written mathematics. The proof language includes specialised constructs for (co-) <b>inductive</b> types and <b>relations.</b> The system includes an abstract/article mechanism that provides a way ofisolating the process of formalization from what results, and simultaneously allow the e cient separate processing of work units. After describing the system we discuss our approach to two subsidiary issues: automation and the interactive environment provided to the user...|$|R
40|$|This chapter 1 {{concerns}} <b>inductive</b> {{logic in}} <b>relation</b> to mathematical statistics. I start by introducing a general notion of probabilistic induc-tive inference. Then I introduce Carnapian inductive logic, and I {{show that it}} can be related to Bayesian statistical inference via de Finetti’s representation theorem. This in turn suggests how Carnapian induc-tive logic can be extended to include inferences over statistical hy-potheses. With this extension inductive logic becomes more easily applicable to statistics. I consider two classical statistical procedures, maximum likelihood estimation and Neyman-Pearson hypothesis test-ing, and I discuss how they can be accommodated in an inductive logic with hypotheses. 1 From inductive logic to statistics There are strong parallels between statistics and inductive logic. An induc-tive logic is a system of inference that describes the relation between dat...|$|R
40|$|Machine-checked proofs of {{properties}} of programming languages {{have become a}} critical need, both for increased confidence in large and complex designs and {{as a foundation for}} technologies such as proof-carrying code. However, constructing these proofs remains a black art, involving many choices in the formulation of definitions and theorems that make a huge cumulative difference in the difficulty of carrying out large formal developments. The representation and manipulation of terms with variable binding is a key issue. We propose a novel style for formalizing metatheory, combining locally nameless representation of terms and cofinite quantification of free variable names in <b>inductive</b> definitions of <b>relations</b> on terms (typing, reduction, [...] .). The key technical insight is that our use of cofinite quantification obviates the need for reasoning about equivariance (the fact that free names can be renamed in derivations) ...|$|R
40|$|The psychometric {{properties}} of the Chinese version of Thurstone Primary Mental Ability scale (PMA-C scale) were investigated in a Hong Kong Chinese adult sample. The respondents were 413 people aged 40 or older from a cross-sectional survey of a representative community sample of the adult population in Hong Kong. Relations between five factors of PMA-C scale (including spatial <b>relation,</b> <b>inductive</b> reasoning, number skill, verbal meaning, and word fluency) were examined and all these five factors were positively and significantly related. The reliability and convergent validity of the PMA-C were also established. The PMA-C demonstrated excellent internal consistency (Cronbach's alpha > 0. 9). In terms of convergent validity, the Chinese version of Short Portable Mental Status Questionnaire were positively and moderately correlated to all five factors of PMA-C scale. Results indicate that the convergent validity of the PMA-C was acceptable. link_to_subscribed_fulltex...|$|R
40|$|AbstractThere is a {{dependency}} between computability of {{algorithmic complexity}} and decidability of different algorithmic problems. It {{is known that}} computability of the algorithmic complexity C(x) is equivalent to decidability of the halting problem for Turing machines. Here we extend this result {{to the realm of}} superrecursive algorithms, considering algorithmic complexity for inductive Turing machines. We study two types of algorithmic complexity: recursive (classical) and <b>inductive</b> algorithmic complexities. <b>Relations</b> between these types of algorithmic complexity and decidability of algorithmic problems for Turing machines and inductive Turing machines are considered. In particular, it is demonsrated that computability of algorithmic complexity is equivalent not only to decidability of the halting problem, but also to decidability by inductive Turing machines of the first order of many other problems for Turing machines, such as: if a Turing machine computes a recursive (total) function; if a Turing machine gives no result only for n inputs; if a Turing machine gives results only for n inputs...|$|R
40|$|Inductive {{probabilistic}} reasoning {{is understood as}} the application of inference patterns that use statistical background information to assign (subjective) probabilities to single events. The simplest such inference pattern is direct inference: from “ 70 % of As are Bs ” and “a is an A ” infer that a is a B with probability 0. 7. Direct inference is generalized by Jeffrey’s rule and the principle of cross-entropy minimization. To adequately formalize inductive {{probabilistic reasoning}} is an interesting topic for artificial intelligence, as an autonomous system acting in a complex environment may have to base its actions on a probabilistic model of its environment, and the probabilities needed to form this model can often be obtained by combining statistical background information with particular observations made, i. e. by inductive probabilistic reasoning. In this paper a formal framework for inductive probabilistic reasoning is developed: syntactically it consists of {{an extension of the}} language of firstorder predicate logic that allows to express statements about both statistical and subjective probabilities. Semantics for this representation language are developed that give rise to two distinct entailment relations: a relation |= that models strict, probabilistically valid, inferences, and a relation | ≈ that models inductive probabilistic inferences. The <b>inductive</b> entailment <b>relation</b> is obtained by implementing cross-entropy minimization in a preferred model semantics. A main objective of our approach is to ensure that for both entailment relations complete proof systems exist. This is achieved by allowing probability distributions in our semantic models that use non-standard probability values. A number of results are presented that show that in several important aspects the resulting logic behaves just like a logic based on realvalued probabilities alone. ...|$|R
