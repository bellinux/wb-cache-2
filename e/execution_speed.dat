1077|187|Public
25|$|In particular, for {{just-in-time}} compilers {{the performance}} of the run time compile component, executing together with its target code, is the key to improving overall <b>execution</b> <b>speed.</b>|$|E
25|$|In the past, APL {{compilation}} {{was regarded}} as a means to achieve <b>execution</b> <b>speed</b> comparable to other mainstream languages, especially on mainframe computers. Several APL compilers achieved some levels of success, though comparatively little of the development effort spent on APL over the years went to perfecting compilation into machine code.|$|E
25|$|As with Reliability, {{the causes}} of {{performance}} inefficiency are often found in violations of good architectural and coding practice which can be detected by measuring the static quality attributes of an application. These static attributes predict potential operational performance bottlenecks and future scalability problems, especially for applications requiring high <b>execution</b> <b>speed</b> for handling complex algorithms or huge volumes of data.|$|E
25|$|When {{switched}} into 6309 Native Mode (as {{opposed to}} the default 6809-compatible mode) many key instructions will complete in fewer clock cycles. This often improves <b>execution</b> <b>speeds</b> by up to 30%.|$|R
40|$|A new nonlinear, process-oriented, quasi-two-dimensional (Q 2 D) {{model is}} {{described}} for microwave laterally diffused MOS (LDMOS) power transistors. A set of one-dimensional energy transport equations are solved across a two-dimensional cross-section in a “current-driven” form. The model accounts for avalanche breakdown and gate conduction, and accurately predicts DC and microwave characteristics at <b>execution</b> <b>speeds</b> sufficiently fast for circuit simulation applications...|$|R
40|$|Cyclic {{averaging}} {{techniques are}} applied to the CLL resonant power converter to provide steady-state converter characteristics for rapid stress analysis. This is shown to facilitate the determination of mode duties and initial conditions through knowledge of the operational modes of the rectifier at various operating frequencies. Comparisons are made with FMA-based cyclic analyses, and Spice simulations, that show, respectively, improved accuracy and vastly improved <b>execution</b> <b>speeds...</b>|$|R
25|$|Efficiency: The {{source code}} and {{software}} architecture attributes are {{the elements that}} ensure high performance once the application is in run-time mode. Efficiency {{is especially important for}} applications in high <b>execution</b> <b>speed</b> environments such as algorithmic or transactional processing where performance and scalability are paramount. An analysis of source code efficiency and scalability provides a clear picture of the latent business risks and the harm they can cause to customer satisfaction due to response-time degradation.|$|E
25|$|The Fluid Library {{allows the}} user to model storage and {{transfer}} of fluids, bulk goods, or large amounts of discrete items, which are not desirable to model as separate objects. The library includes blocks such as tank, pipeline, valve, and objects for routing, merging, and diverging the flow. To improve model <b>execution</b> <b>speed,</b> the Fluid Library uses a linear programming solver. The library is designed to improve AnyLogic use in manufacturing, oil, gas, and mining industries. The user can simulate oil pipes and tanks, ore, coal conveyors, and production processes where liquids or bulk materials are involved, for example, in concrete manufacturing.|$|E
25|$|The Turbo name {{alluded to}} the speed of {{compilation}} and of the executables produced. The edit/compile/run cycle was fast compared to other Pascal implementations because everything related to building the program was stored in RAM, {{and because it was}} a one-pass compiler written in assembly language. Compilation was much faster than compilers for other languages (even Borland's own later compilers for C), and other Pascal compilers, and programmer time was also saved since the program could be compiled and run from the IDE. The <b>execution</b> <b>speed</b> of these COM-format programs was a revelation for developers whose only prior experience programming microcomputers was with interpreted BASIC or UCSD Pascal, which compiled to p-code which was then interpreted at runtime.|$|E
5000|$|Primacy of <b>speed</b> of <b>execution</b> : <b>speed</b> {{prevails}} {{to avoid}} the interference of consciousness of the artist.|$|R
40|$|The project {{seeks to}} develop methods to more {{efficiently}} simulate aerospace vehicles. The goals are to reduce model development time, increase accuracy (e. g.,by allowing {{the integration of}} multidisciplinary models), facilitate collaboration by geographically- distributed groups of engineers, support uncertainty analysis and optimization, reduce hardware costs, and increase <b>execution</b> <b>speeds.</b> These problems {{are the subject of}} considerable contemporary research (e. g., Biedron et al. 1999; Heath and Dick, 2000) ...|$|R
40|$|SELINGER, M. MathScript in LabVIEW. Brno: Brno University of Technology, The Faculty of Electrical Engineering and Communication, 2008. 92 pages. Supervisor Ing. Miloslav Čejka, CSc. The {{main goal}} of this Thesis {{is to examine the}} {{portability}} of the m-scripts between The National Instruments LabVIEW MathScript and The MathWorks MATLAB development programs. The Thesis deals with function differences <b>execution</b> <b>speeds</b> and giving overview of using The National Instruments LabVIEW MathScript programme...|$|R
500|$|For {{specific}} and more advanced usage scenarios, PHP offers a well defined and documented way for writing custom extensions in C or C++. [...] Besides extending the language itself {{in form of}} additional libraries, extensions are providing a way for improving <b>execution</b> <b>speed</b> where it is critical and {{there is room for}} improvements by using a true compiled language. [...] PHP also offers well defined ways for embedding itself into other software projects. [...] That way PHP can be easily used as an internal scripting language for another project, also providing tight interfacing with the project's specific internal data structures.|$|E
2500|$|In June 2013, Tom's Hardware again {{performance}} tested Firefox 22, Chrome 27, Opera 12, and Internet Explorer 10. They {{found that}} Firefox slightly edged {{out the other}} browsers in their [...] "performance" [...] index, which examined wait times, JavaScript <b>execution</b> <b>speed,</b> HTML5/CSS3 rendering, and hardware acceleration performance. Firefox also scored the highest on the [...] "non-performance" [...] index, which measured memory efficiency, reliability, security, and standards conformance, finishing substantially ahead of Chrome, the runner-up. Tom's Hardware concluded by declaring Firefox the [...] "sound" [...] winner of the performance benchmarks.|$|E
2500|$|Assembly {{language}} {{has long been}} the primary development language for many popular home computers of the 1980s and 1990s (such as the MSX, [...] Sinclair ZX Spectrum, Commodore 64, Commodore Amiga, and Atari ST). This was in large part because interpreted BASIC dialects on these systems offered insufficient <b>execution</b> <b>speed,</b> as well as insufficient facilities {{to take full advantage of}} the available hardware on these systems. Some systems even have an integrated development environment (IDE) with highly advanced debugging and macro facilities. Some compilers available for the Radio Shack TRS-80 and its successors had the capability to combine inline assembly source with high-level program statements. Upon compilation a built-in assembler produced inline machine code.|$|E
40|$|A {{protocol}} {{is given}} {{that allows a}} set of n servers to cooperate and produce an ElGamal ciphertext encrypted under one key from an ElGamal ciphertext encrypted under another, but without plaintext ever becoming available. The protocol is resilient to ⌊(n − 1) / 3 ⌋ of the servers being compromised and requires no assumptions about <b>execution</b> <b>speeds</b> or message delivery delays. Two new building blocks employed—a distributed blinding protocol and verifiable dual encryption proofs—could have uses beyond re-encryption protocols...|$|R
40|$|Collision {{detection}} is {{the process}} of determining whether objects in a computer-simulated environment are intersecting. It is vital for a range of diverse applications. However, despite numerous developments, it is often challenging to perform accurate collision detection at interactive rates. To overcome this challenge, we propose a radical departure from the state of the art: a custom broad phase collision detection microarchitecture combined with software to achieve <b>execution</b> <b>speeds</b> greater than those attainable using software alone. The integration of this microarchitecture into a ray-tracer is also investigated...|$|R
40|$|This paper {{consists}} of printed notes given {{as the first}} lecture of a two-part special lecture course on efficient programming. Emphasis is laid on on efficient programming {{in relation to the}} hardware and operating system of the Perkin-Elmer 3220 computer, although the principles embodied are in general, universally applicable. The functioning of the operating system and its interaction with the hardware of the computer is explained in considerable detail, as this is felt a necessary prerequisite to understanding how the features of the operating system might be exploited to improve program <b>execution</b> <b>speeds...</b>|$|R
2500|$|There {{have always}} been debates over the {{usefulness}} and performance of assembly language relative to high-level languages. Assembly language has specific niche uses where it is important; see below. , the TIOBE index of programming language popularity ranks assembly language at 11, ahead of Visual Basic, for example. Assembler {{can be used to}} optimize for speed or optimize for size. In the case of speed optimization, modern optimizing compilers are claimed [...] to render high-level languages into code that can run as fast as hand-written assembly, despite the counter-examples that can be found. The complexity of modern processors and memory sub-systems makes effective optimization increasingly difficult for compilers, as well as assembly programmers. Moreover, increasing processor performance has meant that most CPUs sit idle most of the time, with delays caused by predictable bottlenecks such as cache misses, I/O operations and paging. This has made raw code <b>execution</b> <b>speed</b> a non-issue for many programmers.|$|E
5000|$|... #Subtitle level 3: <b>Execution</b> <b>speed</b> with {{double-precision}} arithmetic ...|$|E
5000|$|<b>Execution</b> <b>speed</b> is {{generally}} much superior to interpreted systems.|$|E
40|$|This paper {{describes}} and {{evaluates the}} use of SIMD floating point instructions for scientific calculations. The performance of these instructions is compared with ordinary floating point code. Implementation concerns, the effects of loop unroll as well as matrix size variations are analyzed. <b>Execution</b> <b>speeds</b> are compared using matrix multiplication. The intrinsic incompatibility of the SIMD floating point implementations used by different manufacturers requires {{the use of}} two different instruction sets: 3 DNOW! on the AMD K 6 processor and the Streaming-SIMD Extensions (SSE) on the Intel Pentium III processor...|$|R
40|$|This paper {{presents}} {{a novel approach}} to object detection in images. We build on the existing work on detecting knives in images, which has previously attempted {{to solve the problem}} by using the well-established histogram of oriented gradients (HOG) features. We introduce a new feature set that allows for rapid initial object location in images, and can then be followed by the use of an object specific detector. This approach allows for speeding up the overall detection process, which has been demonstrated on the example of knives, and is in the position of bringing many object detectors closer to real-time <b>execution</b> <b>speeds...</b>|$|R
5000|$|A {{lightning}} at the base: symbolizing the <b>execution</b> {{with lightning}} <b>speed.</b>|$|R
5000|$|The highest <b>execution</b> <b>speed</b> 80 MIPS (120+ Dhrystone MIPS @ 80 MHz) ...|$|E
50|$|TI Extended BASIC {{improved}} <b>execution</b> <b>speed</b> {{somewhat by}} providing some functionality in assembly language.|$|E
5000|$|Latency of an {{architecture}} is the reciprocal of the <b>execution</b> <b>speed</b> of a task: ...|$|E
5000|$|Advanced {{computerized}} trading {{platforms and}} market gateways are becoming standard tools of most types of traders, including high-frequency traders. Broker-dealers now compete on routing order flow directly, in the fastest and most efficient manner, {{to the line}} handler where it undergoes a strict set of risk filters before hitting the execution venue(s). Ultra-low latency direct market access (ULLDMA) is a hot topic amongst brokers and technology vendors such as Goldman Sachs, Credit Suisse, and UBS. Typically, ULLDMA systems can currently handle high amounts of volume and boast round-trip order <b>execution</b> <b>speeds</b> (from hitting [...] "transmit order" [...] to receiving an acknowledgment) of 10 milliseconds or less.|$|R
40|$|Abstract — Service-Oriented Computing (SOC) is a {{promising}} means to integrate heterogeneous systems. Services from different providers {{can be integrated}} into a composite service regardless of their locations, platforms, and/or <b>execution</b> <b>speeds</b> to imple-ment complex business processes. In this paper we propose an approach for the services composition {{that takes into account}} the QoS that the composite system must satisfy. After that we design the service selection algorithm used to construct the optimal composite service with the objective to maximize the values of the well-defined QoS characteristics. In this paper we are interested on the Data-Intensive applications where the QoS attributes are very important for the reliability and performance of these systems. I...|$|R
40|$|AbstractThe {{parallel}} preconditioned {{conjugate gradient}} method (CGM) {{is often used}} in adaptive FEMs and has a critical impact on the performance. This article proposes a method for dynamically balancing the computational load of this CGM between CPU and GPU. For {{the determination of the}} optimal balance of the computational load on CPU and GPU, an execution time model for the CGM is developed which considers the different <b>execution</b> <b>speeds</b> of the two kinds of processing units. The model relies on data-specific and machine-specific parameters which are both determined at runtime. The accuracy of the model is verified in experiments. This auto-tuning-based approach for CPU/GPU collaboration enables significant performance benefits compared to CPU-only or GPU-only execution...|$|R
50|$|Whilst MASON is less {{extensive}} {{than other}} similar libraries {{it is designed}} with simplicity and <b>execution</b> <b>speed</b> as a priority.|$|E
50|$|In particular, for {{just-in-time}} compilers {{the performance}} of the run time compile component, executing together with its target code, is the key to improving overall <b>execution</b> <b>speed.</b>|$|E
5000|$|Atmel {{has also}} created an LP (low power) series of these chips with a [...] "Single Cycle Core", making the <b>execution</b> <b>speed</b> of these chips {{considerably}} faster.|$|E
40|$|This work {{focuses on}} the {{development}} of a real-time training simulator engine for a forestry machine. The rigid body dynamics of the machine’s manipulator is integrated with electrohydraulic actuator dynamics and joint controllers. System numerical stiffness introduced by the closing valves, high order hydraulic dynamics, and simulator implementation using an interpreted language were identified as the prime reasons for slowing down the integration. Successive models of lower complexity and switching between models for the open and closed phases of the valves are proposed aiming to achieve a satisfactory simulator engine that can run in real-time. Simulation results demonstrate very good prediction of an actual machine behaviour with <b>execution</b> <b>speeds</b> improved by a factor of 35...|$|R
40|$|This paper {{describes}} APSS, a PSS {{protocol for}} asynchronous systems [...] - systems in which message delivery delays and processor <b>execution</b> <b>speeds</b> {{do not have}} fixed bounds. We are eliminating an assumption and thus eliminate a vulnerability. Besides implementing secret sharing, APSS {{can be used for}} threshold cryptography [Boyd 1989; Desmedt 1988], where servers store shares of a private key and perform cryptographic operations using these shares (without ever materializing the entire private key). The particular secret sharing scheme we employ for APSS has the number of shares grow exponentially with t and is thus practical only if t is small (e. g., 1, 2, or 3); such small values of t are common when building distributed service...|$|R
40|$|A {{protocol}} {{is given}} to take an ElGamal ciphertext encrypted under the key of one distributed service and produce the corresponding ciphertext encrypted under the key of another distributed service, but without the plaintext ever becoming available. Each distributed service comprises a set of servers and employs threshold cryptography to maintain its service private key. Unlike prior work, the protocol requires no assumptions about <b>execution</b> <b>speeds</b> or message delivery delays. The protocol also imposes fewer constraints on where and when its various steps are performed, which can bring improvements in end-to-end performance for some applications (e. g., a trusted publish/subscribe infrastructure.) Two new building blocks employed [...] -a distributed blinding protocol and verifiable dual encryption proofs [...] -could have uses beyond re-encryption protocols...|$|R
