17|3|Public
5000|$|... #Caption: An {{approximate}} {{block diagram}} of the Z80. There is no dedicated adder for offsets or separate <b>incrementer</b> for R, and no need {{for more than a}} single 16-bit temporary register WZ (although the <b>incrementer</b> latches are also used as a 16-bit temporary register, in other contexts). It is the PC and IR registers that are placed in a separate group, with a detachable bus segment, to allow updates of these registers in parallel with the main register bank.|$|E
50|$|The decode stage {{ended up}} with {{quite a lot of}} hardware: MIPS had the {{possibility}} of branching if two registers were equal, so a 32-bit-wide AND tree ran in series after the register file read, making a very long critical path through this stage. Also, the branch target computation generally required a 16 bit add and a 14 bit <b>incrementer.</b> Resolving the branch in the decode stage made it possible to have just a single-cycle branch mispredict penalty. Since branches were very often taken (and thus mispredicted), it was very important to keep this penalty low.|$|E
5000|$|A simple array {{is defined}} using the colon syntax: init''''increment''''terminator. For instance:>> array = 1:2:9array = 1 3 5 7 9defines a {{variable}} named [...] (or assigns a new value to an existing variable {{with the name}} [...] ) which is an array consisting of the values 1, 3, 5, 7, and 9. That is, the array starts at 1 (the init value), increments with each step from the previous value by 2 (the increment value), and stops once it reaches (or to avoid exceeding) 9 (the terminator value).>> array = 1:3:9array = 1 4 7the increment value can actually be left out of this syntax (along {{with one of the}} colons), to use a default value of 1.>> ari = 1:5ari = 1 2 3 4 5assigns to the variable named [...] an array with the values 1, 2, 3, 4, and 5, since the default value of 1 is used as the <b>incrementer.</b>|$|E
40|$|We {{describe}} {{the results and}} status of a project aiming to provide a provably correct library of basic circuits. We use the theorem proving system PVS {{in order to prove}} circuits such as <b>incrementers,</b> adders, arithmetic units, multipliers, leading zero counters, shifters, and decoders. All specifications and proofs are available on the web. ...|$|R
40|$|This paper {{introduces}} RT-SCAN, {{a register}} transfer (RT) level test synthesis technique which enables {{the testing of}} complex sequential circuits by combinational test patterns {{without the use of}} scan, eliminating the high overheads associated with full-scan testing. The methodology involves both DFT to prepare the sequential circuit for combinational testing, as well as synthesizing the necessary sequential circuit input patterns from the given combinational test patterns. Unlike the existing high-level methods, the new approach is applicable to any general design, including control-flow intensive designs, where the control-flow and hence random logic, multiplexors, counters (<b>incrementers),</b> buses, and registers, dominate the circuit, with the existence of a few arithmetic units...|$|R
40|$|This paper {{presents}} {{a very fast}} and low-power address bus encoder, whose critical path delay and area are only weakly dependent on the address bus width. Although the encoding algorithm of the proposed structure {{is the same as}} the INC-XOR encoding, its encoder and decoder architectures, called DX, are much faster. The DX architecture implements the INC-XOR encoding partially (partial DX architecture) or fully (registered DX architecture.) The partial implementation, which is faster and consumes less power and silicon area, is appropriate for cases where the size of the basic block (sequential addresses without branches or jumps) is bounded, e. g., by 256. The registered DX architecture uses a multi-stage pipelined structure with pseudo-incrementers to reduce the combinational delay of each pipeline stage. The two DX implementations (partial and registered) are compared with three conventional INC-XOR architectures realized by using the ripple carry, the carry look-ahead, and Sklansky prefix <b>incrementers.</b> The 1 results for the critical path delay, gate count, power-delay product, and energy-delay product show considerable improvements over the conventional implementations...|$|R
40|$|The complex valued {{matched filter}} correlators consume maximum {{power in the}} DS/SS CDMA receivers. These correlators {{accumulate}} 1024 samples lying in the range- 7 to + 7. This accumulation needs 3 data bits, 1 sign bit and 10 extra bits for overflow. Hence, the correlator can be implemented as a cascade of 4 -bit full adder and a 10 -bit <b>incrementer.</b> As a ripple carry adder (RCA) consumes the least power among all the existing adder architectures, we have implemented the 4 -bit adder as a RCA. Previous incrementers were implemented as ripple counters. In this {{paper we propose a}} novel <b>incrementer</b> which is faster than a ripple counter based <b>incrementer.</b> Hence, it can be operated at a reduced voltage resulting in considerable power reduction. The <b>incrementer</b> is implemented using multiplexers, AND gates and TSPC registers. The ripplecounte...|$|E
40|$|Implementing Shor's Algorithm with quantum {{circuits}} involves many complex operations such as addition and modular exponentiation. The {{variety and}} complexity of the quantum gates involved are tremendous. The quantum <b>incrementer</b> is the simplest nontrivial quantum circuit which exhibits basic arithmetic operations such as addition, carry propagation, and the reset of carry, or auxiliary, bits. These operations are ubiquitous in quantum computing; thus, an investigation of this simplest case, the quantum <b>incrementer,</b> offers fundamental insight which can be used to build more complicated circuits. An analysis of various 4 -bit <b>incrementer</b> circuits is presented, and is generalized to the n-bit case. Three <b>incrementer</b> circuit topologies are derived and compared based on their total number of gates, the number of carry or auxiliary bits utilized, and the complexity of the types of gates used. A general method is derived to decompose complicated circuits into simpler circuits which are easier to manage and physically implement. Due to the cancellation of intermediate unitary gates, it is shown that adding auxiliary bits slightly increases the complexity of a given circuit by the order of 3 n, which pales in comparison to the complexity of the original circuit of the order n 2. The fundamental logic unit in classical computation theory is the bit, which has two distinc...|$|E
40|$|Wireless Sensor Networks (WSN) {{are gaining}} {{popularity}} as a flexible and economical alternative to field-bus installations for {{monitoring and control}} applications. For mission-critical applications, communication networks must provide end-to-end reliability guarantees, posing substantial challenges for WSN. Reliability can be improved by redundancy, and is often addressed on the MAC layer by re-submission of lost packets, usually applying slotted scheduling. Recently, researchers have proposed a strategy to optimally improve the reliability of a given schedule by repeating the most rewarding slots in a schedule incrementally until a deadline. This <b>Incrementer</b> {{can be used with}} most scheduling algorithms but has scalability issues which narrows its usability to offline calculations of schedules, for networks that are rather static. In this paper, we introduce SchedEx, a generic heuristic scheduling algorithm extension which guarantees a user-defined end-to-end reliability. SchedEx produces competitive schedules to the existing approach, and it does that consistently more than an order of magnitude faster. The harsher the end-to-end reliability demand of the network, the better SchedEx performs compared to the <b>Incrementer.</b> We further show that SchedEx has a more evenly distributed improvement impact on the scheduling algorithms, whereas the <b>Incrementer</b> favors schedules created by certain scheduling algorithms...|$|E
40|$|With a modulo-N {{accumulator}} {{and a set}} {{of reference}} waveforms, a new architecture of high-performance digital frequency synthesizer is devised. The reference waveforms with the same frequency but different phases are passed through a multiplexer to obtain the maximal frequency with an <b>incrementer.</b> A Gray encoder is designed to eliminate the glitch problem. The performance of the synthesizer is illustrated via timing simulations with the TSMC 0. 35 Âµm cell-based process...|$|E
40|$|This paper {{presents}} {{a collection of}} computational modules implemented with chemical reactions: an inverter, an <b>incrementer,</b> a decrementer, a copier, a comparator, a multiplier, an exponentiator, a raise-to-a-power operation, and a logarithm in base two. Unlike previous schemes for chemical computation, this method produces designs that are dependent only on coarse rate categories for the reactions ("fast" vs. "slow"). Given such categories, the computation is exact and independent of the specific reaction rates. The designs are validated through stochastic simulations of the chemical kinetics...|$|E
40|$|In this letter, {{a compact}} {{reconfigurable}} counter memory (RCM) is proposed for spiking pixels. In contrast to conventional in-pixel counter circuitry, the proposed RCM does {{not rely on}} a flip-flop-based circuit but instead uses a very novel circuit structure that combines a combinational <b>incrementer</b> together with static and dynamic memory cells. The proposed RCM provides counting as well as in-pixel storage functionalities allowing for intermediate readout of digital pixel values. Reported experimental results validate the novel concept of RCM-based spiking pixel in AMIS 0. 35 -mu m CMOS technology. The propose pixel architecture is inherently insensitive to power supply voltage scaling and is thus well suited to submicrometer CMOS processes...|$|E
40|$|This paper {{presents}} {{a collection of}} computational modules implemented with chemical reactions: an inverter, an <b>incrementer,</b> a decrementer, a copier, a comparator, and a multiplier. Unlike previous schemes for chemical computation, ours produces designs that are dependent only on coarse rate categories for the reactions (âfast â vs. âslowâ). Given such categories, the computation is exact and independent of the specific reaction rates. We validate our designs through stochastic simulations of the chemical kinetics. Although conceptual for the time being, our methodology has potential applications in domains of synthetic biology such as biochemical sensing and drug delivery. We are exploring DNA-based computation via strand displacement as a possible experimental chassis...|$|E
40|$|We {{can use a}} {{high-speed}} parallel adder in <b>incrementer</b> / decrementer to improve the operating speed which can count up or count down from the loaded value by one step in one clock cycle. For this, design of a faster and highly reliable adder is of major importance. Thus, much effort has been invested in the research {{that has led to}} faster and more efficient ways to perform this operation. To prove the efficiency of the proposed method, the circuit is simulated in pass transistor CMOS 50 nm technology and some simulation parameters are calcultes in the layout of the circuit. The binary decrementer reduces the stored binary data in memopry or register by â 1 â. This can be done by using 2 âs complement method by using XOR gates which convert binary data in 1 âs complement and then by addition of binary â 1 â it can be converted to 2 âs complement form. It is made by cascading ân â full adders for ân â number of bits i. e. the storage capacity of the register to be decremented. Hence, a 4 -bit binary decrementer requires 4 cascaded half adder circuits. This paper presents the eight bit CMOS base <b>incrementer</b> and decrementer logic design using eight bit adder and subtractor. The parametric simulation is done on MICROWIND layout editor tool. The any conventional static CMOS adder with pullup and pulldown logic requires 32 MOSFET whereas our design adder requires 30 MOSFETs. Our design methodology is based on static CMOS logic and transmission gate logic to achieve smaller delays, reduce power dissipation and optimized area...|$|E
40|$|Abstract â In this paper, {{we propose}} 32 -bit pipelined RISC {{processor}} using VLIW architectures. This processor is especially used for both D. S. P applications and general purpose applications. Reduced instruction {{is the main}} criteria used to develop in this processor. With a single instruction scheme, more executions can be done using S. I. M. E. processor consists of the blocks namely program counter, clock control unit, ALU, IDU and registers. Advantageous architectural modifications {{have been made in}} the <b>incrementer</b> circuit used in program counter and carry select adder unit of the ALU in the RISC CPU core. In this paper, we have extended the utility of the processor towards convolution and correlation applications, which are the most important digital signal processing application...|$|E
40|$|Advanced {{high-speed}} source-synchronous {{systems such}} as GDDR 5 use multiple source-synchronous clocks to increase memory bandwidth. Therefore, well-defined phase relationships among multiple clocks are required to perform correct read/write operations. A GDDR 5 system solves this problem by adaptive clock synchronization training. For such multiple clocks synchronization training at controller side this paper proposes two simplified architectures based on: a) Unit-delay <b>incrementer,</b> b) PI (Phase-Interpolator) based PLL (Phase-Locked Loop). Experiments show that the proposed unit-delay architecture consumes only 0. 89 mW power and 100 (mum) 2 area in 65 nm which is 16. 8 times less power and 35 times less area than other works while power and area consumed in the PI-based PLL architecture depends upon {{the complexity of the}} PI itself...|$|E
40|$|Typical control flows for {{real-time}} ASICs exhibit complex decision making, {{and therefore}} require extensive flag/condition handling and branching. The logic {{implementation of this}} part of the controller often requires an excessive amount of silicon area and limits the throughput of the controller and consequently of the complete ASIC. In this paper, we present novel methods for improving these area and timing characteristics in large microcoded controllers, based on their functional characteristics encountered in typical examples. For the flag and condition handling logic, we use the fact that many flags are needed simultaneously for efficient complex branching and that these are used at different timesteps and thus have a very long lifetime. For the branch generation, we observe that the complexity of the sequencer can be reduced best by use of an <b>incrementer.</b> status: publishe...|$|E
40|$|Reinforcement Programming (RP) {{is a new}} {{approach}} to automatically generating algorithms that uses reinforcement learning techniques. This paper introduces the RP approach and demonstrates its use to generate a generalized, in-place, iterative sort algorithm. The RP approach improves on earlier results that use genetic programming (GP). The resulting algorithm is a novel algorithm that is more efficient than comparable sorting routines. RP learns the sort in fewer iterations than GP and with fewer resources. Experiments establish interesting empirical bounds on learning the sort algorithm: A list of size 4 is sufficient to learn the generalized sort algorithm. The training set only requires one element and learning took less than 200, 000 iterations. Additionally RP was used to generate three binary addition algorithms: a full adder, a binary <b>incrementer,</b> and a binary adder...|$|E
40|$|In this thesis, novel modulo {{reduction}} algorithms {{are proposed}} that considerably simplify a large modulo operation to {{the sum of}} a number of small modulo operations. By applying the proposed modulo reduction algorithms to the modified Chinese Remainder Theorem (CRT), the complexity of modulo operation in the modified CRT is reduced significantly. The modulo reduction technique and the modulo reduced modified CRT are applied to derive R/B algorithms for two existing three-moduli sets and four newly found three-moduli sets. A novel R/B converter for N 1 = { 2 n, 2 n + 1, 2 n - 1 } with reduced modulo operations is proposed to show the efficiency of the proposed modulo reduction technique. Novel MUX-based designs of some components needed for constructing the new converter are developed. New unsigned and signed- 2 's complement incrementer/decrementer are designed to implement the operation of Z Â± 1. The new modulo <b>incrementer</b> and decrementer are developed to implement the operations of [Special characters omitted. ] and [Special characters omitted. ]. (Abstract shortened by UMI. ...|$|E
40|$|This paper {{provides}} {{the first comprehensive}} description of the Z 1, the mechanical computer built by the German inventor Konrad Zuse in Berlin from 1936 to 1938. The paper describes the main structural elements of the machine, the high-level architecture, and the dataflow between components. The computer could perform the four basic arithmetic operations using floating-point numbers. Instructions were read from punched tape. A program consisted of a sequence of arithmetical operations, intermixed with memory store and load instructions, interrupted possibly by input and output operations. Numbers were stored in a mechanical memory. The machine did not include conditional branching in the instruction set. While {{the architecture of the}} Z 1 is similar to the relay computer Zuse finished in 1941 (the Z 3) there are some significant differences. The Z 1 implements operations as sequences of microinstructions, as in the Z 3, but does not use rotary switches as micro-steppers. The Z 1 uses a digital <b>incrementer</b> and a set of conditions which are translated into microinstructions for the exponent and mantissa units, {{as well as for the}} memory blocks. Microinstructions select one out of 12 layers in a machine with a 3 D mechanical structure of binary mechanical elements. The exception circuits for mantissa zero, necessary for normalized floating-point, were lacking; they were first implemented in the Z 3. The information for this article was extracted from careful study of the blueprints drawn by Zuse for the reconstruction of the Z 1 for the German Technology Museum in Berlin, from some letters, and from sketches in notebooks. Although the machine has been in exhibition since 1989 (non-operational), no detailed high-level description of the machine's architecture had been available. This paper fills that gap. Comment: 24 pages, 20 figure...|$|E

