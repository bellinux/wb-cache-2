72|0|Public
5000|$|PHP allows {{serialization}} and <b>deserialization</b> {{of whole}} objects. If untrusted input is {{allowed into the}} <b>deserialization</b> function, {{it is possible to}} overwrite existing classes in the program and execute malicious attacks. [...] Such an attack on Joomla was found in 2013.|$|E
5000|$|Serialization and <b>deserialization</b> {{of classes}} to/from strings.|$|E
5000|$|... #Subtitle level 2: The {{serialization}} and <b>deserialization</b> library.|$|E
5000|$|JSON: adds JSON related {{serialization}} and <b>deserialization</b> {{methods to}} POJOs ...|$|E
5000|$|... #Subtitle level 3: Example {{serialization}} and <b>deserialization</b> code in Python ...|$|E
5000|$|Rules of what {{fields are}} {{intended}} to be excluded from (<b>de)serialization</b> ...|$|E
50|$|Also {{the use of}} {{serialization}} and <b>deserialization</b> {{is another}} alternative to using clone.|$|E
5000|$|Beyond {{serialization}} and <b>deserialization,</b> MGTs must {{incorporate a}} number of additional technologies {{to allow them to}} operate at high line rates. Some of these are listed below: ...|$|E
50|$|XML-binary Optimized Packaging (XOP) is a {{mechanism}} defined for the serialization of XML Information Sets (infosets) that contain binary data, {{as well as}} <b>deserialization</b> back into the XML Information Set.|$|E
50|$|This {{process of}} serializing an object is also called {{marshalling}} an object. The opposite operation, extracting a data structure {{from a series}} of bytes, is <b>deserialization</b> (which is also called unmarshalling).|$|E
50|$|An {{object that}} is {{serialized}} {{is in the}} form of a byte stream and it can eventually be converted back to a copy of the original object. <b>Deserialization</b> is the process of converting the byte stream data back to its original object type.|$|E
50|$|Even on {{a single}} machine, {{primitive}} pointer objects are too fragile to save because the objects to which they point may be reloaded to a different location in memory. To deal with this, the serialization process includes a step called unswizzling or pointer unswizzling, where direct pointer references are converted to references based on name or position. The <b>deserialization</b> process includes an inverse step called pointer swizzling.|$|E
50|$|In {{computer}} science, pointer swizzling is {{the conversion}} of references based on name or position to direct pointer references. It is typically performed during the <b>deserialization</b> (loading) of a relocatable object from disk, such as an executable file or pointer-based data structure. The reverse operation, replacing pointers with position-independent symbols or positions, is {{sometimes referred to as}} unswizzling, and is performed during serialization (saving).|$|E
50|$|In {{computer}} science, unmarshalling or unmarshaling {{refers to}} the process of transforming a representation of an object that was used for storage or transmission to a representation of the object that is executable. A serialized object which was used for communication can not be processed by a computer program. An unmarshalling interface takes the serialized object and transforms it into an executable form. Unmarshalling (similar to <b>deserialization)</b> is the reverse process of marshalling.|$|E
50|$|Radix trees {{also share}} the {{disadvantages}} of tries, however: {{as they can}} only be applied to strings of elements or elements with an efficiently reversible mapping to strings, they lack the full generality of balanced search trees, which apply to any data type with a total ordering. A reversible mapping to strings {{can be used to}} produce the required total ordering for balanced search trees, but not the other way around. This can also be problematic if a data type only provides a comparison operation, but not a (<b>de)serialization</b> operation.|$|E
50|$|In {{computer}} science, marshalling or marshaling is {{the process}} of transforming the memory representation of an object to a data format suitable for storage or transmission, and it is typically used when data must be moved between different parts of a computer program or from one program to another. Marshalling is similar to serialization and is used to communicate to remote objects with an object, in this case a serialized object. It simplifies complex communication, using custom/complex objects to communicate instead of primitives. The opposite, or reverse, of marshalling is called unmarshalling (or demarshalling, similar to <b>deserialization).</b>|$|E
50|$|The Culture of Collaboration explores how {{collaborative}} {{culture is}} changing business models {{and the nature}} of work. The author goes inside highly-collaborative organizations including Boeing, Toyota, the Dow Chemical Company, Procter & Gamble, DreamWorks Animation, Industrial Light & Magic, the Myelin Repair Foundation, and the Mayo Clinic. He explains how their methods can create value in almost any industry. The book also describes the trend towards real-time, spontaneous collaboration and the <b>deserialization</b> of interaction and work. In his preface, Rosen explains that his idea for the book originated when he was invited to the BMW engineering center in Munich during the final design stage for the X5 sports activity vehicle. Among the terms Rosen coins in the book are mirror zones and the ten cultural elements of collaboration.|$|E
40|$|Many {{tools for}} {{automated}} testing, model checking, and debugging store and restore program states multiple times. Storing/restoring a program state is commonly done with serialization/deserialization. Traditionally, the format for stored states {{is based on}} data: serialization generates the data that encodes the state, and <b>deserialization</b> interprets this data to restore the state. We propose a new approach, calledCoDeSe, wheretheformatforstoredstatesisbasedon code: serialization generates code whose execution restores the state, and <b>deserialization</b> simply executes the code. We implemented CoDeSe in Java and performed a number of experiments on <b>deserialization</b> of states. CoDeSe provides on average more than 6 X speedup over the highly optimized <b>deserialization</b> from the standard Java library. Our new format also allows simple parallel <b>deserialization</b> that can provide additional speedup {{on top of the}} sequential CoDeSe but only for larger states...|$|E
40|$|Abstract — Differential <b>Deserialization</b> (DDS) is a SOAP {{optimization}} technique wherein servers save checkpoints and parser states associated with portions of previously received messages, {{and use them}} to avoid full parsing and <b>deserialization</b> of similar new messages. In this paper, we characterize DDS’s memory requirements and memory overhead, introduce a new technique for storing only the differences between successive parser states for a message, and demonstrate how this optimization, which we call differential checkpointing, speeds up the DDS optimization and reduces its memory requirements. 1 Index Terms — SOAP, Web services performance, <b>deserialization,</b> XML parsing...|$|E
40|$|SOAP, a simple, robust, and {{extensible}} {{protocol for}} {{the exchange of}} messages, is {{the most widely used}} communication protocol in the Web services model. SOAP’s XML-based message format hinders its performance, thus making it unsuitable in high-performance scientific applications. The <b>deserialization</b> of SOAP messages, which includes processing of XML data and conversion of strings to in-memory data types, is the major performance bottleneck in a SOAP message exchange. This paper presents and evaluates a new optimization technique for removing this bottleneck. This technique, called differential <b>deserialization</b> (DDS), exploits the similarities between incoming messages to reduce <b>deserialization</b> time. Differential <b>deserialization</b> is fully SOAPcompliant and requires no changes to a SOAP client. A performance study demonstrates that DDS can result in a significant performance improvement for some Web services 1...|$|E
40|$|Differential <b>Deserialization</b> (DDS) is an {{optimization}} technique that exploits similarities between incoming SOAP messages to reduce <b>deserialization</b> time. DDS works by checkpointing {{the state of}} the SOAP deserializer at various points while deserializing a message, and using those checkpoints to avoid full <b>deserialization</b> of similar messages. DDS can improve performance in many cases, but its benefit is limited by the potentially significant memory and processing overhead associated with its checkpointing mechanism. Differential checkpointing (DCP) substantially reduces memory use, but still requires significant processing overhead. In this paper, we introduce lightweight checkpointing (LCP), a checkpointing approach that significantly reduces the cost of both DDS and DCP, in terms of both memory use and processing time. LCP statically determines locations in the incoming message where it would be most efficient to create checkpoints. LCP creates checkpoints much faster than both our original DDS checkpointing mechanism and our DCP approach. LCP also has significantly smaller memory requirements. For example, in some of our test cases, LCP requires only 10 % of the memory that DCP requires, and only 3 % of the memory that our original approach required. In terms of processing time, <b>deserialization</b> with LCP is approximately 50 % to 60 % faster than without differential <b>deserialization,</b> when approximately half the message is unchanged from the previous message. 1...|$|E
40|$|Abstract: The {{object-oriented}} {{paradigm is}} increasingly {{used in the}} implementation {{and the use of}} web services. How-ever, the mismatch between objects and document structures in the wire has a negative impact over interoper-ability, more particularly when subtyping is involved. In this paper, we discuss how to improve interoperability in this context by preserving the subsumption property associated to subtyping. First we show the weaknesses of existing web service frameworks used for serialization and <b>deserialization.</b> Second we propose new foun-dations for serialization and <b>deserialization,</b> which leads to the specification of a new data binding between objects and document structures, compatible with subtyping. ...|$|E
40|$|Web {{services}} technology {{has emerged as}} a key infrastructure that enables business entities to interact with each other without any human inventions. In order for the technology to be widely used, especially in any field where a large volume of transactions may be processed, it is highly desirable that the Web services engine should tolerate such environments. In this paper, we present a novel approach for improving Web services performance. We first focus on the fundamental characteristics of the Web services in that the SOAP messages on the wire are mostly generated by machines and have a lot of similarities among the processed messages. By making use of these features and eliminating the redundant processing, we propose a new <b>deserialization</b> mechanism that reuses matching regions from the previously deserialized application objects from earlier messages, and only performs <b>deserialization</b> for a new region that would not be processed before. Through our experiments in this paper, we observed that our approach obtained a 288 % performance gain (maximum) by incorporating the differential <b>deserialization</b> into the Axis SOAP engine...|$|E
40|$|Short paper {{presented}} as a posterInternational audienceThe object-oriented paradigm is increasingly used in the implementation {{and the use of}} web services. However, the mismatch between objects and document structures in the wire has a negative impact over interoperability, more particularly when subtyping is involved. In this paper, we discuss how to improve interoperability in this context by preserving the subsumption property associated to subtyping. First we show the weaknesses of existing web service frameworks used for serialization and <b>deserialization.</b> Second we propose new foundations for serialization and <b>deserialization,</b> which leads to the specification of a new data binding between objects and document structures, compatible with subtyping...|$|E
30|$|For {{the code}} {{validation}} of declarative languages derived from XML, the most trivial {{is to think}} of using XML Schema validation [14], since it specifies validation rules for the elements and attributes of the language. There are several tools that implement this validation method. Intelligent Knowledge Management Environment (IKME) [15] is a static code validation tool that identifies syntactical errors with basis just on XML Schema of the language. XML Screamer [16] is another tool that uses XML Schema to validate XML documents and has an architecture that tries to optimize this process. Such optimizations are possible because of the integration between the SAX parser and the XML <b>deserialization.</b> For example, in a traditional scenario, a SAX parser throws an event whenever it finds a start tag. Then the <b>deserialization</b> catches this event and converts the information of the start tag for some business class related to the application. The XML Screamer integrates the scanning, parsing, validation and <b>deserialization</b> process in a single low level tool, making unnecessary creating and catching SAX events. It also carries out performance evaluations {{in order to prove}} the gain when using that approach. Finally, there are also validation libraries that use XML Schema, like the standard Java library for XML treatment and the Xerces API (Application Programming Interface) [17].|$|E
40|$|AbstractÐSystem-on-a-chip �SOC) designs {{present a}} number of unique {{testability}} challenges to system integrators. Test access to embedded cores often requires dedicated test access mechanisms �TAMs). We present an improved approach for designing efficient TAMs and investigate the problems of improved <b>deserialization</b> of test data in the core wrapper, optimal test bus sizing, and optimal assignment of cores to test buses in the system. Place-and-route and power constraints are incorporated in the model. This work represents {{an important first step}} towards combining TAM design with efficient wrapper design for test data <b>deserialization.</b> Experimental results demonstrate that the proposed TAM optimization methodology provides efficient test bus designs for minimizing the testing time. Index TermsÐCore-based systems, embedded core testing, integer linear programming, linearization, test access mechanism �TAM), test bus, testing time. ...|$|E
40|$|Abstract:- This paper {{describes}} RuCOS runtime {{code generator}} for object serialization embedded into RMI. We developed RuCOS and a modified Java RMI. The feature of RuCOS is dynamic code generation for serialization / <b>deserialization</b> at runtime. We {{can improve the}} performance of RMI using RuCOS in comparison with standard Java RMI. In this paper, the implementation issues of RuCOS are described...|$|E
40|$|The {{process of}} {{converting}} a data structure or object state into a storable format {{is referred to}} as serialization. The resurrection of the stored data in the same or another computer environment {{is referred to as}} <b>deserialization.</b> Binary Serialization is converting the object in binary format and being able to store it in a storage medium. Many programming languages provide interfaces for serializing which can be implemented by our object classes that we want to serialize. Serialization and <b>deserialization</b> can hence be attained by writing codes for converting a class object into any format which we can save in a hardware and produce back later in any other or the same environment. This paper describes how serialization is performed in different programming languages. It gives a clear picture on how to create classes and objects which need to be serialized implementing the different build-in interfaces provided within languages. Binary Serialization is one of them. In this paper we explain how binary serialization of objects is done in C++, Java and. NET. 1...|$|E
40|$|ABSTRACT: Components from {{different}} sources are often non-interoperable. This is often due to data mismatches. This paper presents an XML-based {{approach to the}} data adaptation problem. It covers serialization of objects to XML, their transformation with XSLT, as well as <b>deserialization,</b> i. e., parsing and reconstruction of the transformed objects. We statically analyze classes to generate specific document types and allow static preprocessing. Compared to normal interpreted XML processing, this approach eliminates introspection overhead, thus accelerating the components ’ communication. I...|$|E
40|$|This paper {{introduces}} a standard cell based {{design for a}} Serializer and Deserializer (SerDes) communication link. The proposed design is area, power and design time efficient as compared to conventional SerDes Designs, making it very attractive for modest budget multi-core and multi-processor ASICs with wide communication buses {{that are difficult to}} accommodate within the pin count of commonly available packaging. The design employs a “Statistical Random Sampling Technique ” to observe and adjust the synchronization and serialization signals at start up rather than using a resource-heavy PLL or DLL based frequency multiplier/synthesizer and clock data recovery circuits. The serialization and <b>deserialization</b> logic is based on standard cell technology that makes the design highly portable. Multiple serial lines are bundled with a strobe that is used as a reference signal for <b>deserialization.</b> Data-to-strobe timing skew is compensated by adjusting the launch times of strobe and data symbols at the sender side. The edges of the strobe are set within the eye of data symbols to have maximum timing margin, which makes the design inherently tolerant of jitter. Power consumption of the proposed SerDes design is 30 mW per serial link targeted to IBM Cu- 11 (130 nm) Technology, nearly a 2. 5 x improvement over the conventional design with a 60 % less area requirement...|$|E
40|$|Subtyping {{tests are}} {{essential}} in typed publish/subscribe infrastructures, {{especially when the}} underlying programming language supports subtype conformance, as in Java or C#. These tests are particularly challenging when the publish/subscribe infrastructure is distributed, because processes have diverging views and new types may be added in a decentralized manner. Maybe surprisingly, subtyping tests for such distributed systems have been devoted only little attention so far; they are usually strongly intertwined with serialization and code transfer mechanisms. This paper presents an efficient subtype testing method for event objects received through the wire, requiring neither the download of a full description of the types or classes of these objects nor their <b>deserialization.</b> We use a slicing technique that encodes a multiple subtyping hierarchy with as little memory as the best known centralized type encoding, but allows for the dynamic addition of event types without re-computing the encoding. We convey the practicality of our approach through performance measures obtained with standard Java libraries in a publish/subscribe system. Our approach performs between 3 and 12 times faster than a code transfer approach without adding overhead to object <b>deserialization,</b> and requires the same testing time as a straightforward stringbased type encoding while reducing the encoding length {{by a factor of}} 50...|$|E
40|$|This {{application}} note describes a 16 -channel, source-synchronous LVDS interface operating at double data rate (DDR). The transmitter (TX) requires 16 LVDS pairs for data and one LVDS pair for the forwarded clock. The transmitter operates at 8 : 1 serialization {{on each of}} the 16 data channels. The receiver (RX) also requires 16 LVDS pairs for data and one LVDS pair for the source-synchronous clock input. The receiver operates at 1 : 8 <b>deserialization</b> {{on each of the}} 16 data channels. The timing of the receiver is described in depth and characterized in hardware...|$|E
40|$|Map-Reduce is {{a popular}} {{distributed}} programming framework for parallelizing computation on huge datasets over {{a large number of}} compute nodes. This year completes a decade since it was invented by Google in 2004. Hadoop, a popular open source implementation of Map-Reduce was introduced by Yahoo in 2005. Over these years many researchers have worked on various problems related to Map-Reduce and similar distributed programming models. Hadoop itself {{has been the subject of}} various research projects. The prior work in this field is focussed on making Map- Reduce more efficient for iterative processing, or making it more pipelined across different jobs. This has resulted in an improvement of performance for iterative applications. However, little focus was given to the task engine which carries out the Map-Reduce computation itself. Our analysis of applications running on Hadoop shows that more than 50 % of the time is spent in the framework in doing tasks such as sorting, serialization and <b>deserialization.</b> We solve this problem introducing an extension to the Map-Reduce programming model. This extension allows us to use more efficient data structures like hash tables. It also allows us to lower the cost of serialization and <b>deserialization</b> of the key value pairs. With these efforts we have been able to lower the overheads of the framework, and the performance of certain important applications such as Pagerank and Join has improved by 1. 5 to 2. 5 times...|$|E
40|$|International audienceWe {{present a}} library for generic {{programming}} in OCaml, adapting some techniques borrowed from other functional languages. The library {{makes use of}} three recent additions to OCaml: generalised abstract datatypes are essential to reflect types, extensible variants allow this reflection to be open for new additions, and extension points (PPX) provide syntactic sugar and generate boiler plate code that simplify {{the use of the}} library. The building blocks of the library can be used to support many approaches to generic programming through the concept of view. We present an application of the library to provide type-safe alternatives to OCaml's unsafe <b>deserialization</b> and unsafe type-cast...|$|E
30|$|CIMverter {{uses the}} CIM++ Deserializer for <b>deserialization</b> of CIM objects from RDF/XML {{documents}} to C++ objects. Therefore, CIMverter {{also includes the}} adapted CIM C++ codebase, especially the headers for all CIM classes. Due to ongoing development of CIM and the concomitant automated modifications of these headers, one might suppose that the CIMverter development has {{to keep track of}} all CIM modifications but {{in the vast majority of}} cases a subsequent modification of CIMverter code is unneeded. This is because the continuous development of CIM mostly leads to new CIM classes with further relations or new attributes in existing classes. Such extensions of existing CIM classes require no changes on CIMverter code using them.|$|E
40|$|Large {{databases}} such as aflowlib. org {{provide valuable}} data sources for discovering material trends through machine learning. Although a REST API and query language are available, {{there is a}} learning curve associated with the AFLUX language {{that acts as a}} barrier for new users. Additionally, the data is stored using non-standard serialization formats. Here we present a high-level API that allows immediate access to the aflowlib data using standard python operators and language features. It provides an easy way to integrate aflowlib data with other python materials packages such as ase and quippy, and provides automatic <b>deserialization</b> into numpy arrays and python objects. This package is available via "pip install aflow". Comment: 7 pages, 3 code listing...|$|E
