196|695|Public
500|$|Encountering a MissingNo. Pokémon is {{the result}} of three {{computing}} events. The first is the game's random battle encounter system; each area assigns values to Pokémon in a <b>data</b> <b>buffer,</b> which the game accesses for the player's encounters with wild Pokémon. However, no values are assigned to this buffer on the east coast of the Cinnabar and Seafoam Island locations—the information from the previously visited area is used instead. The second factor is the in-game tutorial, which temporarily stores the player's name in the <b>data</b> <b>buffer.</b> This causes the game to access the hexadecimal values of the player's name for Pokémon encounters at Cinnabar and Seafoam Island. The third factor is the game's error handling system; if the game selects a value from the <b>data</b> <b>buffer</b> that is not an existing Pokémon, a subroutine is triggered that causes the appearance of a Pokémon named MissingNo., short for [...] "Missing Number".|$|E
5000|$|File: LCC Blast Door 1.png|LCC tunnel junctionFile: LCEB Blast Door.png|Launch Control Equipment Building Blast DoorFile: SAS Container.png|Sealed Authenticator System {{safe with}} two crew locksFile: Foxtrot LCC Artwork.png|Art work at Foxtrot-01 LCCFile: Hotel LCC Artwork.png|Art work at Hotel-01 LCCFile: Blast Door Pins.png|Blast Door PinsFile: Command <b>Data</b> <b>Buffer</b> {{configuration}}.png|Command <b>Data</b> <b>Buffer</b> configuration ...|$|E
5000|$|It {{requires}} two internal address A =0 {{for selecting}} <b>data</b> <b>buffer</b> and A = 1 for selecting control register of8279.|$|E
5000|$|Memory or <b>data</b> <b>buffers,</b> to hold packet data as {{it moves}} {{up and down the}} {{networking}} protocol stack ...|$|R
5000|$|<b>Data</b> <b>buffers</b> {{that are}} {{accessed}} directly by peripheral devices that use {{direct memory access}} or I/O channels must reside in pinned pages while the I/O operation is in progress because such devices and the buses {{to which they are}} attached expect to find <b>data</b> <b>buffers</b> located at physical memory addresses; regardless of whether the bus has a memory management unit for I/O, transfers cannot be stopped if a page fault occurs and then restarted when the page fault has been processed.|$|R
50|$|<b>Data</b> <b>buffers</b> {{are used}} for {{temporarily}} storing data while waiting for delayed packets to arrive. They are common in internet browser loading bars and video applications, like YouTube.|$|R
5000|$|GPU chipset: 3× Namco 02xx GFX Shifter (16-bit video shifter), 2× Namco 03xx Playfield <b>Data</b> <b>Buffer,</b> Namco 04xx Sprite Address Generator, Namco 09xx Sprite RAM Buffer ...|$|E
5000|$|Encountering a MissingNo. Pokémon is {{the result}} of three {{computing}} events. The first is the game's random battle encounter system; each area assigns values to Pokémon in a <b>data</b> <b>buffer,</b> which the game accesses for the player's encounters with wild Pokémon. However, no values are assigned to this buffer on the east coast of the Cinnabar and Seafoam Island locations—the information from the previously visited area is used instead. The second factor is the in-game tutorial, which temporarily stores the player's name in the <b>data</b> <b>buffer.</b> This causes the game to access the hexadecimal values of the player's name for Pokémon encounters at Cinnabar and Seafoam Island. The third factor is the game's error handling system; if the game selects a value from the <b>data</b> <b>buffer</b> that is not an existing Pokémon, a subroutine is triggered that causes the appearance of a Pokémon named MissingNo., short for [...] "Missing Number".|$|E
50|$|DAT+ and DAT- signals will be {{activated}} {{as soon as}} data {{is placed in the}} internal <b>data</b> <b>buffer</b> memory. DAT- goes positive and then activates the BSEL lines 3.5ms after the DAT lines are activated. The bus speed in DOLLx8 network is managed by the CLK signal and are currently set to 36kHz, which represents 14 milliseconds between each clock pulse. The bus clock is controlled by a positive BSEL- signal (BSEL + goes then simultaneously negative or low) and remains high {{as long as there is}} data in the <b>data</b> <b>buffer</b> memory. When data communication is completed and DAT receives HEX 0D 0A (CRLF) from the <b>data</b> <b>buffer</b> memory, the BSEL+ signal goes high again while BSEL signal goes low, which results in that the CLK signal ceases. The DOLLx8 system is then passively in standby or hibernation mode with minimal power consumption that leads to zero electromagnetic interference (EMI) in the network.|$|E
40|$|The turbo {{coprocessor}} (TCP) is a programmable peripheral for decoding IS 2000 / 3 GPP turbo codes, {{that are}} {{integrated into the}} Texas Instruments (TI) TMS 320 C 6416 digital signal processor. The TCP is controlled via memory-mapped control registers and <b>data</b> <b>buffers.</b> Control registers can be accessed directly by the CPU, whereas <b>data</b> <b>buffers</b> are typically accessed using the EDMA controller. This application report describes {{the relationship between the}} theory of turbo decoding and TCP implementation, outlines TCP programming procedures, and provides examples that demonstrate how to program TCPs for typica...|$|R
50|$|Shift registers, {{processor}} registers, <b>data</b> <b>buffers</b> {{and other}} small digital registers that have no memory address decoding mechanism are not considered as memory although they also store digital data.|$|R
50|$|Tuxedo {{middleware}} {{also uses}} OBBs to mention C and C++ arrays, or typed <b>data</b> <b>buffers.</b> This probably (input needed from experts) {{is the oldest}} reference to OBBs used in a computer system.|$|R
50|$|The {{benefits}} of a large <b>data</b> <b>buffer</b> are particularly evident in long distance applications, when operating at higher data rates (2Gbit/s, 4Gbit/s), or in systems with a heavily loaded PCI bus.|$|E
5000|$|For TCP connections, the {{operating}} system may have to retransmit the data given to it with a [...] call. However, the user space program is free to delete the <b>data</b> <b>buffer</b> passed to [...] after [...] returns. This implies that {{the operating}} system must make {{a copy of the}} data which can lead to a considerable CPU load in high throughput/performance applications. Other APIs, such as those supporting RDMA require that the <b>data</b> <b>buffer</b> is not released until the acknowledgement from the remote end has been received and thus make it possible to have zero memory copy operations.|$|E
50|$|Electronic skip {{protection}} is a <b>data</b> <b>buffer</b> system {{used in some}} portable compact disc (CD) players and all MiniDisc (MD) units so that audio would not skip while the disk could not be read due to movement.|$|E
50|$|Non-volatile memory {{does not}} support the Write command to row <b>data</b> <b>buffers.</b> Rather, a series of control {{registers}} in a special address region support Read and Write commands, which can be used to erase and program the memory array.|$|R
40|$|An {{automated}} {{accounting system}} useful for applying data {{to a computer}} from {{any or all of}} a multiplicity of data terminals is disclosed. The system essentially includes a preselected number of data terminals which are each adapted to convert data words of decimal form to another form, i. e., binary, usable with the computer. Each data terminal may {{take the form of a}} keyboard unit having a number of depressable buttons or switches corresponding to selected data digits and/or function digits. A bank of <b>data</b> <b>buffers,</b> one of which is associated with each data terminal, is provided as a temporary storage. Data from the terminals is applied to the <b>data</b> <b>buffers</b> on a digit by digit basis for transfer via a multiplexer to the computer...|$|R
40|$|A {{decoding}} {{method for}} coded data representing original data. Corrupted data is detected {{and replaced with}} <b>buffered</b> <b>data.</b> The <b>buffered</b> <b>data</b> is stored in the buffer a time interval corresponding to an estimated periodicity or an integer multiple thereof before the corrupted data was received. The estimated periodicity is determined by estimating the periodicity of the original data represented by the corrupted data...|$|R
50|$|ILCS was {{operational}} at most Minuteman II wings (except the 44th Missile Wing, {{which was}} never upgraded) {{by the late}} 1970s. Minuteman III wings had a similar install, designated Command <b>Data</b> <b>Buffer,</b> providing the newer system the potential for remote retarging.|$|E
50|$|In November 1975, {{the wing}} began an {{integrated}} improvement program {{that included a}} command <b>data</b> <b>buffer</b> and an improved launch control system. In 1985, the 341st SMW became the lead unit in the Minuteman Integrated Life Extension program (Rivet Mile).|$|E
50|$|A {{write buffer}} {{is a type}} of <b>data</b> <b>buffer</b> used in certain CPU cache {{architectures}} like Intel's x86 and AMD64. In multi-core systems, write buffers destroy sequential consistency. Some software disciplines, like C11's data-race-freedom, are sufficient to regain a sequentially consistent view of memory.|$|E
50|$|QEMM takes {{advantage}} of EMS memory and usually will create more free RAM in the lower 1M address space than the 64KB required for EMS. QEMM StealthROM, SqueezeFrame, and Stealth D*Space all require EMS to work by mapping ROM and <b>data</b> <b>buffers</b> into EMS, thus freeing more UMB's.|$|R
50|$|Some simple stack {{machines}} have a {{chip design}} which is fully customized {{all the way}} down to the level of individual registers. The top of stack address register and the N top of stack <b>data</b> <b>buffers</b> are built from separate individual register circuits, with separate adders and ad hoc connections.|$|R
50|$|Elements {{communicate}} {{by means of}} pads. A source pad on one element can be connected to a sink pad on another. When the pipeline is in the playing state, <b>data</b> <b>buffers</b> flow from the source pad to the sink pad. Pads negotiate the kind of data that will be sent using capabilities.|$|R
50|$|In {{computer}} science, a <b>data</b> <b>buffer</b> (or just buffer) is {{a region}} of a physical memory storage used to temporarily store data while it is being moved {{from one place to}} another. Typically, the data is stored in a buffer as it is retrieved from an input device (such as a microphone) or just before it is sent to an output device (such as speakers). However, a buffer may be used when moving data between processes within a computer. This is comparable to buffers in telecommunication. Buffers can be implemented in a fixed memory location in hardware—or by using a virtual <b>data</b> <b>buffer</b> in software, pointing at a location in the physical memory. In all cases, the data stored in a <b>data</b> <b>buffer</b> are stored on a physical storage medium. A majority of buffers are implemented in software, which typically use the faster RAM to store temporary data, due to the much faster access time compared with hard disk drives. Buffers are typically used when {{there is a difference between}} the rate at which data is received and the rate at which it can be processed, or in the case that these rates are variable, for example in a printer spooler or in online video streaming.|$|E
5000|$|Flow control: The rate of data {{transmission}} between two nodes must sometimes be managed {{to prevent a}} fast sender from transmitting more data than can be supported by the receiving <b>data</b> <b>buffer,</b> causing a buffer overrun. This {{can also be used}} to improve efficiency by reducing buffer underrun.|$|E
5000|$|... class tc_Text_Buffer {{definition}} for testing. [...] "#AU Risk_Level Harmless private section. methods set_Text_And_Get_Text for testing.endclass.class tc_Text_Buffer implementation. method set_Text_And_Get_Text. constants c_Hello_World type string value 'Hello World'. <b>data</b> <b>buffer</b> type ref to zcl_Text_Editor_Buffer. create object buffer. buffer->set_Text( [...] c_Hello_World [...] ). cl_Aunit_Assert=>assert_Equals( [...] act = buffer->text exp = c_Hello_World [...] ). endmethod.endclass.|$|E
50|$|In November 1972, SAC {{initiated}} the Minuteman Integrated Improvement Program. The program entailed silo hardening and upgrading command <b>data</b> <b>buffers,</b> which allowed for quicker missile retargeting. In addition to receiving upgraded silos and launcher control facilities, Warren also received new missiles, with the Minuteman I being replaced with LGM-30G Minuteman III between 1973-1975.|$|R
50|$|Store {{instructions}} {{result in}} <b>data</b> <b>buffered</b> in a 4-entry by 32-byte write buffer. The write buffer improved performance {{by reducing the}} number of writes on the system bus by merging data from adjacent stores and by temporarily delaying stores, enabling loads to be serviced quicker as the system bus is not utilized as often.|$|R
30|$|RBs {{are first}} {{allocated}} to the highest priority user till its target is met. If some RBs remain available, they are assigned to next highest priority user, and so on. Any degenerate cases, like <b>data</b> <b>buffers</b> or control resources running out are handled such {{that as many as}} possible number of RBs are assigned in each subframe.|$|R
50|$|In computing, {{the term}} bucket can have several meanings. It is used {{both as a}} live metaphor, and as a {{generally}} accepted technical term in some specialised areas. A bucket is most commonly a type of <b>data</b> <b>buffer</b> or a type of document in which data is divided into regions.|$|E
50|$|Any {{symbol that}} is not a marker byte is {{considered}} a literal byte, and will be copied as is to the decompressed <b>data</b> <b>buffer.</b> However, if the decoder encounters any of the four marker bytes, it will decode a length-distance pair that is used as a back reference into the previously decompressed data.|$|E
50|$|Modern {{disk storage}} {{does not need}} {{interleaving}} since the buffer space is now much larger. Data is now more commonly stored as clusters which are groups of sectors, and the <b>data</b> <b>buffer</b> is sufficiently large to allow all sectors in a block to be read at once without any delay between sectors.|$|E
50|$|The theory behind CoDel {{is based}} on {{observations}} of packet behavior in packet-switched networks {{under the influence of}} <b>data</b> <b>buffers.</b> Some of these observations are about the fundamental nature of queueing and the causes of bufferbloat, others relate to weaknesses of alternative queue management algorithms. CoDel was developed as an attempt {{to address the problem of}} bufferbloat.|$|R
30|$|Note {{that there}} is no need to {{introduce}} a slack variable for the relay node. This follows from the fact that the source nodes can adjust their rates so as not to transmit more data than the relay can store. Therefore, the slack variable for the source nodes d_j,i^(n) effectively covers the impact of the finite <b>data</b> <b>buffers</b> at the relay as well.|$|R
5000|$|Node.js {{allows the}} {{creation}} of Web servers and networking tools using JavaScript {{and a collection of}} [...] "modules" [...] that handle various core functionality. Modules are provided for file system I/O, networking (DNS, HTTP, TCP, TLS/SSL, or UDP), binary <b>data</b> (<b>buffers),</b> cryptography functions, <b>data</b> streams and other core functions. Node.js's modules use an API designed to reduce the complexity of writing server applications.|$|R
