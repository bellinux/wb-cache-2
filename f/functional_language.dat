2050|4189|Public
5|$|Prus' novel The Doll, {{with its}} rich {{realistic}} detail and simple, <b>functional</b> <b>language,</b> was considered by Czesław Miłosz {{to be the}} great Polish novel.|$|E
25|$|A {{library for}} the <b>functional</b> <b>language</b> OCaml {{was written in}} {{assembly}} language and C.|$|E
25|$|Hume, {{a strict}} <b>functional</b> <b>language</b> for {{embedded}} systems based on processes as stateless automata over {{a sort of}} tuples of one element mailbox channels where the state is kept by feedback into the mailboxes, and a mapping description from outputs to channels as box wiring, with a Haskell-like expression language and syntax.|$|E
50|$|Dana Scott's LCF {{language}} was {{a stage in}} the evolution of lambda calculus into modern <b>functional</b> <b>languages.</b> This language introduced the let expression, which has appeared in most <b>functional</b> <b>languages</b> since that time.|$|R
40|$|One of {{the factors}} {{hindering}} the use of <b>functional</b> <b>languages</b> has been their relatively poor performance in comparison to more traditional languages such as C and Pascal. During the last decade tremendous {{progress has been made}} in building implementations of <b>functional</b> <b>languages</b> but the approaches adopted have employed specialist hardware andlor compiler optimisations that have been developed specifically for <b>functional</b> <b>languages.</b> Building specialist hardware may be the best long-term solution but in the short run it is possible to increase the use and acceptance of <b>functional</b> <b>languages</b> by exploiting the performance of commercially available machines. The goal of the project described in this paper has been to design an optimising compiler that produces fast code for <b>functional</b> <b>languages</b> on conventional sequential and parallel machines...|$|R
50|$|The usual {{implementation}} strategy for lazy evaluation in <b>functional</b> <b>languages</b> is graph reduction. Lazy evaluation {{is used by}} default in several pure <b>functional</b> <b>languages,</b> including Miranda, Clean, and Haskell.|$|R
25|$|Haskell {{features}} lazy evaluation, pattern matching, list comprehension, type {{classes and}} type polymorphism. It is a purely <b>functional</b> <b>language,</b> {{which means that}} functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal {{to the type of}} functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages.|$|E
2500|$|Epigram, a <b>functional</b> <b>language</b> with {{dependent}} types suitable for proving properties of programs ...|$|E
2500|$|Idris, {{a general}} purpose <b>functional</b> <b>language</b> with {{dependent}} types, {{developed at the}} University of St Andrews ...|$|E
40|$|In {{efforts to}} {{overcome}} {{the complexity of the}} syntax and the lack of formal semantics in conventional hardware description languages (most notably Verilog and VHDL), a number of approaches based on <b>functional</b> <b>languages</b> have been proposed. The merits of <b>functional</b> <b>languages</b> as hardware description languages {{can be attributed to the}} fact that basic building blocks for hardware circuits are equivalent to mathematical functions while <b>functional</b> <b>languages</b> lend themselves to creating and composing mathematical functions. <b>Functional</b> hardware description <b>languages</b> are typically embedded into existing <b>functional</b> <b>languages</b> such as Haskell and ML, or into new <b>functional</b> <b>languages</b> designed specifically for hardware design such as reFL ect. Since its semantics is unaware of hardware circuits, a host language represents hardware circuits as a special datatype. Eventually we convert such a datatype into netlists which describe connections in hardware circuits at the lowest level. Converting a datatype representing hardware circuits into netlists is certainly a necessary step, but makes it an unnecessarily low level task to prove propertie...|$|R
50|$|There {{do exist}} a few esoteric <b>functional</b> <b>languages</b> (like Unlambda) that eschew {{structured}} programming precepts {{for the sake}} of being difficult to program in (and therefore challenging). These languages are the exception to the common ground between procedural and <b>functional</b> <b>languages.</b>|$|R
50|$|In {{mathematics}} a variable's value may not change. This {{is fundamental}} to the mathematical approach. <b>Functional</b> <b>languages</b> based on lambda calculus allow this mathematical approach to programming. <b>Functional</b> <b>languages</b> developed by implementing lazy evaluation, and allowing functions to be passed as parameters.|$|R
2500|$|The Haskell {{programming}} {{language is a}} <b>functional</b> <b>language</b> that makes heavy use of monads, and includes syntactic sugar to make monadic composition more convenient. [...] All of the code samples {{in this article are}} written in Haskell unless noted otherwise.|$|E
2500|$|The 1980s saw a {{rapid growth}} in {{interest}} in object-oriented programming. These languages were imperative in style, but added features to support objects. The last two decades of the 20th century saw the development of many such languages. Smalltalk-80, originally conceived by Alan Kay in 1969, was released in 1980, by the Xerox Palo Alto Research Center (PARC). Drawing from concepts in another object-oriented language—Simula (which is considered the world's first object-oriented programming language, developed in the 1960s)—Bjarne Stroustrup designed C++, an object-oriented language based on C. Design of C++ began in 1979 and the first implementation was completed in 1983. In the late 1980s and 1990s, the notable imperative languages drawing on object-oriented concepts were Perl, released by Larry Wall in 1987; Python, released by Guido van Rossum in 1990; Visual Basic and Visual C++ (which included Microsoft Foundation Class Library (MFC) 2.0), released by Microsoft in 1991 and 1993 respectively; PHP, released by Rasmus Lerdorf in 1994; Java, released by Sun Microsystems in 1994, JavaScript, by Brendan Eich (Netscape), and Ruby, by Yukihiro [...] "Matz" [...] Matsumoto, both released in 1995. Microsoft's [...]NET Framework (2002) is imperative at its core, as are its main target languages, VB.NET and C# that run on it; however Microsoft's F#, a <b>functional</b> <b>language,</b> also runs on it.|$|E
5000|$|O'Haskell, an {{object-oriented}} {{extension to}} the <b>functional</b> <b>language</b> Haskell ...|$|E
50|$|<b>Functional</b> <b>languages</b> such as Lisp and Haskell.|$|R
40|$|<b>Functional</b> logic <b>languages</b> are {{declarative}} programming languages that {{integrate the}} programming paradigms of <b>functional</b> and logic <b>languages</b> {{within a single}} framework. They are extensions of <b>functional</b> <b>languages</b> with principles derived from logic programming. Narrowing, the evaluation mechanism of <b>functional</b> logic <b>languages,</b> {{can be defined as}} a generalization of reduction, the evaluation mechanism of purely <b>functional</b> <b>languages.</b> The unidirectional pattern matching, which is used for parameter passing in <b>functional</b> <b>languages,</b> is simply replaced by the bidirectional unification known from logic programming languages. We show in this paper, how to extend a reduction machine, that has been designed for the evaluation of purely functional programs to a machine that performs narrowing. The necessary extensions concern the realization of unification and backtracking, for which we fall back upon the methods of Warren's Prolog engine [Warren 83]. The narrowing machine embodies an optimized trea [...] ...|$|R
50|$|Many <b>{{functional}}</b> <b>languages,</b> however, {{are in fact}} impurely {{functional and}} offer imperative/procedural constructs that allow the programmer to write programs in procedural style, or in {{a combination of both}} styles. It is common for input/output code in <b>functional</b> <b>languages</b> to be written in a procedural style.|$|R
50|$|PLaSM {{sources are}} {{publicly}} available at GitHub.(original <b>functional</b> <b>language</b> approach).|$|E
5000|$|Elm (programming language), a compile-to-JavaScript <b>functional</b> <b>language</b> with static typing ...|$|E
5000|$|Concurrent Haskell—lazy, pure <b>functional</b> <b>language</b> {{operating}} {{concurrent processes}} on shared memory ...|$|E
5000|$|... #Subtitle level 3: Multiple {{parameters}} in <b>functional</b> <b>languages</b> ...|$|R
50|$|Uniqueness {{types are}} {{implemented}} in the <b>functional</b> programming <b>languages</b> Clean, Mercury and Idris. They are sometimes used for doing I/O operations in <b>functional</b> <b>languages</b> in lieu of monads.|$|R
40|$|A fully {{abstract}} {{model of a}} programming language assigns the same meaning to two terms {{if and only if}} they have the same operational behavior. Such models are well-known for <b>functional</b> <b>languages</b> but little is known about extended <b>functional</b> <b>languages</b> with sophisticated control structures. We show that a direct model with error values and the conventional continuation model are adequate for <b>functional</b> <b>languages</b> augmented with first- and higher-order control facilities, respectively. Furthermore, both models become fully abstract on adding a control delimiter and a parallel conditional to the programming languages...|$|R
5000|$|Epigram, a <b>functional</b> <b>language</b> with {{dependent}} types suitable for proving properties of programs ...|$|E
5000|$|In 1977, Gordon Plotkin {{introduces}} Programming Computable Functions, {{an abstract}} typed <b>functional</b> <b>language.</b>|$|E
50|$|A {{library for}} the <b>functional</b> <b>language</b> OCaml {{was written in}} {{assembly}} language and C.|$|E
40|$|<b>Functional</b> <b>languages</b> {{potentially}} oer {{benefits for}} distributed fault tolerance: many computations are pure, and hence have no side-effects to be reversed during error recovery; moreover <b>functional</b> <b>languages</b> have a high-level runtime system (RTS) where computations and data are readily manipulated. We propose a new RTS level of fault tolerance for distributed <b>functional</b> <b>languages,</b> and outline a design for its implementation for the GdH language. The design distinguishes between pure and impure computations: impure computations must be recovered using conventional exception-based techniques, but the RTS attempts implicit recovery of pure computations...|$|R
40|$|This paper {{explores the}} {{practical}} potential for enhancing code reuse in <b>functional</b> <b>languages</b> by leveraging techniques and experiences from object-oriented programming. Since data types in typed <b>functional</b> <b>languages</b> {{do not support}} adding new variants, programming techniques derived from the object-oriented Visitor pattern can be readily applied to recursive functions on trees in <b>functional</b> <b>languages.</b> Specifically, we demonstrate how to define recursive functions on trees {{in such a way}} that they can be extended without modification through an inheritance-like mechanism. Furthermore, we demonstrate how the extensions themselves can be made highly reusable through a mechanism akin to mixin-based inheritance, which allows an extension to be applied to any suitable recursive function. These mechanisms combine well with the usual higher-order approach to reuse in <b>functional</b> <b>languages.</b> Although general encodings of inheritance in <b>functional</b> <b>languages</b> are not novel, such encodings lead to a particularly simple and elegant presentation when limited to recursive functions on trees. Because of their simplicity, we believe that these techniques have the potential to enhance code reuse in the practice of functional programming without requiring additional tool support...|$|R
5000|$|IFL: International Symposia on Implementation and Application of <b>Functional</b> <b>Languages</b> ...|$|R
5000|$|Elm, a <b>functional</b> <b>language</b> {{to create}} web {{front-end}} apps, no support for higher-kinded types ...|$|E
5000|$|To parse it {{and search}} for a <b>functional</b> <b>language,</b> Groovy's [...] method can serve: ...|$|E
50|$|Extensions {{that allow}} users {{to create new}} {{functions}} can provide the capabilities of a <b>functional</b> <b>language.</b>|$|E
5000|$|... #Subtitle level 2: Integration with JavaScript {{generated}} from <b>functional</b> <b>languages</b> ...|$|R
40|$|With {{interest}} in parallel implementations of <b>functional</b> <b>languages</b> as a whole, we first discuss some {{issues related to}} parallel execution of functional programs, and then review some key proposals considering three differents approaches, namely Parallel lisp Systems, Dataflow Systems and Reduction Systems. 1. Introduction <b>Functional</b> programming <b>languages</b> have received a special attention since the famous Backus' Turing Award lecture [Bac 78], when Backus stated the advantages of <b>functional</b> programming <b>languages</b> over traditional imperative ones. During the last decade, {{a number of researchers}} have been attempted to put these ideas into practice by proposing different implementations of <b>functional</b> <b>languages.</b> Substantial progress has been obtained for the sequential implementations of <b>functional</b> <b>languages</b> [Aug 84, Joh 84, Kranz 86], however the parallel implementations still do not present big advantages as it was expected theoretically. 2. Some issues related to parallelism Every pure functio [...] ...|$|R
25|$|Following {{the release}} of Miranda by Research Software Ltd, in 1985, {{interest}} in lazy <b>functional</b> <b>languages</b> grew. By 1987, {{more than a dozen}} non-strict, purely <b>functional</b> programming <b>languages</b> existed. Miranda was the most widely used, but it was proprietary software. At the conference on <b>Functional</b> Programming <b>Languages</b> and Computer Architecture (FPCA '87) in Portland, Oregon, there was a strong consensus that a committee be formed to define an open standard for such languages. The committee's purpose was to consolidate existing <b>functional</b> <b>languages</b> into a common one to serve as a basis for future research in functional-language design.|$|R
