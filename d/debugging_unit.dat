2|19|Public
50|$|Komodo IDE has an {{open-source}} counterpart called Komodo Edit. Both share much of {{the same}} code base, Komodo IDE containing the more advanced IDE features such as <b>debugging,</b> <b>unit</b> testing, etc.|$|E
40|$|Abstract: This paper {{presents}} a survey on Importance of Secondary Memory management in Wireless Sensor Network (WSN) Operating Systems (OSs). Sensor nodes {{may also have}} a storage unit or <b>debugging</b> <b>unit.</b> The storage unit is an external memory device that works as a secondary memory, keeping a data log from an energy perspective. In recent years, WSNs have received tremendous attention in the research community, with applications in battlefields, industrial process monitoring, home automation, and environmental monitoring. A WSN is a huge dynamic network in this aspect a severe environmental circumstances and low power of battery nodes might be die. Furthermore, a WSN is composed of limited memory and computational abilities. WSNs invariably operate in an unattended mode and in many scenarios {{it is impossible to}} replace sensor nodes after deployment, therefore a fundamental objective is to optimize the sensor nodes life time. These characteristics of WSNs impose additional challenges on OS design for WSN, and consequently, OS design for WSN deviates from traditional OS design. The purpose of this survey is to highlight major concerns pertaining to OS design in WSNs and to point out strengths an...|$|E
40|$|The <b>debug</b> <b>unit</b> of {{a modern}} digital system on chip (SoC) is a {{critical}} unit that allows users to monitor and analyze the chip’s activity that occurs throughout a SoC design. Selection of the <b>debug</b> <b>unit’s</b> correct feature set and architecture are {{critical to the success}} of the design. Debugging systems that exist have different architectures and are closely coupled to their host SoCs. As a consequence they are resource intensive to improve on due to the different nature of each SoC designs. Moreover, the bus protocols that allow the <b>debug</b> <b>unit</b> to interact with the SoC design are often designed towards the SoC design itself and are not easily extensible. This project serves to analyze existing <b>debug</b> <b>units</b> in the public domain and classify their feature sets, architectures, speed and size vs. the developed modular <b>debug</b> <b>unit.</b> Hardware description languages now enable new forms of modular designs which allow the possibility of building a modular debugging core. This allows for integration with arbitrary on chip bus systems and actual CPU processor cores. A hierarchical finite state machine (HFSM) design approach also enables the <b>debug</b> <b>unit</b> to be extended with debugging features. The size and speed of synthesized designs targeting field programmable gate array (FPGA) technology are compared, and preliminary results show that the a modular design approach <b>debug</b> <b>unit</b> is able to significantly reduce development time and be extended with new features. Future work will be carried out to build on preliminary results obtained from a modular <b>debug</b> <b>unit...</b>|$|R
5000|$|... #Caption: Debugging {{on video}} game {{consoles}} is usually done with special hardware {{such as this}} Xbox <b>debug</b> <b>unit</b> intended for developers.|$|R
5000|$|Easy entry level, in-circuit {{programming}} plus in-circuit <b>debugging</b> PICkit <b>units</b> {{available for}} less than $50 ...|$|R
40|$|This thesis {{describes}} {{the implementation of}} a central processing unit with pipeline called Hypothetical processor (HIP), which is described in book [1]. It contains logic for data forwarding, an adder for floating point numbers and it has an instruction and data cache. Through the <b>debug</b> <b>unit</b> it is possible to read from and write to all general and to other registers in the HIP pipeline and therefore monitor the flow of the compiled program. HIP runs in the FPGA chip on the Spartan 3 E development board where supporting logic for monitoring is present. The external program written in Java runs on different operating systems. The monitoring program contains a text editor where it is possible to write in the assembler language. It also contains a compiler which translates an assembler code to HIP machine code. Operations and data are sent to the <b>debug</b> <b>unit</b> to HIP. Each clock cycle, the monitoring program reads the content of every register in the CPU. The content of the main memory and cache is seen too...|$|R
40|$|Abstract—As {{complexity}} {{and size of}} Systems-on-Chip (SoC) grow, debugging becomes a bottleneck for designing IC products. In this paper, we present an approach for online debug of NoC-based multiprocessor SoCs. Our approach utilizes monitors and filters implemented in hardware. Monitors and filters observe and filter transactions at run-time. They are connected to a <b>Debug</b> <b>Unit</b> (DU). Transaction-based programmable Finite State Machines (FSMs) in the DU check assertions online to validate the correct relation of transactions at run-time. The experimental results show efficiency and performance of our approach. Keywords—transaction-based online debug, system-on-chip (SoC), network-on-chip (NoC) I...|$|R
50|$|The IP {{core of the}} OR1200 is {{implemented}} in the Verilog HDL. As an open source core, the design is fully public and may be downloaded and modified by any individual. The official implementation is maintained by developers at OpenCores.org. The implementation specifies a power management <b>unit,</b> <b>debug</b> <b>unit,</b> tick timer, programmable interrupt controller (PIC), central processing unit (CPU), and memory management hardware. Peripheral systems and a memory subsystem may be added using the processor's implementation of a standardized 32-bit Wishbone bus interface. The OR1200 is intended to have a performance comparable to an ARM10 processor architecture.|$|R
40|$|Domain-specific {{languages}} (DSLs) assist {{a software}} developer (or end-user) in writing a program using idioms {{that are similar}} to the abstractions found in a specific problem domain. Testing tool support for DSLs is lacking when compared to the capabilities provided for standard general-purpose languages (GPLs), such as Java and C++. For example, support for <b>debugging</b> and <b>unit</b> testing a program written in a DSL is often non-existent. The lack of a debugger and unit test engine at the proper abstraction level limits an end-user‟s ability to discover and locate faults in a DSL program. This dissertation describes a grammar-driven technique to build a <b>debugging</b> and <b>unit</b> testing tool generation framework by adaptations to existing DSL grammars. This approach leverages existing GPL testing tools to indirectly exercise the end-user‟s debug and test intentions at the DSL level. The adaptations to DSL grammars represent the hooks needed to interface with a supporting infrastructure constructed for an Integrated Development Environment (IDE) that assists in <b>debugging</b> and <b>unit</b> testing a program written in a DSL. The contribution represents a coordinated approach to bring essentia...|$|R
5000|$|On May 2, 2003 a Translucent Green Limited Edition Xbox(rare) was {{released}} in Europe to celebrate Xbox's one-year European birthday. The console came with two matching Controller S and retailed for €229/£149. It had a limited manufacture of 20,000 units but only sold 5,000 units(in Europe). The styling of the Translucent Green Xbox is identical to <b>Debug</b> <b>Units</b> used in game development; of course, the retail versions lacked the words [...] "Debug Kit" [...] {{on the front of}} the case. The green Controller S was also sold separately. The Translucent Green Limited Edition Xbox was also released in Canada and came with one matching Controller S and two games, Crimson Skies and Project Gotham Racing 2.|$|R
50|$|Priced {{at around}} $750 USD, the Net Yaroze (DTL-H300x) package {{contained}} a special black-colored <b>debugging</b> PlayStation <b>unit</b> with documentation, software, and no regional lockout. The user has {{to provide a}} personal computer (IBM-PC or Macintosh; NEC PC-9801 was also supported in Japan) to write the computer code, compile it, and send the program to the PlayStation.|$|R
40|$|Abstract—In {{multi-core}} designs, distributed embedded logic an-alyzers {{with multiple}} trigger units and trace buffers with real-time offload capability through high-speed trace ports {{can be placed}} on-chip. This brings new challenges on how to connect the <b>debug</b> <b>units</b> together in such way that the limited storage space in the trace buffers can be used efficiently. This problem is further ag-gravated when shadow registers are used to capture data for some signals in the design. In this paper, we propose a new architecture that can dynamically allocate the trace buffers at runtime based on the needs for debug data acquisition coming from multiple data sources and user-programmable priorities. Experimental results show that using the proposed architecture, real-time observability can be improved using {{only a small amount}} of on-chip logic hard-ware, while avoiding excessive storage on-chip. Index Terms—Design-for-debug, distributed embedded logic analysis, post-silicon validation, real-time observability. I...|$|R
5000|$|Integrated {{development}} environments (IDE) add further functionality, such as <b>debugging,</b> refactoring, <b>unit</b> testing, etc. As with plain editors, IDEs {{with support}} for Python can be beneficial. Some IDEs that are specialized on Python additionally have integrated support for Django projects, so that using such an IDE when developing a Django project can help further increase productivity. For comparison of such Python IDEs, see the main article: ...|$|R
5000|$|There {{were also}} {{debugging}} consoles - these were generally in either {{blue or green}} cases, although there were some special production units (mostly intended for use as show demo units) that were grey, {{the same as the}} retail consoles. The <b>debug</b> <b>units</b> were designed to be {{as close as possible to}} retail consoles, so they only had 2MB of ram (the developer boards had 8MB) and had standard retail boot ROMs. The only real difference is that the CD controller was reprogrammed so that it would identify any disc that had a data track as being [...] "licensed", rather than requiring the region code in the lead-in that was present on pressed PlayStation CDs. This was done to allow developers to burn games to CD-R for testing - a side effect of this was that most debug consoles would also boot discs from other regions (one notable exception being the later NTSC:J debugs, which only boot Japanese titles), although this was not officially supported - Sony made specific debug consoles for each region, and the technical required checklist provided by Sony for each region required you to test your title on the correct debug stations.|$|R
40|$|Seaside is {{the open}} source {{framework}} {{of choice for}} developing sophisticated and dynamic web applications. Seaside uses the power of objects to master the web. With Seaside web applications {{is as simple as}} building desktop applications. Seaside lets you build highly dynamic and interactive web applications. Seaside supports agile development through interactive <b>debugging</b> and <b>unit</b> testing. Seaside is based on Smalltalk, a proven and robust language implemented by different vendors. Seaside is now available for all the major Smalltalk including Pharo, Squeak, GNU Smalltalk, Cincom Smalltalk, GemStone Smalltalk, and VA Smalltalk...|$|R
40|$|This thesis {{describes}} {{the design and}} implementation of an FPGA-based hardware platform based on the rVEX VLIW softcore and the adaption of a Linux 2. 0 no_mmu kernel to run on that platform. The rVEX is a runtime reconfigurable VLIW softcore processor. It supports various configurations that allow programs to run faster or more efficient. The rVEX core can switch between different configurations while it is running. Reconfigurations are typically performed by a software program that is running on a different processor. We discuss the concept of using an Operating System, running on the core itself, that monitors the execution of its tasks and orchestrates core reconfigurations during task switches. In addition to using statically found optimal configurations, performance counters could {{be added to the}} core that measure how efficient a program is running on the current core configuration. The OS could use that data to evaluate if another configuration would be beneficial. The implementation of the hardware platform and the porting of the Linux kernel represent the first steps in working towards that final goal. To support our Linux port, a vectored trap controller has been designed. Additionally, a debugging environment has been created by designing a hardware <b>debug</b> <b>unit,</b> implementing an RSP server program and adding rVEX support to the GNU debugger (GDB). CESCTElectrical Engineering, Mathematics and Computer Scienc...|$|R
40|$|Approved {{for public}} release; {{distribution}} is unlimitedThe {{purpose of this}} thesis is to explicate {{the benefits of the}} computer visual interface by identifying the functional capabilities of some of the visual devices made possible by such an interface, and by examining the ways in which these visual devices can provide tools to aid the programmer in writing, <b>debugging,</b> and <b>unit</b> testing application programs, and the user in learning and using applications. This thesis should give the reader some insight into how current visual technology is being used (or can be used in the future) to aid the applications programmer and application user. The focus will primarily be on the programmers and users of applications for low-cost desktop computers. [URL] United States Nav...|$|R
40|$|More {{and more}} {{companies}} are opting for informatisation of field operations. Regardless {{of the outcome}} of the integration, looking from a business perspective, all mobile applications technically face the problem of safe access to the central database without communication failures. In this thesis, I have explained and implemented synchronization of various data sources, through which the end-users can transfer a subset of centralized data to their mobile devices. Enriched information from the field is later, again by means of synchronization, transferred back to the central database. Synchronization between the consuming devices and server is implemented via WCF service. Mock solution is implemented using Microsoft Sync Framework with MS SQL Server 2008 R 2 and MS SQL Server CE 3. 5 acting as server and client database back-ends respectively. Stored procedures, which are used during the synchronization process, are explained in detail. Since this work is based on a real-life project, it also includes information on security, <b>debugging</b> and <b>unit</b> testing...|$|R
40|$|Abstract- A {{hundred years}} ago, people faced problem {{in using the}} new {{typewriters}} [...] . Typing was error prone [...] . Correcting a character, even a word, {{might not be so}} bad. Correcting a missed sentence, early on the typed page, was better fixed by starting the page over. With this background for almost a human generation of using typewriters, the new idea of touch-typing, typing without looking at the keys, was a very strange one. “That’s silly. Who could possibly do that? ” [...] . Of course, we know how touch-typing turned out as an internationally useful method [...] . But we also know that very few key-looking typists learned how to touch type. It was the young generation coming into the field. There is a lesson in touch typing for software development. In software, teaching a programming language and how to compile and execute programs allows people to write programs immediately. Very likely, such programs will require considerable debugging [...] . errors and <b>unit</b> <b>debugging</b> are just an expected and integral part of programming. However, people with the right education and training need not <b>unit</b> <b>debug</b> their software any more than people {{need to look at the}} keys when they type [...] . Yet, just as in touch-typing, serious programming begins only with formal methods, more explicit design, and verification from specifications. [1]...|$|R
40|$|In {{previous}} work {{we have developed}} a system that automatically checks for unit errors in spreadsheets. In this paper we describe our experiences using the system in a workshop on spreadsheet safety aimed at high school teachers and students. We present the results from a think-aloud study we conducted with five high school teachers and one high school student as the subjects. The study is the first ever to investigate the usability of a type system in spreadsheets. We discovered that end users can effectively use the system to debug a variety of errors in their spreadsheets. This result is encouraging given that type systems are difficult even for programmers. The subjects had difficulty <b>debugging</b> “non-local” <b>unit</b> errors. Guided {{by the results of}} the study we devised new methods to improve the errorlocation inference. We also extended the system to generate change suggestions for cells with unit errors, which when applied, would correct unit errors. These extensions solved the problem that the study revealed in the original system...|$|R
40|$|Wireless sensor networks, {{which are}} {{becoming}} increasingly more commonly used, had been difficult to write programs for due to the inability to effectively perform many different tasks that were common on other development platforms, such as <b>debugging</b> and <b>unit</b> testing. In order to solve this problem, Kamin Whitehouse and his co-authors developed Marionette, a development framework which uses remote procedure calls (RPCs) simplifies wireless sensor network development in many ways. Marionette allows a programmer to call functions and manipulate variables on nodes from a PC. I {{became involved in the}} project when I approached Professor Whitehouse and asked if I could perform research under him. He suggested that I work on improving Marionette; a conference paper had already been published on it, but much time had passed and the framework had not been updated. In addition, we were interested in undertaking enough new research to warrant publishing a journal article through expansion of the original conference paper. I first updated Marionette to function with the new version of TinyOS, the operating system running on the sensor nodes that Marionette is targeting. This work greatly increased the number of applications that could utilize Marionette by making it much more viable. After that...|$|R

