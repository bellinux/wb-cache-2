266|5|Public
25|$|A {{conditional}} {{using an}} <b>if-then-else</b> syntax {{was invented by}} McCarthy in a Fortran context. He proposed its inclusion in ALGOL, {{but it was not}} made part of the Algol 58 specification. For Lisp, McCarthy used the more general cond-structure. Algol 60 took up <b>if-then-else</b> and popularized it.|$|E
25|$|A common {{example of}} {{ambiguity}} in computer programming languages is the dangling else problem. In many languages, the else in an <b>If–then(–else)</b> statement is optional, {{which results in}} nested conditionals having multiple ways of being recognized {{in terms of the}} context-free grammar.|$|E
25|$|In {{sequential}} code it {{is possible}} to control the flow of the program using <b>if-then-else</b> statements and various forms of loops. Such flow control structures have only recently been added to GPUs. Conditional writes could be performed using a properly crafted series of arithmetic/bit operations, but looping and conditional branching were not possible.|$|E
40|$|Exceptions {{historically}} {{derive from}} a single-threaded, imperative model of computation. Rather than including tests {{for the success}} of subsidiary operations at every procedure level using <b>if-then-else's,</b> it was deemed simpler to describe problems only where they arise and where they are dealt with. The catch-throw style was transferred to C++ (and then Java), and also grafted onto the I/O structures of declarative languages such as Prolog and Haskell. However, the evolution from object-oriented to eventoriented programming and the blending of this with a declarative base has led to a rather different view of computation, one which raises new questions about the relationships among events, exceptions and interrupts. This paper looks at some of these. ...|$|R
40|$|Abstract. For any LP system, tabling can {{be quite}} handy {{in a variety of}} tasks, {{especially}} if it is efficiently implemented and fully integrated in the language. Implementing tabling in Mercury poses special challenges for several reasons. First, Mercury is both semantically and culturally quite different from Prolog. While decreeing that tabled predicates must not include cuts is acceptable in a Prolog system, it is not acceptable in Mercury, since <b>if-then-elses</b> and existential quantification have sound semantics for stratified programs and are used very frequently both by programmers and by the compiler. The Mercury implementation thus has no option but to handle interactions of tabling with Mercury’s language features safely. Second, the Mercury implementation is vastly different from the WAM, and many of the differences (e. g. the absence of a trail) have significant impact on the implementation of tabling. In this paper, we describe how we adapted the copying approach to tabling to implement tabling in Mercury. ...|$|R
40|$|Abstract. Prolog {{systems such}} as XSB have proven that tabling can be quite helpful {{in a variety of}} tasks, {{especially}} if it is efficiently implemented and fully integrated in the language. Implementing tabling in Mercury poses special challenges for several reasons. First, Mercury is both semantically and culturally quite different from Prolog. While decreeing that tabled predicates must not include cuts (or Prolog-style negations) is acceptable in a Prolog system, it is not acceptable in Mercury, since <b>if-then-elses</b> and existential quantification have sound semantics and are used very frequently both by programmers and by the compiler. The Mercury implementation thus has no option but to handle interactions of tabling with Mercury’s language features safely. Second, the Mercury implementation is vastly different from the WAM, and many of the differences (e. g. storing values directly in stack slots without indirection, the absence of a trail) have significant impact on the implementation of tabling. In this paper, we describe how we adapted the copying approach to tabling to implement minimal model tabling in Mercury. ...|$|R
25|$|Some syntax issues (changes in {{the formal}} grammar) were fixed: pattern guards were added, {{allowing}} pattern matching within guards; resolution of operator fixity was specified in a simpler way that reflected actual practice; an edge case in {{the interaction of the}} language's lexical syntax of operators and comments was addressed; and the interaction of do-notation and <b>if-then-else</b> was tweaked to eliminate unexpected syntax errors.|$|E
25|$|The Monroe Epic {{programmable}} calculator {{came on the}} market in 1967. A large, printing, desk-top unit, with an attached floor-standing logic tower, it could be programmed to perform many computer-like functions. However, the only branch instruction was an implied unconditional branch (GOTO) {{at the end of the}} operation stack, returning the program to its starting instruction. Thus, it was not possible to include any conditional branch (<b>IF-THEN-ELSE)</b> logic. During this era, the absence of the conditional branch was sometimes used to distinguish a {{programmable calculator}} from a computer.|$|E
2500|$|Concretely, in many {{languages}} one may write conditionals in two valid forms: the if-then form, and the <b>if-then-else</b> form – in effect, {{making the}} else clause optional: ...|$|E
40|$|Abstract For any LP system, tabling can {{be quite}} handy {{in a variety of}} tasks, {{especially}} if it is efficiently implemented andfully integrated in the language. Implementing tabling in Mercury poses special challenges for several reasons. First, Mercury is both semantically and culturally quite different from Prolog. While decreeing that tabled predicates mustnot include cuts is acceptable in a Prolog system, it is not acceptable in Mercury, since <b>if-then-elses</b> and existential quantification have sound semantics for stratified programs and are used very frequently both by programmers andby the compiler. The Mercury implementation thus has no option but to handle interactions of tabling with Mercury's language features safely. Second, the Mercury implementation is vastly different from the WAM, and many of thedifferences (e. g. the absence of a trail) have significant impact on the implementation of tabling. In this paper, we describe how we adapted the copying approach to tabling to implement minimal model tabling in Mercury. 1 Introduction By now, it is widely recognized that tabling adds power to a logic programming system. By avoiding repeated sub-computations, it often significantly improves the performance of applications, and by terminating more often it allows for a more natural and declarative style of programming. As a result, many LP systems (e. g., XSB, Yap, B-Prolog,and TALS) nowadays offer some form of tabling. When deciding which tabling mechanism to adopt, an implementor is faced with various choices. The first con-cerns the tabling strategy to adopt. Tabled resolution strategies such as OLDT [9] and SLG [1] are guaranteed to avoid recomputation, but their implementation is challenging because they require the introduction of a suspen-sion/resumption mechanism into the basic execution engine...|$|R
2500|$|This {{definition}} of a formula does not support defining an <b>if-then-else</b> function ite(c, a, b), where [...] "c" [...] is a condition expressed as a formula, that would return [...] "a" [...] if c is true, and [...] "b" [...] if it is false. This is because both predicates and functions can only accept terms as parameters, but the first parameter is a formula. [...] Some languages built on first-order logic, such as SMT-LIB 2.0, add this.|$|E
2500|$|The {{unbounded}} μ operator {{is defined}} by Minsky (1967) p.210 but with a peculiar flaw: the operator will not yield t = 0 when its predicate (the <b>IF-THEN-ELSE</b> test) is satisfied; rather, it yields t=2. In Minsky's version the counter is [...] "t", and the function φ( [...] t, x [...] ) deposits its number in register φ. In the usual μ definition register w will contain 0, but Minsky observes that it can contain any number k. Minsky's instruction set {{is equivalent to the}} following where [...] "JNE" [...] = Jump to z if Not Equal: ...|$|E
2500|$|Canonical {{flowchart}} symbols: The graphical aide {{called a}} flowchart offers {{a way to}} describe and document an algorithm (and a computer program of one). Like program flow of a Minsky machine, a flowchart always starts {{at the top of}} a page and proceeds down. Its primary symbols are only four: the directed arrow showing program flow, the rectangle (SEQUENCE, GOTO), the diamond (<b>IF-THEN-ELSE),</b> and the dot (OR-tie). The Böhm–Jacopini canonical structures are made of these primitive shapes. Sub-structures can [...] "nest" [...] in rectangles, but only if a single exit occurs from the superstructure. The symbols, and their use to build the canonical structures, are shown in the diagram.|$|E
2500|$|Dijkstra's thesis {{was that}} departures from linear control flow were clearer if allowed only in disciplined higher-level {{structures}} such as the <b>if-then-else</b> statement and the while loop. This methodology was developed into structured programming movement, {{the title of his}} 1972 book, coauthored with C.A.R. Hoare and Ole-Johan Dahl. Considered by many as the first significant movement in history of computer programming, structured programming became the new programming orthodoxy during the 1970s. Bertrand Meyer remarked that, [...] "The revolution in views of programming started by Dijkstra's iconoclasm led to a movement known as structured programming, which advocated a systematic, rational approach to program construction. Structured programming is the basis for all that has been done since in programming methodology, including object-oriented programming." ...|$|E
2500|$|Structured programming, {{canonical}} structures: Per the Church–Turing thesis, any algorithm can be computed by a model {{known to}} be Turing complete, and per Minsky's demonstrations, Turing completeness requires only four instruction types—conditional GOTO, unconditional GOTO, assignment, HALT. Kemeny and Kurtz observe that, while [...] "undisciplined" [...] use of unconditional GOTOs and conditional IF-THEN GOTOs can result in [...] "spaghetti code", a programmer can write structured programs using only these instructions; {{on the other hand}} [...] "it is also possible, and not too hard, to write badly structured programs in a structured language". Tausworthe augments the three Böhm-Jacopini canonical structures: SEQUENCE, <b>IF-THEN-ELSE,</b> and WHILE-DO, with two more: DO-WHILE and CASE. An additional benefit of a structured program is that it lends itself to proofs of correctness using mathematical induction.|$|E
2500|$|Windows PowerShell {{includes}} a dynamically typed scripting language which can implement complex operations using cmdlets imperatively. The scripting language supports variables, functions, branching (<b>if-then-else),</b> loops (while, do, for, and foreach), structured error/exception handling and closures/lambda expressions, {{as well as}} integration with [...]NET. Variables in PowerShell scripts are prefixed with $. [...] Variables can be assigned any value, including the output of cmdlets. Strings can be enclosed either in single quotes or in double quotes: when using double quotes, variables will be expanded {{even if they are}} inside the quotation marks. Enclosing the path to a file in braces preceded by a dollar sign (as in ${C:\foo.txt}) creates a reference to the contents of the file. If it is used as an L-value, anything assigned to it will be written to the file. When used as an R-value, the contents of the file will be read. If an object is assigned, it is serialized before being stored.|$|E
2500|$|TeX {{commands}} commonly {{start with}} a backslash and are grouped with curly braces. Almost all of TeX's syntactic properties can be changed on the fly, which makes TeX input hard to parse by anything but TeX itself. TeX is a macro- and token-based language: many commands, including most user-defined ones, are expanded on the fly until only unexpandable tokens remain, which are then executed. Expansion itself is practically free from side effects. Tail recursion of macros takes no memory, and <b>if-then-else</b> constructs are available. This makes TeX a Turing-complete language even at the expansion level. The system {{can be divided into}} four levels: in the first, characters are read from the input file and assigned a category code (sometimes called [...] "catcode", for short). Combinations of a backslash (actually, any character of category zero) followed by letters (characters of category 11) or a single other character are replaced by a control-sequence token. In this sense, this stage is like lexical analysis, although it does not form numbers from digits. In the next stage, expandable control sequences (such as conditionals or defined macros) are replaced by their replacement text. The input for the third stage is then a stream of characters (including ones with special meaning) and unexpandable control sequences (typically assignments and visual commands). Here characters get assembled into a paragraph. TeX's paragraph breaking algorithm works by optimizing breakpoints over the whole paragraph. The fourth stage breaks the vertical list of lines and other material into pages.|$|E
50|$|The ?: {{operator}} {{is similar}} to the way conditional expressions (<b>if-then-else</b> constructs) work in functional programming languages, like Scheme, ML, and Haskell, since <b>if-then-else</b> forms an expression instead of a statement in those languages.|$|E
5000|$|SKI {{combinator}} calculus {{can also}} implement Boolean logic {{in the form}} of an <b>if-then-else</b> structure. An <b>if-then-else</b> structure consists of a Boolean expression that is either true (T) or false (F) and two arguments, such that: ...|$|E
50|$|A {{conditional}} {{using an}} <b>if-then-else</b> syntax {{was invented by}} McCarthy in a Fortran context. He proposed its inclusion in ALGOL, {{but it was not}} made part of the Algol 58 specification. For Lisp, McCarthy used the more general cond-structure. Algol 60 took up <b>if-then-else</b> and popularized it.|$|E
50|$|The CASE {{statement}} simplifies {{some large}} <b>IF-THEN-ELSE</b> structures.|$|E
50|$|Control {{structures}} include <b>IF-THEN-ELSE,</b> iteration, WHILE and CASE statements.|$|E
5000|$|... #Subtitle level 3: Expansion of <b>IF-THEN-ELSE</b> to the CASE {{operator}} ...|$|E
50|$|For example, {{consider}} {{a program that}} consists of two sequential <b>if-then-else</b> statements.|$|E
5000|$|... {{statement}} {{may include}} optional [...] block, {{in which case}} it becomes an <b>if-then-else</b> statement: ...|$|E
5000|$|... (for example, for n = 2 this is 1, {{corresponding}} {{to a single}} <b>if-then-else</b> construct).|$|E
50|$|She used {{a special}} board with plastic symbols to {{correctly}} parse various syntactic expressions including <b>if-then-else.</b>|$|E
50|$|Once true {{and false}} are defined, all Boolean logic can be {{implemented}} in terms of <b>if-then-else</b> structures.|$|E
5000|$|... {{which can}} be {{compared}} to the Algol-family <b>if-then-else</b> expressions (and similar in Ruby and Scala, among others).|$|E
5000|$|Improved Pre-Processing Capabilities: Additions to {{built-in}} functions include {{a range of}} Boolean operations and an <b>If-Then-Else</b> function.|$|E
50|$|Conditional {{statements}} (if-then or <b>if-then-else)</b> {{in computer}} science, binary decisions about which piece of code to execute next.|$|E
50|$|An <b>IF-THEN-ELSE</b> {{construct}} {{is available}} for conditional execution and two forms of FOR-NEXT construct are provided for looping.|$|E
5000|$|If this {{is put in}} an <b>if-then-else</b> structure, it can {{be shown}} that this has the {{expected}} result ...|$|E
50|$|The <b>IF-THEN-ELSE</b> is {{the basis}} of the McCarthy formalism: its usage replaces both {{primitive}} recursion and the mu-operator.|$|E
50|$|Program logic can tie all of {{the above}} {{elements}} together using constructs such as <b>if-then-else</b> statements and logical operators.|$|E
5000|$|The {{built-in}} <b>if-then-else</b> syntax is inline: the expressionif predicate then expr1 else expr2has typeBool -> a -> a -> a ...|$|E
