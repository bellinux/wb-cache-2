1|10000|Public
5000|$|Pytorch - Python based {{implementation}} of Torch API, allows <b>for</b> <b>dynamic</b> <b>graph</b> <b>construction</b> ...|$|E
40|$|Abstract. Spectral {{methods are}} {{naturally}} suited <b>for</b> <b>dynamic</b> <b>graph</b> layout, because moderate changes of a graph yield moderate {{changes of the}} layout under weak assumptions. We discuss some general principles <b>for</b> <b>dynamic</b> <b>graph</b> layout and derive a dynamic spectral layout approach for the animation of small-world models. ...|$|R
25|$|The {{separator}} based {{divide and}} conquer paradigm has also been used to design data structures <b>for</b> <b>dynamic</b> <b>graph</b> algorithms and point location, algorithms for polygon triangulation, shortest paths, {{and the construction of}} nearest neighbor graphs, and approximation algorithms for the maximum independent set of a planar graph.|$|R
40|$|Among the {{variants}} {{of the well}} known shortest path problem, those that refer to a dynamically changing graphs are theoretically interesting, as well as computationally challenging. Applicationwise, there is an industrial need for computing point-to-point shortest paths on large-scale road networks whose arcs are weighted with a travelling time which depends on traffic conditions. We survey recent techniques <b>for</b> <b>dynamic</b> <b>graph</b> weights as well as <b>dynamic</b> <b>graph</b> topology. ...|$|R
40|$|The {{world is}} a dynamic place, so when we use graphs to help {{understand}} real world problems the structure of such graphs inevitably changes over time. Understanding this change is important, but often challenging. Techniques <b>for</b> general purpose <b>dynamic</b> <b>graph</b> visualizations generally {{fall into one of}} two broad categories: animation or timeline based techniques [2]. Simple approaches using animation or small multiples experience challenges with change blindness and “preserving the user’s mental map” [1]. Storyline visualization techniques [5, 7] hold promise, though these techniques were not originally designed as general purpose solutions <b>for</b> <b>dynamic</b> <b>graph</b> visualization...|$|R
30|$|Our {{approach}} for optimizing the data structure selection <b>for</b> <b>dynamic</b> <b>graph</b> analysis {{is based on}} the assumption that workload and characteristics of the <b>dynamic</b> <b>graph</b> do not change drastically over time. We refer to such a workload as constant and call a workload non-constant in case access patterns or list sizes change significantly over time. In this case, we can estimate the workload for the complete analys{{is based on the}} first batches and determine the best configuration.|$|R
30|$|In this section, {{we report}} {{the results of}} the first study {{investigating}} the effects of proposed approach applied for implementation of a complex randomized algorithm involving the creation and evolution of <b>dynamic</b> <b>graphs.</b> First, we provide an overview on domain and related concepts, giving an idea about the complexity of the problem handled. Then, we describe the single-subject experiment carried out by the researcher proponent of the algorithm <b>for</b> <b>dynamic</b> <b>graphs</b> and, finally, we report the results of this study.|$|R
30|$|We {{proposed}} a compile-time approach for optimizing these data structures. As a case study, {{we performed a}} measurement study of seven data structures, fitted estimation functions from the results, implemented our approach {{on top of a}} Java-based framework <b>for</b> <b>dynamic</b> <b>graph</b> analysis, and evaluated it using real-world datasets. Our results show that our optimization achieves speedups of up to 5.4 × over basic configurations on real-world datasets.|$|R
30|$|Last, the {{visualization}} of large graphs {{in an online}} scenario, where node and edge updates are received in a live stream, and the related practical implications of dynamic visualizations, have rarely been considered. In this context, just some exploratory work {{has been carried out}} about information selection techniques <b>for</b> <b>dynamic</b> <b>graph</b> visualization, including solutions based on temporal decay of nodes and edges [59], node clustering [58], and centrality indices [60], [63].|$|R
40|$|Abstract. In this paper, {{we present}} new visual {{analysis}} methods for {{history of the}} FIFA World Cup competition data, a social network from Graph Drawing 2006 Competition. Our methods {{are based on the}} use of network analysis method, and new visualization methods <b>for</b> <b>dynamic</b> <b>graphs</b> with <b>dynamic</b> hierarchy and geographic clustering. More specifically, we derive a dynamic network with geographic clustering from the history of the FIFA World Cup competition data, based on who-beats-whom relationship. Combined with the centrality analysis (which defines dynamic hierarchy) {{and the use of the}} union of graphs (which determines the overall layout topology), we present three new visualization methods <b>for</b> <b>dynamic</b> <b>graphs</b> with <b>dynamic</b> hierarchy and geographic clustering: wheel layout, radial layout and hierarchical layout. Our experimental results show that our visual analysis methods can clearly reveal the overall winner of the World Cup competition history as well as the strong and weak countries. Further, one can analyze and compare the performance of each country for each year along the context with their overall performance. This enables to confirm the expected and discover the unexpected. ...|$|R
40|$|The k-core {{decomposition}} {{can be used}} {{to reveal}} structure in a graph. It is straight-forward to implement using a centralised algorithm with complete knowledge of the graph, but no distributed k-core decomposition algorithm has been published. We present a con- tinuous, distributed, k-core decomposition algorithm <b>for</b> <b>dynamic</b> <b>graphs,</b> outline a proof of correctness, and give initial performance results. We briefly describe an application of this distributed k-core algorithm to landmark selection for compact routing...|$|R
40|$|Timeslices {{are often}} used to draw and {{visualize}} <b>dynamic</b> <b>graphs.</b> While timeslices are a natural {{way to think about}} <b>dynamic</b> <b>graphs,</b> they are routinely imposed on continuous data. Often, it is unclear how many timeslices to select: too few timeslices can miss temporal features such as causality or even graph structure while too many timeslices slows the drawing computation. We present a model <b>for</b> <b>dynamic</b> <b>graphs</b> which is not based on timeslices, and a <b>dynamic</b> <b>graph</b> drawing algorithm, DynNoSlice, to draw graphs in this model. In our evaluation, we demonstrate the advantages of this approach over timeslicing on continuous data sets. Comment: Appears in the Proceedings of the 25 th International Symposium on Graph Drawing and Network Visualization (GD 2017...|$|R
30|$|In this Section, we {{introduce}} our terminology and notations <b>for</b> <b>graphs,</b> <b>dynamic</b> <b>graphs,</b> {{and their}} analysis. We introduce the different lists for representing graphs in memory {{as well as}} the operations required to adapt them over time and access them for analysis. Finally, we define the problem of selecting the best data structures for these lists.|$|R
40|$|<b>Dynamic</b> <b>graph</b> {{algorithms}} {{have been}} extensively {{studied in the}} last two decades due to their wide applicability in many contexts. Recently, several implementations and experimental studies have been conducted investigating the practical merits of fundamental techniques and algorithms. In most cases, these algorithms required sophisticated engineering and fine-tuning to be turned into efficient implementations. In this paper, we survey several implementations along with their experimental studies <b>for</b> <b>dynamic</b> problems on undirected and directed graphs. The former case includes dynamic connectivity, dynamic minimum spanning trees, and the sparsification technique. The latter case includes dynamic transitive closure and dynamic shortest paths. We also discuss the design and implementation of a software library <b>for</b> <b>dynamic</b> <b>graph</b> algorithms...|$|R
40|$|We {{present a}} method, {{inspired}} from routing in dynamic data networks, {{to solve the}} Semiring Algebraic Path Problem (SAPP) <b>for</b> <b>dynamic</b> <b>graphs.</b> The method {{can be used in}} dynamic networks such as Mobile Ad Hoc Networks, where the network link states are highly dynamic. The algorithm makes use of broadcasting as primary mechanism to recompute the SAPP solution. The solution suffers from broadcast storm problems, and we propose a selective broadcasting mechanism that reduces the broadcast storm. We call this method local pruning and prove its correctness...|$|R
30|$|A {{simulation}} {{program has}} been designed using Java language based on the GraphStream package [27]. The developed package provides an easy-to-use library of generators and methods <b>for</b> <b>dynamic</b> <b>graphs.</b> A node class has been extended to facilitate agent’s management. Agents are autonomous objects that take decisions according to their internal state and/or environment state. An agent interacts with other agents to accomplish specific tasks. Agents have been frequently used to simulate various complex systems [28, 29]. In social networks, agent-based models {{can be used to}} simulate real actors [22].|$|R
40|$|In {{this paper}} {{we present a}} {{modification}} of a technique by Chiba and Nishizeki [Chiba and Nishizeki: Arboricity and Subgraph Listing Algorithms, SIAM J. Comput. 14 (1), pp. 210 [...] 223 (1985) ]. Based on it, we design a data structure suitable <b>for</b> <b>dynamic</b> <b>graph</b> algorithms. We employ the data structure to formulate new algorithms for several problems, including counting subgraphs of four vertices, recognition of diamond-free graphs, cop-win graphs and strongly chordal graphs, among others. We improve the time complexity for graphs with low arboricity or h-index. Comment: 19 pages, no figure...|$|R
40|$|Dynamically {{changing}} graphs {{are used}} in many applications of graph algorithms. The scope of these graphs are in graphics, communication networks and in VLSI designs where graphs are subjected to change, such as addition and deletion of edges and vertices. There is a rich body of the algorithms and data structures used <b>for</b> <b>dynamic</b> <b>graphs.</b> The paper overview the techniques and data structures used in various dynamic algorithms. The effort is {{tried to find out}} the comparison in these techniques namely the hierarchical decomposition of graphs and highlighting the ingenuity used in designing these algorithms...|$|R
40|$|This article {{presents}} a novel visualization approach <b>for</b> <b>dynamic</b> <b>graphs,</b> the versinus method, specially useful for real world networks exhibiting free-scale properties. With {{a simple and}} fixed layout, and a small set of visual markups, the method has been useful for understanding network dynamics. Local community often suggests that it be reported, which motivated this article. Online resources deliver videos and computer scripts for rendering new animations. This article has a concise description of the method. Comment: article written by request of research colleagues that appreciated these visualizations. arXiv admin note: text overlap with arXiv: 1310. 776...|$|R
40|$|Spectral {{clustering}} is {{a widely}} studied problem, yet its complexity is prohibitive <b>for</b> <b>dynamic</b> <b>graphs</b> of even modest size. We claim {{that it is possible}} to reuse information of past cluster assignments to expedite computation. Our approach builds on a recent idea of sidestepping the main bottleneck of spectral clustering, i. e., computing the graph eigenvectors, by using fast Chebyshev graph filtering of random signals. We show that the proposed algorithm achieves clustering assignments with quality approximating that of spectral clustering and that it can yield significant complexity benefits when the graph dynamics are appropriately bounded...|$|R
40|$|Thesis (Ph. D.), Department of Electrical Engineering and Computer Science, Washington State UniversitySubgraph {{search is}} the problem of searching a data graph for the occurrences of another graph, {{typically}} referred to as the query or pattern graph. This thesis is dedicated to studying a specific class of subgraph search, named subgraph isomorphism <b>for</b> <b>dynamic</b> <b>graphs,</b> i. e., graphs that are evolving over time. Subgraph isomorphism is a well studied NP-complete problem in computer science. It requires finding a bijective mapping between the vertices in the query graph and the data graph so that if two vertices are neighbors in the query graph, their mapped counterparts are neighbors in the data graph as well. Our research on <b>dynamic</b> <b>graphs</b> is motivated by large-scale graph data sources such as social media and cyber-security where applications continuously produce prodigious amounts of data. This thesis makes three major contributions. We begin with proposing a new subgraph isomorphism algorithm <b>for</b> <b>dynamic</b> <b>graphs</b> and a novel data structure, namely the Subgraph Join-Tree (SJ-Tree) to support the algorithm. Next, we demonstrate how the statistics of the graph stream can be leveraged to produce the best-performing SJ-Tree for a given query graph. We propose a metric for estimating the selectivity of a graph query and demonstrate its use to reason about the relative performance of different query execution strategies. Our observations are supported by experiments on multiple real-world data sources drawn from online news, social media and network traffic. Our experiments demonstrate speedups by 10 - 100 times over existing approaches. Finally, we propose a new algorithm and supporting data structures to implement the aforementioned <b>dynamic</b> <b>graph</b> search algorithm on a distributed system. As a secondary contribution, we demonstrate how the novel ideas from the graph search paradigm can be applied to discover patterns in <b>dynamic</b> <b>graphs.</b> The thesis concludes with presentation of real-world use cases from three different application domains. Department of Electrical Engineering and Computer Science, Washington State Universit...|$|R
40|$|Over {{the last}} decade, {{there has been}} {{considerable}} in-terest in designing algorithms for processing massive graphs in the data stream model. The original moti-vation was two-fold: a) in many applications, the dy-namic graphs that arise are too large to be stored in the main memory of a single machine and b) considering graph problems yields {{new insights into the}} complexity of stream computation. However, the techniques devel-oped in this area are now finding applications in other areas including data structures <b>for</b> <b>dynamic</b> <b>graphs,</b> ap-proximation algorithms, and distributed and parallel com-putation. We survey the state-of-the-art results; iden-tify general techniques; and highlight some simple al-gorithms that illustrate basic ideas. 1...|$|R
40|$|Drawing graphs is an {{important}} problem that combines flavors of computational geometry and graph theory. Applications {{can be found in}} a variety of areas including circuit layout, network management, software engineering, and graphics. The main contributions of this paper can be summarized as follows: ffl We devise a model <b>for</b> <b>dynamic</b> <b>graph</b> algorithms, based on performing queries and updates on an implicit representation of the drawing, and we show its applications. ffl We present several efficient <b>dynamic</b> drawing algorithms <b>for</b> trees, series-parallel digraphs, planar st-digraphs, and planar graphs. These algorithms adopt a variety of representations (e. g., straight-line, polyline, visibility), and update the drawing in a smooth way...|$|R
40|$|Introduction In many {{applications}} of graph algorithms, including communication networks, graphics, assembly planning, and VLSI design, graphs {{are subject to}} discrete changes, such as additions or deletions of edges or vertices. In the last decade {{there has been a}} growing interest in such dynamically changing graphs, and a whole body of algorithms and data structures <b>for</b> <b>dynamic</b> <b>graphs</b> has been discovered. This chapter is intended as an overview of this field. In a typical <b>dynamic</b> <b>graph</b> problem one would like to answer queries on graphs that are undergoing a sequence of updates, for instance, insertions and deletions of edges and vertices. The goal of a <b>dynamic</b> <b>graph</b> algorithm is to update efficiently the solution of a problem after dynamic changes, rather than having to recompute it from scratch each time. Given their powerful versatility, {{it is not surprising that}} dynamic algorithms and dynamic data structures are often more difficult to design and analyze than their static...|$|R
40|$|The {{sharing of}} {{resources}} among processes in a distributed system {{leads to a}} conflict graph that may change with time. Resource allocation over a static conflict graph (also called the dining philosophers problem) has been studied extensively. We seek to solve resource allocation on <b>dynamic</b> conflict <b>graphs</b> by using existing algorithms that work only for static conflict graphs. In the process we define {{the notion of a}} snapshot of a <b>dynamic</b> <b>graph,</b> specify its properties, and show how it can be combined with static graph algorithms to yield efficient solutions <b>for</b> <b>dynamic</b> <b>graphs.</b> Index Terms: Distributed Algorithms, <b>Dynamic</b> Grpahs, <b>Graph</b> Coloring, Resource Allocation 1 Introduction In modern computer systems, resources are usually distributed and shared among a number of users. Since the resources are usually used in an exclusive manner, efficient resource allocation algorithm are needed to minimize the amount of waiting and to improve the throughput of the system. The distributed job sc [...] ...|$|R
50|$|Prior to {{becoming}} a TV writer, Westbrook was a successful algorithms researcher. After majoring in physics and history of science at Harvard University, he studied computer science with Robert Tarjan at Princeton University, receiving his Ph.D. in 1989 with a thesis entitled Algorithms and Data Structures <b>for</b> <b>Dynamic</b> <b>Graph</b> Algorithms. He then took a faculty position at Yale University, later becoming a researcher for AT&T Laboratories before leaving research for Hollywood. Westbrook's Erdős number is three due to his research collaborations with Tarjan and others. His Bacon number is also three, due to his appearance as an extra in the movie Master and Commander: The Far Side of the World, giving a combined Erdős-Bacon number of six.|$|R
40|$|Universal pointsets can be {{used for}} {{visualizing}} multiple relationships on the same set of objects or <b>for</b> visualizing <b>dynamic</b> <b>graph</b> processes. In simultaneous geometric embeddings, the same point in the plane is used to represent the same object as a way to preserve the viewer’s mental map. In colored simultaneous embeddings this restriction is relaxed, by allowing a given objec...|$|R
40|$|In this paper, {{we present}} a new {{approach}} to exploring <b>dynamic</b> <b>graphs.</b> We have developed a new clustering algorithm <b>for</b> <b>dynamic</b> <b>graphs</b> which finds an ideal clustering for each time-step and links the clusters together. The resulting time-varying clusters are then used to define two visual representations. The first view is an overview that shows how clusters evolve over time and provides an interface to find and select interesting time-steps. The second view consists of a node link diagram of a selected time-step which uses the clustering to efficiently define the layout. By using the time-dependant clustering, we ensure the stability of our visualization and preserve user mental map by minimizing node motion, while simultaneously producing an ideal layout for each time step. Also, as the clustering is computed ahead of time, the second view updates in linear time which allows for interactivity even for graphs with upwards {{of tens of thousands of}} nodes...|$|R
40|$|Monitoring key {{properties}} of <b>dynamic</b> <b>graphs</b> {{in real time}} can help detect spam accounts in social networks, identify anomalies and intrusions, and inform resource management. Traditional frameworks <b>for</b> <b>dynamic</b> <b>graphs</b> have relied on processing only the stream of edges added into or deleted from an evolving graph, but not any additional related information such as the degrees or neighbor lists of nodes associated with the edges. In this paper, we propose a new edge sampling framework for big-graph analytics in <b>dynamic</b> <b>graphs</b> which enhances the traditional model and offers significantly improved trade-off between accuracy and computational/memory costs in the running estimates of a graph's properties. To demonstrate this higher accuracy using the framework, we present a new sampling algorithm, called Edge Sample and Discard, which generates an unbiased estimate {{of the total number}} of triangles in a fully <b>dynamic</b> <b>graph.</b> The experimental results show that, with the help of the neighborhood information of the sampled edges, the accuracy achieved by our algorithm is substantially better than the accuracy achieved by current state-of-the-art algorithms. Comment: A shorter version of this article will appear in Proceedings of the 2017 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM 2017...|$|R
3000|$|Firstly, the Laplacians <b>for</b> a given <b>dynamic</b> <b>graph</b> all {{exist on}} a matrix manifold. For the {{trajectory}} L(t) on that manifold, though, the trajectory speed is not constant, the trajectory direction is not constant, {{and it is}} not the shortest path from L [...]...|$|R
40|$|Recent work in <b>dynamic</b> <b>graph</b> {{algorithms}} {{has led to}} efficient algorithms <b>for</b> <b>dynamic</b> undirected <b>graph</b> {{problems such}} as connectivity. However, no efficient algorithms are known <b>for</b> the <b>dynamic</b> versions of fundamental directed graph problems like strong connectivity and transitive closure, {{as well as some}} undirected graph problems such as maximum matchings and cuts. We provide some explanation for this lack of success by presenting quadratic lower bounds on the certificate complexity of the seemingly difficult problems, in contrast to the known linear certificate complexity for the problems which have efficient dynamic algorithms. A direct outcome of our lower bounds is the demonstration that a generic technique <b>for</b> designing efficient <b>dynamic</b> <b>graph</b> algorithms, viz., sparsification, will not apply to the difficult problems. More generally, it is our belief that the boundary between tractable and intractable <b>dynamic</b> <b>graph</b> problems can be demarcated in terms of certificate complexity. In many applications of <b>dynamic</b> (di) <b>graph</b> problems, a certain form of lookahead is available. Specifically, we consider the problems of assembly planning in robotics and the maintenance of relations in databases. These give rise to dynamic strong connectivity and dynamic transitive closure problems, respectively. We explain why it is reasonable, and indeed natural and desirable, to assume that lookahead is available in these two applications. Exploiting lookahead to circumvent their inherent complexity, we obtain efficient fully-dynamic algorithms for strong connectivity and transitive closure...|$|R
40|$|Drawing large graphs {{appropriately}} is {{an important}} step for the visual analysis of data from real-world networks. Here we present a novel multilevel algorithm to compute a graph layout with respect to a recently proposed metric that combines layout stress and entropy. As opposed to previous work, we do not solve the linear systems of the maxent-stress metric with a typical numerical solver. Instead we use a simple local iterative scheme within a multilevel approach. To accelerate local optimization, we approximate long-range forces and use shared-memory parallelism. Our experiments validate the high potential of our approach, which is particularly appealing <b>for</b> <b>dynamic</b> <b>graphs.</b> In comparison to the previously best maxent-stress optimizer, which is sequential, our parallel implementation is on average 30 times faster already for static graphs (and still faster if executed on one thread) while producing a comparable solution quality...|$|R
40|$|Since today's {{real-world}} graphs, such {{as social}} network graphs, are evolving all the time, it is of great importance to perform graph computations and analysis in these <b>dynamic</b> <b>graphs.</b> Due {{to the fact that}} many applications {{such as social}} network link analysis with the existence of inactive users need to handle failed links or nodes, decremental computation and maintenance for graphs is considered a challenging problem. Shortest path computation {{is one of the most}} fundamental operations for managing and analyzing large graphs. A number of indexing methods have been proposed to answer distance queries in static graphs. Unfortunately, there is little work on answering such queries <b>for</b> <b>dynamic</b> <b>graphs.</b> In this paper, we focus on the problem of computing the shortest path distance in <b>dynamic</b> <b>graphs,</b> particularly on decremental updates (i. e., edge deletions). We propose maintenance algorithms based on distance labeling, which can handle decremental updates efficiently. By exploiting properties of distance labeling in original graphs, we are able to efficiently maintain distance labeling for new graphs. We experimentally evaluate our algorithms using eleven real-world large graphs and confirm the effectiveness and efficiency of our approach. More specifically, our method can speed up index re-computation by up to an order of magnitude compared with the state-of-the-art method, Pruned Landmark Labeling (PLL) ...|$|R
40|$|<b>Dynamic</b> <b>graphs</b> {{have emerged}} as an {{appropriate}} model to capture {{the changing nature of}} many modern networks, such as peer-to-peer overlays and mobile ad hoc networks. Most of the recent research on dynamic networks has only addressed the undirected <b>dynamic</b> <b>graph</b> model. However, realistic networks such as the ones identified above are directed. In this paper we present early work in addressing the properties of directed <b>dynamic</b> <b>graphs.</b> In particular, we explore the problem of random walk in such graphs. We assume the existence of an oblivious adversary that makes arbitrary changes in every communication round. We explore the problem of covering the <b>dynamic</b> <b>graph,</b> that even in the static case can be exponential, and we establish an upper bound O(d_max n^ 3 log^ 2 n) of the cover time <b>for</b> balanced <b>dynamic</b> <b>graphs.</b> Comment: This paper has been withdrawn by the autho...|$|R
40|$|We combine and {{supplement}} existing {{approaches to}} arrive at a general algorithm <b>for</b> <b>dynamic</b> orthogonal <b>graph</b> drawing with few bends. Our approach is applicable to non-planar graphs with vertices of arbitrary degree, reduces the number of bends if possible, allows explicit control of the bend-number/modification trade-off and does not suffer from the so-called rotation problem, all of which have been limitations in earlier approaches...|$|R
30|$|Tools <b>for</b> <b>dynamic</b> <b>graph</b> {{visualization}} developed so far do {{not provide}} specialized ways to dynamically select the most important portions of large evolving graphs. We contribute to filling this gap by proposing an algorithm to filter nodes and edges that best represent the network structure at a given time. Our method captures trends and smoothens the dynamics of structural properties of weighted networks by leveraging the short-term and long-term node activity. Furthermore, our filtering method uses limited memory and processor time making it viable for large live data streams. We implemented our filtering algorithm in open source tools that take in input a stream of interaction data and output a movie of the network evolution or a live Gephi animation. As future work, we wish to improve our algorithm by means of further optimization and to enhance the tools by providing a standalone module for live visualization of graph evolution.|$|R
