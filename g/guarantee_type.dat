21|238|Public
40|$|Scenario {{analysis}} was used to examine empirically the relationships between <b>guarantee</b> <b>type</b> and service experience, and consumer satisfaction, for the service of an Internet Service Provider (ISP). The scenarios involved hypothetical situations in which several factors were varied: the existence of a problem; the invocation of a guarantee, the identity of the invoker; and the manner of resolution of any problem. Alternative service guarantees were associated with each hypothetical experience: a specific guarantee, and an unconditional guarantee. Overall, consumer satisfaction related {{to the nature of the}} service experience much more strongly than it did to the difference in <b>guarantee</b> <b>type.</b> <br /...|$|E
40|$|We {{suggest a}} model for dynamic linking and {{verification}} as in Java. We distinguish five components in a Java implementation: evaluation, resolution, loading, verification, and preparation – with their associated checks. We demonstrate how these five together <b>guarantee</b> <b>type</b> soundness. We take an abstract view, and base our model on a language nearer to Java source than to bytecode. We consider the following features of Java: classes, subclasses, fields and hiding, methods and inheritance, and interfaces...|$|E
40|$|Photograph of Western Air Patrol radio, Southern California, 1931. "Made in USA, The Magnavox Company, Chicago, Ill[inois], Model, See Cone Housing Label for Patent Notice; To Replace Fuse Remove this Plate, Caution [...] Set for Use on 110 Volt, 50 - 60 Cycle A. C. Current For 125 Line Voltage Change to Second Position. Licensed Under R. C. A. Hazeltine and La Tour Patents, R. C. A. Patents, Hazeltine and La Tour Patents, Standard R. M. A <b>Guarantee,</b> <b>Type,</b> Volts, Watts, Ser[ial] No. " [...] signage on radio...|$|E
40|$|We {{introduce}} {{tests for}} finite-sample linear regressions with heteroskedastic errors. The tests are exact, i. e., they have <b>guaranteed</b> <b>type</b> I error probabilities when bounds are known {{on the range}} of the dependent variable, without any assumptions about the noise structure. We provide upper bounds on probability of type II errors, and apply the tests to empirical data...|$|R
40|$|We {{introduce}} {{tests for}} finite sample multivariate linear regressions with heteroskedastic errors that have mean zero. We assume bounds on endoge- nous variables {{but do not}} make additional assumptions on errors. The tests are exact, i. e., they have <b>guaranteed</b> <b>type</b> I error probabilities. We provide bounds on probability of type II errors, and apply the tests to empirical data. ...|$|R
40|$|Scripting {{languages}} like Python and Ruby allow {{rapid development}} of software, {{but make no}} <b>guarantees</b> about the <b>type</b> safety of a program at compile time. While static languages like Java do make strong <b>guarantees</b> about the <b>type</b> safety of a program at compile time, they are not perceived to be as agile as their more dynamic counterparts. Is it possible to develop a statically-typed language that makes strong <b>guarantees</b> about <b>type</b> safety, but looks and acts like a scripting language?...|$|R
40|$|In {{the modern}} {{commercial}} world guarantees {{have become an}} important instrument. Guarantees {{are not limited to}} those given by a bank in the commercial world. Guarantees may also be issued by a parent company on behalf of a subsidiary, or by an individual(s) in personal transactions. The question then is what is a contract of guarantee? A guarantee is an assurance or security issued by one party (the guarantor) {{at the request of the}} party with the liability (the principal) to the party the liability is owed to (the beneficiary). Guarantees are discussed in this paper in the context of bank issued guarantees in shipbuilding contract. In shipbuilding contracts there are two types of guarantees issued – (i) refund guarantees, and (ii) payment guarantees. When payment is due under a guarantee, irrespective of if it is a refund guarantee or a payment guarantee, is dependent upon if it is a traditional <b>guarantee</b> <b>type,</b> or an on-demand bond type. The aim of this thesis is to examine the distinction between the true <b>guarantee</b> <b>type</b> and the on-demand bond type under English law. At the same time the objective of this thesis is to analyse the legal literature and the English common law cases to understand how a refund guarantee issued in shipbuilding contracts is conceived by the English courts to be either an on-demand bond or true guarantee. What are true guarantees and on-demand bonds? What are the distinguishing characteristics of each type of guarantee...|$|E
40|$|Publish/subscribe {{research}} {{has so far}} been mostly focused on efficient event routing, event filtering, and composite event detection. The little research that has been published regarding security in publish/subscribe systems has been tentative at best. This paper presents a model for secure type names, and definitions for type-checked, content-based publish/subscribe systems. Our model provides a cryptographically verifiable binding between type names and type definitions. It also produces self-certifiable type definitions that <b>guarantee</b> <b>type</b> definition authenticity and integrity. We also consider type management in a large-scale publish/subscribe system and present a way for delegating management duties to type managers by issuing SPKI authorisation certificates. We feel that secure names are a prerequisite for most other security related work with publish/subscribe systems. 1...|$|E
40|$|We {{present the}} first typeful {{implementation}} of Normalization by Evaluation for the simply typed lambda-calculus with sums and control operators: we <b>guarantee</b> <b>type</b> preservation and eta-long (modulo commuting conversions), beta-normal forms using only Generalized Algebraic Data Types in a general-purpose programming language, here OCaml; and we account for sums and control operators with Continuation-Passing Style. First, we implement the standard NbE algorithm for the implicational fragment in a typeful {{way that is}} correct by construction. We then derive its call-by-value continuation-passing counterpart, that maps a lambda-term with sums and call/cc into a CPS term in normal form, which we express in a typed dedicated syntax. Beyond showcasing the expressive power of GADTs, we emphasize that type inference gives a smooth way to re-derive the encodings of the syntax and typing of normal forms in Continuation-Passing Style...|$|E
40|$|Statically typed aspect-oriented {{programming}} languages restrict {{application of}} around advice {{only to the}} join points that have conforming types. Though the restriction <b>guarantees</b> <b>type</b> safety, it can prohibit application of advice that is useful, yet does not cause runtime type errors. To this problem, we present a novel weaving mechanism, called the type relaxed weaving, that allows such advice applications while preserving type safety. We formalized the mechanism, and implemented as an AspectJ compatible compiler, called RelaxAJ...|$|R
30|$|An {{approach}} to ensure security property of computer software {{consists of the}} use of type systems in order to control information flow in software [46]. In programming languages with security types, variables and expressions types have annotations that indicate policies to be ensured by the compiler on uses of such data. This approach has the following benefits: (1) since these policies are checked at compile-time, there is no run-time overhead; (2) once security policies are expressed by a type system, standard techniques for <b>guaranteeing</b> <b>type</b> system soundness can be used to certify that security policies are enforced in an end-to-end way in the whole program.|$|R
40|$|Three {{trends in}} the {{development}} of advanced object-oriented languages are toward better encapsulation, increased expressiveness, and strong, static typing. To understand the interaction of these three design goals we have developed Dubious, a small and highly uniform core language. Dubious provides a simple and flexible object model as well as first-class modules. In addition, Dubious features several advanced language constructs, including multimethod dispatch, first-class generic functions, and the complete separation of inheritance and subtyping. Finally, the language has an orthogonal type system which statically <b>guarantees</b> <b>type</b> safety. The type system allows modules to be safely type-checked in isolation, facilitating independent development and incremental modification of programs...|$|R
40|$|It is {{generally}} accepted {{that the possibility}} of a procedure in one program to call a procedure in another program is a useful paradigm for developing distributed applications. However, in a distributed environment, programs should be allowed to be built and then changed in an independent manner, thus allowing inconsistent types to be declared in the expected and the actual remote procedure interface. If one cannot <b>guarantee</b> <b>type</b> consistency, the program executing the remote procedure would be vulnerable to invalid call requests. The paper describes how a persistent programming language can be used to implement an RPC mechanism that automatically supports type-safety. It is typesafe since the expected interface is checked against the actual remote procedure interface before a call is attempted and automatic because user intervention is only that needed otherwise (that is, to call a local procedure) ...|$|E
40|$|Mid-study design {{modifications}} {{are becoming}} increasingly accepted in confirmatory clinical trials, so long as appropriate methods are applied such that error rates are controlled. It is therefore unfortunate that the important case of time-to-event endpoints is not easily handled by the standard theory. We analyze current methods that allow design modifications {{to be based on}} the full interim data, i. e., not only the observed event times but also secondary endpoint and safety data from patients who are yet to have an event. We show that the final test statistic may ignore a substantial subset of the observed event times. An alternative test incorporating all event times is found, where a conservative assumption must be made in order to <b>guarantee</b> <b>type</b> I error control. We examine the power of this approach using the example of a clinical trial comparing two cancer therapies...|$|E
40|$|Object-oriented {{databases}} enforce behavioral schema consistency {{rules to}} <b>guarantee</b> <b>type</b> safety, i. e., that no run-time type error can occur. When the schema must evolve, some schema updates may violate these rules. In {{order to maintain}} behavioral schema consistency, traditional solutions require significant changes to the types, the type hierarchy and the code of existing methods. Such operations are very expensive in a database context. To ease schema evolution, we propose to support exceptions to the behavioral consistency rules without sacrificing type safety. The basic idea is to detect unsafe statements in a method code at compile-time and check them at run-time. The run-time check is performed by a specific clause that is automatically inserted around unsafe statements. This check clause warns the programmer of the safety problem and lets him provide exception-handling code. Schema updates can therefore be performed with only {{minor changes to the}} code of methods...|$|E
5000|$|Bank <b>guarantee</b> has various <b>types</b> like1. Tender Bond2. Advance Payment3. Performance Bond4. Financial5. Retention6. Labour ...|$|R
50|$|Claimants are {{automatically}} excluded from benefit {{with more than}} £16,000 of capital (unless qualifying for Pension Credit <b>Guarantee).</b> Certain <b>types</b> of capital, such as personal injury compensation payments {{and the value of}} capital that is no longer available to the claimant are disregarded.|$|R
40|$|Typed {{assembly}} languages {{have the}} goal of providing security guarantees, for example, for the limited use of resources in a host machine or the detection of autoupdate code. This work presents a simple typed assembly language which allows us to perform various kinds of static analysis tasks {{with the purpose of}} detecting flaws in the code security. The security policy we use <b>guarantees</b> <b>type</b> and memory safety. Moreover, wa can ensure that non-initialized variables are not read, and that there is no out-of-bound array accesses. The language we present, called STALlion, was designed in order to interpret a particular kind of imperative programs, more specifically abstract syntax tree. Eje: I - Workshop de Ingeniería de Software y Base de Dato...|$|R
40|$|International audienceWe {{present the}} first typeful {{implementation}} of Normalization by Evaluation for the simply typed λ-calculus with sums and control operators: we <b>guarantee</b> <b>type</b> preservation and η-long (modulo commuting conversions), β-normal forms using only Generalized Algebraic Data Types in a general-purpose programming language, here OCaml; and we account for sums and control operators with Continuation-Passing Style. Our presentation {{takes the form}} of a typed functional pearl. First, we implement the standard NbE algorithm for the implicational fragment in a typeful way that is correct by construction. We then derive its continuation-passing counterpart, in call-by-value and call-by-name, that maps a λ-term with sums and call/cc into a CPS term in normal form, which we express in a typed, dedicated syntax. Beyond showcasing the expressive power of GADTs, we emphasize that type inference gives a smooth way to re-derive the encodings of the syntax and typing of normal forms in Continuation-Passing Style...|$|E
40|$|Projet RODINObject-oriented {{databases}} enforce behavioral schema consistency {{rules to}} <b>guarantee</b> <b>type</b> safety, i. e., that no run-time type error can occur. When the schema must evolve, some schema updates may violate these rules. In {{order to maintain}} behavioral schema consistency, traditional solutions require significant changes to the types, the type hierarchy and the code of existing methods. Such operations are very expensive in a database context. To ease schema evolution, we propose to support exceptions to the behavioral consistency rules without sacrificing type safety. The basic idea is to detect unsafe statements in a method code at compile-time and check them at run-time. The run-time check is performed by a specific clause that is automatically inserted around unsafe statements. This check clause warns the programmer of the safety problem and lets him provide exception-handling code. Schema updates can therefore be performed with only {{minor changes to the}} code of metho...|$|E
40|$|We {{suggest a}} model for dynamic linking and {{verification}} as in Java. We distinguish five components in a Java implementation: evaluation, resolution, loading, verification, and preparation [...] with their associated checks. We demonstrate how these five together <b>guarantee</b> <b>type</b> soundness. We take an abstract view, and base our model on a language nearer to Java source than to bytecode. We consider the following features of Java: classes, subclasses, fields and hiding, methods and inheritance, and interfaces. 1 Introduction Java's recent spectacular success {{is partly due to}} its novel approach to code deployment. Rather than compiling and linking a fixed piece of code for a set target machine, Java is compiled to bytecode[18], that can be executed on several platforms, and can link further code on demand: This approach, however, creates opportunities for malicious attacks. The security of Java greatly depends on the safety of the type system [4]. As it is bytecode that is executed rather th [...] ...|$|E
40|$|We {{propose a}} new type system for Java-like {{languages}} which allows compilation of a class in isolation, that is, in a context where no information is available on other classes. Indeed, by this type system {{it is possible to}} infer the assumptions <b>guaranteeing</b> <b>type</b> correctness of a class c, and generate (abstract) bytecode for c, by just inspecting the source code of c. Then, a collection of classes can be safely linked together without further inspection of the classes' code, provided that each class has been typechecked in isolation (intra-checking), and that the mutual class assumptions are satisfied (inter-checking). In other words, the type systems supports compositional analysis, as formally guaranteed {{by the fact that it}} has principal typings. We also develop an algorithm for inter-checking, and prove it correct...|$|R
5000|$|Safety - A type system {{enables the}} {{compiler}} to detect meaningless or probably invalid code. For example, {{we can identify}} an expression [...] as invalid, when the rules do not specify how to divide an integer by a string. Strong typing offers more safety, but cannot <b>guarantee</b> complete <b>type</b> safety.|$|R
2500|$|Safety – A type system {{enables the}} {{compiler}} to detect meaningless or probably invalid code. For example, {{we can identify}} an expression 3 / [...] "Hello, World" [...] as invalid, when the rules do not specify how to divide an integer by a string. Strong typing offers more safety, but cannot <b>guarantee</b> complete <b>type</b> safety.|$|R
40|$|Abstract—Interdependent {{functionalities}} such as access autho-rizing, routing, traffic observing, {{and load}} adjusting are offered by today’s networks. Inconveniently, the existing languages for programming software defined networks {{do not provide}} paral-lelism to simulate the natural interdependence between common network functionalities. These languages are also not successful in providing a rudimentary solution to overcome the bad need for concurrency. This results in perplexed network programs. This paper proposes ConNet, {{a model for a}} concurrent net-work programming langauge. This model is simple, yet powerful enough to express strong networking applications. The model is supported with a new operational semantics that is based on a new concept, the event of states concept. A type system to <b>guarantee</b> <b>type</b> safety of ConNet programs is proposed in this paper as well. Mathematical formalization for the correctness of the type system is stated in the paper. Results of experiments checking efficiency of the language model are presented and discussed in the paper. I...|$|E
40|$|From now on, a {{main goal}} in {{designing}} a language {{should be to}} plan for growth. " Guy Steele: Growing a Language, OOPSLA' 98 invited talk. We present our experiences with a syntax macro language which we claim forms a general abstraction mechanism for growing (domain-specific) extensions of programming languages. Our syntax macro language is designed to <b>guarantee</b> <b>type</b> safety and termination. A concept of metamorphisms allows the arguments of a macro to be inductively defined in a meta level grammar and morphed into the host language. We also show how the metamorphisms {{can be made to}} operate simultaneously on multiple parse trees at once. The result is a highly flexible mechanism for growing new language constructs without resorting to compile-time programming. In fact, whole new languages can be defined at surprisingly low cost. This work is fully implemented as part of the system for defining interactive Web services, but could find use in many other languages. 1...|$|E
40|$|The {{effectiveness}} of traditional type checking in C {{is limited by}} the presence of type conversions using type casts. Because the C standard allows arbitrary type conversions between pointer types, neither C compilers, nor tools such as lint, can <b>guarantee</b> <b>type</b> safety in the presence of such type conversions. In particular, by using casts involving pointers to structures (C structs), a programmer can interpret any memory region to be of any desired type, further compromising C's weak type system. Not only do type casts make program vulnerable to type errors, they hinder program comprehension and maintenance by creating latent dependencies between seemingly independent pieces of code. To address these problems, we have developed a stronger form of type checking for C programs, called physical type checking. Physical type checking takes into account the layout of C struct fields in memory. This paper describes an inference-based physical type checking algorithm and its implementation. Ou [...] ...|$|E
40|$|The {{safety of}} {{anaesthetic}} agents in early pregnancy cannot be <b>guaranteed.</b> Certain <b>types</b> of surgery, particularly gynaecological, {{may also be}} dangerous. It is therefore important to ensure that, female patients are not inadvertently pregnant when undergoing elective surgery. Different hospitals have different policies and guidelines in place to determine female patients' pregnancy status prior to elective surgery...|$|R
40|$|Abstract. There {{are many}} source-level {{analyses}} or instrumentation tools that enforce various safety properties. In this paper we present an infrastructure {{that can be}} used to check independently that the assembly output of such tools has the desired safety properties. By working at assembly level we avoid the complications with unavailability of source code, with source-level parsing, and we certify the code that is actually deployed. The novel feature of the framework is an extensible dependently-typed framework that supports type inference and mutation of dependent values in memory. The type system can be extended with new types as needed for the source-level tool that is certified. Using these dependent types, we are able to express the invariants enforced by CCured, a sourcelevel instrumentation tool that <b>guarantees</b> <b>type</b> safety in legacy C programs. We can therefore check that the x 86 assembly code resulting from compilation with CCured is in fact type-safe. ...|$|R
50|$|MacroML is an {{experimental}} programming language {{based on the}} ML programming language family that seeks to reconcile ML's static typing systems, {{and the types of}} macro systems more commonly found in dynamically typed languages like Scheme; this reconciliation is difficult as macro transformations are typically Turing-complete and so can break the <b>type</b> safety <b>guarantees</b> static <b>typing</b> is supposed to provide.|$|R
40|$|Sensitivity and {{specificity}} {{are often used}} to assess the performance of a diagnostic test with binary outcomes. Wald-type test statistics have been proposed for testing sensitivity {{and specificity}} individually. In the presence of a gold standard, simultaneous comparison between two diagnostic tests for noninferiority of sensitivity and specificity based on an asymptotic approach has been studied by Chen et al. (2003). However, the asymptotic approach may suffer from unsatisfactory type I error control as observed from many studies, especially in small to medium sample settings. In this paper, we compare three unconditional approaches for simultaneously testing sensitivity and specificity. They are approaches based on estimation, maximization, and a combination of estimation and maximization. Although the estimation approach does not <b>guarantee</b> <b>type</b> I error, it has satisfactory performance with regard to type I error control. The other two unconditional approaches are exact. The approach based on estimation and maximization is generally more powerful than the approach based on maximization...|$|E
40|$|Abstract. We {{define a}} {{framework}} of components based on Java-like languages, where components are binary mixin modules. Basic components {{can be obtained from}} a collection of classes by compiling such classes in isolation; for allowing that, requirements in the form of type constraints are associated with each class. Requirements are specified by the user who, however, is assisted by the compiler which can generate missing constraints essential to <b>guarantee</b> <b>type</b> safety. Basic components can be composed together by using a set of expressive typed operators; thanks to soundness results, such a composition is always type safe. The framework is designed as a separate layer which can be instantiated on top of any Java-like language; a prototype implementation is available for a small Java subset. Besides safety, the approach achieves great flexibility in reusing components for two reasons: (1) type constraints generated for a single component exactly capture all possible contexts where it can be safely used; (2) composition of components is not limited to conventional linking, but is achieved by means of a set of powerful operators typical of mixin modules. ...|$|E
40|$|Abstract approved: Djang et al. [1998] {{introduced}} {{a new model of}} types for declarative visual programming languages (VPLs). Implicit static typing is used in their type model, in order to eliminate the programming mechanisms associated with type declarations, provide immediate visual feedback with respect to type errors and <b>guarantee</b> <b>type</b> safe programs. Their type model also evaluates types on a level of granularity that is finer than in previous approaches to types. Instead of evaluating types on the basis of abstract names, their model determines a set of operations that an object guarantees and compares this set to the set of operations this object is required to support. If the set of required operations is a subset of the set of guaranteed operations, then the object is considered type safe. This granularity provides their model with the ability to support inheritance without introducing explicit type declarations and to communicate type errors to users without requiring the user to understand a large set of terminology. These features of their model attempt to provide VPL users with more powerful programming capabilities without the introduction of a high learning curve. In this thesis, an implementation of the Djang et aI. ' s model of types is presented. Data structures and algorithms are developed that conform to the axioms prescribed by Djang et al. The space and time complexity analyses for our data structures and algorithms are examined. Our implementation provides new insights into the cost and performance of the Djang et aI. ' s type model. Redacted for privac...|$|E
40|$|Most dependently-typed {{programming}} languages either {{require that}} all expressions terminate (e. g. Coq, Agda, and Epigram), or allow infinite loops but are inconsistent when viewed as logics (e. g. Haskell, ATS, mega). Here, we combine these two approaches {{into a single}} dependently-typed core language. The language is composed of two fragments that share a common syntax and overlapping semantics: a logic that guarantees total correctness, and a call-by-value programming language that <b>guarantees</b> <b>type</b> safety but not termination. The two fragments may interact: logical expressions {{may be used as}} programs; the logic may soundly reason about potentially nonterminating programs; programs can require logical proofs as arguments; and “mobile” program values, including proofs computed at runtime, may be used as evidence by the logic. This language allows programmers to work with total and partial functions uniformly, providing a smooth path from functional programming to dependently-typed programming. Categories and Subject Descriptors D. 3. 1 [Programming Languages]: Formal Definitions and Theory Keywords Dependent types; Termination; General recursio...|$|R
40|$|Memory usage {{analysis}} {{is an important}} problem for resource-constrained mobile devices, especially under mission- or safety-critical circumstances. Program codes running on or being downloaded into such devices are often available in low-level bytecode forms. We propose in this paper a formal heap model for Java bytecode language, on top of which we can then provide separation logic support for further memory usage verification. Our low-level heap model for Java bytecode {{would allow us to}} reason about the size and alignment properties of primitive values stored in the heap. To support type-related reasoning such as <b>guaranteeing</b> <b>type</b> and alignment safety, this model is also lifted with both base types and user-defined classes. Based on such model, we have also defined a separation logic proof system whose assertions are interpreted using the lifted heap with types. We envision, with further extension, the system would provide good support for memory usage analysis and verification for mobile devices...|$|R
40|$|By {{combining}} existing type {{systems with}} standard typebased compilation techniques, we describe {{how to write}} strongly typed programs that include a function {{that acts as a}} tracing garbage collector for the program. Since the garbage collector is an explicit function, we do not need to provide a trusted garbage collector as a runtime service to manage memory. Since our language is strongly typed, the standard <b>type</b> soundness <b>guarantee</b> "Well <b>typed</b> programs do not go wrong" is extended to include the collector. Our <b>type</b> safety <b>guarantee</b> is non-trivial since not only does it <b>guarantee</b> the <b>type</b> safety of the garbage collector, but it guarantees that the collector preservers the type safety of the program being garbage collected. We describe the technique in detail and report performance measurements for a few microbenchmarks as well as sketch the proofs of type soundness for our system. 1 Introduction We outline an approach, based on ideas from existing type systems, to build a type-preser [...] ...|$|R
