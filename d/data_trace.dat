125|2080|Public
2500|$|These {{two sets}} {{intersect}} at exactly one point. [...] There {{is only one}} possible signal field that both has the correct intensity to match the <b>data</b> <b>trace</b> and fits the mathematical form dictated by the nonlinear interaction. [...] To find that point, which will give the pulse {{we are trying to}} measure, generalized projections is used. [...] The generalized projections algorithm operates in this electric field space. [...] At each step, we find the closest point to the current guess point that will satisfy the constraint for the other set. [...] That is, the current guess is “projected” onto the other set. [...] This closest point becomes the new current guess, and the closest point on the first set is found. [...] By alternating between projecting onto the mathematical constraint set and projecting onto the data constraint set, we eventually end up at the solution.|$|E
5000|$|<b>Data</b> <b>trace</b> ... Accesses {{to memory}} {{locations}} may be tracked, as limited by range (start and stop address) and access type (read or write).|$|E
50|$|If a {{development}} task requires a high measurement data throughput {{of up to}} 30 MByte/s, Vector’s VX1000 System {{can be used to}} access data over microcontroller-specific <b>data</b> <b>trace</b> and debug interfaces like JTAG, DAP, LFAST, RTP/DMM, Nexus AUX or AURORA.|$|E
40|$|In this paper, {{we present}} METRIC, an {{environment}} for determining memory inefficiencies by examining <b>data</b> <b>traces.</b> METRIC {{is designed to}} alter the performance behavior of applications that are mostly constrained by their latency to resolve memory references. The main contributions of this paper are as follows. First, we present methods to extract partial <b>data</b> <b>traces</b> from running applications by observing their memory behavior via dynamic binary rewriting. Second, we present a methodology to represent partial <b>data</b> <b>traces</b> in constant space for regular references by employing a novel technique for online compression of reference streams. Third, we employ offline cache simulation to derive indications about memory performance bottlenecks from partial <b>data</b> <b>traces.</b> By exploiting summarized memory metrics, by-reference metrics as well as cache evictor information, we can pin-point the sources of performance problems. Fourth, we demonstrate the ability to derive opportunities for optimizations and assess their benefits in several experiments resulting in up to 40 % lower miss ratios. 1...|$|R
30|$|An {{emulation}} {{technique that}} makes hardware <b>data</b> <b>tracing</b> realizable on commodity Intel processors with moderate performance overhead.|$|R
40|$|Abstract. fgN and fARIMA (0,d, 0) {{are two of}} {{the models}} {{frequently}} employed in Internet traffic. However, there is not a set of <b>data</b> <b>traces</b> available. In this work, a set of 187 fGN <b>data</b> <b>traces</b> each one of 64 KPoints were generated with three tools: S-Plus, SelQoS; and a fGN-MatlabScript; and a cumulative analysis with 1144 files was done. From this study, it is concluded that the best algorithms respect to the Minimum Mean Squared Error (MMSE) for Hurst index estimates were Modified Allan Variance in time domain far followed for R/S statistic, while in frequency domain Periodogram presented the MMSE followed very close for Local Whittle. A set of 53 “well-behaved ” <b>data</b> <b>traces</b> with different theoretical values H T were obtained and will be publicly available. The fGN <b>data</b> <b>traces</b> generated by our tool SelQoS compared with those generated with S-Plus, fGN, fARIMA (0, d, 0), and fGN-MatlabScript showed the best performance relative to MSE. For all data generation methods, the higher H is, the bigger MSE is...|$|R
5000|$|Data {{acquisition}} ... Rapid prototyping {{may require}} rapid transfer of {{large amounts of}} data via the auxiliary port to the debug tools. It uses a more efficient protocol than that used in <b>data</b> <b>trace.</b> It also helps calibration in automotive applications.|$|E
5000|$|A core trace {{provides}} detailed {{visibility of}} the program execution on an embedded core. Trace data are generated for the instruction execution sequence (sometimes referred to as instruction trace) and/or data transfers (sometimes referred to as <b>data</b> <b>trace).</b> A SoC may contain several core traces.|$|E
50|$|Most early potentiostats could {{function}} independently, providing {{data output}} through a physical <b>data</b> <b>trace.</b> Modern potentiostats {{are designed to}} interface with a personal computer and operate through a dedicated software package. The automated software allows the user rapidly to shift between experiments and experimental conditions. The computer allows data to be stored and analyzed more effectively, rapidly, and accurately than historic methods.|$|E
40|$|Capturing {{program and}} <b>data</b> <b>traces</b> during program {{execution}} unobtrusively in real-time {{is crucial in}} debugging and testing of cyber-physical systems. However, tracing a complete program unobtrusively is often cost-prohibitive, requiring large on-chip trace buffers and wide trace ports. Whereas program execution traces can be efficiently compressed in hardware, compression of data address and <b>data</b> value <b>traces</b> is much more challenging due to limited redundancy. In this paper we describe two hardwarebased filtering techniques for data traces: cache first-access tracking for load data values and data address filtering using partial register-file replay. The results of our experimental analysis indicate that the proposed filtering techniques can significantly {{reduce the size of}} the <b>data</b> <b>traces</b> (~ 5 - 20 times for the load <b>data</b> value <b>trace,</b> depending on the data cache size; and ~ 5 times for the <b>data</b> address <b>trace)</b> at the cost of rather small hardware structures in the trace module...|$|R
30|$|The {{objective}} of experiment 1 is {{to evaluate the}} impact of different nodes and throughput by considering relative speed of vehicles based on real <b>data</b> <b>traces.</b>|$|R
30|$|A novel design named DTrace that {{incorporates}} hardware instruction <b>tracing</b> mechanism into <b>data</b> integrity protection which realizes hardware <b>data</b> <b>tracing</b> and provides fine-grained and efficient data integrity guarantee.|$|R
5000|$|... Embedded Trace Module (ETM), 40 bits (7 bit address, one 32-bit long data word, and a R/W bit) used {{to control}} the {{operation}} of a passive instruction and <b>data</b> <b>trace</b> mechanism. This feeds either an on-chip Embedded Trace Buffer (ETB), or an external high speed trace data collection pod. Tracing supports passive debugging (examining execution history) and profiling for performance tuning.|$|E
50|$|A trace is a {{sequence}} of instructions, including branches but not including loops, that is executed for some input <b>data.</b> <b>Trace</b> scheduling uses a basic block scheduling method to schedule the instructions in each entire trace, beginning with the trace with the highest frequency. It then adds compensation code at the entry and exit of each trace to compensate for any effects that out of order execution may have had.|$|E
5000|$|Abdeslam {{bought a}} SIM card at the Place Albert Kahn in the 18th {{arrondissement}} at about 22:00 hours. He phoned a detainee at Namur prison, Abdheila Chouaa, who was closely acquainted with Mohamed Abrini. [...] Abdeslam {{then made a}} phone call to associates in Brussels, requesting they drive to him in order to help him escape. He was heard crying {{at the time of the}} call. [...] He wandered the streets for a period of approximately seven to nine hours until he was collected at approximately 07:00 hours. [...] A <b>data</b> <b>trace</b> of the aforementioned call shows Abdeslam was in Montrouge at the time, and that the call was received by a cell site in Châtillon, likely either Châtillon-la-Borde or Châtillon, Hauts-de-Seine.|$|E
40|$|This paper {{introduces}} a novel technique {{to construct an}} empirical model fitting time-varying (transient) <b>trace</b> <b>data.</b> The <b>trace</b> is a categorical or numerical time-series. The modeling technique described in this paper first builds a Mass Evolution Graph (MEG) from the <b>trace</b> <b>data.</b> Linear regression is then used to construct a time-dependent probability mass function (pmf) for each state in the <b>trace</b> <b>data...</b>|$|R
40|$|<b>Data</b> <b>traces</b> everywhere? Which <b>data</b> do {{customers}} leave {{during an}} ordinary e-shopping session {{and who will}} have access to this data? Naturally customers disclose some kind of payment information to the shop (service provider) as well as their shipping address when goods have to be delivered. However, users involuntarily leave many additional <b>data</b> <b>traces.</b> In a classical e-shopping scenario, data about the customer’s shopping habits and interests are exposed at the merchant’s and payment institute’s sides. Utilising cookies, the service provider is able to identify users at their next visit and can display offers matching thei...|$|R
30|$|As we {{surveyed}} the literature, we observed that numerous works relied on synthetic data, particularly in resource and fault management, network security, and QoE/QoS correlation. Synthetic datasets are usually simplistic {{and do not}} truly reflect the complexity of real-world settings. This is not surprising, since obtaining real-world <b>data</b> <b>traces</b> is difficult due to the critical and private nature of network traffic, especially the payload. Furthermore, establishing the ground truth is particularly challenging, given the voluminous amount of traffic making any manual inspection intractable. Although injecting faults and, or attacks in the network can help produce the required data as adopted by [285], {{it is unrealistic to}} jeopardize a production network for the sake of generating training data. Such limitations increase the probability of ML techniques being ill-trained and inapplicable in real-world network settings. Thus, it remains unclear how the numerous works in the literature would perform over real <b>data</b> <b>traces.</b> Therefore, a combined effort from both academia and industry is needed, to create public repositories of <b>data</b> <b>traces</b> annotated with ground truth from various real networks.|$|R
50|$|These {{two sets}} {{intersect}} at exactly one point. There {{is only one}} possible signal field that both has the correct intensity to match the <b>data</b> <b>trace</b> and fits the mathematical form dictated by the nonlinear interaction. To find that point, which will give the pulse {{we are trying to}} measure, generalized projections is used. The generalized projections algorithm operates in this electric field space. At each step, we find the closest point to the current guess point that will satisfy the constraint for the other set. That is, the current guess is “projected” onto the other set. This closest point becomes the new current guess, and the closest point on the first set is found. By alternating between projecting onto the mathematical constraint set and projecting onto the data constraint set, we eventually end up at the solution.|$|E
50|$|The TCP/IP script {{generator}} {{is unique}} to WSim and was introduced in December 2015. It processes a TCP/IP trace dataset produced by the WSim-supplied TCP/IP Trace Utility (ITPIPTRX), which invokes the z/OS Communication Server real-time, application-controlled TCP/IP trace Network Management Interface (NMI) to capture TCP/IP <b>data</b> <b>trace</b> records. These trace records contain HTTP messages (packets and data) exchanged between a server and client. The TCP/IP script generator (ITPIPGEN) then processes this trace dataset and creates a script, in the STL language, which replicates the communication that occurred between the server and client. After translation from STL into the WSim language and when running the simulation (ITPENTER), the generated script sends the client messages - obtained from the trace - to the server port, and waits to receive {{a message from the}} server. A separate utility (ITPIPFMT) is also supplied to format and print the contents of the trace dataset created by the TCP/IP Trace Utility (ITPIPTRX).|$|E
30|$|The {{recorded}} <b>data</b> <b>trace</b> {{must be kept}} {{secure from}} memory corruption exploits in user mode.|$|E
5000|$|... #Caption: Typical TOFD data, {{created by}} {{aligning}} the <b>data</b> <b>traces</b> {{from the above}} figure vertically and colour-coding them for amplitude. The defect or discontinuity creates a characteristic parabolic indication, due to the apparent change in depth as the probes travel.|$|R
40|$|Abstract. A {{scalable}} {{approach to}} performance analysis of MPI applications is presented that includes automated source code instrumentation, low overhead generation of profile and <b>trace</b> <b>data,</b> and database management of performance data. In addition, tools are described that analyze large-scale parallel profile and <b>trace</b> <b>data.</b> Analysis of <b>trace</b> <b>data</b> is done using an automated pattern-matching approach. Examples {{of using the}} tools on large-scale MPI applications are presented. ...|$|R
40|$|Fast {{and robust}} Hurst {{parameter}} estimation of traffic <b>data</b> <b>traces</b> tops {{the bill of}} nowadays problems {{of the field of}} traffic engineering. Almost every existent approach fits up the goal of as far as possible precise H parameter estimation; however this option is not as necessary as approximate estimation of boundaries of H parameter if traffic demonstrates long range dependence. Often this is the satisfactory condition for defining adequate traffic engineering operations. In this paper we verify a possibility of heuristic H parameter estimation algorithm which is based on wavelet transform of fractional Brownian motion synthesized <b>data</b> <b>traces,</b> and forthcoming operating with neural network learning capabilities. In this paper algorithm is described. Experimental data are depicted and future research subjects are pointed...|$|R
40|$|Increasing {{disparity}} between processor speeds and memory access times {{is a major}} problem in today’s systems. In this paper we have studied the design of a proposed system i. e. An Application specific <b>Data</b> <b>Trace</b> Cache and have tried to do some modification to the Data Remapping portion of it. We have tried to further improve the benefits of this system by implementing this system {{with the help of an}} already existing concept of Cache Conscious Data Structures. Reference locality of data can be improved by changing a program’s data organization and layout. This is the concept behind both cache conscious data structures as well as <b>Data</b> <b>Trace</b> Cache. So we have tried to merge both these strategies to get some more performance benefits...|$|E
30|$|In {{the current}} implementation, {{we assume that}} an {{observation}} refers to a 1 -week <b>data</b> <b>trace</b> (including weekend), because it represents a typical consumption cycle of inhabitants. One week of data at a 30 -min granularity implies that an input trace contains 336 data samples for each variable.|$|E
40|$|Benefits of {{advances}} in processor technology {{have long been}} held hostage to the widening processor-memory gap. Off-chip memory access latency {{is one of the}} most critical parameters limiting system performance. Caches have been used as a way of alleviating this problem by reducing the average memory access latency. The memory bottleneck assumes greater significance for high performance computer architectures with high data throughput requirements such as network processors. This paper addresses the memory bottleneck with the goal of minimizing off-chip memory demand and average memory access latency by proposing the use of small application specific compiler-visible <b>data</b> <b>trace</b> caches. We focus on tree data structures which are responsible for a significant component of the memory traffic in several applications. We have observed that tree accesses create a simple to characterize trace of memory references and propose a <b>data</b> <b>trace</b> cache design to exploit the locality of reference in these data traces...|$|E
40|$|Capturing {{program and}} <b>data</b> <b>traces</b> during program {{execution}} unobtrusively on-the-fly {{is crucial in}} debug-ging and testing of cyber-physical systems. However, tracing a complete program unobtrusively is often cost-prohibitive, requiring large on-chip trace buffers and wide trace ports. This article describes a new hardware-based load data value filtering technique called Cache First-access Tracking. Coupled with an effective variable encoding scheme, this technique achieves a significant reduction of load <b>data</b> value <b>traces,</b> from 5. 86 to 56. 39 times depending on the data cache size, thus enabling cost-effective, unobtrusive on-the-fly tracing and debugging...|$|R
40|$|A typical {{step in the}} model-based {{evaluation}} of communication systems is to fit measured data to analytically tractable distributions. Due to the increased speed of today's networks, even basic measurements, such as logging the requests at a Web server, can quickly generate large <b>data</b> <b>traces</b> with millions of entries. Employing complex fitting algorithms on such traces can take {{a significant amount of}} time. In this paper, we focus on the Expectation Maximization-based fitting of heavy-tailed distributed data to hyper-exponential distributions. We present a data aggregation algorithm which accelerates the fitting by several orders of magnitude. The employed aggregation algorithm has been derived from a sampling stratification technique and adapts dynamically to the distribution of the data. We illustrate the performance of the algorithm by applying it to empirical and artificial <b>data</b> <b>traces...</b>|$|R
40|$|Robust Hurst {{parameter}} estimation of traffic <b>data</b> <b>traces</b> tops {{the bill of}} nowadays problems {{of the field of}} traffic engineering. Almost every going approach fits up the goal of as far as possible precise H {{parameter estimation}}; however this option is not as indispensable as approximate estimation of boundaries of H parameter if traffic demonstrates long range dependence. Constantly this is satisfactory condition for defining adequate traffic engineering operations. In this paper we verify a possibility of robust wavelet based H parameter estimation algorithm with ulterior traffic classification, which is based on wavelet transform of fractional Brownian motion synthesized <b>data</b> <b>traces,</b> and forthcoming wavelet coefficient clustering and operating with neural network learning capabilities. In this paper algorithm is described. Experimental data are depicted and future research subjects are pointed. Ill. 5, bibl. 1...|$|R
40|$|This work {{deals with}} {{generally}} questions of microwave connections. In work we found information about wire-less transfers dividend {{in line with}} frequence ray inclusive abstrakt of technology. Also there are general information about wireless transfer, used modulations and data security during the transfer. In praktical part we located concrete project of concept <b>data</b> <b>trace,</b> on which I worked and took part on realization...|$|E
40|$|Markov Modulated Posson Process (MMPP) {{is a good}} {{model of}} Internet traffic. We take an IP trace and fit an MMPP to it using an {{algorithm}} recently published in a Journal. It is observed that trace generated using the MMPP model of the original trace has a distribution similar to the original trace. This {{is seen in the}} form of a linear quantile-quantile plot. Average queuing delay with <b>data</b> <b>trace</b> as input is close to the average queuing delay with model generated trace as input at low loads. At high loads, queuing delay of original <b>data</b> <b>trace</b> is much greater than queuing delay of generated trace. This is because original trace has longer durations when arrival rate exceeds service rate. Lloyd-Max algorithm, commonly used in digital communications systems for non uniform quantization is used here to determine arrival rate at each state. Levels generated at the end of the sixth iteration of the Lloyd max algorithm are used as arrival rates. The resultant MMPP model is used to generate a traffic trace. This trace has a very different distributio...|$|E
40|$|Abstract. We fit a Hidden Markov Model (HMM) {{to patient}} arrivals data, input as a {{discrete}} <b>data</b> <b>trace,</b> collected over many months. The processing of the <b>data</b> <b>trace</b> {{makes use of}} a simple binning technique, followed by clustering, before it is input into the Baum-Welch algorithm, which estimates {{the parameters of the}} underlying Markov chain’s statetransition matrix. Upon convergence, the HMM is used to predict its own synthetic traces of patient arrivals, behaving as a fluid input model. Utilizing the Viterbi algorithm, one can decode the meaning of the hidden states of the HMM, further understanding the varying rate of patient arrivals at different times of the hospital schedule. The HMM is validated by comparing means, standard deviations and autocorrelation functions of raw and synthetic traces. Finally, an efficient set up is explored to provide optimal parameter initialization for the HMM, including choosing the number of hidden states. We conclude with a summary of our findings, comparing results with other work in the field, and proposals for future work. ...|$|E
40|$|Modeling the {{behavior}} of 802. 15. 4 links is a nontrivial problem, because 802. 15. 4 links experience different level of dynamics at short and long time scales. This makes {{the design of a}} suitable model that combines the different dynamics at different time scales a nontrivial problem. We propose a novel multilevel approach, the M&M model, involving hidden Markov models (HMMs) and mixtures of multivariate Bernoullis (MMBs) for modeling the long and short time-scale behavior of wireless links from 802. 15. 4 test beds. We characterize the synthetic traces generated from our model of the wireless link in terms of the mean and variance of the packet reception rates from the <b>data</b> <b>traces,</b> comparison of distributions of run lengths, and conditional packet delivery functions of successive packet receptions (1 ’s) and losses (0 ’s). Our results show that when compared to the closest-fit pattern matching model in TOSSIM, the proposed modeling approach is able to mimic {{the behavior}} of the <b>data</b> <b>traces</b> quite closely, with differences in packet reception rates of the empirical and simulated traces of less than 1. 9 % on average and 6. 6 % in the worst case. Moreover, the simulated links from our proposed approach were able to account for long runs of 1 ’s and 0 ’s as observed in empirical <b>data</b> <b>traces...</b>|$|R
40|$|This {{paper is}} an {{analysis}} of program address <b>trace</b> <b>data</b> in a demand-paged computer system with a three-level staging hierarchy. Our primary objective is to explore the data both graphically and numerically, using methods that may be useful when other <b>data</b> <b>traces</b> become available. In addition, plausible point-process type models are fit to the data. Such an approach, combining data-analytic procedures with probability modeling, should prove useful in understanding program behavior and thus will aid in the rational design of complex computer systems...|$|R
40|$|Explaining and {{reasoning}} about processes which underlie observed black-box phenomena enables {{the discovery of}} causal mechanisms, derivation of suitable abstract representations and the formulation of more robust predictions. We propose to learn high level functional programs in order to represent abstract models which capture the invariant structure in the observed data. We introduce the π-machine (program-induction machine) [...] an architecture able to induce interpretable LISP-like programs from observed <b>data</b> <b>traces.</b> We propose an optimisation procedure for program learning based on backpropagation, gradient descent and A* search. We apply the proposed method to three problems: system identification of dynamical systems, explaining the behaviour of a DQN agent and learning by demonstration in a human-robot interaction scenario. Our experimental {{results show that the}} π-machine can efficiently induce interpretable programs from individual <b>data</b> <b>traces.</b> Comment: submitted to Neural Information Processing Systems 201...|$|R
