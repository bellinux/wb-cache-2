65|141|Public
5000|$|The Virtual <b>Instrumentation</b> <b>Tool</b> for the ESS (VITESS) is an {{open source}} {{software}} package for the simulation of neutron scattering experiments. The software is maintained and developed by the [...] Helmholtz-Zentrum Berlin für Materialien und Energie (HZB), the former Hahn-Meitner-Institur HMI, and available for Windows, Linux and Macintosh on the VITESS homepage. It is widely used for simulation of existing neutron scattering instruments {{as well as for}} the development of new instruments. VITESS was initiated by F. Mezei in 1998, closely followed by the first release of VITESS in 1999 and version 2 in 2001. The current version 3 including an X3D visualization interface has been released in November 2012.|$|E
40|$|In this paper, {{we present}} Diabatik, a new, retargetable, {{open-source}} <b>instrumentation</b> <b>tool</b> {{that can be}} used to build program analysis tools for ARM, Alpha, i 386, IA 64 and MIPS binaries. Diabatik is built on top of Diablo, a retargetable link-time rewriting framework and offers the same user interface as ATOM – another widely used link-time <b>instrumentation</b> <b>tool</b> – to specify analysis tools. Moreover, it offers additional functionality to overcome ATOM’s limitations. 1...|$|E
40|$|While a {{large number}} of program {{profiling}} and instrumentation tools have been developed to support hardware and software analysis on general purpose systems, there is a general lack of sophisticated tools available for embedded architectures. Embedded systems are sensitive to performance bottlenecks, memory leaks, and software inefficiencies. There is a growing need to develop more sophisticated profiling and instrumentation tools in this rapidly growing design space. In this paper we describe, DSPInst, a binary <b>instrumentation</b> <b>tool</b> for the Analog Device’s Blackfin family of Digital Signal Processors (DSPs). DSPInst provides for fine-grained control over the execution of programs. <b>Instrumentation</b> <b>tool</b> users are able to gain transparent access to the processor and memory state at instruction boundaries, without perturbing the architected program state. DSPInst provides a platform for building a wide range of customized analysis tools at an instruction level granularity. To demonstrate the utility of this toolset, we provide an example analysis and optimization tool that performs dynamic voltage and frequency scaling to balance performance and power...|$|E
40|$|Robust and {{powerful}} software <b>instrumentation</b> <b>tools</b> are es-sential for dynamic program analysis {{tasks such as}} profiling, performance evaluation, and bug detection. Dynamic binary instrumentation (DBI) is a general purpose technique that eases the development of program analysis tools by facili-tating automatic low-level instrumentation. DBI-based pro-gram analysis can introduce high overhead and it is crucial for tool writers to minimize the cost. Analyzing the per-formance of <b>instrumentation</b> <b>tools</b> is challenging because most systems use a just-in-time compiler (JIT) to dynami-cally generate code. In this paper, we describe our method for analyzing the performance of <b>instrumentation</b> <b>tools.</b> The instrumented code is itself instrumented with basic block counters. We implement the profiler in Pin {{and use it to}} an-alyze the behavior of simple and complex <b>instrumentation</b> <b>tools.</b> The analysis yields several unexpected results about the dynamic behavior of instrumented programs. By exam-ining these results, we often find effective solutions to im-prove performance. 1...|$|R
40|$|The {{instrumentation}} {{of applications}} to generate run-time information and statistics {{is an important}} enabling technology {{for the development of}} tools that support the fast and accurate simulation of computer architectures. In addition, <b>instrumentation</b> <b>tools</b> play an equally important role in the optimization of applications...|$|R
5000|$|Different {{operating}} systems feature other similar or related <b>instrumentation</b> <b>tools,</b> offering similar or more advanced features; {{some of the}} tools (although using the same or a similar name) may use completely different work mechanisms, resulting in different feature sets or results. Such tools include the following: ...|$|R
3000|$|To {{show the}} {{feasibility}} of our approach, we implemented a prototype for the proposed self-adaptive fuzzing algorithm (as depicted in Fig. 1). Our implementation is based on Intel’s dynamic <b>instrumentation</b> <b>tool</b> Pin [26] to trace the reached basic blocks of a generated test case. In order to calculate the number E(x_ 0, I') of newly discovered basic blocks executed by a test case x [...]...|$|E
30|$|Progress in {{the modern}} {{biomedicine}} is governed by successful development of novel materials effectively exploring nanostructural atomistic and sub-atomistic length scales. That is why high-informative characterization probes are needed to engineer such biomaterials suitable for advanced medical practice. One {{of the most promising}} probes is grounded on analytical space-time continuum determination for electron interaction with its antiparticle (positron), this <b>instrumentation</b> <b>tool</b> being termed as positron annihilation lifetime (PAL) spectroscopy [1 – 3].|$|E
40|$|Abstract. This paper {{describes}} a dynamic <b>instrumentation</b> <b>tool</b> for the Linux Kernel which allows a stock Linux kernel to be modied while in ex-ecution, with instruments implemented as kernel modules. The Intel x 86 architecture poses a particular problem, due to variable length instruc-tions, which this paper addresses for the rst time. Finally {{we present a}} short case study illustrating its use in understanding i/o behaviour in the kernel. The source code is freely available for download. ...|$|E
40|$|Abstract: The C {{programming}} language is expressive and flexible, but not safe; as its expressive power and flexibility are obtained through unsafe language features, and improper {{use of these}} features can lead to program bugs whose causes are hard to identify. Since C is widely used, and it is impractical to rewrite all existing C programs in safe languages, so ways must be found to make C programs safe. This paper deals with the unsafe features of C and presents a survey on existing solutions to make C programs safe. We have studied binary-level <b>instrumentation</b> <b>tools,</b> source checkers, source-level <b>instrumentation</b> <b>tools</b> and safe dialects of C, and present a comparison of different solutions, summarized {{the strengths and weaknesses}} of different classes of solutions, and show measures that could possibly improve the accuracy or alleviate the overhead of existing solutions...|$|R
40|$|Among {{the many}} {{techniques}} in computer graphics, ray tracing is prized {{because it can}} render realistic images, albeit at great computational expense. In this note, the performance of several approaches to ray tracing on a distributed memory parallel system is evaluated. A set of performance <b>instrumentation</b> <b>tools</b> and their associated visualization software are used to identify {{the underlying causes of}} performance differences...|$|R
40|$|Technologies for SSTO and {{hypersonic}} atmospheric {{cruise flight}} being {{developed in the}} context of the National Aero-Space Plane (NASP) program are discussed. Emphasis is given to research in aerothermodynamics, propulsion, fuel technology, structures and materials, vehicle management systems, and CVD and <b>instrumentation</b> <b>tools.</b> Brief attention is also given to the X- 30 vehicle and to long-term applications of NASP technologies...|$|R
40|$|This paper {{presents}} a framework named Pin++. Pin++ is an object-oriented framework that uses template metaprogramming to implement Pintools, which are analysis tools for the dynamic binary <b>instrumentation</b> <b>tool</b> named Pin. The goal of Pin++ is to simplify programming a Pintool and promote reuse of its components across different Pintools. Our {{results show that}} Pintools implemented using Pin++ can have a 54 % reduction in complexity, increase its modularity, and up to 60 % reduction in instrumentation overhead...|$|E
40|$|This paper {{describes}} a dynamic <b>instrumentation</b> <b>tool</b> for the Linux Kernel which allows a stock Linux kernel to be modi ed while in execution, with instruments implemented as kernel modules. The Intel x 86 architecture poses a particular problem, due to variable length instructions, which this paper addresses for the rst time. Finally {{we present a}} short case study illustrating its use in understanding i/o behaviour in the kernel. The source code is freely available for download...|$|E
40|$|Web service {{technology}} {{will provide a}} platform for dynamic e-business applications. This paper describes a framework for identifying, monitoring and reporting performance data of critical transactions within a web service using the Java ARM standard, a Transaction Definition Language (TDL) and a bytecode <b>instrumentation</b> <b>tool.</b> The data extracted using this framework is shown to be appropriate for dynamically selecting web services based on performance metrics. A case study is provided using Gourmet 2 Go, an IBM demonstrator of a dynamic business-to-business (B 2 B) application...|$|E
40|$|The wide use of {{separate}} compilation and precompiled libraries among programmers poses {{a challenge to}} source-code based security and analysis tools such as CCured. These tools must understand enough {{of the behavior of}} precompiled libraries that they can prevent any unsafe use of the library. The situation is even more complicated for <b>instrumentation</b> <b>tools</b> that change the layout of data to accommodate array bounds or other metadata that is necessary for safety checking...|$|R
40|$|Programs often {{call the}} same {{function}} {{with the same}} arguments, yielding the same results. We call this phenomenon, “function reuse”. Previously, we have shown such a behavior {{for some of the}} SPEC 2000 integer benchmarks using HP ATOM <b>instrumentation</b> <b>tools.</b> However, this required extensive analysis by hand, and assumptions regarding side-effects caused by functions. In this paper, we modified a well-known architecture simulator, SimpleScalar, to analyze multiple benchmarks to investigate the function reuse behavior...|$|R
30|$|In the {{analyzing}} stage, analysts try {{to determine}} the location and root cause of captured violations. The analysis is often processed {{with the help of}} debuggers, like GDB, windbg, or other binary analysis tools, like IDA Pro, OllyDbg, etc. Binary <b>instrumentation</b> <b>tools,</b> like Pin (Luk et al. 2005), could also be used to monitor the exact execution state of collected testcases, such as the thread information, instructions, register information and so on. Automatically crash analysis is another important field of research.|$|R
40|$|An {{efficient}} and robust <b>instrumentation</b> <b>tool</b> (or compiler support) {{is necessary for}} an efficient implementation of fine-grain software-based shared memory systems (SW-DSMs). The DSZOOM system, developed by the Uppsala Architecture Research Team (UART) at Uppsala University, is a sequentially consistent fine-grained SW-DSM originally developed using Executable Editing Library (EEL) —a binary modification tool from University of Wisconsin-Madison. In this paper, we identify several weaknesses of this original approach and present a new and simple tool for assembler instrumentation: SPARC Assembler <b>Instrumentation</b> <b>Tool</b> (SAIT). This tool can instrument (modify) a highly optimized assembler output from the compiler for the newest UltraSPARC processors. Currently, {{the focus of the}} tool is load-, store-, and load-store-instrumentation. By using the SAIT, we develop and present several low-level instrumentation optimization techniques that significantly improve the performance of the original DSZOOM system. One of the presented techniques is a write permission cache (WPC), a latency-hiding mechanism for memory-store operations that can lower the instrumentation overheads for some applications (as much as 45 % for LU-cont, running on two nodes with eight processors each). Finally, we demonstrate that this new DSZOOM system executes faster than the old one for all 13 applications studied, from the SPLASH- 2 benchmark suite. Execution time improvement factors range from 1. 07 to 2. 82 (average 1. 73). ...|$|E
40|$|My {{research}} {{is in the}} area of Systems and High Performance Computing, specifically performance profiling of distributed and parallel programs. My approach combines static analysis with runtime data to map data centric performance information to program variables. This includes direct measurement for data metrics such as cache misses. It also examines an inclusive approach, variable blame, that analyzes all data flow that goes into the computation of a variable, which is utilized for time based metrics. My earlier research included work on the Dyninst project, a dynamic <b>instrumentation</b> <b>tool.</b> I specifically worked on optimizing instrumentation code, adding OpenMP functionality for binary analysis and instrumentation, and register liveness analysis for instrumented code...|$|E
40|$|Abstract—Most {{efforts at}} {{analyzing}} {{the behavior and}} perfor-mance of sensor network software have been simulation-based, but deployment in the field can bring about conditions that were unexpected, or just too hard to simulate. Thus monitoring the software in the field would be a valuable capability for engineering of sensor networks. We have developed a lightweight <b>instrumentation</b> <b>tool</b> for TinyOS, called LIMOW, that is deploy-able onto sensor hardware, is low cost in overhead, and is configurable and controllable {{in terms of how}} much it monitors and how much overhead is tolerable. We show both behavioral and timing results from our tool, and compare results with other monitoring approaches. I...|$|E
40|$|Software tracing {{techniques}} are well-established {{and used by}} <b>instrumentation</b> <b>tools</b> to extract run-time information for program analysis and debugging. Dynamic binary <b>instrumentation</b> as one <b>tool</b> instruments program binaries to extract information. Unfortunately, instrumentation causes perturbation that is unacceptable for time-sensitive applications. Consequently we developed DIME*, a tool for dynamic binary instrumentation that considers timing constraints. DIME* uses Pin and a rate-based server approach to extract information {{only as long as}} user-specified constraints are maintained. Due to the large amount of redundancies in program traces, DIME* reduces the instrumentation overhead by one to three orders of magnitude compared to native Pin while extracting up to 99 % of the information. We instrument VLC and PostgreSQL to demonstrate the usability of DIME*. Comment: 11 page...|$|R
40|$|International audienceIn {{this paper}} we give an {{overview}} of the results obtained after benchmarking <b>instrumentation</b> <b>tools</b> for the characterization of micro-optics within the EC Network of Excellence on Micro-Optics NEMO. After a call within the NEMO network six different partners decided to organize a round robin. In this paper we will give {{an overview of}} all the experimental values obtained in the 6 different round robins, then we will comment on these results by explaining the measurement differences and the uncertainties for all measurands...|$|R
40|$|The present paper {{presents}} {{the opinions of}} European Science teachers that explored the usability of virtual <b>instrumentation</b> <b>tools</b> and experiments in improving Science teaching and classroom achievement. After designing and applying virtual instrumentation based learning objects into classroom settings, teachers reflected upon the importance of using virtual instrumentation in their teaching, the educational components that improved due to the new teaching tools, the difficulties they encountered {{as well as on}} the improvements that would make in the following teaching situations based on virtual instrumentation...|$|R
40|$|Continuing recent {{architectural}} {{trends that}} rely on branch predictions, value predictions, speculative execution, and reuse of results from instruction execution, we investigate the reuse of results from previous function invocations. In this paper we show that for integer benchmarks, {{it is possible to}} eliminate some function invocations since the same function is executed repeatedly with the same arguments. We feel that along with compiler techniques such as function cloning and partial evaluations, dynamic, hardware based techniques to check if a function should be invoked or the results from a prior execution can be used will lead to dramatic performance gains. We use HP Alpha based <b>instrumentation</b> <b>tool</b> called ATOM in our experiments on SPEC 2000 integer benchmarks...|$|E
40|$|Abstract. An {{address decoder}} {{is a small}} {{hardware}} unit that uses an address to index and place the data into memory units including cache memories. In current CPU cache designs {{there is a single}} decoder unit which serves to place data into the cache. In this paper we describe a technique to reduce contention on CPU’s caches through the use of multiple address decoders. We argue that by using multiple decoding techniques better data placement can be achieved and the CPU cache can be better utilized. We present an overview of an <b>instrumentation</b> <b>tool</b> developed to collect fine-grained data traces and a technique for virtually splitting caches using separate address decoders. Our results demonstrate the feasibility and the impact of virtual cache splitting...|$|E
40|$|Chip multiprocessors are {{the next}} {{attractive}} {{point in the}} design space of future high performance processors. There is a growing need for simulation methodologies to determine the memory system requirements of emerging workloads in {{a reasonable amount of}} time. To explore the design space of a CMP memory hierarchy, this paper presents the use of binary instrumentation as an alternative to execution-driven and trace-driven simulation methodologies. Using the binary <b>instrumentation</b> <b>tool,</b> Pin, we present CMP$im to characterize cache performance of single-threaded, multi-threaded, and multi-programmed workloads at the speeds of 4 - 10 MIPS. For memory intensive single-threaded workloads, the cache performance reported by CMP$im is three orders of magnitude faster and within 4 % of an cycle-accurate x 86 performance model. 1...|$|E
40|$|A {{summary of}} the beam <b>instrumentation</b> <b>tools</b> in place dur ing the year 2000 {{commissioning}} run is given including the technical layout and the appearance on the user level, here mainly the RHIC control room. Experience from first usage is reported {{as well as the}} lessons we have learned during RHIC operation so far. Upgrades and changes com pared to the year 2000 systems are outlined. Described tools include beam position monitors (BPM), ionization profile monitors (IPM), beam loss monitors (BLM), bunch current measurements, luminosity monitors, tune meters and Schottky monitors...|$|R
40|$|The {{quality of}} beam {{diagnostics}} {{is very important}} in accel-erators for the optimization of machine paerformance and for the understanding of accelerator physics issues. Many examples of successful and outstanding beam instrumenta-tion at different accelerators will be shown highlighting the following aspects: ultimate measurement resolution in space and time ob-tained exploiting different detection principles clever use of standard <b>instrumentation</b> <b>tools</b> benefit for beam instrumentation obtained from intro-ducing digital signal treatment techniques. 1 GENERAL ASPECTS When preparing this presentation I often asked myself the question of the definition of a ”highlight ” of beam instru...|$|R
50|$|Test and automation—By using ETS in {{conjunction}} with virtual <b>instrumentation</b> programming <b>tools,</b> design and test engineers avoid custom software programming unrelated to device characterization, and can thereby accelerate test system development.|$|R
40|$|Abstract—We {{introduce}} a new hybrid <b>instrumentation</b> <b>tool</b> for dynamic application instrumentation called iProbe 1, which is flexible and has low overhead. iProbe takes a novel 2 -stage design, and offloads much of the dynamic instrumentation complexity to an offline compilation stage. It leverages standard compiler flags to introduce “place-holders ” for hooks in the program executable. Then it utilizes an efficient user-space “HotPatching ” mechanism which modifies the functions to be traced and enables execution of instrumented code in a safe and secure manner. In its eval-uation on a micro-benchmark and SPEC CPU 2006 benchmark applications, the iProbe prototype achieved the instrumentation overhead {{an order of magnitude}} lower than existing state-of-the-art dynamic instrumentation tools like SystemTap and DynInst. Index Terms—monitoring, tracing, hotpatching, production systems, low-overhea...|$|E
40|$|This thesis {{presents}} a novel technique and framework for decreasing instrumentation overhead in software systems that utilize dynamic binary instrumentation. First, we introduce a lightweight networking framework {{combined with an}} easily extensible BSON implementation as a heavy analysis routine replacement. Secondly, we bind instrumentation and analysis threads to non-overlapping cpu cores—allowing analysis threads to execute faster. Lastly, we utilize a lock-free buffering system {{to bridge the gap}} between instrumentation and analysis threads, and minimize the overhead to the instrumentation threads. Using this combination, we managed to write a dynamic binary <b>instrumentation</b> <b>tool</b> (DBI) in Pin using Pin++ that is almost 1100 % faster than its counterpart DBI tool with no buffering, and less than 500 % slower than a similar tool with no analysis routine. ...|$|E
40|$|Indiana University-Purdue University Indianapolis (IUPUI) This thesis {{presents}} a novel technique and framework for decreasing instrumenta- tion overhead in software systems that utilize dynamic binary instrumentation. First, we introduce a lightweight networking framework {{combined with an}} easily extensible BSON implementation as a heavy analysis routine replacement. Secondly, we bind instrumentation and analysis threads to non-overlapping cpu cores [...] allowing analysis threads to execute faster. Lastly, we utilize a lock-free buffering system {{to bridge the gap}} between instrumentation and analysis threads, and minimize the overhead to the instrumentation threads. Using this combination, we managed to write a dynamic binary <b>instrumentation</b> <b>tool</b> (DBI) in Pin using Pin++ that is almost 1100 % faster than its counterpart DBI tool with no buffering, and less than 500 % slower than a similar tool with no analysis routine...|$|E
40|$|In UWB imaging {{for breast}} cancer detection, breast-reflected RF signals are {{processed}} to create energy images. This method was validated with <b>instrumentation</b> <b>tools,</b> which must be replaced with integrated circuits. We compare two front-end architectures, Direct Conversion (DC) and Coherent Equivalent Time Sampling (CETS). We evaluate the effect—on energy maps and SCR/SMR metrics—of noise sources, phase inaccuracies and non-linearity. DC receiver is more sensitive to phase inaccuracies and so less robust than CETS receiver. The latter can work in time domain with UWB pulses, other than in frequency domain like the DC one, which reduces acquisition time without performance impac...|$|R
40|$|Dynamic binary {{instrumentation}} (DBI) is {{a powerful}} technique for analyzing the runtime behavior of software. While numerous DBI frameworks {{have been developed for}} general-purpose architectures, work on DBI frameworks for embedded architectures has been fairly limited. In this paper, we describe the design, implementation, and applications of the ARM version of Pin, a dynamic instrumentation system from Intel. In particular, we highlight the design decisions that are geared toward the space and processing limitations of embedded systems. Pin for ARM is publicly available and is shipped with dozens of sample plug-in <b>instrumentation</b> <b>tools.</b> It has been downloaded over 500 times since its release...|$|R
40|$|Within {{the field}} of aspect-oriented {{software}} development, testing can be discussed in two directions: (1) How can aspect technology help to build testing tools? (2) Which new requirements does aspect technology used in the system under test impose on the test strategy? In this paper we suggest to discuss both questions in combination. We discuss some prior work regarding each question and outline a perspective in which the application and also testing tools are smoothly developed using the same programming language and {{without the need for}} specialized <b>instrumentation</b> <b>tools.</b> From this perspective we derive some requirements concerning the aspect language used and also concerning the test method. 1...|$|R
