5|139|Public
25|$|One ArcGIS <b>Engine</b> <b>Runtime</b> or ArcGIS Desktop license per {{computer}} is necessary.|$|E
50|$|Wintermute Engine {{follows the}} {{object-oriented}} design philosophy. The game developers use the engine tools for building various game objects (actors, scenes, windows etc.) and assembling them together. Every game object {{is defined by}} its appearance (graphics, animations, captions, fonts) and by a script, which defines the underlying logic of a given game object and its responses to game events. All those game definitions are then interpreted by the <b>engine</b> <b>runtime</b> interpreter, which is otherwise completely independent on any actual game implementation.|$|E
50|$|The R-25 jet engine's {{specialty}} was {{the addition}} of a second fuel pump in the afterburning stage. Activating the ЦР(чрезвычайный режим - emergency mode) booster feature allows the engine to develop 96.8 kN of thrust under 4000 m of altitude. The limit of operation is 1 minute for dogfight practice and 3 minutes for an actual wartime emergency, as further use causes the engine to overheat and potentially explode. Use of CSR requires engine take-out inspection upon landing and every minute of its use counts as one full hour of <b>engine</b> <b>runtime</b> on the logbook.|$|E
5000|$|At second, it is {{a hybrid}} multithreaded {{dataflow}} <b>runtime</b> <b>engine</b> {{controlled by a}} von-Neumann front-end VM. The dataflow <b>runtime</b> <b>engine</b> executes tagged-token contextual parallel instructions (opposite to the restricted fork-join paradigm) while the von-Neumann front-end VM initializes contexts and feeds the dataflow <b>runtime</b> <b>engine</b> with marshaled clusters of instructions.|$|R
5000|$|Automated {{exception}} handling is a computing term {{referring to the}} computerized handling of errors. <b>runtime</b> systems (<b>engines)</b> such as those for the Java programming language or [...]NET Framework lend themselves to an automated mode of exception or error handling. In these environments software errors do not crash the operating system or <b>runtime</b> <b>engine,</b> but rather generate exceptions. Recent advances in these <b>runtime</b> <b>engines</b> enables specialized <b>runtime</b> <b>engine</b> add-on products to provide automated {{exception handling}} that is independent of the source code and provides root-cause information for every exception of interest.|$|R
50|$|Redistributable {{components}} to allow developers to package the <b>engines</b> and <b>runtime</b> with their application code {{to produce a}} single installable application.|$|R
5000|$|Some {{three-way}} {{catalytic converter}} systems have air injection systems with the air injected between the first (NOx reduction) and second (HC and CO oxidation) stages of the converter. As in two-way converters, this injected air provides oxygen for the oxidation reactions. An upstream air injection point, ahead of the catalytic converter, is also sometimes present to provide additional oxygen only during the engine warm up period. This causes unburned fuel to ignite in the exhaust tract, thereby preventing it reaching the catalytic converter at all. This technique reduces the <b>engine</b> <b>runtime</b> needed for the catalytic converter to reach its [...] "light-off" [...] or operating temperature.|$|E
50|$|Upon exception, the <b>runtime</b> <b>engine</b> {{calls an}} error {{interception}} tool that {{is attached to}} the <b>runtime</b> <b>engine</b> (e.g., Java Virtual Machine (JVM)). Based {{on the nature of the}} exception such as its type and the class and method in which it occurred and based on user preferences, an exception can be either handled or ignored.|$|R
50|$|TIBCO built a <b>runtime</b> <b>engine</b> called TERR, {{which is}} part of Spotfire.|$|R
50|$|The Fork Particle SDK {{includes}} these components: {{real time}} particle <b>engine</b> (Fork <b>Runtime</b> SDK), particle editor or modeling tool (Fork Particle Studio), live update for in application particle effects editing (Fork Live Tuner), and particle effects definitions batch file exporter.|$|R
2500|$|In <b>runtime</b> <b>engine</b> environments such as Java or [...]NET, {{there exist}} tools that {{attach to the}} <b>runtime</b> <b>engine</b> and every time that an {{exception}} of interest occurs, they record debugging information that existed in memory {{at the time the}} exception was thrown (call stack and heap values). These tools are called automated exception handling or error interception tools and provide 'root-cause' information for exceptions.|$|R
50|$|The Flare3D {{platform}} {{consists of}} a 3D world editor, a <b>runtime</b> <b>engine,</b> {{and a collection of}} plug-ins for various applications.|$|R
5000|$|In <b>runtime</b> <b>engine</b> environments such as Java or [...]Net {{there exist}} tools that {{attach to the}} <b>runtime</b> <b>engine</b> and every time that an {{exception}} of interest occurs they record debugging information that existed in memory {{at the time the}} exception was thrown (stack and heap values). These tools are called Exception Interception and they provide [...] "root-cause" [...] information for exceptions in Java programs that run in production, testing, or development environments.|$|R
50|$|Open source BIRT {{consists}} of a designer and a <b>runtime</b> <b>engine</b> for generating report content that can be embedded into an application.|$|R
50|$|Exception {{handling}} is {{one language}} feature {{designed to handle}} runtime errors, providing a structured way to catch completely unexpected situations as well as predictable errors or unusual results without the amount of inline error checking required of languages without it. More recent advancements in <b>runtime</b> <b>engines</b> enable automated exception handling which provides 'root-cause' debug information for every exception of interest and is implemented independent of the source code, by attaching a special software product to the <b>runtime</b> <b>engine.</b>|$|R
50|$|The {{editor and}} <b>runtime</b> <b>engine</b> were {{originally}} designed for Windows operating systems; though the <b>runtime</b> <b>engine</b> has been ported to Android, iOS, Linux, Mac OS X and PSP since {{the release of}} the source code. Prior to AGS 2.7, a DOS engine was also available; this has since been discontinued. It is not yet possible to run the editor to create games on operating systems other than Windows without an emulator or API wrapper such as Wine.|$|R
5000|$|SILVIA Core: A <b>runtime</b> <b>engine</b> {{which can}} be {{configurable}} for use in any user, server, or mobile systems. It can also be embedded.|$|R
40|$|Abstract Parallel {{implementations}} {{of dynamic}} structured adaptive mesh refinement (SAMR) methods lead to significant runtime management challenges that can limit their scalability on large systems. This paper presents a <b>runtime</b> <b>engine</b> {{that addresses the}} scalability of SAMR applications with localized refinements and high SAMR efficiencies on large numbers of processors (upto 1024 processors). The SAMR <b>runtime</b> <b>engine</b> augments hierarchical partitioning with bin-packing based load-balancing to manage the space-time heterogeneity of the SAMR grid hierarchy, and includes a communication substrate that optimizes the use of MPI non-blocking communication primitives. An experimental evaluation on the IBM SP 2 supercomputer using the 3 -D Richtmyer-Meshkov compressible turbulence kernel demonstrates {{the effectiveness of the}} <b>runtime</b> <b>engine</b> in improving SAMR scalability. Keywords Structured adaptive mesh refinement · SAMR scalability · Hierarchical partitioning · Bin-packing based load-balancing · MPI non-blocking communication optimization · 3 -D Richtmyer-Meshkov applicatio...|$|R
5000|$|Data Management - {{consists}} of a data modeler, code generator, sample test application builder and <b>runtime</b> <b>engine</b> that supports real-time client synchronization and transaction processing.|$|R
50|$|The <b>runtime</b> <b>engine</b> is {{responsible}} to distribute the available jobs across the available systems. In a large scale HPC clusters, these can be heterogeneous and consist of traditional compute nodes as well as nodes with accelerator cards, such as GPUs or Intel's Xeon Phi. Besides the mere scheduling and distribution of jobs, the <b>runtime</b> <b>engine</b> is also adding fault-tolerance. Jobs are monitored {{after they have been}} assigned and reassigned to different ressources, in case the initially assigned hardware fails. New hardware can be added dynamically.|$|R
5000|$|BMDFM is a {{convenient}} parallel programming environment and an efficient <b>runtime</b> <b>engine</b> for multi-core SMP {{due to the}} MIMD unification of several architectural paradigms (von-Neumann, SMP and dataflow): ...|$|R
40|$|A common {{approach}} to configuration management is to couple a high-level declarative programming language with a <b>runtime</b> <b>engine.</b> The language {{is used to}} specify configurations and the engine is used to deliver and apply those configurations {{on a set of}} computing resources. The design and architecture of current <b>runtime</b> <b>engines</b> of configuration management systems lack 1) essential coordination and synchronization of actions between computing resources and 2) strong security mechanisms. This thesis examines a number of techniques that {{can be applied to the}} area of configuration management to address these limitations. In particular, the combination of these techniques leads to a new architecture for the <b>runtime</b> <b>engines</b> of modern configuration management systems, providing them with secure coordination and synchronization capabilities. A prototype of this new approach was developed and evaluated in an environment that simulates highly-demanding computing landscapes and the results show that the new architecture is able to reduce the occurrence and impacts of configuration errors in these environments...|$|R
50|$|The <b>runtime</b> <b>engine</b> executes the {{application}} components. It displays presentation components using the appropriate user interface connector (either GUI or character-based), and sends and receives data via a DBMS connector.|$|R
5000|$|Moscow ML is a {{light-weight}} implementation, {{based on}} the CAML Light <b>runtime</b> <b>engine.</b> It implements the full SML language, including SML Modules, {{and much of the}} SML Basis Library. http://www.itu.dk/people/sestoft/mosml.html ...|$|R
5000|$|Scripting {{languages}} are executed by their <b>runtime</b> <b>engine,</b> which {{is itself a}} service. For example, the Groovy language runtime will run a program contained in the file [...] with the following: ...|$|R
50|$|Java {{applications}} {{may only}} use a subset (The JRE Class White List) {{of the classes}} from the JRE standard edition. This restriction does not exist with the App <b>Engine</b> Standard Java8 <b>runtime.</b>|$|R
3000|$|PaaS {{facilitates}} {{deployment of}} cloud-based applications without {{the cost of}} buying and maintaining the underlying hardware and software layers [21]. As with SaaS and IaaS, PaaS depends on a secure and reliable network and secure web browser. PaaS application security comprises two software layers: Security of the PaaS platform itself (i.e., <b>runtime</b> <b>engine),</b> and Security of customer applications deployed on a PaaS platform [10]. PaaS providers are responsible for securing the platform software stack that includes the <b>runtime</b> <b>engine</b> that runs the customer applications. Same as SaaS, PaaS also brings data security issues and other challenges that are described as follows: [...]...|$|R
50|$|On 26 October 2010, Chris Jones {{released}} the source code for the editor {{under the terms}} of the Artistic License, version 2. On 27 April 2011, the <b>runtime</b> <b>engine</b> code was released under the same licence.|$|R
50|$|Zend Engine is used {{internally}} by PHP as a compiler and <b>runtime</b> <b>engine.</b> PHP Scripts {{are loaded}} into memory and compiled into Zend opcodes. These opcodes are executed and the HTML generated {{is sent to}} the client.|$|R
5000|$|At third, it is {{a hybrid}} of static and dynamic parallelization. The von-Neumann {{front-end}} VM tries statically to split an application into parallel marshaled clusters of instructions while the dataflow <b>runtime</b> <b>engine</b> compliments to the static parallelization methods dynamically.|$|R
5000|$|SQL CLR or SQLCLR (SQL Common Language Runtime) is {{technology}} for hosting of the Microsoft [...]NET common language <b>runtime</b> <b>engine</b> within SQL Server. The SQLCLR allows managed code to be hosted by, and run in, the Microsoft SQL Server environment.|$|R
50|$|This {{mechanism}} {{enables the}} automated handling of software errors {{independent of the}} application source code and of its developers. It is a direct artifact of the <b>runtime</b> <b>engine</b> paradigm and it enables unique advantages to the software lifecycle that were unavailable before.|$|R
50|$|Crank Software {{began in}} 2007. The {{first version of}} Storyboard Suite was {{released}} in November 2009. This version contains an Eclipse-based User Interface development tool and a <b>runtime</b> <b>engine</b> for the target system. It has been under active development since with releases every few months.|$|R
5000|$|DataScene is a {{scientific}} graphing, animation, data analysis, and real-time data monitoring software package. It was developed with the Common Language Infrastructure {{technology and the}} GDI+ graphics library. With the two Common Language <b>Runtime</b> <b>engines</b> - the [...]Net and Mono frameworks - DataScene runs on all major operating systems.|$|R
5000|$|In implementation, all [...]NET {{programming}} languages {{share the}} same <b>runtime</b> <b>engine,</b> uniform abstract syntax tree, and Common Intermediate Language. Additionally all [...]NET languages have access to platform features including garbage collection, cross language inheritance, exception handling, and debugging. This allows the same output binary to be produced from any [...]NET programming language.|$|R
40|$|The {{purpose of}} the Dual Compile Strategy is to {{increase}} our trust in the Compute Engine during its execution of instructions. This is accomplished by introducing a heterogeneous Monitor Engine that checks {{the execution of the}} Compute Engine. This leads to the production of a second and custom set of instructions designed for monitoring the execution of the Compute <b>Engine</b> at <b>runtime.</b> This use of multiple engines differs from redundancy in that one engine is working on the application while the other engine is monitoring and checking in parallel instead of both applications (and engines) performing the same work at the same time...|$|R
