335|789|Public
2500|$|Lisp deeply {{influenced}} Alan Kay, {{the leader}} of the research team that developed Smalltalk at Xerox PARC; and in turn Lisp was influenced by Smalltalk, with later dialects adopting object-oriented programming features (inheritance classes, encapsulating instances, message passing, etc.) in the 1970s. [...] The Flavors object system introduced the concept of multiple inheritance and the mixin. The Common Lisp Object System provides multiple inheritance, multimethods with multiple dispatch, and first-class <b>generic</b> <b>functions,</b> yielding a flexible and powerful form of dynamic dispatch. It has served as the template for many subsequent Lisp (including Scheme) object systems, which are often implemented via a metaobject protocol, a reflective metacircular design in which the object system is defined in terms of itself: Lisp was only the second language after Smalltalk (and {{is still one of the}} very few languages) to possess such a metaobject system. Many years later, Alan Kay suggested that as a result of the confluence of these features, only Smalltalk and Lisp could be regarded as properly conceived object-oriented programming systems.|$|E
50|$|<b>Generic</b> <b>Functions</b> {{are also}} a first class data type. There are many more {{features}} to <b>Generic</b> <b>Functions</b> and Methods than described above.|$|E
50|$|New Flavors {{replaced}} message sending with calling <b>generic</b> <b>functions.</b>|$|E
5000|$|Define a <b>generic</b> <b>function</b> {{with two}} {{parameters}} object-1 and object-2. The {{name of the}} <b>generic</b> <b>function</b> is collide. (defgeneric collide (object-1 object-2)) ...|$|R
5000|$|... is a <b>generic</b> <b>function</b> {{with one}} {{argument}} {{that uses the}} [...] method combination. This combination determines that all applicable methods for a <b>generic</b> <b>function</b> will be called and {{the results will be}} added.|$|R
50|$|In {{computer}} programming, a <b>generic</b> <b>function</b> is {{a function}} defined for polymorphism.|$|R
50|$|Classes {{are similar}} to structures, but offer more dynamic {{features}} and multiple-inheritance. (See CLOS). Classes have been added late to Common Lisp {{and there is some}} conceptual overlap with structures. Objects created of classes are called Instances. A special case are <b>Generic</b> <b>Functions.</b> <b>Generic</b> <b>Functions</b> are both functions and instances.|$|E
5000|$|... <b>Generic</b> <b>functions</b> have {{infinite}} Dini derivatives {{at almost}} all points.|$|E
50|$|SKILL {{supports}} CLOS-like <b>generic</b> <b>functions</b> {{which are}} allowed to have an optional default implementation.|$|E
50|$|When a <b>generic</b> <b>function</b> is called, multiple-dispatch will {{determine}} the effective method to use.|$|R
40|$|AbstractWe compare {{different}} kinds of first-order models of objects and message passing, as found in object-oriented programming languages. We show that <b>generic</b> <b>function</b> models can easily simulate record models for static, class-based languages. We explore type systems for such languages, and show that our simulation preserves typing. Algebraic models emerge as abstractions of the <b>generic</b> <b>function</b> model that suppress details that are irrelevant for client code. Thanks to Todd Millstein for {{comments on an earlier}} draft, and for suggesting that we make our comparisons between the record and <b>generic</b> <b>function</b> models constructive, which greatly improved the paper. Thanks to Todd and Craig Chambers for many discussions about multimethod languages and their type systems...|$|R
40|$|A <b>generic</b> <b>function</b> {{is similar}} to an {{overloaded}} operator, but provides a way to select an appropriate behavior at run-time instead of compiletime. Dujardin and colleagues have proposed an algorithm for building and compressing <b>generic</b> <b>function</b> dispatch tables. We present several modifications to their algorithm, including an improvement to Pseudo-Closest-Poles and two new algorithms for compressing pole tables. The two new compression algorithms are simple and fast, and one produces smaller output than the original. ...|$|R
5000|$|... {{an object}} {{system based on}} CLOS with {{multiple}} inheritance, <b>generic</b> <b>functions,</b> multimethods and a MOP ...|$|E
5000|$|The macro [...] defines generic functions.The macro [...] defines methods. <b>Generic</b> <b>functions</b> are a {{collection}} of methods.|$|E
50|$|In {{order to}} {{estimate}} how often multiple dispatch is used in practice, Muschevici et al. studied programs that use dynamic dispatch. They analyzed nine applications, mostly compilers, written in six different languages: Common Lisp Object System, Dylan, Cecil, MultiJava, Diesel, and Nice. Their results show that 13-32% of <b>generic</b> <b>functions</b> use the dynamic type of one argument, while 2.7-6.5% of them use the dynamic type of multiple arguments. The remaining 65-93% of <b>generic</b> <b>functions</b> have one concrete method (overrider), and thus are not considered to use the dynamic types of their arguments. Further, the study reports that 2-20% of <b>generic</b> <b>functions</b> had two and 3-6% had three concrete function implementations. The numbers decrease rapidly for functions with more concrete overriders.|$|E
5000|$|Methods {{belonging}} to the <b>generic</b> <b>function</b> are defined outside of classes.Here we define a method for the <b>generic</b> <b>function</b> collide which is specialized for the classes asteroid (first parameter object-1) and spaceship (second parameter object-2). The parameters are used as normal variables inside the method body. There is no special namespace that has access to class slots. (defmethod collide ((object-1 asteroid) (object-2 spaceship)) (format t [...] "asteroid ~a collides with spaceship ~a" [...] object-1 object-2)) ...|$|R
5000|$|Selected methods {{from this}} list are then {{combined}} into an effective method {{using the method}} combination used by the <b>generic</b> <b>function.</b>|$|R
5000|$|... message {{now is a}} <b>generic</b> <b>{{function}},</b> {{an object}} and function in its own right. Individual implementations of the message are called methods.|$|R
5000|$|Telcordia GR-833, TL1 Surveillance and Maintenance Messages {{contains}} the <b>generic</b> <b>functions</b> and messages that {{pertain to the}} following generic types of NEs: ...|$|E
50|$|<b>Generic</b> <b>functions</b> {{correspond}} roughly to what Smalltalk terms methods, {{with the}} notable exception that, in Smalltalk, the receiver's class is the sole determinant of which body of code is called: the types or values of the arguments are irrelevant (single dispatch). In a programming language with multiple dispatch when a generic function is called, method dispatch occurs {{on the basis of}} all arguments, not just one which is privileged. New Flavors also provided <b>generic</b> <b>functions,</b> but only single dispatch.|$|E
50|$|Bilateral {{transforms}} don't respect causality. They {{make sense}} when applied over <b>generic</b> <b>functions</b> but {{when working with}} functions of time (signals) unilateral transforms are preferred.|$|E
3000|$|We denote with y_tâˆˆR the {{observation}} at time t. We consider that {{the observation}} can be expressed by any <b>generic</b> <b>function</b> h(x [...]...|$|R
5000|$|... // <b>Generic</b> <b>{{function}}</b> for {{the minimum}} of one item function Min(X : ordered) return ordered is ... compute Y of type ordered ... return Y ...|$|R
5000|$|... sort is a <b>generic</b> <b>function</b> in the C++ Standard Library {{for doing}} {{comparison}} sorting. The function {{originated in the}} Standard Template Library (STL).|$|R
50|$|This {{technique}} {{is used by}} the DatabaseObjects library and it's set of <b>generic</b> <b>functions</b> to provide the mapping between a relational database and an object-oriented structure.|$|E
50|$|In some {{systems for}} {{object-oriented}} programming {{such as the}} Common Lisp Object System (CLOS) and Dylan, a generic function is an entity made up of all methods having the same name. Typically a generic function is an instance of a class that inherits both from function and standard-object. Thus <b>generic</b> <b>functions</b> are both functions (that can be called with and applied to arguments) and ordinary objects. The book The Art of the Metaobject Protocol explains the implementation and use of CLOS <b>generic</b> <b>functions</b> in detail.|$|E
5000|$|The Common Lisp Object System: An Overview by Richard P. Gabriel and Linda DeMichiel {{provides}} a good introduction to the motivation for defining classes by means of <b>generic</b> <b>functions.</b>|$|E
5000|$|... // <b>Generic</b> <b>{{function}}</b> for {{the minimum}} of N item function Min(X : ordered; ...) return ordered is result := Min(...) if X < result then result := X ...|$|R
40|$|We {{consider}} Bergman {{spaces and}} variations {{of them in}} one or several complex variables. For some domains we show that in these spaces the <b>generic</b> <b>function</b> is totally unbounded and hence non - extendable. We also show that the <b>generic</b> <b>function</b> is not - even locally - in Bergman spaces of higher order. Finally, in certain domains we consider the space of holomorphic functions whose derivatives up to some order extend continuously to {{the closure of the}} domain endowed with its natural topology. Generically, every function in this space is proven to be non - extendable, although bounded...|$|R
40|$|A <b>generic</b> <b>function</b> {{is a set}} of methods, all {{of which}} have {{equivalent}} semantics but each of which apply to different domains. This document describes how to augment the Scheme programming language with the capability to define multi-method genetic functions. Also described are optimization issues and areas of potentially fruitful future exploration. introduction A domain is the set of values over which a function is defined. A generic domain {{is a set of}} values of more than one type. An ad hoc genetic domain has subdomains that are related by their semantics rather than by having some common structure. A <b>generic</b> <b>function</b> is a single abstract operation that is defined over an ad hoc generic domain. To handle ad hoc generic domains, a single <b>generic</b> <b>function</b> can consist of several independent blocks of code with each block designed to handle different arguments, but with all blocks sharing a common name [1]. For example, many programming languages provide {{more than one way to}} represent numbers, and the code to add integers is different from the code to add reals, which is in turn different from the code to add complex numbers. However, every version of the addition function is usually represented by a single symbol: &quot;+&quot;. The compiler decides which version is appropriate by examining the arguments provided. When a <b>generic</b> <b>function</b> is defined by more than one body of code, each of the separately defined bodies is called...|$|R
5000|$|In New Flavors (a {{successor}} of Flavors) and CLOS, {{methods are}} organized in [...] "generic functions". These <b>generic</b> <b>functions</b> are functions that are defined in multiple cases (methods) by class dispatch and method combinations.|$|E
50|$|In {{functional}} programming, an anamorphism is a {{generalization of}} the concept of unfolds on lists. Formally, anamorphisms are <b>generic</b> <b>functions</b> that can corecursively construct a result of a certain type and which is parameterized by functions that determine the next single step of the construction.|$|E
5000|$|Methods in CLOS {{are grouped}} into <b>generic</b> <b>{{function}}s.</b> A generic function is an object which is callable like a function and which associates {{a collection of}} methods with a shared name and argument structure, each specialized for different arguments. Since Common Lisp provides non-CLOS classes for structures and built-in data types (numbers, strings, characters, symbols, ...), CLOS dispatch works also with these non-CLOS classes. CLOS also supports dispatch over individual objects (eql specializers). CLOS does not by default support dispatch over all Common Lisp data types (for example dispatch does not work for fully specialized array types or for types introduced by [...] ). However, most Common Lisp implementations provide a metaobject protocol which allows <b>generic</b> <b>functions</b> to provide application specific specialization and dispatch rules.|$|E
40|$|In {{this paper}} we propose a new means to model and operate on nested arrays that allows for a high level of {{abstraction}} without introducing a performance penalty. We achieve this by using a nesting structure on array types which allows us to shift the nesting information of arrays from the runtime representation level to the type system level. This information can then be exploited for <b>generic</b> <b>function</b> definitions on the nesting structure of arrays which, as we show, neatly integrates with subtyping based function overloading. Finally, we demonstrate for an example how nested arrays and <b>generic</b> <b>function</b> definitions can be fully stripped out using existing optimisation techniques. ...|$|R
40|$|This article {{presents}} the first {{elements of a}} <b>generic</b> <b>function</b> that assesses the capacity of technical multi-component systems to accomplish the assigned productive tasks from production planning. This assessment {{is based on the}} prognostics of their components. It must so be able to process inaccuracies and uncertainties of these prognostics. For its implementation the aimed function combines the Dempster-Shafer theory combined and Bayesian inferences. The paper presents the multi-component system modeling and the inferences for the different identified structures as well as a general algorithm. The final aim of the proposed <b>generic</b> <b>function</b> is to compute decision supports for cooperative maintenance and production management...|$|R
40|$|Abstract. Generic {{programming}} {{enables the}} programmer to define functions by induction {{on the structure}} of types. Defined once, such a <b>generic</b> <b>function</b> can be used to generate a specialized function for any user defined data type. Several ways to support generic programming in functional languages have been proposed, each with its own pros and cons. In this paper we describe a combination of two existing approaches, which has the advantages of both of them. In our approach overloaded functions with class variables of an arbitrary kind can be defined generically. A single generic definition defines a kind-indexed family of overloaded functions, one for each kind. For instance, the <b>generic</b> mapping <b>function</b> generates an overloaded mapping function for each kind. Additionally, we propose a separate extension that allows to specify a customized instance of a <b>generic</b> <b>function</b> for a type in terms of the generated instance for that type. ...|$|R
