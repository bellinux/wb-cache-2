219|498|Public
25|$|Insertion sort iterates, {{consuming}} one input element each repetition, {{and growing}} a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no <b>input</b> <b>elements</b> remain.|$|E
25|$|With a {{partitioning}} algorithm such as {{the ones}} described above (even with one that chooses good pivot values), quicksort exhibits poor performance for inputs that contain many repeated elements. The problem is clearly apparent when all the <b>input</b> <b>elements</b> are equal: at each recursion, the left partition is empty (no input values are less than the pivot), and the right partition has only decreased by one element (the pivot is removed). Consequently, the algorithm takes quadratic time to sort an array of equal values.|$|E
2500|$|Building a heap from {{an array}} of [...] <b>input</b> <b>elements</b> {{can be done by}} {{starting}} with an empty heap, then successively inserting each element. This approach, called Williams’ method after the inventor of binary heaps, is easily seen to run in [...] time: it performs [...] insertions at [...] cost each.|$|E
5000|$|Deletion time - time {{required}} for the update of the data structure when an <b>input</b> <b>element</b> is deleted; ...|$|R
5000|$|Insertion time - time {{required}} for the update of the data structure when one more <b>input</b> <b>element</b> is added; ...|$|R
50|$|A {{process is}} a series of transformations during transit, due to which the <b>input</b> <b>element</b> changes in place, position, shape, size, function, {{property}} or any other characteristic.|$|R
5000|$|Input transparency: In XSLT any <b>input</b> <b>elements</b> {{that are}} not {{specified}} by a transform rule are removed from the output. Tritium reverses this behavior: any <b>input</b> <b>elements</b> {{that are not}} specified by a transform rule are passed to the output unchanged.|$|E
50|$|HTML5 allows {{multiple}} file uploads {{using the}} multiple attribute on <b>input</b> <b>elements.</b>|$|E
5000|$|... <b>input</b> <b>elements</b> allow {{a variety}} of {{standard}} form controls to be implemented.|$|E
40|$|This paper {{proposes a}} {{modification}} {{to the traditional}} binary search algorithm in which it checks {{the presence of the}} <b>input</b> <b>element</b> with the middle element of the given set of elements at each iteration. Modified binary search algorithm optimizes the worst case of the binary search algorithm by comparing the <b>input</b> <b>element</b> with the first & last element of the data set along with the middle element and also checks the input number belongs to the range of numbers present in the given data set at each iteration there by reducing the time taken by the worst cases of binary search algorithm...|$|R
50|$|Some {{data-driven}} {{languages are}} Turing-complete, such as AWK and even sed, {{while others are}} intentionally very limited, notably for filtering. An extreme example of the latter is pcap, which only consists of filtering, with the only action being “capture”. Less extremely, sieve has filters and actions, but in the base standard has no variables or loops, only allowing stateless filtering statements: each <b>input</b> <b>element</b> is processed independently. Variables allow state, which allow operations that depend {{on more than one}} <b>input</b> <b>element,</b> such as aggregation (summing inputs) or throttling (allow at most 5 mails per hour from each sender, or limiting repeated log messages).|$|R
50|$|Another {{recognized}} {{problem is}} that, as a modal window, the dialog blocks all workflow {{in the program}} until it is closed. Users may not recognize that the dialog requires their attention, leading to confusion about the main window being non-responsive, or causing loss of the user's data input. This often happens in data entry forms after an error alert produced by invalid data. The preferred design include changing a visual aspect of the <b>input</b> <b>element</b> to reflect an invalid entry (such as applying a red border), or adding a character such as an asterisk next to the <b>input</b> <b>element</b> {{that needs to be}} corrected.|$|R
5000|$|A {{process is}} a set of transformations of <b>input</b> <b>elements</b> into products: {{respecting}} constraints, ...|$|E
5000|$|... {{composable}} <b>input</b> <b>elements</b> (html form elements) (library Graphics.Input), image elements (library Graphics.Element) and container elements ...|$|E
5000|$|Instead of web forms, you {{wrap the}} status signals of the <b>input</b> <b>elements</b> in a Request signal as input to Elm's Ajax Http.send ...|$|E
5000|$|The control {{positions}} {{a transparent}} (opacity = 0) <b>input</b> <b>element</b> in a containing [...] element {{with a background}} [...]png image of the clipboard icon. When the user gives focus to the input by left- or right-clicking it, tabbing etc. the control script gets the data that should be copied by calling the OnGetLiveClipboardData function. This callback function is implemented by the page developer and returns an instance of LiveClipboardClass containing the data that should be copied to the clipboard. Next, the control script serializes this data to the Live Clipboard XML format, which it sets as {{the value of the}} <b>input</b> <b>element</b> and selects.|$|R
5000|$|Building on the [...] {{function}}: the [...] function {{returns the}} value of the requested form element. For a 'text' input, the function will return the data contained in the element. For a 'select' <b>input</b> <b>element,</b> the function will return the currently selected value.$F("id_of_input_element") ...|$|R
30|$|Confidence can be {{propagated}} {{along an}} inference. In other words, given an <b>input</b> <b>element,</b> {{it is possible}} to calculate the probable confidence of the result of the inference. The discussion of this {{is beyond the scope of}} this paper, but the reader is referred to [24],[25].|$|R
50|$|One common {{exception}} is to enable or display additional user <b>input</b> <b>elements</b> {{that are only}} relevant if the checkbox is either checked or unchecked.|$|E
5000|$|The {{difference}} between pigeonhole sort and counting sort {{is that in}} counting sort, the auxiliary array does not contain lists of <b>input</b> <b>elements,</b> only counts: ...|$|E
5000|$|Operations {{organized}} {{according to}} a logic aimed at optimizing the attainment of specific products from the <b>input</b> <b>elements,</b> with the allocated resources and on compliance with the imposed constraints.|$|E
5000|$|In other words, the {{function}} value [...] in [...] (that is, the codomain) {{is always the}} same <b>input</b> <b>element</b> [...] of [...] (now considered as the domain). The identity function on [...] is clearly an injective function as well as a surjective function, so it is also bijective.|$|R
40|$|AbstractIterative {{learning}} (It-learning) is a Gold-style learning {{model in}} which each of a learner’s output conjectures may depend only upon the learner’s current conjecture and the current <b>input</b> <b>element.</b> Two extensions of the It-learning model are considered, each of which involves parallelism. The first is to run, in parallel, distinct instantiations of a single learner on each <b>input</b> <b>element.</b> The second is to run, in parallel, n individual learners incorporating the first extension, and to allow the n learners to communicate their results. In most contexts, parallelism is only a means of improving efficiency. However, as shown herein, learners incorporating the first extension are more powerful than It-learners, and, collective learners resulting from the second extension increase in learning power as n increases. Attention is paid to how one would actually implement a learner incorporating each extension. Parallelism is the underlying mechanism employed...|$|R
40|$|Transformation {{rules are}} often used to {{implement}} compilers for domain-specific languages. In an ideal situation, each transformation rule is a modular unit transforming one <b>input</b> <b>element</b> of the source program into a new element of the output program. However, in practice, transformation rules must be written which take one <b>input</b> <b>element</b> and produce several new elements belonging to various locations in the output program, the so-called local-to-global transformations. The implementation of such transformations is very complex and tightly coupled which imposes severe constraints on maintenance and evolvability. In this paper, we propose a transformation architecture on top of rewrite rules to loosen this coupling. The resulting transformation system combines the simplicity and modularity properties of rewrite rules with a new semi-automatic composition system that enables the implementation of local-to-global transformations without hampering maintenance and future evolutions...|$|R
50|$|This {{definition}} {{requires a}} process description {{to include the}} Constraints, Products, Resources, <b>Input</b> <b>Elements</b> and Transformations. This leads to the CPRET acronym {{to be used as}} name and mnemonic for this definition.|$|E
5000|$|Dynamic content: dynamic pages {{which are}} {{returned}} {{in response to}} a submitted query or accessed only through a form, especially if open-domain <b>input</b> <b>elements</b> (such as text fields) are used; such fields are hard to navigate without domain knowledge.|$|E
50|$|The CPRET formalized {{definition}} systematically {{addresses the}} <b>input</b> <b>Elements,</b> Transformations, and Products {{but also the}} other essential components of a Process, namely the Constraints and Resources. Among the resources, note the specificity of the Resource-Time component which passes inexorably and irreversibly, with problems of synchronization and sequencing.|$|E
5000|$|The {{product of}} any two <b>input</b> vector <b>elements</b> has at most 2n/2k bits; ...|$|R
25|$|A grid view, however, can be mimicked {{by using}} a {{standard}} HTML table with each cell containing a text <b>input</b> <b>element.</b> A tree view could also be mimicked through nested tables or, more semantically appropriately, nested lists. In both cases, a server-side process is responsible for processing the information, while JavaScript handles the user-interaction. Implementations of these interface elements are available through JavaScript libraries such as jQuery.|$|R
5000|$|Legacy DOM {{was limited}} {{in the kinds}} of {{elements}} that could be accessed. Form, link and image elements could be referenced with a hierarchical name that began with the root document object. A hierarchical name could make use of either the names or the sequential index of the traversed elements. For example, a form <b>input</b> <b>element</b> could be accessed as either [...] or [...]|$|R
50|$|Insertion sort iterates, {{consuming}} one input element each repetition, {{and growing}} a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no <b>input</b> <b>elements</b> remain.|$|E
5000|$|Building a heap from {{an array}} of [...] <b>input</b> <b>elements</b> {{can be done by}} {{starting}} with an empty heap, then successively inserting each element. This approach, called Williams’ method after the inventor of binary heaps, is easily seen to run in [...] time: it performs [...] insertions at [...] cost each.|$|E
50|$|A {{process may}} {{be defined as a}} set of transformations of <b>input</b> <b>{{elements}}</b> into output elements with specific properties, with the transformations characterized by parameters and constraints, such as in manufacturing or biology. A process may also be defined as the workflows and sequence of events inherent in processes such as manufacturing, engineering and business processes.|$|E
40|$|The {{invention}} {{relates to}} an interferometric element comprising a first interferometer of the Mach-Zehnder type {{and a second}} interferometer of the Mach-Zehnder type, said first interferometer comprising a first <b>input</b> coupling <b>element</b> and a first output coupling element, and said second interferometer comprising a second <b>input</b> coupling <b>element</b> and a second output coupling <b>element,</b> said <b>input</b> coupling <b>elements</b> being optically connected to the output coupling elements by means of transmission lines, such that {{for each of the}} output coupling elements at least one delayed transmission line from among the respective associated transmission lines is designed for providing a frequency-dependent phase shift that differs from the frequency-dependent phase shift of the or each of the other, non-delayed transmission lines connected to the relevant output coupling element,; while {{at least one of the}} transmission lines in the interferometric element is designed for providing an additional, frequency-independent phase shift, wherein the first and the second interferometer are optically coupled to one another cross-wise such that at least one transmission line of the first <b>input</b> coupling <b>element</b> is connected to the second output coupling element, and that at least one transmission line of the second <b>input</b> coupling <b>element</b> is connected to the first output coupling element. Furthermore, the invention relates to an N-stage tree element comprising the interferometric elements and to the use of the element...|$|R
50|$|As an example, {{consider}} the sorting algorithms selection sort and insertion sort: Selection sort repeatedly selects the minimum element from the unsorted remainder {{and places it}} at the front, which requires access to the entire input; it is thus an offline algorithm. On the other hand, insertion sort considers one <b>input</b> <b>element</b> per iteration and produces a partial solution without considering future elements. Thus insertion sort is an online algorithm.|$|R
40|$|A {{compatible}} chord {{code for}} <b>inputting</b> <b>elements</b> of Chinese characters (ECC) to computer was proposed, it capitalized on the graphic compatibility between ECC and chord combination of keys (CCK) on a single-handed chord keyboard with five keys. Experimental {{results showed that}} the proposed compatible chord code was better than a code that randomly mapped ECC onto CCK with respect to learning time and response time. Explicit indication of the graphic compatibility between ECC and CCK did not enhance memorizing the compatible code. A compatible chord code for <b>inputting</b> <b>elements</b> of Chinese characters (ECC) to computer was proposed, it capitalized on the graphic compatibility between ECC and chord combination of keys (CCK) on a single-handed chord keyboard with five keys. Experimental {{results showed that the}} proposed compatible chord code was better than a code that randomly mapped ECC onto CCK with respect to learning time and response time. Explicit indication of the graphic compatibility between ECC and CCK did not enhance memorizing the compatible code. (C) 2001 Elsevier Science Ltd. All rights reserved...|$|R
