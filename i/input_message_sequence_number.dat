0|7767|Public
30|$|The first type of loophole: In the NACR mode, {{randomly}} {{changing the}} value of the <b>message</b> <b>sequence</b> <b>number</b> “Ksn” and the random number will make the protocol lose synchronization, resulting in unexpected authentication failure of the protocol. The attacker “I” observed that in the continuous NACR mode, the <b>message</b> <b>sequence</b> <b>number</b> “Ksn” will increase by one when the slave sends a new NACR request. The attacker “I” can tamper with the <b>sequence</b> <b>number</b> “Ksn” of the challenge message sent from the station “O”, posing as a station “O” and sending it to the master station “M” to induce the master station to generate an incorrect message authentication code, which results in failure of the message authentication. Figure  2 gives the MSC model of this attack behaviour.|$|R
50|$|The {{protocol}} may be initialized {{by sending}} bogus messages and acks with <b>sequence</b> <b>number</b> 1. The first <b>message</b> with <b>sequence</b> <b>number</b> 0 {{is a real}} message.|$|R
30|$|The third type of loophole: By {{observing a}} large amount of {{information}} in the plaintext challenge, the attacker “I” replays the AGM active request message “Old_AGMRQ” intercepted in the previous rounds of sessions to the station “O” when it finds the challenge information with the same <b>message</b> <b>sequence</b> <b>number</b> “Ksn”. This loophole caused station “O” to perform unauthorized critical operations. Figure  4 shows the MSC model of this attack behaviour.|$|R
30|$|The {{second type}} of loophole: By observing {{a large amount of}} {{information}} in the cleartext challenge, the attacker “I” can replay the message authentication code “tag_old” intercepted in the previous rounds of the session to the station “O” to trigger the execution of false orders “Prented_RSP” when finding the challenge information with the same <b>message</b> <b>sequence</b> <b>number</b> “Ksn” and random number. Figure  3 shows the MSC model of this attack behaviour.|$|R
50|$|Library {{provides}} UDP session management (connect, disconnect, keep-alives, {{sliding window}} for <b>messages</b> and <b>message</b> <b>sequence</b> <b>numbers)</b> and supports {{any number of}} concurrent sessions. Library contains standard Intelligent Platform Management Interface encryption algorithms for authentication (RAKP-HMAC-SHA1), integrity (HMAC-SHA1-96) and confidentiality (AES-CBC-128), however additional algorithms can be provided. Library contains encoders and decoders for event log, sensor values and hardware information (FRU - Field Replaceable Unit). Library can be extended with additional, user-defined encoders.|$|R
5000|$|Each <b>message</b> has a <b>sequence</b> <b>number</b> {{that protects}} the network against replay attacks.|$|R
50|$|The Web Service Conversation Language (WSCL) {{proposal}} {{defines the}} overall <b>input</b> and output <b>message</b> <b>sequences</b> for one web service using a finite state automaton FSA over the alphabet of message types.|$|R
5000|$|... sends {{a request}} <b>message</b> {{containing}} new <b>sequence</b> <b>number</b> to all {{processes in the}} system ...|$|R
50|$|This {{means that}} A may still receive ACK0 {{when it is}} already {{transmitting}} <b>messages</b> with <b>sequence</b> <b>number</b> one. (And vice versa.) It treats such messages as negative-acknowledge codes (NAKs). The simplest behaviour is to ignore them all and continue transmitting.|$|R
40|$|A group {{including}} {{a larger number}} of processes implies larger computation and communication overheads O(n 2) required to manipulate and transmit messages for a number n of processes. In this paper, we discuss a group which is composed of subgroups of processes. Each subgroup has a gateway process which communicates with the other gateway processes. We propose a mechanism to causally deliver messages to processes in a group by using a vector of <b>message</b> <b>sequence</b> <b>numbers</b> whose size is the number of subgroups, not the number of processes. We assume that networks are less-reliable; i. e., that messages may be lost...|$|R
40|$|Dictionary-based {{modelling}} is {{the mechanism}} {{used in many}} practical compression schemes. For example, {{the members of the}} two Ziv-Lempel families parse the <b>input</b> <b>message</b> into a <b>sequence</b> of phrases selected from a dictionary, and obtain compression since a reference to the phrase can be more compact than the phrase itself...|$|R
40|$|In this paper, {{we propose}} a new {{multicast}} protocol that guarantees reliable message delivery in an efficient manner. In the proposed protocol, the channel implosion effect is diminished by transmitting ACK packet alternately at the receiver nodes, {{and the channel}} utilization is increased using multiple selective retransmission request scheme. In addition, we minimized the replicated retransmissions by maintaining timestamps for the retransmitted packets. Especially, the number of control messages is reduced by electing one responding node among the receivers by only looking at the <b>message</b> <b>sequence</b> <b>number.</b> The proposed protocol {{can be applied to}} the multicasting service over any broadcast medium. This paper investigates the performance of the proposed protocol by evaluating delay and number of control messages in the satellite communication medium. Keyword : multicast protocol, implosion effect, selective retransmission, timestamp 1 Introduction The reliable multicast protocol in the [...] ...|$|R
40|$|Modern ring-based {{communication}} media {{provide opportunities}} for novel protocols that exploit the properties of a ring. Such properties are particularly advantageous for systems that make extensive use of multicast communication with a total order on messages, such as fault-tolerant distributed systems. We present two such protocols. A local area protocol, operating on a single ring, uses a single <b>sequence</b> of <b>message</b> <b>sequence</b> <b>numbers</b> {{to ensure that all}} messages are delivered and ordered. A wide area protocol, operating on many rings interconnected by gateways, uses the single ring protocol to ensure message delivery, with timestamps to order the messages. 1 INTRODUCTION The computer system of tomorrow will be a network of computers that are fully cooperating, integrated and fault tolerant. Communication in such a network will be equal in significance to processing and storage. To achieve this integration, we must look beyond current protocols that provide a communication service only. [...] ...|$|R
40|$|In {{distributed}} system common global clock and shared memory does not exist, so knowledge {{is shared by}} passing messages between several sites. Reliable broadcast eventually delivers messages to all participating sites. Total order broadcast ensures that all messages must be delivered to all sites in same order {{and it is a}} stronger notion of reliable broadcast [1]. Event-B is based on set theory and used event driven approach. For system-level analysis and modeling Event-B is a formal technique. In this technique system is gone through several stages for refinement [7, 9]. To specify total order broadcasting, introduce privilege based algorithm and refine it at the refinement level that only owner of the token can broadcast the messages in privilege based algorithm and detect failures like <b>messages</b> having same <b>sequence</b> <b>number,</b> token is not present for broadcasting a <b>messages,</b> higher <b>sequence</b> <b>number</b> <b>message</b> is delivered before lower one...|$|R
40|$|Abstract—In a {{best-effort}} publish/subscribe network, publica-tions may {{be delivered}} {{out of order}} (e. g., violating FIFO order). We contend that {{the primary cause of}} such ordering violations is the parallel matching and forwarding process employed by brokers to achieve high throughput. In this paper, we present an end-to-end method to improve event ordering. The method involves the receiver and minimally the sender, but otherwise uses the broker network as a black box. The idea is to analyze the dynamics of the network, and in particular to measure the delivery delay and its variation, which is directly related to out-of-order delivery. With these measures, receivers can determine a near-optimal latch time to defer message delivery upon the detection of a hole in the <b>message</b> <b>sequence</b> <b>number.</b> We evaluate the performance of this ordering scheme empirically in terms of the reduction in out-of-order deliveries, the delay imposed by the latch time, and its automatic adaptability to variable network conditions and input loads. I...|$|R
40|$|Abstract — {{we propose}} a testing {{technique}} for object-oriented programs. Based {{on the state}} and collaboration models of a system, we construct an intermediate representation, which we have named state collaboration diagram (SCOTEM). We generate test cases to achieve state-activity coverage of SCOTEM. We have empirically evaluated the effectiveness of our approach. The {{results show that the}} proposed technique could detect seeded integration testing faults which could not be detected by the related approaches. The previous work of this topic is only show the state and activity model. But we can consider the event if any message deliver to an object that behaves according to message so we can say that event based. the programming approach with the help of UML (unified modeling language) to generate the text file for collaboration diagram and the prototype model is used for the testing of path generated by that pr ototype model. My testing work is based on path based, path is generated with the help of UML diagram, and it shows the <b>message</b> <b>sequence</b> <b>number</b> it’s also provide the source to target path, object, transition state. Transition shows the message imitate from source to destination. And the message passing according to the <b>sequence</b> <b>number</b> each, <b>sequence</b> <b>number</b> identifies the separate massage...|$|R
30|$|The RREQ {{messages}} {{generated by}} the reactive routing protocol {{as well as all}} the broadcast messages are generated with a <b>sequence</b> <b>number.</b> The <b>sequence</b> <b>number</b> helps a receiving node to detect the message whether it is new or it is a copy of a previous message. In this way, the receiving nodes maintain a table to associate the <b>sequence</b> <b>number</b> and the sources which are employing them. Thus, a receiving node only pays attention to the <b>messages</b> with a <b>sequence</b> <b>number</b> which is higher than the one stored for the source. In order to implement this behavior properly when managing multiple routing protocols, in GREENIE, a source just uses one <b>sequence</b> <b>number</b> which is incremented either by the reactive or the proactive routing protocol when a broadcast message needs to be generated.|$|R
30|$|In {{infrastructure}} mode, {{when the}} manager receives a reconfiguration command that invalidates a route, it removes the old route and then execute the route discovery process {{to find a}} replacement route. If no replacement route exists, an exception is generated. In adhoc mode, a mote that receives a reconfiguration command, which impacts a Hitch Hiker route will flood a route-remove <b>message</b> with the <b>sequence</b> <b>number</b> of the matching route. All motes that receive this message will remove the route, causing the source node to re-run the route discovery process.|$|R
40|$|We {{propose a}} coordinated {{checkpointing}} algorithm based unreliable non-FIFO channel. In unreliable non-FIFO channel, {{the system can}} lose, duplicate, or reorder messages. The processes may not compute some messages because of message losses; the processes may compute some messages twice or more because of message duplicate; the processes may not compute messages according to their sending order because of message reordering. The above-mentioned problems make processes produce incorrect computation result, consequently, prevent processes from taking consistent global checkpoints. Our algorithm assigns each <b>message</b> a <b>sequence</b> <b>number</b> in order to resolve above-mentioned problems. During the establishing of the checkpoint, the consistency of checkpoint can {{be determined by the}} <b>sequence</b> <b>number</b> of sending and receiving messages. We can identify the lost messages, reordering messages and duplicate messages by checking the <b>sequence</b> <b>number</b> of sending and receiving messages. We resolve above-mentioned problems by resending the lost messages, buffering the reordering messages and dropping the duplicate messages. Our algorithm makes processes take consistent global checkpoints. Index Terms: unreliable non-FIFO channel; message losses; message duplicate; message reordering; consistent global checkpoints © 2012 Published by MECS Publisher. Selection and/or peer review under responsibility of the Researc...|$|R
50|$|When an SBC is {{included}} in the call path, the SBC acts as a B2BUA that behaves as a user agent server towards the caller and as user agent client towards the callee. In this sense, the SBC actually terminates that call that was generated by the caller and starts a new call towards the callee. The INVITE message sent by the SBC contains no longer a clear reference to the caller. The INVITE sent by the SBC to the proxy includes Via and Contact headers that point to the SBC itself and not the caller. SBCs often also manipulate the dialog identification information listed in the Call-Id and From tag. Further, in case the SBC is configured to also control the media traffic then the SBC also changes the media addressing information included in the c and m lines of the SDP body. Thereby, not only will all SIP messages traverse the SBC but also all audio and video packets. As the INVITE sent by the SBC establishes a new dialog, the SBC also manipulates the <b>message</b> <b>sequence</b> <b>number</b> (CSeq) as well the Max-Forwards value. Note that the list of header manipulations listed here is only a subset of the possible changes that an SBC might introduce to a SIP message. Furthermore, some SBCs might not do all of the listed manipulations. If the SBC is not expected to control the media traffic then there might be no need to change anything in the SDP header. Some SBCs do not change the dialog identification information and others might even not change the addressing information.|$|R
30|$|Because {{we allow}} mobile nodes {{to rejoin the}} network, the replicas of {{compromised}} nodes may affect EDDK. By {{limiting the number of}} neighbors for any node and by authenticating all <b>messages</b> using the <b>sequence</b> <b>numbers</b> and the pairwise keys, we can prevent an intruder from launching Sybil attacks, rushing attacks, and node replication attacks to some extent. Moreover, we can use multiple paths to the sink node to counter such attacks. In a sensor network where nodes are mostly stationary, the intrusion detection system can focus on monitoring mobile nodes whose locations have just changed. If the behavior of a mobile node matches an attack profile or deviates from a normal profile, the node will be regarded as a malicious node.|$|R
40|$|When one transmits {{a secret}} <b>message</b> <b>sequence</b> on a random number type {{subliminal}} channel, he/she has {{to convert the}} secret <b>message</b> <b>sequence</b> into a (practically) indistinguishable random <b>number</b> <b>sequence</b> first, and then embeds it on a carrier sequence. Otherwise the carrier sequence could be distinguished from one that contains no secret message. If others can distinguish whether a secret <b>message</b> <b>sequence</b> {{is embedded in the}} carrier sequence, the carrier sequence cannot be a subliminal channel. That is, a converter to convert any <b>message</b> <b>sequence</b> into a (practically) indistinguishable one is required. Moreover in many applications of subliminal channels, the deconverter corresponding to the converter should be self-synchronized with the converted sequence, because additional information to synchronize reduces the indistinguishability. Therefore, both (practical) indistinguishability and self-synchronization are required to the converter for subliminal channels. Vernum encryption can convert any <b>message</b> <b>sequences</b> into perfectly indistinguishable random <b>number</b> <b>sequences.</b> However the receivers cannot decode the <b>message</b> <b>sequences</b> from anywhere of the converted sequences without any knowledge of the synchronization. On the contrary, (ECB), CBC, CFB mode block ciphers and self-synchronizing stream ciphers can realize the self-synchronization. However, most of the output sequences can be distinguished from real or well-designed random <b>number</b> <b>sequences</b> by using the birthday paradox distinguishers we propose in this paper under some conditions...|$|R
40|$|Rollback-recovery in {{distributed}} systems {{is important for}} fault-tolerant computing. Without fault tolerance mechanisms, an application running on a system has to be restarted from scratch if a fault happens {{in the middle of}} its execution, resulting in loss of useful computation. To provide efficient rollback-recovery for fault-tolerance in {{distributed systems}}, it is significant {{to reduce the number of}} checkpoints under the existence of consistent global checkpoints in index-based distributed checkpointing algorithms. Because of the dependencies among the processes states that induced by inter-process communication in distributed systems, asynchronous checkpointing may suffer from the domino effect. Therefore, a consistent global checkpoint should always be ensured to restrict the rollback distance. The quasi-synchronous checkpointing protocols achieve synchronization in a loose fashion. Index-based checkpointing algorithm is a kind of typical quasi- synchronous checkpointing mechanism. The algorithm proposed in this thesis follows a new strategy to update the checkpoint interval dynamically as opposed to the static interval used by the existing algorithms explained in the previous chapter. Whenever a process takes a forced checkpoint due to the reception of a <b>message</b> with <b>sequence</b> <b>number</b> higher than the <b>sequence</b> <b>number</b> of the process, the checkpoint interval is either reset or the next basic checkpoint is skipped depending on when the massage has been received. The simulation is built on SPIN, a tool to trace logical design errors and check the logical consistency of protocols and algorithms in distributed systems. Simulation results show that the proposed scheme can reduce the number of induced forced-checkpoints per message 27 - 32 % on an average as compared to the traditional strategies...|$|R
30|$|As {{a stream}} {{processing}} system, the computations are {{triggered by the}} arrival of an external <b>input</b> <b>message.</b> We require no particular assumption about the arrival rate of the <b>input</b> <b>messages.</b>|$|R
40|$|We {{describe}} {{the implementation of}} a Word Sense Disambiguation (WSD) tool in a Dutch Text-to-Pictograph translation system, which converts textual <b>messages</b> into <b>sequences</b> of pictographic images. The system is used in an online platform for Augmentative and Alternative Communi cation (AAC). In the original translation process, the appropriate sense of a word was not disambiguated before converting it into a pictograph. This often resulted in incorrect translations. The implementation of a WSD tool provides a better semantic understanding of the <b>input</b> <b>messages.</b> status: publishe...|$|R
40|$|MANET {{are gaining}} {{popularity}} now days due to flexibility and communication without the infrastructure or centralized access point. The dynamic {{changing nature of}} network topology makes any node in MANET to leave and join the network at any point of time. From a security design perspective, MANETs have no clear line of defense; i. e. no in -bulit security. Thus MANET is accessible to both legitimate network users and malicious attackers. There are many routing attacks caused {{due to lack of}} security. The one of most suitable protocol is AODV for Ad-hoc networks and it is vulnerable to black hole attack by malicious nodes. It is similar to the black hole in the universe in which things disappear. The Black hole attack is that where a malicious node advertises itself as it is having the optimal route to the destination by sending RREP <b>message</b> with highest <b>sequence</b> <b>number</b> and minimum hop count. In this paper, a review of different types of attacks and existing solutions to detect black hole attack and their demerits...|$|R
40|$|An {{effective}} way to assemble partial views of a distributed system is to compute their product. Given two languages of <b>message</b> <b>sequence</b> charts generated by <b>message</b> <b>sequence</b> graphs, we {{address the problem of}} computing a <b>message</b> <b>sequence</b> graph that generates their product. Since all MSCs generated by a <b>message</b> <b>sequence</b> graph may be run within fixed bounds on the message channels, a subproblem is to decide whether the considered product is existentially bounded. We show that this question is undecidable but turns decidable in the restricted case where all shared events belong to the same process. For this case, we propose sufficient conditions under which a <b>message</b> <b>sequence</b> graph representing the product can be constructed...|$|R
50|$|For the {{inductive}} hypothesis, {{we assume}} that for some j+1 ≤ p and any <b>message</b> <b>sequence</b> Mj+1, NMj = Praccepts w and then prove the hypothesis for j and any <b>message</b> <b>sequence</b> Mj.|$|R
50|$|Joining and departing a {{confederation}} is {{an integral}} part of time management process. When a simulation joins a confederation, all other ACMs in the confederation create <b>input</b> <b>message</b> queues for the new simulation. Conversely, when a simulation departs a confederation the other ACMs delete <b>input</b> <b>message</b> queues for that simulation.|$|R
40|$|We {{extend the}} formal {{developments}} for <b>message</b> <b>sequence</b> charts (MSCs) to support scenarios with {{lost and found}} messages. We define a notion of extended compositional <b>message</b> <b>sequence</b> charts (ECMSCs) which subsumes the notion of compositional <b>message</b> <b>sequence</b> charts in expressive power but additionally allows to define lost and found messages explicitly. As usual, ECMSCs can be combined by means of choice and repetition to (extended) compositional <b>message</b> <b>sequence</b> graphs. We show that [...] -despite extended expressive power [...] -model checking of monadic second-order logic (MSO) for this framework remains to be decidable. The key technique to achieve our results is to use an extended notion for linearizations...|$|R
30|$|The <b>input</b> <b>message</b> {{should be}} an {{arbitrary}} and not negative integer.|$|R
40|$|This {{article is}} {{organized}} as follows: section 2 introduces our notation for <b>Message</b> <b>Sequence</b> Charts. Then, section 3 shows how a basic <b>Message</b> <b>Sequence</b> Chart can be decomposed into {{a set of}} basic patterns. Section 4 introduces the notion of irreducible <b>message</b> <b>sequence</b> charts, a kind of "normal form" based on composition of basic patterns. Section 5 provides an algorithm for computing an irreducible form for a HMSC, before conclusion. 2 Notation...|$|R
40|$|<b>Message</b> <b>Sequence</b> Charts is a {{graphical}} and textual {{language for}} the description and speci cation {{of the interactions}} between system components and their environment. The language is standardized by the ITU-TS (the Telecommunication Standardization section of the International Telecommunication Union, the former CCITT). The main area of application for <b>Message</b> <b>Sequence</b> Charts is as an overview specication of the communication behavior of real-time systems, in particular telecommunication switching systems. <b>Message</b> <b>Sequence</b> Charts {{may be used for}} requirement specication, interface spec-i cation, simulation and validation, test-case specication and documentation of real-time systems. In this paper we present a formal semantics of <b>Message</b> <b>Sequence</b> Charts exploiting techniques from process algebra. This semantics is proposed for standardization within the ITU-TS. We start with the semantics of the core language of <b>Message</b> <b>Sequence</b> Charts, Basic <b>Message</b> Se-quence Charts, and subsequently add other features such as process creation and termination, re nement and timer handling. ...|$|R
40|$|In {{a network}} {{computing}} platform, tasks compete with others for shared resources to communicate messages. Incremental computing masks communication latency by overlapping computation with communication. However, a <b>sequence</b> of <b>messages</b> {{with a large}} latency variance still makes computations proceed intermittently. In this paper, {{the impact of the}} <b>message</b> <b>sequence</b> on computation efficiency is studied and a framework which employs a well organized <b>message</b> <b>sequence</b> to maximize the efficiency of computations is introduced. Firstly, a network computing model for performing incremental computations is proposed. Based on the model, theorems are developed as the groundwork based on which algorithms for finding a well organized <b>message</b> <b>sequence</b> are derived. Finally, algorithms which find a well organized <b>message</b> <b>sequence</b> in 1 ((r k...|$|R
5000|$|<b>Input</b> <b>message</b> - This is {{the command}} {{sent by the}} user or the OSS.|$|R
40|$|Circuitry {{simultaneously}} inserts message framing {{information and}} detects noise errors in binary code data transmissions. Separate message groups are framed without requiring both framing bits and error-checking bits, and predetermined <b>message</b> <b>sequence</b> {{are separated from}} other <b>message</b> <b>sequences</b> without being hampered by intervening noise...|$|R
