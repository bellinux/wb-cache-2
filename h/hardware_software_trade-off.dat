1|10000|Public
40|$|Hardware blocks {{are used}} to execute very {{different}} Digital Signal Processing tasks, ranging from simple audio applications to {{state of the art}} LTE mobile communication and high definition video processing. Users expect continuous and very rapid innovation, and each new product to be more energy efficient and more powerful in terms of functionality than the previous generation. These user driven market requirements force companies to continuously struggle to design new devices with novel features and improved performance. Also the large number of semiconductor companies (especially fab-less) results in a strong competition, especially in terms of time to market. In summary, two key factors that determine the success of a new product are its differentiating features and its design time. These requirements ultimately translate into an increased pressure on the hardware and software designers to come up with new and innovative designs in short time spans, which can only be achieved with novel design tools and flows. For hardware design the standard RTL-based flow employed in the industry consists of using pre-built and pre-verified hardware IPs plus some customized blocks that are specially designed for new devices. These customized hardware blocks are one of the main ingredients that enable product differentiation in the market. These blocks are normally designed using a procedure that consists of two major designs and modeling steps. The first step models the algorithm in some C-like language that allows algorithmic analysis and verification. The second step manually implements a hardware architecture coded in a hardware description language. The manual translation involved in the second step requires a long time, and in theory it should be iterated for many possible hardware architectures, in order to find the best one. This hardware Design Space Exploration is especially lengthy because verification must be repeated for each new RTL implementation. The best way to cope with these issues is to use hardware synthesis tools that allow modeling in a C-like language at the algorithmic level, and can directly and quickly perform design space exploration with as little manual effort as possible. This observation is the basic motivation for the methods and results described in this thesis. The model-based design paradigm has been studied extensively by the research community to raise the level of abstraction for design, verification and synthesis of hardware and software. The scope of the term is very broad, and it cannot be captured easily in a few lines. However, in the scope of hardware and software design for embedded systems model-based design can be defined as a design paradigm that allows one to rapidly design, verify, validate and implement hardware and software systems starting from pre-verified abstract component models. Model-based design usually starts from abstract graphical drag-and-drop models which are usually modeled in a proprietary way (as in the case of Simulink) or in a loosely standardized way (as {{in the case of the}} UML). The components used for modeling range from simple atomic blocks like arithmetic operations to complex blocks like a Fast Fourier Transform, a Finite Impulse Response filter, a Viterbi decoder, a Discrete Cosine Transform etc. The entire algorithm is modeled in this way, and then automatically synthesized to an implementation-dependent model, in order to enhance re-use under different application scenarios. Model-based design is normally carried out using frameworks and design environments, such as Simulink or Labview, that are equipped with powerful model-to-model translation tools. These tools can be used to implement different low level models for software and hardware simulation and implementation from a single "golden" verified algorithmic model. Most of the model-based design tools that are available in industry and academia today allow automatic software code generation from graphical models. The software code generators can generate optimized code that can come close to hand optimized code in terms of size and performance, because they exploit information about the target processor architecture and the associated memory hierarchy. Model-based design tools also offer the capability to generate hardware from graphical models. However, they either rely on parameterized hand-optimized implementations of the larger macro blocks, or require the designer to use smaller blocks at an abstraction level that is very close to RTL. In other words these tools either rely either on pre-modeled intellectual proprietary blocks (IPs) with fixed hardware architecture or tend to decrease the abstraction level in a proprietary manner. The reliance on a single architectural template can result in a sub-optimal implementation if this architecture is not suitable for particular application, while working at lower abstraction level design space exploration becomes again very expensive, essentially defeating one of the main purposes of model-based design. Simulink (from The Mathworks) is a very powerful modeling, simulation and analysis tool that is used in this thesis as the starting point for model-based design. It has a huge set of libraries and allows modeling systems and algorithms from very different application domains, ranging from embedded control to video and communication systems. It includes many parameterized built in components that can be used for modeling, as well as components that allow easy mathematical and graphical analysis of data in the time and frequency domains, thus making the debugging and verification very easy and intuitive. Simulink also has tools that perform fixed point analysis analysis and ease the transition from floating to fixed point models. Simulink comes bundled with different code-generators that can generate C/C++ code from models for different embedded processors. There are many code generators available with Simulink that can generate C/C++ software code for a variety of processor architectures. These code generators are called Target Language Compilers (TLC) in Simulink terminology. Simulink also supports for hardware generation from graphical models, but as explained above for complex algorithms it relies on parameterizable fixed architectural templates which are not flexible enough to target different application domains with different requirements or it requires modeling at a low abstraction level, resulting in longer design times. The research presented in this thesis uses Simulink as graphical modeling environment front-end for hardware synthesis and hardware/software trade-off analysis. It proposes a novel design flow, which incorporates a more flexible and powerful approach for hardware synthesis and design space exploration than the industrial and research state of the art. Several high level synthesis (HLS) tools are available to synthesize RTL hardware from C/C++/SystemC abstract specifications. Normally these high level synthesis tools also require a set of constraints which drive them to synthesize a specific macro and micro-architecture from the C-like specification. Hence Design Space Exploration can be performed only by changing these constraints, while preserving the same pre-verified C code. Simulink used as a modeling front-end to high level hardware synthesis results in a very powerful flow that allows flexible hardware design and synthesis. Since Simulink supports code generation for software implementation, hardware/software trade-off analysis can also be performed easily starting from Simulink models. During the course of this thesis Simulink was evaluated as graphical modeling front-end for high level hardware synthesis and <b>hardware</b> <b>software</b> <b>trade-off</b> analysis. The tool that was used for high level hardware synthesis is Cadence C-to-Silicon, or CtoS. In the input, C++ constructs {{are used to}} specify the algorithm, while SystemC constructs are used for more hardware oriented artifacts, such as bit-true IOs and timing. Hence our goal is to define a methodology to convert the C output from Simulink and efficiently synthesize it with CtoS. In particular, by exploring the variety of TLCs available from Simulink, we found that Embedded Real Time coder (ERT), which was specifically designed to produce readable and optimized code for embedded processors, can generate C code that is well suited for high level hardware synthesis. ERT has many optimization that can be selectively enabled or disabled to generate code that is suitable for a particular application. We first analyzed them to understand which ones can be used to generate code that is best suited for high level hardware synthesis. Also different graphical modeling options were analyzed to enable hierarchical and modular code generation, that is especially useful when model partitioning is required in order to obtain a more concurrent hardware implementation. Simulink allows one to easily control the level of granularity, by grouping sub-designs into aggregate blocks that can become single function calls in the generated C code. In order to illustrate how one can perform hardware/software trade-off analysis, we used a case study from the domain of wireless video surveillance sensor networks, where cameras are triggered to capture video whenever an interesting audio event is detected by an audio detector. The platform that was used as implementation target consisted of ARM Cortex-M 3 processor. The audio algorithm was modeled in Simulink and then model was grouped into aggregate Simulink blocks to generate modular code through ERT. This modular code was then used in the form of different C-code partitions to perform extensive hardware/software trade-off analysis, where final implementation decisions were made based on very accurate low level power/area/throughput estimates. An accurate picture of power, area and throughput was easily generated because most of the design space exploration was performed using CtoS with minor or no changes to the C-model. Very simple and abstract architectural constraints to automatically generate the low level synthesis scripts for both CtoS and the downstream tools (e. g. RTL Compiler). Once a C-model is generated from Simulink through ERT it can be synthesized using CtoS by providing architectural constraints. But in order to efficiently perform design space exploration one must gain a high level understanding of the computationally most expensive loops and code segments. This may again become a complex and tedious task for automatically generated code. Hence a very important part of our research was to devise and implement a mechanism that can shield the designer from understanding the automatically generated code during high level synthesis. We implemented an automated TCL script to perform automatic design space exploration. This tool takes as input a set of simple high-level directives that limit the design space to be explored, and then produces many points in the design space that can be used for further low level throughput, power and area analysis. The directives specify, for example, how many resources such as multipliers or adders must be considered, what type of memories must be used, how many operations should be scheduled in a single cycle etc. In the second part of this thesis, we also explored in detail how to implement algorithms, like an FFT, that are used in a multitude of different applications and may require inherently different macro/micro-architectures to satisfy very different performance requirements. The fully sequential C-code that is generated by ERT for such complex blocks limits the design space that can be explored. Especially more concurrent implementations are very difficult to derive from such code because it is inherently sequential and not well suited to achieve the level of concurrency which can be essential for some hardware implementations.. We thus proposed and experimented with a technique that allowed us to represent complex block as proprietary blocks in Simulink. These blocks can be considered as IPs that are defined at a higher abstraction level to enable efficient hardware synthesis and extended hardware design space exploration, still starting from a single C model. The modeling strategy that we used for defining these high level synthesis IPs (HLS-IP) relies on the S-function modeling mechanism. This is a mechanism provided by Simulink to extend its component library. It allows modeling of algorithms in a well-defined manner to enable integration into the simulation environment and C-code generation. We used plain C for modeling S-functions because C-like specifications are also well suited for high level hardware synthesis, which is the target of our proposed HLS-IP scheme. Complex algorithms, like an FFT, have many different signal flow graph representations, where each representation is suited for different purpose. Some representations may be best suited for software implementation and some are more interesting for hardware implementation. The choice of signal flow graph and template architecture in our case was made based on flexibility and opportunity to map to different macro/micro-architectures, to enable more extended hardware design space exploration. This mostly involves a change of the level of concurrency, because state of the art high level synthesis tools are hardly able to increase the level of concurrency starting from sequential C-like specifications, thus essentially limiting a very important dimension of the hardware design space that can explored. We experimented extensively with an FFT test case for designing high level flexible IPs that can be used for modeling, simulation and verification in the Simulink environment and then for efficient hardware synthesis and design space exploration. In the end we were able to formulate and write an FFT IP-generator that generates flexible HLS-IPs following all the guidelines described above, including all the wrappers that are required for integration into Simulink and the high level synthesis scripts. The HLS-IPs are generated in a way that allows separation of pure functionality and behavioral constructs from the SystemC interfaces and threads. The functional part of HLS-IP that is generated remains the same in order to perform verification once, and only the level of parallelism and datapath bit-width is changed to reflect the application requirement...|$|E
40|$|The Author(s) 2015. One of the {{emerging}} challenges to designing HPC systems is understanding and projecting the requirements of exascale applications. In {{order to determine the}} performance consequences of different hardware designs, analytic models are essential because they can provide fast feedback to the co-design centers and chip designers without costly simulations. However, current attempts to analytically model program performance typically rely on the user manually specifying a performance model. We introduce the ExaSAT framework that automates the extraction of parameterized performance models directly from source code using compiler analysis. The parameterized analytic model enables quantitative evaluation of a broad range of <b>hardware</b> design <b>trade-offs</b> and <b>software</b> optimizations on a variety of different performance metrics, with a primary focus on data movement as a metric. We demonstrate the ExaSAT framework's ability to perform deep code analysis of a proxy application from the Department of Energy Combustion Co-design Center to illustrate its value to the exascale co-design process. ExaSAT analysis provides insights into the <b>hardware</b> and <b>software</b> <b>trade-offs</b> and lays the groundwork for exploring a more targeted set of design points using cycle-accurate architectural simulators...|$|R
40|$|Design {{automation}} {{has steadily}} contributed to improvements witnessed {{in the system}} design process. Initial applications were to address low level design concerns such as transistor layout and simulation; however the focus of tools has slowly been progressing up the design abstraction scale. The current state-of-the-art provides modelling capabilities {{at different levels of}} abstraction, but solutions for synthesis issues at the register-transfer and lower levels are the norm. The proliferation of design description languages at different abstraction levels has prompted the need for standardization (VHDL and Open-Verilog) to promote design migration and re-use. While design automation has helped in reducing design time-lines and design churn, a major source of design difficulties is just recently being addressed and promise to be the next wave in design automation applicability. The problems arise within the architectural (or system) level of abstraction very early in the design cycle. The recent research in this field attempts to bridge the design process gap between specification and design, and provides a platform for experimenting with <b>hardware</b> and <b>software</b> <b>trade-offs.</b> This dissertation studies the requirements for an environment for architectural design. In particular, an environment specific to the telecommunications domain is proposed in order to limit the potentially large design exploration space. An intermediate design language is also introduced to accommodate both high level modelling and synthesis driven by the user and environment. Finally a Design Analysis and Synthesis Environment (DASE) is described to facilitate the architectural level activities. The environment, a proof of concept, provides generic modal library, simulation, synthesis and Petri-net analysis support. Realistic design examples are explored, to illustrate architectural design activities with the environment...|$|R
40|$|In the {{embedded}} system applications {{the combination of}} data-processing and system throughput requirements is constantly increasing. Implementing the algorithm purely in software becomes constantly more difficult because of system power, cost and the limited CPU’s processing capacity. Among all the possible options customizing the CPU’s instruction set for the specific application and using multiple CPU cores are the most common. A very different approach is the migration of performance-hungry elements of the algorithm into hardware to generate hardware accelerators. A hardware accelerator is a block of logic that implements on silicon the same functions performed by the processor but faster and with a silicon area occupation. This methodology addresses several important issues: • Integration with software design-flow • Direct connection of generated hardware accelerators into the processor’s memory map • Support for pointers and array • Efficient latency-aware scheduling and pipelining of memory transactions The Altera NIOS II C-to-Hardware Compiler (C 2 H) compiler automates the generation of hardware accelerators from pure ANSI C functions and its interfacing with the Altera NIOS II processor, a soft-core processor system implemented on Altera FPGA. The generated accelerator has direct access to memory and other peripherals in the processor’s system. This methodology solves {{also one of the}} biggest problems in the EDA industry concerning the incompatibility between <b>hardware</b> and <b>software</b> design flows. The issue is fixed by C 2 H by enabling development of embedded <b>software</b> and embedded <b>hardware</b> accelerators and management of <b>hardware</b> <b>software</b> <b>trade-offs.</b> The report is organized in 8 Chapters. The Chapter 1 introduces the internship overview with a brief presentation of the company Thales Communications of Colombes, Paris (where the internship has been carried out). The Chapter 2 begins with a brief history of the Electronic Design Automation evolution, with particular attention to high-level synthesis. In this Chapter is also present a brief description of the main high-level tools and languages developed in the last years from EDA industry. The Chapter 3 presents the Altera NIOS II Processor system, its architecture and its connections. The NIOS II Processor is a fundamental concept in the Altera C-to-Hardware tool comprehension. In fact the C 2 H tool, as showed in the next chapters, generates hardware accelerators automatically integrated in the NIOS II processor system, in order to improve its performances. In the Chapter there is also a brief presentation of the main Altera tools used in the NIOS II design environment. The forth Chapter is focused on the C 2 H compiler. The main features of the tool are examined and the Design Flow is explained in all its steps. Moreover it is present a brief paragraph introducing how C 2 H interacts with the other tools. The Chapter 4 presents the target hardware used. All the components described are included in the Cyclone III development kit. In the Chapter 5 is analyzed the case study, the OFDM Demodulator Algorithm with particular attention to the software main functions candidates to the acceleration. The Chapter 6 shows the C 2 H design flow applied to the case study. It is explained the acceleration process and some optimisation rules. The Chapter 7 shows the results in terms of time and area performance on the case study algorithm. In the 8 Chapter are summarized the main advantages and drawbacks using C 2 H and it is present a brief author’s conclusion...|$|R
50|$|Computationally intensive: <b>hardware,</b> <b>software.</b>|$|R
5000|$|Combines <b>hardware,</b> <b>software,</b> environment, {{and human}} {{interaction}} ...|$|R
5000|$|Debugging {{and testing}} of <b>hardware,</b> <b>software,</b> and {{documentation}} ...|$|R
5000|$|... "Participating <b>hardware,</b> <b>software,</b> {{wireless}} {{and professional}} development companies include: ...|$|R
5000|$|Comprehensive {{knowledge}} of <b>hardware,</b> <b>software,</b> application, and systems engineering ...|$|R
5000|$|Skidata {{provides}} <b>hardware,</b> <b>software,</b> {{business logic}} and service for ...|$|R
5000|$|Sean O'Sullivan - Global: <b>Software,</b> <b>Hardware,</b> <b>Software,</b> Information {{technology}} ...|$|R
5000|$|... {{e-business}} infrastructure (<b>hardware,</b> <b>software,</b> telecoms, networks, human capital, etc.), ...|$|R
5000|$|... #Subtitle level 3: <b>Hardware,</b> <b>software,</b> and {{facility}} resource requirement ...|$|R
40|$|Abstract: Embedded Systems play a {{key role}} to drive the {{technological}} evolution. A key issue is to translate system knowledge and competences into complex embedded systems. Creating an embedded computer system which meets its performance, cost, and design time goals is a hardware-software co-design. Embedded controller is implemented for reactive real time applications as mixed <b>hardware</b> <b>software</b> system. <b>Hardware</b> <b>Software</b> co-design system involves Specification, Modeling, Design space exploration and partitioning, synthesis and optimization, Validation, and Implementation. The main aim of the co-design is to design a whole system without excessive preliminary constraints on the mapping or partitioning. Basically we can define “Meeting System level objectives by exploiting the synergism of <b>hardware</b> and <b>software</b> through their concurrent design”. This paper presents a co-design approach and roles of <b>hardware</b> <b>software</b> co-design in Embedded System and <b>Hardware</b> <b>Software</b> Co-design process is used to design a whole system without excessive preliminary constraints on the mapping or partitioning...|$|R
2500|$|Discusses <b>hardware,</b> <b>software,</b> {{repairs and}} the scene for the Commodore 64 ...|$|R
5000|$|Founding Member, <b>Hardware,</b> <b>Software</b> & Game Reviewer, Senior Editor - Leon Hyman ...|$|R
5000|$|On Test - Reviews and {{comparisons}} of computing <b>hardware,</b> <b>software,</b> and peripherals ...|$|R
40|$|Pattern {{matching}} {{is commonly}} required in {{many application areas}} and bioinformatics is a major area of interest that requires both exact and approximate pattern matching. Much {{work has been done}} in this area, yet there is still a significant space for improvement in efficiency, flexibility, and throughput. This paper presents a <b>hardware</b> <b>software</b> co-design of Aho-Corasick algorithm in Nios II soft-processor and a study on its scalability for a pattern matching application. A software only approach is used to compare the throughput and the scalability of the <b>hardware</b> <b>software</b> co-design approach. According to the results we obtained, we conclude that the <b>hardware</b> <b>software</b> co-design implementation shows a maximum of 10 times speed up for pattern size of 1200 peptides compared to the software only implementation. The results also show that the <b>hardware</b> <b>software</b> co-design approach scales well for increasing data size compared to the software only approach...|$|R
5000|$|... {{ensuring}} the correct <b>hardware</b> and <b>software</b> have been prepared; any additional <b>hardware</b> and <b>software</b> are prepared and stored {{until they are}} implemented. Before setting up the <b>hardware</b> and <b>software,</b> {{they need to be}} checked for errors ...|$|R
40|$|Most {{system-on-chip}} (SoC) design methodologies {{promote the}} reuse of pre-designed (<b>hardware,</b> <b>software,</b> and functional) components. However, as these components are heterogeneous, their integration requires complex interface sub-systems. These sub-systems {{can also be}} constructed by assembling pre-designed basic interface components. Hence, SoC design and validation involves component composition techniques to create <b>hardware,</b> <b>software,</b> and functional interface sub-systems by assembling basic interface components. We propose a unified methodology for automatic component integration that allows designers to reuse pre-designed components effectively. We also present ROSES, a design flow that uses this methodology to generate <b>hardware,</b> <b>software,</b> and functional interface sub-systems automatically starting from a system-level architectural model...|$|R
50|$|Information-technology (IT) {{consultants}} in many disciplines such {{as computer}} <b>hardware,</b> <b>software</b> engineering, or networks.|$|R
5000|$|... "Theft of functionality": Unauthorized {{acquisition}} of actual <b>hardware,</b> <b>software,</b> or firmware {{of a system}} component.|$|R
50|$|Tampering with or {{intentionally}} damaging computer <b>hardware,</b> <b>software,</b> printer, operation systems, {{or other}} associated equipment.|$|R
5000|$|Lower <b>hardware,</b> <b>software</b> and {{maintenance}} costs for game terminals, {{due to their}} thin client nature.|$|R
40|$|Includes all {{articles}} indexed by Scopus® for {{the seven}} journals listed on the Design Society website and all papers indexed for DESIGN and ICED (accessed on 05 /Nov/ 2016). The full search query used to extract the articles is: "(SRCTITLE ("Intelligence for Engineering Design, Analysis and Manufacturing: AIEDAM" OR "Journal of Engineering Design" OR "Design Studies" OR "Research in Engineering Design" OR "CoDesign" OR "Journal of Design Research" OR "Design Science Journal" OR "The International Journal of Design Creativity and Innovation" OR "International Conference on Engineering Design" OR "INTERNATIONAL DESIGN CONFERENCE")) AND ("data collection" OR "data acquisition" OR "data source" OR database OR "empirical data" OR "empirical grounding" OR interview OR documents OR "data logs" OR "case study" OR observation OR experiment* OR "empirical finding*" OR "empirical result*") AND (EXCLUDE (EXACTSRCTITLE, "Hardware Software Codesign Proceedings Of The International Workshop") OR EXCLUDE (EXACTSRCTITLE, "Journal Of Engineering Design And Technology") OR EXCLUDE (EXACTSRCTITLE, "Research In Engineering Design Theory Applications And Concurrent Engineering") OR EXCLUDE (EXACTSRCTITLE, "Chinese Journal Of Engineering Design") OR EXCLUDE (EXACTSRCTITLE, "Codes Isss 2005 International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis") OR EXCLUDE (EXACTSRCTITLE, "Codes Isss 12 Proceedings Of The 10 th ACM International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Co Located With Esweek") OR EXCLUDE (EXACTSRCTITLE, "Codes Isss 2006 Proceedings Of The 4 th International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis") OR EXCLUDE (EXACTSRCTITLE, "Codes Isss 2007 International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis") OR EXCLUDE (EXACTSRCTITLE, "Embedded Systems Week 2008 Proceedings Of The 6 th IEEE ACM IFIP International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 2008 ") OR EXCLUDE (EXACTSRCTITLE, "Second IEEE ACM IFIP International Conference On <b>Hardware</b> <b>Software</b> Codesign And Systems Synthesis Codes Isss 2004 ") OR EXCLUDE (EXACTSRCTITLE, "Embedded Systems Week 2011 Esweek 2011 Proceedings Of The 9 th IEEE ACM IFIP International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 11 ") OR EXCLUDE (EXACTSRCTITLE, " 2010 IEEE ACM IFIP International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 2010 ") OR EXCLUDE (EXACTSRCTITLE, " 2013 International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 2013 ") OR EXCLUDE (EXACTSRCTITLE, " 2014 International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 2014 ") OR EXCLUDE (EXACTSRCTITLE, " 2015 ACM IEEE International Conference On Formal Methods And Models For Codesign Memocode 2015 ") OR EXCLUDE (EXACTSRCTITLE, " 8 th ACM IEEE International Conference On Formal Methods And Models For Codesign Memocode 2010 ")) AND (EXCLUDE (EXACTSRCTITLE, " 2015 International Conference On <b>Hardware</b> <b>Software</b> Codesign And System Synthesis Codes Isss 2015 ") OR EXCLUDE (EXACTSRCTITLE, " 9 th ACM IEEE International Conference On Formal Methods And Models For Codesign Memocode 2011 ") OR EXCLUDE (EXACTSRCTITLE, " 11 th ACM IEEE International Conference On Formal Methods And Models For Codesign Memocode 2013 ") OR EXCLUDE (EXACTSRCTITLE, " 10 th ACM IEEE International Conference On Formal Methods And Models For Codesign Memocode 2012 ") OR EXCLUDE (EXACTSRCTITLE, "A Practical Introduction To <b>Hardware</b> <b>Software</b> Codesign")) " The keywords used in the article "DATA-DRIVEN ENGINEERING DESIGN RESEARCH: OPPORTUNITIES USING OPEN DATA" are: "data collection" OR "data acquisition" OR "data source" OR database OR "empirical data" OR "empirical grounding" OR interview OR documents OR "data logs" OR "case study" OR observation OR experiment* OR "empirical finding*" OR "empirical result*...|$|R
50|$|Failure modes, {{including}} <b>hardware,</b> <b>software,</b> {{human and}} system are {{addressed in the}} design of the software.|$|R
5000|$|Cyberpunk: Stories of <b>Hardware,</b> <b>Software,</b> Wetware, Evolution, and Revolution {{edited by}} Victoria Blake - February 2013 ...|$|R
5000|$|Provide {{materials}} like <b>hardware,</b> <b>software,</b> manuals, tools, {{and other}} items to law enforcement to conduct investigations.|$|R
25|$|Identification {{of assets}} and {{estimating}} their value. Include: people, buildings, <b>hardware,</b> <b>software,</b> data (electronic, print, other), supplies.|$|R
50|$|There {{are several}} {{methods used to}} uncap a cable modem, by <b>hardware,</b> <b>software,</b> tricks, alterations, and modifications.|$|R
5000|$|Error-correction {{techniques}} in digital circuitry. These may {{be implemented in}} <b>hardware,</b> <b>software</b> {{or a combination of}} both.|$|R
5000|$|Identification {{of assets}} and {{estimating}} their value. Include: people, buildings, <b>hardware,</b> <b>software,</b> data (electronic, print, other), supplies.|$|R
5000|$|... assets, primary (i.e. Business {{processes}} and related information) and supporting (i.e. <b>hardware,</b> <b>software,</b> personnel, site, organization structure) ...|$|R
40|$|Remarkable {{features}} of digital systems are complexity {{and variety of}} subsystems. Computer based embedded systems gain more and more importance. In view {{of the necessity of}} a constantly reduced design time <b>hardware</b> <b>software</b> codesign will become key issue because commercially available logic and high level synthesis tools do not meet the changed and more complex requirements. Therefore the goal of this project supported by BMBF was to rationalize <b>hardware</b> <b>software</b> codesign. The following tasks have been worked on in the project: 1. PROLOG data base specifications of complex components and VHDL models of processors. In this way evaluation and validation possibilities are offered which are inevitable in <b>hardware</b> <b>software</b> codesign. 2. Development of design improvement procedures improving designs as neccessary (timing, area, throughput) by postprocessing. In this way <b>hardware</b> <b>software</b> codesign could eliminate within the design flow multiple iterations with modified control parameters the influence of which being hardly to predict. Besides, a design improvement workbench has been implemented to ease usage of commercial tools, converters, and self-developed tools. 3. Top-down <b>hardware</b> <b>software</b> codesign of a transport multiplexer from Digital Audio Broadcasting (DAB). This example of a special, practical relevant class of problems is characterized by parallel asynchronous processes. (orig.) SIGLEAvailable from TIB Hannover: DtF QN 1 (39, 28) / FIZ - Fachinformationszzentrum Karlsruhe / TIB - Technische InformationsbibliothekBundesministerium fuer Bildung, Wissenschaft, Forschung und Technologie, Bonn (Germany) DEGerman...|$|R
5000|$|Capacity {{planning}} of storage, computer <b>hardware,</b> <b>software</b> and connection infrastructure resources required over some future period of time.|$|R
5000|$|... {{provide a}} {{technically}} sound basis for re-bundling {{as much as}} possible of IBM's offerings (<b>hardware,</b> <b>software</b> and services) ...|$|R
