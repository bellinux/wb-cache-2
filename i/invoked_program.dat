2|133|Public
5000|$|On Unix systems, the execute {{permission}} controls {{access to}} invoking the file as a program, and applies both to executables and scripts.As the permission is enforced {{in the program}} loader, no obligation is needed from the invoking program, nor the <b>invoked</b> <b>program,</b> in enforcing the execute permission — this also goes for shells and other interpreter programs.The behaviour is mandated by the POSIX C library that is used for interfacing with the kernel: POSIX specifies that the [...] family of functions shall fail with EACCESS (permission denied) if the file denies execution permission (see [...] ).|$|E
5000|$|A basic {{example of}} {{multiple}} pointer indirection is the argv argument {{to the main}} function in C (and C++), which is given in the prototype as [...] The name of the <b>invoked</b> <b>program</b> executable, {{as well as all}} command line arguments that followed, are stored as independent character strings. An array of pointers to [...] contains pointers to the first character of each of these strings, and this array of pointers is passed to the [...] function as the [...] argument. The passed array itself [...] "decays" [...] to a pointer, thus [...] is actually a pointer to a pointer to , even though it stands for an array of pointers to [...] (similarly, the pointers in the array, while each formally pointing to a single , actually point to what are strings of characters). The accompanying [...] argument, , provides the size of the array (i.e. the number of strings pointed to by the elements of the array), as the size of an (outmost) array is otherwise lost when it is passed to a function and converted to a pointer. Thus, [...] is a pointer to the 0th element of an array of pointers to , , which in turn is a pointer to , a character (precisely, the 0th character of the first argument string, which by convention {{is the name of the}} program).|$|E
2500|$|The {{behavior}} {{implemented by}} a library can {{be connected to}} the <b>invoking</b> <b>program</b> at different program lifecycle phases. [...] If the code of the library is accessed during the build of the <b>invoking</b> <b>program,</b> then the library is called a static library. [...] An alternative is to build the executable of the <b>invoking</b> <b>program</b> and distribute that, independently of the library implementation. [...] The library behavior is connected after the executable has been invoked to be executed, either as {{part of the process of}} starting the execution, or in the middle of execution. [...] In this case the library is called a dynamic library (loaded at run time). [...] A dynamic library can be loaded and linked when preparing a program for execution, by the linker. [...] Alternatively, in the middle of execution, an application may explicitly request that a module be loaded.|$|R
5000|$|The {{behavior}} {{implemented by}} a library can {{be connected to}} the <b>invoking</b> <b>program</b> at different program lifecycle phases. If the code of the library is accessed during the build of the <b>invoking</b> <b>program,</b> then the library is called a static library. [...] An alternative is to build the executable of the <b>invoking</b> <b>program</b> and distribute that, independently of the library implementation. The library behavior is connected after the executable has been invoked to be executed, either as {{part of the process of}} starting the execution, or in the middle of execution. In this case the library is called a dynamic library (loaded at run time). A dynamic library can be loaded and linked when preparing a program for execution, by the linker. Alternatively, in the middle of execution, an application may explicitly request that a module be loaded.|$|R
50|$|None of {{the main}} {{programming}} paradigms have a precise, globally unanimous definition, nor official international standard. Nor is there any agreement on which paradigm constitutes the best method to developing software. The subroutines that implement OOP methods may be ultimately coded in an imperative, functional, or procedural style that may, or may not, directly alter state {{on behalf of the}} <b>invoking</b> <b>program.</b>|$|R
50|$|Message passing is a {{technique}} for invoking behavior (i.e., running a program) on a computer. In contrast to the traditional technique of calling a program by name, message passing uses an object model to distinguish the general function from the specific implementations. The <b>invoking</b> <b>program</b> sends a message and relies on the object to select and execute the appropriate code. The justifications for using an intermediate layer essentially falls into two categories: encapsulation and distribution.|$|R
5000|$|The other (simpler, {{but less}} flexible) method to define {{commands}} is via foreign commands. This is {{more akin to}} the Unix method of <b>invoking</b> <b>programs.</b> By giving the command: foo :== $sys$sysexe:foo.exethe command 'FOO' will invoke FOO.EXE, and supply any additional arguments literally to the program, for example, [...] "foo -v". This method is generally used for programs ported from Unix and other non-native systems; for C programs using argc and argv command syntax.|$|R
5000|$|In addition, modules may {{optional}} contain static startup and shutdown procedures <b>invoked</b> during <b>program</b> startup and shutdown {{that match}} the signatures: ...|$|R
40|$|Distributed {{applications}} {{have become}} very popular {{and there is a}} growing need to efficiently and securely distribute data and remotely <b>invoke</b> <b>program</b> components. This paper describes the design and the implementation of a distributed installer (DI), which can accomplish both these tasks. We review goals that any such system should achieve, and show which goals are achieved by DI and several similar systems. This paper provides the description of the functionality, design and the implementation of DI. 1...|$|R
50|$|Yambo has {{a command}} line user interface. <b>Invoking</b> the <b>program</b> with {{specific}} option generates the input with default {{values for the}} parameters consistent with the present data on the system.|$|R
5000|$|Tactile Programming: (1996) AgentSheets {{becomes the}} world's first {{drag and drop}} {{educational}} programming environment. Drag and drop interfaces {{can be used to}} compose syntactically correct programs. In Visual AgenTalk (VAT), a rule-based visual programming language, users create rules by dragging and dropping conditions and actions from palettes. The tactile aspect of Visual AgenTalk allows users to perceive through drag and drop what programs do. By dragging and dropping conditions, actions, rules and even methods onto agents they see the consequence of <b>invoking</b> <b>program</b> fragment without having to write a test program. Similar drag and drop programming can later be found in the Etoys language (part of Squeak), in Alice and in Scratch.|$|R
5000|$|The term run is used almost synonymously. A related {{meaning of}} both [...] "to run" [...] and [...] "to execute" [...] {{refers to the}} {{specific}} action of a user starting (or launching or <b>invoking)</b> a <b>program,</b> as in [...] "Please run the application." ...|$|R
5000|$|The LBL [...] "DOUBLE" [...] {{instruction}} is a label, {{indicating that the}} user can <b>invoke</b> the <b>program</b> by XEQ [...] "DOUBLE". The name [...] "DOUBLE" [...] can also be assigned to any key on the user keyboard, effectively adding a new function to the calculator.|$|R
40|$|Laetirobin, {{isolated}} from a parasitic fungus host–plant relationship, was synthesized in six practical steps {{with an overall}} yield of 12 % from commercially available 2, 4 -dihydroxyacetophenone. Because the product is a pseudosymmetric tetramer of benzo[b]furans, {{each step of the}} synthesis was designed to involve tandem operations. Highlights include: 1) the double Sonogashira reaction of a bis(alkyne), 2) the practical copper(I) -mediated formation of a bis(benzo[b]furan), and 3) the biomimetic [4 + 2] dimerization and unexpected cationic [5 + 2] annulation of gem-diaryl alkene precursors. Preliminary structure–activity relationship data between the isomeric [4 + 2] and [5 + 2] tetramers revealed only the natural product to possess promising anticancer potential. Specifically, laetirobin is capable of blocking tumor cell division (mitosis) and <b>invoking</b> <b>programmed</b> cell death (apoptosis) ...|$|R
50|$|In many C implementations, it is a {{separate}} <b>program</b> <b>invoked</b> by the compiler as {{the first part of}} translation.|$|R
5000|$|Le Select is a {{framework}} prototype for accessing data of heterogeneous nature and for <b>invoking</b> data processing <b>program</b> over Internet/intranet environments" [...] 1 ...|$|R
50|$|Some {{distributions}} use an event-driven hotplug agent such as udev, which <b>invokes</b> helper <b>programs</b> as hardware devices, disk partitions {{and storage}} volumes matching certain rules come online. This allows discovery {{to run in}} parallel, and to progressively cascade into arbitrary nestings of LVM, RAID or encryption {{to get at the}} root file system.|$|R
40|$|SMILE is a {{multi-user}} {{software engineering}} environment that behaves as an intelligent assistant. SMILE presents a `fileless environment', derives and transforms data to shelter users from entering redundant information, automatically <b>invokes</b> <b>programming</b> tools, and actively {{participates in the}} software development and maintenance process. Unlike other intelligent assistants, SMILE is not a rule-based environment: its knowledge of software objects and the programming process is hardcoded into the environment. We describe SMILE's functionality and explain how we achieved this functionality without reliance on artificial intelligence technology. The development and maintenance of SMILE is {{supported in part by}} the United States Army, Software Technology Development Division of CECOM COMM/ADP, Fort Monmouth, NJ and in part by ZTI-SOF of Siemens AG, Munich, Germany. This paper was written while Dr. Kaiser was a Visiting Computer Scientist at the Software Engineering Institute, Carnegie-Mello [...] ...|$|R
40|$|AbstractThe {{definition}} of data refinement between datatypes {{is expressed in}} terms of all <b>programs</b> that <b>invoke</b> procedures of the types. As a result it is laborious to check. Simulations provide sound conditions that, being ‘static’, facilitate checking; but then their soundness is important. In this paper we extract a technique from the heart of the theory and show it to be equivalent to data refinement; it {{plays a key role in}} establishing properties about simulations in any of the computational models. We survey the difficulties confronting the theory when the procedures and <b>invoking</b> <b>programs</b> may contain probabilistic choices, and show that then each of the two simulation conditions is alone not complete as a rule for data refinement, even if the datatypes are deterministic (in contrast to the standard case). The last part of the paper discusses work in progress...|$|R
50|$|Postfix {{consists}} {{of a combination of}} server programs that run in the background, and client <b>programs</b> that are <b>invoked</b> by user <b>programs</b> or by system administrators.|$|R
40|$|Many modern {{programs}} provide operating system-style {{services to}} extension modules. A Web server, for instance, behaves like a simple OS kernel. It <b>invokes</b> <b>programs</b> that dynamically generate Web pages and manages their resource consumption. Most Web servers, however, rely on conventional operating systems to provide these services. As a result, the solutions are inefficient, and impose a serious overhead on the programmer of dynamic extensions. In this paper, {{we show that}} a Web server implemented in a suitably extended high-level programming language overcomes all these problems. First, building a server in such a language is straightforward. Second, the server delivers static content at performance levels comparable to a conventional server. Third, the Web server delivers dynamic content {{at a much higher}} rate than a conventional server, which is important because a significant portion of Web content is now dynamically generated. Finally, the server provides programming mech [...] ...|$|R
5000|$|Programs {{can listen}} on an [...] "ARexx port" [...] for string {{messages}}. These messages {{can then be}} interpreted by the program {{in a similar fashion}} to a user pushing buttons. For example, an ARexx script run in an e-mail program could save the currently displayed email, <b>invoke</b> an external <b>program</b> which could extract and process information, and then <b>invoke</b> a viewer <b>program.</b> This allows applications to control other applications by sending data back and forth directly with memory handles, instead of saving files to disk and then reloading them.|$|R
5000|$|Typing [...] at the DOS {{command-line}} <b>invoked</b> the <b>program</b> file [...] or [...] (depending on the DOS version). Recover proceeded {{under the}} assumption that all directory information included on a disk or disk partition was hopelessly corrupted, but that the FAT and non-directory areas might still contain useful information (though there might be additional bad disk sectors not recorded in the FAT).|$|R
40|$|Dynamic Web pages can seriously {{reduce the}} {{performance}} of Web servers. One technique for improving performance is to cache dynamic Web pages. We have developed the Dynamic Web cache which is particularly well-suited for dynamic pages. Our cache has improved performance significantly at several commercial Web sites. This paper analyzes the design and performance of the Dynamic Web cache. It also presents a model for analyzing overall system performance {{in the presence of}} caching. Our cache can satisfy several hundred requests per second. On systems which <b>invoke</b> server <b>programs</b> via CGI, the DynamicWeb cache results in near-optimal performance, where optimal performance is that which would be achieved by a hypothetical cache which consumed no CPU cycles. On a system we tested which <b>invoked</b> server <b>programs</b> via ICAPI which has significantly less overhead than CGI, the Dynamic Web cache resulted in near-optimal performance for many cases and 58 % of optimal performance in the worst case. The Dynamic Web cache [...] ...|$|R
50|$|Program {{steps are}} {{numbered}} starting from 1, but this numbering has no intrinsic meaning, and can change as new instructions areadded or removed {{in the middle}} of a program. A special instruction LBL is used to create a label, that can be used by the user to <b>invoke</b> the <b>program,</b> or by the program itself, as target of a GTO (unconditional go-to) or XEQ (execute) instruction.|$|R
5000|$|The former would resemble:voiddestroy (T * p, A & arena){ p->~T (...) // First {{invoke the}} {{destructor}} explicitly. arena.deallocate(p) // Then call the deallocator function directly.}which would be <b>invoked</b> from a <b>program</b> as:A arenaT * p = new (arena) T/* .../destroy(p, arena) ...|$|R
50|$|The exit {{operation}} typically performs clean-up operations {{within the}} process space before returning control {{back to the}} operating system. Some systems and programming languages allow user subroutines to be registered {{so that they are}} <b>invoked</b> at <b>program</b> termination before the process actually terminates for good. As the final step of termination, a primitive system exit call is invoked, informing the operating system that the process has terminated and allows it to reclaim the resources used by the process.|$|R
40|$|KMS is a {{commercial}} hypermedia system developed by Knowledge Systems for networks of heterogeneous workstations. It {{is designed to}} support organization-wide collaboration for {{a broad range of}} applications, such as electronic publishing, software engineering, project management, computer-aided design and on-line documentation. KMS is a successor to the ZOG system developed at Carnegie Mellon University from 1972 to 1985. A KMS database consists of screen-sized WYSIWYG workspaces called frames that contain text, graphics and image items. Single items in frames can be linked to other frames. They may also be used to <b>invoke</b> <b>programs.</b> The database can be distributed across an indefinite number of file servers and be as large as available disk space permits. Independently developed KMS databases can be linked together. The KMS user interface uses an extreme form of direct manipulation. A single browser/editor is used to traverse the database and manipulate its contents. Over 85 % of the user’s interaction is direct [...] a single point-and-click designates both object and operation. Running on Sun and Apollo workstations, KMS accesses and displays frames in less than one second, on average. This paper describes KMS and how it addresses a number of hypermedia design issues...|$|R
5|$|Unlike Unix, Plan 9 was {{designed}} with graphics in mind. After booting, a Plan 9 terminal {{will run the}} rio windowing system, in which the user can create new windows displaying rc. Graphical <b>programs</b> <b>invoked</b> from this shell replace it in its window.|$|R
5000|$|... "WTO" [...] is an {{assembler}} macro {{that generates}} an operating system call. Because of saving registers and later restoring and returning, this small program is usable as a batch <b>program</b> <b>invoked</b> {{directly by the}} operating system Job control language (JCL) like this: ...|$|R
50|$|Unlike Unix, Plan 9 was {{designed}} with graphics in mind. After booting, a Plan 9 terminal {{will run the}} rio windowing system, in which the user can create new windows displaying rc. Graphical <b>programs</b> <b>invoked</b> from this shell replace it in its window.|$|R
40|$|Variety of plots {{available}} in video or printed form. LONGLIB library of computer programs set of subroutines designed for vector plotting on cathode-ray tubes and dot-matrix printers. LONGLIB subroutines <b>invoked</b> by <b>program</b> calls similar to standard CALCOMP routines. In addition to basic plotting routines, LONGLIB contains extensive set of routines to allow viewport clipping, extended character sets, graphic input, gray-level plots, polar plots, and three-dimensional plotting {{with or without}} removal of hidden lines. LONGLIB written in FORTRAN 77 and C for batch execution...|$|R
5000|$|On OS/360 and derived {{mainframe}} systems, most programs never specify files (usually called datasets) directly, {{but instead}} reference them indirectly through the Job Control Language (JCL) statements that <b>invoke</b> the <b>programs.</b> These data definition (or [...] "") statements can include a [...] "disposition" [...] (...) parameter that indicates how the file {{is to be}} managed [...] - [...] whether a new file is to be created or an old one re-used; and whether the file should be deleted upon completion or retained; etc.|$|R
5000|$|Macros allow {{users to}} specify the <b>programs</b> <b>invoked</b> and other custom {{behavior}} during the build process. For example, the macro [...] "CC" [...] is frequently used in makefiles {{to refer to the}} location of a C compiler, and the user may wish to specify a particular compiler to use.|$|R
2500|$|The {{value of}} a library lies in the reuse of the {{behavior}}. [...] When a <b>program</b> <b>invokes</b> a library, it gains the behavior implemented inside that library without having to implement that behavior itself. Libraries encourage the sharing of code in a modular fashion, and ease {{the distribution of the}} code.|$|R
40|$|Code-patterns are statically {{recurring}} structure {{specific to}} a programming language. It can be parallel {{to aid in}} designing software systems for solving particular problems. Contrary to compilation assistance of code-patterns, control-patterns are dynamically recurring structures <b>invoked</b> during <b>program</b> execution time. It {{can be used for}} benchmarking OO-programs and underlying architecture like Java and Java-VM. We have proposed a run-time profiler based on control patterns and show that all run-time trace can be represented by a directed graph, a constrained output and a Boolean function. A transformed graph can be fed into a data-mining analyzer to find out the recurring structure representing run-time behaviors...|$|R
