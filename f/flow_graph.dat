1502|997|Public
25|$|A more {{practical}} {{choice is to}} drop the two-port approach altogether, and use various alternatives based on signal <b>flow</b> <b>graph</b> theory, including the Rosenstark method, the Choma method, and use of Blackman's theorem. That choice may be advisable if small-signal device models are complex, or are not available (for example, the devices are known only numerically, perhaps from measurement or from SPICE simulations).|$|E
2500|$|There {{are various}} notions of a flow {{function}} {{that can be}} defined in a <b>flow</b> <b>graph.</b> Flow functions model the net flow of units between pairs of nodes, and are useful when asking questions such as what is {{the maximum number of}} units that can be transferred from the source node s to the sink node t? The simplest example of a flow function is [...] known as a pseudo-flow.|$|E
50|$|The use of data {{switches}} in {{the data}} <b>flow</b> <b>graph</b> could to some extent make a static data <b>flow</b> <b>graph</b> appear as dynamic, and blur the distinction slightly. True dynamic reactive programming however could use imperative programming to reconstruct the data <b>flow</b> <b>graph.</b>|$|E
50|$|When {{required}} to have a single exit, <b>flow</b> <b>graphs</b> have two properties not shared with directed <b>graphs</b> in general. <b>Flow</b> <b>graphs</b> can be nested, which {{is the equivalent of}} a subroutine call (although there is no notion of passing parameters), and <b>flow</b> <b>graphs</b> can also be sequenced, which is the equivalent of sequential execution of two pieces of code. Prime <b>flow</b> <b>graphs</b> are defined as <b>flow</b> <b>graphs</b> that cannot be decomposed via nesting or sequencing using a chosen pattern of subgraphs, for example the primitives of structured programming. Theoretical research has been done on determining, for example, the proportion of prime <b>flow</b> <b>graphs</b> given a chosen set of graphs.|$|R
50|$|Digital {{filters are}} often diagramed as signal <b>flow</b> <b>graphs.</b>|$|R
40|$|Constant {{propagation}} aims at identifying expressions {{that always}} yield a unique constant value at run-time. It is well-known that constant propagation is undecidable for programs working on integers even if guards are ignored as in non-deterministic <b>flow</b> <b>graphs.</b> We show that polynomial constants are decidable in non-deterministic <b>flow</b> <b>graphs.</b> In polynomia...|$|R
5000|$|... "A signal <b>flow</b> <b>graph</b> is {{a network}} of nodes (or points) {{interconnected}} by directed branches, representing a set of linear algebraic equations. The nodes in a <b>flow</b> <b>graph</b> are used to represent the variables, or parameters, and the connecting branches represent the coefficients relating these variables to one another. The <b>flow</b> <b>graph</b> {{is associated with a}} number of simple rules which enable every possible solution to the equations to be obtained." ...|$|E
50|$|GNU cflow is a <b>flow</b> <b>graph</b> {{generator}} {{that is part}} of the GNU Project. It reads {{a collection}} of C source files and generates a C <b>flow</b> <b>graph</b> of external references. It uses only sources and doesn't need to run the program.|$|E
5000|$|The signal <b>flow</b> <b>graph</b> {{is further}} {{manipulated}} {{so that the}} gains into each summing node is +1. The result of all the manipulation is shown as the bottom signal-flow graph in the figure. The equations represented by the resulting signal <b>flow</b> <b>graph</b> are as follows: ...|$|E
5000|$|<b>Flow</b> <b>graphs</b> are digraphs {{associated}} {{with a set of}} linear algebraic or differential equations.|$|R
40|$|Single-Flux Quantum based {{large-scale}} data-path processor (SFQ-LSRDP) is a reconfigurable {{computing system}} which is implemented {{by means of}} superconductivity circuits. SFQ-LSRDP has a capability of accelerating data <b>flow</b> <b>graphs</b> (DFGs) extracted from scientific applications. Using an alternative technology instead of CMOS circuits for implementing such hardware entails considering particular constraints and conditions from the architecture and tools development perspectives. In this paper, we will introduce hardware specifications of the LSRDP and the tool chain developed for implementing applications. Placing and routing data <b>flow</b> <b>graphs</b> is a fundamental part to develop applications on the SFQ-LSRDP. Algorithms for placing DFG operations and routing nets corresponding {{to the edges of}} data <b>flow</b> <b>graphs</b> will be discussed in more details. These algorithms have been applied on a number of data <b>flow</b> <b>graphs</b> and the results demonstrate their efficiency. Further, simulation results demonstrates remarkable performance numbers in the range of hundreds of Gflops for the proposed architecture...|$|R
5000|$|... "Like block diagrams, signal <b>flow</b> <b>graphs</b> {{represent}} the computational, not the physical {{structure of a}} system." ...|$|R
50|$|Flow graphs may {{be viewed}} as abstractions of flow charts, with the {{non-structural}} elements (node contents and types) removed. Perhaps the best known sub-class of flow graphs are control flow graphs, used in compilers and program analysis. An arbitrary <b>flow</b> <b>graph</b> may converted to a control <b>flow</b> <b>graph</b> by performing an edge contraction on every edge that is the only outgoing edge from its source and the only incoming edge into its target. Another type of <b>flow</b> <b>graph</b> commonly used is the call graph, in which nodes correspond to entire subroutines.|$|E
50|$|A control <b>flow</b> <b>graph</b> (CFG) in {{computer}} science is a representation, using graph notation, of all paths that might be traversed through a program during its execution. The control <b>flow</b> <b>graph</b> is due to Frances E. Allen, who notes that Reese T. Prosser used boolean connectivity matrices for flow analysis before.|$|E
5000|$|... #Caption: An example control <b>flow</b> <b>graph,</b> before {{conversion}} to SSA ...|$|E
5000|$|IEEE Std 155-1960, IEEE Standards on Circuits: Definitions of Terms for Linear Signal <b>Flow</b> <b>Graphs,</b> 1960.|$|R
40|$|Abstract. WepresentanimplementationinthetheoremproverPVS of co-inductive stream {{calculus}}. Stream calculus {{can be used}} {{to model}} signal <b>flow</b> <b>graphs,</b> and thus provides a nice mathematical foundation for reasoning about properties of signal <b>flow</b> <b>graphs,</b> which are again used to model a variety of systems such as digital signal processing. We show how proofs by co-induction are used to prove equality of streams, and present a strategy to do this automatically. ...|$|R
40|$|Testing of {{software}} components during {{development is a}} heavily used approach to detect programming errors and to evaluate the quality {{of software}}. Systematic approaches to software testing get a more and more increasing impact on software development processes. For imperative programs there are several approaches to measure the appropriateness {{of a set of}} test cases for a program part under testing. Some of them are source code directed and are given as coverage criteria on <b>flow</b> <b>graphs.</b> This paper gives a definition of <b>flow</b> <b>graphs</b> for Erlang programs and describes a tool for generating such <b>flow</b> <b>graphs.</b> It provides a first step towards the transfer of advanced source code directed testing methods to functional programming...|$|R
5000|$|... #Caption: Fig 1: <b>Flow</b> <b>graph</b> {{depicting}} {{need for}} critical section ...|$|E
5000|$|... â€” S.J. Mason: Section IV: Illustrative {{applications}} of <b>flow</b> <b>graph</b> technique ...|$|E
5000|$|Generates {{the control}} <b>flow</b> <b>graph</b> of each {{function}} per source file ...|$|E
30|$|The {{hierarchy}} of an HCDFG {{is shown in}} Figure 3. An HCDFG can consist of other HCDFGs, Control/Data <b>flow</b> <b>graphs</b> (CDFGs) and data <b>flow</b> <b>graphs</b> (DFGs) as well as elementary nodes (processing, memory, and control nodes). An HCDFG is connected via dependency edges. In this work we only explore the graph at levels above the DFGs, and therefore only concentrate on these when we define the graph types in what follows.|$|R
40|$|Abstract. We {{consider}} {{association of}} decision trees and <b>flow</b> <b>graphs,</b> {{resulting in a}} new method of decision rule generation from data, and giving a better insight in data structure. The introduced <b>flow</b> <b>graphs</b> can also give {{a new look at}} the conception of probability. We show that in some cases the conception of probability can be eliminated and replaced by a study of deterministic flows in a flow network. ...|$|R
40|$|This report {{contains}} {{a set of}} lecture notes {{that were used in}} the spring of 2003 for a mini course of six lectures on the subject of streams, coinduction and signal <b>flow</b> <b>graphs.</b> It presents an application of coinductive stream calculus (as introduced in Technical Report SEN-R 0023, CWI, Amsterdam, 2000) to signal <b>flow</b> <b>graphs.</b> In comparison to existing approaches, which are usually based on Laplace and Z-transforms, the model presented in these notes is very elementary. From a didactical point of view, the formal treatment of <b>flow</b> <b>graphs</b> is interesting because it deals with two fundamental phenomena in the theory of computation: memory (in the form of register or delay elements) and infinite behaviour (in the form of feedback) ...|$|R
50|$|A signal <b>flow</b> <b>graph</b> {{for these}} {{equations}} {{is shown to}} the right.|$|E
50|$|Robert Endre Tarjan and Jacobo Valdes (1980) used triconnected {{components}} for structural analysis of biconnected flow graphs. The triconnected {{components of the}} undirected version of a <b>flow</b> <b>graph</b> are shown to be useful for discovering structural information of directed flow graphs. The triconnected components can be discovered efficiently and form a hierarchy of SESE fragments of a <b>flow</b> <b>graph.</b>|$|E
5000|$|An {{example of}} a <b>flow</b> <b>graph</b> {{connected}} to some starting equations is presented.|$|E
5000|$|Rooted {{directed}} graphs (also {{known as}} <b>flow</b> <b>graphs)</b> are digraphs {{in which a}} vertex has been distinguished as the root.|$|R
40|$|We present {{early work}} on a PVS {{implementation}} of a model of simple control as signal <b>flow</b> <b>graphs</b> to enable formal verification of input/output behaviour of the control system. As has been shown by Rutten, Signal <b>flow</b> <b>graphs</b> can be described using Escardo's coinductive stream calculus, which includes a definition of di#erentiation for streams over the real numbers {{and the use of}} di#erential equations. The basics of coinductive stream calculus has been implemented in PVS...|$|R
40|$|Applications in {{the signal}} {{processing}} domain are often modeled by data <b>flow</b> <b>graphs.</b> Due to heterogeneous complexity requirements, these graphs contain both dynamic and static data flow actors. In previous work, we presented a generalized clustering approach for these heterogeneous data <b>flow</b> <b>graphs</b> {{in the presence}} of unbounded buffers. This clustering approach allows the application of static scheduling methodologies for static parts of an application during embedded software generation for multi-processor systems. It systematically exploits the predictability and efficiency of the static data flow model to obtain latency and throughput improvements. In this paper, we present a generalization of this clustering technique to data <b>flow</b> <b>graphs</b> with bounded buffers, therefore enabling synthesis for embedded systems without dynamic memory allocation. Furthermore, a case study is given to demonstrate the performance benefits of the approach...|$|R
5000|$|Every node on a <b>flow</b> <b>graph</b> of {{a program}} belongs to one DD-path.|$|E
5000|$|Leapfrog filter for {{an example}} of filter design using a signal <b>flow</b> <b>graph</b> ...|$|E
5000|$|... #Caption: Signal <b>flow</b> <b>graph</b> {{refactoring}} rule: replacing outflowing edges {{with direct}} flows from inflowing sources.|$|E
40|$|In {{the pursuit}} of massively {{multiplayer}} online games, efficient engines capable of processing sophisticated game scenarios are necessary to support large scale virtual worlds. By applying microprocessor microarchitectural design techniques to game server software design, functional parallelism inherent in complex game transactions can be exploited, augmenting server performance. In a given gaming scenario, complex game transactions can be modeled as data <b>flow</b> <b>graphs.</b> An individual graph represents the collective atomic operations of a particular transaction. Analysis of data <b>flow</b> <b>graphs</b> provides a mechanism that identifies opportunities for parallelism by exposing data dependencies. This poster presents an engine architecture that supports spatial and temporal parallel execution of complex game transactions expressed as data <b>flow</b> <b>graphs.</b> The engine takes advantage of data flow enhancement techniques such as dynamic out-of-order execution to enhance performance...|$|R
40|$|The {{most of the}} {{analyses}} {{evaluating the quality of}} code are derived from Control <b>Flow</b> <b>Graphs</b> [...] CFG. Model-based testing as one of them uses paths found in CFG for generation of test cases. To ease use of a general analysis of CFG, {{there is a need for}} CFG to contain instructions of some general instruction set. This work deals with extraction of control <b>flow</b> <b>graphs</b> from Java bytecode, followed by a translation of the instructions inside basic blocks into LLVM IR set. The resulting program is able to reliably extract control <b>flow</b> <b>graphs</b> from a Java program, given in any of its casual forms (. jar archive,. java or. class file). In addition to that, the graphs on output are assembled so, that they can be analyzed in order to generate unit tests...|$|R
40|$|AbstractThis paper {{presents}} {{an application of}} coinductive stream calculus to signal <b>flow</b> <b>graphs.</b> In comparison to existing approaches, which are usually based on Z-transforms (a discrete version of Laplace transforms) and transfer functions, the model presented in these notes is very elementary. The formal treatment of <b>flow</b> <b>graphs</b> is interesting because it deals with two fundamental phenomena {{in the theory of}} computation: memory (in the form of register or delay elements) and infinite behaviour (in the form of feedback) ...|$|R
