1|423|Public
40|$|Summary: Web {{applications}} {{have been}} the main intrusion target, and input errors from the web users lead to serious security vulnerabilities. Many web applications contain such errors, making them vulnerable to remotely exploitable input validation attacks such as SQL Injection, Command Injection, Meta-Characters, Formatting String, Path Traversal and Cross Site scripting. In this paper, we present ontology to represent patterns of input validation attacks on web applications. More specifically, our ontology is based on individual subclasses, properties and inverse functional properties, domain and range of <b>input</b> <b>validation</b> <b>attack</b> patterns. The ontology is implemented and interpreted with the web application development language OWL (Ontology Web Language) ...|$|E
40|$|The {{software}} life cycle was in use {{to develop the}} good software. Now a day’s the software development life cycle should incorporate the security features. <b>Input</b> <b>Validation</b> <b>Attacks</b> {{are one of the}} most wide spread forms of vulnerability on the Web application. Our main intention is to focuses on detection and prevention of <b>Input</b> <b>Validation</b> <b>attacks</b> like SQL Injection, Cross Site Scripting and Buffer Overflow by incorporating security in software development life cycle. We have introduced a novel approach of preclusion and uncovering of <b>Input</b> <b>Validation</b> <b>Attacks.</b> SQL Injection, Cross Site Scripting, A buffer overflow attacks, experimentations are made to do these attacks on various sides and the defense mechanism model is proposed to avoid these attacks on the code...|$|R
40|$|Internet {{continues}} to expand exponentially {{and access to the}} Internet become more prevalent in our daily life {{but at the same time}} web application are becoming most attractive targets for hacker and cyber criminals. This paper presents an enhanced intrusion detection system approach for detecting <b>input</b> <b>validation</b> <b>attacks</b> in the web application. The existing IDS for <b>Input</b> <b>validation</b> <b>attacks</b> are language dependent. The proposed IDS is language independent i. e. it works for any web application developed with the aid of java, php, dot net etc. In addition the proposed system detects directory traversal attacks, command injection attacks, cross site scripting attacks and SQL injection attacks, those were not detected in the existing IDS. This is an automatic technique for detection vulnerabilities over the internet. Our technique is based on the web application parameter which is in form of POST and GET which has generalized structure and values. This technique reduces analysis time of <b>input</b> <b>validation</b> <b>attacks...</b>|$|R
40|$|Errors in <b>validation</b> of user <b>inputs</b> lead {{to serious}} {{security}} vulnerabilities. Many web applications contain such errors, making them vulnerable to remotely exploitable <b>input</b> <b>validation</b> <b>attacks</b> such as SQL injection, and cross site scripting. In this paper, {{we present a}} dynamic taint analysis technique to detect the <b>input</b> <b>validation</b> <b>attacks.</b> More specifically, our technique is based on tracking flow of taint information from untrusted input into {{the parts of the}} generated output (or commands). A unique benefit of our approach is that it can be applied to all of the web application development languages whose interpreters are implemented in C. We demonstrate this ability by applying our technique on web applications which use PHP, and bash scripts. Our technique is implemented as a fully automatic source-to-source transformation. We present experimental evaluation to establish effectiveness of our approach, paying particular attention to its attack detection ability. Experiments demonstrate that our technique detects all the attacks accurately with no false alarms...|$|R
40|$|In the {{internet}} era web applications are mostly {{targeted by the}} hackers. In this paper we presents an efficient intrusion detection system for detecting <b>input</b> <b>validation</b> <b>attacks</b> against web application. Web applications give the chance to the attacker to get unrestricted access to data base and web servers. By using our approach we can prevent <b>input</b> <b>validation</b> <b>attacks</b> against web applications in an efficient way. It presents detection mode using pair wise sequence alignment of amino acid code formulated form parameter sent via web application. These parameters analyzed by the intrusion system to find malicious access. In this we used an efficient Hirschberg algorithm this is an divide and conquer approach to find attacks against web applications. This system analyzes malicious code and immediately generates an alert to protect web applications from the attacker. By using this technique we can reduce the analysis time and false positive rate. Experimental results shows that our proposed intrusion detection technique is efficient compared to other systems...|$|R
40|$|Intrusion Detection Systems (IDS) {{tools are}} {{deployed}} within networks to monitor data that is transmitted to particular destinations such as MySQL,Oracle databases or log files. The data is normally dumped to these destinations without a forensic standard structure. When digital evidence is needed, forensic specialists {{are required to}} analyse a very large volume of data. Even though forensic tools can be utilised, most of this process {{has to be done}} manually, consuming time and resources. In this research, we aim to address this issue by combining several existing tools to archive the original IDS data into a new container (Digital Evidence Bag) that has a structure based upon standard forensic processes. The aim is to develop a method to improve the current IDS database function in a forensic manner. This database will be optimised for future, forensic, analysis. Since evidence validity is always an issue, a secondary aim of this research is to develop a new monitoring scheme. This is to provide the necessary evidence to prove that an attacker had surveyed the network prior to the attack. To achieve this, we will set up a network that will be monitored by multiple IDSs. Open source tools will be used to carry <b>input</b> <b>validation</b> <b>attacks</b> into the network including SQL injection. We will design a new tool to obtain the original data in order to store it within the proposed DEB. This tool will collect the data from several databases of the different IDSs. We will assume that the IDS will not have been compromised...|$|R
40|$|Network Intrusion {{detection}} systems (NIDS) are {{security systems}} utilized to detect security threats to computer networks. They usually log events and store other {{information that is}} useful for forensic purposes. Laurensen (2010) showed that the forensic capability of IDS in wireless networks was dependent on packet rates and under high workloads up to 50 % of the packets passed uninspected. He concluded that a forensically ready network required more than IDS to assure sufficient evidence could be available after events. In this research it is proposed to test a selection of common NIDS (as listed below) and to evaluate the performance under different work loadings. The common attack problems and short comings are also to be explored. For example <b>input</b> <b>validation</b> <b>attacks,</b> signature recognition algorithms and attack vector information. The implications will be for a forensic treatment of NIDS capability and recommendations for fixing the short falls in current NIDS tools by specifying system requirements. The main goal of the research project addresses the implementation of common open source NIDSs and their capabilities for acquiring and preserving network digital evidence under workloads. The objective is to report the best practice for handling and reporting evidentiary trails from two types of <b>input</b> <b>validation</b> <b>attacks.</b> The architecture of the proposed system consists of two networks and these networks are a simulated internet network and a host-only production network. Each network has specific components. The internet network includes four machines producing traffic from common stress tools and one machine producing the Cross-site scripting and SQL injection attacks against the web server. The production networks consist of a webserver with a vulnerable web application for the proposed attacks, a firewall with NIDS including Snort, Suricata and Bro-IDS, and finally a forensic server. As a result, the proposed system works to monitor and forensically study the transmitted traffic between both networks. Four phases were conducted during {{the life of the}} research project: two initial phases were conducted to ensure the stability of the test bed and the final two phases were conducted to carry out the formal testing. Phases one and two of the initial testing consist of the implementation and installation of all the network components, the NIDSs configurations, the network performance monitoring system and the creation of the training traffic. The initial test was built to evaluate and determine the capabilities of the performance monitoring system and the NIDSs’ alert detections for the proposed attacks. Phase three recreated workload traffic and measured the performance of each NIDS in term of the resources usages and the detected alerts. Phase four consists of two methods of the evidence collection and recording the best practice to acquire and preserve the evidentiary trails of the attacks. The findings demonstrate that the proposed NIDSs’ {{can be used as a}} source of digital evidence. However, those NIDSs suffer from number of issues including dropped packets before reaching their engines. The issue is largely related to the interception functions and those functions need to be improved to eliminate the problem. Also, the findings demonstrate the fact that the extraction of the evidence can be another problem area that needs solution. In the research scripts were written to improve tool performance and preservation capability (see Appendix F for the code). Moreover, the evidence analysis examined by two different methods was either time consuming or had difficulties with making correct timestamps. Overall, this thesis shows the limitations of the NIDS, shows how the current tools can be improved, and provides advice on how to overcome common investigation issues...|$|R
40|$|<b>Input</b> <b>validation</b> {{has long}} been {{recognized}} as an essen-tial part of a well–designed system, yet existing liter-ature gives {{very little in the}} way of formal axioms for <b>input</b> <b>validation</b> or guidance on how to put in practice what few recommendations exist. We present basic formal axioms for <b>input</b> <b>validation</b> and apply them to sql, where we demonstrate enhanced resistance to injection attacks...|$|R
40|$|In {{this paper}} we {{introduce}} the topic <b>input</b> <b>validation,</b> analyze its {{great importance to}} Web applications and suggest a new comprehensive approach to <b>input</b> <b>validation.</b> The approach has been developed {{as a result of}} an evaluation of current <b>input</b> <b>validation</b> approaches that showed that no sufficient solution to common <b>input</b> <b>validation</b> requirements is available at present. The paper describes important requirements for <b>input</b> <b>validation</b> frameworks, especially in the Web context, and introduces main concepts of this approach. The approach is based on the declarative, rule based definition of validation logic and the automatic translation of validation rules into server side and client side code. It supports conditional, composite and complex inter-field validation scenarios. It considers topics such as value normalization, inter-field dependencies and validation actions and integrates these aspects into a consistent validator based system. Our evaluation shows the benefits of this new approach and highlights its advantages compared to other popular and promising approaches such as PowerForms or Topes...|$|R
40|$|Abstract—Client-side {{computation}} in web applications {{is becoming}} increasingly common due to the popularity of powerful client-side programming languages such as JavaScript. Clientside computation is commonly used to improve an application’s responsiveness by validating user inputs before they are sent to the server. In this paper, we present an analysis technique for checking if a client-side <b>input</b> <b>validation</b> function conforms to a given policy. In our approach, <b>input</b> <b>validation</b> policies are expressed using two regular expressions, one specifying the maximum policy (the upper bound for the set of inputs that should be allowed) and the other specifying the minimum policy (the lower bound for the set of inputs that should be allowed). Using our analysis we can identify two types of errors 1) the <b>input</b> <b>validation</b> function accepts an input that is not permitted by the maximum policy, or 2) the <b>input</b> <b>validation</b> function rejects an input that is permitted by the minimum policy. We implemented our analysis using dynamic slicing to automatically extract the <b>input</b> <b>validation</b> functions from web applications and using automata-based string analysis to analyze the extracted functions. Our experiments demonstrate that our approach is effective in finding errors in <b>input</b> <b>validation</b> functions that we collected from real-world applications and from tutorials and books for teaching JavaScript. I...|$|R
40|$|Abstract [...] The {{internet}} {{has evolved into}} a critical delivery pipeline for institutions to interact with Customers, partners and employees. Peoples use web sites to send and receive Information via Hypertext Markup Language (HTML) messages to web applications reside on web servers. Generally this information, expected as legitimate messages, can be used illegitimately by the unauthorized persons to compromise security vulnerabilities. Web application vulnerabilities provide the potential for an unauthorized party to gain access to critical and sensitive information, use resources inappropriately, interrupt web based business transactions or commit fraud. The cause for all inconvenience and fraud in web, improper input handling {{is one of the most}} common weaknesses identified across applications today. Poorly handled input is a leading cause behind critical vulnerabilities that exist in systems and applications. Generally, the term input handling is used to describe functions like validation, sanitization, filtering, encoding and/or decoding of input data. Applications receive input from various sources including human users, software agents, and network/peripheral devices etc. all input data should be considered as untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, XSS attacks, OS Commanding, Denial of Service and many more. Among all, SQLIA and XSS are most common and serious threats to web applications. This paper describes all aspects of SQL injection attacks and defenses. Keywords [...] <b>input</b> <b>validation,</b> SQLIA, XSS <b>attacks,</b> web applications, SQL injection Defense, untrusted data I...|$|R
5000|$|<b>Input</b> <b>validation,</b> such as {{whitelisting}} {{only known}} good values ...|$|R
2500|$|Security best {{practices}} (<b>Input</b> <b>Validation,</b> SQL Injection, Cross-Site Scripting, etc. [...] ) ...|$|R
40|$|Abstract — <b>Input</b> <b>validation</b> {{refers to}} {{checking}} user inputs {{to a program}} {{to ensure that they}} conform to expectations of the program. <b>Input</b> <b>validation</b> is used to check the format of numbers and strings, check the length of strings, and to ensure that strings do not contain invalid characters. <b>Input</b> <b>validation</b> testing (IVT) is particularly important for software that has a heavy reliance on user inputs, including Web applications. A common technique in Web applications is to perform <b>input</b> <b>validation</b> on the client by using HTML attributes and scripting languages such as JavaScript. An insidious problem with performing <b>input</b> <b>validation</b> on the client is that end users have the ability to bypass this validation. Bypass testing is a unique and novel way to create test cases that is available only because of the unusual mix of client-server, HTML GUI, and JavaScript technologies that are used in Web applications. This workshop paper presents the issues and concerns that allow bypass testing, the preliminary concepts behind the technique, and some early results on applying it. How effective and useful bypass testing can be in testing Web applications will be determined through ongoing research and automation...|$|R
40|$|Since web {{applications}} are easily accessible, and often store {{a large amount}} of sensitive user information, they are a common target for attackers. In particular, attacks that focus on <b>input</b> <b>validation</b> vulnerabilities are extremely effective and dangerous. To address this problem, we developed ViewPoints—a technique that can identify erroneous or insufficient validation and sanitization of the user inputs by automatically discovering inconsistencies between clientand server-side <b>input</b> <b>validation</b> functions. Developers typically perform redundant <b>input</b> <b>validation</b> in both the front-end (client) and the back-end (server) components of a web application. Clientside validation is used to improve the responsiveness of the application, as it allows for responding without communicating with the server, whereas server-side validation is necessary for security reasons, as malicious users can easily circumvent client-side checks. ViewPoints (1) automatically extracts client- and server-side <b>input</b> <b>validation</b> functions, (2) models them as deterministic finite automata (DFAs), and (3) compares client- and server-side DFAs to identify and report the inconsistencies between the two sets of checks. Our initial evaluation of the technique is promising: when applied to a set of real-world web applications, ViewPoints was able to automatically identify a large number of inconsistencies in their <b>input</b> <b>validation</b> functions...|$|R
2500|$|Ensure <b>input</b> <b>validation</b> {{to avoid}} cross-site {{scripting}} flaws or SQL injections flaws ...|$|R
5000|$|<b>Input</b> <b>validation</b> [...] - [...] {{verify that}} each sensor is {{providing}} valid data ...|$|R
5000|$|<b>Input</b> <b>validation,</b> e.g. (in SQL): [...] is {{an example}} of a SQL {{injection}} vulnerability ...|$|R
5000|$|Improper <b>input</b> <b>validation</b> [...] - [...] {{a type of}} {{software}} security vulnerability particularly relevant for user-given strings ...|$|R
50|$|For instance, {{database}} normalization is {{the process}} of organizing the fields and tables of a relational database to minimize redundancy and dependency. In the field of software security, a common vulnerability is unchecked malicious input. The mitigation for this problem is proper <b>input</b> <b>validation.</b> Before <b>input</b> <b>validation</b> may be performed, the input must be normalized, i.e., eliminating encoding (for instance HTML encoding) and reducing the input data to a single common character set.|$|R
5000|$|With SQL Injection, {{one can use}} {{parameterized}} queries, stored procedures, whitelist <b>input</b> <b>validation,</b> {{and more}} to help mitigate Code Injection problems.|$|R
50|$|Improper <b>input</b> <b>validation</b> or {{unchecked}} {{user input}} {{is a type}} of vulnerability in computer software that may be used for security exploits.|$|R
40|$|Internet {{remains to}} blow up {{exponentially}} and has become more significant in our everyday life, but this resulted in web application targeted by cyber crooks and hacker. The paper identifies vulnerability attacks caused due to inputs performed by a user which are not properly validated across the web application. The existing IDS designed for <b>validation</b> vulnerability <b>attacks</b> are language reliable. Survey paper present a proposed IDS concept which is not language reliant i. e. it is designed for any web application developed {{with the support of}} PHP, Java, Dotnet etc. Such concept of IDS is helpful to detect <b>input</b> <b>validation</b> weaknesses like directory traversal attacks, cross site scripting attacks and SQL injection attacks; these were not detected in the extant IDS...|$|R
50|$|LDAP {{injection}} is a known {{attack and}} can be prevented by simple measures. All of the client supplied input must be checked/sanitized of any characters that may result in malicious behavior. The <b>input</b> <b>validation</b> should verify the input by checking {{for the presence of}} special characters that {{are a part of the}} LDAP query language, known data types, legal values, etc. White list <b>input</b> <b>validation</b> can also be used to detect unauthorized input before it is passed to the LDAP query.|$|R
40|$|<b>Input</b> <b>validation</b> is {{essential}} for any software that deals with input from its external environment. It forms {{a major part of}} such software that has intensive interaction with its environment. Through the integration of invariant and empirical properties for implementing <b>input</b> <b>validation,</b> this paper proposes a novel approach for the automation of the following tasks from processing the source code of a program: (1) verification of existence of input validation; (2) generation of test cases to test and demonstrate all the input validations; (3) classification of each validation into the various types defined along with its test case generated. All the empirical properties in the theory have been validated statistically based on open source systems. Our evaluation shows that the proposed approach can help in both testing of <b>input</b> <b>validation</b> features and verifying the adequacy of input control...|$|R
40|$|Security is an {{integral}} part of most software systems but it is not considered as an explicit part in the development process yet. <b>Input</b> <b>validation</b> is the most critical part of software security that is not covered in the design phase of software development life-cycle resulting in many security vulnerabilities. Our objective is to extend UML to new integrated framework for model driven security engineering leading to ideal way to design more secure software. <b>Input</b> <b>validation</b> in UML has not been addressed previously, hence we incorporate <b>input</b> <b>validation</b> into UML diagrams such as use case, class, sequence and activity. This approach has some advantages such as preventing from common input tampering attacks, having both security and convenience in software at high level of abstraction and ability of solving the problem of weak security background for developers...|$|R
40|$|Web {{software}} applications {{are increasingly being}} deployed in sensitive situations. Web applications are used to transmit, accept and store data that is personal, company confidential and sensitive. <b>Input</b> <b>validation</b> testing (IVT) checks user inputs {{to ensure that they}} conform to the program’s requirements, which is particularly important for software that relies on user inputs, including Web applications. A common technique in Web applications is to perform <b>input</b> <b>validation</b> on the client with scripting languages such as JavaScript. An insidious problem with client-side <b>input</b> <b>validation</b> is that end users can bypass this validation. Bypassing validation can reveal faults in the software, and can also break the security on Web applications, leading to unauthorized access to data, system failures, invalid purchases and entry of bogus data. We are developing a strategy called bypass testing to create IVT tests. This paper describes the strategy, defines specific rules and adequacy criteria for tests, describes a proof-of-concept automated tool, and presents initial empirical results from applying bypass testing. ...|$|R
40|$|Accepting unvalidated input is {{considered}} today's greatest web security threat. This master's thesis addresses that threat by proposing an automatic and centralized mechanism for validating web services input. By building on existing web services standards, the proposed solution intercepts incoming web service requests and validates them against a security policy. A major design goal {{for this work}} was to realize web services <b>input</b> <b>validation</b> without modifying existing functionality. That is, the <b>input</b> <b>validation</b> security mechanism should be added out of code. This is achieved by keeping the web services and the <b>validation</b> mechanism separate. <b>Input</b> <b>validation</b> configuration is accomplished by modifying a configuration file. Even when the validation mechanism logic is correct, it may not function as intended. Such anomalies are in most cases caused by human-introduced errors in the configuration file, resulting in {{the need for a}} configuration file verification tool. This thesis proposes a verification tool that quantifies the level of security by analyzing the configuration file. </p...|$|R
50|$|WMLScript is a {{client-side}} {{scripting language}} and {{is similar to}} JavaScript. Just like JavaScript WMLScript is used for tasks such as user <b>input</b> <b>validation,</b> generation of error message and other Dialog boxes etc.|$|R
40|$|An {{increasing}} number of cyber attacks are occurring at the application layer when attackers use malicious <b>input.</b> These <b>input</b> <b>validation</b> vulnerabilities can be exploited by (among others) SQL injection, cross site scripting, and buffer overflow attacks. Statement coverage and similar test adequacy metrics have historically been {{used to assess the}} level of functional and unit testing which has been performed on an application. However, these currently-available metrics do not highlight how well the system protects itself through validation. In this paper, we propose two SQL injection <b>input</b> <b>validation</b> testing adequacy metrics: target statement coverage and input variable coverage. A test suite which satisfies both adequacy criteria can be leveraged as a solid foundation for <b>input</b> <b>validation</b> scanning with a blacklist. To determine whether it is feasible to calculate values for our two metrics, we perform a case study on a web healthcare application and discuss some issues in implementation we have encountered. We find that the web healthcare application scored 96. 7 % target statement coverage and 98. 5 % input variable coverage...|$|R
40|$|Enhancements: better <b>input</b> <b>validation</b> {{and error}} {{reporting}} (alignment/starting tree) Bugfixes: compilation with gcc 7 (# 17) failed assertion in MSA::remove_sites failed assertion in pllmod_algo_spr_round (fix libpll error propagation) fix excessive memory allocation during pattern compression ([URL]...|$|R
50|$|Two central {{categories}} of mitigation {{to the problems}} caused by weird machine functionality include <b>input</b> <b>validation</b> within the software and protecting against problems arising from the platform on which the program runs, such as memory errors. <b>Input</b> <b>validation</b> aims to limit the scope and forms of unexpected inputs e.g. through whitelists of allowed inputs, so that the software program itself would not end up in an unexpected state by interpreting the data internally. Equally importantly, secure programming practices such as protecting against buffer overflows make it less likely that input data becomes interpreted in unintended ways by lower layers, such as the hardware on which the program is executed.|$|R
5000|$|The {{data type}} {{of the value}} column/s in a row-modeled table is pre-determined {{by the nature of}} the facts it records. By contrast, in an EAV table, the {{conceptual}} data type of a value in a particular row depend on the attribute in that row. It follows that in production systems, allowing direct data entry into an EAV table would be a recipe for disaster, because the database engine itself would not be able to perform robust <b>input</b> <b>validation.</b> We shall see later how it is possible to build generic frameworks that perform most of the tasks of <b>input</b> <b>validation,</b> without endless coding on an attribute-by-attribute basis.|$|R
5000|$|Form {{request is}} {{a feature of}} Laravel 5 {{that serves as the}} base for form <b>input</b> <b>validation</b> by {{internally}} binding event listeners, resulting in automated invoking of the form validation methods and generation of the actual form.|$|R
40|$|The <b>Input</b> <b>Validation</b> Testing #IVT# {{technique}} {{has been developed}} {{to address the problem}} of statically analyzing input command syntax as de#ned in English textual interface and requirements speci#cations and then generating test cases for <b>input</b> <b>validation</b> testing. The technique does not require design or code, so it can be appliedearly in the lifecycle. A proof-of-concept tool has been implemented and validation has been performed. Empirical validation on industrial software shows that the IVT method found morerequirement speci#cation defects than senior testers, generated test cases with higher syntactic coverage than senior testers, and found defects that were not found by the test cases of senior testers. Additionally, the tool performed at a much-reducedcost...|$|R
50|$|Vulnerability {{assessment}} {{is a process}} of defining, identifying and classifying the security holes in information technology systems. An attacker can exploit a vulnerability to violate the security of a system. Some known vulnerabilities are Authentication Vulnerability, Authorization Vulnerability and <b>Input</b> <b>Validation</b> Vulnerability.|$|R
