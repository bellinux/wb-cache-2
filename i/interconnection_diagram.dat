2|7|Public
40|$|Large {{and complex}} {{embedded}} software applications {{are almost always}} integrated out of smaller, more tangible modules. This {{is especially true for}} software that goes in an automotive powertrain control system. In this paper we present new tools and techniques that are useful for doing this integration. The research presented here is an outcome of the DARPA-funded MoBIES program; an acronym that stands for Model-Based Integration of Embedded Systems. A typical powertrain control system consists of approximately 50 - 60 software ‘features’. Roughly speaking, a feature is a module that has a specific purpose, execution context, data model and input/output interface. Examples of features are ‘Electronic throttle control monitor’, ‘Fuel-injection driver ’ and so on. These features are interconnected through their inputs and outputs and each feature has 10 - 100 such inputs and outputs. Furthermore, the interconnections are implicitly constrained by ‘units’, ‘scales ’ and so forth. It is not hard to see that integrating the complete system out of these features is no easy task. Semantic compatibility aside, very few diagram editors can handle the <b>interconnection</b> <b>diagram</b> in a presentable manner. Due to the large number of modules and interconnections, powertrain control software developers rely on software management, modeling and simulation tools to integrate the overall system. I...|$|E
40|$|The {{analysis}} of existing software architectures may {{be supported by}} a relational approach. The approach is based on relational algebra with multi-relations extended with a theory about 2 ̆ 2 lifting 2 ̆ 2. Lifting transforms a relation at {{a certain level of}} the decomposition structure of a system (e. g. the module level) to a higher level (e. g. the subsystem level). The application of lifting has been reported for various industrial contexts for balanced systems (i. e. systems where the decomposition structure is a balanced tree). This paper reports upon a more liberal kind of lifting, termed 2 ̆ 2 oblique lifting 2 ̆ 2, which has the important advantage that it can also be used for unbalanced systems. Lowering, the opposite of lifting, can be liberalized in a similar fashion. The use of oblique lowering is illustrated by means of a typical example from the field of software architecture verification. The leading example of this paper uses the relational approach as a formal basis for a software architecture browser visualizing the module interconnection architecture of a software system. Oblique lifting is applied to hiding the decomposition structure of a module in a module <b>interconnection</b> <b>diagram</b> by choosing an appropriate mapping. After the hiding, various kinds of weights (or multiplicities) may be associated with the interconnections in the resulting diagram. Four definitions of weights are described, including the formalization of their related operations, with each weight having its own merits during architectural analysi...|$|E
40|$|A {{portable}} payload and check-out {{facility is}} described. A {{system that is}} easily transported has been provided by a modular design in which the equipment is shock mounted in transit cases for shipment and use in payload check-out. Function versatility is obtained by use of a removable program board. The program and function identification overlay panels for switches and monitored voltages minimize the effort and time for changeover between different rocket payloads. A complete set of electrical <b>interconnection</b> <b>diagrams</b> and schematics for custom equipment is included. Peer reviewed: NoNRC publication: Ye...|$|R
50|$|While a {{small amount}} of data could be {{represented}} in a circular diagram using straight lines to show the <b>interconnections,</b> a <b>diagram</b> featuring numerous lines would quickly become illegible. To reduce the visual complexity, chord diagrams employ a technique called hierarchical edge bundling.|$|R
40|$|We {{propose a}} {{specification}} style which combines the features and advantages of object-oriented and constraint-oriented system decomposition. A system description is decomposed into data-handling objects, which usually reflect objects and individual {{operations in the}} real system, and temporal-ordering constraints, which capture aspects of functionality as behavioural sequences, with a possibility to introduce also entities which blurr the distinction between these two extreme cases. Composition is achieved via synchronisation on shared operations: different objects/constraints insisting on an operation express different views on the enabling conditions and effects of that operation. Objects, constraints, and their composition can be formally specified in Object-Z, an object-oriented extension of the Z notation, with pure temporal ordering constraints equivalently expressed as transition graphs. However, expressing object/constraint compositions in Object-Z is cumbersome. We solve this problem by proposing a natural textual notation, called co-expression, which is a most direct description of an object/constraint interconnection graph, and we define a mapping from co-expressions to Object-Z. Thus, specifications in an object/constraint-oriented style can be conveniently written using transition graphs and <b>interconnection</b> <b>diagrams</b> mixed with Object-Z text, and then translated into this language...|$|R
40|$|The {{extraction}} of reusable software components from existing systems {{is an attractive}} idea. The goal {{of the work in}} this paper is not to extract a component automatically, but to identify its tightly coupled region (subsystem) for extraction by hand or knowledge-based system. Much of our experience is anecdotal. Our experience with scientific systems differs from much of the work in reverse engineering that focuses on COBOL systems. Module and data interconnection was collected from three large scientific systems over a 12 year period from 1980 to 1992. The interconnection data was analyzed in an attempt to identify subsystems that correspond to domain-specific components. The difficulties of dealing with large scientific systems and their organizations are discussed. The failures and successes of various subsystem analysis methods is discussed. A simple algorithm for the identification of subsystems is presented. A pattern of object hierarchies of subsystems is briefly mentioned. The average subsystem is surprisingly large at 17, 000 source lines and 35 modules. The concept of a subsystem is informally validated by developers from subsystem <b>interconnection</b> <b>diagrams.</b> The actual reusability of these identified components is not assessed. Keywords: reuse, component, subsystem 1...|$|R
40|$|Abstract [...] Optimal and {{effective}} {{operation of a}} large power system requires analysis of {{a huge amount of}} information by the system operators. In a large power system, it is a challenge to present the vast amount of data in a way, which assists the operators in assessing the state of the system and responding expeditiously. Restructuring of the power sector worldwide, the advent of new market mechanisms and the need to analyze various parameters and available security margins has made this challenge all the more formidable. These challenges are a prime mover for the continuous improvement and evolution of new visualization techniques. Effective visualization methods, techniques and tools are key to empowering the system operator and facilitating quick operator response under critical conditions. Internet and the development of new IT tools have added a new dimension for the power system operator. Analysis in real time and drill-downs into the data are required by the operator for a detailed investigation. Effective power system visualization capability is a strong motivating factor for the operator for improving his response and productivity. This paper describes the visualization methods, tools and techniques implemented and used by the Indian power system operator. Classical displays including single line diagrams, tabular displays, load curves, bar charts, pie charts, tie line <b>interconnection</b> <b>diagrams,</b> etc. have been discussed. New methods used more recently like multi-layered displays, macro visualization of a parameter over longer duration using zooming and panning, 3 -D presentations, contours, data leveling, animation etc. and future methods such as GIS Maps are discussed. The human aspects and the ability of operators to comprehend and respond to the information presented to them in various formats are also discussed...|$|R
5000|$|A {{wiring diagram}} usually gives {{information}} about the relative position and arrangement of devices and terminals on the devices, to help in building or servicing the device. This is unlike a schematic diagram, where {{the arrangement of the}} components' <b>interconnections</b> on the <b>diagram</b> usually does not correspond to the components' physical locations in the finished device. A pictorial diagram would show more detail of the physical appearance, whereas a wiring diagram uses a more symbolic notation to emphasize interconnections over physical appearance.|$|R
40|$|This paper uses {{concepts}} from sheaf {{theory to}} explicate phenomena in concurrent systems, including object, inheritance, deadlock, and non-interference, {{as used in}} computer security. The approach is very general, and applies not only to concurrent object oriented systems, but also to systems of differential equations, electrical circuits, hardware description languges, and much more. Time can be discrete or continuous, linear or branching, and distribution is allowed over space as well as time. Concepts from category theory help to achieve this generality: objects are modeled by sheaves; inheritance by sheaf morphisms; systems by diagrams; and <b>interconnections</b> by <b>diagrams</b> of diagrams. In addition, behaviour is given by limit, {{and the result of}} interconnection by colimit. The approach is illustrated with many examples, including a semantics for a simple concurrent object-based programming language. 1 Introduction Many popular formalisms for concurrent systems are syntactic (or "formal [...] ...|$|R

