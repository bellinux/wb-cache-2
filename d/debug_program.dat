9|1192|Public
50|$|Depending {{upon the}} system, {{low-level}} formatting was generally done by an operating system utility. IBM compatible PCs used the BIOS, which is invoked using the MS-DOS <b>debug</b> <b>program,</b> to transfer control to a routine hidden at different addresses in different BIOSes.|$|E
50|$|When the DOS <b>DEBUG</b> <b>program</b> is in memory, Ontario.2048 will detect it and {{disinfect}} {{programs in}} memory {{to avoid being}} analysed. Ontario.2048 also features an extremely complex encryption system; a given sample of Ontario.2048 may only share two bytes in common with another.|$|E
50|$|The MEK6800D2 was a {{development}} {{board for the}} Motorola 6800 microprocessor, produced by Motorola in 1976. It featured a keyboard with hexadecimal keys and a LED display, but also featured an RS-232 asynchronous serial interface for a Teletype or other terminal. There was an on-board <b>debug</b> <b>program</b> called JBUG fitted in a 1k ROM, and the maximum RAM capacity on board was 512 bytes, but this could be expanded via the Motorola EXORciser computer bus interface.|$|E
5000|$|DBX is also {{available}} on IBM z/OS systems, in the UNIX System Services component. DBX for z/OS can <b>debug</b> <b>programs</b> written in C and C++, and can also perform machine level debugging. As of z/OS V1R5, DBX is able to <b>debug</b> <b>programs</b> using the DWARF debug format. z/OS V1R6 added support for <b>debugging</b> 64-bit <b>programs.</b>|$|R
50|$|To {{compile a}} program using {{multiple}} threads with the Microsoft C/C++ Compiler, you must specify the /MT switch (or /MTd, for <b>debug</b> <b>programs).</b>|$|R
50|$|A model-specific {{register}} (MSR) is any {{of various}} control registers in the x86 instruction set used for <b>debugging,</b> <b>program</b> execution tracing, computer performance monitoring, and toggling certain CPU features.|$|R
40|$|An assembly-language <b>debug</b> <b>program</b> {{written for}} the Honeywell HDC- 601 and DDP- 516 / 316 {{computers}} is described. Names and relative addressing to improve operator-machine interaction are used. Features include versatile display, on-line assembly, and improved program execution and analysis. The program is discussed from both a programmer's and an operator's standpoint. Functional diagrams are included to describe the program, and each command is illustrated...|$|E
40|$|Abstract. Simulation {{software}} {{is used to}} PLC program development,Engineering and technical personnel {{can get rid of}} the shackles of PLC hardware conditions,They can be flexible and independent to design and <b>debug</b> <b>program.</b> Sequential function chart (SFC) is a programming method of efficient and simple in PLC program development,For complex procedures,The efficiency is very high,This paper introduces PLC program development and simulation with sequential function chart and simulation software,This method can greatly improve efficiency...|$|E
40|$|Abstract. The modern {{demands for}} hearing level is getting higher and higher, so the {{authenticity}} of stereo sound quality demand is higher and higher, the stereo power amplifier is integrated circuit TDA 2030 A primarily composed of stereo power amplifier, it USES the typical power amplification circuit, with less distortion, peripheral components, high stability, wide frequency response range, high fidelity, the advantages of large power, {{at the same time}} adopt SiYun put GL 324 A of input audio signal processing and high, bass, and thus more output sound of quality guarantee. Articles of amplifiers made simple introduction, and give the detailed design and <b>debug</b> <b>program...</b>|$|E
5000|$|The {{availability}} of compilers, assemblers, and a Symbolic Debugging System (SDS) that allow users to <b>debug</b> <b>programs</b> written in high-level languages such as FORTRAN, Pascal, PL/I, ... {{as well as}} in assembly language.|$|R
50|$|The FX-603P {{featured}} a two line dot matrix display with 16 characters each as main display. An additional 4 digits 7-segment display used {{to display the}} program step when entering or <b>debugging</b> <b>programs</b> and 20 status indicators.|$|R
50|$|Programs {{designed}} to require concurrency {{are more difficult}} to <b>debug.</b> <b>Programs</b> {{designed to}} require concurrency will have performance issues when the number of required threads exceeds the number of hardware threads because time slicing artifacts can hit hard.|$|R
40|$|A DSP based {{longitudinal}} multi-bunch {{feedback system}} {{is being developed}} in SRRC, The software structure of feedback consist of a digital signal processors array to execute feedback algorithm and to provide raw data for beam diagnostic purposes. In order to develop, commission and operate this system efficiently, an integrated software environment has been developed. In such environment, we have major software components including, (1) feedback control algorithm on DSP, (2) DSP developing environment is on PC, (3) diagnostics toolkits is on PC and embedded computer, (4) operator interface on PC and workstation. The feedback control loop is a combined with digital filter and controller. DSP developing environment includes a code composer running on PC {{as well as a}} remote Ethernet based JTAG emulator to <b>debug</b> <b>program.</b> The system will equip diagnostic toolkits to acquire and analyse data. The associated hardware and software are commercial products that may help to reduce the system development time. The design features and performance of such will be reported...|$|E
40|$|Over {{the last}} several years, {{measurement}} technology has undergone a transformation from systems with many transducers attached to a central computer to distributed measurement systems where each transducer has an attached CPU, downloadable code, and a network connection. Even though measurement technology has changed dramatically, measurement systems are still built using old-fashioned and difficult to <b>debug</b> <b>program</b> logic control (PLC) technology, which lacks important features such as fault tolerance, flexibility, and visualization capabilities. Research in software agent technology has been underway for several years, resulting in many high-performance agent systems. With a few exceptions, most existing agent systems focus on low-level technical details, such as performance, mobility and communication and do not address deployment, scaling, and especially the management issues of {{hundreds or thousands of}} agents. Many of them also ignore higher-level issues, such as intelligence and autonomous behavior. Based on experiments and case studies in two different domains, we demonstrate that software agents combined with a visual programming language address the shortcoming...|$|E
40|$|Parallel {{programming}} {{has long}} been recognized as a difficult problem. This problem has recently taken on a sense of urgency: the long march of single-thread performance increases has stopped in its tracks. Due to limitations on power dissipation and decreased return on investments in additional processor complexity, additional transistors provided by Moore’s Law are now being channeled into a geometrically increasing number of cores per die. These cores can easily be applied to embarrassingly parallel problems and distributed computing in server environments by running multiple parallel tasks. However, there are many applications where increased performance on formerly single-threaded applications are highly desirable, ranging from personal computing devices to capability supercomputers. A key problem in parallel programming {{is the ability to}} find concurrency bugs and to <b>debug</b> <b>program</b> execution in the presence of memory races on accesses to both synchronization and data variables. Subsequent executions of a parallel program containing a race or bug are unlikely to have the same exact ordering on each execution due to nondeterministic system effects. This may cause rare problems to occur long after deployment of an application. Rerunning programs in a slower debug mode also changes the relative timing, and can easily mask problems. Ideally what we’d like is a way to deterministically replay execution of parallel programs, by recording the outcome of memory races without significantly slowing down the execution of the original program. Additionally, one would like logging requirements of the execution to be manageable, and the replay of applications to occur at a speed {{similar to that of the}} original execution. An important step in this direction appeared five years ago in the Universit...|$|E
50|$|The GNU MIX Development Kit (GNU MDK) {{is a free}} {{software}} package for developing, running and <b>debugging</b> <b>programs</b> written in MIXAL, an assembly-like language for programming a hypothetical computer called MIX. GNU MDK {{is part of the}} GNU Project.|$|R
50|$|The FX-601P series {{featured}} {{a single line}} dot matrix display with 11 characters as main display. An additional 3 digits 7-segment display used to display exponents as well as program steps when entering or <b>debugging</b> <b>programs.</b> There were 11 status indicators.|$|R
50|$|Daikon is a {{computer}} program that detects likely invariants of programs. An invariant is a condition that always holds true at certain points in the program. It is mainly used for <b>debugging</b> <b>programs</b> in late development, or checking modifications to existing code.|$|R
50|$|HBasic is an {{integrated}} development environment used to create, execute and <b>debug</b> <b>programs</b> with a Basic language. HBasic has object oriented features either in combination with precompiled C++ components (shared libraries) or class definitions (HBasic sourcecode). This also includes a version of inheritance.|$|R
5000|$|... is {{a system}} call tracer for Sun(tm) systems much like the Sun {{supplied}} program [...] [...] is a useful utility to sort of <b>debug</b> <b>programs</b> for which no source is available which unfortunately includes {{almost all of the}} Sun supplied system software.|$|R
5000|$|Another {{technique}} for <b>debugging</b> <b>programs</b> remotely {{is to use}} a remote stub. In this case, the <b>program</b> to be <b>debugged</b> is linked with a few special-purpose subroutines that implement the GDB remote serial protocol. The file containing these subroutines is called a [...] "debugging stub".|$|R
50|$|Monitor can be {{used for}} reading and writing memory, modifying CPU registers, running code at {{specific}} addresses in memory, saving/loading memory to/from a plugin option, etc. This is very useful for <b>debugging</b> <b>programs</b> written in machine code in difference to programs written in the EPSON BASIC programming language.|$|R
50|$|A {{time-sharing}} system, TSS-8, {{was also}} available. TSS-8 allowed multiple users to log {{into the system}} via 110-baud terminals, and edit, compile and <b>debug</b> <b>programs.</b> Languages included a special version of BASIC, a FORTRAN subset similar to FORTRAN-1 (no user-written subroutines or functions), an ALGOL subset, FOCAL, and an assembler called PAL-D.|$|R
50|$|Plato is the Integrated Development Environment {{supplied}} with FTN95. It can edit, compile and <b>debug</b> <b>programs</b> {{in a manner}} similar to the Visual Studio plug-ins. Although Plato specialises in Fortran it is not limited to it and can be tuned to work with any compiler. It is designed to stand-alone from FTN95.|$|R
40|$|The major {{challenge}} for present technology is to generate software more efficiently. Computers {{are being used}} in essentially all areas of human activities; even products that seemingly {{have nothing to do}} with computers contain a significant portion of computer related cost. More efficient software means three things: coding and <b>debugging</b> <b>programs</b> faster; generating program...|$|R
40|$|Program paths—sequences of {{executed}} basic blocks—have {{proven to}} be an effective way to capture a program’s elusive dynamic behavior. This paper shows how paths and path spectra compactly and precisely record many aspects of programs’ execution-time control flow behavior and explores applications of these paths in computer architecture, compilers, <b>debugging,</b> <b>program</b> testing, and software maintenance...|$|R
40|$|Program {{verification}} tools (such as model checkers and static analyzers) {{can find}} many errors in programs. These tools need formal specifications of correct program behavior, but writing a correct specification is difficult, just as writing a correct program is difficult. Thus, {{just as we}} need methods for <b>debugging</b> <b>programs,</b> we need methods for debugging specifications...|$|R
50|$|The FX-501P and FX-502P {{featured}} {{a single line}} 7-segment liquid crystal display with 10 digits as main display. An additional 3 digits 7-segment display used to display exponents and program steps when entering or <b>debugging</b> <b>programs</b> and 10 status indicators. The display {{was covered with a}} yellow filter, supposedly to prevent ultra-violet radiation damage.|$|R
40|$|By {{the end of}} this quarter, {{you should}} be able to apply the {{concepts}} above to the following: • Develop, test and <b>debug</b> <b>programs</b> in Unix. • Improve the performance of programs by tuning virtual memory usage, and file io. • Design and construct device drivers for Unix. • Design and build newer file systems for any OS...|$|R
40|$|This paper {{addresses}} {{the problem of}} <b>debugging</b> distributed <b>programs</b> executing on distributed memory parallel computers with message-passing interprocess communication. The main issues of <b>debugging</b> such <b>programs</b> are exposed. Principles for designing and implementing a debugger for programs specified in the Estelle language are presented. All the described solutions have been implemented in a distributed debugger called EREBUS...|$|R
40|$|Introduction A runtime {{debugger}} {{is the one}} of the {{frequently used}} debugging tools, which controls the program execution and through which the states of <b>debugged</b> <b>programs</b> are inspected. Like Dbx or Gdb on Unix, this type of tool is generally equipped on programming development environment. We designed a runtime debugger for massively parallel programming, and did a prototype implementation. 2 Design Goal Our design goal is to realize "scalable debugging tool". The term "scalable" has two meanings, i. e. : Scalable usage: A parallel program consists {{of a large number of}} threads. Even if the number of threads contained in a <b>program</b> increases, the <b>debugging</b> manner or operation must be uniform. Scalable implementation: We intend that how many processors to use for the execution of the <b>debugged</b> <b>program,</b> the performance must not be worse. Figure 1 shows a typical debugging system. Figure 1 : Debugging...|$|R
40|$|Conventional UNIX debug and {{analysis}} tools, with their static debugging model and lowresolution-sampling profiling techniques, are not effective {{in dealing with}} real-time applications. Encore Computer Corporation has developed Parasight, a set of debug {{and analysis}} tools for real-time applications. The Parasight tool set can <b>debug</b> running <b>programs,</b> <b>debug</b> multiple <b>programs,</b> constantly monitor local and global variables, and perform on-the-fly execution analysis. Thus, Parasight provides much improved debug and analysis capabilities, which application developers can use on both static and dynamic applications. Parasight {{can be used on}} any of Digital’s Alpha platforms runnin...|$|R
40|$|<b>Debugging</b> {{distributed}} <b>programs</b> {{is considerably}} {{more difficult than}} <b>debugging</b> sequential <b>programs.</b> We address issues in <b>debugging</b> distributed <b>programs</b> and provide a general framework for observing and controlling a dis-tributed computation and its applications to distributed de-bugging. Observing distributed computations involves solv-ing the predicate detection problem. We present the main ideas involved in developing efficient algorithms for pred-icate detection. Controlling distributed computations in-volves solving the predicate control problem. Predicate control {{may be used to}} restrict the behavior of the dis-tributed program to suspicious executions. We also present an example of how predicate detection and predicate con-trol can be used in practice to facilitate distributed debug-ging. 1...|$|R
40|$|This report {{presents}} {{a way of}} recording information about the types of programs as a graph. The focus is on programs typed with Hindley-Milner type systems. The graphs can record information about untypeable programs (which are traditionally rejected with a type error message by type inference algorithms) and thus {{can be used to}} produce information to help programmers <b>debug</b> <b>programs.</b> ...|$|R
40|$|This {{proposal}} {{introduces a}} pragmatically motivated {{project in the}} field of type systems for programming languages. The practical concern which inspires this project is the difficulty programmers experience when trying to <b>debug</b> <b>programs.</b> In particular <b>debugging</b> <b>programs</b> deemed unacceptable by the type system of the programming language. We will explore the background to the project: why we use strong static type systems, why debugging type errors is unlike debugging execution errors and what previous efforts have been made to solve the problem. Following this, the objectives of this project are defined, both generally as a list of the principles to be applied and specifically as a list of the features resulting software, an interactive type debugger, should have and the theorems which must accompany this software. Several pieces of work have already been produced as part of this project, these are described, along with the work still to be completed and an indication of the f [...] ...|$|R
40|$|We {{present a}} novel {{strategy}} for automatically <b>debugging</b> <b>programs</b> given sampled data {{from thousands of}} actual user runs. Our goal is to pinpoint those features that are most correlated with crashes. This is accomplished by maximizing an appropriately defined utility function. It has analogies with intuitive debugging heuristics, and, as we demonstrate, is {{able to deal with}} various types of bugs that occur in real programs. ...|$|R
