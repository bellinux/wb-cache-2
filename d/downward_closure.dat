89|5|Public
2500|$|A set picture if [...] is well-founded and extensional, and {{the field}} of [...] either equals the <b>downward</b> <b>closure</b> {{of one of its}} members (called its top element), or is empty.|$|E
2500|$|The <b>downward</b> <b>closure</b> of {{a member}} [...] {{of the field of}} [...] is the {{smallest}} set [...] containing , and containing each [...] for each [...] (i.e., including the preimage of each of its elements with respect to [...] as a subset.) ...|$|E
2500|$|This {{suggests}} that (an initial segment of) the cumulative hierarchy {{can be studied}} by considering the isomorphism classes of set pictures. These isomorphism classes are sets and make up a set in NFU. There is a natural set relation analogous to membership on isomorphism classes of set pictures: if [...] is a set picture, write [...] for its isomorphism class and define [...] as holding if [...] is the isomorphism class of the restriction of y to the <b>downward</b> <b>closure</b> {{of one of the}} elements of the preimage under y of the top element of y. The relation E is a set relation, and it is straightforward to prove that it is well-founded and extensional. If the definition of E is confusing, it can be deduced from the observation that it is induced by precisely the relationship which holds between the set picture associated with A and the set picture associated with B when [...] in the usual set theory.|$|E
40|$|We {{define the}} notion of meet-uniformity for closure {{operators}} on a complete lattice, which corresponds to co-additivity restricted to subsets mapped into the same element, and we study its properties. A class of closures given by principal filters and the <b>downward</b> <b>closures</b> are relevant examples of meet-uniform closures. Next, we introduce a lifting of a complete order {{by means of a}} meet-uniform closure. Our main results show that this lifting preserves the complete lattice structure, and allows the meet-uniform closure to become fully co-additive. Mathematics Subject Classification (1991) : 06 A 15, 06 A 23. Keywords: closure operator, co-additivity, meet-uniformity, lifted complete order. 1 Introduction We introduce {{the notion of}} meet-uniform (upper) closure operator on a complete lattice, and prove that meet-uniformity is sufficient to achieve co-additivity of these closure operators, relatively to an induced complete order. A meet-uniform closure on a complete lattice C is a clo [...] ...|$|R
40|$|We {{study the}} size and the {{complexity}} of computing finite state automata (FSA) representing and approximating the downward and the upward closure of Petri net languages with coverability as the acceptance condition. We show how to construct an FSA recognizing the upward closure of a Petri net language in doubly-exponential time, and therefore the size is at most doubly exponential. For <b>downward</b> <b>closures,</b> we prove {{that the size of}} the minimal automata can be non-primitive recursive. In the case of BPP nets, a well-known subclass of Petri nets, we show that an FSA accepting the downward/upward closure can be constructed in exponential time. Furthermore, we consider the problem of checking whether a simple regular language is included in the downward/upward closure of a Petri net/BPP net language. We show that this problem is EXPSPACE-complete (resp. NP-complete) in the case of Petri nets (resp. BPP nets). Finally, we show that it is decidable whether a Petri net language is upward/downward closed...|$|R
40|$|The <b>downward</b> and upward <b>closures</b> of {{a regular}} {{language}} $L$ are obtained by collecting all the subwords and superwords of its elements, respectively. The downward and upward interiors of $L$ are obtained dually by collecting words having all their subwords and superwords in $L$, respectively. We provide lower and upper bounds {{on the size of}} the smallest automata recognizing these closures and interiors. We also consider the computational complexity of decision problems for closures of regular languages...|$|R
50|$|Apriori uses a {{breadth-first search}} {{strategy}} {{to count the}} support of itemsets and uses a candidate generation function which exploits the <b>downward</b> <b>closure</b> property of support.|$|E
5000|$|A set picture if [...] is well-founded and extensional, and {{the field}} of [...] either equals the <b>downward</b> <b>closure</b> {{of one of its}} members (called its top element), or is empty.|$|E
5000|$|The <b>downward</b> <b>closure</b> of {{a member}} [...] {{of the field of}} [...] is the {{smallest}} set [...] containing , and containing each [...] for each [...] (i.e., including the preimage of each of its elements with respect to [...] as a subset.) ...|$|E
40|$|Automata {{theory has}} given rise to a variety of automata models that consist of a finite-state control and an infinite-state storage mechanism. The aim of this work is to provide {{insights}} into how the structure of the storage mechanism influences the expressiveness and the analyzability of the resulting model. To this end, it presents generalizations of results about individual storage mechanisms to larger classes. These generalizations characterize those storage mechanisms for which the given result remains true and for which it fails. In order to speak of classes of storage mechanisms, we need an overarching framework that accommodates each of the concrete storage mechanisms we wish to address. Such a framework is provided by the model of valence automata, in which the storage mechanism is represented by a monoid. Since the monoid serves as a parameter to specifying the storage mechanism, our aim translates into the question: For which monoids does the given (automata-theoretic) result hold? As a first result, we present an algebraic characterization of those monoids over which valence automata accept only regular languages. In addition, it turns out that for each monoid, this is the case if and only if valence grammars, an analogous grammar model, can generate only context-free languages. Furthermore, we are concerned with closure properties: We study which monoids result in a Boolean closed language class. For every language class that is closed under rational transductions (in particular, those induced by valence automata), we show: If the class is Boolean closed and contains any non-regular language, then it already includes the whole arithmetical hierarchy. This work also introduces the class of graph monoids, which are defined by finite graphs. By choosing appropriate graphs, one can realize a number of prominent storage mechanisms, but also combinations and variants thereof. Examples are pushdowns, counters, and Turing tapes. We can therefore relate the structure of the graphs to computational properties of the resulting storage mechanisms. In the case of graph monoids, we study (i) the decidability of the emptiness problem, (ii) which storage mechanisms guarantee semilinear Parikh images, (iii) when silent transitions (i. e. those that read no input) can be avoided, and (iv) which storage mechanisms permit the computation of <b>downward</b> <b>closures.</b> ...|$|R
40|$|International audienceThis problem {{concerns}} hypergraph dualization and generalization to poset dualization. A hypergraph H = (V, E) {{consists of}} a finite collection E of sets over a finite set V, i. e. E ⊆ P(V) (the powerset of V). The elements of E are called hyperedges, or simply edges. A hypergraph is said simple if none of its edges is contained within another. A transversal (or hitting set) of H is a set T ⊆ V that intersects every edge of E. A transversal is minimal {{if it does not}} contain any other transversal as a subset. The set of all minimal transversal of H is denoted by T r(H). The hypergraph (V, T r(H)) is called the transversal hypergraph of H. Given a simple hypergraph H, the hypergraph dualization problem (Trans-Enum for short) concerns the enumeration without repetitions of T r(H). The Trans-Enum problem can also be formulated as a dualization problem in posets. Let (P, ≤) be a poset (i. e. ≤ is a reflexive, antisymmetric, and transitive relation on the set P). For A ⊆ P, ↓ A (resp. ↑ A) is the <b>downward</b> (resp. upward) <b>closure</b> of A under the relation ≤ (i. e. ↓ A is an ideal and ↑ A a filter of (P, ≤)). Two antichains (B +, B −) of P are said to be dual if ↓ B + ∪ ↑ B − = P and ↓ B + ∩ ↑ B − = ∅. Given an implicit description of a poset P and an antichain B + (resp. B −) of P, the poset dualization problem (Dual-Enum for short) enumerates the set B − (resp. B +), denoted by Dual(B +) = B − (resp. Dual(B −) = B +). Notice that the function dual is self-dual or idempotent, i. e. Dual(Dual(B)) = B...|$|R
5000|$|<b>Downward</b> <b>closure.</b> A point x lies in {{the closure}} of a subset S of X {{if and only if}} there is a point y in S such that x ≤ y where ≤ is the {{specialization}} preorder i.e. x {{lies in the}} closure of {y}.|$|E
5000|$|Schreiber and Schwöbbermeyer [...] {{proposed}} an algorithm named flexible pattern finder (FPF) for extracting frequent sub-graphs of an input network and implemented it {{in a system}} named Mavisto. Their algorithm exploits the <b>downward</b> <b>closure</b> property which is applicable for frequency concepts [...] and [...] The <b>downward</b> <b>closure</b> property asserts that the frequency for sub-graphs decrease monotonically by increasing the size of sub-graphs; however, this property does not hold necessarily for frequency concept [...] FPF {{is based on a}} pattern tree (see figure) consisting of nodes that represents different graphs (or patterns), where the parent of each node is a sub-graph of its children nodes; in other words, the corresponding graph of each pattern tree’s node is expanded by adding a new edge to the graph of its parent node.|$|E
5000|$|Apriori uses {{breadth-first search}} and a Hash tree {{structure}} to count candidate item sets efficiently. It generates candidate item sets of length [...] from item sets of length [...] Then it prunes the candidates which have an infrequent sub pattern. According to the <b>downward</b> <b>closure</b> lemma, the candidate set contains all frequent -length item sets. After that, it scans the transaction database to determine frequent item sets among the candidates.|$|E
5000|$|A {{directed}} {{subset of}} a poset {{is not required}} to be downward closed; a subset of a poset is directed if and only if its <b>downward</b> <b>closure</b> is an ideal. While the definition of a directed set is for an [...] "upward-directed" [...] set (every pair of elements has an upper bound), it is also possible to define a downward-directed set in which every pair of elements has a common lower bound. A subset of a poset is downward-directed if and only if its upper closure is a filter.|$|E
5000|$|The {{pseudo code}} for the {{algorithm}} is given below for a transaction database , and a support threshold of [...] Usual set theoretic notation is employed, though note that [...] is a multiset. [...] is the candidate set for level [...] At each step, the algorithm {{is assumed to}} generate the candidate sets from the large item sets of the preceding level, heeding the <b>downward</b> <b>closure</b> lemma. [...] accesses a field of the data structure that represents candidate set , which is initially assumed to be zero. Many details are omitted below, usually {{the most important part}} of the implementation is the data structure used for storing the candidate sets, and counting their frequencies.|$|E
50|$|At first, the FPF {{algorithm}} enumerates {{and maintains}} the information of all matches of a sub-graph {{located at the}} root of the pattern tree. Then, one-by-one it builds child nodes of the previous node in the pattern tree by adding one edge supported by a matching edge in the target graph, and tries to expand all of the previous information about matches to the new sub-graph (child node). In next step, it decides whether the frequency of the current pattern is lower than a predefined threshold or not. If it is lower and if <b>downward</b> <b>closure</b> holds, FPF can abandon that path and not traverse further in this part of the tree; as a result, unnecessary computation is avoided. This procedure is continued until there is no remaining path to traverse.|$|E
5000|$|Proof. Assume {{the ideal}} M is maximal {{with respect to}} disjointness from the filter F. Suppose for a contradiction that M is not prime, i.e. there exists a pair of {{elements}} a and b such that a''''b in M but neither a nor b are in M. Consider the case that for all m in M, m''''a is not in F. One can construct an ideal N by taking the <b>downward</b> <b>closure</b> of the set of all binary joins of this form, i.e. N = { x | x≤ m''''a for some m in M}. It is readily checked that N is indeed an ideal disjoint from F which is strictly greater than M. But this contradicts the maximality of M and thus the assumption that M is not prime.|$|E
5000|$|The {{advantage}} of the algorithm {{is that it does}} not consider infrequent sub-graphs and tries to finish the enumeration process as soon as possible; therefore, it only spends time for promising nodes in the pattern tree and discards all other nodes. As an added bonus, the pattern tree notion permits FPF to be implemented and executed in a parallel manner since it is possible to traverse each path of the pattern tree independently. However, FPF is most useful for frequency concepts [...] and , because <b>downward</b> <b>closure</b> is not applicable to [...] Nevertheless, the pattern tree is still practical for [...] if the algorithm runs in parallel. Another {{advantage of}} the algorithm is that the implementation of this algorithm has no limitation on motif size, which makes it more amenable to improvements. The pseudocode of FPF (Mavisto) is shown below: ...|$|E
5000|$|This {{suggests}} that (an initial segment of) the cumulative hierarchy {{can be studied}} by considering the isomorphism classes of set pictures. These isomorphism classes are sets and make up a set in NFU. There is a natural set relation analogous to membership on isomorphism classes of set pictures: if [...] is a set picture, write [...] for its isomorphism class and define [...] as holding if [...] is the isomorphism class of the restriction of y to the <b>downward</b> <b>closure</b> {{of one of the}} elements of the preimage under y of the top element of y. The relation E is a set relation, and it is straightforward to prove that it is well-founded and extensional. If the definition of E is confusing, it can be deduced from the observation that it is induced by precisely the relationship which holds between the set picture associated with A and the set picture associated with B when [...] in the usual set theory.|$|E
40|$|The <b>downward</b> <b>closure</b> of a {{language}} L of words is the set of all (not necessarily contiguous) subwords of members of L. It {{is well known that}} the <b>downward</b> <b>closure</b> of any language is regular. Although the <b>downward</b> <b>closure</b> seems to be a promising abstraction, there are only few language classes for which an automaton for the <b>downward</b> <b>closure</b> is known to be computable. It is shown here that for stacked counter automata, the <b>downward</b> <b>closure</b> is computable. Stacked counter automata are finite automata with a storage mechanism obtained by adding blind counters and building stacks. Hence, they generalize pushdown and blind counter automata. The class of languages accepted by these automata are precisely those in the hierarchy ob-tained from the context-free languages by alternating two closure operators: imposing semilinear constraints and taking the algebraic extension. The main tool for computing downward closures is the new concept of Parikh annotations. As a second application of Parikh annotations, it is shown that the hierarchy above is strict at every level. ...|$|E
40|$|The <b>downward</b> <b>closure</b> {{of a word}} {{language}} is the set of all (not necessarily contiguous) subwords of its members. It is well-known that the <b>downward</b> <b>closure</b> of any {{language is}} regular. While the <b>downward</b> <b>closure</b> {{appears to be a}} powerful abstraction, algorithms for computing a finite automaton for the <b>downward</b> <b>closure</b> of a given language have been established only for few language classes. This work presents a simple general method for computing downward closures. For language classes that are closed under rational transductions, it is shown that the computation of downward closures can be reduced to checking a certain unboundedness property. This result is used to prove that downward closures are computable for (i) every language class with effectively semilinear Parikh images that are closed under rational transductions, (ii) matrix languages, and (iii) indexed languages (equivalently, languages accepted by higher-order pushdown automata of order 2). Comment: Full version of contribution to ICALP 2015. Comments welcom...|$|E
30|$|In {{conventional}} frequent pattern mining, {{the complete}} set of frequent patterns satisfies the <b>downward</b> <b>closure</b> property if {{there is only one}} minsup. That is, if an itemset is frequent, then all its subsets are also frequent. However, in the case of MMSs, the <b>downward</b> <b>closure</b> property does not hold; that is, certain subsets of a frequent itemset are not frequent and their support values are indeterminate.|$|E
40|$|The <b>downward</b> <b>closure</b> of a {{language}} is the set of all (not necessarily contiguous) subwords of its members. It is well-known that the <b>downward</b> <b>closure</b> of every language is regular. Moreover, recent results show that downward closures are computable for quite powerful system models. One advantage of abstracting {{a language}} by its <b>downward</b> <b>closure</b> is that then equivalence and inclusion become decidable. In this work, we study the complexity of these two problems. More precisely, we consider the following decision problems: Given languages K and L from classes C and D, respectively, does the <b>downward</b> <b>closure</b> of K include (equal) that of L? These problems are investigated for finite automata, one-counter automata, context-free grammars, and reversal-bounded counter automata. For each combination, we prove a completeness result either for fixed or for arbitrary alphabets. Moreover, for Petri net languages, we show that both problems are Ackermann-hard and for higher-order pushdown automata of order k, we prove hardness for complements of nondeterministic k-fold exponential time. Comment: 24 pages, to appear in proceedings of ICALP 201...|$|E
40|$|We {{show the}} {{diagonal}} problem for higher-order pushdown automata (HOPDA), {{and hence the}} simultaneous unboundedness problem, is decidable. From recent work by Zet-zsche this means that we can construct the <b>downward</b> <b>closure</b> of the set of words accepted by a given HOPDA. This also means we can construct the <b>downward</b> <b>closure</b> of the Parikh image of a HOPDA. Both of these consequences play an important rôle in verifying concur-rent higher-order programs expressed as HOPDA or safe higher-order recursion schemes. ...|$|E
40|$|In {{this paper}} we extend {{the problem of}} mining {{weighted}} association rules. A classical model of boolean and fuzzy quantitative association rule mining is adopted {{to address the issue}} of invalidation of <b>downward</b> <b>closure</b> property (DCP) in weighted association rule mining where each item is assigned a weight according to its significance w. r. t some user defined criteria. Most works on DCP so far struggle with invalid <b>downward</b> <b>closure</b> property and some assumptions are made to validate the property. We generalize the problem of <b>downward</b> <b>closure</b> property and propose a fuzzy weighted support and confidence framework for boolean and quantitative items with weighted settings. The problem of invalidation of the DCP is solved using an improved model of weighted support and confidence framework for classical and fuzzy association rule mining. Our methodology follows an Apriori algorithm approach and avoids pre and post processing as opposed to most weighted ARM algorithms, thus eliminating the extra steps during rules generation. The paper concludes with experimental results and discussion on evaluating the proposed framework...|$|E
40|$|Abstract. A novel {{approach}} is presented for mining weighted association rules (ARs) from binary and fuzzy data. We {{address the issue}} of invalidation of <b>downward</b> <b>closure</b> property (DCP) in weighted association rule mining where each item is assigned a weight according to its significance w. r. t some user defined criteria. Most works on weighted association rule mining so far struggle with invalid <b>downward</b> <b>closure</b> property and some assumptions are made to validate the property. We generalize the weighted association rule mining problem for databases with binary and quantitative attributes with weighted settings. Our methodology follows an Apriori approach [9] and avoids pre and post processing as opposed to most weighted association rule mining algorithms, thus eliminating the extra steps during rules generation. The paper concludes with experimental results and discussion on evaluating the proposed approach...|$|E
40|$|A novel {{approach}} is presented for effectively mining weighted fuzzy association rules (ARs). The authors {{address the issue}} of invalidation of <b>downward</b> <b>closure</b> property (DCP) in weighted association rule mining where each item is assigned a weight according to its significance wrt some user defined criteria. Most works on weighted association rule mining do not address the <b>downward</b> <b>closure</b> property while some make assumptions to validate the property. This chapter generalizes the weighted association rule mining problem with binary and fuzzy attributes with weighted settings. Their methodology follows an Apriori approach but employs T-tree data structure to improve efficiency of counting itemsets. The authors ’ approach avoids pre and post processing as opposed to most weighted association rule mining algorithms, thus eliminating the extra steps during rules generation. The chapter presents experimental results on both synthetic and real-data sets and a discussion on evaluating the proposed approach...|$|E
40|$|The inter-transactional {{association}} rule framework is improved by giving a more concise definition of inter-transactional {{association rule}}s and related measurements. The closure property, theoretical foundations, multidimensional mining contexts, and performance issues in mining are investigated. The <b>downward</b> <b>closure</b> property problem {{within the framework}} is studied and a solution for efficient mining of inter-transactional association rule is proposed. Department of Computin...|$|E
40|$|Modal {{dependence}} logics are modal logics defined on {{the basis}} of team semantics and have the <b>downward</b> <b>closure</b> property. In this paper, we introduce sound and complete deduction systems for the major modal dependence logics, especially those with intuitionistic connectives in their languages. We also establish a concrete connection between team semantics and single-world semantics, and show that modal dependence logics can be interpreted as variants of intuitionistic modal logics...|$|E
40|$|Researchers have {{proposed}} weighted frequent itemset mining algorithms {{that reflect the}} importance of items. The main focus of weighted frequent itemset mining concerns satisfying the <b>downward</b> <b>closure</b> property. All weighted association rule mining algorithms suggested {{so far have been}} based on the Apriori algorithm. However, pattern growth algorithms are more efficient than Apriori based algorithms. Our main approach is to push the weight constraints into the pattern growth algorithm while maintaining the <b>downward</b> <b>closure</b> property. In this paper, a weight range and a minimum weight constraint are defined and items are given different weights within the weight range. The weight and support of each item are considered separately for pruning the search space. The number of weighted frequent itemsets can be reduced by setting a weight range and a minimum weight, allowing the user to balance support and weight of itemsets. WFIM generates more concise and important weighted frequent itemsets in large databases, particularly dense databases with low minimum support, by adjusting a minimum weight and a weight range. 1...|$|E
40|$|International audienceA {{non-deterministic}} recursion scheme recognizes {{a language}} of finite trees. This very expressive model can simulate, among others, higher-order pushdown automata with collapse. We show decidabil-ity of the diagonal problem for schemes. This result has several interesting consequences. In particular, it gives an algorithm that computes the <b>downward</b> <b>closure</b> of languages of words recognized by schemes. In turn, this has immediate application to separability problems and reachability analysis of concurrent systems...|$|E
40|$|A {{non-deterministic}} recursion scheme recognizes {{a language}} of finite trees. This very expressive model can simulate, among others, higher-order pushdown automata with collapse. We show decidability of the diagonal problem for schemes. This result has several interesting consequences. In particular, it gives an algorithm that computes the <b>downward</b> <b>closure</b> of languages of words recognized by schemes. In turn, this has immediate application to separability problems and reachability analysis of concurrent systems. Comment: technical report; to appear in LICS' 1...|$|E
40|$|Abstract—Data mining {{is defined}} as the process of {{discovering}} significant and potentially useful patterns in large volumes of data. Discovering associations between items in a large database is one such data mining activity. In finding associations, support is used as an indicator as to whether an association is interesting. In this paper, we discuss three alternative interest measures for associations: any-confidence, all-confidence, and bond. We prove that the important <b>downward</b> <b>closure</b> property applies to both all-confidence and bond. We show that <b>downward</b> <b>closure</b> does not hold for any-confidence. We also prove that, if associations have a minimum allconfidence or minimum bond, then those associations will have a given lower bound on their minimum support and the rules produced from those associations will have a given lower bound on their minimum confidence as well. However, associations that have that minimum support (and likewise their rules that have minimum confidence) may not satisfy the minimum all-confidence or minimum bond constraint. We describe the algorithms that efficiently find all associations with a minimum all-confidence or minimum bond and present some experimental results. Index Terms—Data mining, associations, interest measures, databases, performance. æ...|$|E
40|$|Well-structured {{transition}} systems {{provide the}} right foundation to compute a finite {{basis of the}} set of predecessors of the upward closure of a state. The dual problem, to compute a finite representation of the set of successors of the <b>downward</b> <b>closure</b> of a state, is harder: Until now, the theoretical framework for manipulating downward-closed sets was missing. We answer this problem, using insights from domain theory (dcpos and ideal completions), from topology (sobrifications), and shed {{new light on the}} notion of adequate domains of limits...|$|E
40|$|Business {{workflow}} analysis has become crucial in strategizing {{how to create}} competitive edge. Consequently, deriving a series of positively correlated association rules from workflows is essential to identify strong relationships among key business activities. These rules can subsequently, serve as best practices. We have addressed this problem by hybridizing genetic algorithm with association rules. First, we used correlation to replace support-confidence in genetic algorithm to enable dynamic data-driven determination of support and confidence, i. e., use correlation to optimize the derivation of positively correlated association rules. Second, we used correlation as fitness function to support upward closure in association rules (hitherto, association rules support only <b>downward</b> <b>closure).</b> The ability to support upward closure allows derivation of the most specific association rules (business model) from less specific association rules (business meta-model) and generic association rules (reference meta-model). <b>Downward</b> <b>closure</b> allows the opposite. Upward-downward closures allow the manager to drill-down and analyze based {{on the degree of}} dependency among business activities. Subsequently, association rules can be used to describe best practices at the model, meta-model and reference meta-model levels with the most general positively dependent association rules as reference meta-model. Experiments are based on an online hotel reservation system. (C) 2012 Elsevier Ltd. All rights reserved...|$|E
