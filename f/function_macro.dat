1|157|Public
40|$|NODE CAPABILITIES ACTUAL NODE CAPABILITIES SERVICE FUNCTION SERVICE FUNCTION SERVICE <b>FUNCTION</b> <b>MACRO</b> DEPLOYMENT MICRO DEPLOYMENT SERVICE COMPONENTS NETWORK LEVEL NODE LEVEL 152 timedia {{transcoding}} and compression service, {{with one}} node {{on the path}} performing transcoding while another node performs compression...|$|E
40|$|The SAS ® macro {{language}} {{includes a}} number of <b>macro</b> <b>functions,</b> such as %UPCASE, %QSCAN, and %SUBSTR. In addition {{a number of}} Autocall macros, such as %LEFT, %TRIM, and %VERIFY, are also supplied that act like <b>macro</b> <b>functions.</b> <b>Macro</b> <b>functions</b> are especially useful as programming tools, because the function call is replaced directly by {{the result of the}} call. Many macro programmers are unaware that they too can write useful <b>macro</b> <b>functions.</b> Fortunately <b>macro</b> <b>functions</b> are not difficult to program. Not difficult, that is, if you know the simple techniques required to turn a macro into a <b>macro</b> <b>function.</b> This paper shows you how to create a <b>macro</b> <b>function,</b> the statements that you must avoid, and the technique used to “pass ” the result of the function back to the calling program...|$|R
50|$|Common Lisp {{implementations}} provide advice functionality (in {{addition to}} the standard method combination for CLOS) as extensions. LispWorks supports advising <b>functions,</b> <b>macros</b> and CLOS methods.|$|R
5000|$|Programmable soft keys, {{allowing}} user-defined <b>functions</b> and <b>macros</b> ...|$|R
40|$|Abstract. Macro {{expansion}} in current Lisp systems is naive with respect o block structure. Every <b>macro</b> <b>function</b> {{can cause the}} capture of free user identifiers and thus corrupt intended bindings. We propose a change to the expansion algorithm so that macros will only violate the binding discipline when it is explicitly intended. 1. Prob lems with Macro Expansions Lisp <b>macro</b> <b>functions</b> are powerful tools for the extension of language syntax. They allow programmers to add new syntactic onstructs to a programming language. A pro-stammer specifies a <b>macro</b> <b>function</b> which translates ac-tual instances of a syntactic extension to core language x-pressions. This process can also be pyramided, i. e., <b>macro</b> <b>functions</b> may translate into an already extended language [5]. The defined set of <b>macro</b> <b>functions</b> is coordinated by...|$|R
5000|$|One quirk of MFC {{is the use}} of [...] "Afx" [...] as the prefix {{for many}} <b>functions,</b> <b>macros</b> and the {{standard}} precompiled header name [...] "stdafx.h". During early development, what became MFC was called [...] "Application Framework Extensions" [...] and abbreviated [...] "Afx". The name Microsoft Foundation Classes (MFC) was adopted too late in the release cycle to change these references.|$|R
40|$|Bachelor {{thesis is}} focused on using the ICMP {{protocol}} for transferring user-defined data content. The main objective of this thesis is to introduce of using sockets working with OpenWRT operating system, which transmitting ICMP messages. Bachelor thesis {{is divided into two}} parts. The first section contains a description of program <b>functions,</b> <b>macros</b> and settings. In the second part there is a description of communication between access points...|$|R
50|$|In Common Lisp symbols may use any characters, {{including}} whitespace, such as {{spaces and}} newlines. If a symbol contains a whitespace character {{it needs to}} be written as |this is a symbol|. Symbols can be used as identifiers for any kind of named programming constructs: variables, <b>functions,</b> <b>macros,</b> classes, types, goto tags and more.Symbols can be interned in a package. Keyword symbols are self-evaluating and interned in the package named KEYWORD.|$|R
40|$|Task of {{managing}} duplicated or “cloned” code has occupied {{the minds of}} programmers for the past 50 years. During this time, researchersand practitioners have developed {{a variety of techniques}} for removing or avoiding it by employing <b>functions,</b> <b>macros</b> and other programmingabstractions. Functional abstraction was designed into early programming languages, such as Fortran and Lisp. Object-oriented programming, originating with Simula- 67, has provided further mechanisms for parameterized reuse to avoid duplication. Aspect-oriented programming has allowed cross-cutting duplication to be abstracted. Engineering practices like Refactoring and Extreme Programming have promoted specific methodologies of abstracting duplicated code. In the last decade, a multitude of tools have been developed (both in research and in industry) that helpprogrammers semi-automatically find and refactor existing duplication into <b>functions,</b> <b>macros</b> and methods. Given this long-term commitment toprogramming abstractions as a solution use “duplicated code” and “cloned code” synonymously to mean two or more multi-line code fragments that are either identical or similar, particularly in their structure. Duplicated code, {{it stands to reason that}} there should be little duplication left in practice...|$|R
5000|$|A full REPL for {{interactive}} {{development and}} testing (unlike Erlang's shell, the CSCM REPL supports <b>function</b> and <b>macro</b> definitions) ...|$|R
50|$|CLX {{contains}} data types, <b>functions</b> and <b>macros</b> {{to interact}} with an X server by sending requests and receiving events and replies.|$|R
50|$|However, syntax-case is more {{powerful}} than syntax-rules. For example, syntax-case macros can specify side-conditions on its pattern matching rules via arbitrary Scheme <b>functions.</b> Alternatively, a <b>macro</b> writer can choose {{not to use the}} pattern matching frontend and manipulate the syntax directly. Using the datum->syntax <b>function,</b> syntax-case <b>macros</b> can also intentionally capture identifiers, thus breaking hygiene. The R6RS Scheme standard adopted the syntax-case macro system.|$|R
50|$|In 1979, Mark Horton took on {{responsibility}} for vi. Horton added support for arrow and <b>function</b> keys, <b>macros,</b> and improved performance by replacing termcap with terminfo.|$|R
40|$|A {{package of}} Lisp {{functions}} is described which implements a simple multi-level simulation toolkit, MLS. Its design owes {{a great deal}} to MIMOSE. MLS runs within Lisp-Stat. It offers a set of <b>functions,</b> <b>macros</b> and objects designed to make the specification of multi-level models straightforward and easy to understand. Lisp-Stat provides a Lisp environment, statistical functions and easy to use graphics, such as histograms, scatterplots and spin-plots, to make the results of multi-level simulations easy to visualise. Multi-Level Simulation, Social Simulation, Lisp, Computer Modelling, Social Simulation Tookit...|$|R
25|$|Common Lisp is a {{successor}} to MacLisp. The primary influences were Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, and Scheme. It has many {{of the features of}} Lisp Machine Lisp (a large Lisp dialect used to program Lisp Machines), but was designed to be efficiently implementable on any personal computer or workstation. Common Lisp has a large language standard including many built-in data types, <b>functions,</b> <b>macros</b> and other language elements, as well as an object system (Common Lisp Object System). Common Lisp also borrowed certain features from Scheme such as lexical scoping and lexical closures.|$|R
5000|$|Common Lisp is a dialect of Lisp; it uses S-expressions {{to denote}} both code and data structure. <b>Function</b> calls, <b>macro</b> forms and special forms are written as lists, {{with the name}} of the {{function}} first, as in these examples: ...|$|R
50|$|As seen in {{the example}} above, LFE {{expressions}} are written as lists, using prefix notation. The first element in the list {{is the name of}} a form, i.e., a <b>function,</b> operator, <b>macro,</b> or operator. The remainder of the list are the arguments.|$|R
50|$|Holding the Control and Alt {{keys and}} {{pressing}} the Suspend Macro key clears {{all of the}} keyboard's programming. The Program light will flash while the keyboard erases its memory. Afterwards, it will go dark and all keys will be reset to their original <b>function,</b> all <b>macros</b> deleted, and all remappings reset.|$|R
50|$|The {{resulting}} {{location for}} S=1 {{is the one}} with minimum cost <b>function</b> and the <b>macro</b> block at this location is the best match.|$|R
40|$|This paper {{considers}} the aggregation of production functions within a stochastic framework where both the technological parameters and the factor inputs {{are thought to}} be probabilistically distributed across firms. The corresponding "true" aggregate production function expressed in moments form is compared with the <b>macro</b> <b>function</b> of choice. This comparison either yields an aggregation bias in total output, if the <b>macro</b> <b>function</b> is fully specified, or allows the relation between exact aggregation macro parameters and their micro foundations to be established, if not. ...|$|R
50|$|An {{assertion}} is a <b>function</b> or <b>macro</b> that verifies {{the behavior}} (or the state) {{of the unit}} under test. Usually an assertion expresses a logical condition that is true for results expected in a correctly running system under test (SUT).Failure of an assertion typically throws an exception, aborting {{the execution of the}} current test.|$|R
50|$|The {{interfaces}} {{for using}} obstacks {{may be defined}} either as <b>functions</b> or as <b>macros,</b> depending on the compiler. The obstack facility works with all C compilers.|$|R
5000|$|... heads a {{preprocessor}} procedure, {{a set of}} preprocessor {{statements that}} <b>functions</b> as a <b>macro</b> returning a value when its name is encountered in the input text.|$|R
50|$|Macros {{can also}} be used to achieve some of the effects of higher order <b>functions.</b> However, <b>macros</b> cannot easily avoid the problem of {{variable}} capture; they may also result in large amounts of duplicated code, which can be more difficult for a compiler to optimize. Macros are generally not strongly typed, although they may produce strongly typed code.|$|R
5000|$|Preprocessor <b>macro</b> <b>{{functions}}</b> (without type) can be rewritten as inline functions (typed). The {{flexibility of}} accepting and returning different types {{can still be}} obtained by function overloading.|$|R
5000|$|The HLA Standard Library {{provides}} {{thousands of}} <b>functions,</b> procedures, and <b>macros.</b> While the list changes over time, as of mid-2010 for HLA v2.12, it included functions in these categories: ...|$|R
40|$|Abstract—Make {{is one of}} {{the oldest}} build {{technologies}} and is still widely used today, whether by manually writing Makefiles, or by generating them using tools like Autotools and CMake. Despite its conceptual simplicity, modern Make implementations such as GNU Make have become very complex languages, featuring <b>functions,</b> <b>macros,</b> lazy variable assignments and (in GNU Make 4. 0) the Guile embedded scripting language. Since we are interested in understanding how widespread such complex language features are, this paper studies the use of Make features in almost 20, 000 Makefiles, comprised of over 8. 4 million lines, from more than 350 different open source projects. We look at the popularity of features and the difference between hand-written Makefiles and those generated using various tools. We find that generated Makefiles use only a core set of features and that more advanced features (such as function calls) are used very little, and almost exclusively in hand-written Makefiles. I...|$|R
40|$|The {{purpose of}} the Supervisor in an Extended Data Management Facility (EDMF) is to direct the Facility 2 ̆ 7 s {{handling}} of a user 2 ̆ 7 s request for service. The Supervisor fulfills its task {{through the use of}} five main functions: Access Control, Retrieval Initialization, File Searching, Record Validating and Record Formatting. The major and most important component of the Retrieval Initialization phase is the Retrieval Optimization subfunction. This report is concerned mainly with the design and implementation of the Access Control and Retrieval Optimization <b>functions.</b> <b>Macro</b> instructions are the mechanism through which a user 2 ̆ 7 s program can call upon the ECMF. The Authority Item check is the EDMF 2 ̆ 7 s security control over file access while the Prime Keyword Search is the method used to optimize the retrieval strategy. The Authority Item check and the Prime Keyword Search are two of the major concepts of the Extended Data Management Facility...|$|R
5000|$|... 2 A [...] "top camera" [...] {{which will}} be used to take the photograph. Typically this is a digital SLR or digital compact camera with a macro lens or <b>macro</b> <b>function.</b>|$|R
40|$|ACL 2 {{computed}} hints dynamically calculate {{advice to}} the ACL 2 theorem prover during a mechanical proof. We wrote an ACL 2 book that adds a number of useful <b>functions</b> and <b>macros</b> to ease the use of computed hints. The combination of these macros can specify a complex condition under which a certain hint is invoked. We will also review the usage of computed hints in the FM 9801 project...|$|R
40|$|A {{source code}} for calculating {{reference}} on thermophysical properties: density and viscosity for several gases (nitrogen, helium, hydrogen, argon and air) {{has been developed}} under Visual Basic for Applications (VBA) programming in MS Excel (as a macros). Selected density and viscosity equations have been chosen as a basic equation in the VBA programming as a user-defined <b>function.</b> This <b>macro</b> is very useful for engineers and researchers due to enhance their experimental and/or theoretical studies...|$|R
40|$|ACL 2 (r) {{supports}} {{the definition of}} real-valued functions. In this paper, we introduce a theory of inverse functions into description of inverse functions, to a still abstract but more tractable treatment of the inverse of continuous <b>functions.</b> A <b>macro</b> is introduced to simplify the introduction of concrete inverse functions. We illustrate the approach by defining some inverse functions in ACL 2, including the square root, natural logarithm, inverse sine, and inverse cosine functions...|$|R
40|$|The MetaPost package bpolynomial helps {{plotting}} polynomial {{and root}} <b>functions.</b> It provides <b>macros</b> to calculate one-segment Bézier curves exactly matching a given cubic polynomial or square or cubic root function. Additionally, tangents on all functions and derivatives of polynomials can be calculated...|$|R
40|$|Properly {{control of}} blow molding machine’s wall-thickness {{relates to the}} quality of plastic products,design on curves is the key {{technology}} of blow molding machine’s wall-thickness control. Adopted cubic spline curve as a fitting prototype,used advanced HMI as a design platform,by cooperation with HMI configuration <b>function</b> and <b>macro</b> code,an interface of curves was designed,a good performance of human-computer interaction and core data’s transmission in the whole machine were realized. By using this method,the integration of the system was increased and costs was reduced dramatically...|$|R
5000|$|NoteTab {{has its own}} macro language, called [...] "Clip". The clipbook {{displays}} a library of clips (clickable macros) in a side pane. These could be anything from pieces of boilerplate text to HTML tags to [...] "mini-applications" [...] complicated scripts written in the scripting language. A selection of clip libraries is included with the software and others can be downloaded from the Web. Some special uses include custom (user-defined) <b>functions</b> and <b>macros</b> suitable for running from the user-defined clipbar (see below).|$|R
5000|$|For z/System VSE, all STXIT {{functions}} provided previously by IBM DOS/VSE {{are still}} supported. In addition, a new STXIT <b>macro</b> <b>function</b> 'Disabled Timer Appendage (DIE)' is available, {{but only for}} use in Supervisor Mode (Key 0, PSW privilege bit =1). Format is: label STXIT DIE,rtnaddr|(1) ...|$|R
