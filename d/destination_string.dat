7|5|Public
25|$|The 68000 {{assembler}} code {{below is}} for a subroutine named , which copies a source null-terminated ASCIZ character string to another <b>destination</b> <b>string,</b> converting all alphabetic characters to lower case.|$|E
50|$|The {{inefficiency}} {{to which}} Spolsky was drawing an analogy was the poor programming practice of repeated concatenation of C-style null-terminated character arrays (that is, strings) {{in which the}} position of the <b>destination</b> <b>string</b> has to be recomputed {{from the beginning of the}} string each time because it is not carried over from a previous concatenation.|$|E
5000|$|Suppose {{a program}} is being run in an {{emulator}} {{and needs to}} copy a null-terminated string. The program is compiled originally for a very simple processor. This processor can only copy a byte at a time, and must do so by first reading it from the source string into a register, then writing it from that register into the <b>destination</b> <b>string.</b> The original program might look something like this: ...|$|E
50|$|ES:DI (ES is Extra Segment, DI is Destination Index) is {{typically}} used {{to point to}} the <b>destination</b> for a <b>string</b> copy, as mentioned above.|$|R
5000|$|The Makarska Riviera {{is a part}} of the Croatian {{coast of}} the Adriatic Sea, about 60 {{kilometers}} long and only several kilometers wide, squeezed under towering mountain Biokovo. Sunny climate and long pebbly beaches make this region a popular tourist <b>destination.</b> A <b>string</b> of settlements along the coast from the border with Omi≈° coast on northwest to Neretva Delta on the southeast: ...|$|R
50|$|Student {{groups and}} {{activities}} at Moorhead High School include <b>Destination</b> Imagination, Apollo <b>Strings,</b> Business Professionals of America, carolers, drama, Key Club, Knowledge Bowl, newspaper, pep band, Science Olympiad, speech, debate, student council, and yearbook.|$|R
5000|$|... beginning: mov A,string pointer Put {{location}} of first character of source string in register A mov B,string pointer Put {{location of}} first character of <b>destination</b> <b>string</b> in register Bloop: movs B,A Copy 16 bytes at address in register A to address in register B, then increment A and B by 16 jnz loop If the zero flag isn't set then we haven't {{reached the end}} of the string, so go back and copy some more.end: If we didn't loop then we must have finished, so carry on with something else.|$|E
5000|$|... beginning: mov A,string pointer Put {{location}} of first character of source string in register A mov B,string pointer Put {{location of}} first character of <b>destination</b> <b>string</b> in register Bloop: mov C,A Copy byte at address in register A to register C mov B,C Copy byte in register C {{to the address}} in register B inc A Increment the address in register A {{to point to the}} next byte inc B Increment the address in register B to point to the next byte cmp C,#0 Compare the data we just copied to 0 (string end marker) jnz loop If it wasn't 0 then we have more to copy, so go back and copy the next byteend: If we didn't loop then we must have finished, so carry on with something else.|$|E
40|$|As the {{prevalence}} of buffer overflow attacks has increased, more and more programmers are using size or length-bounded string functions such as strncpy() and strncat(). While this is certainly an encouraging trend, the standard C string functions generally used were not really designed for the task. This paper describes an alternate, intuitive, and consistent API designed with safe string copies in mind. There are several problems encountered when strncpy() and strncat() are used as safe versions of strcpy() and strcat(). Both functions deal with NUL-termination and the length parameter in different and non-intuitive ways that confuse even experienced programmers. They also provide {{no easy way to}} detect when truncation occurs. Finally, strncpy() zero-fills the remainder of the <b>destination</b> <b>string,</b> incurring a performance penalty. Ofall these issues, the confusion caused by the length parameters and the related issue of NUL-termination are most important. When we audited the OpenBSD source tree for potential security holes we found rampant misuse of strncpy() and strncat(). While not all of these resulted in exploitable security holes, they {{made it clear that the}} rules for using strncpy() and strncat() in safe string operations are widely misunderstood. The proposed replacement functions, strlcpy() and strlcat(), address these problems by presenting an API designed for safe string copies (see Figure 1 for function prototypes). Both functions guarantee NUL-termination, take asalength parameter the size of the string in bytes, and provide an easy way to detect truncation. Neither function zero-fills unused bytes in the destination...|$|E
50|$|The {{choice of}} segment is {{normally}} defaulted by the processor {{according to the}} function being executed. Instructions are always fetched from the code segment. Any stack push or pop or any data reference referring to the stack uses the stack segment. All other references to data use the data segment. The extra segment is the default <b>destination</b> for <b>string</b> operations (for example MOVS or CMPS). FS and GS have no hardware-assigned uses. The instruction format allows an optional segment prefix byte {{which can be used}} to override the default segment for selected instructions if desired.|$|R
5000|$|Symbolic links {{are special}} files which when {{encountered}} during pathname resolution modify the pathname resolution {{to be taken}} to the location which the symbolic link contains. The content of the symbolic link is therefore the <b>destination</b> path <b>string,</b> which can also be examined using the [...] command line utility. The symbolic link may contain an arbitrary string which does not refer to the location of an existing file, such a symbolic link will fail until a file is created at the location which is contained by the symbolic link. By contrast a symbolic link to an existing file will fail if the existing file is moved to a different location (or renamed).|$|R

