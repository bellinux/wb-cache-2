69|163|Public
2500|$|Supports up to 256 {{interrupts}} in EIC (External Interrupt Controller) {{mode and}} eight <b>hardware</b> <b>interrupt</b> pins ...|$|E
5000|$|<b>Hardware</b> <b>Interrupt</b> (Hwi): support threads {{initiated}} by a <b>hardware</b> <b>interrupt.</b>|$|E
5000|$|... seidisable IRQs waiwait for any <b>hardware</b> <b>interrupt</b> ...execution resumes here ...|$|E
50|$|MS-DOS {{compatibility}} {{was added}} {{late in the}} design, so <b>hardware</b> <b>interrupts</b> and MS-DOS software interrupts overlapped. One DEC documentation pack for developers included a listing of Microsoft assembly code to handle this. The theory was that <b>hardware</b> <b>interrupts</b> would interrupt again but software interrupts would only happen once. The Rainbow 100B fixed this overlap in hardware by changes to the board design that allowed the OS to move the <b>hardware</b> <b>interrupts.</b> This means that the MS-DOS 3.10b version for the Rainbow can only run on the Rainbow 100B.|$|R
5000|$|... handles <b>hardware</b> <b>interrupts</b> and {{may call}} upon , [...] or the like.|$|R
5000|$|... {{processing}} all <b>hardware</b> <b>interrupts</b> including page-faults {{and program}} interrupts due to errors in job programs, ...|$|R
5000|$|The <b>hardware</b> <b>interrupt</b> {{signals are}} all active low, and are as follows: ...|$|E
5000|$|Supports up to 256 {{interrupts}} in EIC (External Interrupt Controller) {{mode and}} eight <b>hardware</b> <b>interrupt</b> pins ...|$|E
5000|$|In {{a modern}} {{operating}} system, upon entry the execution {{context of a}} <b>hardware</b> <b>interrupt</b> handler is subtle.|$|E
40|$|Abstract We empirically {{evaluate}} interrupt-related covert channels, {{in short}} IRCCs, {{a type of}} covert channel that leverages <b>hardware</b> <b>interrupts</b> for communication. The evaluation {{is based on an}} exploit of IRCCs that we implemented as a proof-of-concept. We use a combination of exper-imental evaluation and information-theoretic analysis to compute the bandwidth of the channel on a concrete system. Our analysis shows a channel bandwidth of IRCCs based on interrupts of network interface cards (NICs) of approximately 5 bit/s. Besides the channel bandwidth, our experiments revealed previously unnoticed properties of IRCCs based on interrupts of NICs. While side channels based on <b>hardware</b> <b>interrupts</b> have been discussed before, this is the first experimental evaluation of covert channels based on <b>hardware</b> <b>interrupts.</b> ...|$|R
5000|$|The {{interrupt}} table contains handlers for <b>hardware</b> <b>interrupts,</b> software interrupts, and exceptions. One {{example of}} a software interrupt handler (there are many others) is in table entry 0x2e. It points to the [...]|$|R
25|$|From the {{processing}} point of view, <b>hardware</b> <b>interrupts</b> {{are similar to}} resumable exceptions, though they are typically unrelated to the user program's control flow.|$|R
5000|$|In some {{architectures}} IOMMU also performs <b>hardware</b> <b>interrupt</b> re-mapping, in {{a manner}} similar to standard memory address re-mapping.|$|E
5000|$|Preemption: {{a thread}} may preempt a lower-priority thread, {{such as a}} <b>hardware</b> <b>interrupt</b> or light weight kernel threads.|$|E
5000|$|Maskable {{interrupt}} (IRQ): a <b>hardware</b> <b>interrupt</b> {{that may}} be ignored by setting a bit in an interrupt mask register's (IMR) bit-mask.|$|E
40|$|In this paper, {{we propose}} to {{implement}} hybrid operating systems based on two-level <b>hardware</b> <b>interrupts.</b> To separate real-time and non-real-time <b>hardware</b> <b>interrupts</b> by <b>hardware,</b> {{we show that}} {{it is easier to}} build up hybrid systems with better performance. We analyze and discuss the key issues for implementing a hybrid system based on this and implement a hybrid system called RTLinux-THIN (Real-Time LINUX with Two-level <b>Hardware</b> <b>INterrupts)</b> on the ARM architecture by combining ARM Linux kernel 2. 6. 9 and �C/OS-II. We conduct experiments on a set of real application programs including mplayer [20], Bonnie [4] and iperf [13] and compare the interrupt latency distributions for RTLinux-THIN (with and without cache locking), RTAI and Linux on a hardware platform based on Intel PXA 270 processor [12]. The experimental results show that RTLinux-THIN improves real-time interrupt latencies and provides better predictability. ...|$|R
5000|$|The POWER Hypervisor {{controls}} time slicing, {{management of}} all <b>hardware</b> <b>interrupts,</b> dynamic movement of resources across multiple operating systems, and dispatching of logical partition workloads.|$|R
5000|$|STACKS (DOS 3.2 and Novell DOS 7 and higher, ignored under DR DOS 6.0 and PTS-DOS) : Specifies {{the number}} of stacks for <b>hardware</b> <b>interrupts.</b>|$|R
5000|$|A <b>hardware</b> <b>interrupt</b> occurs; for example, a key {{was pressed}} on the keyboard, or a timer runs out (used in pre-emptive multitasking).|$|E
5000|$|Software Interrupt (Swi): {{structured}} {{to be similar}} to Hwis, but allow processing to be deferred until after a <b>hardware</b> <b>interrupt</b> has completed.|$|E
50|$|The IBM 1620 {{used in the}} 1710 {{system was}} {{modified}} in several ways, the most obvious was {{the addition of a}} very primitive <b>hardware</b> <b>interrupt</b> mechanism.|$|E
50|$|IF (Interrupt Flag) is {{a system}} flag bit in the x86 architecture's FLAGS register, which determines {{whether or not the}} CPU will handle {{maskable}} <b>hardware</b> <b>interrupts.</b>|$|R
50|$|In {{protected}} mode, the IDT is {{an array}} of 8-byte descriptors stored consecutively in memory and indexed by an interrupt vector. These descriptors may be either interrupt gates, trap gates or task gates. Interrupt and trap gates point to a memory location containing code to execute by specifying both a segment (present in either the GDT or LDT) and an offset within that segment. The only {{difference between these two}} is that an interrupt gate will disable further processor handling of <b>hardware</b> <b>interrupts,</b> making it especially suitable to service <b>hardware</b> <b>interrupts,</b> while a trap gate will leave <b>hardware</b> <b>interrupts</b> enabled and is thus mainly used for handling software interrupts and exceptions. Finally, a task gate will cause the currently active task-state segment to be switched, using the hardware task switch mechanism to effectively hand over use of the processor to another program, thread or process.|$|R
40|$|Digital signal {{processors}} (DSPs) {{typically have}} one or more on-chip timers that generate <b>hardware</b> <b>interrupts</b> at periodic intervals. DSP/BIOS ™ normally uses one of the available on-chip timers {{as a source for}} its system clock. The on-chip timer {{can also be used to}} generate periodic <b>hardware</b> <b>interrupts</b> from the user application. DSP/BIOS also has a PRD module that allows the user to trigger periodic functions based on events that are triggered by certain sources. This application report describes the DSP/BIOS timers, clock (CLK), and periodic function (PRD) modules of DSP/BIOS. This document also explains how to configure a periodic function, and how to configure an on-chip timer to generate periodic <b>hardware</b> <b>interrupts.</b> The report also gives some tips on benchmarking with regard to the timers and the clock module. Examples that run on TMS 320 C 6711 DSP starter kit (DSK) and TMS 320 C 5402 DSK are included. The examples demonstrate how to configure timers, and periodic and clock functions using the configuration tool...|$|R
5000|$|Spurious interrupt: a <b>hardware</b> <b>interrupt</b> that is unwanted. They are {{typically}} generated by system {{conditions such as}} electrical interference on an interrupt line or through incorrectly designed hardware.|$|E
5000|$|The 65xx {{family of}} microprocessors, {{consisting}} of the MOS Technology 6502 and its derivatives, the WDC 65C02, WDC 65C802 and WDC 65C816, and CSG 65CE02, all handle interrupts in a similar fashion. There are three <b>hardware</b> <b>interrupt</b> signals common to all 65xx processors and one software interrupt, the [...] instruction. The WDC 65C816 adds a fourth <b>hardware</b> <b>interrupt</b> - , useful for implementing virtual memory architectures - and the [...] software interrupt instruction (also present in the 65C802), intended {{for use in a}} system with a coprocessor of some type (e.g., a floating point processor).|$|E
5000|$|Ring Indicator (RI) is {{a signal}} sent from the DCE to the DTE device. It {{indicates}} {{to the terminal}} device that the phone line is ringing. In many computer serial ports, a <b>hardware</b> <b>interrupt</b> is generated when the RI signal changes state. Having support for this <b>hardware</b> <b>interrupt</b> means that a program or operating system can be informed {{of a change in}} state of the RI pin, without requiring the software to constantly [...] "poll" [...] the state of the pin. RI does not correspond to another signal that carries similar information the opposite way.|$|E
50|$|Profilers use a {{wide variety}} of {{techniques}} to collect data, including <b>hardware</b> <b>interrupts,</b> code instrumentation, instruction set simulation, operating system hooks, and performance counters. Profilers are used in the performance engineering process.|$|R
50|$|In {{computer}} systems programming, an interrupt handler, {{also known as}} an interrupt service routine or ISR, is a special block of code associated with a specific interrupt condition. Interrupt handlers are initiated by <b>hardware</b> <b>interrupts,</b> software interrupt instructions, or software exceptions, and are used for implementing device drivers or transitions between protected modes of operation, such as system calls.|$|R
40|$|In this paper, {{we propose}} to {{implement}} hybrid operating systems based on two-level <b>hardware</b> <b>interrupts.</b> We analyze and model the worst-case real-time interrupt latency for RTAI {{and identify the}} key component for its optimization. Then, we propose our methodology to implement hybrid operating systems with two-level <b>hardware</b> <b>interrupts</b> by combining the real-time kernel and the time-sharing OS (Operating System) kernel. Based on the methodology, we discuss the important issues for the implementation. Finally, we implement a hybrid system called RTLinux-THIN (Real-Time LINUX with Two-level <b>Hardware</b> <b>INterrupts)</b> on the ARM architecture by combining ARM Linux kernel 2. 6. 9 and murm C/OS-rm II}. We conduct experiments {{on a set of}} real application programs including mplayer, Bonnie, and iperf, and compare the interrupt latency and interrupt task distributions for RTLinux-THIN (with and without cache locking), RTAI, Linux, and Linux with RT patch on a hardware platform based on Intel PXA 270 processor. The results show that our scheme not only provides an easy method for implementing hybrid systems but also achieves the performance improvement for both the time-sharing and real-time subsystems. Department of Computin...|$|R
5000|$|Non-maskable {{interrupt}} (NMI): a <b>hardware</b> <b>interrupt</b> {{that lacks}} an associated bit-mask, {{so that it}} can never be ignored. NMIs are used for the highest priority tasks such as timers, especially watchdog timers.|$|E
5000|$|... int t;void swap(int *x, int *y){ t = *x; *x = *y; // <b>hardware</b> <b>interrupt</b> might invoke isr (...) here!! *y = t;}void isr (...) { int x = 1, y = 2; swap(&x, &y);} ...|$|E
50|$|The {{successor}} {{machine was}} the UNIVAC 1103A or Univac Scientific, which improved upon the design by replacing the unreliable Williams tube memory with magnetic core memory, adding hardware floating point instructions, and a <b>hardware</b> <b>interrupt</b> feature.|$|E
40|$|There {{is offered}} theoretic and {{numerical}} approach to simulation of process of <b>hardware</b> <b>interrupts</b> processing i n microcontroller systems. By results of simulation the guidelines on optimization of a loading multitask microcontroller systems are given. ????????? ?????????-????????? ?????? ? ????????????? ???????? ????????? ?????????? ?????????? ? ?????????????????? ????????, ???????????? ? ???????? ?????????????? ????????????. ?? ??????????? ????????????? ???? ???????????? ?? ??????????? ???????? ????????????? ?????????????????? ??????...|$|R
25|$|<b>Hardware</b> <b>{{interrupt}}s</b> are signalled to the CPU {{using three}} inputs that encode the highest pending interrupt priority. A separate Encoder is usually required to encode the interrupts, though for systems {{that do not}} require more than three <b>hardware</b> <b>interrupts</b> it is possible to connect the interrupt signals directly to the encoded inputs at the cost of additional software complexity. The interrupt controller {{can be as simple as}} a 74LS148 priority encoder, or may be part of a VLSI peripheral chip such as the MC68901 Multi-Function Peripheral (used in the Atari ST range of computers and Sharp X68000), which also provided a UART, timer, and parallel I/O.|$|R
50|$|<b>Hardware</b> <b>interrupts</b> were {{introduced}} as an optimization, eliminating unproductive waiting time in polling loops, waiting for external events. They may {{be implemented in}} hardware as a distinct system with control lines, {{or they may be}} integrated into the memory subsystem.|$|R
