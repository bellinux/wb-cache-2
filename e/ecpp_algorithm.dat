5|5|Public
50|$|The large prime {{database}} of The Prime Pages website records the top 20 primes of various special forms; {{one of them}} is proof of primality using the elliptic curve primality proving (<b>ECPP)</b> <b>algorithm.</b> Thus, if the number were large enough and proved prime using ECPP, it would be published.|$|E
50|$|Of those prime candidates, several were {{identified}} as probable prime using the open source program OpenPFGW, {{and one of them}} was proved prime using the <b>ECPP</b> <b>algorithm</b> implemented by the Titanix software. Even at the time of discovery in 2001, this 1401-digit number, of the form k·2562 + 2083, was too small to be mentioned, so Carmody created a 1905-digit prime, of the form k·256211 + 99, that was the tenth largest prime found using ECPP, a remarkable achievement by itself and worthy of being published on the lists of the highest prime numbers. In a way, by having this number independently published for a completely unrelated reason to the DeCSS code, he had been able to evade legal responsibility for the original software.|$|E
40|$|This paper {{deals with}} an {{implementation}} of the elliptic curve primality proving (<b>ECPP)</b> <b>algorithm</b> of Atkin and Morain. As the <b>ECPP</b> <b>algorithm</b> is not deterministic, we are developing a strategy to avoid certain situations in which the original implementation could get stuck and {{to get closer to}} the situation where the probability that the algorithm terminates successfully is 1. We apply heuristics and tricks in order to test the strategy in our implementation in Magma on numbers of up to 7000 decimal digits and collect data to show the advantages over previous implementations in practice...|$|E
50|$|In a 1993 paper, Atkin and Morain {{described}} an <b>algorithm</b> <b>ECPP</b> which avoided {{the trouble of}} relying on a cumbersome point counting algorithm (Schoof's). The algorithm still relies on the proposition stated above, but rather than randomly generating elliptic curves and searching for a proper m, their idea was to construct a curve E where the number of points is easy to compute. Complex multiplication is key {{in the construction of}} the curve.|$|R
40|$|Projet ICSLAThis report {{describes}} {{the theory and}} implementation of the Elliptic Curve Primality Proving <b>algorithm</b> - <b>ECPP</b> - <b>algorithm.</b> This includes the relationships between representing primes by quadratic forms and the explicit construction of class fields of imaginary quadratic fields; the theory of elliptic curves with complex multiplication over the field of complex numbers as well as over finite fields. We then use this theory to design a very powerful primality proving algorithm. Half of the paper is devoted to the description of its implementation. In particular, we give the currently best algorithms to speed up each part of the program. The resulting program is very fast. We can prove the primality of 100 -digit numbers in less than five minutes on a SUN 3 / 60 workstation, and we can treat all numbers with less than 1000 digits in a reasonable amount of time using a distributed implementation...|$|R
40|$|Let E be an {{elliptic}} curve having complex multiplication by a given quadratic order of an imaginary quadratic field K. The field of definition of E is the ring class {{field of the}} order. If the prime p splits completely in then we can reduce E modulo one the factors of p and get a curve E defined over Fp. The trace of the Frobenius of E is known up to sign {{and we need a}} fast way to find this sign. For this, we propose to use the action of the Frobenius on torsion points of small order built with class invariants à la Weber, in a manner reminiscent of the Schoof-Elkies-Atkin algorithm for computing the cardinality of a given {{elliptic curve}} modulo p. We apply our results to the Elliptic Curve Primality Proving <b>algorithm</b> (<b>ECPP)</b> ...|$|R
40|$|Abstract. The {{elliptic}} curve primality proving (<b>ECPP)</b> <b>algorithm</b> {{is one of}} the current fastest practical algorithms for proving the primality of large numbers. Its running time cannot be proven rigorously, but heuristic arguments show that it should run in time Õ((log N) 5) to prove the primality of N. An asymptotically fast version of it, attributed to J. O. Shallit, runs in time Õ((log N) 4). The aim {{of this article is to}} describe this version in more details, leading to actual implementations able to handle numbers with several thousands of decimal digits. 1...|$|E
40|$|On August 2002, Agrawal, Kayal and Saxena {{announced}} the first deterministic and polynomial time primality testing algorithm. For an input n, the AKS algorithm runs in heuristic n). Verification takes {{roughly the same}} amount of time. On the other hand, the Elliptic Curve Primality Proving <b>algorithm</b> (<b>ECPP)</b> runs in random heuristic time O(log n) (O(log n) if the fast multiplication is used), and generates certificates which can be easily verified. More recently, Berrizbeitia gave a variant of the AKS algorithm, in which some primes cost much less time to prove than a general prime does. Building on these celebrated results, this paper explores the possibility of designing a more e#cient algorithm. A random primality proving algorithm with heuristic time complexity O(log n) is presented. It generates a certificate of primality which is O(log n) bits long and can be verified in deterministic time O(log n). The reduction in time complexity is achieved by first generalizing Berrizbeitia's algorithm to one which has higher density of easily-proved primes. For a general prime, one round of ECPP is deployed to reduce its primality proof to the proof of a random easily-proved prime...|$|R
40|$|Abstract. On August 2002, Agrawal, Kayal and Saxena {{announced}} the first deterministic and polynomial time primality testing algorithm. For an input n, the AKS algorithm runs in heuristic time Õ(log 6 n). Verification takes {{roughly the same}} amount of time. On the other hand, the Elliptic Curve Primality Proving <b>algorithm</b> (<b>ECPP),</b> runs in random heuristic time Õ(log 6 n) (Õ(log 5 n) if the fast multiplication is used), and generates certificates which can be easily verified. More recently, Berrizbeitia gave a variant of the AKS algorithm, in which some primes cost much less time to prove than a general prime does. Building on these celebrated results, this paper explores the possibility of designing a more efficient algorithm. A random primality proving algorithm with heuristic time complexity Õ(log 4 n) is presented. It generates a certificate of primality which is O(log n) bits long and can be verified in deterministic time Õ(log 4 n). The reduction in time complexity is achieved by first generalizing Berrizbeitia’s algorithm to one which has higher density of easily-proved primes. For a general prime, one round of ECPP is deployed to reduce its primality proof to the proof of a random easilyproved prime. ...|$|R

