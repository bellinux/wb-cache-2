18|130|Public
40|$|We {{present a}} {{completeness}} {{proof of the}} <b>inductive</b> <b>assertion</b> <b>method</b> for object-oriented programs extended with auxiliary variables. The class of programs considered are assumed to compute over structures which include the standard interpretation of Presburger arithmetic. Further, the assertion language is first-order, i. e., quantification only ranges over basic types {{like that of the}} natural numbers, Boolean and Object...|$|E
40|$|This paper {{explores the}} {{relationship}} between verification of logic programs and imperative programs {{with the aim of}} uncovering the kinds of reasoning used to construct logic programs. We discuss forward reasoning, such as that used for verifying imperative programs using the <b>inductive</b> <b>assertion</b> <b>method,</b> and backward reasoning, such as that used for verifying imperative programs using subgoal induction and logic programs using consequence verification. We argue that consequence verification is often inadequate for Prolog programs because programmers make implicit assumptions about how procedures are called. These assumptions can be made explicit using general type declarations. Verification of logic programs with type declarations can be done in two steps. We show that one corresponds to subgoal induction and the other corresponds to the <b>inductive</b> <b>assertion</b> <b>method.</b> Thus two existing verification methods are combined. The forward and backward reasoning inherent in this method of verificat [...] ...|$|E
40|$|Abstract. We {{present a}} {{completeness}} {{proof of the}} <b>inductive</b> <b>assertion</b> <b>method</b> for object-oriented programs extended with auxiliary variables. The class of programs considered are assumed to compute over structures which include the standard interpretation of Presburger arithmetic. Fur-ther, the assertion language is first-order, i. e., quantification only ranges over basic types {{like that of the}} natural numbers, Boolean and Object. ...|$|E
40|$|Abstract. A {{fundamental}} {{method of}} analyzing a system {{such as a}} program or a circuit is invariance analysis, in which one proves that an assertion holds on all reachable states. Typically, the proof is performed via induction; however, an assertion, while invariant, may not be inductive (provable via induction). Invariant generation procedures construct auxiliary <b>inductive</b> <b>assertions</b> for strengthening the <b>assertion</b> to be <b>inductive.</b> We describe a general method of generating invariants that is incremental and property-directed. Rather than generating one large auxiliary <b>inductive</b> <b>assertion,</b> our <b>method</b> generates many simple assertions, {{each of which is}} inductive relative to those generated before it. Incremental generation is amenable to parallelization. Our method is also property-directed in that it generates <b>inductive</b> <b>assertions</b> that are relevant for strengthening the given assertion. We describe two instances of our method: a procedure for generating clausal invariants of finite-state systems and a procedure for generating affine inequalities of numerical infinite-state systems. We provide evidence that our method scales to checking safety properties of some large finite-state systems...|$|R
40|$|Abstract. The {{deductive}} method reduces verification of safety properties of programs to, first, proposing <b>inductive</b> <b>assertions</b> and, second, proving {{the validity of}} the resulting set of first-order verification conditions. We discuss the transition from verification conditions to verification constraints that occurs when the {{deductive method}} is applied to parameterized assertions instead of fixed expressions (e. g., p 0 +p 1 j +p 2 k ≥ 0, for parameters p 0, p 1, and p 2, instead of 3 +j −k ≥ 0) in order to discover <b>inductive</b> <b>assertions.</b> We then introduce two new verification constraint forms that enable the incremental and propertydirected construction of <b>inductive</b> <b>assertions.</b> We describe an iterative method for solving the resulting constraint problems. The main advantage of this approach is that it uses off-the-shelf constraint solvers and thus directly benefits from progress in constraint solving. ...|$|R
40|$|We present various {{heuristic}} {{techniques for}} use in proving the correctness of computer programs. The techniques are designed to obtain automatically the &quot;inductive assertions &quot; attached to the loops of the program which previously required human &quot;understanding&quot; of the program's performance. We distinguish between two general approaches: one in which we obtain the <b>inductive</b> <b>assertion</b> by analyzing predicates which {{are known to be}} true at the entrances and exits of the loop (top-down approach), and another in which we generate the <b>inductive</b> <b>assertion</b> directly from the statements of the loop (bottom-up approach). I...|$|R
40|$|The <b>inductive</b> <b>assertion</b> <b>method</b> is {{generalized}} to permit formal, machine-verifiable proofs of correctness for multiprocess programs. Individual processes {{are represented by}} ordinary flowcharts, and no special synchronization mechanisms are assumed, so the method {{can be applied to}} a large class of multiprocess programs. A correctness proof can be designed together with the program by a hierarchical process of stepwise refinement, making the method practical for larger programs. The resulting proofs tend to be natural formalizations of the informal proofs that are now used...|$|E
40|$|Program {{verification}} procedures are described {{and used to}} determine the correctness of a program written for an airborne computer. The basic method relies on the <b>inductive</b> <b>assertion</b> <b>method</b> of Floyd (1967), modified and extended for application to a machine-language situation. Correctness considerations in the flight director program include self-modification, system correctness, executable instructions, overflow, approximate calculations with fractional quantities, and fixed point scaling. An example proof of correctness, which proceeds by proving the correctness of a certain subroutine, is provided...|$|E
40|$|AbstractIn {{the second}} part of this work, we {{formulate}} a new <b>inductive</b> <b>assertion</b> <b>method</b> applying to the class of nondeterministic flowchart programs with recursive procedures studied in part 1. Using results on unfolding proved in part 1, we prove that this method is sound and complete with a finite number of assertions. We study four notions of correctness: two notions of partial correctness (existential and universal) and the corresponding notions of total correctness. We also formalize two notions of extension and equivalence (existential and universal) in the second-order predicate calculus...|$|E
40|$|Topics {{concerning}} {{theorem proving}} and program verification are discussed with particlar {{emphasis on the}} Boyer/Moore theorem prover, and approaches to program verification such as the functional and interpreter <b>methods</b> and the <b>inductive</b> <b>assertion</b> approach. A history of the discipline and specific program examples are included...|$|R
40|$|Abstract. We formalize {{the problem}} of program {{verification}} as a learning problem, showing that invariants in program verification {{can be regarded as}} geometric concepts in machine learning. Safety properties define bad states: states a program should not reach. Program verification explains why a program’s set of reachable states is disjoint from the set of bad states. In Hoare Logic, these explanations are predicates that form <b>inductive</b> <b>assertions.</b> Using samples for reachable and bad states and by applying well known machine learning algorithms for classification, we are able to generate <b>inductive</b> <b>assertions.</b> By relaxing the search for an exact proof to classifiers, we obtain complexity theoretic improvements. Further, we extend the learning algorithm to obtain a sound procedure that can generate proofs containing invariants that are arbitrary boolean combinations of polynomial inequalities. We have evaluated our approach on a number of challenging benchmarks and the results are promising...|$|R
40|$|The {{correctness}} of a sequential {{program can}} be shown by the anno-tation of its control flow graph with <b>inductive</b> <b>assertions.</b> We pro-pose <b>inductive</b> data flow graphs, data flow graphs with incorpo-rated <b>inductive</b> <b>assertions,</b> {{as the basis of}} an approach to verifying concurrent programs. An inductive data flow graph accounts for a set of dependencies between program actions in interleaved thread executions, and therefore stands as a representation for the set of concurrent program traces which give rise to these dependencies. The approach first constructs an inductive data flow graph and then checks whether all program traces are represented. The size of the inductive data flow graph is polynomial in the number of data de-pendencies (in a sense that can be made formal); it does not grow exponentially in the number of threads unless the data dependen-cies do. The approach shifts the burden of the exponential explosion towards the check whether all program traces are represented, i. e., to a combinatorial problem (over finite graphs) ...|$|R
40|$|Today the {{predominant}} theoretical {{basis for the}} semantic analysis of programs is the <b>inductive</b> <b>assertion</b> <b>method</b> due to floyd 'Floyd 1 ', and the deductive logical systems subsequently developed by Hoare and others. Howoever, these systems link the derivation of knowledge about programs directly to the verification of asserted programs; they do not provide an adequate basis for such tasks as source-to-source optimization, interactive program documentation, or static performance analysis. In varying degrees, they require the user to provide redundant specificatlons trlvially derivable from the program text. Furthermore,several features found in hlgher-level programming languages create substantial problems for the practical application of these deductive systems...|$|E
40|$|AbstractAn {{extension}} of the <b>inductive</b> <b>assertion</b> <b>method</b> allowing one to prove the partial correctness of an attribute grammar w. r. t. a specification is presented. It is complete in an abstract sense. It is also shown that the semantics of systems of recursive imperative procedures or of recursive applicative procedures computed with call-by-value or call-by-name can be expressed by an attribute grammar associating attributes with the nodes of the so-called trees of calls. Hence the proof methods for the partial correctness of attribute grammars {{can be applied to}} these recursive procedures. We show also how the proof method can be applied in logic programming...|$|E
40|$|AbstractCertain {{properties}} of logic programs are inexpressible {{in terms of}} their declarative semantics. One example of such properties would be the actual form of procedure calls and successes which occur during computations of a program. They are often used by programmers in their informal reasoning. In this paper, the <b>inductive</b> <b>assertion</b> <b>method</b> for proving partial correctness of logic programs is introduced and proved sound. The method makes it possible to formulate and prove properties which are inexpressible in terms of the declarative semantics. An execution mechanism using the Prolog computation rule and arbitrary search strategy (e. g., OR-parallelism or Prolog backtracking) is assumed. The method may also be used to specify the semantics of some extra-logical built-in procedures for which the declarative semantics is not applicable...|$|E
40|$|Abstract. Differential {{evolution}} {{algorithm is}} a kind of heuristic random search algorithm, and the traditional sample learning is to find a <b>inductive</b> <b>assertion</b> including all positive examples but not all counter-examples in the example space. But this process is endless and cumbersome because of the large number of the samples. The merit of difference evolution algorithm is searching in the community. So this paper using this merit to combine with sample learning then promoting efficiency...|$|R
5000|$|QUnit uses {{a set of}} <b>assertion</b> <b>method</b> {{to provide}} {{semantic}} meaning in unit tests: ...|$|R
40|$|Abstract—An {{incremental}} algorithm for model checking progress properties is proposed. It {{follows from}} the following insight: any SCC-closed region of a system’s state graph can be represented by a sequence of <b>inductive</b> <b>assertions.</b> Each iteration of the algorithm selects a set of states, called a skeleton, that together satisfy all fairness conditions; it then applies safety model checkers to attempt to connect the states into a reachable fair cycle. If this attempt fails, the resulting learned lemma takes one of two forms: an <b>inductive</b> reachability <b>assertion</b> that shows {{that at least one}} state of the skeleton is unreachable, or an inductive wall that defines two SCC-closed regions of the state graph. Subsequent skeletons must be chosen entirely {{from one side of the}} wall. Because a lemma often applies more generally than to the one skeleton from which it was derived, property-directed abstraction is achieved. The algorithm is highly parallelizable. I...|$|R
40|$|Manna's theorem on (partial) {{correctness}} {{of programs}} essentially states {{that in the}} statement of the Floyd <b>inductive</b> <b>assertion</b> <b>method,</b> "A flow diagram is correct with respect o given initial and final assertions if suitable intermediate assertions can be found, " we may replace "if " by "if and only if. " In other words, the method is complete. A precise formulation and proof for the flow chart case is given. The theorem is then extended to programs with (parameterless) recursion; for this {{the structure of the}} intermediate assertions has to be refined considerably. The result is used to provide a characterization of recursion which is an alternative to the minimal fixed point characterization, and to clarify the relationship between partial and total correctness. Important tools are the relational representation f programs, and Scott's induction. 1...|$|E
40|$|AbstractIn this paper, {{we study}} {{some aspects of}} the {{semantics}} of nondeterministic flowchart programs with recursive procedures. In {{the first part of this}} work we provide the operational semantics of programs using the concept of an execution tree. We propose a new definition of the semantics of a non-deterministic recursive program as a mapping from the input domain to the set of execution trees determined by the program. Using this new concept, we prove that every nondeterministic flowchart program with recursive procedures can be unfolded into a semantically equivalent infinite pure flowchart (without procedures). This result is applied in the second part of this work to prove the soundness of an <b>inductive</b> <b>assertion</b> <b>method</b> which is also complete with a finite number of assertions (contrary to De Bakker and Meertens's method [11]) ...|$|E
40|$|Certain {{properties}} of logic programs are inexpressible {{in terms of}} their declarative semantics. One example of such properties would be the actual form of procedure calls and successes which occur during computations of a program. They are often used by programmers in their informal reasoning. In this paper, the <b>inductive</b> <b>assertion</b> <b>method</b> for proving partial correctness of logic programs is introduced and proved sound. The method makes it possible to formulate and prove properties which are inexpressible in terms of the declarative semantics. An execution mechanism using the Prolog computation rule and arbitrary search strategy (eg. OR-parallelism or Prolog backtracking) is assumed. The method may be also used to specify the semantics of some extra-logical built-in procedures for which the declarative semantics is not applicable. 1. INTRODUCTION One of the most attractive features of logic programs is their declarative semantics [Apt, van Emden][Lloyd]. It describes program meaning in [...] ...|$|E
50|$|QUnit's <b>assertion</b> <b>methods</b> {{follow the}} CommonJS unit testing specification, which itself was {{influenced}} {{to some degree}} by QUnit.|$|R
40|$|Abstract — We {{present a}} method for verifying {{information}} flow properties of software programs using <b>inductive</b> <b>assertions</b> and theorem proving. Given a program annotated with information flow assertions at cutpoints, the method uses a theorem prover and operational semantics to generate and discharge verification conditions. This obviates {{the need to develop}} a verification condition generator (VCG) or a customized logic for information flow properties. The method is compositional: a subroutine needs to be analyzed once, rather than at each call site. The method is being mechanized in the ACL 2 theorem prover, and we discuss initial results demonstrating its applicability. I...|$|R
40|$|Abstract. We analyze three proof {{strategies}} {{commonly used}} in deductive verification of deterministic sequential programs formalized with operational semantics. The strategies are: (i) stepwise invariants, (ii) clock functions, and (iii) <b>inductive</b> <b>assertions.</b> We show how to formalize the strategies in {{the logic of the}} ACL 2 theorem prover. Based on our formalization, we prove that each strategy is both sound and complete. The completeness result implies that given any proof of correctness of a sequential program one can derive a proof in each of the above strategies. The soundness and completeness theorems have been mechanically checked with ACL 2...|$|R
40|$|The {{author of}} a program can {{convince}} its readers (including himself) that it computes as he intended by writing into the program text a precise description of what it should do. This description can include a clear proof that the program behaves as advertised. In the future, programming languages may offer far more mechanical assistance in expressing, checking, and processing these descriptions than they do now. However, some existing languages, such as PL/C, provide features which help in these tasks considerably. Here we examine such features applied to simple programs of the type traditionally taught in beginning programming classes. We discuss various proposals for expanding programming languages to provide more assistance of this type. Keywords and phrases: program correctness, automatic program verification, Hoare axioms, Scott induction, recursive programs, least number operator, bounded quantifiers, <b>inductive</b> <b>assertion</b> <b>method,</b> programming language design, very high level programmng languages, PL/I, PL/C, macro facilities...|$|E
40|$|Abstract. I t is {{proved that}} in the general case of {{arbitrary}} context-free schemes a program is (partially) correct with respect to given initial and final assertions {{if and only if}} a suitable finite system of intermediate assertions can be found. Assertions are allowed from the extended state space V x V. This result contrasts with the results of [2], where it is proved that if assertions are taken from the original state space V. then in the general case an infinite system of intermediate assertions is needed. The extension of the state space allows a unification in the relational framework of [2], of the (essence of the) results of [2], and of [4], 151 and [6], and provides a semantic counterpart of the use of auxiliary variables. Key words. partial correctness, intermediate assertions, relational framework, extended state space, recursive program schemes 1. Introduction. De Bakker and Meertens proved in [2] that an infinite system of intermediate assertions is needed to prove the completeness of the <b>inductive</b> <b>assertion</b> <b>method</b> in the case o f an arbitrary system of (mutually) recursive parameterless procedures. On the other hand, Gorelick in [5] extended the results of [3] and obtained a completeness result for a Hoare-like axiomatic system (see [7]) for a fragment o...|$|E
40|$|In code {{certification}} {{the code}} consumer publishes a safety {{policy and the}} code producer generates a proof that the produced code is {{in compliance with the}} published safety policy. In this paper, a novel viewpoint approach towards an implementational re-use oriented framework for code certification is taken. It adopts ingredients from Necula's approach for proof-carrying code, but in this work safety properties can be analyzed on a higher code level than assembly language instructions. It consists of three parts: (1) The specification language is extended to include generic pre-conditions that shall ensure safety at all states that can be reached during program execution. Actual safety requirements can be expressed by providing domain-specific definitions for the generic predicates which act as interface to the environment. (2) The Floyd-Hoare <b>inductive</b> <b>assertion</b> <b>method</b> is refined to obtain proof rules that allow the derivation of the proof obligations in terms of the generic safety predicates. (3) A meta-interpreter is designed and experimentally implemented that enables automatic synthesis of proof obligations for submitted programs by applying the modified Floyd-Hoare rules. The proof obligations have two separate conjuncts, one for functional correctness and another for the generic safety obligations. Proof of the generic obligations, having provided the actual safety definitions as context, ensures domain-specific safety of program execution in a particular environment and is simpler than full program verification...|$|E
40|$|Program Verification, proving {{programs}} correct, <b>inductive</b> <b>assertions,</b> proof rule, uniform loop programs, stack schema, for programs. Three {{different classes}} of programs are identi-fied {{for which the}} proof of correctness is shown to be &quot;natural&quot;, in that the functional input-output specifications of the programs lead, in a straight-forward manner, to the verification conditions that should be proven. Furthermore, these verification conditions are shown to be necessary and sufficient so that a proof/refutation follows by proving/dis-proving the corresponding verification conditions. It {{is not necessary to}} follow the exact control flow of the programs to generate these conditions; certai...|$|R
40|$|Abstract. This paper {{shows how}} classic <b>inductive</b> <b>assertions</b> {{can be used}} in {{conjunction}} with an operational semantics to prove partial correctness properties of programs. The method imposes only the proof obligations that would be produced by a verification condition generator but does not require the definition of a verification condition generation. The paper focuses on iterative programs but recursive programs are briefly discussed. Assertions are attached to the program by defining a predicate on states. This predicate is then “completed ” to an alleged invariant by the definition of a partial function defined in terms of the state transition function of the operational semantics. If this alleged invariant can be proved to be an invariant under the state transition function, it follows that the assertions are true every time they are encountered in execution and thus that the post-condition is true if reached from a state satisfying the pre-condition. But because of {{the manner in which the}} alleged invariant is defined, the verification conditions are sufficient to prove invariance. Indeed, the “natural ” proof generates the classical verification conditions as subgoals. The invariant function may be thought of as a state-based verification condition generator for the annotated program. The <b>method</b> allows standard <b>inductive</b> <b>assertion</b> style proofs to be constructed directly in an operational semantics setting. The technique is demonstrated by proving the partial correctness of simple bytecode programs with respect to a pre-existing operational model of the Java Virtual Machine. ...|$|R
40|$|The trace <b>assertion</b> <b>method</b> is {{a formal}} state machine based method for specifying module {{interfaces}} [2, 10, 23, 27, 31, 35]. A module interface specification treats the module as a black-box, identifying all module's access programs (i. e., programs {{that can be}} invoked from outside of the module), and describing their externally visible effects. In the method, both the system states and the behaviors observed are fully described by traces built from access program invocations and their visible effects. So far the method has only been applied to the sequential accesses to modules, i. e. there is an assumption that no two events can occur simultaneously. This paper improves the existing method and presents the trace <b>assertion</b> <b>method</b> of module interface specification with concurrent events. The foundations and specification formats of Concurrent Trace <b>Assertion</b> <b>Method</b> is developed for deterministic, non-deterministic, output dependent and output independent modules...|$|R
40|$|This paper {{develops}} verification {{methodology for}} quantum programs, and {{the contribution of}} the paper is two-fold: 1. Sharir, Pnueli and Hart [SIAM J. Comput. 13 (1984) 292 - 314] presented a general method for proving properties of probabilistic programs, in which a probabilistic program is modeled by a Markov chain and an assertion on the output distribution is extended into an invariant assertion on all intermediate distributions. Their method is essentially a probabilistic generalization of the classical Floyd <b>inductive</b> <b>assertion</b> <b>method.</b> In this paper, we consider quantum programs modeled by quantum Markov chains which are defined by super-operators. It is shown that the Sharir-Pnueli-Hart method can be elegantly generalized to quantum programs by exploiting the Schrödinger-Heisenberg duality between quantum states and observables. In particular, a completeness theorem for the Sharir-Pnueli-Hart verification method of quantum programs is established. 2. As indicated by the completeness theorem, the Sharir-Pnueli-Hart method is in principle effective for verifying all properties of quantum programs that can be expressed in terms of Hermitian operators (observables). But it is not feasible for many practical applications because of the complicated calculation involved in the verification. For the case of finite-dimensional state spaces, we find a method for verification of quantum programs much simpler than the Sharir-Pnueli-Hart method by employing the matrix representation of super-operators and Jordan decomposition of matrices. In particular, this method enables us to compute easily the average running time and even to analyze some interesting long-run behaviors of quantum programs in a finite-dimensional state space...|$|E
40|$|This {{thesis is}} {{concerned}} with ways of proving the correctness of computer programs. The {{first part of the}} thesis presents a new method for doing this. The method, called continuation induction, is based on the ideas of symbolic execution, the description of a given program by a virtual program, and the demonstration that these two programs are equivalent whenever the given program terminates. The main advantage of continuation induction over other methods is that it enables programs using a wide variety of programming constructs such as recursion, iteration, non-determinism, procedures with side-effects and jumps out of blocks to be handled in a natural and uniform way. In {{the second part of the}} thesis a program verifier which uses both this method and Floyd's <b>inductive</b> <b>assertion</b> <b>method</b> is described. The significance of this verifier is that it is designed to be extensible, and to this end the user can declare new functions and predicates to be used in giving a natural description of the program's intention. Rules describing these new functions can then be used when verifying the program. To actually prove the verification conditions, the system employs automatic simplification, a relatively clever matcher, a simple natural deduction system and, most importantly, the user's advice. A large number of commands are provided for the user in guiding the system to a proof of the program's correctness. The system has been used to verify various programs including two sorting programs and a program to invert a permutation 'in place' the proofs of the sorting programs included a proof of the fact that the final array was a permutation of the original one. Finally, some observations and suggestions are made concerning the continued development of such interactive verification systems...|$|E
40|$|The goal of {{the paper}} is to {{emphasize}} the connection between specification languages and program verification techniques, such as Floyd 2 ̆ 7 s <b>Inductive</b> <b>assertions</b> and Topor 2 ̆ 7 s virtual programs, {{which are based on}} symbolic execution. The paper claims the opportunity of having an "executable" specification language, i. e. of having a procedural representation of both the assertions, and the simplification rules and axioms. The parer describes a predicate logic functional specification language with an efficient symbolic interpreter. The interpreter can deterministically execute axioms which express functions as well as function properties, thus reducing most of the burden of theorem proving...|$|R
3000|$|Modify {{the test}} code to n = 2 {{so that it}} uses the <b>assertion</b> <b>method</b> you created. The @ReTest {{annotation}} must be used for this test method to run 10 times; [...]...|$|R
40|$|AbstractThe simple set WL of {{deterministic}} while {{programs is}} defined {{and a number}} of known methods for proving the correctness of these programs are surveyed. Emphasis is placed on the tradeoff existing between data-directed and syntax-directed methods, and on providing, especially for the latter, a uniform description enabling comparison and assessment. Among the works considered are the Floyd/Hoare invariant <b>assertion</b> <b>method</b> for partial correctness, Floyd's well-founded sets method for termination, Dijkstra's notion of weakest precondition, the Burstall/Manna and Waldinger intermittent <b>assertion</b> <b>method</b> and more. Also, a brief comparison is carried out between three logics of programs: dynamic logic, algorithmic logic and programming logic...|$|R
40|$|This paper {{shows how}} classic <b>inductive</b> <b>assertions</b> {{can be used}} in {{conjunction}} with an operational semantics to prove partial correctness properties of programs, without the introduction of a verification condition generator. In particular, we show how a formal statement about the operational semantics can be deduced more or less directly from verification conditions and how a "natural" proof strategy generates those veri cation conditions as subgoals. Both iterative and recursive programs are considered. Assertions are attached to the program by defining a predicate on states. This predicate is then "completed" to an alleged invariant by the definition of a tail-recursive partial function defined in terms of the state transition function of the operational semantics. If thi...|$|R
