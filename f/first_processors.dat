15|564|Public
25|$|The <b>first</b> <b>processors</b> {{that used}} this {{architecture}} were code-named 'Merom', 'Conroe', and 'Woodcrest'; Merom is for mobile computing, Conroe is for desktop systems, and Woodcrest is for servers and workstations. While architecturally identical, the three processor lines {{differ in the}} socket used, bus speed, and power consumption. Mainstream Core-based processors are branded Pentium Dual-Core or Pentium and low end branded Celeron; server and workstation Core-based processors are branded Xeon, while Intel's first 64-bit desktop and mobile Core-based processors were branded Core 2.|$|E
5000|$|One of the <b>first</b> <b>processors</b> to {{implement}} such counter and an associated instruction [...] to access {{it was the}} Intel Pentium, {{but they were not}} documented until Terje Mathisen wrote an article about reverse engineering them in Byte July 1994: ...|$|E
50|$|The <b>first</b> <b>processors</b> using Socket 754 came on {{the market}} {{in the second half of}} 2003. Socket 754 was phased out in favor of Socket 939 on {{desktops}} because of low sales. The socket remained in use for laptops until it was replaced by S1 in 2006.|$|E
5|$|April: AMD {{releases}} Opteron, the <b>first</b> <b>processor</b> with x86-64 extensions.|$|R
500|$|June: Intel {{releases}} its <b>first</b> <b>processor</b> with x86-64 extensions, a Xeon processor codenamed [...] "Nocona".|$|R
50|$|In November 2008, Intel {{released}} Core i7, {{which was}} the <b>first</b> <b>processor</b> requiring this socket.|$|R
5000|$|In the <b>first</b> <b>processors</b> that {{supported}} PAE, support for larger physical addresses {{is evident in}} their package pinout, with address pin designations going up to A35 instead of stopping at A31. Later processor families use interconnects such as Hypertransport or QuickPath Interconnect, which lack dedicated memory address signals, so this relationship is less apparent.|$|E
50|$|While the <b>first</b> <b>processors</b> in this {{category}} were single core (such as the SU3500), newer CULV processors are dual core (e.g., the SU9600). They are all based on the Intel Core 2 architecture, but the ultra-low voltage versions have thermal rating of 5.5 W, more than the Intel Atom but {{a fraction of the}} dual-core mainstream Intel mobile chips rated at 25 and 35 watts, and they come in a small 22 mm chip package.|$|E
50|$|The Clipper {{architecture}} is a 32-bit RISC-like instruction set architecture designed by Fairchild Semiconductor. The architecture never enjoyed much market success, {{and the only}} computer manufacturers to create major product lines using Clipper processors were Intergraph and High Level Hardware. The <b>first</b> <b>processors</b> using the Clipper architecture were designed and sold by Fairchild, but the division responsible for them was subsequently sold to Intergraph in 1987; Intergraph continued work on Clipper processors for use in its own systems.|$|E
5000|$|... 1993. Intel {{launches}} {{the original}} Pentium microprocessor, the <b>first</b> <b>processor</b> with a x86 superscalar microarchitecture.|$|R
5000|$|June: Intel {{releases}} its <b>first</b> <b>processor</b> with x86-64 extensions, a Xeon processor codenamed [...] "Nocona".|$|R
5000|$|TMS32010, {{the very}} <b>first</b> <b>processor</b> in the <b>first</b> series {{introduced}} in 1983, using external memory ...|$|R
50|$|The <b>first</b> <b>processors</b> {{using the}} brand {{appeared}} in notebook computers in early 2007. Those processors, named Pentium T2060, T2080, and T2130, had the 32-bit Pentium M-derived Yonah core, and closely resembled the Core Duo T2050 processor {{with the exception}} of having 1 MB of L2 cache instead of 2 MB. All three of them had a 533 MHz FSB connecting the CPU with the memory. Intel developed the Pentium Dual-Core at the request of laptop manufacturers.|$|E
50|$|The <b>first</b> <b>processors</b> {{that used}} this {{architecture}} were code-named 'Merom', 'Conroe', and 'Woodcrest'; Merom is for mobile computing, Conroe is for desktop systems, and Woodcrest is for servers and workstations. While architecturally identical, the three processor lines {{differ in the}} socket used, bus speed, and power consumption. Mainstream Core-based processors are branded Pentium Dual-Core or Pentium and low end branded Celeron; server and workstation Core-based processors are branded Xeon, while Intel's first 64-bit desktop and mobile Core-based processors were branded Core 2.|$|E
50|$|Modern {{computers}} {{may contain}} a dedicated MAC, {{consisting of a}} multiplier implemented in combinational logic followed by an adder and an accumulator register that stores the result. The output of the register is fed back to one input of the adder, so that on each clock cycle, {{the output of the}} multiplier is added to the register. Combinational multipliers require a large amount of logic, but can compute a product much more quickly than the method of shifting and adding typical of earlier computers. The <b>first</b> <b>processors</b> to be equipped with MAC units were digital signal processors, but the technique is now also common in general-purpose processors.|$|E
50|$|This was the <b>first</b> <b>processor</b> {{released}} by Cortus, {{it has now}} been superseded by the APS3R.|$|R
50|$|DEC's first multi-processor VAX system, the VAX-11/782, was an {{asymmetric}} dual-processor system; {{only the}} <b>first</b> <b>processor</b> {{had access to}} the I/O devices.|$|R
50|$|The <b>first</b> <b>processor</b> to use HMCs was the Fujitsu SPARC64 XIfx, {{which is}} used in the Fujitsu PRIMEHPC FX100 {{supercomputer}} introduced in 2015.|$|R
50|$|In {{addition}} to being a top-10 payment processor, First National Merchant Solutions is also the 4th largest bank processor in the United States and is the 6th largest in-house processor of credit cards. In 1967, First National Bank of Omaha automated many of its manual credit card processes and was the first credit card processing center in the nation to offer descriptive billing statements. In 1988, First National Bank of Omaha became the first processor to develop authorization slips for restaurants with a blank area for including tip. A couple of years later, FNBO's acquiring division was renamed to First of Omaha Merchant Processing. First of Omaha Merchant Processing received the 1994 Member Service Quality Performance Award for Best Copy Performance by an acquirer with Visa sales over $1.5 billion. In 2002, First of Omaha Merchant Processing changed its name to First National Merchant Solutions. A year later, FNMS celebrated its 50th year of processing payments. First National Merchant Solutions became one of the <b>first</b> <b>processors</b> to offer merchants ACH and credit card transactions in the same batch file in 2004. The following year, First National Merchant Solutions introduced First Resolution OnlineTM, the first chargeback management tool in the market to allow merchants to resolve chargebacks online.|$|E
40|$|The {{pipeline}} is {{a simple}} and intuitive structure to speed up many problems. Novice parallel programmers are usually taught this structure early on. However, expert parallel programmers typically eschew using the pipeline in coarse–grained applications because it has three serious problems that {{make it difficult to}} implement efficiently. <b>First,</b> <b>processors</b> are idle when the pipeline is not full. Second, load balancing is crucial to obtaining good speedup. Third, it is difficult to incrementally incorporate more processors into an existing pipeline. Instead, experts recast the problem as a master/slave structure which does not suffer from these problems. This paper details a transformation that allows programs written in a pipeline style to execute using the master/slave structure. Parallel programmers can benefit from both the intuitive simplicity of the pipeline and the efficient execution of a master/slave structure. This is demonstrated by performance results from two applications. 1...|$|E
40|$|This {{research}} report describes the formal verification of an {{arithmetic logic unit}} of the VIPER microprocessor. VIPER {{is one of the}} <b>first</b> <b>processors</b> designed using formal methods. A formal model in HOL has been created which models the ALU at two levels: on the higher level, the ALU is specified as a function taking two 32 bit operands and returning a result; on the lower level, the ALU is implemented by a number of 4 -bit slices which should takes the same operands and returns the same result. The ALU is capable of performing thirteen different operations. A formal proof of functional equivalence of these two levels has been completed successfully. The complete HOL text of the ALU formal model and details of the proof procedures are included in this report. It has demonstrated that the HOL system is powerful and efficient enough to perform formal verification of realistic hardware design. 4 ALU Verification 1 Introduction This report describes the verification of the Arithmetic Logi [...] ...|$|E
30|$|The <b>first</b> <b>processor,</b> called MCISAR, {{is based}} on the {{isotropic}} point hypothesis. It is analogous to classical processors as it coherently sums bistatic images.|$|R
50|$|While many {{processors}} of {{the time}} used either superscalar instruction dispatch or superpipelined operation, the Clipper C400 was the <b>first</b> <b>processor</b> to use both.|$|R
50|$|SSSE3 {{has been}} {{referred}} to by the codenames Tejas New Instructions (TNI) or Merom New Instructions (MNI) for the <b>first</b> <b>processor</b> designs intended to support it.|$|R
40|$|Computational and {{biological}} systems are often distributed so that processors (cells) jointly solve a task, {{without any of}} them receiving all inputs or observing all outputs. Maximal independent set (MIS) selection is a fundamental distributed computing procedure that seeks to elect a set of local leaders in a network. A variant of this problem is solved during {{the development of the}} fly’s nervous system, when sensory organ precursor (SOP) cells are chosen. By studying SOP selection, we derived a fast algorithm for MIS selection that combines two attractive features. <b>First,</b> <b>processors</b> do not need to know their degree; second, it has an optimal message complexity while only using one-bit messages. Our findings suggest that simple and efficient algorithms can be developed on the basis of biologically derived insights. Computational and mathematical methods are extensively used to analyze and model biological systems (1 – 3). We provide an example of the reverse of this strategy, in which a biological process is used to derive a solution to a long-standing computational problem...|$|E
40|$|Increasing the {{performance}} of microprocessors {{has always been a}} pressing issue in the fields of Computer Science and Computer Engineering. The <b>first</b> <b>processors</b> functioned by executing a single stream of sequential instructions. The initial approach to increasing the speed of instruction execution involved using smaller and faster transistors so that the clock frequency could be increased. This approach was stymied by slow memory accesses that could not keep up with a fast clock cycle. Cache memories were developed to keep frequently accessed data closer to the processor to prevent the types of stalls. RISC, reduced instruction set computing, architectures were also designed to allow for faster clock cycles and execution. After RISC, the focus shifted away from speeding up the execution of a single instruction and moved towards increasing the number of instructions that can be active in a single clock cycle. Different designs, such as pipelining and superscalars, allowed multiple instructions to be issued in the same clock cycle, but were limited by increased power consumption, heat, and chip size. Multi-core and multiprocessor designs allowed multiple threads of instructions to be simultaneously executed on different processors or cores. These designs were improved by the development of multithreading, which aimed to increase threadlevel parallelism on a single core. This thesis addresses the intricacies of a specific type of hardware multithreading: Simultaneous Multithreading (SMT). SMT is a technique used to increase {{the performance}} of a microprocessor by exploiting parallelism in all available forms. SMT combines instruction-level and thread-level parallelism and enables multiple instructions from multiple threads to be issued in the same clock cycle. This paper is a detailed examination of Simultaneous Multithreading and will specifically address: how multiple instructions are fetched and issued simultaneously, how hardware resources are designated amongst threads, the performance upgrade associated with SMT in terms of instructions per cycle, the energy-efficiency of the design, and how SMT is utilized in general purpose microprocessors such as in the Intel Pentium 4 Hyper-Threading processor...|$|E
40|$|Memory accesses {{in modern}} {{processors}} are both far slower and vastly more energy-expensive {{than the actual}} computations. To improve performance, processors spend {{a significant amount of}} energy and resources trying to hide and reduce the memory latency. To hide the latency, processors use out-order-order execution to overlap memory accesses with independent work and aggressive speculative instruction scheduling to execute dependent instructions back-to-back. To reduce the latency, processors use several levels of caching that keep frequently used data closer to the processor. However, these optimizations are not for free. Out-of-order execution requires expensive processor resources, and speculative scheduling must re-execute instructions on incorrect speculations, and multi-level caching requires extra energy and latency to search the cache hierarchy. This thesis investigates several energy-efficient techniques for: 1) hiding the latency in the processor pipeline, and 2) reducing the latency in the memory hierarchy. Much of the inefficiencies of hiding latency in the processor come from two sources. <b>First,</b> <b>processors</b> need several large and expensive structures to do out-of-order execution (instructions queue, register file, etc.). These resources are typically allocated in program order, effectively giving all instructions equal priority. To reduce the size of these expensive resources without hurting performance, we propose Long Term Parking (LTP). LTP parks non-critical instructions before they allocate resources, thereby making room for critical memory accessing instructions to continue and expose more memory-level parallelism. This enables us to save energy by shrinking the resources sizes without hurting performance. Second, when a load's data returns, the load's dependent instructions need to be scheduled and executed. To execute the dependent instructions back-to-back, the processor will speculatively schedule instructions before the processor knows if the input data will be available at execution time. To save energy, we investigate different scheduling techniques that reduce the number of re-executions due to misspeculation. The inefficiencies of traditional memory hierarchies come from the need to do level-by-level searches to locate data. The search starts at the L 1 cache, then proceeds level by level until the data is found, or determined not to be in any cache, at which point the processor has to fetch the data from main memory. This wastes time and energy for every level that is searched. To reduce the latency, we propose tracking the location of the data directly in a separate metadata hierarchy. This allows us to directly access the data without needing to search. The processor simply queries the metadata hierarchy for the location information about where the data is stored. Separating metadata into its own hierarchy brings a wide range of additional benefits, including flexibility in how we place data storages in the hierarchy, the ability to intelligently store data in the hierarchy, direct access to remote cores, and many other data-oriented optimizations that can leverage our precise knowledge of where data are located...|$|E
5000|$|QorIQ AMP Series T4240 as the <b>first</b> <b>processor</b> {{revealed}} with 12 cores {{followed by}} T2080 and T2081 with four cores and {{speeds up to}} 1.8 GHz.|$|R
5000|$|In October 2015, Oracle {{released}} SPARC M7, the <b>first</b> <b>processor</b> {{based on}} the new Oracle SPARC Architecture 2015 specification.- [...] This revision includes VIS 4 instruction set extensions.|$|R
50|$|EasyWriter {{was a word}} <b>processor</b> <b>first</b> {{written for}} the Apple II series {{computer}} in 1979, the <b>first</b> word <b>processor</b> for that platform.|$|R
50|$|Whitefield, the <b>first</b> Xeon <b>processor</b> {{to feature}} QuickPath, {{suffered}} significant project delays and was cancelled. The <b>first</b> Xeon MP <b>processor</b> to feature QuickPath is Beckton.|$|R
50|$|Carta was the world's <b>first</b> <b>processor</b> to {{complete}} integration to MasterCard MOTAPS, enabling rapid deployment for NFC programs. Their Charlottetown, PEI, data centre {{is the only}} secure third party issuer processing data host for financial services in Canada.|$|R
25|$|The <b>first</b> <b>processor</b> with a Thumb {{instruction}} decoder was the ARM7TDMI. All ARM9 and later families, including XScale, have included a Thumb {{instruction decoder}}. The Thumb instruction set was originally inspired by SuperH's ISA; ARM licensed several patents from Hitachi.|$|R
50|$|The <b>first</b> <b>processor</b> to {{be advertised}} as a PPU {{was called the}} PhysX chip, {{introduced}} by a fabless semiconductor company called AGEIA. Games wishing {{to take advantage of}} the PhysX PPU must use AGEIA's PhysX SDK, (formerly known as the NovodeX SDK).|$|R
50|$|In 2000, IBM {{launched}} a refined version called IStar manufactured with a SOI fabrication process with copper interconnects, which increased the processor's clock frequency to 600 MHz. This was the <b>first</b> <b>processor</b> implemented in this process. Architecturally however, the IStar was identical to Pulsar.|$|R
50|$|Its <b>first</b> <b>processor</b> board {{included}} an ARM architecture 32 bit CPU with ARM920T core running at 180 MHz. It had 512 KB RAM and 4 MB flash memory. A 2.4 GHz IEEE 802.15.4 radio had an integrated antenna and a USB interface was included.|$|R
