103|30|Public
25|$|The {{number of}} {{possible}} URLs crawled being generated by server-side software has also {{made it difficult for}} web crawlers to avoid retrieving duplicate content. Endless combinations of <b>HTTP</b> <b>GET</b> (URL-based) parameters exist, of which only a small selection will actually return unique content. For example, a simple online photo gallery may offer three options to users, as specified through <b>HTTP</b> <b>GET</b> parameters in the URL. If there exist four ways to sort images, three choices of thumbnail size, two file formats, and an option to disable user-provided content, then the same set of content can be accessed with 48 different URLs, all of which may be linked on the site. This mathematical combination creates a problem for crawlers, as they must sort through endless combinations of relatively minor scripted changes in order to retrieve unique content.|$|E
2500|$|The [...] {{acts as the}} Controller. It accepts input via {{a single}} source (<b>HTTP</b> <b>GET</b> and POST), routes {{requests}} to the appropriate helper functions, pulls data out of the Abstraction (nodes and, from Drupal 5 onwards, forms), and then pushes it through a filter to get a Presentation of it (the theme system).|$|E
2500|$|In Semantic Web applications, and in {{relatively}} popular applications of RDF like RSS and FOAF (Friend of a Friend), resources {{tend to be}} represented by URIs that intentionally denote, {{and can be used}} to access, actual data on the World Wide Web. But RDF, in general, {{is not limited to the}} description of Internet-based resources. In fact, the URI that names a resource does not have to be dereferenceable at all. For example, a URI that begins with [...] "http:" [...] and is used as the subject of an RDF statement does not necessarily have to represent a resource that is accessible via HTTP, nor does it need to represent a tangible, network-accessible resource â€” such a URI could represent absolutely anything. However, there is broad agreement that a bare URI (without a # symbol) which returns a 300-level coded response when used in an <b>HTTP</b> <b>GET</b> request should be treated as denoting the internet resource that it succeeds in accessing.|$|E
5000|$|<b>HTTP</b> 1.1. <b>GET,</b> POST, PUT, DELETE, HEAD {{including}} file upload operations; ...|$|R
5000|$|Capture {{network traffic}} incoming/outgoing to/from eth0 {{interface}} and show parameters following <b>HTTP</b> (TCP/80) <b>GET</b> or POST methods ...|$|R
40|$|As part of {{the overall}} effort to {{understand}} implications of migrating ESDIS data and services to the cloud we are testing several common OPeNDAP and HDF use cases against three architectures for general performance and cost characteristics. The architectures include retrieving entire files, retrieving datasets using <b>HTTP</b> range <b>gets,</b> and retrieving elements of datasets (chunks) with <b>HTTP</b> range <b>gets.</b> We will describe these architectures and discuss our approach to estimating cost...|$|R
5000|$|A simple PURL {{works by}} {{responding}} to an <b>HTTP</b> <b>GET</b> request by returning a response of type 302 (equivalent to the HTTP status code 302, meaning [...] "Found"). The response contains an HTTP [...] "Location" [...] header, {{the value of}} which is a URL that the client should subsequently retrieve via a new <b>HTTP</b> <b>GET</b> request.|$|E
5000|$|Key/value pairs (encoded in <b>HTTP</b> <b>GET</b> query strings, {{to perform}} remote {{procedure}} calls) ...|$|E
5000|$|Sending email, ICQ and Windows Live Messages, FTP, <b>HTTP</b> <b>get</b> and TELNET client, ...|$|E
5000|$|... cURL [...] - [...] {{command line}} tool and library for {{transferring}} (including getting) data with URLs supporting {{a wide range}} of <b>http</b> methods (<b>GET,</b> POST, cookies, etc.) ...|$|R
5000|$|The client's {{user agent}} will {{translate}} {{it into a}} connection to [...] with the following <b>HTTP</b> 1.1 request: <b>GET</b> /path/file.html HTTP/1.1 ...|$|R
5000|$|SensorThings API {{defines the}} {{following}} resources. As SensorThings is a RESTful web service, each entity can be CREATE, READ, UPDATE, and DELETE with standard <b>HTTP</b> verbs (POST, <b>GET,</b> PATCH, and DELETE): ...|$|R
50|$|Wadja's API {{for sending}} text {{messages}} {{has been criticized}} for using <b>HTTP</b> <b>GET</b> instead of POST.|$|E
5000|$|Restful {{controllers}} {{provide an}} optional way for separating the logic behind serving <b>HTTP</b> <b>GET</b> and POST requests.|$|E
5000|$|LoadVars - A Load Variables object {{allows for}} the storing and send of HTTP POST and <b>HTTP</b> <b>GET</b> {{variables}} ...|$|E
5000|$|All items have {{a unique}} URI that <b>gets</b> exposed via <b>HTTP.</b> It uses the <b>HTTP</b> methods POST, <b>GET,</b> PUT and DELETE for the four basic CRUD (Create, Read, Update, Delete) {{operations}} on all resources.|$|R
50|$|The {{access layer}} in the WoT {{is built around}} two core patterns:Firstly, all things should be exposing their {{services}} through a RESTful API (either directly or through gateway). REST is an architectural style {{at the root of}} the programmable Web thanks to its implementation in HTTP 1.1. As a consequence, if things offer RESTful APIs over <b>HTTP,</b> they <b>get</b> a URL and become seamlessly integrated to the World Wide Web and its tools such as browsers, hyperlinked HTML pages and Javascript applications.|$|R
50|$|In {{the example}} flow above, all {{depicted}} exchanges are front-channel exchanges, that is, an HTTP user agent (browser) communicates with a SAML entity at each step. In particular, {{there are no}} back-channel exchanges or direct communications between the service provider and the identity provider. Front-channel exchanges lead to simple protocol flows where all messages are passed by value using a simple <b>HTTP</b> binding (<b>GET</b> or POST). Indeed, the flow outlined {{in the previous section}} is sometimes called the Lightweight Web Browser SSO Profile.|$|R
5000|$|GET/KVP: {{using the}} <b>HTTP</b> <b>GET</b> {{protocol}} for sending key-value pair (KVP) encoded requests and receiving XML metadata and binary coverage data.|$|E
50|$|Methods {{which are}} {{declared}} remote {{may also be}} invoked via an <b>HTTP</b> <b>GET</b> or POST request. Consider the GET request as shown.|$|E
5000|$|This will execute 100 <b>HTTP</b> <b>GET</b> requests, {{processing}} up to 10 requests concurrently, to {{the specified}} URL, in this example, [...] "".|$|E
30|$|Control Channel. This {{channel is}} {{conceived}} for the transmission/reception of configuration commands. By means of this channel the NC component periodically sends <b>GET</b> <b>HTTP</b> requests to the CCS {{in order to}} get the pending configuration commands. The frequency for this polling process is also a configurable parameter of the NC.|$|R
50|$|OutSight {{measured}} {{web application}} health from three perspectives: the end user (by passively monitoring <b>HTTP</b> connections); SNMP <b>GETs</b> to infrastructure components; and synthetic testing. The company continued to sell OutSight as a standalone offering until early 2004, and reduced its staff substantially {{as it got}} out of the application management business.|$|R
5000|$|WikipediaFS is {{implemented}} in Python {{and uses the}} FUSE kernel module. The file system works by lazily downloading and uploading article sourcetexts [...] - [...] only sending HTTP requests to the selected site when a file is accessed. (Reading a file corresponds to a <b>GET</b> <b>HTTP</b> request, writing to a POST HTTP request.) ...|$|R
50|$|A YubNub {{command is}} {{typically}} a one (1) to ten (10) letter abbreviation or word {{that corresponds to}} a web service via a <b>HTTP</b> <b>GET</b> request.|$|E
50|$|CookieCadger is a Java app that automates sidejacking and {{replay of}} {{insecure}} <b>HTTP</b> <b>GET</b> requests. Cookie Cadger helps identify information leakage from applications that utilize insecure <b>HTTP</b> <b>GET</b> requests. Web providers have started {{stepping up to}} the plate since Firesheep was released in 2010. Today, most major websites can provide SSL/TLS during all transactions, preventing cookie data from leaking over wired Ethernet or insecure Wi-Fi. Cookie Cadger is the first open-source pen-testing tool ever made for intercepting and replaying specific insecure <b>HTTP</b> <b>GET</b> requests into a browser. Cookie Cadger is a graphical utility which harnesses the power of the Wireshark suite and Java to provide a fully cross-platform, entirely open-source utility which can monitor wired Ethernet, insecure Wi-Fi, or load a packet capture file for offline analysis. Cookie Cadger has been used to highlight the weaknesses of youth team sharing sites such as Shutterfly (used by AYSO soccer league) and TeamSnap.|$|E
5000|$|... server side, page {{retrieving}} functions with no {{side effects}} (<b>http</b> <b>GET</b> method) are accessible through a URL as /ModulePath/functionName, {{they should have}} type (unit -> transaction page).|$|E
50|$|RESTHeart leverages MongoDB's document-oriented nature, {{creating}} an automatic mapping between MongoDB's internal {{storage of data}} and a graph of externally accessible HTTP resources, implementing a model of interaction compliant with an HATEOAS (Hypermedia as the Engine of Application State) representation, where the state of a client process is entirely driven by <b>HTTP</b> verbs like <b>GET,</b> POST, PUT, PATCH, DELETE, etc.|$|R
5000|$|... "Web resources" [...] {{were first}} defined on the World Wide Web as {{documents}} or files identified by their URLs, but today {{they have a}} much more generic and abstract definition encompassing every thing or entity that can be identified, named, addressed or handled, in any way whatsoever, on the Web. In a RESTful Web service, requests made to a resource's URI will elicit a response that may be in XML, HTML, JSON or some other defined format. The response may confirm that some alteration has been made to the stored resource, and it may provide hypertext links to other related resources or collections of resources. Using HTTP, as is most common, the kind of operations available include those predefined by the <b>HTTP</b> verbs <b>GET,</b> POST, PUT, DELETE and so on.|$|R
40|$|Sensor {{networks}} {{are seen as}} {{an important part in}} emerging office and building energy management system, but the integration of sensor networks with future energy management systems is still an open problem. We present an IP-based sensor network system where nodes communicate their information using Web services, allowing direct integration in modern IT systems. Our system uses two mechanisms to provide a good performance and low-power operation: a session-aware power-saving radio protocol {{and the use of the}} <b>HTTP</b> Conditional <b>GET</b> mechanism. We perform an extensive evaluation of our system and show that Web services are a viable mechanism for use in low-power sensor networks. Our results show that Web service requests can be completed well below one second and with a low power consumption, even in a multi-hop setting...|$|R
50|$|An Alpha release REST API, at a {{very early}} stage of development, {{supported}} <b>HTTP</b> <b>GET</b> requests for content that was either public, or shared through a keyed hyperlink.|$|E
50|$|Simplest is if {{the stream}} is served by simply {{requesting}} it, just as web pages are, as in an <b>HTTP</b> <b>GET</b> request: this will directly copy the encoded, streamed file.|$|E
5000|$|XmlHttpRequest (in Elm's Http.send) {{requires}} server side authorization headers [...] for <b>Http</b> <b>GET</b> {{and extra}} [...] for Http POST. Url encoding of requests is implemented in a third-party library named elm_CodecURI.|$|E
50|$|SensorThings API {{provides}} {{two main}} functionalities, each handled by a profile. The two profiles are the Sensing profile and the Tasking profile. The Sensing profile provides a standard way {{to manage and}} retrieve observations and metadata from heterogeneous IoT sensor systems, and the Sensing profile functions {{are similar to the}} OGC Sensor Observation Service. The Tasking profile provides a standard way for parameterizing - also called tasking - of task-able IoT devices, such as sensors or actuators. The Tasking profile functions are similar to the OGC Sensor Planning Service. The Sensing profile is designed based on the ISO/OGC Observations and Measurements (O&M) model, and allows IoT devices and applications to CREATE, READ, UPDATE, and DELETE (i.e., <b>HTTP</b> POST, <b>GET,</b> PATCH, and DELETE) IoT data and metadata in a SensorThings service.|$|R
50|$|Gentoox uses a {{modified}} version of the Xbox-Linux BIOS known as Cromwell. Gentoox Loader has advanced features such as the ability to flash the Xbox's BIOS via HTTP POST and even the ability to boot a Linux kernel via <b>HTTP</b> POST or <b>GET.</b> Gentoox compiles all new software, safely optimizing it for the Xbox's architecture. While this may increase the performance of the compilation output, it means that installing new software can take large amounts of time (e.g. compiling open office takes around 24 hours).|$|R
5000|$|As per the {{semantics}} {{defined in}} the <b>HTTP</b> protocol, the <b>GET,</b> PUT, POST, DELETE methods {{need to use a}} full representation of the resource. The PUT method which can be used for resource creation or replacement is idempotent and can be used only for full updates. The edit forms used in conventional Ruby on Rails application need to create new resources by applying partial updates to a parent resource. Due to this requirement, the PATCH method was added to the HTTP protocol in 2010 (RFC 5789).|$|R
